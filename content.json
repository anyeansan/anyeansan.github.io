{"meta":{"title":"安₃","subtitle":"我未成名君未嫁 可能俱是不如人","description":"一蓑烟雨任平生","author":"安₃","url":"https://anyeansan.github.io","root":"/anyeansan.github.io/"},"pages":[{"title":"categories","date":"2019-11-12T04:47:40.000Z","updated":"2019-11-12T04:48:21.027Z","comments":true,"path":"categories/index.html","permalink":"https://anyeansan.github.io/categories/","excerpt":"","text":""},{"title":"tags","date":"2019-11-12T04:46:04.000Z","updated":"2019-11-12T04:47:01.286Z","comments":true,"path":"tags/index.html","permalink":"https://anyeansan.github.io/tags/","excerpt":"","text":""}],"posts":[{"title":"Javascript 异步","slug":"Javascript-异步","date":"2020-03-30T14:33:35.000Z","updated":"2020-03-30T14:35:57.727Z","comments":true,"path":"2020/03/30/Javascript-异步/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/Javascript-%E5%BC%82%E6%AD%A5/","excerpt":"","text":"一 概述1.1 JavaScript是单线程的。 注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合 1.2 同步任务和异步任务 同步任务 在主线程上排队执行的任务。 只有前一个任务执行完毕，才能执行后一个任务 异步任务 不进入主线程而进入任务队列的任务 只有引擎认为某个异步任务可以执行了，该任务才会进入主线程执行 异步任务不具有“堵塞”效应，即异步任务后的代码不用等待异步任务结束。 1.3 任务队列和事件循环 任务队列（task queue） JavaScript 运行时，除了一个正在运行的主线程，引擎还提供任务队列，里面是各种需要当前程序处理的异步任务。（根据异步任务的类型，可以存在多个任务队列。） 事件循环（Event Loop） 同步任务执行完毕后，引擎会在任务队列循环检查，如果有可以执行的异步任务，则结束等待状态，进入主线程开始执行。 执行步骤 首先，主线程会去执行所有的同步任务，异步任务会进入任务队列。 同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。 直到任务队列清空，程序结束执行。 1.4 异步操作模式 回调函数callback 定时器，ajax…… 缺点 高耦合，维护困难，回调地狱，当多个异步任务多级依赖时，回调函数会形成多级嵌套 每个任务只能指定一个回调函数 如果多个异步操作没有顺序之分，同样需要等待上一个操作执行结束再进行下一个操作 事件监听 发布/订阅 promise generators async/await 二 promise2.1 概述 Promise 对象本质上表示的是一系列操作的中间状态，或者说是未来某时刻一个操作完成或失败后返回的结果。 Promise 的回调函数不是正常的异步任务（宏任务），而是微任务（microtask） 正常异步任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常异步任务 2.2 promise 状态1 三种状态 pending ：初始状态，初始化 promise 时的状态 fulfilled：异步操作成功 rejected：异步操作失败 2 说明 fulfilled 和 rejected 统称 settled resolved promise 已经 settled promise 已经使用另一个promise（B）来resolve 此时promise的状态由B来决定，可能是pending fulfilled rejected 的任何一种 unresolved &amp; resolved unresolved ：promise的状态只能是pending resolved：promise的状态可能是pending、fulfilled、rejected 的任何一种 2.3 Promise API1 构造函数12345new Promise(executor)// executorfunction(resolve, reject) &#123;&#125;// 或(resolve, reject) =&gt; &#123;&#125; executor 指带有 resolve 和 reject 两个参数的函数 Promise构造函数执行时立即调用executor 函数 resolve 和 reject 是JavaScript 提供提供的两个函数 resolve被调用时，将promise的状态改为fulfilled reject被调用时，将promise的状态改为rejected 如果executor内部出错，将promise的状态改为rejected，且忽略executor返回值 2 静态方法 Promise.resolve(value) 返回一个以给定值解析后的Promise 对象。 value 如果该value值为promise，返回这个promise； 如果该value值是thenable（即带有”then” 方法），会将thenable对象包装为promise并返回; 否则，返回的promise将以此value值完成，即此promise的成功值是value，也就是then方法中第一个函数的参数。 Promise.reject(reason) 返回一个带有拒绝原因的Promise对象 reason 拒绝的原因，通常是一个Error对象，也就是then方法中第二个函数的参数 Promise.all(iterable) // TODO 注：iterable中非promise元素会被转为promise 如果参数是一个空的可迭代对象 返回一个已完成（already resolved）的 Promise。 此promise会调用成功回调函数，成功值是空数组1234Promis.all([]).then( value =&gt; console.log(value), // [] reason =&gt; console.log(reason)); 如果iterable参数不包含任何 promise 返回一个异步完成（asynchronously resolved） Promise 此promise会调用成功回调函数，成功值是由参数的元素构成的数组1234Promis.all(&quot;abc&quot;).then( value =&gt; console.log(value), // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;] reason =&gt; console.log(reason)); 其它情况下返回一个处理中（pending）的Promise 如果iterable参数中包含的所有promise都成功，则此返回的promise调用成功函数，成功值为一个数组，数组元素为所有promise的成功值和非promise的值1234567const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&apos;p1-success&apos;);&#125;);Promis.all([p1, 3, 4, &apos;abc&apos;]).then( value =&gt; console.log(value), // [&apos;p1-success&apos;,3,4,&apos;abc&apos;] reason =&gt; console.log(reason)); 如果iterable参数中 包含的promise 有一个失败，则此返回的promise调用失败函数，失败原因是第一个失败的promise的原因1234567const p1 = new Promise((resolve, reject) =&gt; &#123; reject(&apos;p1-fail&apos;);&#125;);Promis.all([p1, 3, 4, &apos;abc&apos;]).then( value =&gt; console.log(value), reason =&gt; console.log(reason) // p1-fail); Promise.allSettled(iterable) 返回一个fulfilled状态的promise，成功值为一个对象数组，每个对象包含两个属性，表示对应的iterable元素的结果12&#123;status: &quot;fulfilled&quot;, value: ...&#125;&#123;status: &quot;rejected&quot;, reason: ...&#125; Promise.race(iterable) 返回一个promise，此返回promise的状态取决于iterable参数中promise 成功/失败的最快的那个。 3 原型方法1 then1 语法1234567then(onFulfilled[, onRejected])then(value =&gt; &#123; // fulfillment&#125;, reason =&gt; &#123; // rejection&#125;) 2 参数 onFulfilled ，可选 当 Promise 变成fulfilled状态时调用的函数，参数为 fulfillment value，表示成功的值 如果onFulfilled不是一个函数，会被忽略，内部变成(value) =&gt; value，即将fulfillment value原样返回 onRejected，可选 当 Promise 变成rejected状态时调用的函数，参数为rejection reason，表示失败原因 如果onRejected不是函数，则会在内部被替换为一个 “Thrower” 函数，抛出失败原因 3 返回值 如果then没有参数，或者要执行的回调函数对应的参数不是一个函数，则返回的promise与原promise状态相同，且成功值和失败原因也相同。 如果then没有返回值，则返回的promise，状态为fulfilled，成功值为undefined 如果then返回一个值，则返回的promise，状态为fulfilled，成功值为返回的值 如果then抛出错误，则返回的promise，状态为rejected，失败原因为抛出的错误 如果then返回一个promise（三种状态都有可能），则可以当作是最终返回的promise，即状态，成功值或者失败原因都是一样的 内部返回值 最终返回promise状态 成功的值 失败原因 错误 rejected - 错误 无 fulfilled undefined - 非promise的值 fulfilled 非promise的值 - promise值 同promise值 同promise值 同promise值 2 catch1234catch(onRejected)catch(reason =&gt; &#123;&#125;) 等同于 then(undefined, onRejected) catch之前任一promise状态变为rejected，如果此promise自己没有处理，则会被catch捕获 catch返回一个promise，其状态取决于catch内部onRejected函数 如果onRejected返回一个rejected状态的Promise或着抛出一个错误，则catch返回的promise状态为rejected 否则，catch返回的promise状态为fulfilled 3 finally1234finally(onFinally)finally(() =&gt; &#123;&#125;) onFinally Promise 结束后，无论结果是fulfilled或者是rejected，都会执行onFinally回调函数 返回一个设置了 finally 回调函数的Promise对象 三 async / await3.1 概述 async/await 是promise 的语法糖 async用来声明一个异步函数（async function），await操作符只能用在异步函数中 3.2 async1234567891011async function show()&#123;&#125;let show = async function()&#123;&#125;let obj = &#123; async show()&#123;&#125;&#125;class xxx&#123; async show() &#123;&#125;&#125; 异步函数返回一个promise 如果异步函数正常执行，则返回的promise会调用成功函数，成功值为异步函数内部返回值。 如果异步函数抛出异常，则返回的promise会调用失败函数，失败原因是抛出异常 错误处理 async返回一个promise，可以调用catch来处理错误 3.3 await1[return_value] = await expression; await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成 如果表达式是一个promise，则返回值为promise的处理结果 如果表达式不是一个promise，则返回该值本身 错误处理 await后边的promise出错，相当于async函数返回的promise为reject，所以可以在外部调用catch方法处理 可以在内部用try…catch…处理 await的并行 让promise先执行后再使用await处理结果 使用 Promise.all() 处理多个promise并行执行","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"Javascript","slug":"UI/Javascript","permalink":"https://anyeansan.github.io/categories/UI/Javascript/"}],"tags":[]},{"title":"Javascript 模块化","slug":"Javascript-模块化","date":"2020-03-30T14:31:03.000Z","updated":"2020-03-30T14:33:19.695Z","comments":true,"path":"2020/03/30/Javascript-模块化/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/Javascript-%E6%A8%A1%E5%9D%97%E5%8C%96/","excerpt":"","text":"一 网上概述网上概述 二 概述 模块就是一个独立的文件，文件内部的变量，函数，类…外部无法获取 使用模块可以解决全局变量冲突 模块需要隐藏内部实现，只对外开发接口 模块可以避免滥用全局变量，造成代码不可控 模块可以被不同的应用使用，提高编码效率 模块默认运行在严格模式 模块都有独立的顶级作用域，不同模块间不能相互访问，类似函数作用域 模块在导入时只执行一次解析，之后的导入不会再执行模块代码，而使用第一次解析结果，并共享数据 三 加载1&lt;script type=&quot;module&quot;&gt;&lt;/script&gt; 异步加载，即模块总是会在所有html解析后才执行 四 export4.1 概述 模块中的功能默认外部无法使用，使用export命令规定模块的对面接口，即将指定功能导出供外部使用。 4.2 导出单个 export 声明语句1234export let name = &apos;xiaoqiang&apos;;export let obj = &#123;&#125;;export function show() &#123;&#125;;export class User &#123;&#125; 4.3 导出列表 export { name1, name2, …, nameN };12345export let name = &apos;xiaoqiang&apos;;export let obj = &#123;&#125;;export function show() &#123;&#125;;export class User &#123;&#125;export &#123;name, obj, show, User&#125;; 4.4 别名 export { variable1 as name1, variable2 as name2, …, nameN }; 4.5 默认导出1234export default expression;export default function (…) &#123; … &#125; // also class, function*export default function name1(…) &#123; … &#125; // also class, function*export &#123; name1 as default, … &#125;; 默认导出接口只能有一个，但默认导出可以与普通导出共存 本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字 默认导出时，函数和类可以具名也可以匿名，变量不能具名1234export default let a = 1; // 错误let a = 1;export default a; // 正确，相当于把a的值赋予defaultexport default 1; // 正确，相当于直接把值赋予default 五 import（静态导入）5.1 概述 import用于导入其它模块提供的功能。 import导入的变量名要与export导出的一致 import导入的变量是只读的 import命令具有提升效果，会提升到整个模块的头部，首先执行 import是静态导入，不能使用表达式和变量 在浏览器中引用模块必须添加路径，但在打包工具如webpack中则不需要，因为他们有自己的存放方式。 5.2 导入所有导出接口 import * as name from &quot;module-name&quot;; name 导入模块的命名空间 module-name 要导入的模块。通常是包含目标模块的.js文件的相对或绝对路径名，可以不包括.js扩展名。 使用default获取默认导出 5.3 导入指定导出接口 import { export1, export2, ..., exportN } from &quot;module-name&quot;; 5.4 别名 import { export1 as alias1, export2, ..., exportN } from &quot;module-name&quot;; 5.5 导入默认导出 import defaultExport from &quot;module-name&quot;; 导入默认导出时名称任意 由于默认导出只有一个，所以不需要{} 5.6 混合导入 import defaultExport, { export1, export2, ..., exportN} from &quot;module-name&quot;; 六 export default6.1 概述 使用import命令时，需要知道export导出的变量名。 export default 本质是导出一个名为defualt的变量，使用import导入时可以以任意名称导入。 一个模块只能有一个默认输出，可以与普通导出共存 6.2 语法 export default expression 将expression表达式的值赋给default导出1234let a = 1;export default a; // 将a的值1赋给defaultexport default 1; // 将1赋给defaultexport default let a = 1; // 错误 因为let a = 1不能计算出一个值 export default function(){} // also class, function* 导出匿名函数/类，名称为default export default function name(…) { … } // also class, function* 导出具名函数/类，名称为default，原有名称会被忽略 export { name1 as default, … }; 由于 export default 本质是导出一个名为default的变量 可以使用export导出一个别名为default的变量 七 export + import7.1 概述 可以将导入的模块再次导出 如果export和import结合在一起，其实就相当于一个转发，并没有导入到当前模块，即当前模块不能使用导入导出的功能。 7.2 语法1234export * from …;export &#123; name1, name2, …, nameN &#125; from …;export &#123; import1 as name1, import2 as name2, …, nameN &#125; from …;export &#123; default &#125; from …; 八 import()（动态导入） 接收参数与静态导入一致 使用import() 函数可以动态导入模块，它返回一个 promise 对象，可以按需加载 import() 函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块 九 打包工具 webpack","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"Javascript","slug":"UI/Javascript","permalink":"https://anyeansan.github.io/categories/UI/Javascript/"}],"tags":[]},{"title":"Javascript Class","slug":"Javascript-Class","date":"2020-03-30T14:28:26.000Z","updated":"2020-03-30T14:30:42.011Z","comments":true,"path":"2020/03/30/Javascript-Class/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/Javascript-Class/","excerpt":"","text":"一 概述 JavaScript 中，生成实例对象的传统方法是通过构造函数 为了和其他语言继承形态一致，JS提供了class 关键词用于模拟传统的class ，但底层实现机制依然是原型继承 class 只是语法糖，为了让类的声明与继承更加简洁清晰 class 其实就是函数，typeof 类返回function class 内部代码始终以严格模式执行 class 不存在变量提升 class 中的属性名可以采用表达式[] class 中定义的属性都是实例属性，定义的方法都是原型方法且不可枚举 二 语法 类声明1class 类名 &#123;&#125; 类表达式1let 类名= class&#123;&#125; 三 构造函数 constructor123456// 基类默认构造函数constructor() &#123;&#125;// 派生类默认构造函数constructor(...args) &#123; super(...args);&#125; 使用类new一个对象时会自动调用构造函数 如果省略，则会有默认构造函数 constructor 默认返回实例对象（即this），可以改为返回另一个对象 类的原型的constructor属性指向类本身 类.prototype.constructor = 类 四 属性 &amp; 方法4.1 实例属性 旧：使用this. 定义在constructor中 新：在类中直接定义的属性就是实例属性 123456class User &#123; name = &apos;haha&apos;; constructor(age) &#123; this.age = age; &#125;&#125; 4.2 原型方法 旧：在类的原型上定义方法，是可以枚举的 新：在类中直接定义的方法就是原型方法，且不可枚举（non-enumerable） 1234class User &#123; show()&#123;&#125;&#125;User.prototype.show = function()&#123;&#125; 4.3 静态属性/方法 定义在类上 在类中定义的属性/方法前加static关键字 123456class User &#123; static age = 10; static show() &#123;&#125;&#125;User.age = 10;User.show() = function()&#123;&#125;; 注意：如果静态方法包含this关键字，这个this指的是类本身，而不是实例对象 4.4 私有属性 / 方法 私有属性：在属性名前加 # 私有方法：以表达式形式定义方法并在方法前加# ，可以理解为就是定义私有属性，不过属性的值是一个函数 1234class User &#123; #phone = &apos;13800000000&apos;; // 私有属性 #say = function() &#123;&#125; &#125; 4.5 受保护属性 / 方法 在属性/方法名前加 _，这只是约定不是语法，不是规范 可以通过symbol weakmap ... 人为实现保护 五 访问器 getter/setter 类中同样可以使用访问器，且访问器也是定义在属性的属性描述符上 六 class的继承6.1 extends123456789class Fu &#123; constructor() &#123; &#125;&#125;class Zi extends Fu &#123; constructor() &#123; super(); &#125;&#125; 子类构造函数第一行必须先调用父类构造函数 class的继承做了两件事 与ES5的 继承一样 在子类构造函数中调用父类构造 子类的原型对象的原型指向父类的原型对象 子类.__proto__ = 父类 用于继承静态属性/方法 6.2 super1 问题 子 父：在子类中调用父类方法 子：this.__proto__.__proto__ this代表子类实例，this.__proto__.__proto__就代表父类原型，就可以调用到父类的方法。 子 父 爷：在子类中调用父类方法，父类方法中又调用了父类的父类的方法 子：this.__proto__.__proto__ 父：this.__proto__ 因为子类中调用父类方法的是父类原型对象，所以父类中的this代表的是父类原型，所以用this.__proto__获取爷爷的原型，就可以调用爷爷的方法 父 爷 父：this.__proto__.__proto__ 如果直接使用父类调用爷爷的方法，此时父类就是子，爷爷就是父类，就跟1子 父是一样的。 父类扮演不同角色时，代码是矛盾的。 如果只有双层继承，使用this是可以的，如果有多重继承，是行不通的。 使用call/apply指定this，在多重继承中也是行不通的。 2 用法 super 只能在类或对象的方法中使用，而不能在函数中使用 使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。 console.log(super) 无法看出是函数还是对象，错误 11super([arguments]); 调用 父对象/父类 的构造函数 此时super代表父对象/父类的构造函数 21super.functionOnParent([arguments]); 调用 父对象/父类 上的方法 此时super代表父类原型对象 如果是静态方法则super代表父类本身 3 原生构造函数的继承 之前，这些内置的构造函数如Object() Array() ... 是无法继承的 ES6 允许继承 4 mixin 创建一个mixin类，包含许多供其它类使用的方法 将mixin类 合并到要使用功能的类的原型上","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"Javascript","slug":"UI/Javascript","permalink":"https://anyeansan.github.io/categories/UI/Javascript/"}],"tags":[]},{"title":"Javascript 继承和原型","slug":"Javascript-继承和原型","date":"2020-03-30T14:24:38.000Z","updated":"2020-03-30T14:28:12.696Z","comments":true,"path":"2020/03/30/Javascript-继承和原型/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/Javascript-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B/","excerpt":"","text":"一 原型 1.1 原型链 对象有自己的原型对象，而原型对象也是对象，所以原型对象也有自己的原型对象，就会形成一个“原型链”（prototype chain） 对象有自己的原型对象，而对象又可以充当其他对象的原型； 1.2 __proto__ 是浏览器实现的非JavaScript标准的属性，在ES6写入了附录，用于获取或设置对象的原型 obj.__proto__ 并非是普通的属性访问方式，而是通过getter/setter访问器 __proto__理解为prototype 属性的 getter/setter 实现 每个对象都有__proto__属性，指向它的构造函数的原型对象，即如果A对象是由B函数构造的，则 A.__proto__ === B.prototype 普通对象的构造函数是其对应的构造函数，则对象.__proto__ === 构造函数.prototype 函数（包括Function自身）的构造函数是Function，则 函数.__proto__ === Function.prototype 原型对象默认的构造函数是Object，则原型对象.__proto__ === Object.prototype 原型对象中Object.prototype比较特殊，它是原型链的顶端，Object.prototype.__proto__ === null 由于非标准，浏览器有这个属性，其它环境未必有。建议使用Object中的方法 替代__proto__ Object.getPrototypeOf(obj) Object.setPrototypeOf(obj, prototype) Object.create(proto[, propertiesObject]) 1.3 prototype 函数作为对象有__proto__，又可以作为构造函数有prototype 每个函数都有一个prototype属性，指向函数的原型对象，且函数的原型对象是普通对象。 Function.prototype是个例外 它是Function函数的原型对象但它是个函数对象 它是函数对象但是没有prototype属性 实例对象的__proto__和其构造函数的prototype都指向构造函数的原型对象 prototype的作用是让该函数所实例化的对象们都可以找到公用的属性和方法，即js的继承是通过prototype实现的 4 constructor 只有原型对象才有constructor属性，此属性指向函数本身，即 函数.prototype.constructor = 函数 实例对象.__proto__.constructor = 函数 二 new2.1 new的执行过程 创建一个空对象 let obj = {}; 将新建对象的__proto__指向构造函数的原型对象，obj.__proto__ = 构造函数.prototype 将新建对象作为构造函数执行的上下文，即将构造函数内部的this指向新建对象 执行构造函数，如果构造函数没有返回引用类型的值，则返回新建对象 2.2 自定义new1234567let myNew = function(cons, args) &#123; let obj = &#123;&#125;; // 步骤1 obj.__proto__ = cons.prototype; // 步骤2 // let obj = Object.create(cons.prototype); 步骤1，2合在一起 let result = cons.apply(obj, args); // 步骤3 return result instanceof Object ? result : obj; // 步骤4&#125;; 2.3 new.target 属性 用来检测函数是否通过new或者Reflect.construct()调用的 如果在普通函数中使用，返回undefined 在构造函数中使用指向被new调用的构造函数 在class的constructor函数中使用指向被new调用的class 三 构造函数中的属性和方法12345678910function User(name) &#123; let age = 18; // 私有属性 let test = function()&#123;&#125;; // 私有方法 this.name = name; // 实例属性 this.show = function()&#123;&#125;// 实例方法&#125;User.country = &apos;中国&apos;; // 静态属性User.sayHello = function()&#123;&#125;; // 静态方法User.prototype.gender = &apos;男&apos;; // 原型属性User.prototype.change = function()&#123;&#125;; // 原型方法 私有实例属性 / 方法（private） 在构造函数内部使用var/let/const声明的属性/方法 公有实例属性 / 方法（public） 在构造函数内部使用this.声明的属性/方法 静态属性 / 方法（static） 定义在构造函数上的属性/方法 原型属性 / 方法（prototype） 定义在构造函数原型上的属性/方法 ，原型方法默认可枚举 四 继承4.1 设置原型方式 设置构造函数原型，使用函数的prototype属性 设置对象的原型 Object.create(proto[, propertiesObject]) 创建对象时指定原型（只是定义无法获取） 使用对象的属性__proto__ 获取或设置原型，在浏览器之外的环境可能不行。 Object的方法，与__proto__效果一样，但是是js标准 Object.getPrototypeOf(obj) 获取对象的原型，即__proto__ Object.setPrototypeOf(obj, prototype) 设置对象的原型 4.2 继承原理 将子类构造函数的原型对象的原型指向父类构造函数的原型对象 4.3 实现继承的方式1 原型链-1 1A.prototype.__proto__ = B.prototype; 将子类构造函数的原型对象的原型直接指向父类构造函数的原型 好处 父类原型在子类原型链上，则子类可以继承父类的原型属性/方法 弊端 创建子类时不会调用父类构造函数，无法继承父类的实例属性/方法 2 构造函数 在子类构造函数中通过call/apply调用父类构造函数，并指定this为子类对象12345678910function Fu(name, age) &#123; this.name = name; this.age = age; this.show = function()&#123;&#125;;&#125;;function Zi(name, age) &#123; Fu(name,age); // 不行，因为直接调用时，父类构造函数this是指向window的 Fu.call(this, name, age); Fu.apply(this, [name, age])&#125; 好处 创建的子类实例具备父类实例属性/方法 弊端 只是子类的实例，不是父类的实例（只是通过调用父类构造函数模拟继承） 无法继承父类原型属性/方法 3 原型链-2 1A.prototype = new B(); 将子类构造函数的原型对象修改为一个父类实例（舍弃原有原型对象） 好处 父类实例对象具有父类的实例属性/方法，父类实例对象的原型又指向父类构造函数原型，所以父类的实例属性/方法 和 原型属性/方法，子类都可以继承 弊端 父类的实例属性/方法是在子类原型对象上，这就导致父类的实例属性/方法实际上变成了子类的原型属性/方法。 需要手动为新的子类原型对象添加 constructor属性 1 对新增对象的影响 如果新增对象在修改原型操作之前，那就意味着，新增对象指向的原型还是原来被舍弃的原型，所以这种方式只对修改原型操作之后新增的对象有效 2 对constructor的影响 由于这种方式是将子类原型修改成了一个新的对象，而这个新对象中是没有constructor属性的，所以需要手动为新对象添加constructor属性，并指向子类构造函数 直接添加1A.prototype.constructor = A; 直接添加的方式有一个弊端，就是constructor属性默认可遍历 使用Object的defineProperty() 添加1234Object.defineProperty(A.prototype, &quot;constructor&quot;, &#123; value: A, enumerable: false&#125;); 4 组合继承1（构造函数+原型链2）1234567891011function B(name) &#123; this.name = name;&#125;B.prototype.gender = &apos;nan&apos;;B.prototype.eat = function() &#123;&#125;;function A(age) &#123; B.call(this, &apos;小猫&apos;); // 第一次调用 this.age = age;&#125;A.prototype = new B(&apos;小狗&apos;); // 第二次调用A.prototype.constructor = A; 好处 通过构造函数方式可以继承到父类的实例属性/方法 通过原型链方式可以继承到父类的原型属性/方法 弊端 父类的实例属性会在子类实例和子类原型上都定义一份，不过不影响，因为会先使用实例自己的属性 会调用两次父类构造函数 需要手动为新的子类原型对象添加 constructor属性 5 组合继承2（构造函数+原型链1）12345678910function B(name) &#123; this.name = name;&#125;B.prototype.gender = &apos;nan&apos;;B.prototype.eat = function() &#123;&#125;;function A(age) &#123; B.call(this, &apos;小猫&apos;); this.age = age;&#125;A.prototype.__proto__ = B.prototype 好处 通过构造函数方式可以继承到父类的实例属性/方法 通过原型链方式可以继承到父类的原型属性/方法 弊端 __proto__ 在浏览器之外的环境可能不行。 6 最终方式1234567891011121314function B(name) &#123; this.name = name;&#125;B.prototype.gender = &apos;nan&apos;;B.prototype.eat = function() &#123;&#125;;function A(age) &#123; B.call(this, &apos;小猫&apos;); this.age = age;&#125;A.prototype = Object.create(B.prototype);Object.defineProperty(A.prototype, &quot;constructor&quot;, &#123; value: A, enumerable: false&#125;); 将__proto__ 方式改为Object.create() A.prototype = Object.create(B.prototype); 以父类的原型创建一个对象作为子类原型对象，此新建对象没有调用父类构造函数，没有父类实例属性/方法 4.4 对象工厂12345678function Fu(name)&#123; this.name = name;&#125;function createObj(...args) &#123; const obj = Object.create(Fu.prototype); Fu.call(obj, ...args); //通过调用父类 return obj;&#125; 与继承方式类似，只是通过对象工厂创建子类对象，不需要子类构造函数 创建一个以父类原型为原型的对象，相当于继承了父类原型属性/方法 调用父类构造函数，并设置this为新建对象，即相当于继承了父类实例属性 返回新建对象 4.5 静态属性/方法的继承 静态属性/方法即在构造函数上定义的属性/方法，继承原理都是一样的，函数也是对象，把子类构造函数看作对象，设置其原型为父类构造函数，即可继承静态属性/方法1234567function Fu() &#123;&#125;Fu.haha = &quot;wangcai&quot;;Fu.show = function() &#123; console.log(&apos;fu static show&apos;)&#125;function Zi() &#123;&#125;Zi.__proto__ = Fu; 4.6 多继承 js不支持多继承，也没有接口实现，如果要使用多个类的方法时可以使用mixin混合模式来完成 Mixin模式 Mixin模式 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口 mixin 可以看作是一个包含许多功能的对象，使用时将这些功能合并到要使用功能的对象原型上即可 例12345678910let myMix = &#123; sayHi() &#123;&#125;, sayBye() &#123;&#125;, eat()&#123;&#125;&#125;;function User() &#123;&#125;// 合并之后，User的实例就有了myMix的功能了Object.assign(User.prototype, myMix);// 手动添加某个功能User.prototype.eat = myHix.eat;","categories":[{"name":"父","slug":"父","permalink":"https://anyeansan.github.io/categories/%E7%88%B6/"},{"name":"子","slug":"父/子","permalink":"https://anyeansan.github.io/categories/%E7%88%B6/%E5%AD%90/"}],"tags":[]},{"title":"Javascript 闭包","slug":"Javascript-闭包","date":"2020-03-30T14:24:25.000Z","updated":"2020-03-30T14:24:50.663Z","comments":true,"path":"2020/03/30/Javascript-闭包/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/Javascript-%E9%97%AD%E5%8C%85/","excerpt":"","text":"一 概述 通常情况下，函数执行时（入栈）创建一个单独的作用域，函数执行完毕（弹栈），此作用域销毁，函数内部的变量也就销毁了，无法再访问。 闭包则会添加一个对函数的引用，使得函数作用域一直保存到闭包不存在为止。 二 概念及现象 闭包是由函数以及创建该函数的词法环境组合而成。在此词法环境外调用函数时，可以访问到词法环境中的变量。 通俗来说就是： 有一个单独的作用域，此作用域中定义一个函数，则这个函数与它能在此作用域中所有能访问的变量构成了闭包。 在此作用域外调用函数时，函数能够使用作用域中的变量。 三 如何形成闭包3.1 条件 单独的作用域：为了创建局部变量 内部定义一个函数：形成闭包 将函数暴漏给外部：为了能在外部访问到函数 3.2 方式 函数嵌套 外部函数是一个单独的函数作用域 定义一个内部函数，此内部函数与外部函数中的变量构成了闭包 把内部函数return, 或者添加到window对象上，暴漏给外部。 12345678function outer() &#123; let i = 0; return function() &#123; console.log(i++); &#125;&#125;let inner = outer(); inner(); // 外部函数执行完毕后，依然可以访问到外部函数中的变量","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"Javascript","slug":"UI/Javascript","permalink":"https://anyeansan.github.io/categories/UI/Javascript/"}],"tags":[]},{"title":"Javascript 引用数据类型","slug":"Javascript-引用数据类型","date":"2020-03-30T14:13:52.000Z","updated":"2020-03-30T14:21:56.687Z","comments":true,"path":"2020/03/30/Javascript-引用数据类型/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/Javascript-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"一 属性描述符1.1 概述 JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为属性描述符（property descriptor），或者叫属性描述对象 属性描述符有两种主要形式，且只能取其一 数据描述符可以具有的属性 configurable enumerable value writable 存取描述符可以具有的属性 configurable enumerable get set 1.2 元属性（属性描述对象中用来描述属性元信息的属性） 元属性 说明 默认值 value 表示该属性的值 undefined writable 表示该属性是否可写 true enumerable 表示该属性是否可遍历 true configurable 1 该属性是否可删除2 该属性的属性描述符是否可修改 true get 表示该属性的取值函数getter undefined set 表示该属性的存值函数setter undefined 二 对象2.1 Object1 构造函数 Object([value]) 普通函数，作用是类型转换，将value转成一个对象 用法与构造函数相同，只是语义上的区别 new Object([value]) 构造函数，创建一个对象，值为value转成的对象 如果参数value 为空或者是undefined null，返回一个空对象 是基本类型的值则返回其包装对象 是引用类型则直接返回 2 静态方法1 获取 Object.keys(obj) 返回对象自身可枚举属性键的数组 Object.values(obj) 返回对象自身可枚举属性值的数组 Object.entries(obj) 返回对象自身可枚举属性键值对的数组 以上三个方法与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性） Object.getOwnPropertyNames(obj) 返回对象自身的所有属性（包含可枚举和不可枚举属性，不包含Symbol属性）键的数组 Object.getOwnPropertySymbols(obj) 返回对象自身的所有 Symbol 属性的数组 2 属性描述符 Object.getOwnPropertyDescriptor(obj, prop) 获取对象自身某个属性的属性描述对象 Object.getOwnPropertyDescriptors(obj) 获取对象自身所有属性的属性描述对像 Object.defineProperty(obj, prop, descriptor) 如果对象自身存在指定属性，则修改它的属性描述对象，否则为对象添加指定属性并定义属性描述对象。返回该对象 通过这种方式定义属性描述法时的默认值 configurable enumerable writable 均为false value get set 均为undefined Object.defineProperties(obj, props) 修改或添加对象多个属性的属性描述对象，返回该对象 3 创建对象 Object.create(proto[, propertiesObject]) 指定原型对象和属性（使用属性描述符定义），返回一个新的对象 propertiesObject 同 Object.defineProperties(obj, props) 的props Object.assign(target, ...sources) 将一个或多个源对象的所有可枚举属性复制到目标对象。并返回目标对象 如果目标对象与源对象有同名属性，或多个源对象有同名属性，后边覆盖前边 Object.assign 方法实行的是浅拷贝 数组会被当作对象，即相同索引会覆盖 如果属性值是取值函数，会计算后再复制 Object.fromEntries(iterable) 把键值对列表转换为一个对象 是 Object.entries() 的反转 4 原型 Object.getPrototypeOf(obj) 获取对象的Prototype对象，即__proto__ Object.setPrototypeOf(obj, prototype) 修改对象的prototype对象 5 状态 Object.preventExtensions(obj) 让一个对象变的不可扩展，也就是永远不能再添加新的属性 Object.isExtensible(obj) 判断一个对象是否可扩展 Object.seal(obj) 封闭一个对象，此对象不可扩展且对象所有自身属性configurable标记为false 不能添加、删除属性，属性修饰符不可配置 Object.isSealed(obj) 判断一个对象是否被封闭 Object.freeze(obj) 冻结一个对象，此对象不可扩展且对象所有自身属性 writable configurable 标记为false 不能添加、修改和删除属性，属性修饰符不可配置 Object.isFrozen(obj) 判断一个对象是否被冻结 6 判断 Object.is(value1, value2) 判断两个值是否相等，不会作类型转换 与===的区别 === 认为-0和+0相等，此方法认为不相等 === 认为NaN和NaN不相等，此方法认为相等 3 原型方法 valueOf() 返回对象原始值，若没有原始值，返回对象本身，通常会覆盖 对象 返回值 Number 数值 Boolean 布尔值 String 字符串值 Object 对象本身 Array 数组本身 Function 函数本身 Date 距离1970-01-01 00:00:00 的毫秒数 toString() 默认返回 [object type]，通常会覆盖 toLocaleString() 默认返回调用 toString() 的结果，可以覆盖 hasOwnProperty(prop) 判断对象自身是否含有某个属性 propertyIsEnumerable(prop) 判断某个属性是否可枚举 isPrototypeOf(object) 判断调用对象是否在另一个对象的原型链上 和 instanceof 的区别 A instanceof B ：判断 B.prototype是否在A的原型链上 B.isPrototypeOf(A)：判断B是否在A的原型链上 2.2 创建对象方式 Object构造函数 对象字面量 对象字面量内部调用了Object的构造函数 Object.create(proto, [propertiesObject]) 这种方式可以指定原型 2.3 对象字面量 标准形式12345let obj =&#123; key:value, key:function()&#123;&#125; ...&#125;; 如果属性值是方法，可以简写123key:function()&#123;&#125; //简写key()&#123;&#125; 如果属性名是一个表达式，使用[]包裹，意思是取表达式的值123let a = &apos;haha&apos;;let obj = &#123; [a]:a &#125;; console.log(obj); // &#123;haha:&apos;haha&apos;&#125; 如果属性值是外部变量的值，属性名与变量名相同时可以简写（其实就是将变量作为对象属性）12345let a = &apos;haha&apos;；let obj = &#123; a:a &#125;;// 简写let obj = &#123;a&#125;; console.log(obj); // &#123;a:&apos;haha&apos;&#125; 与json的区别 json只允许&quot;property&quot;:value，属性名必须用双引号括起来 json值仅允许字符串，数字，数组，true，false，null或其他（JSON）对象，值不能是函数 2.4 自定义构造函数1234567// 可以空参function Person(name,age)&#123; this.name=name; this.age=age; this.show=function()&#123;code...&#125;&#125;let person=new Person(&quot;xq&quot;,8); 2.5 工厂函数1234567891011function userFactory(name) &#123; let obj = &#123;&#125;; obj.name = name; obj.show = function()&#123;&#125;; return obj; // 或者简写 return &#123; name, show()&#123;&#125; &#125;;&#125; 在函数内部根据传入的参数创建一个对象（可以使用字面量或Object构造等等方式），然后将对象返回，为了复用 与自定义构造函数方式的区别 工厂函数是函数调用，自定义构造是new 工厂函数是函数名称小写，自定义构造名称大写 工厂函数内部需要显式创建一个对象，然后根据参数赋值后再显式返回 自定义构造根据参数自动创建一个对象并返回 2.6 属性管理1 属性的访问121 obj.property2 obj[&apos;property&apos;] 点后边只能是属性名，中括号中可以是一个表达式 当属性名称比较特殊时，如数字,空格…，只能用中括号 当属性名称是变量时，如遍历时，只能用中括号 2 属性的删除121 delete object.property 2 delete object[&apos;property&apos;] 删除自身属性，返回布尔值 如果要删除的属性不存在，返回true 2.7 访问器（get/set）1 语法123456// getter1 get prop() &#123; ... &#125;2 get [expression]() &#123; ... &#125;// setter1 set prop(val) &#123; . . . &#125;2 set [expression](val) &#123; . . . &#125; 函数名可以是一个表达式 访问器函数调用方式与访问对象属性一样，其实是调用访问器函数 obj.访问器名 obj[&#39;访问器名&#39;] 访问器跟属性同名时，如果访问器方法内部访问属性会造成无限循环。 2 定义方式 通过配置属性描述符对象定义访问器12345678910111213let obj = &#123; name : &apos;小明&apos;;&#125;Object.defineProperty(obj, &apos;name&apos;, &#123; get() &#123; return obj.name; // 跟取值方式一样，也会调用get，会无限循环 &#125;, set(value) &#123; obj.name = value; &#125;&#125;;obj.name; // 调用get取值obj.name = &apos;旺财&apos;; // 调用set设置值 对象字面量中直接定义123456789let obj = &#123; _name: &apos;小明&apos;, get name() &#123; return this._name; &#125;, set name(value) &#123; this._name = value; &#125;&#125; 2.8 对象拷贝1 概念 浅拷贝 如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 一个对象修改可能会影响到另一个对象 深拷贝 将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象 一个对象修改不会影响到另一个对象 2 浅拷贝方式 创建新对象，然后使用for...in遍历原对象属性并一个一个连值一起添加到新对象上1234567let source = &#123;name:&apos;an3&apos;, age:18&#125;;let cp = &#123;&#125;;for (const key in source)&#123; if(source.hasOwnProperty(key)&#123; cp[key] = source[key]; &#125;&#125; 使用Object.assign(目标对象, 原对象列表)，并将目标对象设为空对象，就相当于返回了对原对象的浅拷贝12let source = &#123;name:&apos;an3&apos;, age:18&#125;;let cp = Object.assign(&#123;&#125;, source); 展开语法12let source = &#123;name:&apos;an3&apos;, age:18&#125;;let cp = &#123;...source&#125;; 3 深拷贝方式 使用JSON 步骤 JSON.stringify()：将一个对象序列成一个字符串 JSON.parse()：将字符串反序列化生成深拷贝对象 注意 拷贝的对象的值中如果有函数,undefined,symbol则经过JSON.stringify()序列化后的JSON字符串中这个键值对会消失 无法拷贝不可枚举的属性，无法拷贝对象的原型链 拷贝Date引用类型会变成字符串 拷贝RegExp引用类型会变成空对象 对象中含有NaN、Infinity和-Infinity，则序列化的结果会变成null 无法拷贝对象的循环应用(即obj[key] = obj) 递归12345678910function deepCopy(obj) &#123; // 对象的属性值有可能是数组，判断一下防止递归时把数组变成了对象 let cpObj = obj instanceof Array ? [] : &#123;&#125;; // 我用for in 也可以，但for in 不推荐用来遍历数组，Object.entries()方法对于对象和数组返回结果形式是一样的 for(const [k, v] of Object.entries(obj)) &#123; // 判断对象属性如果是引用类型就递归拷贝，最终就是深拷贝 cpObj[k] = typeof v == &apos;object&apos; ? deepCopy(v) : v; &#125; return cpObj;&#125;; 原理就是浅拷贝只拷贝一层，那我们就递归，如果这一层属性的值是引用类型，就再拷贝一层…… 2.9 代理1 概述 代理（拦截器）是对象的访问控制，setter/getter 访问器是对对象单个属性的控制 2 Proxy1 构造函数 new Proxy(target, handler) 返回一个Proxy实例 target 用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理） handler 处理器对象，有许多拦截相应操作的函数，如果没有配置，则执行默认操作 注意：处理操作都是针对代理对象的，目标对象无效。 2 handler get(target, property, receiver) 参数 target 目标对象 property 获取的属性名 reveiver Proxy或者继承Proxy的对象 说明 get 方法拦截属性的获取，可以返回任何值 set(target, property, value, receiver) 参数 value 被设置的新值 说明 set 方法拦截属性的设置 严格模式下 set 必须返回布尔值，且如果返回false会报错 apply(target, thisArg, argumentsList) 参数 target 目标函数 thisArg 被调用时的上下文对象 argumentsList 被调用时的参数数组 说明 apply 方法拦截函数调用，可以返回任何值 直接调用 Function.prototype.call() 方式调用 Function.prototype.apply() 方式调用 Reflet.apply() 方式调用 has(target, prop) 参数 target 目标对象 prop 需要检查是否存在的属性. 说明 拦截 prop in object 语句，返回布尔值 construct(target, argumentsList, newTarget) 参数 target 目标构造函数 argumentsList constructor的参数列表 newTarget 生成的代理对象（即代理构造函数） 说明 拦截new操作，必须返回一个对象 deleteProperty(target, prop) 拦截delete 操作，必须返回布尔值 defineProperty(target, property, descriptor) 拦截Object.defineProperty()，必须返回布尔值 getOwnPropertyDescriptor(target, prop) 拦截 Object.getOwnPropertyDescriptor()，必须返回一个对象或undefined getPrototypeOf(target) 拦截获取原型操作 setPrototypeOf(target, prototype) 拦截设置原型操作，返回布尔值 preventExtensions(target) 拦截Object.preventExtensions()，返回一个布尔值 isExtensible(target) 拦截Object.isExtensible()，必须返回布尔值 ownKeys(target) 拦截对象获取自身属性的操作 2.10 Reflect1 概述 Reflect不是一个构造函数，不能new，Reflect的所有属性和方法都是静态的（就像Math对象）。 将Object对象的一些明显属于语言内部的方法（如Object.defineProperty），放到Reflect对象上 修改某些Object方法的返回结果，让其变得更合理 如Object.defineProperty无法定义属性时，会抛出错误，而Reflect.defineProperty会返回false 让Object操作都变成函数行为 如 prop in object ，对应Reflect.has(obj, prop) delete obj.prop，对应Reflect.deleteProperty(obj, prop) Reflect对象与Proxy的handler 方法完全一致，在使用代理拦截某些操作时，使用Reflect的方法可以保证原生行为能正常执行。 2 静态方法 见Proxy handler 2.11 this &amp; super1 this 在全局环境中 或者 在函数中 非严格模式：this指向顶层对象window 严格模式：this为undefined 在对象中，this代表当前对象的引用 在对象方法（对象的属性是函数则称为方法）中，this指向调用该方法的对象 在箭头函数中，this与定义箭头函数时所在的环境指向同一个this 在构造函数中，this指向正在构造的新对象 在DOM事件处理函数中，this指向触发事件的元素 在内联事件处理函数中，this指向监听器所在的DOM元素 2 super super指向当前对象的原型对象 三 数组3.1 Array1 概述 数组都是Array对象的实例 数组可以存任意类型的数据 数组长度可变 ES6 明确数组中空位值为undefined 数组字面量 [ele0, ele1, ..., eleN] 2 构造函数 Array() 和 new Array() 是等同的 new Array(arrayLength) 如果参数只有一个且是 0-232-1 之间的整数，则创建一个指定长度的数组 new Array(element0, element1[, ...[, elementN]]) 创建一个指定元素的数组 3 静态属性 length 4 静态方法 Array.isArray(obj) 如果值是 Array，则返回true，否则返回false 用来弥补typeof，因为typeof 数组 返回的是object Array.of(element0[, element1[, ...[, elementN]]]) 将一组值转换为数组 用来弥补构造函数，构造函数参数个数不同会导致结果不同。 Array.from(arrayLike[, mapFn[, thisArg]]) 从一个类数组对象或可迭代对象创建一个新的浅拷贝的数组实例并返回 mapFn 如果指定了该参数，新数组中的每个元素都会执行该回调函数 thisArg 执行回调函数 mapFn 时的 this 对象 5 原型方法1 获取 valueOf() 返回数组本身 toString() 返回数组的字符串形式 join([separator]) 以指定分隔符（默认为逗号）将所有数组成员连接为一个字符串返回 2 增删改 push(element1, ..., elementN) 将一个或多个元素添加到数组的末尾，并返回该数组的新长度，改变原数组 如果参数为数组，把数组作为元素添加到数组中。(二维数组) pop() 删除并返回最后一个元素，改变原数组 unshift(element1, ..., elementN) 将一个或多个元素添加到数组的开头，并返回该数组的新长度，改变原数组 参数可以是数组（二维数组） shift() 删除并返回第一个元素，改变原数组 fill(value[, start[, end]]) 使用指定值填充数组，可指定开始结束索引，返回修改后的数组 slice([begin[, end]]) 提取目标数组的一部分，返回一个浅拷贝新数组，原数组不变 splice(start[, deleteCount[, item1[, item2[, ...]]]]) 删除目标数组的一部分成员，并可以在删除的位置添加新的数组成员，返回被删除的元素组成的数组，改变原数组 concat(value1, value2, ..., valueN) 将一个或多个值合并到数组中，返回新数组，不改变原数组 copyWithin(target[, start[, end]]) 复制数组的一部分到数组指定位置（覆盖原有成员），并返回数组，改变原数组但不改变数组长度（因为会覆盖原有成员） target 目标位置 start 复制的起始索引，默认为0 end 复制的终止索引（不含），默认为尾部 flat([depth]) 将数组降维，返回新数组，不改变原数组 depth 指定结构深度，默认值为 1，即只可以将二维数组合并成一维数组 flatMap(callback[, thisArg]) 对数组中每一个元素执行回调函数，然后对返回值组成的数组执行flat()方法，结构深度 depth 值为1，返回新数组 callback(currentValue[, index[, array]]) currentValue：当前遍历的元素 index：当前遍历到的索引 array：当前数组 3 查 indexOf(searchElement[, fromIndex]) 返回第一个匹配索引，如果不存在，则返回-1 lastIndexOf(searchElement[, fromIndex]) 返回从后往前的第一个匹配索引，如果不存在，则返回-1 includes(valueToFind[, fromIndex]) 判断数组是否包含指定元素 find(callback[, thisArg]) 返回数组中第一个满足所提供测试函数（返回true）的元素的值，否则返回 undefined callback(element[, index[, array]]) element：当前遍历的元素 index：当前遍历到的索引 array：当前数组 thisArg 执行回调时函数时this 指向的对象。 findIndex(callback[, thisArg]) 返回数组中第一个满足所提供测试函数（返回true）的元素的索引，否则返回 -1 4 排序 reverse() 反转数组并返回，改变原数组 sort([compareFunction]) 默认是按照字典顺序排序，返回排序后的数组，改变原数组 compareFunction(value1, value2) 返回一个数字，如果小于0则value1排在value2之前 5 循环遍历 forEach(callback[, thisArg]) callback(currentValue[, index[, array]]) currentValue：当前遍历的元素 index：当前遍历到的索引 array：当前数组 keys() 返回数组元素键的迭代器对象 values() 返回数组元素值的迭代器对象 entries() 返回数组元素键值对的迭代器对象 6 扩展方法 every(callback[, thisArg]) 判断数组元素是否全部能通过指定测试函数，返回布尔值，碰到一个元素返回false，则every立即返回false callback(element[, index[, array]]) element：当前遍历的元素 index：当前遍历到的索引 array：当前数组 some(callback[, thisArg]) 数组中有至少一个元素通过回调函数的测试就会返回true； filter(callback[, thisArg]) 返回一个新的由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组 map(callback[, thisArg]) 对数组中每一个元素执行回调函数，返回每一个回调函数结果组成的新数组 reduce(callback[, initialValue]) 返回回调函数累计处理的结果 callback(accumulator, currentValue[, index[, array]]) accumulator 第一次循环 有initialValue，则为initialValue 无initialValue，则为数组第一个元素 从第二次循环往后为回调函数返回值 currentValue 数组中当前循环的元素 第一次循环时，如果没有initialValue，由于accumulator是数组第一个元素，则currentValue会从第二个元素开始循环 index 数组中当前循环的元素的索引 array 当前数组 reduceRight(callback[, initialValue]) 与reduce()相似，只是从右向左遍历数组 四 函数4.1 Function1 概述 每个 JavaScript 函数都是一个 Function 对象 2 构造函数 new Function ([arg1[, arg2[, ...argN]],] functionBody) arg1, arg2, ... argN 字符串，字符串中多个参数用逗号分隔 functionBody 函数体的字符串 3 静态属性 Function.length 函数的形参个数 Function.name 函数的名称 4 原型方法 call(thisArg, arg1, arg2, ...) 使用指定的 this 值和参数列表来调用此函数 thisArg 函数运行时this的值 与 bind 不同 call/apply 会立即执行函数 apply(thisArg, [argsArray]) 同call()，不同的是接受的是一个参数数组 bind(thisArg[, arg1[, arg2[, ...]]]) 使用指定的this和参数列表创建一个原函数的拷贝并返回 call() 和 apply() 用来执行函数，bind()用来创建函数，即不会立即执行 bind设置的参数优先级高（即调用时设置的相应参数无效） toString() 返回表示函数源代码的字符串 4.2 立即执行函数（IIFE Imdiately Invoked Function Expression）121 (function()&#123;...&#125;())2 (function()&#123;...&#125;)() 不必为函数命名 形成单独的作用域，封装遍历，避免重名… 4.3 定义函数1 函数声明123function 函数名(参数列表) &#123; 函数体&#125; 函数提升，提升优先级高于var变量提升 函数会添加到window对象中 优先级高于函数表达式 2 函数表达式123var/let/const 函数名 = function (参数列表) &#123; 函数体&#125; 函数不会提升 var声明的函数会添加到window对象中，但let/const则不会 3 Function构造函数1var/let/const 函数名 = new Function(&quot;参数列表&quot;,&quot;函数体&quot;); 函数不会提升 var声明的函数会添加到window对象中，但let/const则不会 4.4 参数1 形参 &amp; 实参 形参是默认声明的，不用var/let/const修饰 实参数量小于形参时，没有传递的形参值为 undefined 实参数量大于形参时，多余的实参将忽略并不会报错 2 参数默认值 在形参上可以直接定义参数默认值，如果传递对应参数则使用传递值，否则使用默认值 3 arguments arguments 对象是所有（非箭头）函数中都可用的局部变量，是一个类数组对象，存储了传递的实参 4.5 箭头函数1 概述 箭头函数内部的this 是固定的，指向定义时所在的环境的this 箭头函数不可以当作构造函数，也就是说，不可以使用new命令 箭头函数内部不存在arguments 对象 箭头函数不可以使用yield命令，因此箭头函数不能用作 Generator 函数 2 语法 基础语法1(param1, param2, …, paramN) =&gt; &#123; statements &#125; 没有参数1() =&gt; &#123; statements &#125; 只有一个参数，小括号可以省略1singleParam =&gt; &#123; statements &#125; 函数体只有一句，return、分号和大括号都可以省略12345(param1, param2, …, paramN) =&gt; expression//相当于(param1, param2, …, paramN) =&gt;&#123; return expression; &#125;// 返回对象(param1, param2, …, paramN) =&gt; (&#123;name: &apos;xiaoming&apos;&#125;) 注意：如果返回的是一个对象，要用()包括，因为{}会被认为是一个代码块 五 集合5.1 Set1 概述 Set中的元素有序（存取顺序一致） 唯一 基本数据类型和引用数据类型都可以存储（包括NaN，undefined和null） 元素相等 基于 sameValueZero 算法 类似===，除了NaN不同，NaN === NaN返回false，但是在Set中看作相等 2 构造函数 new Set([iterable]) iterable 可迭代对象，它的所有元素将不重复地被添加到 Set中。 如果省略或其值为null，则新的 Set为空 3 原型属性 size 返回Set对象中元素的个数 4 原型方法 add(value) 向Set末尾添加元素，返回Set delete(value) 从Set 中删除指定元素，成功删除返回 true，否则返回 false has(value) 判断Set中是否有指定的元素 clear() 清空Set keys() 由于 Set 结构没有键，只有值，keys() 与 values() 完全一样 values() 返回值的迭代器对象 entries() 返回键值对的迭代器对象 键值对形式为[value, value]，即Set中的元素即是键也是值 forEach(callback[, thisArg]) 根据集合中元素的插入顺序，依次执行提供的回调函数 callback([currentValue[, currentKey[, set]]]) currentValue 当前元素 currentKey 由于Set没有键，currentKey与currentValue永远都一样，即也是当前元素 set 当前Set thisArg 回调函数执行过程中的 this 值 6 Set转数组 展开语法 ...set Array.from(set) 5.2 WeakSet 用法同Set大致相同 与Set的区别 WeakSet只能存引用数据类型 WeakSet是弱引用 当对象引用数量为0时，会被垃圾回收掉，弱引用的意思就是不会增加对象的引用数量。 WeakSet 不可遍历 因为WeakSet弱引用，其中的对象随时有可能别垃圾回收掉 没有size 属性 原型方法只有 add() delete() has() 5.3 Map1 概述 Map是键值对的集合，且键有序（存取一致） 对象的键只能是字符串，Map的键可以是任何值 如果键相等，后边的值回覆盖前边，键相等 基于 sameValueZero 算法 类似===，除了NaN不同，NaN === NaN返回false，但是在Map中看作相等 2 构造函数 new Map([iterable]) iterable 可迭代对象，其元素为键值对。 如数组为 [[&#39;name&#39;,&#39;xiaoming&#39;],[&#39;age&#39;,18]] 3 原型属性 size 返回Map中键值对的个数 4 原型方法 set(key, value) 向Map添加元素，返回Map get(key) 根据key获取value，没有返回undefined delete(key) 根据key删除元素，删除成功返回true，否则返回false clear() 清空Map has(key) 判断指定key的元素是否存在 keys() 返回键的迭代器对象 values() 返回值的迭代器对象 entries() 返回键值对[key, value]的迭代器对象 forEach(callback[, thisArg]) 根据集合中元素的插入顺序，依次执行提供的回调函数 callback([value[, key[, map]]]) 5 Map转数组 展开语法 ...map 5.4 WeakMap 用法同Map大致相同 与Map的区别 WeakMap的键只能是引用数据类型（不能为null） WeakMap的键是弱引用 WeakMap不能遍历 WeakMap没有size属性 WeakMap原型方法只有 set() get() delete() has() 六 Date6.1 构造函数 Date([value]) 普通函数，无论有没有参数，都返回当前日期和时间的字符串 new Date() new Date() 创建一个当前日期和时间的Date对象 new Date(value) value Unix 时间戳，是一个整数值，表示自1970年1月1日00:00:00 UTC（the Unix epoch）以来的毫秒数 new Date(dateString) dateString 表示日期的字符串。该字符串能被 Date.parse()正确识别 new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]) 分别指定年月日时分秒毫秒 6.2 静态方法 Date.now() 返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数 Date.parse(dateString) 解析日期字符串，返回该时间距离时间零点的毫秒数。 Date.UTC(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]) 返回该时间距离时间零点的毫秒数 6.3 原型方法1 to valueOf() 返回实例对象距离时间零点对应的毫秒数，同getTime() toString() / toDateString() / toTimeString() 返回一个日期时间字符串 / 日期字符串 / 时间字符串 toLocaleString() / toLocaleDateString() / toLocaleTimeString() 返回一个本地日期时间字符串 / 本地日期字符串 / 本地时间字符串 toUTCString() 返回使用UTC时区表示给定日期的字符串，比北京时间晚8个小时 toISOString() 返回对应时间的 ISO8601 写法的字符串 toJSON() 返回一个符合 JSON 格式的 ISO 日期字符串，与toISOString()方法的返回结果完全相同 2 get getTime() 返回Date实例距离事件元点的毫秒数 getFullYear 四位数的年份 getMonth() 月 0-11 getDate() 日 1-31 getDay() 星期 0-6 getHours() 时 0-23 getMinutes() 分 0-59 getSeconds() 秒 0-59 getMilliseconds 毫秒 0-999 3 set set 与 get 一一相对应，除了没有 setDay()，因为星期是算的 七 RegExp7.1 构造函数 RegExp() 和 new RegExp() 一样，返回正则对象 new RegExp(pattern [, flags]) pattern 正则表达式的文本 flags 修饰符，可以是g i m u y s的任意组合 7.2 字面量 /pattern/flags / 斜杠表示开始和结束 7.3 原型属性 global 只读，返回一个布尔值，判断是否设置了修饰符g ignoreCase 只读，返回一个布尔值，判断是否设置了修饰符i multiline 只读，返回一个布尔值，判断是否设置了修饰符m unicode 只读，返回一个布尔值，判断是否设置了修饰符u sticky 只读，返回一个布尔值，判断是否设置了修饰符y dotAll 只读，返回一个布尔值，判断是否设置了修饰符s flags 只读，返回一个字符串，包含已经设置的所有修饰符，按字母排序 source 只读，返回正则表达式文本字符串，该字符串不包含正则字面量两边的斜杠以及任何的标志字符 lastIndex 可读写，用来指定下一次匹配的起始索引。只有正则表达式使用了表示全局检索的 “g” 标志时，该属性才会起作用 7.4 原型方法 test(str) 如果正则表达式与指定的字符串匹配 ，返回true；否则false 更新正则对象的lastIndex属性 exec(str) 如果匹配成功，返回一个数组且具有详细信息，并更新正则表达式对象的 lastIndex 属性。 当正则有g标志时，可以多次执行 exec 方法来查找同一个字符串中的成功匹配，且查找将从正则表达式的 lastIndex 属性指定的位置开始 如果匹配失败，返回 null，并将 lastIndex 重置为 0 八 JSON8.1 语法 属性名称必须是双引号括起来的字符串；最后一个属性后不能有逗号 基本类型的值 字符串 数值（必须十进制，NaN不行） 布尔值 null（undefined不行） 引用类型的值 数组 对象 8.2 静态方法 JSON.stringify(value[, replacer [, space]]) 将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被parse()方法还原。 value 要被序列化的对象 如果对象有自定义的toJSON()方法，那么JSON.stringify()会使用toJSON()方法的返回值作为参数 replacer 如果是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的处理 如果是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中 space： 指定缩进用的空白字符串，用于美化输出（pretty-print）增加可读性。 如果是数字，表示每个属性前面添加的空格（不超过10个） 如果是字符串（不超过10个字符），则该字符串会添加在每行前面 JSON.parse(text[, reviver]) 将 JSON 字符串转换成对应的对象 reviver(currentKey, currentValue) 转换器，此函数调用时机在parse 函数返回之前，用于在返回之前对所得到的对象执行操作 转成的对象的所有属性都会调用reviver 函数，并且会将reviver返回值作为新的属性值，如果reviver返回undefined，会删除当前属性 九 Error9.1 概述 当代码运行时的发生错误，会创建新的Error 对象，并将其抛出 9.2 构造函数 new Error([message]) 9.3 原型属性 message 错误信息 name error类型的名称.初始值为Error 9.4 其它类型的错误构造函数 EvalError 错误原因：与 eval() 有关 RangeError 错误原因：数值变量或参数超出其有效范围 ReferenceError 错误原因：无效引用 SyntaxError 错误原因：语法错误 TypeError 错误原因：变量或参数不属于有效类型 URIError 错误原因：给 encodeURI()或 decodeURl()传递的参数无效","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"Javascript","slug":"UI/Javascript","permalink":"https://anyeansan.github.io/categories/UI/Javascript/"}],"tags":[]},{"title":"Javascript 基本数据类型","slug":"Javascript-基本数据类型","date":"2020-03-30T14:10:22.000Z","updated":"2020-03-30T14:13:41.476Z","comments":true,"path":"2020/03/30/Javascript-基本数据类型/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/Javascript-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"一 number1.1 数值 值 说明 任意数字 整数或者浮点数 +Infinity 正无穷 -Infinity 负无穷 NaN not a number 一个不是数字的数字类型 1. JavaScript的number类型为双精度IEEE 754 64位浮点类型。范围（-253- 253） 2. JavaScript 内部，整数和浮点数采用的是同样的储存方法。所以1===1.0 为true 3. 进制 * 十进制 * 二进制：以0b开头 * 八进制：以0o开头 * 十六进制：以0x开头 1.2 Number（包装类）1 构造函数 Number([value]) 普通函数，作用是类型转换，将value转成一个数值number 如果参数为空，返回0 如果参数无法被转换为数字，则返回 NaN new Number([value]) 构造函数，创建一个Number对象，值为value转换成的数值 2 静态属性 Number.POSITIVE_INFINITY 正的无限，指向 +Infinity Number.NEGATIVE_INFINITY 负的无限，指向 -Infinity Number.NaN 表示NaN Number.MIN_VALUE 表示在 JavaScript 中所能表示的最小的正值 Number.MAX_VALUE 表示在 JavaScript 里所能表示的最大数值 Number.MIN_SAFE_INTEGER 表示在 JavaScript 中能够准确表示的整数范围下限（-(253 - 1)） Number.MAX_SAFE_INTEGER 表示在 JavaScript 中能够准确表示的整数范围上限（253 - 1） Number.EPSILON 表示 1 与大于 1 的最小的浮点数之间的差值 实际上是 JavaScript 能够表示的最小精度 3 静态方法 Number.isNaN(value) 判断给定的值是否是 NaN。 和全局函数isNaN() 的区别 全局函数 isNaN() 会先将非数值转换为数值，再进行判断 Number.isNaN() 只对数值有效，非数值直接返回false Number.isFinite(value) 判断给定的值是否是有穷数 和全局函数isFinite() 函数的区别 全局函数 isFinite() 会先将非数值转换为数值，再进行判断 Number.isFinite() 只对数值有效，非数值直接返回false Number.isInteger(value) 判断给定值是否是整数 Number.parseInt(string[, radix]) 将一个字符串转换成指定进制的整数 radix 指定进制（2-36），默认10 同 全局函数 parseInt()，移植到Number上，目的是逐步减少全局性方法，使得语言逐步模块化 Number.parseFloat(string) 把一个字符串解析成浮点数 同 全局函数parseFloat()，移植到Number上，目的是逐步减少全局性方法，使得语言逐步模块化 4 原型方法 valueOf() 返回基本类型的值 toString([radix]) 返回字符串形式 toFixed([digits]) 返回保留指定位数浮点数的字符串 digits 小数点后数字的个数，默认为0 1.3 Math1 静态属性 Math.E 欧拉常数 e Math.PI 常数 π 2 静态方法 Math.abs(x) 绝对值 Math.ceil(x) 向上取整 Math.floor(x) 向下取整 Math.pow(x, y) 返回 x 的 y 次幂 Math.random() 返回0-1之间的伪随机数(含0不含1) Math.round(x) 四舍五入 Math.sqrt(x) 平方 Math.log(x) 对数 Math.exp(x) e 的指数（e的x次方） Math.min([value1[,value2, ...]]) 返回给定的一组数字中的最小值。如果任一参数不能转换为数值，则返回NaN。 Math.max(value1[,value2, ...]) 返回给定的一组数字中的最大值。如果任一参数不能转换为数值，则返回NaN。 Math.sin(x) 正弦 Math.cos(x) 余弦 Math.tan(x) 正切 二 boolean2.1 布尔值 true false 2.2 类型转换1 类型转换规则 值 转换结果 0 false NaN false &quot;&quot; false false false null false undefined false 其它 true 隐式转换 基本上所有类型都可以隐式转换为 boolean类型。 注意：值和布尔值是不同的概念 显式转换 Boolean() !! new Boolean() 不太好，因为返回一个对象，而将对象转换成布尔值必为true 2.3 Boolean（包装类）1 构造函数 Boolean([value]) 普通函数，作用是类型转换，将value转成一个布尔值boolean new Boolean([value]) 构造函数，创建一个Boolean对象 如果省略参数，则Boolean对象值为false 如果value不是布尔值，则先转成布尔值 2 原型方法 valueOf() 返回基本类型的值true/false toString() 返回字符串形式 &#39;true&#39;/&#39;false&#39; 三 string3.1 字符串字面量 单/双引号（特殊字符使用\\转义） 反引号（模板字面量，特殊字符直接使用，反引号需要使用\\转义） 3.2 字符的 Unicode表示法 \\uxxxx 只限于Unicode编码在\\u0000~\\uFFFF（0-65535）之间的字符 \\u{} 使用{}，大于\\uFFFF的字符也能正确表示 3.3 字符串换行 末尾加\\ 加号连接 反引号 3.4 模板字面量 模板字面量是增强版的字符串，它用反引号标识 空格换行等都会原样输出 ${表达式} 占位符就如同一个普通字符串一样，可以插入到字符串中的任意位置 作用是取表达式的值 反引号可以嵌套 3.5 模板字面量标签 模板字面量标签通常是一个函数 调用标签函数，将它放在模板字面量前即可123alert`hello`;function myTag (strings, ...values)&#123;&#125;myTag`hello` 调用标签函数时，会将模板字面量处理成参数，传递给函数 第一个参数是数组，存储模板字面量中占位符${}两侧的字符串 第二个参数是可变参数，存储占位符${}的返回值1234let name = &apos;xiaoming&apos;, age = 18;alert`hello$&#123;name&#125;,ni$&#123;18&#125;了吗`; // 相当于alert ([&apos;hello&apos;, &apos;,ni&apos;, &apos;了吗&apos;], &apos;xiaoming&apos;, 18); 3.6 String（包装类）1 构造函数 String([value]) 普通函数，作用是类型转换，将value转成一个字符串string 如果参数为空，则返回空字符串&#39;&#39; 如果参数是基本类型，则返回基本类型的字符串形式 如果参数是引用类型，相当于调用其toString() new String([value]) 构造函数，创建一个String对象，值为value转成的字符串 2 实例属性 length 3 静态方法 String.fromCharCode(num1, ..., numN) 返回使用指定的 Unicode 编码创建的字符串（不能识别大于0xFFFF的字符） num1, ..., numN 一串 Unicode 编码 String.fromCodePoint(num1[, ...[, numN]]) 返回使用指定的 Unicode 编码创建的字符串（可以识别大于0xFFFF的字符） String.raw&#96;templateString&#96; 返回模板字符串的原始字符串 是唯一一个内置的模板字符串标签函数 4 原型方法1 获取 valueOf() 返回字符串对象的原始字符串 repeat(count) 当前字符串重复count次组成新字符串并返回 concat(str1, str2[, ..., strN]) 将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回，不改变原字符串 slice(beginIndex[, endIndex]) 提取从开始索引到结束索引之间（含头不含尾）的字符串并返回，不改变原字符串 索引可以为负，则索引为负时表示从后开始（-1, -2 …） 索引超过字符串长度时，会被当作末尾 substring(beginIndex[, endIndex]) 提取从开始索引到结束索引之间（含头不含尾）的字符串并返回，不改变原字符串 索引为负时或为 NaN，则被当作 0 索引超过字符串长度时，会被当作末尾 substr(beginIndex, length)（ 已过时） 提取从起始索引号指定数目的字符串并返回，不改变原字符串 2 改 toLowerCase() / toUpperCase() 将一个字符串转小/大写，返回一个新字符串，不改变原字符串 trim() 去除字符串两端的空格，返回一个新字符串，不改变原字符串 trimStart() / trimEnd() trimLeft()是 trimStart() 的别名，trimRight() 是trimEnd()的别名 padStart(targetLength [, padString]) 以指定字符串padString在原字符串开头补充，以达到目标长度targetLength targetLength 当前字符串需要填充到的目标长度，如果小于等于当前字符串长度，则返回当前字符串 padString 填充字符串，如果省略则使用空格 padEnd(targetLength [, padString]) 3 查 charAt(index) 返回指定位置的字符 charCodeAt(index) 返回指定位置的字符Unicode 值（十进制） 只能获取2个字节表示的字符，对于4个字节表示的字符会认为是两个字符 codePointAt(index) 返回指定位置的字符Unicode 值（十进制） 可以正确获取4个字节表示的字符 javaScript内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。（0-65535 或 0x0000-0xFFFF） indexOf(searchValue[, fromIndex]) 返回一个字符串在另一个字符串中第一次出现的索引，未找到返回-1 默认从0索引开始往后找 lastIndexOf(searchValue[, fromIndex]) 返回一个字符串在另一个字符串中从后往前第一次出现的索引，未找到返回-1 4 判断 includes(searchString[, fromIndex]) 判断是否包含指定字符串 startsWith(searchString[, fromIndex]) 判断是否以指定字符串开头 endsWith(searchString[, length]) 判断是否以指定字符串结尾 length 表示只判断当前字符串指定长度的子串，如3，则表示只判断前三个字符是否以指定字符串结尾 默认为当前字符串的length大小 5 正则 split([separator[, limit]]) 按照给定规则分割字符串，返回一个由分割出来的子字符串以指定分隔符组成的数组 separator 可以是一个字符串或正则表达式 limit 限定返回的分割片段数量 search(regexp) 返回正则表达式在字符串中首次匹配项的索引;否则，返回 -1 regexp 正则对象，如果传入一个非正则对象，则会先转成正则对象 match(regexp) 如果正则没有g标志，则返回包含第一个匹配结果的数组，且有附加属性（index, input, groups,…） 如果正则有g标志，则返回包含所有匹配结果的数组，没有附加属性 如果没有匹配，返回null matchAll(regexp) 返回一个包含所有匹配正则表达式的结果（包含附加属性）的迭代器 没有matchAll之前，使用while循环加exec方式（且正则表达式需使用g标志），来获取所有匹配项 replace(regexp|substr, newSubStr|function) regexp|substr 正则匹配的内容或者指定的内容 newSubStr 使用新的字符串替换，替换时可以插入特殊变量 function 使用函数返回的字符串替换 特殊变量 说明 $$ 插入一个 “$” $&amp; 插入匹配的子串 $` 插入当前匹配的子串左边的内容 $&#39; 插入当前匹配的子串右边的内容 $n 如果第一个参数是RegExp对象，表示插入第n组的内容 函数参数 说明 match 匹配的子串。（对应$&amp;。） p1,p2,... 如果第一个参数是RegExp对象，表示第n组的内容（对应$n） offset 匹配到的子字符串在原字符串中起始索引 string 被匹配的原字符串 NamedCaptureGroup 命名捕获组匹配的对象 四 null &amp; undefined 一个没有赋值的变量默认值为undefined 基本类型：初始化推荐undefined（惯例，其实默认就是undefined，null也可以） 引用类型：初始化推荐null（惯例，undefined也可以） 值为undefined的情况 变量或者对象属性没有赋值，则默认值undefined 调用函数时，没有传值的参数则默认为undefined 函数没有返回值时，默认返回 undefined 五 symbol5.1 概述 symbol 的值是唯一的，独一无二的不会重复的 symbol 值作为对象属性名时，不能用点运算符，只能使用[] 不会被for...in for... of遍历到 不会被Object.keys() Object.getOwnPropertyNames() JSON.stringify()返回 使用Object.getOwnPropertySymbols()可以获取 symbol 值不能与其他类型的值进行运算，可以转为字符串和布尔值 5.2 Symbol（包装类）1 构造函数 Symbol([description]) 返回一个symbole类型的值，且是唯一的 不会放入全局symbol注册表 description 字符串类型。仅仅是对symbol的描述，为了控制台显示时或者转为字符串时比较容易区分，不会影响symbol的值（即使用相同描述创建的symbol也不同） 如果传入的不是字符串，会先转成字符串 new Symbol() 不支持此语法 2 静态属性 ES6 提供了 11 个内置的 Symbol 值，指向语言内部使用的方法 Symbol.hasInstance A instanceof B 实际调用的是 B[Symbol.hasInstance](A) Symbol.iterator for(let a of A) 会调用 A[Symbol.iterator]() 返回对象的迭代器 3 实例属性 description 只读属性，返回 Symbol 对象的可选的描述字符串 4 静态方法 Symbol.for(key) 根据键 key 从全局symbol注册表中查询，如果找到则返回，否则创建一个与key关联的symbol，放入全局 symbol 注册表中，并返回 key 一个字符串，作为 symbol 注册表中与某 symbol 关联的键（同时也会作为该 symbol 的描述） Symbol.keyFor(sym) 获取全局symbol 注册表中与某个 symbol 关联的键，若存在则返回字符串key，否则返回undefined 六 bigInt 用任意精度表示整数","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"Javascript","slug":"UI/Javascript","permalink":"https://anyeansan.github.io/categories/UI/Javascript/"}],"tags":[]},{"title":"Javascript 数据类型概述","slug":"Javascript-数据类型概述","date":"2020-03-30T14:07:41.000Z","updated":"2020-03-30T14:10:07.298Z","comments":true,"path":"2020/03/30/Javascript-数据类型概述/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/Javascript-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0/","excerpt":"","text":"一 数据类型判断1.1 typeof1 语法12typeof operand // operand：表示对象或基本值的表达式typeof(operand) 判断数据类型并返回字符串形式 2 返回值 type typeof Result number “number” bigint “bigint” string “string” boolean “boolean” undefined “undefined” null “object” symbol “symbol” function object (implements [[Call]]) “function” any other object “object” * typeof null返回object是历史原因 1.2 instanseof object instanceof constructor 用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上 二 数据类型分类2.1 基本数据类型 number boolean string null undefined symbol bigInt 2.2 引用数据类型 object 内置对象 对象 （Object） 数组 （Array） 集合 （Map Set WeakMap WeakSet） 函数（Function） 基本类型包装对象（Number Boolean String Symbol BigInt） 数学（Math） 日期（Date） Json（JSON） 正则（RegExp） 错误（Error） …… 自定义对象","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"Javascript","slug":"UI/Javascript","permalink":"https://anyeansan.github.io/categories/UI/Javascript/"}],"tags":[]},{"title":"Javascript 语法","slug":"Javascript-语法","date":"2020-03-30T14:02:03.000Z","updated":"2020-03-30T14:23:03.952Z","comments":true,"path":"2020/03/30/Javascript-语法/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/Javascript-%E8%AF%AD%E6%B3%95/","excerpt":"","text":"一 严格模式1.1 启用 &quot;use strict;&quot; 放在脚本文件的第一行，整个脚本都将以严格模式运行。 放在函数体的第一行，则整个函数以严格模式运行。 1.2 严格模式中的变化1 显式报错 严格模式会使引起静默失败(silently fail，不报错也没有任何效果)的赋值操作抛出异常 只读属性的写操作，不可扩展对象扩展操作， 严格模式下，试图删除不可删除的属性时会抛出异常 严格模式下禁止对象属性重名 严格模式下禁止函数参数重名 严格模式禁止八进制数字语法 2 安全措施 严格模式下，变量必须先声明，然后再使用 禁止 this 关键字指向全局对象window 严格模式禁止删除声明变量 3 静态绑定 js允许动态绑定，即属性或方法属于哪个对象不是编译时确定的，而是在运行时确定 严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定，即编译时就确定属性或方法属于哪个对象。 严格模式禁用 with语句 创设 eval 作用域 正常模式下，eval语句的作用域，取决于它处于全局作用域，还是函数作用域。 严格模式下，eval语句本身就是一个作用域，即eval所生成的变量只能用于eval内部 arguments 不再追踪参数的变化 变量arguments代表函数的参数。 严格模式下，函数内部改变参数与arguments的联系被切断了，两者不再存在联动关系 二 顶层对象 JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。 顶层对象在各种实现里面是不统一的 ES2020标准中，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的 环境 顶层对象 ES2020 浏览器 window，self globalThis Web Worker self globalThis Node global globalThis 三 注释 // /* */ 不能嵌套 四 作用域 全局作用域 块作用域 函数作用域 五 声明关键字关键字|初始化|变量提升|块作用域|window|同一作用域重复声明:-:|-|-|-|-var|可选|有|无|全局变量会成为window对象属性|可以，后者覆盖前者let|可选|无|有|全局变量不属于window属性|不能const|必须|无|有|全局变量不属于window属性|不能 变量提升 变量的声明语句，被提升到代码的头部 暂时性死区（temporal dead zone，简称 TDZ let和const没有变量提升，所以必须先声明后使用 从作用域开始到声明语句的区域，如果使用声明的变量就会会导致 ReferenceError，这块区域称为暂时性死区。 const 常量指向的内存地址不能改变 基本类型值不能改变 引用类型地址值不能修改 六 变量 变量的声明和赋值，是分开的两个步骤123let a = 1; // 其实是下边两步let a;a = 1; 同一条声明语句中可以声明多个变量 JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。 变量标识符命名规则 不能用数字开头 可以用中文 不能使用js保留字 七 运算符7.1 赋值运算符 运算符 名称 运算式 等价于 = 赋值 x = y x = y += 加赋值 x += y x = x + y -= 减赋值 x -= y x = x - y *= 乘赋值 x *= y x = x * y /= 除赋值 x /= y x = x / y %= 模赋值 x %= y x = x % y **= 指数赋值 x **= y x = x ** y &lt;&lt;= 左移赋值 x &lt;&lt;= y x = x &lt;&lt; y &gt;&gt;= 右移赋值 x &gt;&gt;= y x = x &gt;&gt; y &gt;&gt;&gt;= 无符号右移赋值 x &gt;&gt;&gt;= y x = x &gt;&gt;&gt; y &amp;= 按位与赋值 x &amp;= y x = x &amp; y &#124;= 按位或赋值 x &#124;= y x = x &#124; y ^= 按位异或赋值 x ^= y x = x ^ y 7.2 算术运算符 运算符 名称 运算式 + 加法 x + y - 减法 x - y * 乘法 x * y / 除法 x / y % 求余 x % y ** 幂 x ** y ++ 自增 x++ 或 ++x -- 自减 x-- 或 --x + 一元正号 +x - 一元负号 -x 1 加法 允许非数值的相加12true + true = 21 + true = 2 遇到字符串会变成连接 对象相加，必须先转成原始类型的值12345678var obj = &#123; p: 1 &#125;;obj + 2 // &quot;[object Object]2&quot;// obj.valueOf() 结果为&#123;p:1&#125;// obj.valueOf().toString() 结果为&quot;[object object]&quot;``` ### 2 一元加号/减号* 一元加号/减号运算符的作用在于可以将任何值转为数值 +true // 1+[] // 0+{} // NaN 1234### 3 幂运算符1. 前一个运算子是底数，后一个运算子是指数2. 幂运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算。 2 ** 4 // 16 即2的4次方2 ** 3 ** 2// 512 相当于2** (3 ** 2) 即先求3的2次方=9 再求2的9次方 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172## 7.3 比较运算符### 1 非相等比较运算符|名称|运算式-|-|-`&gt;`|大于|`x &gt; y``&lt;`|小于|`x &lt; y``&gt;=`|大于等于|`x &gt;= y``&lt;=`|小于等于|`x &lt;= y`1. 基本类型 1. 非字符串：先转成数值再比较 2. 字符串：按照字典顺序比较（实际上是比较 Unicode 码点）2. 引用类型 * 先转为基本类型的值，再进行比较### 2 相等比较运算符|名称|运算式-|-|-`==`|相等|` x == y``===`|严格相等|`x === y``!=`|不相等|`x != y``!==`|严格不相等|`x !== y`1. `===` 1. 先比较类型，类型相同再比较值 2. 引用类型比较地址值 3. `NaN`与任何值都不严格相等（包括自己） 4. `undefined`和`null`与自身严格相等 5. `+0` 与 `-0` 严格相等 6. `!==` * 先求`===`的结果，然后返回相反值。2. `==` 1. 比较不同类型的数据时，会先将数据进行类型转换，然后再用`===`比较。 2. `NaN`与任何值都不相等（包括自己） 3. `undefined`和`null`与其他类型的值比较时，结果都为false， 它们之间比较为true 4. `!=` * 先求`==`的结果，然后返回相反值。## 7.4 逻辑运算符运算符|名称|运算式|说明-|-|-|-`&amp;&amp;`|逻辑与|`expr1 &amp;&amp; expr2`|若`expr1`为true，则返回`expr2`的值，否则，返回`expr1`的值，且不再计算`expr2`&lt;code&gt;&amp;#124;&amp;#124;&lt;/code&gt;|逻辑或|&lt;code&gt;expr1 &amp;#124;&amp;#124; expr2&lt;/code&gt;|若`expr1`为false，则返回`expr2`的值，否则，返回`expr1`的值，且不再计算`expr2``!`|逻辑非|`!expr`|若`expr` 为 true，则返回 `false`，否则，返回`true``!!`|双重非|`!!expr`|显式地将任意值强制转换为其对应的布尔值1. 表达式的布尔值与值不是一个概念，如`1 - 1` 返回的值是0，返回的布尔值是false2. 逻辑与和逻辑或存在短路计算，即整个表达式的值在第一个表达式计算后已经确定了，就不再计算第二个。3. 逻辑与的优先级高于逻辑或## 7.5 按位运算符运算符|名称|运算式|说明-|-|-|-`&amp;`|按位与|`x &amp; y`|有0则0&lt;code&gt;&amp;#124;&lt;/code&gt;|按位或|&lt;code&gt;x &amp;#124; y&lt;/code&gt;|有1则1`~`|按位非|`~x`|1变0，0变1`^`|按位异或|`x ^ y`|相同则0，不同则1`&lt;&lt;`|左移|`x &lt;&lt; y`|低位补0，相当于&lt;code&gt;x * 2&lt;sup&gt;y&lt;/sup&gt;&lt;/code&gt;`&gt;&gt;`|右移|`x &gt;&gt; y`|舍去低位，正数高位补0，负数高位补1，相当于&lt;code&gt;x / 2&lt;sup&gt;y&lt;/sup&gt;&lt;/code&gt;`&gt;&gt;&gt;`|无符号右移|`x &gt;&gt;&gt; y`|舍去低位，高位补0，相当于&lt;code&gt;x / 2&lt;sup&gt;y&lt;/sup&gt;&lt;/code&gt;## 7.6 三元运算符* `condition ? exprIfTrue : exprIfFalse` 1. 若`condition` 为true，返回`exprIfTrue`的值，否则，返回`exprIfFalse`的值 2. 和 `if else` 的区别：if...else是语句，没有返回值；三元运算符是表达式，具有返回值。## 7.7 void运算符* `void expression` * 对给定的表达式进行求值，然后返回 undefined * void 运算符通常只用于获取 undefined的原始值，一般使用`void(0)`（等同于`void 0`）* 应用 1. JavaScript URIs * 当url使用`javascript:`协议，点击时，会执行URI中的代码，然后用返回的值替换页面内容，除非返回的值是undefined。 * void运算符可用于返回undefined。 xxx // 不会跳转。xxx // 会跳转只是跳向本页面。 1232. 在箭头函数中避免泄漏 * 箭头函数标准中，允许在函数体不使用括号来直接返回值。 如果右侧调用了一个原本没有返回值的函数，其返回值改变后，则会导致非预期的副作用 * 应该使用 void 运算符，来确保返回 undefined () =&gt; void doSomething(); 1234## 7.8 逗号运算符* `expr1, expr2, expr3...` * 从左到右依次计算每个表达式，并返回最后一个表达式的值 ‘a’, ‘b’ // “b”var x = 0;var y = (x++, 10); // x=1 y=10 123456789## 八 展开语法(Spread syntax)## 8.1 概述1. 展开语法用 `...` 进行表示2. 展开语法在函数调用或构造字面量数组时, 将**可迭代对象**（如数组, string, ...）在语法层面展开；3. 展开语法在构造字面量对象时, 将对象表达式按key-value的方式展开 ## 8.2 应用### 1 函数调用 function show(x, y, z) { }let args = [0, 1, 2];show(…args); // &lt;=&gt; show(0, 1, 2) 1### 2 字面量数组 let arr1 = [0, 1, 2];let arr2 = [3, 4, 5];let arr3 = […arr1, …arr2]; // [0,1,2,3,4,5] 12### 3 字面量对象 let obj1 = { foo: ‘bar’, x: 42 };let obj2 = { foo: ‘baz’, y: 13 };let clonedObj = { …obj1 };// 克隆后的对象: { foo: “bar”, x: 42 }let mergedObj = { …obj1, …obj2 };// 合并后的对象: { foo: “baz”, x: 42, y: 13 } 1234567# 九 剩余参数## 9.1 概述1. 剩余参数是一个数组，用于接收形参外的所有参数2. 剩余参数必须是最后一个参数## 9.2 语法 function(a, b, …theArgs) { // …} 123456789101112## 9.3 剩余参数和 arguments对象的区别1. 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。2. arguments对象不是一个真正的数组，而剩余参数是真正的 Array实例，即剩余参数可以使用所有的数组方法# 十 解构赋值## 10.1 概述1. 解构赋值：从数组和对象中提取值，对变量进行赋值2. 解构对象时会查找原型链（如果属性不在对象自身，将从原型链中查找）## 10.2 解构数组1. 先声明后赋值的解构 let a, b;[a, b] = [10, 20]; // a=10 b=20 12. 声明并赋值的解构 let [a,b] = [10, 20]; // a=10 b=20 13. 默认值 let [a = 3, b = 4] = [1]; // a=1 b=4 14. 变量数量小于值数量时，忽略多余值 let [a, b] = [1, 2, 3, 4]; // a =1 b = 2 15. 可用于交换变量 let a =1;let b = 2;[a, b] = [b, a]; // a=2 b=1 16. 剩余参数 let [a, …b] = [1, 2, 3]; // a=1 b=[2,3] 123## 10.3 解构对象1. 基本语法 let {key:变量} = {key:value}; 123 * `&#123;key:变量&#125;` * 将对象中属性key的值赋值给变量2. 变量名与属性名相同可以简写 let {key:key} = {key:value};let {key} = {key:value}; // 简写 13. 先声明后赋值的解构 let name, age;{name,age} = {name:’an3’, age:18}); // 错误({name, age} = {name:’an3’, age:18}); // name=’an3’ age=18 12 * 赋值时必须使用()包括，因为左边`&#123;name, age&#125;`会被认为是块而不是对象字面量4. 默认值 let {name=’haha’, age=10} = {name:’an3’}; // name=’an3’ age=10let {name:n=’haha’ age:a=10} = {name:’an3’}; // n=’an3’ a=10 15. 变量数量小于值数量时，忽略多余值 let {name=’haha’, age=10} = {name:’an3’,age:10,sex:1}; // name=’an3’ age=18 16. 解构嵌套 let user = { name:’xiaoming’, lesson:{ title:’js’, score:90 }};let {name,lesson:{title,score}} = user; 12345678# 十一 语句## 11.1 &#123;&#125;* `&#123; StatementList &#125;` * 声明块作用域## 11.2 if...else## 11.3 switch switch (expression) { case value1: // 当 expression 的结果与 value1 匹配时，执行此处语句 [break;] case value2: // 当 expression 的结果与 value2 匹配时，执行此处语句 [break;] … case valueN: // 当 expression 的结果与 valueN 匹配时，执行此处语句 [break;] [default: // 如果 expression 与上面的 value 值都不匹配，执行此处语句 [break;]]} 1234* switch内部采用严格相等* 省略break：会继续运行下一个case语句无论值是否匹配## 11.4 for for ([initialization]; [condition]; [final-expression]){ statement} 123456* for循环每次循环都是一个单独的函数作用域 1. 在 for 循环中使用let/const 会在每一次循环重新生成不同的变量 2. 在 for 循环中使用var声明的变量是全局共享的## 11.5 while / do...while## 11.6 label label : statement 123456789* 相当于定位符，用于跳转到程序的任意位置，通常与break语句和continue语句配合使用，break 可用于任何标记语句，而 continue 用于循环标记语句 * `break [label]` 或 `continue [label]`* label ：任何不属于保留关键字的 JavaScript 标识符## 11.7 in* `prop in object` * 判断对象自身或其原型链上是否包含某个属性## 11.8 for...in for (let/const key in object){ // statements} 1234567891. 遍历对象 1. 遍历对象的所有可枚举属性（包括它的原型链上的可枚举属性），属性是否可枚举由属性描述符的`enumerable`决定 2. 每次循环获取的是属性名2. 遍历数组（不推荐） 1. 数组键名是数字，但每次循环获取的是索引的字符串 2. 除了遍历数组元素外，数组本身以及原型链上的可枚举属性也会被遍历到 3. 某些情况下，不能保证按顺序返回索引## 11.9 for...of for (let/const value of iterable) { //statements} 12345678910111213141516171819202122232425262728291. 用来遍历可迭代对象（Array，Map，Set，String，TypedArray，arguments对象，DOM NodeList对象，Generator对象...）2. 每次循环取出的是值# 十二 概念1. 可枚举属性：属性描述符 `enumerable: true` 的属性2. 普通对象：没有数字键和length属性的对象3. 类数组对象：存在数值键名和length属性的对象## 十三 Iterator## 13.1 迭代器* 迭代器就是具有`next()`方法的对象* `next()` * 返回一个对象，返回对象拥有两个属性 1. `value`：当前迭代的值 1. `done`：布尔值，迭代是否结束。 * false表示没结束，`done:false` 可以省略 * true表示结束，此时value为undefined，`value:undefined` 可以省略## 13.2 Iterator 接口1. 一个数据结构只要具有 `Symbol.iterator` 属性，就认为是实现了Iterator接口2. 对象（或者其原型链）上拥有 `Symbol.iterator` 属性，就是可迭代对象## 13.3 Symbol.iterator1. `Symbol.iterator` 本身是一个函数，就是当前数据结构默认的迭代器生成函数。执行这个函数，就会返回一个迭代器2. `Symbol.iterator` 要放在方括号中，因为它作为属性名是一个表达式，返回Symbole对象的iterator属性。## 13.4 for... of1. for... of 内部就是调用了可迭代对象的 `Symbol.iterator` 生成了迭代器2. 自定义for... of function myForOf(arr) { let it = arrSymbol.iterator; let res = it.next(); while(!res.done) { console.log(res.value); res = it.next(); }} ``` 十四 全局函数 encodeURI(URI) 使用UTF-8进行URL编码，编码后的格式为UTF-8编码的每个字节前加% 不会编码的字符 ; , / ? : @ &amp; = + $ 字母 数字 - _ . ! ~ * &#39; ( ) # decodeURI(encodedURI) encodeURI()对应的解码函数 encodeURIComponent(str) 类似encodeURI()，区别在于不会编码的字符。 不会编码的字符 字母 数字 - _ . ! ~ * &#39; ( ) decodeURIComponent(encodedURI) encodeURIComponent()对应的解码函数 isFinite(value) 见 Number.isFinite(value) isNaN(value) 见 Number.isNaN(value) parseInt(string[, radix]) 见 Number.parseInt(string[, radix]) parseFloat(string) 见 Number.parseFloat(string) eval(string)（永远不要使用!） 将传入的字符串当做 JavaScript 代码进行执行 string 如果是表达式，则对表达式进行求值 如果是一个或多个 JavaScript 语句，则执行这些语句","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"Javascript","slug":"UI/Javascript","permalink":"https://anyeansan.github.io/categories/UI/Javascript/"}],"tags":[]},{"title":"Javascript 概述","slug":"Javascript-概述","date":"2020-03-30T14:01:05.000Z","updated":"2020-03-30T14:01:39.502Z","comments":true,"path":"2020/03/30/Javascript-概述/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/Javascript-%E6%A6%82%E8%BF%B0/","excerpt":"","text":"一 前言1.1 概述 跨平台的解释性脚本语言 ECMAScript是规范，JavaScript是实现 1.2 组成 ECMAScript 根据MCMA-262标准，实现的通用脚本语言规范 DOM document object model 文档对象模型 BOM browser object moel 浏览器对象模型 1.3 JavaScript处理引擎 专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器之中 主要浏览器引擎 chrome v8 firefox SpiderMonkey edge chakra Opera Carakan …… 1.4 网页加载流程 - 前端 浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。 css 和 html 是并行加载的，过程中如果遇到css 或者 img，则会向浏览器返回一个请求，待资源返回后，将其添加到dom的相应位置中 解析过程中，浏览器发现&lt;script&gt;元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎（原因是 JavaScript 代码可以修改 DOM，所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题。） 如果&lt;script&gt;元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。 JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页 二 引入JavaScript脚本2.1 JavaScript脚本位置 浏览器加载 JavaScript 脚本，主要通过&lt;script&gt;元素完成 如果外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。所以&lt;script&gt; 最好放在页面底部 即使遇到脚本失去响应，网页主体的渲染也已经完成了，用户至少可以看到内容 在 DOM 结构生成之前就调用 DOM 节点，JavaScript 会报错，如果脚本都在网页尾部加载，就不存在这个问题，因为这时 DOM 肯定已经生成了。 2.2 javascript: 协议 URL 支持javascript:协议，即在 URL 的位置写入代码，使用这个 URL 的时候就会执行 JavaScript 代码。 2.3 JavaScript 脚本引入方式1 内联脚本12345678&lt;button onclick=&quot;alert(&apos;xxx&apos;)&quot;&gt;第一种直接写方法体&lt;/button&gt;&lt;button onclick=&quot;fn()&quot;&gt;第二种传递方法&lt;/button&gt;&lt;script&gt; function fn() &#123; alert(&apos;xxx&apos;); &#125;&lt;/script&gt; 2 内部脚本1234&lt;button&gt;点我&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; document.querySelector(&apos;button&apos;).addEventListener(&apos;click&apos;,() =&gt; alert(&apos;xxx&apos;));&lt;script&gt; type可以省略 默认text/javascript，新的浏览器可以写application/javascript 3 外部脚本1&lt;script src=&quot;xxx.js&gt;&lt;/script&gt; 标签体不能有内容，&lt;/script&gt;不能省略 src 默认是http协议 外部的js文件中不能包含&lt;script&gt;标签。","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"Javascript","slug":"UI/Javascript","permalink":"https://anyeansan.github.io/categories/UI/Javascript/"}],"tags":[]},{"title":"MongoDB","slug":"MongoDB","date":"2020-03-30T13:57:12.000Z","updated":"2020-03-30T13:57:31.234Z","comments":true,"path":"2020/03/30/MongoDB/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/MongoDB/","excerpt":"","text":"一 安装 下载解压，并修改属主属组 关闭 Linux 大页内存 THP（transparent huge pages） https://docs.mongodb.com/v3.6/tutorial/transparent-huge-pages/ 创建所需用户和用户组 创建存储目录并修改属主属组 data directory log file conf directory 设置用户环境变量 切换到创建用户 修改用户目录下 .bash_profile1export PATH=basedir/bin:$PATH source .bash_profile 二 配置 在指定的 conf directory 下创建配置文件1234567891011121314151617# YAML 模式配置 模板systemLog: destination: file path: /var/log/mongodb/mongod.log logAppend: truestorage: journal: enabled: true dbPath: processManagement: fork: true # 后台守护进程 pidFilePath: # pid文件位置，建议不配置，直接生成到data下net: bindIp: 127.0.0.1 # 监听地址，默认 0.0.0.0 port: 27017security: authorization: enabled # 用户验证 三 启动与关闭 mongod3.1 启动 mongod -f 配置文件 启动 3.2 关闭 mongod -f 配置文件 --shutdown 关闭 db.shutdownServer() kill -2 &lt;mongod process ID&gt; 四 登录与退出 mongo -u -p ip/验证库 exit 五 概述5.1 逻辑结构 概念 说明 database 库 collection 表（集合） document 文档（数据行） field 字段 index 索引 primary key 主键，MongoDB自动将 _id 字段设置为主键 * 文档数据都是 BSON 格式。 * BSON 是一种类似 JSON 的二进制形式的存储格式，是 Binary JSON 的简称 5.2 默认库 test 登录时默认所在库 admin 系统预留库，MongoDB系统管理库 local 本地预留库，存储关键日 config MongoDB配置信息库 六 操作6.1 库操作1 帮助 db.help() 帮助 db.[tab][tab] 两次 tab 2 查 show dbs / show databases db 相当于 select database() db.status() 3 增 use db_name 若存在，切换到数据库， 若不存在，则创建并切换（注意库中存有数据才会显示在数据库列表中） 4 删 db.dropDatabase() 6.2 集合操作1 查 show collections / show tables 2 增 db.createCollection(name, options) name 集合名称 options capped false ：默认 true ：创建固定大小的集合，当达到最大值时，它会自动覆盖最早的文档，必须指定 size 参数 size 为固定集合指定一个最大值（KB） max 指定固定集合中包含文档的最大数量 autoIndexId false ：默认 true ：自动在 _id 字段创建索引 3 删 db.collection.drop() 6.3 文档操作1 增 db.collection_name.insertOne() 如果指定 collection 不存在，则会创建 db.collection_name.insertMany() 2 删 db.collection_name.deleteOne() db.collection_name.deleteMany() 4 改 db.collection_name.updateOne() db.collection_name.updateMany() db.collection_name.replaceOne() 4 查1 语法 db.collection_name.find()[.limit()][.pretty()] 查询所有 .pretty() 以 json 格式显示结果 2 比较 格式 说明 {key:value} 等于 {key:{$ne:value}} 不等于 {key:{$lt:value}} 小于 {key:{$lte:value}} 小于等于 {key:{$gt:value}} 大于 {key:{$gte:value}} 大于等于 3 and12345&#123; key:value, key:value, ...&#125; 4 or1234567&#123; $or: [ &#123;key:value&#125;, &#123;key:value&#125;, ... ]&#125; 七 用户管理7.1 概述 验证库 登陆时要指定验证库才能登录，验证库即创建用户时 user 到的库 管理员验证库为 admin，即管理员必须在 admin 库下创建 普通用户在所管理的库下创建 7.2 创建用户12345678910111213user db_name # 指定验证库db.createUser(&#123; user: &quot;用户名&quot;, pwd: &quot;密码&quot;, roles: [ &#123;role: &quot;root&quot;, db: &quot;admin&quot;&#125;, # 用来创建管理员 &#123;role: &quot;read&quot;, db: &quot;数据库&quot;&#125;, &#123;role: &quot;readWrite&quot;, db: &quot;数据库&quot;&#125; ]&#125;)db.auth(&apos;username&apos;,&apos;password&apos;) # 验证用户 7.3 查看用户1db.system.users.find().pretty() 7.4 删除用户（管理员登录）12user db_name db.dropUser(&quot;username&quot;)","categories":[{"name":"DB","slug":"DB","permalink":"https://anyeansan.github.io/categories/DB/"},{"name":"MongoDB","slug":"DB/MongoDB","permalink":"https://anyeansan.github.io/categories/DB/MongoDB/"}],"tags":[]},{"title":"MySql 数据库设计","slug":"MySql-数据库设计","date":"2020-03-30T13:50:13.000Z","updated":"2020-03-30T13:50:53.773Z","comments":true,"path":"2020/03/30/MySql-数据库设计/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/MySql-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"一 范式概述 Normal Format 是一种离散数学中的知识, 是为了解决一种数据的存储与优化的问题: 保存数据的存储之后, 凡是能够通过关系寻找出来的数据,坚决不再重复存储: 终极目标是为了减少数据的冗余. 范式是一种分层结构的规范, 分为六层: 每一次层都比上一层更加严格: 若要满足下一层范式,前提是满足上一层范式. 1NF,2NF,3NF…6NF 1NF是最底层,要求最低;6NF最高层,最严格 二 1NF 第一范式: 在设计表存储数据的时候, 如果表中设计的字段存储的数据,在取出来使用之前还需要额外的处理(拆分),那么说表的设计不满足第一范式 第一范式要求字段的数据具有原子性: 不可再分 解决 拆分字段 二 2NF 第二范式: 在数据表设计的过程中,如果有复合主键(多字段主键), 且表中有字段并不是由整个主键来确定, 而是依赖主键中的某个字段(主键的部分): 存在字段依赖主键的部分的问题, 称之为部分依赖: 第二范式就是要解决表设计不允许出现部分依赖 解决 可以将复合主键字段单独成表 取消复合主键，使用逻辑主键 三 3NF 第三范式: 理论上讲,应该一张表中的所有字段都应该直接依赖主键(逻辑主键: 代表的是业务主键), 如果表设计中存在一个字段, 并不直接依赖主键,而是通过某个非主键字段依赖,最终实现依赖主键: 把这种不是直接依赖主键,而是依赖非主键字段的依赖关系称之为传递依赖 第三范式就是要解决传递依赖的问题. 解决 将存在传递依赖的字段,以及依赖的字段本身单独取出,形成一个单独的表, 然后在需要对应的信息的时候, 使用对应的实体表的主键加进来.","categories":[{"name":"DB","slug":"DB","permalink":"https://anyeansan.github.io/categories/DB/"},{"name":"MySql","slug":"DB/MySql","permalink":"https://anyeansan.github.io/categories/DB/MySql/"}],"tags":[]},{"title":"MySql 触发器","slug":"MySql-触发器","date":"2020-03-30T13:47:22.000Z","updated":"2020-03-30T13:49:45.541Z","comments":true,"path":"2020/03/30/MySql-触发器/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/MySql-%E8%A7%A6%E5%8F%91%E5%99%A8/","excerpt":"","text":"一 概述 事先为某张表绑定好一段代码 ,当表中的某些内容发生改变的时候(增删改)系统会自动触发代码,执行 一张表中只能拥有一种触发时间的一种类型的触发器 一张表最多能有6个触发器 增删改/前后 6种组合 二 事件类型 增(insert) 删(delete) 改(update) 三 触发时间 前(before) 后(after) 四 触发对象 表中的每一条记录(行) 五 创建触发器1234567891011121314-- 临时修改语句结束符Delimiter 自定义符号: 后续代码中只有碰到自定义符号才算结束Create trigger 触发器名字 触发时间 事件类型 on 表名 for each rowBegin -- 代表左大括号: 开始-- 里面就是触发器的内容: 每行内容都必须使用语句结束符: 分号End -- 代表右带括号: 结束-- 语句结束符自定义符号-- 将临时修改修正过来Delimiter ; 六 查看触发器 Information_schema.triggers 所有的触发器都会保存这一张表中 Show triggers [like ‘pattern’] 查看所有或者模糊匹配 Show create trigger 触发器名 查看触发器创建语句 七 使用触发器 不需要手动调用, 而是当某种情况发生时会自动触发. 八 修改&amp;删除触发器 触发器不能修改 Drop trigger 触发器名 删除","categories":[{"name":"DB","slug":"DB","permalink":"https://anyeansan.github.io/categories/DB/"},{"name":"MySql","slug":"DB/MySql","permalink":"https://anyeansan.github.io/categories/DB/MySql/"}],"tags":[]},{"title":"MySql 存储过程","slug":"MySql-存储过程","date":"2020-03-30T13:45:27.000Z","updated":"2020-03-30T13:47:02.093Z","comments":true,"path":"2020/03/30/MySql-存储过程/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/MySql-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/","excerpt":"","text":"一 概述 SQL 的执行过程 sql语句 → mysql引擎 → 检查语法 → 编译 → 执行 → 返回结果 存储过程是一组为了完成特定功能的sql语句和流程控制语句的预编译集合，存储在数据库内，可以由应用程序调用。 存储过程的好处 可复用 预编译：只在创建时编译一次，以后调用时不再编译，速度快 减少网络流量：存储过程存储在数据库服务器上，都在数据库服务器上运行，调用存储过程时只需要传递名称和参数即可。 安全：可防止sql注入。 二 语法12345678CREATE [DEFINER = user] PROCEDURE sp_name ([proc_parameter[,...]]) [characteristic ...] routine_bodyproc_parameter: [ IN | OUT | INOUT ] param_name type 三 创建1234567DROP PROCEDURE IF EXISTS 存储过程名;DELIMITER [结束标记]CREATE PROCEDURE 存储过程名([参数列表])BEGIN [存储过程体(一组合法的SQL语句)]END [结束标记]DELIMITER ; 形参 in 输入参数，调用存储过程时传入的值 out 输出参数，可在存储过程内部被改变并返回。 into 使用 into 为out参数赋值 inout 输入输出参数，调用存储过程时传入值，在存储过程内部可以改变并返回。 返回值 存储过程可以有返回值也可以没有返回值。 四 查看 show procedure status [like ‘pattern’] 查看所有存储过程或模糊匹配 show create procedure 过程名 查看过程创建语句: 五 调用 call 存储过程名(in参数, @out参数, @inout参数) 存储过程没有返回值（通过out返回），不能用select调用。 实参 in参数：直接传递即可 out参数：定义一个变量接收返回值@变量名 inout参数：在外部定义一个变量，并设置值 123456789// incall inpr(3);// outcall outpr(@name);select @name;// inoutset @age = 10;call inoutpr(@age);select @age; 六 修改&amp;删除 存储过程不可修改 删除 drop procedoure [if exists] 存储过程名 七 存储过程和自定义函数的区别 存储过程实现的功能更复杂，函数的针对性更强 存储过程可以返回多个值，函数只能返回一个值 存储过程一般单独执行，函数可以作为其它sql语句的组成部分。","categories":[{"name":"DB","slug":"DB","permalink":"https://anyeansan.github.io/categories/DB/"},{"name":"MySql","slug":"DB/MySql","permalink":"https://anyeansan.github.io/categories/DB/MySql/"}],"tags":[]},{"title":"MySql 视图","slug":"MySql-视图","date":"2020-03-30T13:41:53.000Z","updated":"2020-03-30T13:45:10.673Z","comments":true,"path":"2020/03/30/MySql-视图/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/MySql-%E8%A7%86%E5%9B%BE/","excerpt":"","text":"一 概述 view可以看作是一张虚拟表，是表通过某种运算得到的一个投影。 视图中并没有真正存储数据。 表的改变会影响视图(视图就好像表的影子一样) 视图的改变也能影响表。(如果可以改变的话) 可以跟基本表一样，进行增删改查操作 二 数据操作 主要是用来查询 增删改操作有条件限制 如果视图的数据与表的数据是一一对应出来的，改变不会影响其它数据，就可以增删改。 如果视图的数据是通过计算得来的，改变则会影响表中的其它数据，不可以增删改。 三 视图作用 方便操作，特别是查询操作，减少复杂的SQL语句 将一条复杂的查询语句使用视图进行保存: 以后可以直接对视图进行操作 数据安全 视图操作是主要针对查询的, 如果对视图结构进行处理(删除), 不会影响基表数据(相对安全). 可以对外提供有用的数据, 但是隐藏关键(无用)的数据 数据库授权命令不能限定到特定行和特定列，但是通过合理创建视图，可以把权限限定到行列级别 权限控制 不希望用户访问表中某些含敏感信息的列,可以通过view开放某几个列 数据过多时，分表用 四 视图操作4.1 创建视图 create view 视图名 as select语句 4.2 查看视图 show create table/view 视图名 show tables [like]/desc 视图名 视图是一张虚拟表，表的所有查看方式，视图都能用，且视图比表多一个关键字view 4.3 修改视图 alter view 视图名 as 新的select语句 视图本身不可修改，但视图来源可以修改 4.4 删除视图 drop view 视图名 五 视图算法(algorithm)5.1 概述 系统对视图以及外部查询视图的Select语句的一种解析方式 create algorithm=xxx view 视图名 as select 语句 是对标准sql的mysql的扩展 5.2 分类 undefined 未定义(默认的), 这不是一种实际使用算法, 是一种推卸责任的算法: 告诉系统,视图没有定义算法, 系统自己看着办 未定义由系统定义，它倾向于MERGE而不是TEMPTABLE 因为MERGE通常更有效，而且如果使用了临时表，视图是不可更新的。 temptable 临时表算法: 系统应该先执行视图的select语句,后执行外部查询语句 视图的结果将被置于临时表中，然后使用它执行语句 适合复杂查询形成的view merge 合并算法: 系统应该先将视图对应的select语句与外部查询视图的select语句进行合并,然后执行(效率高: 常态) 将查询视图的语句与视图定义语句合并起来 查询视图的语句+视图定义语句=查询物理表的语句 合并查询语句，不会创建临时表 适合简单查询形成的view 5.3 算法选择 如果视图的select语句中会包含一个查询子句(五子句), 而且很有可能顺序比外部的查询语句要靠后, 一定要使用算法temptable,其他情况可以不用指定(默认即可)","categories":[{"name":"DB","slug":"DB","permalink":"https://anyeansan.github.io/categories/DB/"},{"name":"MySql","slug":"DB/MySql","permalink":"https://anyeansan.github.io/categories/DB/MySql/"}],"tags":[]},{"title":"MySql 日志","slug":"MySql-日志","date":"2020-03-30T13:39:18.000Z","updated":"2020-03-30T13:41:38.004Z","comments":true,"path":"2020/03/30/MySql-日志/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/MySql-%E6%97%A5%E5%BF%97/","excerpt":"","text":"一 日志分类 类型 说明 Error log 错误日志 Binary log 二进制日志 Slow query log 慢查询日志 General query log 常规日志 二 错误日志 默认开启 默认存储位置 datadir/hostname.err select @@log_error 查看错误日志位置 手动配置 /etc/my.cnf12[mysqld]log_error=路径 三 二进制日志3.1 作用 主从环境必须依赖二进制日志 备份恢复必须依赖二进制日志 3.2 配置 默认没有开启 手动配置 /etc/my.cnf12345678910111213[mysqld]1 server_id= # 服务ID号 0 ~ 655352 log_bin=1 # 开启二进制日志3 log_bin_basename=/目录/二进制日志文件名前缀 # 设置存储目录及文件前缀4 log_bin=/目录/二进制日志文件名前缀 # 等同于 2,3两步5 binlog_format=row # 二进制日志格式，5.7 默认配置，可以省略6 sync_binlog=1 # 每次提交都立即刷写binlog到磁盘 3.3 二进制日志记录内容1 内容 记录了数据库所有变更类的操作日志 DDL：原封不动的记录当前 DDL（statement 语句方式），即原样记录语句 DCL：原封不动的记录当前 DCL（statement 语句方式） DML：只记录已经提交的事务 DML 2 DML 记录模式 statment SBR（statement based replication）模式 语句模式，原封不动的记录当前DML 可读性较高，日志量少，但是不够严谨 row RBR（ROW based replication）模式 记录数据行的变化（用户看不懂，需要工具分析） 可读性很低，日志量大，足够严谨 mixed MBR（mixed based replication）模式 以上两种模式的混合 3.4 二进制日记记录单元 event1 概述 event 是二进制日志的最小记录单元 DDL DCL 一个语句就是一个 event DML ：只记录已提交的事务 begin 是一个 event DML 语句的 event commit 是一个 event 2 event 组成 事件的开始标识：position 号 事件内容 事件的结束标识：end_log_position 号 3.5 二进制日志 操作1 查看信息 show variables like &#39;%log_bin%&#39; 查看二进制日志路径 show binary logs 查看所有二进制日志 show master status 查看当前使用的二进制日志 show binlog events in &#39;log_name&#39; [from pos] [limit] 查看二进制日志 event 信息 2 查看内容 mysqlbinlog mysqlbinlog [OPTION] 日志路径 --base64-output=decode-rows 以指定格式输出 -vvv 更详细 --start-position 开始位置 --stop-position 结束位置 -d db_name 只查看指定库的日志 3 恢复 mysqlbinlog --start-position= --stop--position= &gt;/tmp/log.sql 将指定位置的二进制日志内容截取出来输出到一个文件，其实就是sql脚本，执行即可 set sql_log_bin=0 临时关闭二进制日志，因为恢复时也会产生二进制日志，没有必要 source /tmp/log.sql set sql_log_bin=1 3.6 GTID 模式管理二进制日志1 概述 GTID Global Transaction ID 对二进制日志中每一个事务，自动生成一个 GTID 号 DDL DCL 一个 event 就是一个事务，就有一个 GTID DML 一个事务（从 begin 到 commit）一个 GTID GTID 幂等性 使用有 GTID 的二进制日志做恢复时，会检查当前系统是否有相同的 GTID，若有则跳过不再执行。 会影响恢复和主从复制 2 配置 默认未开启 /etc/my.cnf123[mysqld]gtid-mode=onenforce-gtid-consistency=true 3 GTID 组成 server_uuid:transaction_id server_uuid 启动 mysql 自动生成，存储在 datadir/auto.cnf transaction_id 从 1 开始，自增长 4 查看有 GTID 的日志内容 mysqlbinlog [OPTION] 日志路径 OPTION --incude-gtids 包含指定 gtid，多个逗号隔开，连续可以 server_uuid:1-8 --exclude-gtids 排除指定 gtid --skip-gtids 由于 gtid 的幂等性，导出的 sql 执行时会报错，因为已经存在相同 gtid 此选项表示：导出时，忽略原有的 GTID 信息，恢复时当作新事务对待 5 基于 GTID 的恢复 mysqlbinlog --skip-gtids --include-gtids= 日志路径&gt;/tmp/log.sql set sql_log_bin=0 source /tmp/log.sql set sql_log_bin=1 3.7 二进制日志清理1 自动清理 expire_logs_days 二进制日志过期天数，0 表示永不过期 建议至少保留两个全备周期 +1 2 手动清理 purge binary logs to &#39;log_name&#39; 删除指定日志之前的日志 purge binary logs before &#39;time&#39; 删除指定日期之前的日志 3.8 日志滚动 flush logs 重启 mysql 会自动滚动一个新的 日志文件达到 max_binlog_size 四 慢查询日志4.1 概述 记录运行较慢的 SQL语句，优化常用 4.2 配置 默认未开启 /etc/my.cnf123456789[mysqld]1 slow_query_log=1 # 开启 2 slow_query_log_file=/目录/文件 # 日志文件路径3 long_query_time=0.1 # 设置慢查询时间，超过此时间就算慢，默认 10.000000 10秒，小数位表示粒度4 log_queries_not_using_indexes # 没走索引的语句也记录 4.3 分析 mysqldumpslow -s c -t N 日志路径 -s c sort，按次数排序 -t N top，取前多少个 4.4 相关参数 slow_query_log long_query_time log_throttle_queries_not_using_indexes","categories":[{"name":"DB","slug":"DB","permalink":"https://anyeansan.github.io/categories/DB/"},{"name":"MySql","slug":"DB/MySql","permalink":"https://anyeansan.github.io/categories/DB/MySql/"}],"tags":[]},{"title":"MySql 事务","slug":"MySql-事务","date":"2020-03-30T13:37:10.000Z","updated":"2020-03-30T13:39:01.377Z","comments":true,"path":"2020/03/30/MySql-事务/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/MySql-%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"一 ACID 特性特性||说明-|-原子性 Atomicity|一个事务是一个不可分割的单元，事务中的操作要么都成功，要么都取消一致性 Consistency|事务的执行不能破坏数据库数据的完整性和一致性隔离性 Isolation|事务之间是互不干扰的持久性 Durability|一个事务一旦被提交，它对数据库中数据的改变就是永久性的 二 事务的生命周期2.1 标准生命周期 begin DML（insert update delete） commit | rollback 2.2 autocommit 默认 atutocommit = 1 即开启自动提交 执行 DML 时会自动开启事务并提交 关闭自动提交 set autocommit = 0 会话级别 set global autocommit = 0 全局级别，影响所有会话，重启失效 vim /etc/my.cnf 中添加 autocommit=0 永久生效 2.3 隐式提交 开启事务后，在事务中执行一些语句会触发隐式提交（应避免） DDL（alte create drop truncate） DCL（grant revoke set password） 锁（lock tables unlock tables） … 三 事务原理3.1 概念 redo log 保存在 ib_logfile0~1 默认50M，轮询使用 redo log buffer redo log 缓冲区 ibd 存储数据行和索引 data bufer pool 数据和索引的缓冲区 LSN 日志序列号（redo log 及其缓冲区， ibd 及其缓冲区 都有LSN） MySQL 每次启动都会比较 ibd 和 redo log 的 LSN，两者必须一致数据库才能正常启动 WAL（write ahead log） 持久化的实现机制（日志优先于数据写入磁盘） 脏页 内存中发生了修改，没写入到磁盘之前，把内存页称之为脏页 CKPT（checkpoint） 检查点,就是将脏页刷写到磁盘的动作 TXID 事务号，InnoDB会为每一个事务生成一个事务号，伴随着整个事务 3.2 原理 开启事务后，DML 将 ibd 按照数据页（16kb）为单位读取到内存 data bufer pool 进行操作。 undo log 会记录数据的原始状态以及事务 ID redo log buff 会记录内存数据页的变化、LSN 号以及事务ID 操作正常 commit 优先将 redo log buff 写入 redo log（WAL） 将内存数据的改变写入磁盘 如果 commit 之后出现意外（如断电，断开连接 …），再次重启时可以根据 redo log 进行同步（因为都有 LSN，类似于版本号，所以知道哪个是新版本） 操作未正常完成（如断电，断开连接 rollback …） 不写入 redo log，也不写入数据 四 锁4.1 悲观锁1 概述 数据库提供实现 悲观的认为别人一定会修改我使用的数据，我就未为我使用的数据加锁，防止别人修改 2 锁粒度划分 表锁 开销小，加锁快；不会出现死锁；但锁粒度大，锁冲突概率高，并发度低 行锁 开销大，加锁慢；会出现死锁；锁定粒度小，锁冲突概率低，并发度高。 3 锁机制划分 读锁/共享锁 其他事务可以读，但不能写 写锁/排他锁 其他事务不能读取，也不能写 4.2 乐观锁 需要自己实现 乐观的认为数据一般是不会造成冲突的。只有在提交数据的时候，才会对数据的冲突进行检测 类似与 版本控制（git / svn），会有一个版本号，在提交时会对比版本号，如果冲突则不能提交。 例： id=1 money=100 version=1甲乙同时操作money-10 甲先提交id=1 money=90 version=2提交成功。 乙后提交id=1 money=90 version=2提交失败 乙需要从新查询，然后修改提交id=1 money=80 version=3 五 隔离级别5.1 问题1 脏读 在一个事务中读取到了另一个事务未提交的数据。 例 我开启事务查看工资，老板开启事务发工资 本来是 1 万，老板多按了个 0 发了 10 万，老板没有提交事务，但我却看到发了 10 万，高兴坏了。 然后老板发现错了，回滚了，最后实际还是发了 1 万，我白高兴了，这肯定不合适。 在这个过程中我读到了老板未提交的数据，就是 脏读 2 不可重复读 在一个事务中读取到了另一个事务已提交的数据（update），导致在一个事务中多次读取结果不一样 例 我开启事务查看卡里有多少钱，发现还有 1 万 此时我媳妇开启事务从卡里转走了 1 万并提交了。 然后我想确认一下，又查了一遍，发现没钱了，我懵逼了。 如果此时媳妇又转回来 5000，我再查一遍，发现余额是 5000，那我一定觉得自己疯了 在这个过程中我读到了媳妇提交的更新数据，就是 不可重复读 3 幻读 在一个事务中读取到了另一个事务已提交的数据（insert），导致在一个事务中多次读取结果不一样 例 我开启事务查看班级里多少人的成绩已经录入，发现录入了 24 条数据 此时老师开启事务又录入了一条 然后我打印出来发现有 25 条数据 在这个过程中我读到了 老师提交的插入数据，就是 幻读 5.2 隔离级别分类 隔离级别 脏读 不可重复读 幻读 read uncommitted √ √ √ read committed × √ √ repeatable read × × √ serializable × × × * repeatable read * 是MySQl 默认 隔离级别 * 有可能出现幻读，可通过 gap + next lock 来防止幻读 5.3 设置隔离级别 select @@tx_isolation 查看隔离级别 repeatable read set transaction isolation lever 隔离级别 设置隔离级别（会话级别） 必须在开启事务之前 vim /etc/my.cnf 添加 transaction_isolation=隔离级别 永久设置","categories":[{"name":"DB","slug":"DB","permalink":"https://anyeansan.github.io/categories/DB/"},{"name":"MySql","slug":"DB/MySql","permalink":"https://anyeansan.github.io/categories/DB/MySql/"}],"tags":[]},{"title":"MySql 索引","slug":"MySql-索引","date":"2020-03-30T13:34:48.000Z","updated":"2020-03-30T13:36:56.837Z","comments":true,"path":"2020/03/30/MySql-索引/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/MySql-%E7%B4%A2%E5%BC%95/","excerpt":"","text":"一 概述 系统根据某种算法，将已有的数据（或未来可能新增的数据）单独建立一个文件，此文件能够实现快速的匹配数据，并且能够快速的找到对应表中的记录 几乎所有的索引都是建立在字段之上 索引本身会产生索引文件(有时候有可能比数据文件还大)，会占用磁盘空间. 索引类似书或字典前边的目录，提升查询速度，但是增删改时，索引也要动态的维护，降低了效率。 二 作用 优化查询 如果某个字段需要作为查询的条件经常使用，那么可以使用索引 约束数据的有效性 如果某个字段需要进行数据的有效性约束, 也可能使用索引（主键,唯一键 …） 三 索引分类（算法） 算法 说明 B-tree B 树索引 FullText 全文索引 Hash 哈希索引 GIS 地理位置索引 R-tree R 树索引 B-tree B-tree B+tree B*tree Mysql 默认 四 索引分类（物理/功能）4.1 辅助索引 / 普通索引（secondary index） 辅助索引手动生成，基于表中的列（索引键）生成B树结构 提取列的所有索引键，进行排序 将排序后的索引键均匀的分布在叶节点中，且叶节点中生成索引键对应表数据的指针 根据叶节点生成枝节点和根节点，生成树结构。 4.2 聚集索引 聚集索引由数据库自动生成 Mysql 自动选择主键列作为聚集索引列，没有主键则选择唯一键（如果都没有，会生成隐藏的） Mysql 存储数据时，会按照聚集索引列值的顺序存储数据行（又称之为聚集索引组织表） 将排好序的数据行作为叶节点，进而生成树结构。 查询时 根据辅助索引的B树，查找到辅助索引键 进而找到辅助索引键对应表数据的指针（即聚集索引键，通常为主键 ID） 根据聚集索引的B树，查找到聚集索引键 而聚集索引的叶节点其实就是表数据，所以就查找到了聚集索引键对应的表数据 4.3 区别 表中任何一列都可以创建辅助索引，且可以有多个（不重名即可） 一张表聚集索引只能有一个，通常是主键列 辅助索引叶节点存储 索引列的值（索引键） 聚集索引列的值（聚集索引键） 聚集索引叶节点存储 有序的整行数据 mysql 的表数据存储的是聚集索引组织表 五 索引分类（逻辑） 主键索引 primary key 唯一索引 unique key 普通索引 index / key 单列索引 多列索引（联合索引） 前缀索引 建索引时，可以只索引列的一部分内容 全文索引 full text 六 索引操作6.1 查 desc 表名 key 列显示索引信息 PRI ：主键索引 UNI ：唯一索引 MUL ：普通索引 show index from 表名 显示索引详细信息 6.2 增1 普通索引 alter table 表名 add index 索引名(列1[(lenght)][,列2, ...]) 创建单列/双列/前缀 普通索引 create index 索引名 on 表名(列1(lenght)][,列2, ...]) 2 唯一索引 alter table 表名 add unique index 索引名(列名) create unique index 索引名 on 表名(列名) 6.3 删 alter table 表名 drop index 索引名 drop index 索引名 on 表名 七 执行计划7.1 概述 SQL 层解析器会生成多个执行计划，优化器会选择最优的执行计划 执行计划分析 就是在执行前获取这个最优执行计划，查看其计划信息，可以有效的防止性能较差的语句带来的性能问题 7.2 获取执行计划 desc sql语句 explain sql语句 7.3 执行计划分析 table 查询所操作的表 type 全表扫描：all 不走索引 没有查询条件，或者查询条件列无索引 查询结构集是原表中的大部分数据，一般25%以上 ! not 普通索引列 like %xxx 联合索引有时只走部分索引 索引扫描（性能依次变好） index 全索引扫描 无条件查询索引列 select id from t range 索引范围扫描 &gt; &gt;= &lt; &lt;= between and or in() like xxx% ! not 主键索引或唯一索引列 ref 普通索引列的等值查询 eq_ref 在多表连接时，子表（被连接表）使用主键列或者唯一列作为连接条件 consist(system) 主键索引或唯一索引列的等值查询 null possible_key 可能会用到的索引 key 真正使用的索引 key_len 索引最大预留长度 extra using filesort 说明查询中有关排序的条件列没有合理的应用索引，因为索引本身已经是有序的 7.4 联合索引1 联合索引说明 优化器会自动对查询条件按照索引创建时的顺序排序 最终使用的索引列是排序后连续的等值比较查询 也就是说碰到不连续的或者非等值比较查询（&gt; &gt;= &lt; &lt;= like …）就会停止 例：创建联合索引 inx_haha(a,b,c,d) 查询条件是 b= c= a= d=，排序后 a= b= c= d=，最终使用的索引列 abcd 查询条件是 b= a= d=，排序后 a= b= d=，最终使用的索引列 ab 查询条件是 c= a= d=，排序后 a= c= d=，最终使用的索引列 a 查询条件是 b&gt; a= c= d=，排序后 a= b&gt; c= d=，最终使用的索引列 ab 2 联合索引优化 创建联合索引时唯一键多的列放在最左侧 创建联合索引时等值比较的列放在最左侧 如果查询中出现多种子句（where group by …），要按照子句的执行顺序建立索引 7.5 索引应用规范 建表必须有主键，一般是个无关列，自增值 经常需要where 、ORDER BY、GROUP BY,join on等操作的列建立索引， 值长度较长的列，建议使用前缀索引 索引不是越多越好，不要创建无用索引，不常使用的索引要清理 索引维护避开业务繁忙期 小表不建索引 联合索引优化","categories":[{"name":"DB","slug":"DB","permalink":"https://anyeansan.github.io/categories/DB/"},{"name":"MySql","slug":"DB/MySql","permalink":"https://anyeansan.github.io/categories/DB/MySql/"}],"tags":[]},{"title":"MySql 元数据和语法","slug":"MySql-元数据和语法","date":"2020-03-30T13:32:42.000Z","updated":"2020-03-30T13:33:53.886Z","comments":true,"path":"2020/03/30/MySql-元数据和语法/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/MySql-%E5%85%83%E6%95%B0%E6%8D%AE%E5%92%8C%E8%AF%AD%E6%B3%95/","excerpt":"","text":"一 概述 元数据可以简单理解为描述数据的数据，除了存储在数据库中的数据外，大多可以理解为元数据 元数据存储在“基表”中，不能直接访问 infomation_schema 表中保存了大量元数据查询的视图 show 命令是封装好的，提供元数据查询的基础功能 二 information_schema2.1 schemata 存储当前 mysql 实例中所有数据库的信息。 show databases 命令从这个表获取数据 2.2 tables 存储数据库中的表信息（包括视图），包括表属于哪个数据库，表的类型、存储引擎、创建时间等信息。 show tables [from db_name] 命令从这个表获取结果 列 说明 table_schema 表所在库名 table_name 表名 engine 存储引擎 table_rows 总行数 avg_row_length 行平均长度 index_length 索引长度 表大小 = avg_row_length * table_rows + index_length 2.3 columns 存储数据库中每张表的列信息，会记录这列是属于哪张表( TABLE_NAME )、以及哪个库( TABLE_SCHEMA )、这列的数据类型是什么、列的注释( COLUMN_COMMENT )等信息 2.4 statistics 存储表索引信息 2.5 collations 存储了字符集和校对集对照信息 三 show show databases 查看所有库名 show tables [from db_name] 查看库中所有表名 show create database db_name 查看建库语句 show create table t_name 查看建表语句 show processlist 查看数据库连接情况 show charset 查看支持的字符集 show collation 查看支持的校对集 show engines 查看支持的存储引擎 show grants for user_name 查看用户权限 shwo variables [like pattern] 查看变量信息 show index from t_name 查看表的索引信息 show engine innodb statsu\\G 查看 innodb 引擎详细状态信息（横向） show status [like pattern] 查看数据库状态信息 show binary logs 查看二进制日志的列表信息 show binlog events in log_name 查看二进制日志的事件信息 show master status 查看 mysql 当前使用的二进制日志信息 show relaylog events in log_name 查看中继日志的事件信息 四 语法4.1 运算符1 数学运算符 运算符 说明 + 加 - 减 * 乘 / 除 DIV 整除 % MOD 模 2 比较运算符 运算符 说明 &gt; 大于 &gt;= 大于等于 &lt; 小于 &lt;= 小于等于 = 等于，null = null 返回 null &lt;=&gt; 等于，null = null 返回 1 &lt;&gt; != 不等于 3 逻辑运算符 运算符 说明 and &amp;&amp; 逻辑与 or &#124;&#124; 逻辑或 not ! 逻辑非 xor 逻辑异或 4.2 变量1 系统变量1 查看系统变量 show [session | global] variables [like pattern] 查看变量信息 select @@变量名 查看具体变量 2 修改系统变量 Set @@session.变量名 = 值 会话级别 Set @@global.变量名 = 值 全局级别（仅影响新会话，重启失效） 2 自定义变量1 概述 为了区分系统变量, 规定用户自定义变量必须使用一个 @ 符号 所有自定义的变量都是会话级别 所有自定义变量不区分数据库(用户级别) 2 作用域 全局变量 set @变量名 = 值 声明并赋值 select @变量名 := 使用 select 赋值，但必须使用 := select @变量名 查看变量值 局部变量 declare 变量名 类型 [default 默认值] 局部变量需要先声明 赋值与查看与全局变量一致 4.3 函数1 信息函数 user() 返回当前用户及所在主机 database() 返回当前数据库名 version() 返回数据库的版本号 connection_id() 连接id last_insert_id() 最后插入记录的id 2 数字函数 abs(X) 绝对值 ceil(X) 向上取整 floor(X) 向下取整 round(X[, D]) 四舍五入 D 小数位数 truncate(X, D) 数字截取 D 小数位数 conv(X, from_base, to_base) 将x从进制from_base转为进制to_base的字符串。 X 可以数字或数字的字符串 mod(N, M) 等价于 N % M 或者 N MOD M 3 字符串函数 concat(str1, str2, ...) 将一个或多个参数连接为字符串 参数为数字会被转成字符串 如果有一个参数为null，则返回null concat_ws(separator, str1, str2, ...) 使用指定分隔符将一个或多个参数连接为字符串 format(X, D) 将一个数字X格式化为类似#,###,###.##形式的字符串，小数位数由D指定 length(str) 返回字符串长度 lower(str) 转小写 upper(str) 转大写 trim([{both | leading | trailing}] [remstr from] str) 去除str两端空格 both|leading|trailing 默认为both，可指定左右 remstr 默认空格，可以指定去除字符 ltrim(str) 去除str左端空格 rtrim(str) 去除str右端空格 reverse(str) 反转str left(str, len) 返回str从左开始len个字符的字符串。 right(str, len) 返回str从右开始len个字符的字符串。 substring(str, [from] pos, [[for] len]) 返回从str位置pos开始的len个字符的字符串 pos 从1开始，可以为负 len 若省略，则默认到字符串结尾 若len &lt; 1 则返回空字符串。 substr() 等价于 substring() locate(substr, str[, pos]) 返回子串substr在str中第一次出现的位置，没有则返回 0 pos 指定开始匹配位置 默认从1开始，及字符串开头 instr(str, substr) 返回子串substr在str中第一次出现的位置，没有则返回0 等价于 locate(substr, str) insert(str, pos, len, newstr) 将str中从位置pos开始的len个字符替换为newstr replace(str, from_str, to_str) 将str中的from_str替换为to_str strcmp(expr1,expr2) 比较两个字符串 expr1 = expr2，返回 0 expr1 &lt; expr2，返回 -1 expr1 &gt; expr2 ，返回 1 repeat(str, count) 返回str重复count次组成的字符串 isnull(expr) 判断表达式是否为空 4 日期函数 now() 返回当前日期和时间。yyyy-MM--dd HH:mm:ss curdate() 返回当前日期 yyyy-MM-dd curtime() 返回当前时间 HH:mm:ss dayofyear(date) 返回指定日期是当年的第几天 date 格式为 yyyy-mm-dd dayofmonth(date) 返回指定日期是当月的第几天 dayofweek(date) 返回指定日期是当周的第几天（周日是第一天） datediff(expr1, expr2) 返回expr1 - expr2 的日期差值 date_format(date, format) 日期格式化 date_add(date, INTERVAL expr unit) 给日期加上指定值 unit 指定日期项，如day year day_hour day_second ... date_sub(date, INTERVAL expr unit) 给日期减去指定值 5 加密函数 md5(str) md5加密 6 JSON 函数 json_array([val[, val ...]]) 返回由参数组成json数组 json_object([key, val[, key, val ...]]) 返回由参数组成的json对象，奇数参数是key，偶数参数是value json_pretty(json_val) 漂亮的打印json json_array_append(json_doc, path, val[, path, val ...]) 在json_doc指定位置上的值后追加值 假如数组或对象指定位置上是一个数组，则在数组尾部追加 [a, b] append c [a, b, c] 假如数组或对象指定位置上是一个值，则变成一个数组并在尾部追加 a append b [a, b] json_doc 可以是json对象也可以是json数组 path $[索引] $.key json_array_insert(json_doc, path, val[, path, val ...]) 向json数组指定位置插入值，返回新数组，不改变原有数组 json_doc 要插入值的json数组 path 格式为 $[索引值]，数组索引从0开始 json_insert(json_doc, path, val[, path, val ...]) 向json对象添加新的键值对，返回新对象，不改变原对象 json_doc 要插入值的json对象 path 格式为 $.key 如果key在原对象中存在，不会添加也不改变原有值。 json_set(json_doc, path, val[, path, val ...]) 替换json_doc指定位置现有的值，如果不存在则添加 json_replace(json_doc, path, val[, path, val ...]) 仅替换现有的值 json_remove(json_doc, path[, path...]) 删除json_doc指定位置的值 json_extract(json_doc, path[, path...]) 返回json_doc指定位置的值 json_contains_path(json_doc, one_or_all, path[, path...]) 判断是否包含指定路径（索引或者key） one 只要有一个包含就返回1 all 只要有一个不包含就返回0 json_contains(target, candidate[, path]) 判断是否包含指定值 candidate 要查找的值 path 如果设置则代表查找开始位置 json_length(json_doc[, path]) 返回json_doc的长度 7 自定义函数1 语法1234567891011121314151617CREATE [DEFINER = user] FUNCTION sp_name ([func_parameter[,...]]) RETURNS type [characteristic ...] routine_bodyfunc_parameter: param_name typetype: Any valid MySQL data typecharacteristic: COMMENT &apos;string&apos; | LANGUAGE SQL | [NOT] DETERMINISTIC | &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125; | SQL SECURITY &#123; DEFINER | INVOKER &#125; 2 创建12345678DROP FUNCTION IF EXISTS 函数名;DELIMITER 结束标记CREATE FUNCTION 函数名 ([参数列表]) RETURNS 返回值类型BEGIN 函数体 RETURN 返回值;END 结束标记DELIMITER ; -- 将结束标记改回默认分号 形参 形参名 形参类型 返回值 {STRING|INTEGER|REAL|DECIMAL} 必须有返回值且只有一个 3 查看 show function status [like ‘pattern’] 查看所有函数或模糊匹配 show create function 函数名 查看函数的创建语句 4 修改/删除 函数 函数不能修改 删除 drop function [if exists] 函数名","categories":[{"name":"DB","slug":"DB","permalink":"https://anyeansan.github.io/categories/DB/"},{"name":"MySql","slug":"DB/MySql","permalink":"https://anyeansan.github.io/categories/DB/MySql/"}],"tags":[]},{"title":"MySql SQL语句","slug":"MySql-SQL语句","date":"2020-03-30T13:23:46.000Z","updated":"2020-03-30T13:30:16.296Z","comments":true,"path":"2020/03/30/MySql-SQL语句/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/MySql-SQL%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"一 SQL（Structure Query Language）1.1 概述 结构化查询语言，关系型数据库通用命令 遵循SQL92标准 1.2 严格模式（SQL_MODE） set sql_mode = &#39;traditional&#39; 设置严格模式，默认 set sql_mode = &#39;&#39; 关闭严格模式 1.3 SQL 规范1 注释 -- 单行 /* */ 多行 # mysql 特有 2 编码规范1 库 关键字 和 函数名 大写 库名 小写，不能以数字开头，不能使用关键字和保留字 必须设置字符集 2 表 关键字 和 函数名 大写 表名 小写，不能以数字开头，不能使用关键字和保留字 选择合适的数据类型及长度 每个列设置 NOT NULL + DEFAULT 数值默认为 0 或其它有效数字 字符串默认为空格字符串 &#39; &#39; 或其它有效字符串 enum 类型不要用于数值，只能用于字符串 每个列设置注释 表必须设置存储引擎和字符集 主键列最好是无关数值列，且自增长 1.4 SQL 常用分类 DQL（Data Query Language） 数据查询语言，如 select show DDL（Data Definition Language） 数据定义语言，如 create alter drop truncate DML（Data Manipulation Language） 数据操作语言，如 insert update delete DCL（Data Control Language） 数据控制语言，如 grant revoke 二 库 操作2.1 查 show databases 查看所有库 show create database db_name 查看建库语句 show variables like &#39;character_set_database&#39; 查看当前数据库字符集 show variables like &#39;collation_database&#39; 查看当前数据库校对集 2.2 增 create database [if not exists] 库名 [charset 字符集 collate 校对集] 2.3 删 drop database [if exists] 库名 2.4 改 alter database 库名 [charset 字符集 collate 校对集] 库名不可修改 字符集和校对集可修改 三 表 操作3.1 指定库 use 库名 指定当前使用的数据库 表依赖于库，任何一个表都必须指定数据库 库名.表名 在 sql 语句中显式的指定 select database() 查看正在使用的数据库 3.2 查 show tables [from 库名] 查看库（默认为当前库）中的所有表 show create table 表名 查看当前库中指定的表 desc 表名 查看表结构 show columns from 表名 查看表结构 3.3 增 .12345create table [if not exists] 表名( 列名 列属性, ...... 列名 列属性)[表属性] 表属性 charset 字符集 collate 校对集 engine 存储引擎 create table 新表名 like 旧表名 根据已有表结构创建新表 3.4 删 drop table [if exists] 表名 3.5 改1 表名 rename table 表名 to 新表名 alter table 表名 rename 新表名 2 表属性 alter table 表名 表属性 3 表结构 alter table 表名 add [column] 列名 列属性 [位置] 默认在最后新增一列 位置 first after 列名 alter table 表名 add [column] (列名 列属性, ...) 新增多列 alter table 表名 drop [column] 列名 删除列 alter table 表名 modify 列名 列属性 修改列属性 alter table 表名 change 列名 新列名 列属性 修改列名和列属性 四 数据操作 DML4.1 insert insert [into] 表名(列1,列2,列3,...) values(值1,值2,值3,...)[,(值1,值2,值3,...),...] 列与值一一对应 非数字值，要加引号（建议单引号） 自增列可以用 null / default 占位，默认列可以用 default 占位 如果为表的所有列插入数据，可以省略 (列1,列2,列3,...) insert [into] 表名 set 列=值,... 一次插入一条记录，值可以使用子查询 4.2 update update 表名 set 列 = 值 [where条件] 不加条件会更新所有行 4.3 delete delete from 表名 [where条件] 若没有条件，表示删除所有行 truncate [table] 表名; 清空表 truncate 和 delete 区别 DELETE DML 操作，是逻辑性质删除，逐行删除速度慢 删除表中的数据，表结构还在，删除后的数据可以找回 自增长主键不会重置 TRUNCATE DDL 操作，对表段中的数据页进行清空，速度快 相当于把表扔了又创建一个同样表结构的新表 自增长主键会重置 五 数据操作 DQL5.1 语法123456789select [选项] 表达式[, [选项] 表达式, ...][ from 数据源 [where 子句] [group by 子句] [having 子句] [order by 子句] [limit 子句]] 5.2 select 子句1 选项 all 保留所有结果（默认） distinct 去除重复 distinct row top 2 表达式 每一个表达式代表一列，可以是列名，变量，函数 … * 代表所有列 3 别名 [as] 别名 表别名 可用于全局 列别名 别名可用于 having，order by 5.2 from 子句 本质上只要数据类似二维表，都可以作为数据源 单表数据源 多表数据源 查询语句 5.4 where 子句1 比较运算符 &gt; &gt;= &lt; &lt;= = != ... 2 逻辑运算符 and or not 3 语句 like pattern 模糊查询 pattern %：匹配任意个任意字符 _：匹配一个任意字符 between ... and ... is null is not null is boolean_value 判断一个值的布尔值是否为 boolean_value boolean_value true false unknown in() 匹配其中任意一个值，则为 true，类似逻辑或 any() 必须配合比较运算符使用，代表（大于, 小于, …）其中任意一个值，则为 true some() 是 any() 的别名 all() 必须配合比较运算符使用，代表（大于, 小于, …）其中所有值，则为 true 运算符 any() all() &gt; &gt;= 最小值 最大值 &lt; &lt;= 最大值 最小值 = 任意值 - &lt;&gt; != - 任意值 5.5 group by 子句1 概述 通常配合聚合函数使用 可以有多个分组列，以逗号分隔 select 中查询的列只能有三种 分组的列 聚合函数的列 与分组列一对一的列 2 group by 原理 先按照分组列 排序、去重，形成一张虚拟表 虚拟表的结构：分组列与其它列的对应关系 分组列一对一的列可以直接查询（即与分组列对应的列只有一行记录） 分组列一对多的列不能直接查询（即与分组列对应的列有多行记录） 使用聚合函数将多行记录统计为一行记录 使用 group_concat() 将多行记录合并连接为一行记录 3 聚合函数 函数 说明 max() 列最大值 min() 列最小值 count() 列记录总数 sum() 列和 avg() 列平均值 group_concat() 将group by产生的同一个分组中的其它列的所有值连接成一个字符串（多行记录变一行） * count() 1. count(1) count(*) count(&#39;abc&#39;) ... * 此类参数表示数数，有一行记录总数就+1，也就是说总数与记录内容无关 * 记录总数（包含空行） 2. count(列名) * 记录总数（不包含空行） 5.6 having 子句 having 是对其之前子句筛选出的数据进行条件过滤 5.7 order by子句 语句 说明 asc 升序（默认） desc 降序 1. 排序依赖校对集 2. order by 列1 asc,列2 desc... * 多个排序条件时，前一个排序结果相同才会按照下一个条件排序 5.8 limit 子句 limit [startIndex] length 从 startIndex 开始，取 length 条数据。 startIndex 起始索引，若省略相当于 0。 数据库索引从 0 开始 limit length offset startIndex 5.9 union &amp; union all 合并多个查询结果集 一般情况下,会将 in() 或者 OR 语句 改写成 UNION ALL ,来提高性能 union 去除重复 union all 保留所有 5.10 查询过程 from 确定数据源 where where 是直接对表中数据进行判断，所以只能使用表中的列，且不能使用别名 where 从表中查询出符合条件的数据形成一个概念中的临时结果集，存入内存 where 保证进入内存的数据都是有效的 group by 按照指定列进行分组 select 处理表达式（函数, 别名, 运算 …），形成结果集 having 对结果集进行过滤 order by 对过滤后的结果集进行排序 limit 对排序后的结果集进行条目限制，形成最终结果集 六 多表连接6.1 语法123456789101112131415表1 &#123;[inner | cross] | &#123;left | right&#125; [outer]&#125; join表2on 条件表达式[ &#123;[inner | cross] | &#123;left | right&#125; [outer]&#125; join 表3 on 条件表达式 ......][where 子句][group by 子句][having 子句][order by 子句][limit 子句] 多表连接可以用在 多表查询 多表更新 多表删除 自连接 连接的表是同一张表。 6.2 内连接1 语法121 表1 [inner | cross] join 表2 on 条件2 from 表1,表2 where 条件 查出多表中符合条件的数据，即交集 内连接为左外连接与右外连接的交集。 内连接如果没有条件，结果会形成笛卡儿积 2 笛卡尔积 笛卡儿积是元素相组合，不是数学相乘 数学中的笛卡儿积 集合A有m个元素，集合B有n个元素，则笛卡尔积共 m * n个元素 例 集合 A = {a, b}，集合 B = {0, 1, 2} 两个集合的笛卡尔积 = {(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)} 数据库中的笛卡儿积 表 A 有 m 条数据，表 B 中有 n 条数据，则笛卡尔积结果： 行（记录数）= m * n 列 = 表A的列数 + 表B的列数 6.3 外连接1 左外连接1表1 left [outer] join 表2 on 条件 以左表为主，查出左表的全部记录和右表符合条件的记录，不符合条件的字段置为 null 2 右外连接1表1 right [outer] join 表2 on 条件 以右表为主，查出右表的全部记录和左表符合条件的记录，不符合条件的字段置为 null 6.4 例1 原始表 t1 &amp; t2 id name 1 a 2 b 3 c id age 2 D 3 E 4 F 2 内连接 select * from t1 inner join t2 on t1.id=t2.id; id name id age 2 a 2 D 3 c 3 E 3 左外连接 select * from t1 left join t2 on t1.id=t2.id; id name id age 1 a null null 2 b 2 D 3 c 3 E 4 右外连接 select * from t1 right join t2 on t1.id=t2.id; id name id age 2 b 2 D 3 c 3 E null null 4 F 5 全连接（(full join) mysql不支持） select * from t1 full join t2 on t1.id=t2.id; id name id age 1 a null null 2 b 2 D 3 c 3 E null null 4 F","categories":[{"name":"DB","slug":"DB","permalink":"https://anyeansan.github.io/categories/DB/"},{"name":"MySql","slug":"DB/MySql","permalink":"https://anyeansan.github.io/categories/DB/MySql/"}],"tags":[]},{"title":"MySql 属性","slug":"MySql-属性","date":"2020-03-30T13:20:53.000Z","updated":"2020-03-30T13:23:14.663Z","comments":true,"path":"2020/03/30/MySql-属性/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/MySql-%E5%B1%9E%E6%80%A7/","excerpt":"","text":"一 字符集 charset1.1 MySQL 的 UTF-8 MySQL 中的 utf8mb4 才是真正的 UTF-8，而 utf8 是 utf8mb3 的别名，是 MySQL 脑残的产物 MySQL 表示未来会删除 utf8mb3，然后 utf8 指代 utf8mb4（真是个小机灵鬼） 1.2 字符集说明 show charset 查看数据库支持的字符集 show variables like &#39;character%&#39; 查看数据库默认字符集设置 配置 说明 character_set_database 数据库默认字符集，若没设置则使用 character_set_server character_set_client 客户端字符集 character_set_connection 客户端连接数据库使用的字符集 character_set_results 数据库给客户端返回数据使用的字符集，若没设置则使用 character_set_server character_set_server 服务器字符集，建议由系统自己管理，不要人为定义 character_set_filesystem 用于将系统文件名转化成此字符集，默认 binary 不做转换（建议不改动） character_set_system 数据库系统用来存储元数据的编码，通常是 utf8（不要改动） character_sets_dir 字符集安装目录 1.3 乱码问题1 涉及的字符集 数据本身字符集 客户端字符集 character_set_client 连接字符集 character_set_connection 数据库字符集 character_set_database 结果字符集 character_set_results 2 存 数据字符集 → 客户端字符集 → 连接字符集 → 数据库字符集 数据本身字符集 = 客户端字符集，若不一致则会乱码 将数据从 客户端字符集 转为 连接字符集，若一致则不转换 将数据从 连接字符集 转为 数据库字符集，若一致则不转换 存数据最终是按照 数据库字符集 存储 结论 保证 数据本身字符集 = 客户端字符集 连接字符集不要太小导致转换损失数据 3 取 数据库字符集 → 连接字符集 → 结果字符集 → 客户端字符集 将数据从 数据库字符集 转为 连接字符集 ，若一致则不转换 将数据从 连接字符集 转为 结果字符集，若一致则不转换 取数据最终是按照结果字符集返回给客户端 比较 结果字符集 与 客户端字符集 是否一致 结论 保证 结果字符集 = 客户端字符集 连接字符集不要太小导致转换损失数据 二 校对集 collation2.1 概述 校对集，就是数据的比较方式，或者排序规则 只有当数据产生比较的时候，校对集才会生效 必须在没有数据之前声明好校对集，如果有了数据再进行校对集修改，修改无效 校对集依赖字符集，每个字符集都对应 1 或 多个校对集 utf8mb4 默认校对集 utf8mb4_general_ci 2.2 校对集格式 show collation 查看数据库支持的校对集 格式 说明 _bin binary，二进制比较, 大小写敏感（适用比较特殊的数据，如拼音，日文…） _ci case insensitive，大小写不敏感 _cs case sensitive，大小写敏感 三 存储引擎 engine3.1 概述 MySQL进行存储数据的方式。 每一种存储引擎使用不同的存储机制，索引技巧，锁定水平，最终提供广泛且不同的功能。 3.2 分类 InnoDB 新版 MySQL 默认存储引擎 Myisam 速度快，不支持事务，安全性不够 Memory 数据存在内存中，不存在磁盘，一关闭服务器就消失。适合临时数据 CSV Archive XtraDB PerconaDB 默认存储引擎 TokuDB RocksDB MyRocks 第三方存储引擎：共同点是压缩比较高,数据插入性能极高 3.3 存储引擎操作1 查 show engines 查看支持的存储引擎 select @@default_storage_engine 查看默认的存储引擎 2 改 alter table 表名 engine=存储引擎 除了修改存储引擎外，还会做碎片整理 3.4 InnoDB1 特性 事务（Transaction） 行级锁（Row-level Lock） 多版本并发控制 MVCC（Multi-Version Concurrency Control） 自动故障安全恢复 ACSR（Auto Crash Safey Recovery） 热备份（Hot Backup） 外键 复制 Replication Group Commit GTID (Global Transaction ID) 多线程（Multi-Threads-SQL） 2 物理存储结构1 共享表空间 idbdata1 系统数据字典信息（统计信息），Undo 回滚日志等数据 ib_logfile0~ib_logfile1 Redo 重做日志文件，事务日志文件 ibtmp1 临时表空间，存储临时表（如 join union 等操作） 2 独立表空间 frm 存储表列信息（列名，列属性） ibd 存储表数据行和索引 opt 存储库属性 一张 InnoDB 表 = ibdata1 + frm + ibd（段、区、页） 3 表空间 Tablespace 共享表空间：将所有数据存储到同一个表空间中 ，管理比较混乱 独立表空间：一张表一个 frm 存储列信息，一个 ibd 存储数据行和索引 说明 共享表空间是 5.5 版本出现的管理模式 5.6 版本开始默认使用独立表空间，保留共享表空间，只用来存储：数据字典信息，undo，临时表 5.7 版本临时表被独立出去，共享表空间只存储：数据字典信息，undo 8.0 版本undo也被独立出去，共享表空间只存储：数据字典信息 4 核心参数1 存储引擎 default_storage_engine=innodb 默认存储引擎 2 表空间 innobd_file_pre_table=1 表空间模式，1 独立表空间 innodb_data_file_path=ibdata1:512M:ibdata2:512M:autoextend 共享表空间文件个数和大小 3 缓冲区 innodb_flush_log_at_trx_commit=1 双一标准之一 控制了 innodb 将 log buffer 中的数据写入日志文件并 flush 磁盘的时间点，取值分别为 0、1、2 三个 Innodb_flush_method=(O_DIRECT, fdatasync) 双一标准之一 控制 log buffer 和 data buffer 刷写磁盘的时候是否经过文件系统缓存 OS buffer innodb_max_dirty_pages_pct=75 脏页刷写策略 4 redo 日志 innodb_log_buffer_size innodb_log_file_size innodb_log_files_in_group 四 列属性4.1 数据类型1 数值类型1 整型类型|大小|无符号范围|有符号范围-|-|-|-|-tinyint |1 Byte|0 ~ 255|-128 ~ 127smallint|2 Byte|0 ~ 65535|-215 ~ 215-1mediumint|3 Byte|0 ~ 224-1|&lt;code&gt;-2&lt;sup&gt;23&lt;/sup&gt; ~ 2&lt;sup&gt;23&lt;/sup&gt;-1&lt;/code&gt; **int**|4 Byte|&lt;code&gt;0 ~ 2&lt;sup&gt;32&lt;/sup&gt;-1&lt;/code&gt;|-231 ~ 231-1bigint|8 Byte|0 ~ 264-1`|-263 ~ 263-1 int(M) M 与存储长度无关，只是标识显示长度，且要配合 zerofill 才有意义 2 浮点型 &amp; 定点型 类型 说明 float 单精度 4 Byte double 双精度 8 Byte decimal 精确数值 1. float(M,D) * M * 精度，即总位数 * D * 标度，即小数点后的位数 * 不足用0补，超过则四舍五入 2. decimal(M,D) * 0&lt;M&lt;65，D&lt;M &amp;&amp; 0&lt;D&lt;30 * 默认为 decimal(10, 0) 2 字符串类型 类型 说明 char 定长字符串 varchar 变长字符串 tinytext 短文本 text 文本 mediumtext 中长文本 longtext 长文本 1 char 非空 char 的最大长度是 255【字节】 可空 char 的最大长度是 254【字节】，因为非空标记需要占用 1 个字节 当允许为空时，系统会自动从整个记录中保留一个字节来存储 NULL char(M) M 为字符数，0~255 char 存储时会立即分配 M 个字符长度的存储空间，未占满的空间使用空格填充 2 varchar 非空 varchar 的最大长度是 65532【字节】 如果存储值小于 255 字节，则使用 1 个字节标记长度 如果存储值超过 255 字节，则使用 2 个字节标记长度 varchar是从第二个字节开始存储的 可空 varchar 的最大长度是 65531【字节】 varchar(M) M 为字符数，0 ~ 65535，但由于 varcahr 最大长度是 65532 字节，所以 M 实际范围跟字符集有关，比如 utf8 一个字符占用 3 个字节，则 M 最大长度是 65532 / 3 varchar 存储前会先判断长度，按需分配空间 3 以 utf8 为例比较 类型 可存字符 实存字符 实占字节 利用率 char(M) M n M * 3 n / M varchar(M) M n n * 3 + (1~2) n * 3 / （n * 3 + (1~2)） 3 枚举 enum enum(value1, value2, value3, ...) 建表时在字段上定义枚举列表，按照定义顺序索引值从 1 开始编号 空字符串 &quot;&quot; 索引为 0，null 索引为 null 插入数据时（单选），可以使用索引值或者枚举值 数据库存储时存储索引，读取时再根据枚举列表将索引转为枚举值 4 集合 set set(value1, value2, value3, ...) 建表时在字段上定义集合列表，集合中每个值对应一个二进制位 第一个值对应 1 = 1 第二个值对应 10 = 2 第三个值对应 100 = 4 第四个值对应 1000 = 8 … 也就是说一个二进制数，从低位向高位依次对应集合从 1 开始的值 插入数据时（多选），可以使用二进制对应的十进制数字，插入数字对应的二进制，相应位置为 1 代表插入该值，例如 插入 6，转为二进制 110，即插入第二和第三个值 插入 7，转为二进制 111，即插入前三个值 插入 8，转为二进制 1000，即插入第四个值 5 日期类型 类型 格式 大小 最小值 最大值 零值 datetime yyyy-mm-dd hh:mm:ss 8 Byte 1000-01-01 00:00:00 9999-12-31 23:59:59 0000-00-00 00:00:00 timestamp yyyy-mm-dd hh:mm:ss 4 Byte 1970-01-01 00:00:00 2038-01-19 03:14:07 0000-00-00 00:00:00 date yyyy-mm-dd 3 Byte 1000-01-01 9999-12-31 0000-00-00 time hh:mm:ss 3 Byte -838:59:59 838:59:59 00:00:00 1. Mysql保存日期格式使用 YYYY-MM-DD HH:MM:SS 的ISO 8601标准 2. 向数据表储存日期与时间必须使用ISO格式 3. timestamp 1. yyyy-mm-dd hh:mm:ss 格式的时间戳（从 1970-01-01 00:00:00 到指定时间的毫秒值） 2. 插入和更新时如果未指定则会插入当前时间 3. 根据时区自动变化显示 6 二进制类型 类型 说明 tinyblob 最大长度为255B blob 最大长度为64KB mediumblob 最大长度为16MB longblob 最大长度为4GB * 二进制数据类型可存储任何数据（甚至包括二进制信息），如图像、多媒体、字处理文档等 4.2 注释 comment &#39;注释&#39; 用于描述字段信息 4.3 unsigned unsigned 将数值类型声明为无符号 MySQL 中的数值默认都是有符号的。 4.4 zerofill zerofill 数值类型的列位数不足时用 0 补填充 如果声明 zerofill，则会自动声明为 unsigned 4.5 自增长1 增 auto_increment 自增长需要搭配主键使用 自增长字段必须是数字(整型) 一张表最多只能有一个自增长 如果插入数据时字段指定为0、null或未指定值，那么插入自增长的值 如果插入数据时字段指定了具体值 如果插入值&lt;自增值，则表的自增值不变 如果插入值&gt;自增值，则表的自增值会变成插入值 2 查 show variables like &#39;auto_increment%&#39; auto_increment_increment 初始值 auto_increment_offset 种子 select last_insert_id() 获取自增的最后一个值 show create database 库名 可以通过查看表创建语句查看下一次自增长的值 3 修改自增长的值 alter table 表名 auto_increment = 值 只能比当前自增长的最大值大，不能小(小不生效) 4 删除自增长 修改列属性为没有 auto_increment 即删除。 4.6 约束1 主键约束 primary key1 概述 主键约束列唯一，非null 一张表只能有一个主键 2 增 列名 primaray key 建表时为当前列添加主键 primary key(列1,列2,...) 建表时，单独一行，添加单一主键或复合主键 alter table 表名 add [constraint 主键约束名] primary key(列1,列2,...) 建表后，添加单一主键或复合主键 3 改 / 删 主键无法修改 删除 有自增先要删除自增 删除主键 alter table 表名 drop primary key alter table 表名 drop constraint 主键约束名 4 主键冲突 （主键值已存在 Duplicate key） 更新 Insert into 表名[字段列表(包含主键)] values(值列表) on duplicate key update 字段 = 新值 替换 Replace into 表名 [字段列表(包含主键)] values(值列表) 2 外键约束 foreign key1 概述 父表和子表必须使用相同的存储引擎 InnoDB，且禁止使用临时表 外键列和参照列必须具有一样的数据类型，数字的长度和是否有符号必须一致，字符长度可以不同 外键列和参照列必须创建索引，如果外键列不存在索引，mysql会自动创建索引。 2 外键约束模式1 语法 on update 模式 on delete 模式 2 模式 restrict 严格模式（默认） 如果子表中有关联的记录，则父表不能 update/delete no action 标准SQL的关键字，在 MySQL 中同 restrict cascade 级联模式 对父表 update/delete 时，子表相关联的记录同步 update/delete set null 置空模式 对父表 update/delete 时，将子表外键列设为 null（子表的外键列不能为 not null） 3 增 [constraint 外键约束名] foreign key(外键字段) references 父表(主键字段) [on delete 模式 on update 模式] 建表时添加，在所有字段后 Alter table 表名 add [constraint 外键约束名] foreign key(外键字段) references 父表(主键字段) [on delete 模式 on update 模式] 建表后添加 4 改 / 删 外键不能修改 删除 Alter table 表名 drop foreign key 外键约束名 3 非空约束 not null null 列允许为空（默认） not null 列不能为空，必须插入值，通常配合 default 使用 null 没有意义且所有运算一律返回 null，效率不高，影响索引结果 4 默认约束 default1 增 列名 default 值 建表时，给当前列添加默认值 alter table 表名 alter [column] 列 set default 值 建表后，给指定列添加默认值 2 删 alter table 表名 alter [column] 列 drop default 3 使用 对应字段没有插入值，则使用默认值。 显式的插入 default 关键字，表示使用默认值 5 唯一约束 unique key1 概述 唯一约束列唯一，可以为 null，且可以有多个 null，因为 null = null 返回 false 一张表可以有多个唯一约束 2 增 列 unique key 建表时，为当前列添加唯一约束 unique key(列1,列2,...) 建表时，单独一行，为指定列添加唯一约束 alter table 表名 add [constraint 唯一约束名] unique key(列1,列2,...) 建表后，为指定列添加唯一约束 3 删 alter table 表名 drop [index/key] 唯一约束名","categories":[{"name":"DB","slug":"DB","permalink":"https://anyeansan.github.io/categories/DB/"},{"name":"MySql","slug":"DB/MySql","permalink":"https://anyeansan.github.io/categories/DB/MySql/"}],"tags":[]},{"title":"MySql 安装和配置","slug":"MySql-安装和配置","date":"2020-03-30T13:17:52.000Z","updated":"2020-03-30T13:20:04.615Z","comments":true,"path":"2020/03/30/MySql-安装和配置/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/MySql-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/","excerpt":"","text":"一 概述1.1 概念 DBMS（Database Management System） 数据库管理系统 DBA（Database Administrator） 数据库管理员 1.2 DBMS 分类1 RDBMS（Relational Database Management System） Oracle DB2 Sql-Server Mysql access PG MSSQL 2 NoSQL（Not Only SQL） MongoDB Redis ES（Elasticsearch） memcached 3 NewSQL（分布式） TiDB Spanner AliSQL OB PolarDB 1.3 Mysql GA版本 5.6 5.6.38（2017-09-13） 5.7 5.7.20（2017-09-13） 二 Mysql 安装与配置2.1 Linux1 下载解压 下载 linux-generic 通用二进制包（类似绿色版） 上传到 linux 并解压 2 卸载 mariadb121 rpm -qa | grep mariadb2 yum remove -y xxx 3 创建用户并授权，用于管理mysql1231 useradd -s /sbin/nologin mysql2 chown -R mysql.mysql basedir3 chown -R mysql.mysql datadir 4 设置环境变量12341 vim /etc/profile2 export PATH=basedir/bin:$PATH3 source /etc/profile4 mysql -V 5 初始化1 无密码1mysqld --initialize-insecure --user=mysql --basedir=xxx --datadir=xxx 2 有密码1mysqld --initialize --user=mysql --basedir=xxx --datadir=xxx 可能会因为缺少 libaio-devel 依赖而报错 --initialize 对密码复杂度进行定制：12位，4种 密码过期时间：180天 给root@localhost 用户设置临时密码 6 配置文件1234567891011cat &gt;/etc/my.cnf &lt;&lt;EOF[mysqld] user=mysqlbasedir=datadir=socket=/tmp/mysql.sockport=3306server_id=6[mysql]socket=/tmp/mysql.sockEOF 7 MySQL 服务1 启动方式1 init 配置1cp basedir/support-files/mysql.server /etc/init.d/mysqld 启动 service mysqld start 或 /etc/init.d/mysqld start 其实是调用了 basedir/support-files/mysql.server 脚本 mysql.server 脚本 读取 /etc/my.cnf 配置文件 调用 basedir/bin/mysqld_safe 来启动 mysqld 2 systemd 配置123456789101112131415cat &gt;/etc/systemd/system/mysqld.service &lt;&lt;EOF[Unit]Description=MySQL ServerDocumentation=man:mysqld(8)Documentation=http://dev.mysql.com/doc/refman/en/using-systemd.htmlAfter=network.targetAfter=syslog.target[Install]WantedBy=multi-user.target[Service]User=mysqlGroup=mysqlExecStart=basedir/bin/mysqld --defaults-file=/etc/my.cnfLimitNOFILE = 5000EOF 启动 systemctl start mysqld 其实是加载了 /etc/systemd/system/mysqld.service mysqd.service 中 ExecStart 读取 /etc/my.cnf 配置文件 启动 mysqld 3 手动 mysqld_safe --skip-grant-tables --skip-networking &amp; 维护模式启动 2 初始化配置1 作用 影响数据库的启动 影响客户端的功能 2 初始化配置方式 初始化配置文件（如 etc/my.cnf ） 命令行启动参数 如果参数冲突，命令行参数会优先级高于配置文件 编译安装时配置 3 初始化配置文件1 加载顺序 mysqld --help --verbose | grep my.cnf 查看配置文件加载顺序 默认情况下，MySQL启动时，会依序读取配置文件，如果有重复选项，会以最后一个文件设置的为准 --defaults-file= 如果启动时手动配置了配置文件，则默认配置文件都不读取。 2 格式12[module]key=value module 服务端 [mysqld] [mysqld_safe] [server] 包括服务端所有 客户端 [mysql] [mysqladmin] [mysqldump] [client] 包括客户端所有 3 样板123456789101112131415161718# -----------------服务端配置-------------------------[mysqld]# 管理用户user=mysql# 软件安装目录basedir=/app/mysql# 数据目录datadir=/data/mysql/data# 服务端保存 socket 文件路径socket=/tmp/mysql.sock# 端口号port=3306# 服务器id号 1~65535server_id=6# -----------------客户端配置-------------------------[mysql]# 客户端登录时寻找 socket 文件路径 socket=/tmp/mysql.sock 2.2 Windows1 配置环境变量2 在MySql目录下创建 .ini 配置文件12345678# 服务端配置[mysqld] basedir =datadir =port = 3306character-set-server=utf8mb4 // 1[mysql]default-character-set=utf8mb4 // 2 配置1 与 配置12的结果对比 3 初始化 mysqld --initialize --console 随机密码，并在控制台显示密码 mysqld --initialize-insecure 无密码 4 mysql 服务 mysqld --install 安装服务 net start mysql 启动服务 net stop mysql 停止服务 mysqld remove / sc delete mysql 删除服务 2.3 修改用户密码 mysqladmin -u用户名 -p[旧密码] password 新密码 不需登录 旧密码可以写在命令中，也可以回车后输入 alter user &#39;用户名&#39; @&#39;localhost&#39; identified by &#39;新密码&#39; 需要登录 忘记 root 密码 关闭数据库 维护模式启动数据库 mysqld_safe --skip-grant-tables --skip-networking &amp; 登录并修改密码 alter user &#39;root&#39; @&#39;localhost&#39; identified by &#39;新密码&#39; flush privileges 如果修改密码报错，则刷新权限 三 MySQL 的连接3.1 C/S 模型（客户端 &amp; 服务端） 使用mysql，需要安装服务端 连接访问服务器，需要通过客户端 3.2 客户端1 MySQL自带的命令行工具 mysql.exe1 连接方式 TCP/IP 方式（远程 本地） mysql -uuser -p[password] [-h Host] [-Pport] Socket 方式（本地） mysql -uuser -p[password] [-S /tmp/mysql.sock] 2 myql 命令 mysql [OPTION] OPTION -u -p -h -P -S -e &quot;sql&quot; 免交互执行命令（即不连接数据库） &lt; 脚本路径 导入 sql 脚本 -prompt 提示符 定义 mysql 提示符，默认为 mysql&gt; \\D：完整日期 \\d：当前数据库 \\h：服务器名 \\u：当前用户 2 图形化工具（GUI） 软件 windows mac linux 功能 免费版 sequelpro &nbsp; √ &nbsp; &nbsp; 有 dbeaver √ √ √ &nbsp; 有 navicat √ √ √ 强 &nbsp; SQLyog √ &nbsp; &nbsp; 强 &nbsp; dbForge √ &nbsp; &nbsp; 强 有 heidisql √ &nbsp; &nbsp; &nbsp; 有 * 免费选择跨平台的 dbeaver ，不差钱选择 navicat 四 MySQL 体系结构4.1 mysql 实例 mysqld（老板） master thread（经理） other thread（员工） 预分配内存（办公区） 4.2 mysqld 程序结构1 连接层 提供连接协议：TCP/IP 、SOCKET 提供验证：用户、密码、IP、Port、SOCKET … 提供专用连接线程：接收用户SQL，返回结果 show processlist 查看连接线程 2 SQL 层 接收上层传送的SQL语句 语法验证模块：验证语句语法,是否满足SQL_MODE 语义检查：判断SQL语句的类型（DQL、DML …） 权限检查：用户对库表有没有权限 解析器：语句执行前进行预处理，生成解析树(执行计划)，说白了就是生成多种执行方案 优化器：根据解析器得出的多种执行计划，进行判断，选择最优的执行计划 代价模型：资源（CPU IO MEM）的耗损评估性能好坏 执行器：根据最优执行计划，执行SQL语句，产生执行结果（在磁盘上） 提供查询缓存（默认没开启）：会使用redis tair替代查询缓存功能 提供日志记录（默认没开启）：二进制日志 binlog 、审计日志、通用日志 … 3 存储引擎层 根据SQL层执行的结果，从磁盘上拿数据 将16进制的磁盘数据，返回给 SQL 层结构化成表 由连接层的专用线程返回给用户 4.3 MySQL 逻辑存储结构 库（database） 库名 库属性（字符集，校对集(排序规则)） 表（table） 表名 表属性（存储引擎，字符集，校对集(排序规则)） 列（column）/ 字段（field） 列名 列属性（数据类型，约束，…） 行（row）/ 记录（record） 4.4 MySQL 物理存储结构 库（目录） 表 MyISAM .frm ：存储表结构（列名，列属性） .MYD ：存储数据记录 .MYI ：存储索引 InnoDB .frm ：存储表结构（列名，列属性） .ibd ：存储数据记录和索引 .opt ：存储库属性 ibdata1 ：数据字段信息 InnoDB，一般情况下（非分区表） 段：一个表就是一个段，一个段由多个区构成 区：一个区由64个连续的页构造，1M 大小（ 64*16=1024 ） 页：一个页大小为 16 kb 五 用户 &amp; 权限5.1 用户1 用户定义 user@&#39;Host&#39; Host（白名单） localhost 127.0.0.1 % 任意网段 10.0.0.% 10.0.0.0~10.0.0.255 10.0.0.5% 10.0.0.50~10.0.0.59 10.0.0.0/255.255.255.0 2 用户管理1 查询用户 select user,host,authentication_string from mysql.user 查询用户名，主机，密码 用户信息存储在数据库 mysql 中 的 user 表 2 创建用户 create user user@&#39;Host&#39; [identified by &#39;password&#39;] 3 删除用户 drop user user@&#39;Host&#39; 5.2 权限1 权限列表123SELECT，INSERT，UPDATE，DELETE，CREATE，DROP，ALTER，SHOW DATABASES，CREATE USER，CREATE TEMPORARY TABLES，RELOAD，SHUTDOWN，PROCESS，FILE，REFERENCE，INDEX，SUPER，EXECUTE，REPLICATION，SLAVE，REPLICATION，CLIENT，EVENT，TRIGGER，LOCK TABLES，CREATE VIEW，SHOW VIEW，CREATE ROUTINE，ALTER ROUTINE，CREATE TABLESPACE， ALL privileges 所有权限 with grant option 可以给别的用户授权，超级管理员才具备 2 权限管理1 查看权限 show grants for user@&#39;Host&#39; 2 授权 grant 权限 on 目标 to 用户 [identified by &#39;password&#39;] [with grant option] 权限 ALL privileges 权限列表，以逗号分隔 目标 *.* 所有数据库的所有表 database.* 指定数据库的所有表 database.table 指定数据库的指定表 3 回收权限 revoke 权限 on 目标 from user@&#39;Host&#39; 六 MySQL 内置命令 命令 说明 help 打印帮助 \\c 放弃本条语句，类似 ctrl + c quit exit ctrl+d \\q 退出 \\G 竖形显示数据 source 脚本路径 导入SQL脚本 tee 路径 将输入的sql语句存储到本地 prompt 提示符 定义 mysql 提示符，默认为 mysql&gt; delimiter 符号 定义结束符，默认为;","categories":[{"name":"DB","slug":"DB","permalink":"https://anyeansan.github.io/categories/DB/"},{"name":"MySql","slug":"DB/MySql","permalink":"https://anyeansan.github.io/categories/DB/MySql/"}],"tags":[]},{"title":"Git","slug":"Git","date":"2020-03-30T13:15:07.000Z","updated":"2020-03-30T13:15:37.115Z","comments":true,"path":"2020/03/30/Git/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/Git/","excerpt":"","text":"一 概述 开源的分布式版本控制系统 二 配置2.1 作用域 git config --local 对当前仓库有效（默认） git config --global 对当前用户所有仓库有效 git config --system 对系统所有登录用户有效 2.2 增删改查 git config --list 查看所有配置信息 git config --global key value 增加配置 git config --global --unset key 删除配置 git config --global --replace-all key value 修改所有匹配 key 的 value 2.3 配置用户和邮箱123git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;Your Email@example.com&quot;git config --global color.ui true # 语法高亮 三 初始化仓库3.1 初始化 git init 将所在目录变成 Git 管理的仓库 Git 仓库中会有一个隐藏的 .git 目录 git init project_name 在所在目录下创建一个指定名称的 Git 管理的仓库目录 3.2 .git 目录结构 branchs 分支目录 config 本仓库的配置文件 HEAD 指向当前分支 description 仓库的描述信息，仅供 GitWeb 程序使用 hooks 包含客户端或服务端的钩子脚本（hook scripts） info 包含一个全局性排除（global exclude）文件， 用以放置那些不希望被记录在 .gitignore 文件中的忽略模式（ignored patterns） refs heads 目录下每个文件代表一个本地分支，用来保存该分支最新 commit_id remotes 目录下每个目录代表一个远程仓库，远程仓库目录下每一个文件代表一个远程分支，保存远程仓库该分支的最新 commit_id tags objects 存储所有数据内容，commit_id 哈希值共 40 位，前 2 位作为目录名，后 38 为作为文件名 index 暂存区（stage） 四 Git 原理4.1 概述 Git 的核心部分是一个简单的键值对数据库（key-value data store） 可以向 Git 仓库中插入任意类型的内容，它会返回一个唯一的键，通过该键可以在任意时刻再次取回该内容 4.2 存取数据1 存 git bash-object 可将任意数据保存于 .git/objects 目录（即 对象数据库），并返回指向该数据对象的唯一的键 键 长度为 40 个字符的校验和，这是一个 SHA-1 哈希值（将待存储的数据外加一个头部信息（header）一起做 SHA-1 校验运算而得的校验和） 校验和的前 2 个字符作为./git/objects/子目录名，余下的 38 个字符则用作文件名 git hash-object -w FILE 存储文件数据 -w 指示该命令不要只返回键，还要将该对象写入数据库中 git hash-object -w --stdin 读取标准输入中的数据并存储 2 取 git cat-file [OPTION] commit_id OPTION -p 查看文件内容 -t 查看文件类型 -s 查看文件大小 4.3 Git 对象1 数据对象（block object） 数据对象类似 Linux 中的 inode 或文件内容 只存储文件内容，不存储文件名 2 树对象（tree object） 树对象类似 Linux 中的目录项 一个树对象包含了一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息 3 提交对象（commit object） 一个顶层树对象，代表当前项目快照 可能存在的父提交对象 作者/提交者信息（依据你的 user.name 和 user.email 配置来设定，外加一个时间戳） 留空一行，最后是提交注释 4 标签对象（tag object） 非常类似于提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针 区别在于，标签对象通常指向一个提交对象，而不是一个树对象。 它像是一个永不移动的分支引用——永远指向同一个提交对象，只不过给这个提交对象加上一个更友好的名字罢了。 4.4 总结 每次我们运行 git add 和 git commit 命令时，Git 所做的工作实质就是将被改写的文件保存为数据对象， 更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象 这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 .git/objects 目录下 4.5 ? 工作区的文件分为两种 未暂存（新增文件） 删、改、重命名 随意操作无影响，之后 git add 变成已暂存 已暂存 改 需要重新 git add，之后 git commit 删除 需要将工作区和暂存区的都删除 git rm，之后 git commit 重命名 git mv 直接 git commit mv 相当于删除和新增文件（未暂存） git rm git add git commit 五 Git 工作流程5.1 相关概念 Workspace 工作区，仓库中除了 .git 目录的其它区域 Index / Stage 暂存区，即 .git/index 文件 Repository 本地仓库，即 .git/objects 目录，HEAD指向最新放入仓库的版本 Remote 远程仓库 5.2 文件状态 Untracked 未追踪状态，工作区中未被 git 仓库管理的文件，没有添加到暂存区 Staged 暂存状态，工作区中未被 git 仓库管理的文件，添加到了暂存区 Unmodify 未修改状态，工作区中已被 git 仓库管理的文件，没有任何修改与 git 仓库中一致 Modified 已修改状态，工作区中已被 git 仓库管理的文件，有改动与 git 仓库中不一致 5.3 命令1 git status git status 查看仓库状态 2 git add git add FILE 把文件添加到暂存区，可添加多个，用空格隔开 git add -u 把有改动的已经被 git 仓库管理的文件添加到暂存区 git add .|* 把当前目录所有有改动的文件添加到暂存区（包括新增的） 3 git rm git rm --cache FILE 从暂存区删除文件，即从暂存区撤回 git rm FILE 从暂存区和工作区同时删除文件 4 git commit git commit [OPTION] 将暂存区文件提交到本地仓库当前分支 OPTION -m &quot;message&quot; 提交说明 -a 已经被 git 仓库管理的文件，会自动暂存并提交，即相当于 git add --amend 将暂存区中的文件提交。 如果自上次提交以来还未做任何修改，即暂存区和本地仓库一致，那么快照会保持不变，所修改的只是提交信息 可以用来修改上一次提交信息 5 git mv git mv oldName newName 将工作区和暂存区的文件同时重命名 mv 和 git mv12345git mv a a.txt相当于mv a a.txtgit rm agit add a.txt 使用 mv 时，相当于删除了原名称文件，创建了新名称文件 此时需要删除暂存区中的原名称文件，然后把新名称文件添加到暂存区 6 git diff git diff 比较工作区和暂存区的差异 git diff --cached 比较暂存区和本地仓库（最新版本HEAD）的差异 git diff HEAD 比较工作区和本地仓库（最新版本HEAD）的差异 git diff commit_id 比较工作区和本地仓库（指定 commit_id 的版本）的差异 git diff --cached commit_id 比较暂存区和本地仓库（指定 commit_id 的版本）的差异 git diff commit_id commit_id 比较本地仓库中两个 commit-id 版本间的差异 7 git log git log [OPTION] 查看所有历史提交信息 OPTION -n 显示最近 n 条 -p 显示每次提交详细的变化 --oneline 一行显示（显示8位哈希值和提交message） --decorate 显示分支指针当前指向 --pretty= 使用其他格式显示 oneline 一行显示（显示完整哈希值和提交message） short full fuller format ...... --graph 显示分支合并图形 gitk 图形界面 相当于 git log 命令的可视化版本 8 git reflog git reflog 记录着每一次命令及其对应id git log 只会显示 HEAD 及其之前的 commit_id，回溯之后，可以用此命令查询 HEAD 之后的 commit_id 9 git reset git reset [OPTION] commit_id 回溯到指定 commit_id 的版本 OPTION --mixed（默认） 保留工作区，重置暂存区和本地仓库 --soft 保留工作区和暂存区，重置本地仓库 --hard 重置工作区、暂存区和本地仓库 版本说明 HEAD 当前版本 HEAD^ 上个版本 HEAD^^ 上上个版本 HEAD-100 上100个版本 10 git checkout git checkout branch_name 切换分支 git checkout -- FILE 从暂存区检出文件覆盖工作区 撤销修改 工作区没有 git add 到暂存区，即暂存区没有改变 git checkout -- FILE 直接从暂存区检出覆盖即可 工作区 git add 到暂存区，修改了暂存区 git reset HEAD FILE 默认 mixed 会重置暂存区和本地仓库 即恢复暂存区 git checkout -- FILE 从暂存区检出覆盖 六 分支6.1 分支操作1 查看分支 git branch [OPTION] 显示本地所有分支，当前分支前有 * 号 OPTION -r 显示远程所有分支 -a 显示本地和远程所有分支 -v 显示本地分支及其最后一次提交 -vv 显示本地分支及其跟踪的远程分支 --merged 显示分支列表中已经合并到当前分支的分支 --no-merged 显示分支列表中尚未合并到当前分支的分支 2 创建分支 git branch branch_name 3 切换分支 git checkout branch_name 或 git switch branch_name（新） 切换到指定分支 git checkout -b branch_name 或 git switch -c branch_name（新） 创建并切换到指定分支 4 删除分支 git branch -d branch_name 删除本地分支 git push remote_name --delete branch_name 删除远程分支 5 合并分支 git merge [--no-ff] branch_name 把指定分支合并到当前分支 --no-ff（no fast forward） 默认使用 fast forward 合并策略，其实就是将当前分支的指针指向了 branch_name --no-ff 每次合并都会产生一个新的提交 解决合并冲突 git status 查看冲突信息 vim 手动修改冲突文件 git add git commit 6.2 变基（rebase）1 概述 在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase 将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样，这种操作就叫做 变基 变基可以使提交历史更为线形，简洁，而合并则是保留每一个提交历史 如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基 只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作 2 变基原理 首先找到两个分支（要变基的分支 dev 和目标基底分支 master）的最近共同祖先 然后对比 dev 分支相对于该祖先的历次提交，提取相应的修改并存为临时文件 将 dev 分支指向 master 分支的最后一次提交 在 master 的最后一次提交，依序应用之前的临时文件，最后生成一个新的提交 之后将 dev 分支快速合并到 master 3 命令1 变基命令 git rebase base_branch [re_branch] 将 re_branch 分支变基到 base_branch 分支 base_branch 目标基底分支 re_branch 要变基的分支，省略则表示当前分支 git rebase --onto base_branch branch re_branch 首先找出 re_branch 分支与 branch 分支的分歧之后的提交 然后将这些提交变基到 base_branch 上 2 变基过程中的命令 git rebase --skip 跳过当前冲突 git rebase --abort 退出rebase模式 git add 解决冲突后使用 git add 表示冲突已经解决 git rebase --continue 解决冲突并 git add 之后，表示继续接下来的操作 4 修改提交1 合并多个连续提交 git rebase -i commit_id commit-id为所有要合的commit的前一个commit-id 会进入交互界面 要合成的commit第一个pick不变（要合成到这个提交上），剩下的改为s，pick s s s ... 进入提交信息修改界面 2 合并多个间隔提交 git rebase -i commit_id 手动调整commit位置，pick s s s ... git rebase --continue 进入commit信息修改页面 3 修改旧提交的 message git rebase -i commit_id 进入交互界面，使用相应命令 commit_id 要修改的提交的父提交的 commit_id 6.3 贮藏（stash）1 概述 当需要切换分支而又不想现在提交时，可以贮藏，然后恢复 只能贮藏已追踪和非 .gitignore 的文件 2 添加贮藏 git stash [push] [OPTION] [FILE] 将工作区和暂存区的状态存储起来以备将来使用，之后将工作区和暂存区内容重置为最近一次提交后的内容 push git stash 是 git stash push 的简写 OPTION -m &quot;message&quot; 添加暂存信息 -u, --include-untracked 将未追踪文件也贮藏 -a, --all 将忽略文件也贮藏 -k, --keep-index 表示只重置工作区，不重置暂存区 默认值是 --no-keep-index FILE 只贮藏指定文件 3 查看贮藏 git stash list 4 应用贮藏（恢复） git stash apply [stash_name] [--index] stash_name 省略表示应用最新一个贮藏，可以使用名称指定一个贮藏，如 stash@{2} --index 默认应用贮藏时，不会恢复暂存区，--index 表示恢复暂存区 git stash pop 用法同 git stash apply 区别 git stash apply 应用并保留贮藏 git stash pop 应用并删除贮藏 5 删除贮藏 git stash drop stash_name 删除指定储藏 git stash clear 删除所有储藏 6.4 追踪分支 git checkout -b &lt;本地分支名&gt; &lt;远程主机&gt;/&lt;远程分支名&gt; 创建一个本地分支追踪远程主机的远程分支 git checkout --track &lt;远程主机&gt;/&lt;远程分支名&gt; 创建一个与远程分支同名的本地分支来追踪远程主机的远程分支 git branch -u &lt;远程主机&gt;/&lt;远程分支名&gt; 设置当前本地分支追踪远程主机的远程分支 当设置好追踪分支后，可以通过 @{upstream} 或 @{u} 快捷方式来引用它 七 标签7.1 概述 类似于别名，因为 commit_id 看不出提交的信息，通过打标签可以更方便识别。 7.2 标签分类1 轻量标签（lightweight） 轻量标签就是个指向特定提交对象的引用 2 附注标签（annotated） 附注标签是存储在 Git 数据库中的一个完整对象 它有自身的校验和信息，包含着打标签者的名字，电子邮件地址、日期以及标签说明 标签允许使用 GNU Privacy Guard (GPG) 签名和验证 7.3 查看标签 git tag [-l Pattern] 查看所有标签，默认按字母排序 -l Pattern 只显示匹配的标签 git show tag_name 查看指定标签信息及其对应的提交信息 7.4 创建标签 git tag tag_name [commit_id] 创建轻量标签 默认为当前分支 HEAD 打标签，可以指定 commit_id git tag -a tag_name -m &quot;message&quot; [commit_id] 创建附注标签，并添加标签信息 git tag -s tag_name -m &quot;message&quot; [commit_id] 采用GPG签名创建附注标签，必须首先安装 GPG 7.5 推送标签 git push origin tag_name 推送一个本地标签到远程仓库 默认情况下，git push 命令并不会把标签推送到远端服务器上 git push origin --tags 推送全部不在远程仓库的本地标签 7.6 删除标签 git tag -d tag_name 删除本地标签 并不会从远程仓库中移除这个标签 git push remote_name :refs/tags/tag_name 删除远程标签 将冒号前面的空值推送到远程标签名，从而高效地删除它 git push remote_name --delete tag_name 删除远程标签，更直观 八 远程仓库8.1 远程仓库配置1 HTTPS 本地与远程通讯时需要邮箱和密码验证 2 SSH 查看本地 ~/.ssh 目录下是否有公钥和私钥，若没有则创建 id_rsa id_rsa.pub ssh-keygen -t rsa -b 4096 -C &quot;comment&quot; -t 密钥类型，默认 rsa -b 密钥长度，rsa 密钥，最小要求768位，默认是2048位 -C 注释信息 配置 GitHub Title 任意 Key id_rsa.pub 文件的内容 可以添加多个 8.2 远程仓库操作1 查看远程仓库 git remote 查看已经配置的远程仓库 git remote -v 查看已经配置的远程仓库及URL信息 git remote show remote_name 查看某个远程仓库的信息 2 添加远程仓库 git remote add ShortName URL ShortName 远程仓库别名，通常为 origin URL HTTPS https://github.com/username/repository.git SSH git@github.com:username/repository.git 3 重命名远程仓库 git remote rename old_name new_name 4 删除远程仓库 git remote remove remote_name 8.3 git push git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 将本地分支推送到远程仓库的指定分支 git push &lt;远程主机名&gt; &lt;本地分支名&gt; 省略远程分支 表示将本地分支推送到远程同名分支，如果不存在，则创建 git push &lt;远程主机名&gt; :&lt;远程分支名&gt; 省略本地分支 相当于推送了一个空的本地分支，即删除指定的远程分支，等价于 git push &lt;远程主机名&gt; --delete &lt;远程分支名&gt; git push &lt;远程主机名&gt; 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略 表示将当前分支推送到远程对应分支 git push 如果当前分支只与一个远程主机的存在追踪关系，则主机名可以省略 git push -u &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; -u 如果当前分支与多个远程主机的存在追踪关系，第一次推送使用 -u 指定一个默认的远程主机 以后就可以省略 推送模式 simple 默认，只推送当前分支 matching 推送所有有对应的远程分支的本地分支 8.4 git clone git clone URL 克隆到当前目录，通常会自动地创建一个跟踪 origin/master 的 master 分支 URL HTTPS https://github.com/username/repository.git SSH git@github.com:username/repository.git 8.5 git fetch git fetch &lt;远程主机名&gt; 将远程仓库所有分支的更新取回到本地 git fetch &lt;远程主机名&gt; &lt;远程分支名&gt; 将远程仓库指定分支的更新取回到本地 FETCH_HEAD 指向使用 git fetch 从远程仓库取下来的指定分支的最新版本 8.6 git pull git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 取回远程主机某个分支的更新，并与本地的指定分支合并 8.7 git fetch &amp; git pull 三个概念 本地仓库 远程仓库（本地的）.git/refs/remotes 远程仓库（远程的） git fetch 将本地的远程仓库更新到与远程的远程仓库一致 不会更新本地仓库 git pull 将本地仓库和本地的远程仓库都更新到与远程的远程仓库一致 如果工作区有一些修改尚未提交到本地仓库，即工作区与本地仓库不一致，则此时禁止 git pull git pull orgin master = git fetch orign master; git merge orgin/master 九 技9.1 忽略文件 在工作区创建 .gitignore 文件（可以从网上查询），然后把要忽略的文件名填进去 忽略文件的原则： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的 .class 文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件 9.2 git clone 速度 查询域名 global-ssl.fastly.Net 和 github.com 公网IP地址 将域名与IP映射添加到本地 hosts 文件 /etc/hosts linux c:/windows/system32/driver/etc/hosts windows 刷新DNS缓存 sudo /etc/init.d/networking restart linux ipconfig /flushdns windows 9.3 分离头指针（detached HEAD） 通常，我们工作在某一个分支上，比如 master 分支。这个时候 master 指针和 HEAD 指针是一起前进的，每做一次提交，这两个指针就会一起向前挪一步。但是在某种情况下（例如 checkout 了某个具体的 commit），master 指针 和 HEAD 指针这种「绑定」的状态就被打破了，变成了分离头指针状态 即工作在没有分支的状态下，commit没有和任何分支相关联，此时如果切换分支，则分离头指针状态下的变更都会丢失。 如果想要保留分离头指针变更，就将其与某个分支绑定 git branch 分支名 分离头指针commit_id","categories":[{"name":"技","slug":"技","permalink":"https://anyeansan.github.io/categories/%E6%8A%80/"},{"name":"Git","slug":"技/Git","permalink":"https://anyeansan.github.io/categories/%E6%8A%80/Git/"}],"tags":[]},{"title":"CSS 响应式布局","slug":"CSS-响应式布局","date":"2020-03-30T13:12:49.000Z","updated":"2020-03-30T13:13:09.487Z","comments":true,"path":"2020/03/30/CSS-响应式布局/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/CSS-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/","excerpt":"","text":"一 媒体查询 Media Querie Media Queries能在不同的条件下使用不同的样式，使页面在不同在终端设备下达到不同的渲染效果 二 媒体类型 media 选项 说明 all（默认） 所有媒体类型 screen 用于电脑屏幕，平板电脑，智能手机等 print 打印设备 speech 应用于屏幕阅读器等发声设备 多媒体支持 可以用逗号分隔同时支持多个媒体设备 如 screen, print 三 使用3.1 &lt;style&gt;1&lt;style media=&quot;&quot;&gt;&lt;/style&gt; 3.2 &lt;link&gt;1&lt;link rel=&quot;&quot; href=&quot;&quot; media=&quot;&quot;&gt; 3.3 @import1234567// test.html&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;// style.css@import url(1.css) all;@import url(2.css) screen;@import url(3.css) print;...... 通过&lt;link&gt;指定媒体类型需要导入不同的css文件，导致&lt;link&gt;语句过多 可以导入一个css文件，然后在此css文件中通过@import 引入其它css文件并指定媒体类型 3.4 @media123456&lt;style&gt; @media screen &#123; &#125; @media print &#123; &#125;&lt;/style&gt; 可以使用 @media 做到更细的控制，即在一个样式表中为多个媒体设备定义样式 四 查询条件 条件表达式需要放在括号中 4.1 逻辑与 and12@media screen and (max-width: 769px) &#123;&#125; 4.2 逻辑或 ,12@media screen and (orientation: landscape), screen and (max-width: 600px) &#123;&#125; 4.3 逻辑非 not12@media not screen and (max-width: 769px) &#123;&#125; 必须将not写在查询的最前面，表示对整个条件取反 4.4 only 用来排除不支持媒体查询的浏览器12@media only screen and (max-width: 769px) &#123;&#125; 必须将only写在查询的最前面，表示如果浏览器支持媒体查询，就根据条件响应样式，如果不支持，就忽略 五 查询特性 根据查询特性筛选出使用样式的设备。 特性 说明 orientation: landscape/portrait 横屏/竖屏 width 设备宽度 height 设备高度 min-width 最小宽度 max-width 最大宽度 min-height 最小高度 max-height 最大高度","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"CSS","slug":"UI/CSS","permalink":"https://anyeansan.github.io/categories/UI/CSS/"}],"tags":[]},{"title":"CSS 帧动画","slug":"CSS-帧动画","date":"2020-03-30T13:12:06.000Z","updated":"2020-03-30T13:12:33.095Z","comments":true,"path":"2020/03/30/CSS-帧动画/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/CSS-%E5%B8%A7%E5%8A%A8%E7%94%BB/","excerpt":"","text":"一 概述 通过定义一段动画中的关键点、关键状态来创建动画 过渡动画是两个状态间的变化，帧动画可以理解为帧之间的过渡动画 二 关键帧 @keyframes12345678910@keyframes &lt;keyframes-name&gt; &#123; from &#123; margin-left: 100%; width: 300%; &#125; to &#123; margin-left: 0%; width: 100%; &#125;&#125; 使用@keyframes 规则定义动画名（animation-name）及其关键帧列表，每个@keyframes 规则包含多个关键帧 每个关键帧有一个百分比值作为名称，代表在动画进行中，在哪个阶段触发这个帧所包含的样式（顺序任意） from 相当于 0%，to 相当于 100% 未设置from/0%与to/100% 时将使用元素现有样式作为起始/结束状态，可以用来从初始状态开始元素动画，最终返回初始状态。 动画名称或关键帧名称重复时，后者覆盖前者 关键帧中出现的 !important 关键词将会被忽略 三 animation3.1 语法12345678animation-nameanimation-durationanimation-timing-functionanimation-delayanimation-iteration-countanimation-directionanimation-fill-modeanimation-play-state 必须存在 animation-duration 属性，否则过渡时间为0没有动画效果 延迟时间在过渡时间之后 3.2 animation-name 指定使用的动画，可以多个用逗号隔开 多个动画有相同属性时，后面动画的属性优先使用 3.3 animation-duration 声明动画播放的时间，即把所有帧执行一遍所需要的时间，默认为 0s 使用秒和毫秒为单位 可以为不同动画分别设置执行视角 如果动画数量大于时间数量，则超出的动画从第一个时间重新循环 3.4 animation-timing-function 定义动画速率 值 说明 ease（默认） 开始慢，然后快，慢下来，结束时非常慢（等于 cubic-bezier(0.25,0.1,0.25,1)） linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。 ease-in 开始慢，结束快（等于cubic-bezier(0.42,0,1,1)） ease-out 开始快，结束慢（等于 cubic-bezier(0,0,0.58,1)） ease-in-out 中间快，两边慢（等于 cubic-bezier(0.42,0,0.58,1)） cubic-bezier(n,n,n,n) 三次贝塞尔曲线，在 cubic-bezier 函数中定义自己的值 step-start 同 steps(1, start) step-end 同steps(1,end) steps(n, start) 设置n个时间点，第一时间点变化状态 steps(n, end) 设置n个时间点，第一时间点初始状态 * &lt;timing-function&gt; （此属性接收的值） 作用于每两个关键帧之间，而不是整个动画 steps(n, start/end) n 正整数，将间隔动画等分成指定数目的小间隔动画，然后根据第二个参数来决定显示效果 start/end 在分成的小间隔动画中判断显示效果，意思是每一阶段动画的改变时机 start表示从开始改变，即这一段动画的初始状态，显示的就是结束时的效果，可以理解为从下一步开始 end表示从结束改变，即这一段动画的初始状态，显示的是开始时的效果，可以理解为从当前步开始 3.5 animation-delay 定义动画等待多长时间后执行 3.6 animation-iteration-count 设置动画重复执行次数 设置值为 infinite 表示无限循环 可同时设置元素的多个动画重复，使用逗号分隔 如果动画数量大于重复数量，超出动画从第一个重复次数重新循环 3.7 animation-direction 控制动画运行的方向 值 说明 normal（默认） 从0%到100%运行动画 reverse 从100%到0%运行动画 alternate 先从0%到100%，然后从100%到0% alternate-reverse 先从100%到0%，然后从0%到100% 3.8 animation-play-state 可以控制动画的暂停与运行 恢复一个已暂停的动画，将从它暂停的地方开始，而不是从动画序列的起点开始 值 说明 running（默认） 运行 paused 暂停 3.9 animation-fill-mode 设置CSS动画在执行之前和之后如何将样式应用于其目标 值 说明 none（默认） 动画执行之前效果在初始状态，等延迟结束，起始帧才应用，动画执行之后会回到初始状态 backwards 动画执行之前效果就在起始帧，不会等延迟结束 forwards 动画执行之后停留动画的最后一帧 both 包含backwards与forwards规则，即动画执行之前在起始帧，不等延迟结束，动画执行之后停止在最后一帧","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"CSS","slug":"UI/CSS","permalink":"https://anyeansan.github.io/categories/UI/CSS/"}],"tags":[]},{"title":"CSS 过渡 延迟","slug":"CSS-过渡-延迟","date":"2020-03-30T13:11:36.000Z","updated":"2020-03-30T13:11:54.903Z","comments":true,"path":"2020/03/30/CSS-过渡-延迟/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/CSS-%E8%BF%87%E6%B8%A1-%E5%BB%B6%E8%BF%9F/","excerpt":"","text":"一 概述 默认情况下CSS属性的变化是瞬间完成的（其实也有时间只是毫秒级的，人眼很难感知到） 不是所有css属性都有过渡效果，一般来讲有中间值的属性都可以设置动画如宽度、透明度等。 二 transitionend 用于控制过渡结束后执行的JS事件（即过度结束触发此事件） 简写属性会触发多次 三 transition3.1 语法1234transition-propertytransition-timing-functiontransition-durationtransition-delay 必须设置过渡时间 transition-duration 延迟时间transition-delay在过渡时间之后 3.2 transition-property 指定应用过渡属性的名称 如果指定简写属性（比如 background），那么其完整版中所有可以动画的属性都会被应用过渡。 值 说明 all（默认） 所有可被动画的属性都表现出过渡动画 none 没有过渡动画。 ident 属性名称，多个用逗号隔开 3.3 transition-duration 以秒或毫秒为单位指定过渡动画所需的时间，默认 0 秒（即不出现过渡动画），不能为负 一个值时，所有属性使用同样的时间 多个值时，如果属性数量大于值数量，超出的属性再从第一个时间开始重复使用 可以为初始与变化状态设置不同的时间 3.4 transition-timing-function 用于设置过渡效果的速度 值 说明 ease（默认） 开始慢，然后快，慢下来，结束时非常慢（等于 cubic-bezier(0.25,0.1,0.25,1)） linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。 ease-in 开始慢，结束快（等于cubic-bezier(0.42,0,1,1)） ease-out 开始快，结束慢（等于 cubic-bezier(0,0,0.58,1)） ease-in-out 中间快，两边慢（等于 cubic-bezier(0.42,0,0.58,1)） cubic-bezier(n,n,n,n) 三次贝塞尔曲线，在 cubic-bezier 函数中定义自己的值 step-start 同 steps(1, start) step-end 同steps(1,end) steps(n, start/end) 类似帧 3.5 transition-delay 用于设置延迟过渡的时间（即在过渡效果开始作用之前需要等待的时间） 默认为0s即立刻开始过渡 值可以为负数，如-3s，表示直接显示在3s时的效果 变化属性数量大于时间数量时，后面的属性再从第一个时间开始重复使用","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"CSS","slug":"UI/CSS","permalink":"https://anyeansan.github.io/categories/UI/CSS/"}],"tags":[]},{"title":"CSS 变形","slug":"CSS-变形","date":"2020-03-30T13:10:43.000Z","updated":"2020-03-30T13:11:18.542Z","comments":true,"path":"2020/03/30/CSS-变形/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/CSS-%E5%8F%98%E5%BD%A2/","excerpt":"","text":"一 坐标轴 二 变形操作 transform2.1 概述 使用 transform 规则控制元素的变形操作，包括控制移动、缩放、旋转、倾斜、3D转换等 变形叠加 重复设置变形操作时只在原形态上操作，即第二次设置值时不是在第一次值上变化（就类似后边设置的字体大小会覆盖前边的而不是在前边设置的基础上再变化） 行级元素不产生变形效果 可同时设置多个值，解析器会从左向右依次执行，顺序不同效果也不同 2.2 移动 选项 说明 translateX(x) 定义x轴偏移量 translateY(y) 定义y轴偏移量 translateZ(z) 定义z轴偏移量 translate(x,y) 定义x，y轴偏移量 translate3d(x,y,z) 定义x，y，z轴偏移量 偏移量正负来决定移动方向 X轴：整数向右，负数向左 Y轴：整数向下，负数向上 Z轴：正数向外、负数向里 xy轴因为有宽高可以使用百分比（即偏移量为元素的百分比），z轴则不可以用百分比。 2.3 缩放 选项 说明 scaleX(x) 定义x轴的缩放 scaleY(y) 定义y轴的缩放 scaleZ(z) 定义z轴的缩放 scale(x,y) 定义x，y轴的缩放 scale3d(x,y,z) 定义x，y，z轴的缩放 缩放的值为原尺寸的倍数 2.4 旋转 选项 说明 rotateX(angle) 定义沿着 X 轴的 3D 旋转，angle：角度 rotateY(angle) 定义沿着 Y 轴的 3D 旋转 rotateZ(angle) 定义沿着 Z 轴的 3D 旋转 rotate(angle) 定义 2D 旋转（即沿着xy平面旋转也就是z轴，效果同rotateZ(angle)） rotate3d(x,y,z,angle) 定义 3D 旋转，（x,y,z）定义一个向量 2.5 倾斜 选项 说明 skewX(angle) 定义沿着 X 轴的 2D 倾斜。 skewY(angle) 定义沿着 Y 轴的 2D 倾斜。 skew(x-angle,y-angle) 定义沿着 X 和 Y 轴的 2D 倾斜。 三 变形基点 transform-origin 使用 transform-origin 设置元素的X/Y/Z操作的基点，用于控制缩放，旋转、倾斜等操作 默认以元素中心为基点 移动不受变形基点影响 四 透视景深 perspective4.1 概述 perspective属性用于规定观察点距离元素的距离 我们观察物体时，远小近大，如果足够长，尽头会在视觉上相交 在二维屏幕上通过物体的大小来实现3效果 4.2 舞台透视 perspective: 100px “perspective 规则” 用于将父级整个做为透视元素，会造成里面的每个子元素的透视是不一样的 例如摆一排杯子，是使用统一透视的，每个杯子的透视不一样，造成有大有小 4.3 单独透视 transform: perspective(100px) “perspective 函数” 用于为元素设置单独透视，每个元素的透视效果是一样的。 五 3D透视 transform-style 选项 说明 flat 2D平面舞台 preserve-3d 3D透视舞台 使用 transform-style 用于控制3d透视 应用于舞台即变形元素的父级元素 设置 overflow:visible 时 preserve-3d 才无效 六 观看视角 perspective-origin 选项 说明 x-axis 定义该视图在 x 轴上的位置。默认值：50%。可能的值：left、center、right、length、% y-axis 定义该视图在 y 轴上的位置。默认值：50%。可能的值：top、center、bottom、length、% perspective-origin用于控制视线的落点。就好像我们看车展，可以让车转，也可以我们自己转(perspective-origin) 需要设置 perspective 透视后才可以看到效果 一般设置在舞台元素上来控制子元素 七 隐藏背面 backface-visibility 选项 说明 visible 背面可见 hidden 背面隐藏 使用 backface-visibility 用于控制是否可以看到元素的背面 一般设置在元素上而不是舞台元素上 如果设置在舞台元素（父级元素）需要设置 transform-style: preserve-3d","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"CSS","slug":"UI/CSS","permalink":"https://anyeansan.github.io/categories/UI/CSS/"}],"tags":[]},{"title":"CSS 栅格布局","slug":"CSS-栅格布局","date":"2020-03-30T13:10:12.000Z","updated":"2020-03-30T13:10:35.499Z","comments":true,"path":"2020/03/30/CSS-栅格布局/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/CSS-%E6%A0%85%E6%A0%BC%E5%B8%83%E5%B1%80/","excerpt":"","text":"一 概述 将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局 Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是二维布局 设为网格布局以后，容器子元素（项目）的float、vertical-align等设置都将失效 二 基本概念 栅格容器（Grid Container）：采用 grid 布局的元素 栅格项目（Grid Item）：栅格容器中采用网格定位的子元素 栅格线（Grid Line）：划分网格的线 栅格轨道（Grid Track）：两条相邻网格线之间的空间，即行（row）或者列（column） 栅格单元格（Grid Cell）：行和列的交叉区域 栅格区域（Grid Area）：由任意数量单元格组成的区域（必须为矩形） 三 声明容器 display: grid 块级栅格容器 display: inline-grid 内联栅格容器 四 容器属性4.1 grid-template-rows &amp; grid-template-columns grid-template-rows：定义每一行的高度 grid-template-columns：定义每一列的宽度 1 语法1[ &lt;line-names&gt;? [ &lt;track-size&gt; | &lt;track-repeat&gt; ] ]+ &lt;line-names&gt;? 2 &lt;line-names&gt; 相应位置上的删格线名称 可以省略，则名称按顺序分配为 1 2 3 ... 格式：[name1 name2 ...] 可以指定1或多个名称 3 &lt;track-size&gt; 值 说明 auto 表示由浏览器自己决定长度 &lt;length&gt; 长度单位 &lt;percentage&gt; 栅格容器宽/高的百分比 fr 网格剩余空间比例单位（fraction 的缩写，意为”片段”） minmax(min, max) 尺寸在min和max之间，若min&gt;max，则max的值会被忽略 4 &lt;track-repeat&gt; repeat( count, [ &lt;line-names&gt;? &lt;track-size&gt; ]+ &lt;line-names&gt;? ) count：重复次数 如果重复次数不确定可以使用 auto-fill 关键字 auto-fit 关键字 4.2 grid-template-areas 区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end 1 为每个单元格设置区域（假如三行三列9个单元格）123grid-template-areas: &quot;a b c&quot; &quot;d e f&quot; &quot;g h i&quot;; 2 多个单元格合并成一个区域：区域名相同即可123456grid-template-areas: &quot;a a a&quot; &quot;b b b&quot; &quot;c c c&quot;;grid-template-areas: &quot;header header header&quot; &quot;main main sidebar&quot; &quot;footer footer footer&quot;; 3 区域占位符（点）：表示没有用到该单元格，或者该单元格不属于任何区域123grid-template-areas: &quot;a . c&quot; &quot;. . f&quot; &quot;g h .&quot;; 4.3 grid-template grid-template是grid-template-rows，grid-template-columns和grid-template-areas属性的缩写 推荐使用 grid 代替grid-template 4.4 row-gap &amp; column-gap &amp; grap 属性 说明 row-gap 设置行与行的间隔（行间距） column-gap 设置列与列的间隔（列间距） grap row-gap column-gap 如果grap省略了第二个值，浏览器认为第二个值等于第一个值 4.5 grid-auto-flow 划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。 取值 说明 row（默认） 先行后列 column 先列后行 row dense 先行后列，并且尽量填满空格 column dense 先列后行，并且尽量填满空格 尽量填满的意思是比如第2个元素太宽第一行放不下，可以先放第3,4…个 4.6 justify-items &amp; align-items &amp; place-items 属性 说明 justify-items 单元格中的元素在单元格中的水平对齐方式（针对所有单元格） align-items 单元格中的元素的在单元格中垂直对齐方式（针对所有单元格） place-items align-items justify-items 简写 place-items 如果省略第二个值，则浏览器认为第二个值等于第一个值 取值 说明 stretch（默认） 拉伸，占满单元格的整个宽度 start 对齐单元格的起始边缘 end 对齐单元格的结束边缘 center 单元格内部居中 4.7 justify-content &amp; align-content &amp; place-content 属性 说明 justify-content 所有单元格（整个内容区域）在容器中的水平对齐方式 align-content 所有单元格（整个内容区域）在容器中的垂直对齐方式 place-content align-content justify-content 简写 place-content 如果省略第二个值，则浏览器认为第二个值等于第一个值 取值 说明 stretch（默认） 拉伸，占满单元格的整个宽度 start 对齐单元格的起始边缘 end 对齐单元格的结束边缘 center 单元格内部居中 space-between 两端对齐，两端紧挨边框中间平均分配 space-around 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍 space-evenly 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔 4.8 grid-auto-columns &amp; grid-auto-rows 属性 说明 grid-auto-columns 浏览器自动创建的多余网格的列宽 grid-auto-rows 浏览器自动创建的多余网格的行高 有时，一些项目的指定位置，在现有网格的外部，比如网格只有三行，但是有一个项目在第五行，这时，浏览器会自动生成多余的网格，以便放置项目。 如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高 4.9 grid grid-template-rows grid-template-columns grid-template-areas grid-auto-rows grid-auto-columns grid-auto-flow 六个属性的缩写 五 项目属性5.1 grid-column-start &amp; grid-column-end &amp; grid-row-start &amp; grid-row-end 属性 说明 grid-row-start 行开始栅格线（上边框） grid-row-end 行结束栅格线（下边框） grid-column-start 列开始栅格线（左边框） grid-column-end 列结束栅格线（右边框） 项目定位1 根据栅格线1234grid-column-start: 1;grid-column-end: 3;grid-row-start: 2;grid-row-end: 4; 设置栅格线来定位，设置的数值可以是正数和负数 2 根据栅格命名 固定命名12grid-column-start: header-start;grid-column-end: header-end; 自动命名123// 后边数字表示第几个grid-column-start: c-start 1;grid-column-end: c-end 3; 3 根据偏移量12grid-row-end: span 1;grid-column-end: span 1; span 可以设置移动单元格数量（即开始栅格线和结束栅格线之间有几个单元格），数值只能为正数 5.2 grid-column &amp; grid-row 属性 说明 grid-row grid-row-start / grid-row-end grid-column grid-column-start / grid-column-end 设置起始栅格线12grid-column: 1 / 3;grid-row: 1 / 2; 使用span1234grid-column: 1 / span 3;grid-row: 1 / span 2;// 如果省略斜杠及后面部分，表示span值为1grid-row: 1; 5.3 grid-area 指定项目放在哪一个区域1grid-area: 区域名; grid-row-start/grid-column-start/grid-row-end/grid-column-end1grid-area: 2/2/3/4; 5.4 justify-self &amp; align-self &amp; place-self 属性 说明 justify-self 单元格中的元素在单元格中的水平对齐方式（针对单个单元格） align-self 单元格中的元素在单元格中的垂直对齐方式（针对单个单元格） place-self align-self justify-self 简写 justify-self 用法同justify-items align-self 用法同align-items place-selef 如果省略第二个值，则浏览器认为第二个值等于第一个值","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"CSS","slug":"UI/CSS","permalink":"https://anyeansan.github.io/categories/UI/CSS/"}],"tags":[]},{"title":"CSS 继承和层叠","slug":"CSS-继承和层叠","date":"2020-03-30T12:59:51.000Z","updated":"2020-03-30T13:10:00.320Z","comments":true,"path":"2020/03/30/CSS-继承和层叠/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/CSS-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%B1%82%E5%8F%A0/","excerpt":"","text":"一 继承1.1 控制继承 CSS 为控制继承提供了四个特殊的通用属性值。每个css属性都接收这些值 值 说明 inherit 设置该值会使子元素属性和父元素相同。实际上，就是 “开启继承”. initial 设置 CSS 属性为它的默认值 unset 如果该属性默认可继承，该值等同于 inherit，如果该属性是非继承属性，该值等同于 initial revert 只有很少的浏览器支持 1.2 元素可继承属性12345678azimuth border-collapse border-spacing caption-side color cursordirection elevation empty-cells font-family font-size font-style font-variant font-weight font letter-spacing line-height list-style-image list-style-position list-style-type list-styleorphans pitch-range pitch quotes richness speak-headerspeak-numeral speak-punctuation speak speech-rate stresstext-align text-indent text-transform visibility voice-family volumewhite-space widows word-spacing 1 文本相关属性123font-family font-size font-style font-variant font-weight font letter-spacing line-heighttext-align text-indent text-transform word-spacing color 2 列表相关属性1list-style-image list-style-position list-style-type list-style 3 表格相关属性1border-collapse border-spacing empty-cells 4 可见性相关属性1visibility 二 层叠2.1 层叠上下文 stacking context 层叠上下文是一个概念，跟“块状格式化上下文”（BFC）类似，可以想象成z轴上的一个层叠结界 1 层叠上下文特性 层叠上下文的层叠水平要比普通元素高。 层叠上下文可以阻断元素的混合模式 层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。 每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。 每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中 2 创建层叠上下文 页面根元素&lt;html&gt;天生具有层叠上下文，称为根层叠上下文。 定位元素（position非static）的z-index不是auto，会创建层叠上下文 其它css3属性创建层叠上下文 元素为 flex 布局元素（即父元素 display:flex / inline-flex），同时 z-index值不是 auto。 元素的 opacity 值不是 1。 元素的 transform 值不是 none。 元素 mix-blend-mode 值不是 normal。 元素的 filter 值不是 none。 元素的 isolation 值是 isolate。 元素的 will-change 属性值为上面 2～6 的任意一个（如willchange:opacity、will-chang:transform 等）。 元素的-webkit-overflow-scrolling 设为 touch。 2.2 层叠水平 stacking level 决定了同一个层叠上下文中元素在 z 轴上的显示顺序 所有元素都有层叠水平，普通元素的层叠水平在其层叠上下文中有意义 2.3 层叠顺序 stacking order 就是根据层叠水平规定在z轴显示顺序的规则 每一个层叠顺序规则仅适用于当前层叠上下文元素的小世界 ![](https://gitee.com/3noanswer/npics/raw/master/UI/CSS/stacking order.png) 在同一个层叠上下文中的七层 层叠上下文的背景和边框 层叠上下文中z-index值为负的层叠上下文元素 层叠上下文中块级普通元素 层叠上下文中浮动元素 层级上下文中内联普通元素 此层包含三种 层叠上下文中不依赖z-index 的层叠上下文元素（即元素创建层叠上下文时不是用的z-index） 层叠上下文中z-index值为 0 的层叠上下文元素 层叠上下文中z-index值为 auto 的普通定位元素 元素一旦成为定位元素，其z-index就会自动生效，默认为auto 定位元素的z-index值为数值时才是层叠上下文，所以此时是普通定位元素，并非层叠上下文 层叠上下文中z-index值为负的层叠上下文元素 比较步骤 首先查看两个元素是否在同一个层叠上下文 否，则查看它们所在的层叠上下文是否在同一个层叠上下文，如果还不是，继续往上…直到两个层叠上下文在同一个层叠上下文中，最终肯定在同一个层叠上下文，因为有根层叠上下文。 是，则根据它们的层叠水平，在层叠顺序中找到位置。 如果在层叠顺序中位置相同 如果明显的层叠水平标识的，如生效的z-index，则谁大谁在上 如果没有明显的层叠水平标识的，则后来居上（即在 DOM 流中处于后面的元素会覆盖前面的元素） 2.4 z-index 设定了一个定位元素及其后代元素或 flex 项目的 z-order 即只能用在 定位元素 flex 布局中的项目 值 说明 auto（默认） 不会创建一个新的本地堆叠上下文 &lt;integer&gt; 创建层叠上下文，可以为负","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"CSS","slug":"UI/CSS","permalink":"https://anyeansan.github.io/categories/UI/CSS/"}],"tags":[]},{"title":"CSS 弹性布局","slug":"CSS-弹性布局","date":"2020-03-30T12:58:23.000Z","updated":"2020-03-30T12:59:32.504Z","comments":true,"path":"2020/03/30/CSS-弹性布局/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/CSS-%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/","excerpt":"","text":"一 概述 Flex 是 Flexible Box 的缩写，意为”弹性布局”，可以轻松的控制元素排列、对齐和顺序的控制 任何一个容器都可以指定为 Flex 布局 设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效 弹性元素均为块元素 绝对定位的弹性元素不参与弹性布局 文本节点也在弹性布局操作范围内 在弹性布局中对元素使用margin-right:auto 等形式可以自动撑满空间 二 基本概念 Flex 容器（flex container）：采用 Flex 布局的元素 Flex 项目（flex item）： Flex 容器中的子元素 主轴（main axis）：默认是水平轴 主轴的开始位置（与边框的交叉点）叫做 main start 主轴的结束位置叫做 main end 单个项目占据的主轴空间叫做 main size 交叉轴（cross axis）：默认是垂直轴 交叉轴的开始位置叫做 cross start 交叉轴的结束位置叫做 cross end 单个项目占据的交叉轴空间叫做 cross size 三 声明容器 display:flex 块级弹性盒子 display:inline-flex 内联级弹性盒子 四 容器属性4.1 flex-direction 决定主轴的方向 取值 说明 row（默认） 主轴为水平方向，起点在左端（从左到右） row-reverse 主轴为水平方向，起点在右端（从右到左） column 主轴为垂直方向，起点在上沿（从上到下） column-reverse 主轴为垂直方向，起点在下沿（从下到上） 4.2 flex-wrap 默认情况下，项目都排在一条线（又称”轴线”）上 flex-wrap属性定义，如果一条轴线排不下，如何换行 取值 说明 nowrap（默认） 不换行/列 wrap 换行/列，新行在下 / 新列在右 wrap-reverse 换行/列，新行在上 / 新列在左 4.3 flex-flow flex-direction || flex-wrap flex-flow 是 flex-direction 与 flex-wrap 的组合简写模式，默认 row nowrap 4.4 justify-content 定义了项目在主轴上的对齐方式 取值 说明 flex-start（默认） 元素紧靠主轴起点，左对齐 flex-end 元素紧靠主轴终点，右对齐 center 元素从弹性容器中心开始，居中 space-between 第一个元素靠起点，最后一个元素靠终点，余下元素平均分配剩余空间，两端对齐 space-around 每个元素两侧的间隔相等。所以，项目之间的间隔是项目与边框的间隔的2倍 space-evenly 元素间距离平均分配，所有间距都相等 4.5 align-items 交叉轴上所有项目的对齐方式 取值 说明 stretch（默认） 如果项目未设置高度或设为auto，将占满整个容器的高度 center 交叉轴的中点对齐 flex-start 交叉轴的起点对齐 flex-end 交叉轴的终点对齐 baseline 项目的第一行文字的基线对齐 4.6 align-content 定义多行在交叉轴的对齐方式，如果只有一行则无效 取值 说明 stretch（默认） 轴线占满整个交叉轴 flex-start 与交叉轴的起点对齐 flex-end 与交叉轴的终点对齐 center 与交叉轴的中点对齐 space-between 与交叉轴两端对齐，轴线之间的间隔平均分布 space-around 每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍 space-evenly 轴线间距离相等 五 项目属性5.1 order 定义项目的排列顺序。数值越小，排列越靠前 值 说明 &lt;integer&gt; 默认为 0，可以为负 5.2 flex-grow 指定容器有剩余空间时（即项目宽度之和小于容器宽度）项目的分配规则 剩余空间 = 容器宽度 - 项目宽度之和 默认值是0，不分配多余空间 值 说明 &lt;number&gt; 默认为 0，数字为放大比例，不能为负 * 计算规则 5.3 flex-shrink 指定容器有溢出空间时（即项目宽度之和大于容器宽度）项目的分配规则 溢出空间 = 项目宽度之和 - 容器宽度 值 说明 &lt;number&gt; 默认为 1，数字为缩小比例，不能为负 * 计算规则 * 其实还要算padding border magin..总之很复杂 5.4 flex-basis 指定了 项目在主轴方向上的初始大小。如果不使用 box-sizing 改变盒模型的话，则flex-basis是作用在 content-box 上的 flex-basis的优先级高于width / height属性，低于min-width max width / min-height max-height 值 说明 auto（默认） 项目的本来大小（参照width和height属性） &lt;length&gt; 长度单位 &lt;percentage&gt; 相对于弹性容器主轴尺寸的百分比 content 基于项目的内容自动调整大小 5.5 flex &lt;flex-grow&gt; &lt;flex-shrink&gt;? || &lt;flex-basis&gt; 是flex-grow, flex-shrink 和 flex-basis的简写 值 说明 0 1 auto（默认） 即三个属性分别的默认值 auto 相当于 1 1 auto none 相当于 0 0 auto 5.6 align-self 交叉轴上单个项目对齐方式 覆盖已有的 align-items 的值. 如果项目的交叉轴方向 margin 值设置为 auto，则会忽略align-self 值 说明 auto（默认） 设置为父元素的 align-items 值，如果该元素没有父元素的话，就设置为 stretch strech 如果项目未设置高度或设为auto，将占满整个容器的高度 flex-start 交叉轴的起点对齐 flex-end 交叉轴的终点对齐 center 交叉轴的中点对齐 baseline 项目的第一行文字的基线对齐","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"CSS","slug":"UI/CSS","permalink":"https://anyeansan.github.io/categories/UI/CSS/"}],"tags":[]},{"title":"CSS 浮动和定位","slug":"CSS-浮动和定位","date":"2020-03-30T12:57:30.000Z","updated":"2020-03-30T12:58:05.986Z","comments":true,"path":"2020/03/30/CSS-浮动和定位/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/CSS-%E6%B5%AE%E5%8A%A8%E5%92%8C%E5%AE%9A%E4%BD%8D/","excerpt":"","text":"一 浮动1.1 float 取值 说明 left 左浮动 right 右浮动 none 无浮动 1.2 浮动的特性1 包裹性 包裹和自适应（类似width: fit-content） 2 块状化并格式化上下文 元素display值 inline-table会变成table， 其它都会变成block 3 破坏文档流 元素浮动会脱离文档路，尽量向左上或右上浮动，直到遇到父元素的边框或者其它浮动元素 假如元素A浮动，如果A元素上一个元素 也是浮动的，那么A会跟在上一个元素后边（一行放不下则A会被挤到下一行） 是标准文档流中的元素，那么A的相对垂直位置不变，即元素A的顶部与上一个元素底部对齐。 4 没有任何 margin 合并1.3 文字环绕的机制 浮动的本质就是为了实现文字环绕效果 1 父元素的高度塌陷 为了让文字内容可以和浮动元素在一个水平线上 2 行框盒子和浮动元素的不可重叠性 行框盒子如果和浮动元素的垂直高度有重叠，则行框盒子在正常定位状态下只会跟随浮动元素，而不会发生重叠 1.4 clear 取值 说明 none（默认） 允许浮动元素出现在两侧。 left 在左侧不允许浮动元素。 right 在右侧不允许浮动元素。 both 在左右两侧均不允许浮动元素。 1. 清除浮动原因 * 浮动脱离文档流，只含有浮动元素的父容器，在显示时不考虑浮动子元素的位置，父元素高度会塌陷 2. css的清除浮动只能影响清除浮动的元素本身，无法影响其它元素。 3. clear 属性只有块级元素才有效的，而::after 等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置 display 属性值的原因 1.5 清除浮动的方式1 clear1 父元素定义height（不推荐） 父级元素显式定义高度，就解决了无法自动获取到高度的问题 缺点 只适合高度固定时使用 2 父元素末尾添加一个空标签用来清除浮动（不推荐） 空标签清除两侧浮动，不受浮动元素影响，所在高度不会变，父元素就能获取高度 缺点 会添加不必要的标签 3 使用父元素的伪元素来清除浮动（推荐）12345父元素::after &#123; content: &apos;&apos;; display: block; // clear只对块级元素有效，伪元素默认为内联元素 clear: both;&#125; 2 触发BFC display: flow-root overflow: hidden 1 BFC概念 Block Formatting Context 块级格式化上下文 所谓的BFC就是css布局的一个概念，是一块区域，一个环境。另外还有IFC（inline formattion context），GFC（grid formattion context） BFC会形成一个隔离的独立容器，容器里面的子元素不会影响到外面的元素；外面的元素也不会影响到容器里面的子元素 2 BFC触发条件 根元素 &lt;html&gt; 浮动元素（元素的 float 不是 none） 绝对定位元素（元素的 position 为 absolute 或 fixed） 内联块元素（display: inline-block） 表格单元格或标题（display: table-cell / table-caption） 具有overflow 且值不是 visible 的块元素 display: flow-root 3 BFC功能1 两列自适应布局 图文排列时，图片左浮动，就形成文字环绕 此时如果文字容器触发BFC，则在垂直方向上，文字不会越过图片右边，形成左边宽度固定，右边宽度自适应的布局 2 清除浮动影响 正常情况下，浮动元素会脱离文档流，BFC会阻止浮动超出BFC区域 3 解决相邻元素margin合并 两个相邻的块级元素在垂直方向存在margin合并的问题 如果这两个相邻的块级元素不属于同一个BFC就不会合并！ 二 定位2.1 position 取值 说明 static（默认） 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 sticky 粘性定位 1 static 元素出现在正常的流中（忽略 top, bottom, left, right 和 z-index ）。 2 relative &amp; absolute &amp; fixed 这三种定位有一个共同点，都是相对于某个基点的定位，不同之处仅仅在于基点不同 这三种定位都不会对其他元素的位置产生影响，因此元素之间可能产生重叠 （z-index） 必须搭配top、bottom、left、right这四个属性一起使用，用来指定偏移的方向和距离。如果不设置偏移，元素在默认位置（static时的位置） 2.2 relative 相对于默认位置（static时的位置）进行偏移，即定位基点是元素的默认位置，也可以认为是相对于自身定位 相对定位的元素先放置在未添加定位时的位置（不会脱离文档流），然后在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白，即还会占据原文档流位置） 2.3 absolute 相对于离它最近的非static定位的祖先元素（一般是父元素）进行偏移，即定位基点是最近的非static定位的祖先元素 元素会向上级依次寻找直到找到非static定位的祖先元素 如果所有上级元素都没有开启定位，则相对于根元素html定位（并非浏览器窗口） 绝对定位元素会被移出正常文档流，并不为元素预留空间 绝对定位会随着滚动条滚动 2.4 fixed 相对于视口（viewport，浏览器窗口）进行偏移，即定位基点是浏览器窗口 固定定位元素会被移出正常文档流，并不为元素预留空间 固定定位元素的位置不随页面滚动而变化，好像固定在网页上一样 固定定位可以看作绝对定位的一种 2.5 sticky sticky会产生动态效果，很像relative和fixed的结合：一些时候是relative定位（定位基点是自身默认位置），另一些时候自动变成fixed定位（定位基点是视口） sticky生效的前提是，必须搭配top、bottom、left、right这四个属性中的一个或多个一起使用（看滚动方向），不能省略，否则等同于relative定位，不产生”动态固定”的效果 不能有任何祖先元素设置overflow:hidden，否则没有粘滞效果。因为改变了滚动容器（即使没有出现滚动条） 父元素的高度不能低于sticky元素的高度 sticky元素仅在其父元素内生效，不会超出父元素，滚动时会随着父元素一起消失 当页面滚动，父元素开始脱离视口时（即部分不可见），只要与sticky元素的距离达到生效门槛（设置的top/bottom/left/right），relative定位自动切换为fixed定位，等到父元素完全脱离视口时，fixed定位恢复成relative定位 同一个父容器中的sticky元素，如果定位值相等，则会重叠；如果属于不同父元素，则会随着父元素不再完整占据sticky元素的固定区域以后，再由其他父元素的sticky子元素占据固定位置 我的理解就是设置了粘性定位的元素，没到达所设置的偏移量时，为相对定位，到达后就变为固定定位，但只局限在父元素在视口内，如果父元素都滚走了，也会一同滚走（当然此时为相对定位）","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"CSS","slug":"UI/CSS","permalink":"https://anyeansan.github.io/categories/UI/CSS/"}],"tags":[]},{"title":"CSS 内联盒模型","slug":"CSS-内联盒模型","date":"2020-03-30T12:54:54.000Z","updated":"2020-03-30T12:56:19.826Z","comments":true,"path":"2020/03/30/CSS-内联盒模型/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/CSS-%E5%86%85%E8%81%94%E7%9B%92%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"一 基本组成1.1 内容区域 content area 文字，内容区域可以理解为选中文字时的区域 content area 高度由font-size和font-family决定。font-family为simsun(宋体)时，content area高度 = font-size 图片这样的替换元素，内容区域可以看成元素自身 1.2 内联盒子 inline box 内联盒子 内联元素 匿名内联盒子 纯文本 注意：并不是所有光秃秃的文字都是“匿名内联盒子”，其还有可能是“匿名块级盒子”，关键要看前后的标签是内联还是块级 1.3 行框盒子 line box 由一个一个“内联盒子”组成的一行就是行框盒子 行框盒子的高度是由高度最高的那个“内联盒子”决定 1.4 空白幽灵节点 strut 每个 line-box 起始位置都有一个具有该元素的字体和行高属性的 0 宽度的内联盒，此内联盒叫做strut（支柱）。 永远透明，无法获取，表现如同文本节点一样 看不见的字符，看得见的影响 二 相关概念 2.1 基线 文本内联元素的基线就是小写x的下边缘 类似图片这样的元素的基线就是其下边缘 inline-block 元素 如果该元素里面没有inline内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘 如果该元素中有内联元素，则该元素的基线就是最后一行内联元素的基线 2.2 x-height x-height 指的就是小写字母 x 的高度，术语描述就是基线和等分线（mean line）（也称作中线，midline）之间的距离 ex 是 CSS 中的一个相对单位，指的是小写字母 x 的高度，即 x-height 2.3 高度相关 line-height：两行文字基线之间的距离 文字本身的高度（即文字上下边缘的高度）+ 一些高度 = content area 的高度（即上行线ascent与下行线descent的高度） 即文字距离content area 上下是有距离的（你选中文字时，文字上下跟背景上下是有距离的） 也能看出content area 是跟字体大小和字体类型有关的 font-family 为 simsun（宋体）时，content area的高度等于font-size（font-size跟文字本身的高度不是一个概念） content area 的高度 + 行距（上下等分）= 行高 可以近似认为 font-size + 行距 = line-height 行距 = line-height - font size 当行高和字体大小相等时，行距为0，此时是两行的content area挨在了一起（并不是文字下边缘与下一行文字上边缘挨在了一起） 2.4 line-height 对于非替换内联元素，其可视高度完全由 line-height 决定。padding、border 属性对可视高度是没有任何影响的 对非替换内联元素设置line-height，只是它自己的line-height，最终高度还要看行框盒子内其它内联盒子的line-height 对于替换元素，line-height无影响 对于块级元素，line-height 对其本身是没有任何作用的，块级元素的高度跟着变化实际上是通过改变块级元素里面内联级别元素占据的高度实现的 2.5 vertical-align 用来指定内联元素（inline/inline-block/inline-table）或表格单元格（table-cell）元素的垂直对齐方式 内联元素默认都会受到line-height和vertical-align的影响 vertical-align:middle middle 与中线 midline不同，指的是基线往上 1/2 x-height 高度，可以近似理解为字母 x 交叉点那个位置 相对其父元素垂直对齐 值 说明 baseline（默认） 使元素的基线与父元素的基线对齐 sub 使元素的基线与父元素的下标基线对齐 super 使元素的基线与父元素的上标基线对齐 text-top 使元素的顶部与父元素的字体顶部对齐 text-bottom 使元素的底部与父元素的字体底部对齐 middle 使元素的中部与父元素的基线加上父元素x-height的一半对齐 &lt;length&gt; 使元素的基线对齐到父元素的基线之上的给定长度。可以是负数 &lt;percentage&gt; 使元素的基线对齐到父元素的基线之上的给定百分比，该百分比是line-height属性的百分比。可以是负数 相对整行垂直对齐 值 说明 top 使元素及其后代元素的顶部与整行的顶部对齐 bottom 使元素及其后代元素的底部与整行的底部对齐 三 对几个现象的理解3.1123&lt;div&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt; div的高度为0 123&lt;div&gt; &lt;span style=&quot;display: inline-block;&quot;&gt;&lt;/span&gt;&lt;/div&gt; div的高度不为0 因为div内部span形成了行框盒子，行框盒子起始位置有幽灵节点strut，行高默认值为normal，是有行高的，行高作用在strut上，就撑起了div的高度 我的结论 inline 内联元素形成行框盒子的是内部的文字，如果内部为空，就形不成行框盒子 inline-block 内联元素形成行框盒子的是元素本身，内部为空也能形成行框盒子 3.2123456789&lt;style&gt; div &#123; background: #ddd; border: 1px solid #000; &#125;&lt;/style&gt;&lt;div&gt; &lt;img src=&quot;mm.jpg&quot;&gt;&lt;/div&gt; 底部有空隙的原因 img形成了行框盒子，所以出现了strut vertical-align默认为base-line对齐，strut的base-line为x的下边缘，img的base-line为底部 文本占的空间是content area的高度 + 行距 = 行高，并不是文字的上下边缘。所以图片下边才会有空隙 在图片前边添加文本效果是一样的 解决方式 img块级化，vertical-align对块级元素无效（且没有了行框盒子） 修改vertical-align为其他值比如bottom top middle ... 比如bottom，此时，是文字占据的空间的下边缘与图片下边缘对齐 减小line-height的值 减小line-height 也就是在减小行距，当line-height与font-size相等时，行距为0 行距为0时，文本占据的空间就是content area，此时文字本身距离content area的上下边缘还有一些距离，也就是图片距离底部的空隙 继续减小line-height直到文字base-line到达底部 3.3 单行文本垂直居中 设置line-height 的值与 height值相等即可 因为行距上下等分原则，所以行高与高度相等时，文本自然在中间 3.4 多行文本垂直居中123456789101112131415&lt;style&gt; div &#123; width: 300px; height: 300px; line-height: 300px; &#125; span &#123; display: inline-block; vertical-align: middle; line-height: 20px; &#125;&lt;/style&gt;&lt;div&gt; &lt;span&gt;很多文字...&lt;/span&gt;&lt;/div&gt; 设置div的line-height与height值相等 把行高区域和高度区域都想象成一个盒子，两个区域高度相等重合了，那么在行高里边的元素设置居中在高度区域自然也是居中的 span设置display: inline-block 和 vertical-align: middle，并且设置一个合适的 line-height 为何span要设置display: inline-block ? span的display为默认的inline时，形成行框盒子的是span的内容，由于div的line-height会作用于行框盒子的strut，且div的line-height大于span的line-height，所以行框应用的是div的line-height，也就是说span的内容应用的是div的line-height，就会导致文字行距很大 span的display设置为line-block时，形成行框盒子的是span本身，span的内部还会形成一个行框盒子，这时span设置的line-height就会对内部的行框盒子起作用，即span应用的是div的line-height，sanp的内容应用的是span自身的line-height，所以文字就能正常显示","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"CSS","slug":"UI/CSS","permalink":"https://anyeansan.github.io/categories/UI/CSS/"}],"tags":[]},{"title":"CSS 盒子模型","slug":"CSS-盒子模型","date":"2020-03-30T12:52:25.000Z","updated":"2020-03-30T12:54:02.595Z","comments":true,"path":"2020/03/30/CSS-盒子模型/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/CSS-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"一 组成 指内部盒子（容器盒子）的模型 1.1 content box1 content content 属性插入的内容都是匿名替换元素 content 属性通常用在::before / ::after 这两个伪元素中 content 属性生成的内容特点 content 生成的文本是无法选中、无法复制的 content 无法影响:empty 选择器（即有content还是适配:empty） content 动态生成值无法获取 如计数器 值 说明 none 不会产生伪元素 normal ::before和::after 中会被当作none &lt;string&gt; 字符串（数字，字符，unicode码） &lt;url&gt; 图片可以是png、jpg、ico、svg文件以及 base64URL，但不支持 CSS3 渐变背景图 attr() 获取原生html属性或者自定义属性的值，属性不要加引号 &lt;counter&gt; 计数器 open-quote / close-quote 开闭引号 no-open-quote / no-close-quote 不要开闭引号 1 content 辅助元素生成 核心点不在于 content 生成的内容，而是伪元素本身，如 最常用的清除浮动 注：content生成的是匿名替换元素，替换元素都是内联元素，clear只能用在块级元素上，所以要改变dislay 12345.clear::after &#123; content: &apos;&apos;; display: block; clear: both;&#125; 2 计数器 counter-reset [ &lt;custom-ident&gt; &lt;integer&gt;? ]+ | none &lt;cutom-ident&gt; 自定义计数器名称 &lt;integer&gt; 每次出现元素时将计数器重置为的值（可以理解为初始值），默认为0 counter-increment [ &lt;custom-ident&gt; &lt;integer&gt;? ]+ | none &lt;cutom-ident&gt; 指定使用递增规则的计数器名称 &lt;integer&gt; 定义递增的值，默认为1 counter() counter(counterName, style) 用来显示计数，显示的是序号如1 2 3 ... style即 list-style-type 支持的值，默认是数字 counter()，counters() counters() counters(counterName, string, style) 用来显示计数，显示的是子序号如 1.1 1.2 2.1 2.2 2.2.1 ... string用来指定序号和子序号之间的符号，如.或- 生成的 1.1或1-1 注意如果想要嵌套成功，每一层的序号都要有定义counter-reset的容器包裹 3 content 开启闭合符号生成 open-quote close-quote 关键字意思为开引号，闭引号，即默认为引号。可以通过 quotes 指定开闭符号内容 quotes none | auto | [ &lt;string&gt; &lt;string&gt; ]+ 4 content 混合内容 即各种值可以混合使用，用空格隔开 2 width 值 说明 auto（默认） 浏览器将会为指定的元素计算并选择一个宽度. &lt;length&gt; 指定值 &lt;percentage&gt; 指定为包含块宽度的百分比 fill-available 元素宽度自动填满可用空间 fit-content 元素宽度包裹内容，文本内容正常换行。如浮动、绝对定位、inline-block 元素或 table 元素 min-content 元素宽度为内部元素”首选最小宽度”最大的那一行的宽度 max-content 元素宽度为内部元素宽度值最大的那个元素的宽度 1 min-content 首选最小宽度 指的是元素最适合的最小宽度 类似图片这样的替换元素的最小宽度就是该元素内容本身的宽度 文本 CJK（中日韩）可以任意断行，最小宽度就是每个字符的宽度 non-CJK一般在空格、短横线、问号以及其他非英文字符等断行，最小宽度由连续的英文字符单元决定 2 fit-content 和 max-content 区别 两者的元素宽度其实都是内部元素最大的那个宽度 区别在于fit-content内部元素文字可以正常换行，而max-content内部元素文字不换行 3 CSS 流体布局下的宽度分离原则 宽度分离原则即CSS 中的 width 属性不与影响宽度的 padding/border（有时候包括 margin）属性共存 应该width 独立占用一层标签，而padding、border、margin 利用流动性在内部自适应呈现 3 height 值 说明 auto（默认） 浏览器将会为指定的元素计算并选择一个高度. &lt;length&gt; 指定值 &lt;percentage&gt; 指定为包含块高度的百分比 fill-available 充分利用可用空间 fit-content 收缩到包裹内容 min-content 收缩到最小 max-content 最大内容高度 height: 百分比 对于普通文档流中的元素，百分比高度值要想起作用，其祖先级元素中必须有一个可以生效的高度值 设定显式的高度值 普通文档流中宽高百分比是相对于父元素也就是 content box的 使用绝对定位 绝对定位的宽高百分比计算是相对于 padding box 的 4 min-width / max-width 和 min-height / max-height1 与众不同的初始值 width / height 的默认值是 auto min-width / min-height 的默认值是auto（w3c/mdn上是0） max-width / max-height的默认值是none 2 权重（width / height 规则相同） width，min-width，max-width只有其中一个，则最终宽度为其值 有width 和 max-width，则最终宽度不能大于max-width width &lt; max-width 时，最终宽度为width的值 width &gt; max-widht 时，最终宽度为max-width的值 有width 和 min-width，则最终宽度不能小于min-width width &gt; min-width 时，最终宽度为width的值 width &lt; min-widht 时，最终宽度为min-width的值 有min-width和max-width，则最终宽度为二者中较大的那个值 min-width &lt; max-width 时，则最终宽度为max-width的值 min-width &gt; max-width 时，则最终宽度为min-width的值 有width，min-width，max-width min-width &gt; max-width，无论width值如何，最终宽度都是min-width的值 min-width &lt; max-width，根据width取值，最终宽度在最小和最大宽度之间 width &lt; min-width &lt; max-width，则最终宽度为min-width的值 min-width &lt; width &lt; max-width，则最终宽度为width的值 min-width &lt; max-width &lt; width，则最终宽度为max-width的值 1.2 padding box1 padding padding 对于块级元素有影响 padding 对于替换元素有影响 padding 对于非替换内联元素，水平方向有影响，垂直方向不改变元素高度，但是改变背景高度 值 说明 &lt;length&gt; 指定值 &lt;percentage&gt; 相对于宽度的百分比 * 一个值：同时设置四个边内边距 * 二个值：上下 左右 * 三个值：上 左右 下 * 四个值：上 右 下 左 2 每个边的padding属性 padding-top padding-right padding-bottom padding-left 1.3 border box1 border boder-color || boder-style || border-width 1 border-width 值 说明 &lt;legnth&gt; 指定值 thin 薄，等同于 1px medium（默认） 薄厚均匀，等同于 3px thick 厚，等同于 4px * 不支持百分比，不合常理，没有说边框跟着内容宽度变化的 2 border-style 值 说明 none（默认） 不显示边框，none 值优先级最低，如果存在其他的重叠边框，则会显示为那个边框 hidden 不显示边框，hidden 值优先级最高，如果存在其他的重叠边框，边框也不会显示。 solid 单实线 double 双实线，边框宽最少3px才有效果 dotted 点画线 dashed 虚线 groove 雕刻效果，与ridge相反 ridge 浮雕效果，与groove相反 inset 陷入效果 outset 突出效果 3 border-color 取值 &lt;color&gt; border-color 默认颜色为 color 色值（即边框颜色默认为字体颜色） 2 每个边的border属性 border-top border-top-color border-top-style border-top-width border-right border-right-color border-right-style border-right-width border-bottom border-bottom-color border-bottom-style border-bottom-width border-left border-left-color border-left-style border-left-width 3 border-radius 值 说明 &lt;percentage&gt; 相对于border box的百分比 &lt;length&gt; 长度 1 最大尺寸 &amp; 等比缩放 图形尺寸是有限的，所以圆角半径设置过大时，也只会按照最大尺寸来算，且值会根据设置时的比例变化 例如 border box 宽200px，高300px，此时设置 border-radius: 300px; 水平半径最大只能到200px，所以按200px算，垂直半径虽然能到300px，但是设置时300:300水平与垂直比例是1:1，垂直半径也要跟着变化，结果水平和垂直半径都是200px 2 值语法 第一组值（水平半径）/ 第二组值（垂直半径） 如省略第二组值，则表示垂直半径=水平半径 每组值的数量 一个值：四个角 二个值：左上角右下角 右上角左下角 三个值：左上角 右上角左下角 右下角 四个值：左上角 右上角 右下角 左下角 3 每个角单独设置 border-垂直-水平-radius: 水平半径 垂直半径（可省略） border-top-left-radius border-top-right-radius border-bottom-right-radius border-bottom-left-radius 1.4 margin box1 margin margin对于块级元素有影响，且垂直方向有margin合并 margin对于替换元素有影响，且垂直方向无margin合并 margin对于非替换内联元素水平方向有影响，垂直方向无影响 值 说明 auto 浏览器会自动选择一个合适的margin来应用 &lt;length&gt; 指定值 &lt;percentage&gt; 相对于宽度的百分比 * 一个值：同时设置四个边外边距 * 二个值：上下 左右 * 三个值：上 左右 下 * 四个值：上 右 下 左 1 margin: atuo 计算规则 如果一侧定值，一侧 auto，则 auto 为剩余空间大小。 如果两侧均是 auto，则平分剩余空间 触发 margin:auto 计算的前提条件：width 或 height 为 auto 时，元素是具有对应方向的自动填充特性 块级元素width为auto时，水平方向会自动填充 绝对定位元素 如果设置left和right为0，则水平方向填充特性 如果设置top和bottom为0，则垂直方向有填充特性 绝对定位元素居中的两种方式123456// 1 position: absolute;// 1.1 首先向右向下移动父元素宽高的一半left: 50%; top: 50%;// 1.2 由于参照点是子元素的左上角，所以要向左向上分别移动子元素宽高的一半（margin或者transform:translate）margin-left: -50%; margin-top: -50%; 123456// 2position: absolute;// 2.1 使水平和垂直方向具有填充特性left: 0; right: 0; top:0; bottom:0;// 2.2 margin:auto 触发计算，自动平分margin: auto; 2 margin 合并 块级元素的上外边距（margin-top）与下外边距（margin-bottom）有时会合并为单个外边距 块级元素，但不包括浮动和绝对定位元素，尽管浮动和绝对定位可以让元素块状化 1 场景 相邻兄弟元素 margin 合并 父级和第一个/最后一个子元素 margin 合并 解决margin-top 合并 父元素设置为块状格式化上下文元素 父元素设置 border-top 值 父元素设置 padding-top 值 父元素和第一个子元素之间添加内联元素进行分隔 解决margin-bottom 合并 父元素设置为块状格式化上下文元素 父元素设置 border-bottom 值 父元素设置 padding-bottom 值 父元素和最后一个子元素之间添加内联元素进行分隔 父元素设置 height、min-height 或 max-height 空块级元素的 margin 合并 解决 设置垂直方向的 border； 设置垂直方向的 padding； 里面添加内联元素（直接 Space 键空格是没用的）； 设置 height 或者 min-height。 2 计算规则 如果合并外边距皆为正，取最大值 如果合并外边距皆为负，取最小值（即绝对值最大值） 如果合并外边距有正有负，取最大正外边距与最小负外边距之和 3 margin 无效的场景 非替换内联元素的垂直方向 &lt;tr&gt;&lt;td&gt;标签或者 display为table-row table-cell的元素 绝对定位元素非定位方位的 margin 值表面“无效” 2 每个边的margin属性 margin-top margin-right margin-bottom margin-left 二 box-sizing 值 说明 content-box（默认） 盒子大小是content box（即width/height是对内容盒子的宽和高） border-box 盒子大小是border box（即width/height是内容的宽高+内边距+边框） 三 box-shadow1[ inset? [&lt;offset-x&gt; &lt;offset-y&gt;] &lt;blur-radius&gt;? &lt;spred-radius&gt;? &lt;color&gt;? ]# inset 默认阴影在边框外即向外扩散，inset关键字会使得阴影落在盒子内部即向内扩散 &lt;blur-radius&gt; 阴影模糊半径，值越大，模糊面积越大，阴影就越大越淡，不能为负 &lt;spred-radius&gt; 阴影扩散半径，默认为0，取正值时，阴影扩大；取负值时，阴影收缩。 四 visibility 值 说明 visible（默认） 元素正常显示 hidden 隐藏元素，但是其他元素的布局不改变，相当于此元素变成透明。若其子元素设为visible，则子元素依然可见 collapse 用于 &lt;table&gt; 行、列、列组和行组，隐藏表格的行或列，并且不占用任何空间，就好像折叠了单元格一般（效果同display:none） visibility: hidden &amp; display: none display: none 表示该元素以及它的所有后代元素都会隐藏 元素无法点击，无法使用屏幕阅读器等辅助设备访问 不占用空间，就好像抹去了一般 不会影响计数器的值 visibility: hidden 如果元素的后代元素将visibility设为visible，则后代元素依然可见 占用空间，就好像隐形了一般 会影响计数器的值 五 outline5.1 语法123outline-style ||outline-width ||outline-color 轮廓线不占据空间 1 outline-width 值 说明 &lt;legnth&gt; 指定值 thin 薄 medium 中等 thick 厚 2 outline-style 值 说明 none 无轮廓线 solid 单实线 double 双实线 dotted 点画线 dashed 虚线 groove 雕刻效果，与ridge相反 ridge 浮雕效果，与groove相反 inset 陷入效果 outset 突出效果 3 outline-color 取值 &lt;color&gt; 六 cursor 定义鼠标悬浮在元素上方时的样式 值 说明 auto（默认） 浏览器根据内容类别自动选择光标形状 default 箭头 none 隐藏光标，比如看视频时 pointer 手 help 帮助样式 ... 还有很多样式 七 元素尺寸相关的几个属性 clientWidth clientHeight 指元素可视区域的padding box scrollWidth scrollHeight 指元素实际区域的padding box3 offsetWidth offsetHeight 指元素可视区域的大小（包含边框，滚动条）","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"CSS","slug":"UI/CSS","permalink":"https://anyeansan.github.io/categories/UI/CSS/"}],"tags":[]},{"title":"CSS 元素和流","slug":"CSS-元素和流","date":"2020-03-30T12:51:45.000Z","updated":"2020-03-30T12:52:00.065Z","comments":true,"path":"2020/03/30/CSS-元素和流/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/CSS-%E5%85%83%E7%B4%A0%E5%92%8C%E6%B5%81/","excerpt":"","text":"一 正常文档流（normal flow） 元素默认都在文档流中 自上而下，自左向右排列 二 元素的盒子2.1 外部盒子 决定了元素类型（块级元素 / 内联元素） 2.2 内部盒子（容器盒子） 决定了子元素布局 content box （名称为 content-box） padding box（名称为 padding-box） border box（名称为 border-box） margin box（没有名称） 三 块级元素 &amp; 内联元素3.1 块级元素 独占一行，自上而下排列 宽度：默认为父元素宽度的100% 高度：默认为0，高度与其内容高度一致 可以直接设置宽高（width height） 默认块级元素 display &lt;div&gt; block &lt;header&gt; &lt;main&gt; &lt;footer&gt; block &lt;article&gt; &lt;aside&gt; &lt;section&gt; block &lt;h1&gt;~&lt;h6&gt; block &lt;p&gt; block &lt;ul&gt; &lt;ol&gt; block &lt;li&gt; list-item &lt;dl&gt; &lt;dt&gt; &lt;dd&gt; block &lt;hr&gt; block &lt;table&gt; table &lt;form&gt; block &lt;option&gt; block &lt;address&gt; block &lt;blockquote&gt; block &lt;pre&gt; block &lt;menu&gt; block 3.2 内联元素 只占自身大小，从左向右排列，如果一行不足以容纳，会换行 内联元素宽高与内容一致，width height 属性无效 默认内联元素 display &lt;span&gt; inline &lt;a&gt; inline &lt;img&gt; inline &lt;br&gt; inline &lt;label&gt; inline &lt;input&gt; inline-block（type为hidden时是none） &lt;button&gt; inline-block &lt;select&gt; inline-block &lt;textarea&gt; inline-block &lt;abbr&gt; &lt;em&gt; &lt;i&gt; ... inline 3.3 display1 语法1234[ &lt;display-outside&gt; || &lt;display-inside&gt; ] &lt;display-listitem&gt; | &lt;display-internal&gt; |&lt;display-box&gt; |&lt;display-legacy&gt; 2 &lt;display-outside&gt; 外部盒子显示类型：决定了元素类型 块级 or 内联 值 说明 block 块级元素 inline 内联元素 run-in 了解 3 &lt;display-inside&gt; 内部盒子显示类型：决定子元素布局 值 说明 flow 了解 flow-root 触发BFC table 同 &lt;table&gt; flex 弹性布局 grid 栅格布局 ruby 了解，可以加旁注标记，如中文的拼音 4 &lt;display-listitem&gt; 值 说明 list-item 同 &lt;li&gt;，可以搭配 list-style-type 和 list-style-position 使用 list-item 元素设置display: list-item 和 display: block 时 &lt;display-outside&gt; 默认都是 block &lt;display-inside&gt; 默认都是 flow 唯一区别是前边有项目符号 为什么 list-item 元素会出现项目符号？ 因为生成了一个附加的盒子，学名“标记盒子”（marker box），专门用来放圆点、数字这些项目符号 5 &lt;display-internal&gt; 内部属性值 类似table和ruby等有复杂内部结构的布局模块，它们的子孙有不同的填充方式 内部属性值附属于它的布局模块 值 说明 table-header-group 同 &lt;thead&gt; table-row-group 同 &lt;tbody&gt; table-footer-group 同 &lt;tfoot&gt; table-caption 同 &lt;caption&gt; table-row 同 &lt;tr&gt; table-cell 同 &lt;td&gt; table-column-group 同 &lt;colgroup&gt; table-column 同 &lt;col&gt; ruby-base 同 &lt;rb&gt; ruby-text 同 &lt;rt&gt; ruby-base-container 同 &lt;rbc&gt; ruby-text-container 同 &lt;rtc&gt; 6 &lt;display-box&gt; 值 说明 none 不显示，就好像不存在一样，不占空间 contents 我的理解就是只保留内容 contents 元素本身不产生任何边界框（英文是boxes，自己体会），而元素的子元素和伪元素（::befor和::after）仍然生成边界框，元素文字正常显示 元素不产生任何边界框，因此元素的背景、边框和填充部分都不会渲染（即background border padding width height 等属性会失效）。而继承的属性如颜色(color)和字体(font)却能照常影响子元素 7 &lt;display-legacy&gt; 值 说明 inline-block 行块 inline-table 行表格 inline-flex 行弹性 inline-grid 行栅格 8 单值语法 &amp; 双值语法 single value two value block block flow flow-root block flow-root inline inline flow inline-block inline flow-root flex block flex inline-flex inline flex grid block grid inline-grid inline grid table block table inline-table inline table 双值语法未广泛支持，但可以帮助理解单值语法时 &lt;display-outside&gt; 和 &lt;display-inside&gt; 的默认值 3.4 非替换元素 &amp; 替换元素1 概述 根据 “外在盒子” 把元素分为内联元素和块级元素 根据是否具有可替换内容，把元素分为替换元素和非替换元素 2 非替换元素 如果元素的内容包含在文档中，则称之为非替换元素 html 的大多数元素是不可替换元素，即其内容直接表现给浏览器 如 &lt;p&gt; 文档内容是什么，显示结果就是什么 3 替换元素 浏览器根据元素的标签和属性，来决定元素的具体显示内容（即content box内容可替换，对应的 CSS 属性是 content） 如 &lt;img&gt; &lt;object&gt; &lt;video&gt; &lt;iframe&gt; &lt;textarea&gt; &lt;input&gt; &lt;img&gt;，修改src属性就会改变显示结果 匿名可替换元素 通过 CSS content 属性来插入的对象 被称作 匿名可替换元素 所有的替换元素都是内联元素 4 替换元素的特性1 内容的外观不受页面上的 CSS 的影响 替换元素是一种外部对象，它们外观的渲染，是独立于 CSS 的 样式表现在css作用域之外，如果要替换元素本身的外观，需要类似appearance的属性。或者是浏览器本身暴露的接口。但是直接input[type=&#39;checkbox&#39;]{}没办法改变内间距背景色等特性 2 有自己的尺寸 在 Web 中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是 300 像素×150 像素 如 &lt;video&gt; &lt;iframe&gt; &lt;canvas&gt; 少部分替换元素为 0 像素，如&lt;img&gt; 表单元素的替换元素的尺寸则和浏览器有关，没有明显的规律 3 在很多 CSS 属性上有自己的一套表现规则 如 vertical-align 默认值的 baseline ，但对于替换元素，默认为元素的下边缘 5 替换元素的尺寸计算规则1 尺寸类型 固有尺寸 指的是替换内容原本的尺寸 如图片，视频都有自身的尺寸 HTML 尺寸 HTML 尺寸只能通过HTML 原生属性改变 HTML 原生属性，如&lt;img&gt;的 width 和 height 属性、&lt;input&gt;的 size 属性、&lt;textarea&gt;的 cols 和 rows 属性等 CSS 尺寸 可以通过 CSS 的 width 和 height 或者 max-width/min-width 和max-height/min-height 设置的尺寸 对应盒尺寸中的 content box 2 计算规则 没有 CSS 尺寸和 HTML 尺寸，则使用固有尺寸作为最终的宽高 没有 CSS 尺寸，则使用 HTML尺寸作为最终的宽高 有 CSS 尺寸，则最终尺寸由 CSS 属性决定 如果固有尺寸含有固有的宽高比，css尺寸和html尺寸如果只设置了宽高中的一个，则另一个值根据固有尺寸宽高比变化 如果以上都不符合，则最终宽度表现为 300 像素，高度为 150 像素 &lt;img&gt; 较为特殊 chrome下默认为0*0 firefox下默认为0*22，且firfox下如果省略src属性，则&lt;img&gt;不是替换元素，而是一个普通的内联元素 内联替换元素和块级替换元素使用上面同一套尺寸计算规则 即内联替换元素块级化，计算规则不变 无法改变替换元素内容的固有尺寸 我们为&lt;img&gt;设置宽高，好像是覆盖了固有尺寸，其实改变的是content box的宽高，而&lt;img&gt;的content box替换内容默认适配方式是填充（fill） css3替换元素的替换内容的适配方式可以通过object-fit 属性修改","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"CSS","slug":"UI/CSS","permalink":"https://anyeansan.github.io/categories/UI/CSS/"}],"tags":[]},{"title":"CSS 列表 表格","slug":"CSS-列表-表格","date":"2020-03-30T12:50:56.000Z","updated":"2020-03-30T12:51:13.516Z","comments":true,"path":"2020/03/30/CSS-列表-表格/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/CSS-%E5%88%97%E8%A1%A8-%E8%A1%A8%E6%A0%BC/","excerpt":"","text":"一 列表1.1 list-style1 语法123list-style-type ||list-style-image ||list-style-position 无序 仅有任意一个即可 2 list-style-type 值 说明 disc（默认） 实心圆点 none 无样式 circle 空心圆点 square 实心方块 decimal 从1开始的数字 ...... 还有许多样式 3 list-style-image 值 说明 none（默认） 会使用list-style-type &lt;url&gt; 指定图片 4 list-style-position 值 说明 outside（默认） 标记盒 ::marker 在主块盒之外 inside 标记盒 ::marker 在主块盒之内，是主块盒中的第一个行内盒 二 表格2.1 概述 单元格没有外边距，有边框和内边距 标题是放在表格边框的外面的 2.2 border-collapse 值 说明 separate（默认） 分离，HTML 表格的传统模式。相邻单元格都拥有独立的边框 collapse 合并，表格中相邻单元格共享边框 2.3 border-spacing &lt;length&gt; &lt;length&gt;? 水平 垂直 如果省略垂直则与水平间距相等 只有 border-collapse: separate 时才有效 2.4 empty-cells 值 说明 show（默认） 空单元格的背景和边框正常显示 hide 空单元格的背景和边框隐藏 2.5 caption-side 值 说明 top（默认） &lt;caption&gt;盒子在表格顶部 bottom &lt;caption&gt;盒子在表格底部 2.6 table-layout 值 说明 auto（默认） 表格及单元格的宽度取决于其包含的内容 fixed 表格和列的宽度通过表格的宽度来设置，某一列的宽度仅由该列首行的单元格决定","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"CSS","slug":"UI/CSS","permalink":"https://anyeansan.github.io/categories/UI/CSS/"}],"tags":[]},{"title":"CSS 文字排版和修饰","slug":"CSS-文字排版和修饰","date":"2020-03-30T12:50:10.000Z","updated":"2020-03-30T12:50:31.143Z","comments":true,"path":"2020/03/30/CSS-文字排版和修饰/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/CSS-%E6%96%87%E5%AD%97%E6%8E%92%E7%89%88%E5%92%8C%E4%BF%AE%E9%A5%B0/","excerpt":"","text":"一 文本排版1.1 text-transform 值 说明 none（默认） 无影响 capitalize 每个单词首字母大写 uppercase 所有字母大写 lowercase 所有字母小写 1.2 空白 &amp; 拆分 &amp; 换行1 white-space 设置如何处理元素中的 空白（空格space，制表符tab，换行符enter） 值 说明 normal（默认） 所有空格、制表符、换行符都合并成一个空格，文本自动换行 nowrap 所有空格、制表符、换行符都合并成一个空格，文本不换行 pre 所有东西原样输出，文本不换行 pre-wrap 所有东西原样输出，文本换行 pre-line 所有空格、制表符合并成一个空格，换行符不变，文本换行 break-spaces 同pre-wrap，但有一些区别 2 word-break 控制单词如何被拆分换行 值 说明 normal（默认） CJK（中/日/韩）可以在任意2个字符间断行，non-CJK只能再空白符处断行 keep-all CJK和non-CJK都能只能在空白符处断行 break-all CJK和non-CJK都可以在任意位置断行 3 overflow-wrap 原word-wrap改名为 overflow-wrap 指定一个不可分割的字符串过长，超过容器盒的宽时应该如何处理 值 说明 normal（默认） 在正常的单词结束处换行（CJK从单个字符之间换行，non-CJK保留完整性，可能会溢出容器） break-word 内容将在边界内换行。如果需要，non-CJK单词内部允许断行 1.3 间距1 word-spacing 设置单词之间的距离，中文无效 值 说明 normal（默认） 常规 &lt;length&gt; 长度 &lt;percentage&gt; 百分比 2 letter-spacing 设置字符之间的距离，中文有效 值 说明 normal（默认） 常规 &lt;length&gt; 长度 1.4 缩进 对齐1 text-indent 定义首行缩进量 值 说明 &lt;length&gt; 长度，允许为负 &lt;percentage&gt; 使用包含块宽度的百分比作为缩进 2 text-align 定义行内内容如何相对它的块父元素水平对齐 值 说明 left 左对齐 right 右对齐 center 居中对齐 justify 两端对齐，对最后一行无效 3 text-justify 定义当文本 text-align: justify 时的齐行方法 值 说明 auto（默认） 浏览器根据显示的效果和质量来确定最佳对齐方式 none 表现的效果和没有设置 text-align 一样 inter-word 增加单词间的间隔来实现对齐（会改变 word-spacing 的值） inter-character 增加减少字符间的间隔来实现对齐（会改变 letter-spacing 的值） 1.5 文本溢出1 overflow 当一个元素的内容太大而无法适应 块级格式化上下文 时候该做什么。它是 overflow-x 和overflow-y的 简写属性 值 说明 visible（默认） 内容不会被修剪，可以呈现在元素框之外 hidden 内容会被修剪，并且超出内容不可见 scroll 内容会被修剪，浏览器会显示滚动条以便查看超出内容 auto 由浏览器定夺，如果内容被修剪，就会显示滚动条 2 text-overflow 规定了当文本溢出其包含元素时以何种方式显示 只是规定了文本溢出后的显示样式，但它不会强制文本溢出 值 说明 clip（默认） 将溢出的文本裁减掉 ellipsis 将溢出的文本用省略号...来表示 二 文本装饰2.1 text-docoration1 语法1234text-decoration-line ||text-decoration-style ||text-decoration-color ||text-decoration-thickness 无序 有任意一个即可 2 text-decoration-line 值 说明 none（默认） 无线 underline 下划线 overline 上划线 line-through 删除线 3 text-decoration-style 值 说明 solid（默认） 单实线 double 双实线 dotted 点划线 dashed 虚线 wavy 波浪线 4 text-decoration-color &lt;color&gt; 5 text-decoration-thickness 设置元素中文本所使用的装饰线的厚度或者宽度 值 说明 auto 浏览器为文本装饰线选择合适的宽度 from-font 如果字体文件中包含了首选的厚度值，则使用此字体文件的厚度值，否则同auto &lt;length&gt; 指定装饰线厚度 2.2 text-shadow1 语法12[offset-x offset-y] blur-radius? ||color? 2 blur-radius 默认为0，值越大，模糊半径越大，阴影也就越大越淡","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"CSS","slug":"UI/CSS","permalink":"https://anyeansan.github.io/categories/UI/CSS/"}],"tags":[]},{"title":"CSS 颜色 背景 字体","slug":"CSS-颜色-背景-字体","date":"2020-03-30T12:49:10.000Z","updated":"2020-03-30T12:49:29.989Z","comments":true,"path":"2020/03/30/CSS-颜色-背景-字体/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/CSS-%E9%A2%9C%E8%89%B2-%E8%83%8C%E6%99%AF-%E5%AD%97%E4%BD%93/","excerpt":"","text":"一 颜色1.1 color 取值 &lt;color&gt; 1.2 opacity 值 说明 1（默认） 元素完全不透明 0.0~1.0 元素半透明 0 元素完全透明 二 背景（background）2.1 语法1234567background-color ||background-image ||background-position [ / background-size]? || background-repeat ||background-attachment ||background-origin ||background-clip 无序，但是background-origin background-clip有前后顺序，如果只给一个值，则为它俩的共同值 background-position / background-size 通过斜杠连接 2.2 background-color 值 说明 transparent（默认） 透明 &lt;color&gt; 取值 &lt;color&gt; 2.3 background-image 值 说明 none（默认） 无背景图 &lt;image&gt; 取值&lt;image&gt; 2.4 background-repeat 值 说明 双值 repeat（默认） 背景图从左上角沿着x轴，y轴重复平铺 repeat repeat repeat-x x轴重复 repeat no-repeat repeat-y y轴重复 no-repeat repeat no-repeat 不重复 no-repeat no-repeat space 两端对齐平铺，多出来的空间用空白代替 space space round 两端对齐平铺，多出来空间通过自身的拉伸来填充 round round 水平轴 垂直轴 css3 定义时使用两个值，如果只设置一个，也会被解析成两个 2.5 background-position 值 说明 &lt;position&gt; 见&lt;position&gt; 2.6 background-attachment 决定背景图像的位置是在视口内固定，还是随着包含它的区块滚动。 值 说明 滚动条 scroll（默认） 背景相对于元素本身固定，会随着元素动，不会随着元素的内容滚动 元素上的滚动条（元素本身是不动的），背景不会动。页面上的滚动条（元素也会动），背景会动 fixed 背景相对于视口固定，不会随着元素或元素的内容滚动 不管元素上的滚动条还是页面的滚动条 背景都不动 local 背景相对于元素的内容固定，会随着元素或元素的内容滚动 不管元素上的滚动条还是页面的滚动条 背景都会动 2.7 background-clip 设置元素的背景（背景图片或颜色）切割范围（位置不动，直接裁剪，就好像拿剪刀剪一幅画一样） 值 说明 border-box（默认） 背景延伸至边框外沿（但是在边框下层） content-box 背景被裁剪至内容区外沿 padding-box 背景延伸至内边距外沿 2.8 background-origin 用来决定背景图片定位在哪个盒子中（即改变位置） 值 说明 padding-box（默认） 相对于padding-box定位 content-box 相对于content-box定位 border-box 相对于border-box定位 2.9 background-size设置背景图片大小 值 说明 auto（默认） 以背景图片的比例缩放背景图片 cover 缩放背景图片以完全覆盖背景区，可能背景图片部分看不见 contain 缩放背景图片以完全装入背景区，可能背景区部分空白 &lt;length&gt; 长度 &lt;percentage&gt; 背景图片相对背景区的百分比 * 宽 高 * 默认值 auto auto * 如果只设置一个值，则第二个值为 auto 三 字体3.1 @font face1 概述 自定义字体或字体集 它允许网页开发者为其网页指定在线字体。 通过这种作者自备字体的方式，可以消除对用户电脑字体的依赖 2 语法1234567891011@font-face &#123; [ font-family: &lt;family-name&gt;; ] || [ src: &lt;src&gt;; ] || [ unicode-range: &lt;unicode-range&gt;; ] || [ font-variant: &lt;font-variant&gt;; ] || [ font-feature-settings: &lt;font-feature-settings&gt;; ] || [ font-variation-settings: &lt;font-variation-settings&gt;; ] || [ font-stretch: &lt;font-stretch&gt;; ] || [ font-weight: &lt;font-weight&gt;; ] || [ font-style: &lt;font-style&gt;; ]&#125; 1 font-family 自定义字体的名称，特殊符号必须使用引号 2 src [ &lt;url&gt; [ format( &lt;string&gt;# ) ]? | local( &lt;family-name&gt; ) ]# 可以是在线字体，也可以是本地字体（多个使用逗号隔开） format用于转换字体格式，用于浏览器识别 fromat(&#39;woff2&#39;) 字体格式 说明 TrueType（.ttf） Windows和Mac上常见的字体格式，是一种原始格式，因此它并没有为网页进行优化处理 OpenType（.otf） 以TrueType为基础，也是一种原始格式，但提供更多的功能 Web Open Font（.woff） 针对网页进行特殊优化，因此是Web字体中最佳格式 SVG（.svg） 基于SVG字体渲染的格式 Embedded Open Type（.eot） IE专用字体格式，可以从TrueType格式创建此格式字体 3 font-style &amp; font-weight 用来设置对应字体样式或字重下该使用什么字体，font-family相同，可以通过样式和字重设置不同的字体12345678910@font-face &#123; font-family: &apos;myFont&apos;; font-style: normal; src: local(&apos;FZYaoti&apos;);&#125;@font-face &#123; font-family: &apos;myFont&apos;; font-style: italic; src: local(&apos;FZShuTi&apos;);&#125; 4 unicode-range 可以让特定的字符或者字符片段使用特定的字体 语法123456/* 支持的值 */unicode-range: U+26; /* 单个字符编码 */unicode-range: U+0-7F;unicode-range: U+0025-00FF; /* 字符编码区间 */unicode-range: U+4??; /* 通配符区间 ?表示占位符，U+4??即U+400-U+4FF*/unicode-range: U+0025-00FF, U+4??; /* 多个值 */ 3.2 font1 语法1234567[ font-style || font-variant || font-weight || font-stretch ]? font-size [ / line-height ]? font-family |caption |icon |menu |message-box |small-caption |status-bar font-size/line-height只能通过斜杠/组成一个值，不能分开写，如12px/1.5 font-size和font-family必须有 关键字指字体使用系统相应部位的字体 2 font-style 值 说明 normal（默认） 常规 italic 斜体 oblique &lt;angle&gt;? 倾斜体 可以附加角度 3 font-weight 值 说明 normal（默认） 常规 bold 加粗 lighter 较细 bolder 较粗 &lt;number&gt; 介于 1 和 1000 (包含) 之间 4 font-size 值 说明 关键字 xx-small, x-small, small, medium, large, x-large, xx-large, xxx-large, larger, smaller &lt;length&gt; 长度，如 px em ex rem &lt;percentage&gt; 相对父元素字体大小的百分比 5 line-height 值 说明 normal（默认） 与font-family 有关，不同浏览器和系统字体不同，默认值就不同，所以通常需要重新设置 &lt;number&gt; 推荐，字体大小的倍数。 &lt;length&gt; 长度值（如px，em） &lt;percentage&gt; 字体大小的百分比 数字 长度 百分比的区别 line-height:1.5、line-height:150% 和 line-height:1.5em 最终计算结果都是 line-height = font-size * 1.5，但是继承上是有差异的 数字继承的就是数字本身（所以计算子元素line-height时使用的是子元素的font-size乘以倍数） 长度和百分比继承的是计算值 6 font-family 属性值用逗号隔开 浏览器会选择列表中第一个该计算机上有安装的字体，或者是通过 @font-face 指定的可以直接下载的字体 应当至少在使用的 font-family 列表中添加一个通用的字体系列，因为无法保证用户的计算机内已经安装了指定的字体，也不能保证使用 @font-face 提供的字体移动能够正确地下载 值 说明 &lt;family-name&gt; 字体名称，有空格时要加引号 &lt;generic-name&gt; 字体系列，完全取决于用户机器上该字体系列是否可用，这个属性没有指示任何字体下载 css定义了五种通用字体系列 serif 带衬线字体，笔画结尾有特殊的装饰线或衬线 sans-serif 无衬线字体，即笔画结尾是平滑的字体 monospace 等宽字体，即字体中每个字宽度相同 cursive 草书字体，这种字体有的有连笔，有的还有特殊的斜体效果 fantasy 艺术字体 7 font-variant font-stretch 更像是专为英文设计的，默认即可","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"CSS","slug":"UI/CSS","permalink":"https://anyeansan.github.io/categories/UI/CSS/"}],"tags":[]},{"title":"CSS 值类型和单位","slug":"CSS-值类型和单位","date":"2020-03-30T12:47:36.000Z","updated":"2020-03-30T12:48:41.054Z","comments":true,"path":"2020/03/30/CSS-值类型和单位/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/CSS-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8D%95%E4%BD%8D/","excerpt":"","text":"一 文本类型 类型 说明 &lt;ident&gt; 预定义标识符 &lt;custom-ident&gt; 自定义标识符 &lt;string&gt; &#39;&#39;, &quot;&quot; &lt;url&gt; url(绝对/相对地址) 二 数值类型 类型 说明 &lt;integer&gt; 整数，可以有正负 + - &lt;number&gt; 数字，可以是整数也可以是小数，可以有正负 + - &lt;percentage&gt; % &lt;dimension&gt; 尺寸，由数字和单位构成，即 &lt;number&gt; + unit = &lt;dimension&gt; 三 单位3.1 &lt;length&gt; 单位 说明 px 像素 rem 相对于根元素的字体大小 r1h 相对于根元素的行高大小 em 相对于父元素的字体大小 ex 相对于小写字母”x”的高度即 x-height ch 相对于字符数字”0”的宽度 vw 相对于视窗的宽度：视窗宽度是100vw vh 相对于视窗的高度：视窗高度是100vh vmin 等于vh和vw 中较小的值 vmax 等于vh和vw 中较大的值 3.2 &lt;angle&gt; 单位 说明 deg 角度，一个完整圆角度是 360deg rad 弧度，一个完整圆弧度是 2π grad 百分度，百分度是角的测量单位，常用于建筑或土木工程的角度测量，非相关专业人士用的不多。一个完整圆百分度是 400grad turn 圈数，一个完整圆圈数是 1turn 3.3 &lt;time&gt; 单位 说明 s 秒 ms 毫秒 3.4 &lt;frequency&gt; （频率） 单位 说明 Hz 赫兹 kHz 千赫兹 3.5 &lt;resolution&gt; （分辨率） 单位 说明 dpi 表示每英寸点数 dpcm 表示每厘米点数 dppx 表示每像素点数 x dppx的别名 四 &lt;color&gt;4.1 颜色关键字 关键字 说明 关键字 说明 关键字 说明 black 黑色 gray 灰色 lime 石灰色 red 红色 silver 银色 navy 海蓝色 green 绿色 purple 紫色 teal 蓝绿色 blue 蓝色 orange 橙色 aqua 浅绿色 white 白色 maroon 褐色 fuchsia 紫红色 yellow 黄色 olive 橄榄色 4.2 十六进制 值 说明 #000000 黑色 #ff0000 红色 #00ff00 绿色 #0000ff 蓝色 #ffffff 白色 * 十六进制也属于RGB颜色，#RGB * 数字范围0~255，十进制 255 转成十六进制即 ff 4.3 RGB rgb(r, g, b) 使用数值 0~255 如rgb(255, 0, 100) 使用百分比 如 rgb(100%, 0%, 50%) rgba(r, g, b, a) a即alpha，透明度（0~1） 0表示透明，1表示不透明 4.4 hsl hsl(h, s, l) h即hue，色调（0~360） s即saturation，饱和度（0%~100%） l即lightness，亮度（0%~100%） hsla(h, s, l, a) 4.5 其它关键字 关键字 说明 transparent 透明，可以近似认为是 rgba(0,0,0,0)的缩写 currentColor 当前元素的字体颜色，即 `currentColor = color的值 五 &lt;color-stop&gt; &lt;color&gt; [ &lt;length&gt; | &lt;percentage&gt; ]? 使用长度或百分比指定颜色起止位置，如果省略，默认 50% 六 &lt;image&gt; 值 说明 &lt;url&gt; 使用url引入图片 &lt;gradient&gt; 使用渐变 element() 可以把页面元素当作背景图片 七 &lt;position&gt; 通过距离上下左右的距离指定二维坐标x, y，顺序任意，可以为负，如果省略则默认为 center 值 说明 关键字 left right top bottom center &lt;length&gt; 指定长度 &lt;percentage&gt; 指定百分比 一个值 keyword 指定水平或垂直中的一个，另一个默认为 center value 指定水平，垂直默认 50% 两个值 一个指定水平，一个指定垂直 四个值 keyword value keyword value keyword来表示水平或着垂直，value为值 八 &lt;gradient&gt; 值 说明 linear-gradient() 线性渐变，颜色值沿着一条隐式的直线逐渐过渡 radial-gradient() 径向渐变，颜色值由一个中心点（原点）向外扩散并逐渐过渡到其他颜色值 repeating-linear-gradient() 重复渐变，重复多次渐变图案直到足够填满指定元素 repeating-radial-gradient() 重复渐变 conic-gradient() 锥形渐变，颜色值围绕圆逐渐过渡 8.1 线性渐变语法 [ [ [ &lt;angle&gt; | to [top | bottom] || [left | right] ],]? &lt;color-stop&gt; [, &lt;color-stop&gt;]+ 第一个参数代表渐变的方向（默认 180deg） 角度 180deg 代表垂直向下，也就是to bottom 90deg 代表水平向右，也就是 to right 方向 to left to top right 第二个参数是颜色起止位置，见&lt;color-stop&gt; 8.2 径向渐变语法 [ &lt;ending-shape&gt; || &lt;size&gt; ]? [ at &lt;position&gt; ]? , &lt;color-stop&gt; [, &lt;color-stop&gt;]+ 第一个参数表示渐变的形状和大小 &lt;ending-shape&gt; circle 圆形（默认） ellipse 椭圆 &lt;size&gt; closest-side 近边 farthest-side 远边 closest-corner 近角 farthest-corner 远角 第二个参数表示渐变的位置，见 &lt;position&gt;","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"CSS","slug":"UI/CSS","permalink":"https://anyeansan.github.io/categories/UI/CSS/"}],"tags":[]},{"title":"CSS 选择器","slug":"CSS-选择器","date":"2020-03-30T12:46:31.000Z","updated":"2020-03-30T12:47:05.679Z","comments":true,"path":"2020/03/30/CSS-选择器/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/CSS-%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"","text":"一 选择器1.1 说明 最初定义时，所选元素必须有一个parent。而从选择器 Level 4 开始，parent不再是必须的 p :first-child 表示祖先元素p下的第一个子元素 p:first-child 表示同一个父元素下的第一个为p的子元素，如果第一个子元素不是p，会没有结果 我原来的理解是错误的（我理解的是p是父元素，寻找p的第一个子元素） 1.2 权重规则|粒度—|—|—!important|10000行内|1000id|0100class，伪类，属性|0010标签，伪元素|0001*|0000A&gt;B|null（继承没有权重，比0小） 比较样式的优先级，即算出所有选择器权重之和，然后比较大小 1.3 基础选择器 选择器 说明 html {} 元素选择器 #id {} id 选择器 .class {} class 选择器 * {} 通配选择器 s1, s2, s3, ... {} 组合选择器（并集） 1.4 关系选择器 关系选择器 说明 A E 元素E为元素A的后代元素 祖先元素 后代元素 A &gt; E 元素E为元素A的子元素 父元素 &gt; 子元素 B ~ E 元素E为元素B的兄弟元素 老n ~ 老m B + E 元素E为元素B的下一个兄弟元素 老n + 老n+1 1.5 属性选择器 属性选择器 说明 [attr] 带有attr属性的元素 [attr=value] attr属性值为value的元素 [attr^=value] attr属性值以value开头的元素 [attr$=value] attr属性值以value结尾的元素 [attr*=value] attr属性值包含value的元素 1.6 伪类选择器 伪类选择器 说明 :link 未访问 :visited 已访问 :active 点击 :hover 悬停 :focus 获取焦点 :not() 非（权重由括号内决定，自身0，不支持复杂选择器） :first-child 第一个子元素 :last-child 最后一个子元素 :noly-child 唯一的子元素 :nth-child(表达式) 匹配符合表达式结果的子元素（子元素从1开始) :nth-last-child(表达式) 从后匹配符合表达式结果的子元素 :fitst-of-type 第一个与父元素相同类型的子元素 :last-of-type 最后一个与父元素相同类型的子元素 :noly-of-type 唯一与父元素相同类型的子元素 :nth-of-type(表达式) 匹配符合表达式结果的与父元素相同类型的子元素 :nth-last-of-type(表达式) 从后匹配符合表达式结果的与父元素相同类型的子元素 :empty 没有子元素的元素 :checked 匹配选中的radio，checkbox，option :default 匹配默认选中的元素 :enabled 匹配启用的元素（可选择，点击，文本输入，获取焦点…） :disabled 匹配禁用的元素 :target 代表一个唯一的页面元素(目标元素)，其id 与当前URL片段匹配 :valid 匹配条件验证正确的表单元素 :invalid 匹配条件验证失败的表单元素 :required 匹配必须的表单元素 :optional 匹配可选的表单元素 :root 根元素即html * 表达式 * an+b * a和b为整数，（n=0，1，2，3…） * 元素从1开始 * 例如 * 0n+3/3，匹配第三个 * 1n+0/n，匹配每一个 * -n+3，匹配前三个 * 2n+0/2n 匹配偶数位置，或even * 2n+1，匹配奇数位置，或odd 1.7 伪元素选择器 伪元素选择器 说明 ::before 在元素内容的最前面添加新内容 ::after 在元素内容的最后面添加新内容 ::first-letter 匹配元素文本的第一个字（母） ::first-line 匹配元素文本的第一行 ::selection 匹配被用户选中或者处于高亮状态的部分 ::placeholder 匹配占位符的文本 * 注： * 伪元素默认都是内联水平 1.8 伪类 &amp; 伪元素1 伪类 为了通过选择器，格式化DOM树以外的信息以及不能被常规CSS选择器获取到的信息 格式化DOM树以外的信息。如&lt;a&gt;的:link，:visited，这些不在dom树中 不能被常规CSS选择器获取到的信息。如第一个子元素，常规css选择器无法获取，可以通过:first-child 获取 2 伪元素 伪元素可以创建一些文档语言无法创建的虚拟元素。 比如： 文档语言没有一种机制可以描述元素内容的第一个字母或第一行，但伪元素可以做到(::first-letter、::first-line)。 伪元素还可以创建源文档不存在的内容，比如使用 ::before 或 ::after。 3 区别 伪类其实是弥补了CSS选择器的不足，用来更方便地获取信息。即补充css选择器 伪元素本质上是创建了一个虚拟容器(元素)，我们可以在其中添加内容或样式 css3中伪类使用: 伪元素使用::","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"CSS","slug":"UI/CSS","permalink":"https://anyeansan.github.io/categories/UI/CSS/"}],"tags":[]},{"title":"CSS 概述","slug":"CSS-概述","date":"2020-03-30T12:45:21.000Z","updated":"2020-03-30T12:46:12.185Z","comments":true,"path":"2020/03/30/CSS-概述/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/CSS-%E6%A6%82%E8%BF%B0/","excerpt":"","text":"一 概述1.1 CSS Cascading Style Sheets 层叠样式表 1.2 规范 CSS1 &amp; CSS2 都是单一的规范 CSS3 CSS3 由于css内容日益增多，被划分成了多个模块，每个模块都有自己的规范 1.3 周边 less css 一种简化的功能更多的css语言 sass 一种简化的功能更多的css语言 postcss 一种css处理程序 二 语法2.1 注释 /* */ 2.2 CSS属性值定义语法中的符号说明 符号 说明 [] 表示组 &nbsp; 空格前后的各部分必须出现且按顺序出现 &amp;&amp; 各部分必须出现，但可以不按顺序 &#124;&#124; 各部分至少出现一个，可以不按顺序 &#124; 各部分只能出现一个 &lt;&gt; 值类型 ? 零次或一次 * 零次、一次或多次 + 一次或多次 # 一次或多次，但多次出现必须以逗号分隔 {m,n} 至少m次，至多n次 ! 组后面的叹号表示该组是必需的，并且至少产生一个值；即使组内项目的语法允许省略全部的值，也至少要保留一个值 2.3 样式语法123456选择器 &#123; 属性:值; 属性:值 值; 属性:值 值 值; ...&#125; 属性:值; 即声明，声明可以有多个，声明之间用分号隔开，表示结束 属性与值之间用冒号隔开 一个属性有多个值用空格隔开 三 HTML引入CSS样式3.1 内联样式（行内样式）1&lt;div style=&quot;属性:值;属性:值;&quot;&gt; 每个html标签都有一个style属性，该属性的值就是css样式 3.2 内部样式123&lt;style type=&quot;text/css&quot;&gt; css样式&lt;/style&gt; 在当前页面使用&lt;style&gt;标签书写css样式 3.3 外部样式 将css样式抽取成一个单独css文件,使用时导入页面。 导入方式 &lt;link&gt;1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&quot;/&gt; @import123456// 1 在html导入css文件&lt;style type=&quot;text/css&quot;&gt; @import url(&quot;&quot;); &lt;/style&gt;// 2 在css文件中引入其它css文件（需在文件头部）@import url(&apos;&apos;) link 和 @import方式的区别 link 属于 HTML 标签，而 @import 是 CSS 提供的 @import 只在 IE 5 以上才能识别，而 link 是 HTML 标签，无兼容问题 页面被加载时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载 link 方式的样式的权重高于 @import 权重 @import 不支持js的动态修改 一般推荐link，@import 补充使用","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"CSS","slug":"UI/CSS","permalink":"https://anyeansan.github.io/categories/UI/CSS/"}],"tags":[]},{"title":"HTML","slug":"HTML","date":"2020-03-30T12:43:19.000Z","updated":"2020-03-30T12:43:55.927Z","comments":true,"path":"2020/03/30/HTML/","link":"","permalink":"https://anyeansan.github.io/2020/03/30/HTML/","excerpt":"","text":"一 概述1.1 HTML Hyper Text Markup Language 超文本标记语言 超文本 指页面可以包含非文字内容。 标记 使用标签将需要的内容包括起来 1.2 XHTML Extensible Hyper Text Markup Language 可扩展的超文本标记语言 可以理解为升级版HTML 二 实体字符|描述|实体代码|实体编号—|—&nbsp;|空格|&amp;nbsp;|&amp;#160; | 大于号|&amp;gt;|&amp;#62;&lt;|小于号|&amp;lt;|&amp;#60;&amp;|与|&amp;amp;|&amp;#38;“|双引号|&amp;quot;|&amp;#34;‘|单引号|&nbsp;|&amp;#39;&#96;|反引号|&nbsp;|&amp;#96;&#124;|竖线|&nbsp;|&amp;#124©|版权|&amp;copy;|&amp;#169;®|注册|&amp;reg;|&amp;#174;™|商标|&amp;trade;|&amp;#8482; 前端字符表示方式 HTML中字符输出使用&amp;#x配上charCode值； 在JavaScript文件中为防止乱码转义，则是\\u配上charCode值； 而在CSS文件中，如CSS伪元素的content属性，直接使用\\配上charCode值。 unicode-range是U+配上charCode值。 三 标签12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;&quot; content=&quot;&quot;&gt; &lt;meta http-equiv=&quot;&quot; content=&quot;&quot;&gt; &lt;base href=&quot;&quot; target=&quot;&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link&gt; &lt;style&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt; &lt;/header&gt; &lt;main&gt; &lt;article&gt; &lt;section&gt;&lt;/section&gt; &lt;section&gt;&lt;/section&gt; &lt;aside&gt;&lt;/aside&gt; &lt;/article&gt; &lt;/main&gt; &lt;footer&gt; &lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 3.1 文档声明1&lt;!DOCTYPE html&gt; 3.2 根元素1&lt;html lang=&quot;&quot;&gt; lang 属性 作用 搜索引擎无法判断页面中的内容是什么语言，需要我们告诉它 浏览器会将读取到的页面语言和本地语言进行比较判断，如果一致，不做处理，否则提示是否需要翻译（如果有此功能） 有时候明明页面是中文由于设置的 lang=&quot;en&quot;，还会提示是否翻译，就是此原因 值 英文 en 中文 zh-CN 用的最多其实已过时 zh-Hans 简体中文 zh-cmn-Hans 以简体中文书写的普通话用词 zh-yue-Hans 以简体中文书写的粤语用词 3.3 文档元数据（Metadata）1234567891011# 文档元数据定义在 head 标签中&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;&quot; content=&quot;&quot;&gt; &lt;meta http-equiv=&quot;&quot; content=&quot;&quot;&gt; # 定义此文档中所有相对URL的根URL &lt;base href=&quot;&quot; target=&quot;&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link&gt; &lt;style&gt;&lt;/head&gt; 3.4 文档结构12345678910111213&lt;body&gt; &lt;header&gt; &lt;/header&gt; &lt;main&gt; &lt;article&gt; &lt;section&gt;&lt;/section&gt; &lt;section&gt;&lt;/section&gt; &lt;aside&gt;&lt;/aside&gt; &lt;/article&gt; &lt;/main&gt; &lt;footer&gt; &lt;/footer&gt;&lt;/body&gt; 标签 说明 &lt;header&gt; 文档页眉，用于展示介绍性内容，通常包含一组介绍性的或是辅助导航的实用元素，如标题 Logo、搜索框、作者名称，等等 &lt;footer&gt; 文档页脚，通常包含该章节作者、版权数据或者与文档相关的链接等信息 &lt;main&gt; 文档主体 &lt;nav&gt; 导航链接，如菜单，目录和索引… &lt;artical&gt; 定义独立的自包含内容区域 &lt;section&gt; 定义一个区块，一般是一组相似内容的排列组合 &lt;aside&gt; 附加区域，用于设置与主要区域无关的内容，比如侧面栏的广告等 &lt;body&gt; &lt;body&gt; 默认并不是全屏的 &lt;body&gt; 是块元素所以默认宽度为100%，高度0 &lt;body&gt; 设置背景色时，会发现覆盖全屏，其实是因为当html不设置背景时，body的背景将作为整个浏览器的背景色 3.5 文本相关 标签 说明 &lt;br&gt; 换行 &lt;hr&gt; 横线 &lt;h1&gt;~&lt;h6&gt; 标题标签 &lt;div&gt; 块标签 &lt;span&gt; 行内标签 &lt;p&gt; 段落标签 &lt;pre&gt; 原样显示文本内容包括空白、换行等 &lt;em&gt; 着重元素，显示为斜体 &lt;i&gt; 斜体，因某些原因需要区分普通文本的一系列文本，如技术术语、外文短语或是小说中人物的思想活动 &lt;strong&gt; 强调 &lt;mark&gt; 突出显示，类似生活中使用的马克笔 &lt;del&gt; 表示删除的内容，通常与&lt;ins&gt; 配合表示更新与修正 &lt;ins&gt; 表示文档中添加的内容 &lt;abbr&gt; 缩写 &lt;sub&gt; 下标 &lt;sup&gt; 上标 &lt;cite&gt; 通常表示它所包含的文本对某个参考文献的引用，或文章作者的名字，来源 &lt;blockquote&gt; 用来定义摘自另一个源的块引用 &lt;q&gt; 用于表示行内引用文本 &lt;address&gt; 设置联系地址等信息，通常放在 &lt;footer&gt; 中 &lt;progress&gt; 进度条 3.6 图片 &amp; 链接1 &lt;img&gt;1&lt;img src=&quot;图片地址&quot; alt=&quot;图片无法正常显示时的文字&quot; &gt; 2 &lt;a&gt;1&lt;a href=&quot;支持协议的URL或锚点&quot; target=&quot;&quot; title=&quot;链接提示文本&quot;&gt; 链接显示文本 &lt;/a&gt; target 说明 _selt 默认，当前页面打开 _blank 新页面打开 _parent 父级页面打开 _top 祖先页面打开 3.7 列表1 &lt;ul&gt; unorder list：无序列表12345&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; ...&lt;/ul&gt; 2 &lt;ol&gt; order list：有序列表12345&lt;ol&gt; &lt;li type=&quot;1、A、a、I、i&quot; start=&quot;首项从第几个开始&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; ...&lt;/ol&gt; 3 &lt;dl&gt; definition list：定义列表123456&lt;dl&gt; &lt;dt&gt;孙悟空&lt;/dt&gt; &lt;dd&gt;美猴王&lt;/dd&gt; &lt;dd&gt;齐天大圣&lt;/dd&gt; &lt;dd&gt;斗战胜佛&lt;/dd&gt;&lt;/dl&gt; 3.8 表格标签1234567891011121314151617181920212223&lt;table&gt; &lt;colgroup&gt; &lt;col width=&quot;控制第1列宽度&quot;&gt; &lt;col width=&quot;控制第2列宽度&quot;&gt; &lt;col width=&quot;控制第3列宽度&quot;&gt; &lt;colgroup&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;行列标题，内容默认居中，加粗&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td colspan=&quot;列合并&quot; rowspan=&quot;行合并&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; 使用&lt;thead&gt;&lt;tbody&gt;&lt;tfoot&gt;的好处是规定位置，即使代码的顺序是乱的，显示也是正确的。 &lt;thead&gt;&lt;tfoot&gt;可以没有，&lt;tbody&gt;不写也存在，且可以有多个 3.9 表单12345678&lt;form action=&quot;&quot; method=&quot;&quot;&gt; &lt;input type=&quot;&quot; name=&quot;提交key&quot; value=&quot;&quot;&gt; &lt;select name=&quot;提交key&quot;&gt; &lt;option value=&quot;提交值&quot; selected=&quot;&quot;&gt;页面显示值&lt;/option&gt; &lt;/select&gt; &lt;textarea name=&quot;提交key&quot;&gt;&lt;/textarea&gt; &lt;button&gt;&lt;/button&gt;&lt;/form&gt; form 说明 &lt;label&gt; 用于描述表单元素 &lt;button&gt; 按钮 &lt;input&gt; 表单交互式元素 &lt;select&gt; 选项菜单 &lt;textarea&gt; 文本域 &lt;datalist&gt; 为表单输入框准备一些选项列表 1 &lt;label&gt;12345// 1 id&lt;label for=&quot;表单元素的id&quot;&gt;&lt;input id=&quot;&quot;&gt;// 2 直接包裹表单元素&lt;label&gt;&lt;input&gt;&lt;/label&gt; 2 &lt;input&gt; 属性 说明 type 表单类型，默认为 text name 后台接收字段名 value 默认值 required 必须输入 placeholder 提示文本内容，得到焦点不会消失，一输入值就消失 maxlength 允许最大输入字符数 disabled 禁止使用，不可以提交到后台 readonly 只读，可提交到后台 autocomplete autocomplete=&quot;on&quot;，代表如果&lt;input&gt;元素的 type 允许，则会具有自动填充的功能 1 type type 说明 text 默认，文本框 password 密码框 radio 单选框，name 相同的是一个组，value 为提交值，checked 默认选中 checkbox 复选框，name 相同的是一个组，value 为提交值，checked 默认选中 file 上传文件，multiple=&quot;multiple&quot; 支持多选 button 按钮 image 图片提交按钮 hidden 隐藏域 submit 提交按钮，不指定服务端会提交到当前页面 reset 复位按钮 email 邮件框 search 搜索框 datetime-local 日期 2 表单提交方式 &lt;input type=&quot;submit&quot; name=&quot;&quot; value=&quot;点我提交&quot;&gt; 如果设置了name，按钮数据也会提交到后台，如果有多个表单项可以判断是哪个表单提交的。 &lt;button type=&quot;submit&quot;&gt;点我提交&lt;/button&gt; html5 推荐使用&lt;button&gt; 而不是表单的 &lt;input type=button&gt; &lt;input type=&quot;image&quot;&gt; 图片也能提交 3 &lt;select&gt;12345678&lt;select name=&quot;&quot; multiple&gt; &lt;option value=&quot;提交值&quot;&gt;显示值&lt;/option&gt; &lt;optgroup label=&quot;体育&quot;&gt; &lt;option value=&quot;lanqiu&quot;&gt;篮球&lt;/option&gt; &lt;option value=&quot;zuqiu&quot;&gt;足球&lt;/option&gt; &lt;option value=&quot;wangqiu&quot; selected&gt;网球&lt;/option&gt; &lt;/optgroup&gt;&lt;/select&gt; 属性 说明 name 提交字段 multiple 支持多选. select默认是单选 disabled 禁止使用，不可以提交到后台 required select的值不能为空 1 &lt;optfroup&gt; 选项组，其实只是将一些option分了一下组，与直接写option没区别 2 相关操作 options option集合 selectedIndex 选中的option的索引 获取选中的option var optionElement=selectElement[selectElement.selectedIndex] var optionElement=selectElement.options[selectedIndex] 获取option中的值 var value=optionElement.value var value=optionElement.innerHTML 清空select中的option selectElement.options.length=0 4 &lt;button&gt; type submit 默认 reset 重置所有组件为初始值 button 此按钮没有默认行为 5 &lt;datalist&gt;123456&lt;input type=&quot;text&quot; list=&quot;自定义名&quot;&gt;&lt;datalist id=&quot;输入框list名&quot;&gt; &lt;option value=&quot;&quot;&gt;&lt;/option&gt; &lt;option value=&quot;&quot;&gt;&lt;/option&gt; &lt;option value=&quot;&quot;&gt;&lt;/option&gt;&lt;/datalist&gt; 3.10 音/视频1 &lt;audio&gt; &lt;audio src=&quot;&quot; controls muted preload&gt; 2 &lt;video&gt; &lt;video src=&quot;&quot; controls muted autoplay poster=&quot;&quot; preload=&quot;&quot; loop&gt; controls 视频进度条 muted 静音 autoplay 自动播放，要设置静音才有效 poster 视频封面图 preload 视频预加载方式 loop 循环播放 四 attribute &amp; property4.1 概述 属性 说明 attribute HTML 预定义和自定义属性 property DOM 属性 4.2 操作1 property操作|原生DOM|jQuery-|-读|element.name|$element.prop(name)写|element.name=value|$element.prop(name, value)删|delete element.name|$element.removeProp(name) 2 attribute操作|原生DOM|jQuery-|-读|element.getAttribute(name)|$element.attr(name)写|element.setAttribute(name, value)|$element.attr(name, value)删|element.removeAttribute(name)|$element.removeAttr(name) 4.3 attribute &amp; property 的同步 浏览器只认 property，用户操作的也是 property 非布尔值属性 实时同步 布尔值属性 property 永远都不会同步 attribute attribute 没有动过property attribute会同步property 动过property attribute不会同步property 4.4 总结 优先操作 DOM property 没有 DOM property （如自定义属性 …）时，才使用 HTML attribute","categories":[{"name":"UI","slug":"UI","permalink":"https://anyeansan.github.io/categories/UI/"},{"name":"HTML","slug":"UI/HTML","permalink":"https://anyeansan.github.io/categories/UI/HTML/"}],"tags":[]},{"title":"学书无日不临池","slug":"学书无日不临池","date":"2020-03-29T03:44:12.000Z","updated":"2020-03-29T03:45:59.749Z","comments":true,"path":"2020/03/29/学书无日不临池/","link":"","permalink":"https://anyeansan.github.io/2020/03/29/%E5%AD%A6%E4%B9%A6%E6%97%A0%E6%97%A5%E4%B8%8D%E4%B8%B4%E6%B1%A0/","excerpt":"","text":"","categories":[{"name":"Index","slug":"Index","permalink":"https://anyeansan.github.io/categories/Index/"}],"tags":[]},{"title":"Linux 综合架构","slug":"Linux-综合架构","date":"2020-03-29T03:04:30.000Z","updated":"2020-03-29T03:05:52.277Z","comments":true,"path":"2020/03/29/Linux-综合架构/","link":"","permalink":"https://anyeansan.github.io/2020/03/29/Linux-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/","excerpt":"","text":"一 中小规模网站综合架构组成1.1 前端 防火墙 访问策略控制 负载均衡服务器 对访问请求进行调度处理 web服务器 处理用户请求 1.2 后端 数据库服务器 存储字符数据，如订单… 存储服务器 存储图片 音频 视频 附件都数据 备份服务器 存储网站所有服务器重要数据 缓存服务器 将常用数据存储到内存中，减轻服务器压力，提升用户体验 1.3 扩展 批量管理服务器 批量管理多台服务器主机 VPN服务器 内部员工访问架构 PPTP vpn 审计服务器（跳板机） 内部员工操作管理架构 jumpserver 监控服务器 综合架构服务器的监控 zabbix 网站架构单点问题（高可用服务） 负载均衡服务器 keepalived 数据库 mha 存储服务器 分布式存储 备份服务 rsync 云存储 缓存服务 集群/哨兵模式 二 备份2.1 备份策略 全量备份 完整备份所有数据 增量备份 做一次完全备份，以后每次只备份新增的数据 例 第一天完全备份 第二天备份第二天新增数据 第三天备份第三天新增数据 第四天备份第四天新增数据 差异备份 做一次完全备份，以后每次只备份和第一次完全备份不同的数据 例 第一天完全备份 第二天备份第二天新增数据 第三天备份第二天和第三天新增数据（和第一次比较） 第四天备份第二天第三天和第四天新增数据（和第一次比较） 2.2 备份命令 本地备份 cp 远程备份 scp -rp -r 递归 -p 保持文件属性 2.3 rsync1 概述 Rsync是一款开源的、快速的、多功能的、可实现全量及增量的本地或远程数据同步备份的优秀工具 安装 rsync 软件包 2 本地备份 rsync [OPTION] SRC DEST 等价于 cp 命令 rsync FILE 等价于 ls 命令 3 远程备份1 Push rsync [OPTION] SRC [USER@]HOST:DEST 等价于 scp 命令 OPTION -a 命令的归档参数，等价于 -rtopgDl -v 显示详细的传输信息 -z 传输时进行压缩以提高效率 -r 递归 -t 保持文件最后修改时间不变 -o 保持文件属主信息不变 -p 保持文件权限信息不变 -g 保持文件属组信息不变 -D 保持设备文件信息不变 -P 显示数据传输的进度信息 -l 保留软连接信息 -L 保留软连接指向目标文件的数据 --exclude=PATTERN 排除指定数据不被传输 --exclude-from=file 排除指定数据不被传输(批量排除) --bwlimit=RATE 显示传输的速率 --delete 让目标和源数据保持一致，即会删除目标中源没有的数据 USER@ 以什么用户身份推送数据（默认以当前用户） 2 Pull rsync [OPTION] [USER@]HOST:SRC [DEST] USER@ 以什么用户身份拉取数据（默认以当前用户） 4 守护进程方式（一直在后台持续的运行）1 rsync 守护进程部署流程 安装 rpm -qa rsync yum install -y rsync 配置文件 /etc/rsyncd.conf1234567891011121314151617181920uid = nobody # 管理备份目录的用户gid = nobody # 管理备份目录的用户组port = 873 # rsync # 备份服务的端口号fake super = yes # 将rsync服务虚拟用户伪装成为一个超级管理员用户use chroot = yes # 安全相关max connections = 4 # 最大链接数timeout = 900 # 超时时间pid file = /var/run/rsyncd.pid # 记录进程号的文件，服务运行时才有lock file = /var/run/rsync.lock # 锁文件log file = /var/log/rsyncd.log # rsync 服务日志文件ignore errors # 忽略传输过程中的简单错误read only =false # 备份目录可读写list = false # 客户端是否可以查看服务端的模块信息hosts allow = # 白名单hosts deny = # 黑名单auth users = # 指定认证用户secrests file = /etc/rsync.password # 指定认证用户密码文件 `用户名称:密码信息`[backup] # 模块信息 comment = # 注释信息 path = # 指定备份目录 创建rsync服务的虚拟用户 创建rsync服务密码认证文件（权限 600） 创建备份目录并修改属主属组信息 启动服务 systemctl start rsyncd 2 客户端免密码配置 创建一个密码文件（权限 600），存储密码 执行命令时，在命令后添加 --password-file =密码文件路径 3 Push rsync [OPTION] SRC [USER@]HOST::DEST OPTION 常用 -avz USER@ 指定认证用户信息 DEST 指定备份服务器的模块 4 Pull rsync [OPTION] [USER@]HOST::SRC [DEST] 5 rsync 原理 客户端当前登录用户通过命令向服务端发送推送请求 服务端判断客户端命令中认证用户是否存在配置 /etc/rsyncd.conf 中 服务端判断客户端认证用户密码是否正确 /etc/rsync.password 开始传输后，无论客户端发送请求的是root还是普通用户，到服务端都是通过配置的虚拟管理用户来备份。也就是说，传输的文件属主和属组在服务端会改为虚拟管理用户。 假如文件在客户端属主和属组是 root，服务端虚拟管理用户是 xiaoqiang，即在传输文件时需要把文件的属主和属组改为xiaoqiang，权限不足。 fake super 配置会将虚拟管理用户伪装成root 三 存储3.1 存储服务 FTP（File Transfer Protocol） FTP 服务器 FTP 客户端 samba windows–linux之间数据传输，Linux部署samba NFS（Network File System） linux–linux之间数据传输 门户网站-分布式存储 FastDFS GlusterFS 3.2 NFS1 概述 网络文件共享系统，主要功能是通过网络（一般是局域网）让不同的主机系统之间可以共享文件 2 RPC（Remote Procedure Call）四 批量管理4.1 ansible五 WEB服务","categories":[{"name":"Linux","slug":"Linux","permalink":"https://anyeansan.github.io/categories/Linux/"}],"tags":[]},{"title":"Linux 定时任务","slug":"Linux-定时任务","date":"2020-03-29T03:04:21.000Z","updated":"2020-03-29T03:06:30.004Z","comments":true,"path":"2020/03/29/Linux-定时任务/","link":"","permalink":"https://anyeansan.github.io/2020/03/29/Linux-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","excerpt":"","text":"一 定时任务1.1 实现定时任务的软件 cronie 周期性定时任务 atd 定时任务只执行一次，一次性定时服务 anacron 非7*24小时运行的服务器，用在个人电脑上 二 atd at 时间 创建一次性定时任务 at -l 查看一次性定时任务 atrm 任务序号 删除一次性定时任务 三 crond3.1 概述 Linux 系统定时任务由 crond 这个系统服务来控制，Linux 系统上原本就有非常多的计划性工作，所以 crond 服务是默认启动的 Linux 系统也提供了使用者控制计划任务的命令 crontab 命令 3.2 系统定时任务1234/etc/cron.hourly # 每小时/etc/cron.daily # 每天 00:00-23:59/etc/cron.weekly # 每周 7天/etc/cron.monthly # 每月 放在以上4个目录中的脚本会在相应周期自动执行。 /etc/crontab 系统定时任务的配置文件 只有root可以编辑 3.3 用户定时任务（cronie）1 相关文件 /var/spool/cron/用户名 用户定时任务配置文件 /var/log/cron 用户定时任务服务运行记录文件 /etc/cron.allow 当系统中有此文件时，只有写入此文件的用户可以使用 crontab 命令，优先级高于 /etc/cron.deny /etc/cron.deny 此文件中所列用户不允许使用 crontab 命令 2 配置 crontab crontab [-u USER] [OPTION] [FILE] USER 如果省略则表示针对当前用户 OPTION -l 查看用户定时任务列表 等价于 cat /var/spool/cron/用户名 -e 编辑用户定时任务 等价于 vim /var/spool/cron/用户名 -r 删除用户定时任务 等价于 rm -f /var/spool/cron/用户名 3 定时任务语法123456分 时 日 月 周 任务分：0-59时：0-23日：1-31月：1-12周：0-6 * 表示每（分/时/天/月/周） */N 表示每隔 N（分/时/天/月/周） M/N 表示从 M 开始每隔 N（分/时/天/月/周） M-N 表示 M 到 N 如 01-05 * * * * 表示每小时的01分到05分（01 02 03 04 05） M,N 表示 M 和 N 如 01,05 * * * * 表示每小时的01分和05分（01 05） N 表示具体时间 如 10 02 * * * 表示每天的02时10分 4 定时任务规范 编写定时任务要有注释说明 编写定时任务路径信息尽量使用绝对路径 编写定时任务要使用绝对路径命令 定时任务识别的 PATH 信息只有/usr/bin 和 /bin 编写定时任务尽量不要产生屏幕信息 定时任务执行时如果产生标准输出/标准错误输出（即输出到屏幕的信息），会以邮件的方式通知用户 问题 可能会导致邮件文件过大，占用磁盘空间 解决方式 关闭邮件服务 postfix，虽然可以阻止邮件发送，但会类似其它邮箱的草稿，不断在 /var/spool/postfix/maildrop/ 产生小文件占用磁盘空间 标准输出/标准错误输出都不输出到屏幕，而是重定向到黑洞文件 /dev/null 中（推荐）","categories":[{"name":"Linux","slug":"Linux","permalink":"https://anyeansan.github.io/categories/Linux/"}],"tags":[]},{"title":"Linux 网络","slug":"Linux-网络","date":"2020-03-29T03:04:13.000Z","updated":"2020-03-29T03:06:11.552Z","comments":true,"path":"2020/03/29/Linux-网络/","link":"","permalink":"https://anyeansan.github.io/2020/03/29/Linux-%E7%BD%91%E7%BB%9C/","excerpt":"","text":"一 虚拟机网络连接1.1 Bridged（桥接模式） 虚拟机相当于局域网内一台独立的主机，和宿主主机是对等的，同处于一个局域网 虚拟主机和宿主机网络地址是一致的 网卡：VMnet0 优点 局域网内其它物理主机可以直接和虚拟主机通信 缺点 占用局域网IP地址，同一个网段主机ip地址有限，可能会与其它物理主机ip冲突 1.2 NAT（网络地址转换模式） 虚拟主机 → 虚拟交换机 → 虚拟路由 → 宿主机 虚拟主机通过宿主机访问外网，宿主机相当于一个路由器，会将虚拟主机IP与宿主机IP做一个映射，访问外网使用的都是宿主机的IP 虚拟主机和宿主机网络地址可以不一致 网卡：VMnet8 虚拟机的子网掩码、网关、DNS要与Vmnet8的网卡保持一致。 优点 虚拟主机不占用局域网IP地址 缺点 局域网内其它物理主机不能直接和虚拟主机通信 1.3 Host-only（仅主机模式） 虚拟主机只能和宿主机通信，不能访问外网 网卡：VMnet1 二 网络配置2.1 图形界面 nmtui 2.2 网卡配置文件 /etc/sysconfig/network-scripts/ifcfg-ens3212345678910TYPE=Ethernet # 网络类型 目前基本为以太网BOOTPROTO=none # 网络启动协议，如何让主机获得ipDEFROUTE=yes # 使用默认路由NAME=ens33 # 第一块网卡逻辑名称DEVICE=ens33 # 第一块网卡设备名称（物理名称）ONBOOT=yes # 网卡是否激活IPADDR=192.168.13.24 # 静态ip PREFIX=24 # 子网掩码GATEWAY=192.168.13.2 # 网关DNS1=223.5.5.5 # DNS BOOTPROTO dhcp 动态获取ip none, static 静态ip（手动配置） 2.3 其它配置文件 /etc/resolv.conf 系统DNS客户端的配置文件 每次重启网卡此文件DNS都会更新为网卡配置文件所配置的DNS /etc/hosts 系统本地的DNS解析文件 可以手动设置域名和IP绑定信息 首先使用本地设置的域名对应的ip，若没有设置，才使用所配置的DNS来解析域名 /etc/hostname 主机名配置文件 三 系统路由设置 配置 \\ 版本 CentOS 6 net-tools CentOS 7 iproute 静态默认路由 route add/del default gw 网关 ip route add/del default via 网关 静态网段路由 route add/del -net 目标网络地址 netmask 子网掩码 gw 网关 ip route add/del -net 目标网络地址 netmask 子网掩码 via 网关 静态主机路由 route add/del -host 目标主机地址 dev 网关 ip route add/del -host 目标主机地址 via 网关","categories":[{"name":"Linux","slug":"Linux","permalink":"https://anyeansan.github.io/categories/Linux/"}],"tags":[]},{"title":"Linux 软件","slug":"Linux-软件","date":"2020-03-29T03:04:04.000Z","updated":"2020-03-29T03:06:42.749Z","comments":true,"path":"2020/03/29/Linux-软件/","link":"","permalink":"https://anyeansan.github.io/2020/03/29/Linux-%E8%BD%AF%E4%BB%B6/","excerpt":"","text":"一 软件包类型类型|说明|安装方式-|-源码包|源代码二进制包|编译安装rpm包|已编译过的二进制包|rpm 安装 / yum 安装 rpm 安装 安装时使用默认位置（大多数） rpm包之间存在依赖性 树形依赖 环形依赖 模块依赖 .so www.rpmfind.net 模块依赖查询 yum 安装 自动解决rpm的依赖性 二 源码包安装2.1 概述 可以自定义功能，安装时可以自定义路径 安装配置复杂，耗时 卸载方便（直接删除安装目录） 2.2 编译安装过程1 编译器（没有则安装） gcc yum -y install gcc gcc-c++ make zlib-devel pcre pcre-devel openssl-devel zlib：压缩库 pcre：支持正则表达式，地址重写rewrite openssl：提供https支持 2 下载源码包，解压并进入解压后目录3 软件配置和检查，生成 Makefile 文件 ./configure 定义需要的功能选项 检测系统环境是否符合安装要求 把定义好的功能选项和检测环境信息都写入Makefile文件，用于后续的编译 常见参数 --prefix=PATH 指定安装路径 --enable-ssl --disable-filter 启用禁用某项功能 --with-... 支持模块功能 4 按照 Makefile 文件编译 make 编译 make -j 4 指定4核心CPU编译，提升速度 make clean 清除make产生的文件 安装步骤之前，不会向安装位置写入任何文件，所以如果安装前有错误，执行make clean即可 5 按照 Makefile 定义的文件路径安装 make install 三 RPM（redhat package manager）3.1 概述 红帽软件包管理器 rpm通过将安装规则和源代码打包到一起，来降低软件的安装难度 3.2 rpm 操作1 查询 命令 说明 rpm -qa 查询所有已安装的软件包 rpm -q 包名 查询软件包是否安装 rpm -qi 包名 查询已安装软件包的详细信息 rpm -qip 全包名 查询未安装软件包的详细信息 rpm -ql 包名 查询已安装软件包中的文件列表 rpm -qlp 全包名 查询未安装软件包中的文件列表 rpm -qf file 查询文件属于哪个安装包 rpm -qR 包名 查询软件包的依赖性 rpm -qg group 查询组中的软件包列表 2 安装 rpm -ivh 包全名 -i, --install 安装 -v 显示详细信息 -h, --hash 显示进度 3 更新 rpm -Uvh 包名 -U, --upgrade 更新 4 卸载 rpm -e 包名 -e, --erase 卸载 5 校验 rpm -V 包名 -V 校验，对已经安装软件进行校验 检查包内容是否被修改，校验安全 校验信息 说明 S 文件大小是否改变 M 文件的类型或文件的权限（rwx）是否被改变 5 文件MD5校验和是否改变（可以看成文件内容是否改变） D 设备中的从代码是否改变 L 文件路径是否改变 U 文件的属主是否改变 G 文件的属组是否改变 T 文件的修改时间是否改变 四 Yum（Yellowdog Updater Modified）4.1 概述 yum通过将大量的常用rpm软件包放在一起，解决软件包之间的依赖关系，进一步降低软件的安装难度。 4.2 yum源1 配置基本 yum 源1 手撕配置文件 /etc/yum.repos.d/CentOS-Base.repo123456789[base] # 容器名称，唯一，区分不同yum源name= # 描述#mirrorlist= # 镜像站点，可以注释掉，和baseurl使用哪个都行#baseurl= # yum源服务器的地址。默认是CentOS官方的yum源服务器gpgcheck= # 公钥校验rpm包正确性 0不校验 1校验enabled= # 此yum源是否生效 0不生效 1或省略 生效gpgkey= # 公钥路径$releaseserver = `/etc/centos-release`$basearch = `*86_64` 2 从网络下载配置文件（手动下载，wget，curl …） wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo Aliyun mirror 2 配置扩展 yum 源 EPEL EPEL（Extra Packages for Enterprise Linux） 是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS等提供高质量软件包的项目。 wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo 3 配置本地 yum 源 挂载光盘 备份默认本地 yum 源 /etc/yum.repos.d/CentOS-Media.repo 配置新 /etc/yum.repos.d/CentOS-Media.repo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485[CentOS 7]name=CentOS-serverbaseurl=file:///mnt/cdromenabled=1gpgcheck=0 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7``` ## 4.3 yum 操作### 1 软件包#### 1 查询命令|说明-|-`yum repolist`|查看可用的yum源信息`yum list [all]`|显示所有软件包`yum list available`|显示所有可安装的软件包`yum list installed`|显示所有已安装的软件包`yum list updates`|显示所有可更新的软件包`yum info 软件包名`|查看软件包信息`yum search keyword`|根据关键字搜索软件包`yum provides file`|查询文件的来源，属于哪个软件包#### 2 安装命令|说明-|-`yum install 软件包名`|安装指定软件包#### 3 更新命令|说明-|-`yum update`|更新所有可更新的软件包以及系统内核，保留旧包`yum upgrade`|更新所有可更新的软件包以及系统内核，删除旧包`yum update 软件包名`|更新指定软件包以及系统内核，保留旧包`yum upgrade 软件包名`|更新指定软件包以及系统内核，删除旧包#### 4 删除命令|说明-|-`yum remove 软件包名`|删除指定软件包`yum erase 软件包名`|删除指定软件包#### 5 缓存命令|说明-|-`yum makecache`|生成仓库软件索引表（类似字典索引）`yum clean all`|清除缓存#### 6 gpg key* 安装时如果 yum 源配置 `gpgkey=1` 会进行验证，缺少key会报错 1. 改为 `gpgkey=0` 2. `rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7` * 执行此命令导入 gpg key### 2 软件包组（软件包操作命令加上 group 即可）1. `yum grouplist [all]` * 显示所有软件包组2. `yum groupinstall 软件包组`3. `yum groupupdate 软件包组`4. `yum groupremove 软件包组`# 五 实例## 5.1 恶搞软件1. `cowsay` * 动物说2. `sl` * 火车## 5.2 JDK### 1 查询是否有安装1. `rpm -qa | grep java` * 查看是否安装有jdk * 如果是源码(.tar.gz)安装 查不出来2. `rpm -e 包名` 或 `yum remove 包名` * 卸载### 2 下载* [JDK download](https://www.oracle.com/cn/java/technologies/javase-downloads.html &quot;JDK 官网&quot;) * 下载 `.tar.gz` 压缩包（Linux Compressed Archive）### 3 安装1. 将 `.tar.gz` 压缩包上传至 Linux2. 解压到指定目录### 4 配置环境变量1. `/etc/profile` export JAVA_HOME=解压路径export PATH=$JAVA_HOME/bin:$PATH 123456789101112131415162. `source /etc/profile`3. `java -version`## 5.3 Tomcat### 1 概述* tomcat 依赖 java 环境### 2 下载* [Tomcat download](https://tomcat.apache.org/ &quot;tomcat 官网&quot;) * 下载 `.tar.gz`### 3 安装1. 将 `.tar.gz` 压缩包上传至 Linux2. 解压到指定目录### 4 如果未关闭防火墙，则需要开放 8080 端口 1 添加端口并设置永久生效firewall-cmd –zone=public –add-port=8080/tcp –permanent2 重载firewall-cmd –reload3 查看是否开放firewall-cmd –zone=public –query-port=8080/tcp 5 启动 / 关闭 basedir/bin/version.sh 查看 tomcat 版本信息 basedir/bin/startup.sh 启动 tomcat basedir/bin/shutdown.sh 关闭 tomcat","categories":[{"name":"Linux","slug":"Linux","permalink":"https://anyeansan.github.io/categories/Linux/"}],"tags":[]},{"title":"Linux 文件信息","slug":"Linux-文件信息","date":"2020-03-29T03:03:58.000Z","updated":"2020-03-29T03:07:01.505Z","comments":true,"path":"2020/03/29/Linux-文件信息/","link":"","permalink":"https://anyeansan.github.io/2020/03/29/Linux-%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF/","excerpt":"","text":"一 文件信息133574978 -rw-------. 1 root root 1.5K Mar 25 15:10 anaconda-ks.cfg 文件属性（存储在文件的 inode 中） inode 编号 文件类型及权限 硬链接数 属主 属组 文件大小 最后修改时间 mtime 文件名（存储在父目录的 block 中） 二 inode &amp; block2.1 概述 存储设备格式化创建文件系统后，大致分为了两部分 inode 和 block inode 用来存储文件属性信息（元数据），不包括文件名 block 用来存储数据，文件名存储在父目录的 block 中 一个文件要占用一个 inode 和至少一个 block 2.2 inode1 概述 inode index 指向一个文件的 inode，是文件在文件系统中的唯一标识 文件名仅是为了方便人们的记忆和使用 修改文件会改变 inode，所以修改完服务器配置文件后，都需要重新加载一下配置文件 2 查看 inode 信息1 stat file 属性 说明 Inode inode 编号 Size 文件大小 Uid 文件属主 Gid 文件属组 Access 文件类型及权限 Links 链接数（硬链接） Blocks 数据块 block 数量 IO Block 每个数据块 block 大小 Device 存储该文件的设备号码 Access time atime，最后访问时间 Modify time mtime，文件内容最后修改时间 Change time ctime，inode 信息最后变动时间 2 df -i 查看 inode 使用情况 2.3 block 文件的 block 存储数据，目录的 block 存储目录下文件的文件名和 inode 的对应关系 一个文件可能占用多个 block，一个 block 的读写就消耗一次 I/O 一个 block 只能存放一个文件，如果 block 没有占满，剩余空间就浪费掉了 一个 block 默认大小为 4 k，可调整 如果存储文件较大，block 大点好，节省IO消耗 如果存储文件较小，block 小点好，提高磁盘利用率 三 文件类型3.1 查看文件类型 file [OPTION] FILE 查看文件类型及编码 OPTION -i 查看文件MIME类型及编码 -L 查看软链接文件时，查看的是软链接指向的目标文件的信息 3.2 文件类型分类 符号 说明 - 文件 d 目录 l 链接文件（软连接） s socket 文件（网路编程） b 块设备文件，（光驱 磁盘…）如/dev/sda c 字符设备文件，如 /dev/tty0，dev/null，dev/zero，dev/urandom p pipe 管道文件 1 - ASCII text 纯文本文件，可直接查看和编辑 binary 二进制文件（命令文件），不可以编辑 data 数据文件（压缩文件） 2 c /dev/null “空”设备（黑洞文件） 读 什么内容也读取不到 写 写入的内容会永远丢失 /dev/zero “零”设备 读 读取时提供无限的空字符（NULL， ASCII NUL，0x00） 典型用法是用它来产生一个特定大小的空白文件 写 写入的内容会永远丢失 /dev/urandom 伪随机数生成器 四 链接4.1 硬链接（Hard Link）1 概述 Linux 允许同一个 inode 对应多个文件名，多个文件指向同一个 inode 就是硬链接 不能对目录进行创建，只能对已存在的文件创建硬链接 同一个分区 inode 是唯一的，不能跨文件系统或者跨分区进行硬链接的创建 硬链接与原文件都拥有相同的 inode 和 block 删除一个硬链接不会影响原文件，只有文件的硬链接数为 0 ，文件才会被真正的删除 每个目录下包含两个隐藏项 . 当前目录的硬链接 .. 父目录的硬链接 链接数 文件的硬链接数 = 1（文件本身）+ n（硬链接数） 目录的硬链接数 = 1（目录本身）+ 1（.）+ n（子目录数..） 2 创建硬链接 ln 目标文件 硬链接文件 4.2 软连接（Symbolic Link）1 概述 软连接文件中存储的是另一个文件的指针，类似于快捷方式 软链接有自己 inode 和 block 可对目录或文件（包括不存在的）创建软链接 软链接可跨文件系统和分区 删除原文件相关软连接会变成死链接 2 创建软连接 ln -s 目标文件 软链接文件 软连接文件 -&gt; 目标文件 五 权限5.1 基本权限1 基本权限说明权限|二进制|八进制|文件|目录-|-|-|-r|100|4|读取文件内容|查看目录中的内容（ls）w|010|2|编辑文件内容|在目录中操作（touch mkdir rm cp mv）x|001|1|执行文件|进入目录（cd） 2 文件 权限 属主（root） 属主（普通用户） 其它人（root） 其它人（普通用户） --- 读 写 - 读 写 - r-- 读 写 读 读 写 读 -w- 读 写 写 读 写 写 --x 读 写 执行 - 读 写 执行 - r-x 读 写 执行 读 执行 读 写 执行 读 执行 1. root 对所有文件可读写，执行需要有执行权限 1. 读写：任意权限 2. 执行：x 2. 普通用户读写文件需要有相应权限，执行需要有 读 + 执行权限 1. 读：r 2. 写：w 3. 执行：rx 3. 通常文件权限需要有 r 3 目录 权限 属主（root） 属主（普通用户） 其它人（root） 其它人（普通用户） --- 读 写 执行 - 读 写 执行 - r-- 读 写 执行 读（只有文件名，没有文件属性信息） 读 写 执行 读（只有文件名，没有文件属性信息） -w- 读 写 执行 - 读 写 执行 - --x 读 写 执行 执行 读 写 执行 执行 r-x 读 写 执行 读 执行 读 写 执行 读 执行 -wx 读 写 执行 写 执行 读 写 执行 写 执行 1. root 对所有目录可读、写、执行 2. 普通用户对目录的读写需要 读写权限 + 执行权限 1. 读：rx 2. 写：rx 3. 执行：x 3. 通常目录权限需要有 x 4 umask &amp; 默认权限1 umask1 命令 umask 查看umask值，root 默认 0022，普通用户默认 0002 第一位是特殊权限，后三位是基本权限 rwx umask -S 以rwx形式查看umask值 umask 值 临时修改umask值 2 umask 和 默认权限的计算 没有umask时，文件的默认权限是 0666，目录的默认权限是 0777 有umask时，文件和目录默认权限简单算法（不严谨） 文件默认权限 = 666 - umask 目录默认权限 = 777 - umask 有umask时，文件和目录默认权限科学算法 将默认权限（目录777，文件666）和 umask 值转为 2 进制 对 umask 2 进制值取反 将默认权限和umask取反后的值进行与运算 &amp; 将二进制结果转为八进制，即为默认权限 2 默认权限 root 文件默认权限为 644 rw-r--r-- 目录默认权限为 755 rwxr-xr-x 普通用户 文件默认权限为 664 rw-rw--r-- 目录默认权限为 775 rwxrwxr-x 5.2 特殊权限1 SUID（set uid）（4）1 概述 SUID 权限仅对可执行二进制文件有效，目录没有意义 SUID 权限只有在该命令文件执行过程中有效 执行者必须对文件有可执行权限 命令文件执行时，执行者可以拥有文件属主的权限 总结：SUID 即将文件属主的权限分配给所有可执行此文件的人 2 例123---------- 1 root root /etc/shadow-rwsr-xr-x. 1 root root /usr/bin/passwd-rwxr-xr-x. 1 root root /usr/bin/cat 执行 passwd 命令修改密码其实最终要修改 /etc/shadow，而只有 root 可以读写 /etc/shadow 文件 普通用户执行 passwd 命令能成功的原因 普通用户对 passwd 命令有执行权限 passwd 命令有SUID权限，所以在执行时普通用户拥有了 passwd 属主 root 的权限 cat 命令没有SUID权限，所以普通用户无法通过 cat 查看 /etc/shadow 3 添加 SUID chmod u+s FILE chmod 4xxx FILE （xxx 为普通权限） 设置SUID之后，属主权限的显示 属主有 x 权限，则 x → s 属主无 x 权限，则 - → S 4 删除 SUID chmod u-s FILE chmod xxx FILE（去掉 4 即可） 2 SGID（set gid）（2）1 概述 文件 可执行二进制文件 SGID 权限只有在该命令文件执行过程中有效 执行者必须对文件有可执行权限 命令文件执行时，执行者可以拥有文件属组的权限 总结：SGID 即将文件属组的权限分配给所有可执行此文件的人 目录 普通用户在此目录中的有效组会变成此目录的属组 在此目录中新建文件或目录的属组为该目录的属组 2 例12-rwx--s--x 1 root slocate /usr/bin/locate-rw-r----- 1 root slocate /var/lib/mlocate/mlocate.db 执行 locate 命令需要读取 /var/lib/mlocate/mlocate.db 文件，而普通用户是没有读取此文件的权限的 普通用户执行 locate 命令能成功的原因 普通用户对 locate 命令有执行权限 locate 命令有 SGID 权限，所以在执行时普通用户拥有了 locate 属组 slocate 的权限，而 slocate 对 mlocate.db 文件是可读的 3 添加 SGID chmod g+s FILE chmod 2xxx FILE 设置SGID之后，属组权限的显示 属组有 x 权限，则 x → s 属组无 x 权限，则 - → S 4 删除 SGID chmod g-s FILE chmod xxx FILE 3 SBIT（sticky bit）（1）1 概述 粘滞位权限只对目录有效 如果一个用户对目录有 wx 权限，则意味着此用户可以删除目录下的所有文件（包含其它用户创建的文件） 若一个目录设置了 SBIT 权限，则在此目录下的文件只有 root 和 属主才可以删除或移动。 2 例1drwxrwxrwt. 19 root root /tmp 所有用户对 /tmp 目录都拥有完整权限，但普通用户却不能在 /tmp 下随意操作不属于自己的文件，是因为/tmp 设置了 SBIT 权限 3 添加 SBIT chmod o+t DIR chmod 1xxx DIR 设置SBIT后，其它人权限的显示 其它人有 x 权限，则 x → t 其它人无 x 权限，则 x → T 4 删除 SBID chmod o-t DIR chmod xxx DIR 5.3 权限管理命令1 chmod（change file mode bits） chmod [OPTION] mode file 修改文件权限（只有 root 和属主能改变文件的权限） OPTION -R 递归设置 mode {ugoa} {+-=} {rwx} u=属主 g=属组 o=其它人 a=ugo 八进制数字组合 如 755 ,644 ... 2 chown（change file owner and group） chown [option] [OWNER][:[GROUP]] file 修改文件的属主和属组 只有 root 可以修改文件的属主 属主（非root）只能修改文件的属组，且修改后的属组必须还是属主所在组 option -R 递归修改 5.4 最大有效权限 mask mask 的默认权限是 rwx，通常不会修改 文件上的除了属主外的权限（属组/其它人/ACL）都需要和 mask 权限作“与”运算，才能得到真正的权限 如设置的非属主权限是 r-x，则 r-x &amp; rwx = r-x 5.5 ACL（Access Control List）1 概述 访问控制列表 在普通权限中，用户对文件只有三种身份，属主、属组和其他人，但实际中只有这三个身份不太够用。 当用户对文件的权限与属主、属组和其它人这三种身份的权限都不相同时，就需要单独为用户分配权限，这就是 ACL 权限 文件权限信息最后的 . 就代表 ACL 权限 . 无 ACL 权限 + 有 ACL 权限 2 ACL 权限管理1 setfacl（set file access control lists） setfacl [OPTION] FILE OPTION -m, --modify 设置 acl 权限 -d, --default 设置默认 acl 权限 只对目录生效，目录中新建立的文件都拥有此默认权限 -k, --remove-default 删除默认 acl 权限 -x, --remove 删除指定 acl 权限 -b, --remove-all 删除所有 acl 权限 -R, --recursive 递归设置 acl 权限 设定的 acl 权限会对目录下的所有子文件生效（新建文件不生效） 2 查看 ACL 权限 getfacl FILE 3 增加 ACL 权限 setfacl -m m:权限 FILE 设置最大有效权限 mask setfacl -m u:用户名:权限 FILE 为某个用户设置acl权限 setfacl -m g:组名:权限 FILE 为某个组设置acl权限 setfacl -m d:u:用户名:权限 DIR 对目录设置默认acl权限 setfacl -m u:用户名:权限 DIR 对目录递归设置acl权限 4 删除 ACL 权限 setfacl -x u:用户名 FILE 删除用户的acl权限 setfacl -x g:组名 FILE 删除组的acl权限 setfacl -b FILE 删除文件所有的acl权限 seffacl -k DIR 删除目录默认的acl权限 5.6 文件扩展属性（隐藏属性）1 chattr（change file attributes on a Linux file system） chattr {+-=} [属性] FILE 修改文件或目录的隐藏属性（仅 root 可用） + 增加属性 - 删除属性 = 设置属性 属性 文件 目录 i（immutable） 不允许任何修改 可以修改目录下文件数据，不能新建和删除文件 a（append only） 可以给文件添加数据，不能修改和删除数据 可以修改目录下文件数据以及新建文件，不能删除文件 2 lsattr（list file attributes on a Linux second extended file system） lsattr [OPTION] [FILE] 查看文件或目录的隐藏属性 OPTION -a 若没有指定文件，则显示所有文件和目录 -d 若目标是目录，仅列出目录本身隐藏属性","categories":[{"name":"Linux","slug":"Linux","permalink":"https://anyeansan.github.io/categories/Linux/"}],"tags":[]},{"title":"Linux 磁盘","slug":"Linux-磁盘","date":"2020-03-29T03:03:51.000Z","updated":"2020-03-29T03:07:24.333Z","comments":true,"path":"2020/03/29/Linux-磁盘/","link":"","permalink":"https://anyeansan.github.io/2020/03/29/Linux-%E7%A3%81%E7%9B%98/","excerpt":"","text":"一 磁盘接口分类 类型 说明 使用 SAS Serial Attached SCSI 服务器 SATA Serial ATA 个人电脑 SSD Solid State Disk 服务器，个人电脑 SCSI Small Computer System Interface @declared IDE Integrated Drive Electronics @declared 二 磁盘物理结构2.1 外部结构 磁盘主轴 决定磁盘转速（rpm-round per minute） 磁盘盘片 用于存储数据 磁盘磁头（Head） 用于读取数据 每个盘面都有一个磁头 磁头数 = 盘面数 = 盘片 * 2 磁盘接口 用于连接主板，用于连接阵列卡 2.2 内部结构 磁道（Track） 盘面中一圈圈的同心圆称为磁道 每个盘面都被划分为数目相等的磁道，由外向内从 0 开始编号 柱面（Cylinder） 不同盘面上编号相同的磁道形成一个圆柱就叫做柱面 磁头在每个盘面上的都是一起移动的，所在磁道编号都相同，所以数据的读写以及磁盘分区都是按柱面进行的 柱面数 = 任意一个盘面的磁道数 单元块（Units） 单个柱面的大小 扇区（Sector） 磁道被直径划分为若干个弧段，每个弧段称为一个扇区，从1开始编号 扇区是磁盘存储的最小单位，通常是512字节 簇（Clust）/ 块（Block） 操作系统读取磁盘时，一个扇区一个扇区的读，效率太低，会一次性读取多个扇区，多个扇区就叫簇（windows）/ 块（linux） 簇 / 块 是文件系统存储的最小单位 2.3 磁盘容量 磁盘容量 = 磁头数(盘面数) × 每面磁道数(柱面数) × 每道扇区数 × 每扇区字节数(512byte) 三 RAID（Redundant Array of Independent Disks）3.1 概述 独立冗余磁盘阵列 把好几块硬盘通过一定组合方式把它组合起来，成为一个新的硬盘阵列组，从而使它能够达到高性能硬盘的要求 3.2 作用 提高磁盘存储效率 提高I/O速度，提供了数据并发性 提高磁盘存储安全 数据冗余（备份），数据校验 提高磁盘存储容量 扩充容量 3.3 RAID 级别（整合方式） raid 0 多块盘整合在一起，全部用作存储 可用容量为所有盘容量之和，性能高 没有冗余，有一块盘坏则整个raid 0 就坏，数据会丢失 raid 1 两块盘整合在一起，一个盘存储，一个盘备份 可用容量为一个盘，性能底 冗余100%，一块盘坏了数据也不会丢失 raid 5 至少有三个盘，一次只有两块盘存储，另一个盘作奇偶校验 容量为两个盘的容量，性能高 如果只有一块盘坏了，可以根据另外两块盘推算出这块盘的数据 raid 10 两个盘形成一个raid 1，然后两个raid 1形成一个raid 0 RAID 各级别比较 冗余 RAID 1 &gt; RAID 10 &gt; RAID 5 &gt; RAID 0 性能 RAID 0 &gt; RAID 10 &gt; RAID 5 &gt; RAID 1 成本 RAID 10 &gt; RAID 1 &gt; RAID 5 &gt; RAID 0 四 LVM（Logical Volume Manager）4.1 概述 逻辑卷管理器 实现分区的弹性扩容或缩容，逻辑卷通过命令可以从卷组中获取容量或者将容量返回给卷组 4.2 概念 物理卷 PV（Physical Volume） 物理卷是 LVM 的基本存储逻辑块，可以是分区、磁盘或Raid PE（physical extents） 物理卷中可以分配的最小存储单元，PE的大小是可以指定的，默认为4MB 卷组 VG（Volume Group） 一个卷组由一个或多个物理卷组成 逻辑卷 LV（Logical Volume） 逻辑卷建立在卷组之上，逻辑卷上可以建立文件系统，类似与其它硬盘的分区概念 LE（logical extent） 逻辑卷中可以分配的最小存储单元，在同一个卷组中，LE的大小和PE是相同的，并且一一对应 五 磁盘分区5.1 系统启动引导记录1 MBR（Master Boot Record） 用于引导磁盘空间小于2T 磁盘的 0 磁头、0 磁道、1 扇区 （512 bytes） 主引导程序（BootLoader）（446 bytes） 磁盘分区表DPT（Disk Partition table）（64 bytes） 1 个分区占16 bytes，所以最多有 4 个分区 分区有效(结束)标志（magic number）（2 bytes 55AA） 2 GPT 用于引导磁盘空间大于2T 5.2 分区概述1 Linux 磁盘和分区的命名规则 磁盘种类 磁盘命名 分区命名 SAS SATA SCSI 第一块：sda第二块：sdb… sda1 sda2 ...sdb1 sdb2 ... IDE 第一块：hda第二块：hdb… hda1 hda2 ...hdb1 hdb2 ... 2 分区说明 分区 编号 说明 主分区（Primary） 1 ~ 4 至少有 1 个，至多有 4 个 扩展分区（Extend） 1 ~ 4 至多有 1 个 逻辑分区（Logical） 5+ 由扩展分区划分成一个个逻辑分区 1. 真正存放数据的是主分区和逻辑分区，大量数据都放在逻辑分区中 2. 扩展分区可以理解为一个概念，用来划分逻辑分区用的，可以使用 1 ~ 4 任意一个编号 3 分区方式 1~4 个 主分区 磁盘：sda 主分区：sda1 sda2 sda3 sda4（数量任意） 1~3 个 主分区 + 1 个扩展分区（分成 n 个逻辑分区） 磁盘：sda 主分区：sda1 sda2 sda3（数量任意） 扩展分区：sda4（编号 1 ~ 4 任意，不与主分区重复即可） 逻辑分区：sda5 sda6 ... 4 分区方案1 普通分区方式 /boot 引导分区，256Mb swap 交换分区，把内存中暂时不用的数据临时存放到硬盘中，以腾出物理内存空间供给更活跃的程序服务来使用，目的是为了解决真实物理内存不足 内存 &gt; 8G，swap = 8G，内存 &lt; 8G，swap = 内存 * 1.5 / 根分区，剩余大小 2 存储服务器分区方式 /boot swap / 20G~200G /data 剩余大小，data 名称可自定义 3 灵活分区方式 /boot swap / 20G~200G 剩余保留，以后哪个部门使用，就分出相应的分区。 5.3 分区操作1 fdisk（manipulate disk partition table） fdisk -l [device] 查看磁盘及其分区表信息 fdisk device 分区（交互式操作），有默认值时直接回车代表使用默认值 交互命令 说明 n 创建分区 d 删除分区 p 显示分区表 q 不保存退出 w 将分区信息写入分区表，即保存退出 l 显示分区类型与分区类型id对照表，如 83:linux，8e:linux LVM t 改变分区类型 u 改变分区的方式（是否按照扇区进行划分） g 创建一个新的空的 GPT 分区表 2 parted parted device 用来划分容量大于2T的磁盘（交互式操作） 交互命令 说明 mklabel 创建一个分区表（默认为MBR） mklabel gpt 修改分区表为GPT print 显示分区表 mkpart PART-TYPE [FS-TYPE] START END 创建分区（立即生效） rm NUMBER 根据编号删除分区 quit 退出 3 partprobe partprobe [device] 重新读取分区表信息 分区完成之后，要执行此命令让系统识别分区文件 六 格式化6.1 概述 格式化用来创建文件系统 文件系统 xfs CentOS 7 ext3/4 CentOS 6 6.2 格式化操作mkfs（make file system） mkfs -t type device type 文件系统类型，如 xfs ext4 ... mkfs.type device 七 挂载7.1 概述 Linux中的存储设备（磁盘、光盘…）是不能直接访问的，需要将一个目录与一个存储设备相关联，通过关联目录访问存储设备中的数据。 将目录与存储设备关联的动作叫做 挂载 与存储设备关联的目录叫做 挂载点。 装完Linux系统后，能直接访问磁盘，是因为系统根据我们对磁盘的分区信息及顺序与指定目录进行了挂载，如：1234分区 挂载点/dev/sda1 /boot/dev/sda2 swap/dev/sda3 / 磁盘的使用 分区（可选）→ 格式化 → 挂载 7.2 挂载操作1 查 mount [-l] 显示系统中已经挂载的设备， -l 会显示卷标名称 2 挂载 mount [-t 文件系统] [-L 卷标名] [-o 挂载参数] 设备文件名 挂载点 临时挂载设备，重启失效 3 卸载挂载 umount 挂载点|设备文件 4 开机自动挂载1 使用开机自启动配置文件 /etc/rc.local -&gt; /etc/rc.d/rc.local 在此系统开机自启动配置文件，配置挂载命令，即可实现开机自动挂载 注意要给 /etc/rc.d/rc.local 赋予执行权限 2 使用挂载配置文件 /etc/fstab1234UUID=13ba788b-e881-484b-865f-2adc27ded83c / xfs defaults 0 0UUID=a347b25e-b9a2-4dee-bd26-7d4214c4959b /boot xfs defaults 0 0UUID=fbb8a2df-84b3-441f-a511-0760f45c9584 swap swap defaults 0 0设备/设备UUID 挂载点 文件系统类型 挂载参数 是否备份 是否自检 blkid 查看设备的名称、文件系统类型、UUID、LABEL等信息 mount -a 检查 /etc/fstab 文件中挂载的设备文件有无疏漏，若有，则进行挂载 5 不同设备的挂载 挂载硬盘分区 mount [-t xfs] /dev/分区名 挂载点 挂载U盘 mount [-t vfat] /dev/设备号 挂载点 U盘和硬盘一样，设备号不固定，先使用 fdisk -l 查询设备号 挂载光盘 mount [-t iso9660] {/dev/sr0 | /dev/cdrom} 挂载点 /dev/cdrom 是 /dev/sr0 的软连接 八 问题8.1 磁盘空间不足（no space left on device） block 存储空间不足 原因：存储数据过多 解决：删除没用数据 inode 数量不足 原因：大量小文件占用 inode 解决：删除大量的没用小文件 8.2 调整 swap 分区大小 从磁盘分出一部分空间（创建一个空文件 FILE） dd if=/etc/zero of=DIR bs= count= mkswap FILE 把文件作为 swap 空间使用 swapon FILE 激活扩展的 swap 空间 swapoff FILE 取消扩展的 swap 空间","categories":[{"name":"Linux","slug":"Linux","permalink":"https://anyeansan.github.io/categories/Linux/"}],"tags":[]},{"title":"Linux 用户管理","slug":"Linux-用户管理","date":"2020-03-29T03:03:41.000Z","updated":"2020-03-29T03:07:55.576Z","comments":true,"path":"2020/03/29/Linux-用户管理/","link":"","permalink":"https://anyeansan.github.io/2020/03/29/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/","excerpt":"","text":"一 用户分类UID|用户|说明|例-|-0|超级管理员|root 不一定是超级管理员，uid=0 的一定是超级管理员|root1~999|系统用户（虚拟用户）|用于维持、管理某个服务正常运行，不能登录且没有家目录，不能删除|nobody1000+|普通用户|管理指定数据，可以管理指定进程，可以登录|自定义 二 配置文件2.1 用户信息 /etc/passwd12345678root: x: 0: 0: root: /root: /bin/bash1 用户名:2 用户密码占位符（x表示有密码）:3 用户Uid:4 用户Gid:5 用户描述信息:6 用户家目录:7 用户登录后使用的shell: 2.2 用户密码信息，仅 root 可读 /etc/shadow12345678910root: $6$SlHDoVNtoeyDU/3w$y.ap.le40W39OROwHTk2xJnjDUbIcXX9GcAOOQA3k6yteiu9Xq9XyZzB8U/GbNzFSZ3LoC4q6Pazh806WZaKL0: : 0: 99999: 7: : :1 用户名：2 密码（加密）：3 密码最后修改时间：表示账号在1970-01-01之后的第 n 天修改的密码4 密码最小修改时间间隔：表示密码修改之后隔多久可以再次修改5 密码有效期：表示密码修改之后有效期限，超过期限会过期，必须重新修改6 密码过期前警告天数：默认为7，表示密码过期前7天会发送警告信息7 密码过期后宽限天数：8 账号失效时间：表示账号在1970-01-01之后的 n 天内有效，超过则失效9 保留字段： 2.3 用户组信息 /etc/group12345root: x: 0:1 组名：2 组密码占位符（x表示有密码）：3 组id（Gid）：4 组附加用户：即如果组是用户的初始组，则不显示此用户，只显示组中其它用户 2.4 用户组密码信息 /etc/gshadow12345root: : :1 组名：2 组密码：空表示没有组密码，`!` 表示没有组密码也没有组管理员3 组管理员：4 组附加用户： 2.5 用户模板目录 /etc/skel/12345# 添加用户时，此目录中文件会自动存入用户家目录.bash_logout # 退出登录时执行.bash_profile.bashrc.viminfo # vim文件模板 2.6 用户邮件目录 /var/spool/mail/用户名/ 2.7 新建用户配置文件 /etc/default/useradd 创建用户时的默认值 /etc/login.defs 用于在创建用户时，对用户的一些基本属性做默认设置，例如指定用户 UID 和 GID 的范围，用户的过期时间，密码的最大长度，等等 三 用户管理3.1 查1 id（print real and effective user and group IDs） id [OPTION] [USER] 显示用户 uid gid gids，默认为显示当前用户 OPTION -u, --user 显示用户 uid -g, --group 显示用户 gid -G, --groups 显示用户所有所在组的 gid -n, --name 与 u g G 一起使用显示名称而不是id 2 w（Show who is logged on and what they are doing） w 显示登录用户信息及负载信息 3 who（show who is logged on） who 显示登录用户信息 4 whoami whoami 显示当前登录用户名 5 last last 查看系统的所有登录信息 last 命令默认读取 /var/log/wtmp 日志，这是一个二进制文件 6 lastlog lastlog [-u UID] 查看用户最后一次登录系统的信息 lastlog 命令默认读取 /var/log/lastlog 日志，这是一个二进制文件 3.2 增1 useradd（create a new user or update default new user information） useradd [OPTION] username OPTION -u, --uid UID 指定Uid -g, --gid GROUP 指定用户初始组（组必须存在），且不会创建默认同名组。 默认会创建一个与用户名相同的初始组。 -G, --groups GROUP1[,GROUP2,...[,GROUPN]]] 指定用户附加组 -s, --shell SHELL 指定SHELL，默认为 /bin/bash -c, --comment COMMENT 用户描述信息 -d, --home-dir HOME_DIR 指定用户家目录 默认的用户家目录为 /home/username -M, --no-create-home 不创建家目录 -N, --no-user-group 不创建与用户同名的初始组 2 passwd（update user’s authentication tokens） passwd [OPTION] [USER] 修改用户密码（默认交互式） OPTION -S 查询用户密码状态（仅 root 可用） -l, --lock 锁定用户。会在/etc/shadow 中指定用户的密码前添加 !，使密码失效（仅 root 可用） -u, --unlock 解锁用户（仅 root 可用） --stdin 接收标准输入（如管道）的数据作为密码（非交互式） echo 密码 | passwd --stdin 用户 3.3 删1 userdel（delete a user account and related files） userdel [OPTION] USER 删除用户 实际就是从/etc/passwd shadow group gshadow 中删除用户信息 用户个人文件（家目录和邮件目录）默认会保留 OPTION -r, --remove 删除用户及个人文件 3.4 改1 usermod（modify a user account） usermod [OPTION] [USER] 修改用户信息 OPTION -u UID 修改用户uid -g GROUP 修改用户初始组 -G GROUPS 修改用户附加组 -c COMMENT 修改用户说明 -s SHELL 修改用户Shell -d HOME__DIR 修改用户家目录 -l USERNAME 修改用户名，注意修改家目录名和邮箱名以保持同步 -L 临时锁定用户 -U 解锁用户 2 chage（change user password expiry information） chage [OPTION] [USER] 修改用户密码信息 OPTION -l, --list 列出用户的详细密码状态 -d LAST_DAY 修改密码最后更改日期 0 用户一登陆就要修改密码 -m MIN_DAYS 修改两次密码最小修改间隔 -M MAX_DAYS 修改密码的有效期 -W WARM_DAYS 修改密码到期前的警告天数 -I DAYS 修改密码过期后的宽限天数 -E EXPIRE_DATE 修改账号失效时间 3.5 用户切换1 su su [OPTION] USER 普通用户切换至其它用户需要密码，root 切换至其它用户不需要密码 OPTION - 不加 - ，只有部分环境变量会变 加 -，表示完全切换用户，环境变量会随之改变 -c command 仅切换用户执行一次命令，执行后自动切换回来 2 sudo（execute a command as another user）1 概述 sudo 是一种权限管理机制 管理员可以授权普通用户以其它身份执行一些命令 2 授权方式 /etc/sudoers 直接修改此配置文件 visudo 等效于 vim /etc/sudoers，有语法检查（推荐） 3 配置 /etc/sudoers12345678# 1 语法授权的`用户` 主机地址=(可使用的身份 授权命令绝对路径列表授权的`%组` 主机地址=(可使用的身份 授权命令绝对路径列表# 2 例子root ALL=(ALL) ALL --- 表示root用户可以在任意主机上以任意身份执行任意命令an3 ALL=(ALL) /usr/bin/cat, /usr/bin/less --- 表示an3用户可以在任意主机上以任意身份执行cat和lessan3 ALL=(ALL) /usr/sbin/*, !/usr/sbin/visudo --- 表示 an3 用户可以在任意主机上以任意身份执行 /usr/sbin/ 下的所有命令，但排除 visudo 命令an3 ALL=(ALL) NOPASSWD: /usr/sbin/*, !/usr/sbin/visudo --- NOPASSWD：表示在使用sudo执行命令时不需要输入密码 4 使用 sudo -l 查看当前用户 sudo 可用的命令 sudo command 以管理员身份执行命令 四 用户组管理4.1 groupadd（create a new group） groupadd [OPTION] GROUP 创建用户组 OPTION -g, --gid GID 指定gid 4.2 groupdel（delete a group） groupdel GROUP 删除组 如果组是某个用户的初始组，则不能删除 4.3 groupmod groupmod [OPTION] GROUP 修改组 -g GID 修改gid -n NEW_NAME 修改组名 4.4 gpasswd gpasswd [OPTION] GROUP -A USER 将用户设置为组管理员 -a, --add USER 把用户加入组 -d --delete USER 把用户从组中删除","categories":[{"name":"Linux","slug":"Linux","permalink":"https://anyeansan.github.io/categories/Linux/"}],"tags":[]},{"title":"Linux 服务","slug":"Linux-服务","date":"2020-03-29T03:03:33.000Z","updated":"2020-03-29T03:07:37.025Z","comments":true,"path":"2020/03/29/Linux-服务/","link":"","permalink":"https://anyeansan.github.io/2020/03/29/Linux-%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"一 防火墙（firewalld）1.1 操作操作\\服务名|firewalld（CentOS 7）|iptables（CentOS 6）-|-查看状态|systemctl status firewalld|/etc/init.d/iptables status开启|systemctl start firewalld|/etc/init.d/iptables start关闭|systemctl stop firewalld|/etc/init.d/iptables stop开机启动|systemctl enable firewalld|chkconfig iptables on开机不启动|systemctl disable firewalld|chkconfig iptables off 1.2 配置（firewall-cmd） firewall-cmd --zone=public --list-ports 查看所有已经开放的端口 --zone 作用域 firewall-cmd --zone=public --query-port=端口/协议 查看某个端口是否开放 firewall-cmd [--permanent] --zone=public --add-port=端口/协议 开放端口 --permanent 永久生效，没此参数重启后失效 firewall-cmd [--permanent] --zone=public --remove-port=端口/协议 删除端口 firewall-cmd --reload 重载防火墙规则 二 远程连接服务（sshd）2.1 SSH（Secure Shell Protocol） SSH 加密传输，安全 Telnet 明文传输，不安全 openssh 服务端软件，ssh 协议的开源实现，CentOS默认安装 openssl 连接和传输过程中加密软件 2.2 连接方式1 基于密码的远程连接 公钥和私钥只用来完成数据加密 服务器发送公钥给客户端 客户端使用公钥对密码加密后回传给服务器，服务器解密验证密码 2 基于密钥的远程连接 在客户端创建密钥对 ssh-keygen -t rsa -t 指定密钥加密类型 命令会在 ~/.ssh/ 生成三个文件 id_rsa 私钥 id_rsa.pub 公钥 known hosts 客户端把公钥发送给服务端 ssh-copy-id -i 公钥路径 目标IP 手动上传 服务端将公钥存在 ~/.ssh/authorized_keys 权限 600 2.3 配置文件 /etc/ssh/ssh_config（客户端配置文件） /etc/ssh/sshd_config（服务端配置文件）123456789101112131415161718 17 #Port 22 # 配置端口 默认22 19 #ListenAddress 0.0.0.0 # 指定的网卡才能够接收远程访问请求，默认所有网卡都可以接收 22 HostKey /etc/ssh/ssh_host_rsa_key # 私钥位置 23 #HostKey /etc/ssh/ssh_host_dsa_key 24 HostKey /etc/ssh/ssh_host_ecdsa_key 25 HostKey /etc/ssh/ssh_host_ed25519_key 32 SyslogFacility AUTHPRIV # 日志记录ssh登录信息 33 #LogLevel INFO # 日志等级 38 #PermitRootLogin yes # 是否允许root远程连接 43 #PubkeyAuthentication yes # 是否开启公钥验证 47 AuthorizedKeysFile .ssh/authorized_keys # 公钥位置 65 PasswordAuthentication yes # 是否允许基于密码远程连接 64 #PermitEmptyPasswords no # 是否允许空密码用户远程连接 79 GSSAPIAuthentication yes # GSSAPI认证是否开启（关闭）116 #UseDNS yes # 是否开启反向DNS解析功能（关闭） 2.4 SSH 相关命令 ssh [-p port] [USER@]remote 连接 ssh-keygen 用于生成密钥对 ssh-copy-id 用于复制公钥到服务器 三 网络服务（network）","categories":[{"name":"Linux","slug":"Linux","permalink":"https://anyeansan.github.io/categories/Linux/"}],"tags":[]},{"title":"Linux 系统管理","slug":"Linux-系统管理","date":"2020-03-29T03:03:21.000Z","updated":"2020-03-29T03:08:13.868Z","comments":true,"path":"2020/03/29/Linux-系统管理/","link":"","permalink":"https://anyeansan.github.io/2020/03/29/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/","excerpt":"","text":"一 Systemd1.1 概述 Systemd 是一系列工具的集合，用于取代System V初始进程 Systemd 可以管理所有系统资源，不同的资源统称为 Unit（单位） Systemd 取代 init 成为系统中 PID 值为 1 的进程 1.2 命令1 systemctl Systemd 的主命令，用于管理系统 2 systemd-analyze 命令 说明 systemd-analyze 查看启动耗时 systemd-analyze blame 查看每个服务的启动耗时 3 hostnamectl 命令 说明 hostnamectl 显示当前主机的信息 hostnamectl set-hostname xxx 设置主机名 4 localectl 命令 说明 localectl 查看本地化设置 localectl set-locale en_US.UTF-8 设置字符集 localectl set-keymap us 设置键盘映射 localectl set-layout us 设置 x11 布局 5 timedatectl 命令 说明 timedatectl 查看时间及时区信息 timedatectl list-timezones 显示所有可用的时区 timedatectl set-timezone Asia/Shanghai 设置时区 6 loginctl 命令 说明 loginctl list-sessions 显示当前所有连接会话 loginctl list-users 列出当前所有登录用户 loginctl show-user root 显示指定用户的信息 7 journalctl 管理所有 Unit 的启动日志 日志的配置文件是 /etc/systemd/journald.conf 1.3 Unit1 概述 Unit 是 Systemd 管理系统资源的基本单元，可以认为每个系统资源就是一个 Unit 每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit Systemd 默认从目录 /etc/systemd/system/ 读取配置文件。但里面存放的大部分文件都是符号链接，指向目录 /usr/lib/systemd/system/，真正的配置文件存放在那个目录 2 分类类型|扩展名|说明-|-Service unit|.service|系统服务Target unit|.target|对 Unit 文件进行逻辑分组，多个 Unit 构成的一个 TargetDevice unit|.device|硬件设备Mount unit|.mount|文件系统挂载点，可代替/etc/fstabAutomount unit|.automount|自动挂载点Socket unit|.socket|进程间通信的socketPath unit|.path|文件或路径Scope unit|.scope|不是由Systemd启动的外部进程Slice unit|.slice|进程组Snapshot unit|.snapshot|Systemd快照，可以切回某个快照Swap unit|.swap|swap 文件Timer unit|.timer|定时器 3 Unit 状态1 Loaded（下次开机启动状态） 状态 说明 enabled 开机启动 disabled 开机不启动 static 不能自己启动，但有可能作为依赖被其它 enabled 服务启动 mask 禁止启动 2 Active（当前状态） 状态 说明 active（running） 持续运行 active（exited） 仅执行一次就正常结束的服务 active（waiting） 运行中，但要等待其它事件 inactive 没有运行 4 Unit 管理1 查 命令 说明 systemctl list-units 显示所有正在运行的 Unit systemctl list-units --all 显示所有Unit，包括没有找到配置文件的或者启动失败的 systemctl list-units --all --state=inactive 显示所有没有运行的 Unit systemctl list-units --failed 显示所有加载失败的 Unit systemctl list-units --type=service 显示所有正在运行的、类型为 service 的 Unit systemctl list-unit-files 显示所有配置文件 systemctl list-unit-files --type=service 显示指定类型的配置文件 2 依赖关系 命令 说明 systemctl list-dependencies name.service 显示某个 Unit 的所有依赖 systemctl list-dependencies -all name.service 展开显示某个 Unit 的所有依赖 3 常用操作（以 service 为例） 操作\\版本 CentOS 7 CentOS 6 启动服务 systemctl start name.service service name start 关闭服务 systemctl stop name.service service name stop 重启服务 systemctl restart name.service service name restart 查看服务状态 systemctl status name.service service name status 开机启动 systemctl enable name.service chkconfig name on 开机不启动 systemctl disable name.service chkconfig name off 是否启动 systemctl is-active name.service 是否开机启动 systemctl is-enabled name.service 重载某个配置文件 systemctl reload name.service 重载所有修改过的配置文件 systemctl daemon-reload 杀死服务所有子进程 systemctl kill name.service 1.4 Target1 概述 启动系统时，需要启动大量的 Unit，非常不方便 Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit System V 启动模式的 Runlevel 与 Target 作用类似，不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动 2 运行级别 &amp; TargetCentOS 6|CentOS 7| 说明—|—Runlevel 0 | runlevel0.target -&gt; poweroff.target|关机模式，系统默认运行级别不能设置为0，否则不能正常启动Runlevel 1 | runlevel1.target -&gt; rescue.target|单用户模式，root权限，用于系统维护，修改root密码等等，禁止远程登陆Runlevel 2 |runlevel2.target -&gt; multi-user.target|多用户模式（没有NFS），没有网络Runlevel 3 |runlevel3.target -&gt; multi-user.target|完全的多用户模式(有NFS)，登陆后进入控制台命令行模式Runlevel 4 |runlevel4.target -&gt; multi-user.target|系统未使用，保留Runlevel 5 |runlevel5.target -&gt; graphical.target|X11控制台，登陆后进入图形GUI模式Runlevel 6 |runlevel6.target -&gt; reboot.target|重启模式，默认运行级别不能设为6，否则不能正常启动emergency|emergency.target|急救模式 3 查看/修改默认运行级别 操作/版本 CentOS 6 CentOS 7 查看 runlevel systemctl get-default 修改 /etc/inittab systemctl set-default name.target 4 切换运行级别 CentOS 6 CentOS 7 init 0 systemctl poweroff init 1 systemctl isolate rescue.target init 2/3/4 systemctl isolate multi-user.target init 5 systemctl isolate graphical.target init 6 systemctl reboot * isolate 1. 切换 Target 时，默认不关闭前一个 Target 启动的进程 2. 加上 isolate 会关闭前一个 Target 里面所有不属于后一个 Target 的进程 二 启动流程2.1 CentOS 6 启动流程![](https://gitee.com/3noanswer/npics/raw/master/Linux/CentOS6 启动流程.png) 1 POST（Power-On-Self-Test） 加电自检，是BIOS功能的一个主要部分，负责完成硬件情况的检测 自检后根据设置获取第一个开机引导设备，如：光驱，硬盘，网络，USB BIOS（Basic Input Output System） 它是一组固化到计算机主板一个ROM芯片上的程序，它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序，它可从CMOS中读写系统设置的具体信息。 其主要功能是为计算机提供最底层的、最直接的硬件设置和控制 2 MBR（Master Boot Record） 主引导记录，存储于磁盘的 0 柱面 0 磁道 1 扇区，大小为 512 byte 446 byte BootLoader（GRUB） 64 byte 分区表 2 byte 55AA（用于MBR的有效性检查） 3 GRUB（GRand Unified Bootloader） 是一个来自GNU项目的多操作系统启动程序，分为两个阶段 第一阶段，MBR的前446 byte 1.5 阶段 第二阶段 /boot/grub BootLoader 提供菜单，允许用户选择不同的内核版本，然后将内核装载到内存的特定空间中，解压，展开，并把系统控制权移交给内核 4 加载内核（Kernel） Kernel 会开始侦测硬件并加载驱动程序 5 启动系统第一个进程 init init 进程控制后续各种服务的启动，init 是按照配置顺序启动服务（串行） # chkconfig: 2345 10 90 表示此服务可以在 Runlevel 2345 下启动，启动顺序为 10，关闭顺序为 90 6 获取系统运行级别 init 读取/etc/inittab配置文件， 获取系统默认运行级别 7 系统初始化 init 执行 /etc/rc.d/rc.sysinit 脚本来进行系统初始化，准备软件执行的作业环境 (如网络、时区等) 8 启动服务 init 执行系统运行级别对应的脚本，如 /etc/rc.d/rc3.d，及 /etc/rc3.d/* 下所有脚本 9 开机自启动程序 init 执行 /etc/rc.d/rc.local 脚本 10 登录界面 运行 mingetty 进程，进入登录界面 2.2 CentOS 7 启动流程![](https://gitee.com/3noanswer/npics/raw/master/Linux/CentOS7 启动流程.png) 三 进程3.1 概述 进程是已启动的可执行程序的运行实例，有以下组成部分： 已分配内存的地址空间； 安全属性，包括所有权凭据和特权； 程序代码的一个或多个执行线程； 进程状态 3.2 守护进程（Daemon） Linux服务器的主要任务就是为本地或远程用户提供各种服务 Linux系统上提供服务的程序通常是守护进程 守护进程一直在系统后台运行，时刻地监听用户的服务请求，一旦用户发出了服务请求，守护进程便为它们提供服务 3.3 系统初始化进程 系统初始化进程是一个特殊的的守护进程，其PID为1 是其他守护进程的父进程或者祖先进程，系统上所有的守护进程都是由系统初始化进程进行管理的（如启动、停止等） 在Linux的发展历史过程中，使用过3种初始化进程 init upstart systemd 3.4 进程状态 状态 说明 R（运行） 进程正在运行或在运行队列中等待 S（休眠） 可中断睡眠状态，可以被唤醒 D（不可中断） 不可中断睡眠状态，通常用于 I/O 情况 Z（僵死） 子进程退出，父进程还在运行，但是父进程没有读到子进程的退出状态，子进程进入僵死状态 T（暂停） 进程收到停止信号SIGSTOP后停止运行，可以发送SIGCONT信号让进程继续运行 X（死亡） 该状态是返回状态，在任务列表中看不到 t（追踪） 当利用gdb调试某个程序，程序停留在某个断点处时，就处于跟踪状态 状态组合符号 说明 s 表示进程是控制进程 &lt; 表示进程运行在高优先级上 N 表示进程运行在低优先级上 L 表示进程有页面锁定在内存中 l 表示进程是多线程的 + 表示进程运行在前台 3.5 查看进程1 ps1 ps -aux 属性 说明 user 启动进程的用户 PID 进程ID %CPU 进程占用cpu百分比 %MEM 进程占用内存百分比 VSZ 进程占用虚拟内存大小（KB） RSS 进程占用物理内存大小（KB） TTY 进程启动终端 STAT 进程状态 START 进程启动时间 TIME 进程执行起到现在总的CPU占用时间 COMMAND 启动进程的命令 2 ps -ef 属性 说明 UID 启动进程的用户 PID 进程 ID PPID 父进程 ID C 进程生命周期中的CPU利用率 STIME 进程启动时间 TTY 进程启动终端 TIME 进程执行起到现在总的CPU占用时间 CMD 启动进程的命令 * TTY 1. ? * 表示与终端无关，这种进程一般是内核态进程 2. tty1~7 * 本地终端 3. pts/0+ * 远程终端 3 ps -le 信息更详细 2 pstree pstree [OPTION] [PID | USER] 以树形结构显示程序和进程之间的关系 OPTION -a 显示启动每个进程对应的完整指令，包括启动进程的路径、参数等 -c 不使用精简法显示进程信息，即显示的进程中包含子进程和父进程 -n 根据进程 PID 号来排序输出，默认是以程序名排序输出的 -p 显示进程的 PID -u 显示进程对应的用户名称 3 lsof（list opened files） lsof [OPTION] 列出进程调用或打开的文件的信息 OPTION -u 用户名 列出某个用户的进程打开的文件 -p pid 列出指定进程号所打开的文件 -c 字符串 列出以字符串开头的进程打开的文件 -i 条件 列出符合条件的进程 3.6 监听进程1 top top [OPTION] OPTION -d 秒数 指定每隔几秒刷新，默认3秒 -n 次数 指定 top 抿了执行次数 -b 使用批处理模式输出。 一般和 -n 选项合用，用于把 top 命令重定向到文件中 -p PID 仅查看的进程 -u USER 只监听某个用户的进程 2 top 输出窗口交互命令 命令 说明 ?, h 显示交互模式的帮助 空格 默认 3s 刷新一次，按空格立即刷新 P 按照 CPU 的使用率排序（默认） M 按照内存的使用率排序 N 按照 PID 排序 T 按照 CPU 的累积运算时间排序，即按照 TIME+ 项排序 q 退出 top 命令 3 top 输出信息第一行（任务队列信息） 系统当前时间，系统运行时间，登录用户数，CPU负载 第二行（进程信息） 系统进程总数，运行进程数，睡眠进程数，停止进程数，僵尸进程数 第三行（CPU 信息） 内容 说明 us 用户模式占用的 CPU 百分比 sy 系统模式占用的 CPU 百分比 ni 改变过优先级的用户进程占用的 CPU 百分比 id 空闲 CPU 占用的 CPU 百分比 wa 等待输入/输出的进程占用的 CPU 百分比 hi 硬中断请求服务占用的 CPU 百分比 si 软中断请求服务占用的 CPU 百分比 st 虚拟时间百分比，就是当有虚拟机时，虚拟 CPU 等待实际 CPU 的时间百分比 第四行（物理内存信息 Mem） 内容 说明 total 物理内存的总量 free 空闲的物理内存数量 used 己经使用的物理内存数量 buff/cache 作为缓冲/缓存的内存数量 第五行（交互分区信息 Swap） 内容 说明 total 交换分区（虚拟内存）的总大小 free 空闲交换分区的大小 used 已经使用的交换分区的大小 avail Mem 总的可利用内存是多少 剩余部分（进程信息） 内容 说明 PID 进程的 ID USER 进程所属的用户 PR 优先级，数值越小优先级越高（由内核动态调整，用户不能修改） NI 优先级，数值越小优先级越高（用户可以自己调整） VIRT 进程使用的虚拟内存的大小，单位为 KB RES 进程使用的物理内存的大小，单位为 KB SHR 共享内存大小，单位为 KB S 进程状态 %CPU 进程占用 CPU 的百分比 %MEM 进程占用内存的百分比 TIME+ 进程执行起到现在总的CPU占用时间 COMMAND 启动进程的命令 3.6 结束进程1 kill1 原理 kill 命令会向操作系统内核发送一个信号和目标进程的 PID，然后系统内核根据收到的信号类型，对指定进程进行相应的操作 2 语法 kill -l 查看所有信号信息 kill [信号编号] PID 信号编号 信号名 说明 1 SIGHUP 重启进程 2 SIGINT 非强制性结束进程，ctrl + c 发出的是 kill -2 的信号 9 SIGKILL 强制结束进程 15 SIGTERM 正常结束进程，默认信号 19 SIGSTOP 挂起一个进程，ctrl + z 发出的是 kill -19 信号 2 killall killall [OPTION] [信号编号] 进程名 kill 命令使用 PID 结束进程，而 killall 使用进程名称来结束进程 OPTION -i 交互式，询问是否要杀死某个进程 -I 忽略进程名的大小写 4 pkill pkill [OPTION] [信号编号] 进程名 用来结束进程时，用法与 killall 一致 pkill [信号编号] -t 终端号 按照终端号踢出登陆用户 四 硬件信息4.1 CPU1 CPU 信息 cpu 路数 cpu 的物理个数 cpu 核数 cpu 的逻辑个数 core 一个物理 cpu 的核心数 核数 = 路数 * core 2 查看 CPU 信息 /proc/cpuinfo12345# 每一核cpu信息以空行分隔model name: # cpu型号physical id: # cpu路数，从0开始编号cpu cores: # 一路cpu的核数processor: # cpu核数，从0开始编号 lscpu1234model name: # cpu型号Socket(s): # cpu路数，从0开始编号Core(s) per socket: # 一路cpu的核数CPU(s): # cpu核数，从0开始编号 3 CPU 负载 负载简单说就是 cpu 的任务量，任务队列的平均长度 负载值 与 cpu 核数有关，负载不应该超过核的数量 负载信息 1分钟平均负载 5分钟平均负载 15分钟平均负载 4 查看 CPU 负载 /proc/loadavg10.00 0.01 0.05 1/104 1445 uptime 显示 cpu 负载信息 当前时间 系统运行时间 登录用户数 系统负载 w 显示 cpu 负载 及 登录用户信息 4.2 内存1 说明 通常 空闲内存 &gt; 可用内存，因为有时缓冲或缓存会空出一些内存，但是无法使用，这部分内存算在空闲内存上而不算在可用内存上 空闲内存：没有使用的内存 可用内存：没有使用的内存中可以使用的内存 2 查看内存信息 /proc/meminfo123456MemTotal: # 总内存MemFree: # 空闲内存MemAvailable: # 可用内存Buffers: # 缓冲Cached: # 缓存SwapCached: # 交换分区使用情况 free [OPTION] 显示内存信息 OPTION -h, --human 以人类可读的方式显示信息 -b, --bytes 以 byte 为单位显示 -k, --kilo 以 kb 为单位显示，默认 -m, --mega 以 mb 为单位显示 -g, --giga 以 gb 为单位显示 4.3 磁盘1 /proc/mounts 磁盘挂载信息 2 df df [OPTION] [file] 查看磁盘信息及挂载信息 option -h, --human 以人类可读的方式显示信息 -a, --all 显示所有文件系统信息 五 系统信息 /etc/reedat-release 系统版本信息（简略） /etc/os-release 系统版本信息（详细） uname -a 查看系统与内核相关信息","categories":[{"name":"Linux","slug":"Linux","permalink":"https://anyeansan.github.io/categories/Linux/"}],"tags":[]},{"title":"Linux 目录结构","slug":"Linux-目录结构","date":"2020-03-29T03:03:07.000Z","updated":"2020-03-29T03:05:30.242Z","comments":true,"path":"2020/03/29/Linux-目录结构/","link":"","permalink":"https://anyeansan.github.io/2020/03/29/Linux-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/","excerpt":"","text":"一 FHS1.1 概述 FHS FileSystem Hierarchy Standard 文件系统层次化标准，即目录结构规范 1.2 两层规范 / 目录下的各个目录应该放什么文件数据 针对 /usr 及 /var 这两个目录的子目录来定义 二 Linux目录结构2.1 / 目录 说明 / 根目录 /root Home directory for the root user (optional) /home User home directories (optional) /bin → /usr/bin Essential command binaries /sbin → /usr/sbin Essential system binaries /boot Static files of the boot loader 是boot分区的挂载点 /dev Device files /etc Host-specific system configuration /media Mount point for removeable media /mnt Mount point for mounting a filesystem temporarily /tmp Temporary files /var Variable data /usr Secondary hierarchy 系统软件和用户程序所在目录 /srv Data for services provided by this system /lib → /usr/lib Essential shared libraries and kernel modules /opt Add-on application software packages /proc Kernel and process information virtual filesystem 目录中数据存在内存 重启丢失 /sys 虚拟文件系统，记录内核相关信息，不占磁盘空间 /run 正在运行的进程相关信息的文件 lost + found 磁盘、文件系统损坏 断电 临时存放文件 2.2 /usr 最初linux只有一个盘，此盘挂载在 / 目录 后来一个盘不够用，又加了一个盘，第二个盘挂载在/usr目录，并且规定： 第一块盘用来存放系统程序相关 第二块盘用来存放用户自己程序相关。 / 和 /usr 目录结构完全相同 目录 说明 /usr/locl 源码编译安装软件的默认路径 /usr/src 存放源码的目录 /usr/share 帮助与说明文件，也可放置共享文件 2.3 /var/log 文件 说明 /var/log/messages 记录系统或服务运行的状态信息 和 错误信息 /var/log/secure 记录用户登录信息 /var/log/dmesg 记录了系统在开机时内核自检的信息（硬件加载） /var/log/cron 记录了系统定时任务信息 2.4 /etc 目录 说明 /etc/sysconfig/network-scripts/ifcfg-ens33 网卡配置文件 /etc/resolv.conf DNS客户端配置文件 /etc/hosts 系统本地的DNS解析文件 /etc/hostname 主机名配置文件 /etc/fstab 开机设备自动挂载配置文件 /etc/rc.local -&gt; /etc/rc.d/rc.local 开启自启动程序配置文件 /etc/bashrc /etc/profile 系统环境变量、别名等配置文件 /etc/init.d 软件启动程序所在目录（CentOS 6） /etc/ininttab 系统运行级别配置文件（CentOS 6） /etc/profile.d 用户登录后执行的脚本所在目录 /etc/issue 本地终端登录前欢迎信息 /etc/issue.net 远程终端登录前欢迎信息 /etc/motd 本地及远程登陆后欢迎信息 /etc/sysctl.conf Linux系统内核的配置和优化 /etc/os-release 系统版本信息 /etc/redhat-release 系统版本信息 /etc/passwd 账号信息 /etc/shadow 密码信息 /etc/group 组信息 /etc/gshadow 组密码信息 /etc/sudoers sudo 命令配置文件（权限提升） /etc/login.defs 所有用户登录时的默认配置 /etc/selinux selinux及其配置文件 /etc/locale.conf 系统语言及字符编码，环境变量LANG /etc/logrotate.conf 日志分割配置文件 * /etc/rc.local -&gt; /etc/rc.d/rc.local 1. 开启自启动程序命令的配置文件，开机自动加载此文件 2. CentOS 7 需要先为此文件添加执行权限 2.5 /proc 文件 说明 /proc/meminfo 内存信息 /proc/cpuinfo cpu信息，每一核以空行隔开 /proc/loadavg 负载信息 /proc/mounts -&gt; /proc/self/mounts 挂载信息","categories":[{"name":"Linux","slug":"Linux","permalink":"https://anyeansan.github.io/categories/Linux/"}],"tags":[]},{"title":"Shell","slug":"Shell","date":"2020-03-29T03:02:17.000Z","updated":"2020-03-29T03:02:39.752Z","comments":true,"path":"2020/03/29/Shell/","link":"","permalink":"https://anyeansan.github.io/2020/03/29/Shell/","excerpt":"","text":"一 Shell 概述 硬件 → 内核 → shell → 外层应用程序 shell 是命令解析器，将命令解析成二进制，是人和计算机交互的桥梁，linux 命令，windows 图形操作都需要shell来解析 shell 还是编程语言，解释型的脚本语言，在shell中可以直接调用 linux系统命令 二 Shell 分类2.1 Bourne Shell 1979年 unix 就开始使用，主文件名为sh Bourne Shell 家族 sh Bash 与sh兼容，现在为linux的默认 shell ksh psh zsh 2.2 C Shell 主要用在BSD版的unix中，与Bourne Shell不兼容 C shell家族 csh tcsh 三 Shell 相关配置文件 /etc/shells 所有shell类型 输入shell名即可切换shell /etc/password 用户具体使用哪一个shell，取决于此文件每一行的最后一个字段 四 快捷键 快捷键 说明 tab 补全 ctrl + c 终止正在执行的任务或者结束当前行的输入，发送 SIGINT 信号，终止一个进程 ctrl + d 退出当前shell，同 exit ctrl + z 暂停执行命令并放入后台，发送 SIGSTOP信号，挂起一个进程 ctrl + a 光标回到命令行首 ctrl + e 光标回到命令行尾 ctrl + ← → 在单词间左右移动光标 ctrl + u 剪切（删除）光标到行首的字符 ctrl + k 剪切（删除）光标到行尾的字符 ctrl + w 剪切（删除）一个空格分隔的字符串 ctrl + y 粘贴剪切的内容 ctrl + insert 复制命令行内容 shift + insert 粘贴命令行内容 ctrl + r 搜索命令行使用过的历史命令 ctrl + g 退出ctrl + r 搜索历史命令模式 Esc + . 获取上一条命令的最后部分（空格分隔） ctrl + l 清屏 同clear ctrl + s 锁定终端，使之无法输入内容 ctrl + q 结束 ctrl + s 的锁定 !! 执行上一条命令 !xx 执行最近以xx开头的命令 !xx:p 仅打印最近以xx开头的命令，但不执行 !num 执行历史命令列表的第num条命令 !$ 获取上一条命令的最后部分，同 Esc + . 五 命令5.1 内置命令 &amp; 外部命令1 内置命令 内置命令和shell是一体的，它们作为shell工具的组成部分存在。 内置命令在系统启动时就调入内存，是常驻内存的 内置命令一般在系统中不存在文件，而存在于bash解释器里 执行内置命令时不需要通过衍生出子进程来执行，也不需要打开程序文件。所以内置命令的执行速度要更快，效率也更高 2 外部命令 外部命令也称为文件系统命令，是bash shell之外的程序，它并不是shell 的一部分。 外部命令是系统软件的功能，用户需要时才从硬盘中读入内存 外部命令在系统路径下有相应的可执行文件，一般位于/bin、/usr/bin、/sbin 或 /usr/sbin。 执行外部命令时，Linux系统会创建出一个子进程（这种操作被称为衍生），Linux系统需要消耗资源来设置新子进程的环境，所以执行外部命令有额外的代价。 3 type type [-a] 命令 查看命令类型 pwd is a shell builtin 内置命令 pwd is /usr/bin/pwd 显示命令路径则为外部命令 -a 查看所有信息，有的命令如 pwd，即是内置命令又是外部命令 5.2 别名（alias） alias 查看别名列表 alias 别名 = 命令 为指定命令创建别名（临时） unalias 别名 删除别名 屏蔽别名 \\命令 命令绝对路径 删除别名 5.3 命令执行流程 判断输入的命令是否是绝对路径命令，是则直接执行，否 →2 判断输入的命令是否是别名命令，是则操作别名代表的真实命令，否操作输入的命令，无论是否，操作的命令 → 3 判断命令是否是内置命令，是则直接执行，否 → 4 判断外部命令是否有缓存，是则直接执行，否 → 5 根据系统环境变量 PATH 定义的路径依次查找命令的可执行文件，找到则执行，没找到则报错 执行过的外部命令会保存在内部缓存中，当再次执行相同的命令，会通过缓存调取执行 六 配置文件6.1 login shell &amp; non-login shell1 login shell 取得 shell 时需要完整的登陆流程的，就称为 login shell。 2 non-login shell 取得 shell 没有通过登录流程，就称为 non-loagin shee 比如在原本的 bash 环境下再次使用 bash 这个命令，建立了一个bash子进程，没有输入账号密码， 那第二个 bash 就是 non-login shell 。 3 一个判断的方式 echo $0 -bash：login shell bash：non-login shell 6.2 Interactive shell &amp; non-interactive shell1 Interactive shell（交互式shell） shell中的命令时由用户从键盘交互式地输入的，运行的结果也能够输出到终端显示给用户看。 2 non-interactive shell（非交互式shell） shell可能由某些自动化过程启动，不能直接接收用户的输入，也不能直接输出结果给终端用户看。 6.3 配置文件加载过程 1 login shell /etc/profile 加载系统配置文件1231 配置了一些环境变量 `USER LOGNAME MAIL PATH HOSTNAME HISTSIZE`2 配置了默认 umask3 调用 /etc/profile.d 下的脚本文件 ~/.bash_profile | ~/.bash_login | ~/.profile 加载用户配置文件，三者按照顺序只会读取其中的一个123456# 1 加载 ~/.bashrcif [ -f ~/.bashrc ]; then . ~/.bashrc fi# 2 由于脚本是顺序执行，所以首先加载 ~.bashrc，之后执行下边内容PATH=$PATH:$HOME/bin ~/.bashrc 用户配置12345678# 1 定义了一些别名alias rm=&apos;rm -i&apos;alias cp=&apos;cp -i&apos;alias mv=&apos;mv -i&apos;# 2 加载 /etc/bashrcif [ -f /etc/bashrc ]; then . /etc/bashrcfi /etc/bashrc 系统配置，配置了环境变量 PS1 2 non-login shell ~/.bashrc 只会读取 ~/.bashrc 这一个文件 /etc/bashrc 配置了环境变量 PS1 PATH 配置了 umask 调用 /etc/profile.d 下的脚本文件 .sh 6.4 重载配置文件 source 配置文件 . 配置文件 七 Shell 中的符号7.1 基本符号 符号 说明 \\ 转义符 $ 用于调用变量的值 &#39;&#39; 单引号，所见即所得。 &quot;&quot; 双引号，在双引号中$ &#96; &lt;/code> 有特殊含义 &#96;&#96; 反引号，解析命令 $() 同反引号，解析命令 &#124; 管道符，将前一个命令的正确输出输入到后一个命令 ; 前后命令没有逻辑关系，顺序执行 &amp;&amp; 逻辑与，前命令成功，后命令才执行 &#124;&#124; 逻辑或，前命令成功，后命令不执行；前命令不成功，后命令执行 7.2 集合 &amp; 序列1 集合 {ele1, ele2, ele3, ...} 2 序列 {first .. last .. increment} 从 first 开始，每次增长 increment ，不超过 last 3 集合或序列可与外部字符、集合或序列相结合1234echo a&#123;,2&#125; # a a2echo a&#123;1,2&#125; # a1 a2echo a&#123;1..3&#125; # a1 a2 a3echo &#123;1,2&#125;&#123;1..3&#125; # 11 12 13 21 22 23 7.3 通配符 符号 说明 ? 1个 任意字符 * 0 或多个 任意字符 ### 通配符 &amp; 正则 #### 1 通配符 1. 通配符根据文件名称进行筛选，是完全匹配 2. ls、find、cp... 这些命令不支持正则表达式，所以只能使用shell自己的通配符来进行匹配 2 正则 正则根据文件内容进行筛选，是包含匹配 grep、awk、se... 等命令可以支持正则表达式 3 Shell的 * 和正则的 * Shell 中的 * 表示匹配任意数量的任意字符，是文本，能单独出现 正则中的 * 代表数量，表示前一个字符或组连续出现 0 次或多次，不能单独出现 7.4 重定向1 标准输入/输出 类型 设备 设备文件名 文件描述符 标准输入 键盘 /dev/stdin 0 标准输出 显示器 /dev/stdout 1 标准错误输出 显示器 /dev/stderr 2 * 文件描述符 1. 是内核为了高效管理已被打开的文件所创建的索引，用于指向被打开的文件 2. 对文件描述符的操作就是对文件本身的操作。 可以直接通过操作文件描述来修改文件 2 标准输入重定向 语法 说明 命令 [0]&lt; 文件 将文件作为命令的输入 命令 [0]&lt;&lt; EOF ... EOF 把标识符之间内容作为命令的输入 * EOF * end of file * 可自定义，必须成对，后一个必须顶格（行首部） 3 标准输出重定向 语法 说明 命令 [1]&gt; 文件 将命令的正确输出添加到文件（覆盖） 命令 [1]&gt;&gt; 文件 将命令的正确输出追加到文件 4 标准错误输出重定向 语法 说明 命令 2&gt; 文件 将命令的错误输出添加到文件（覆盖） 命令 2&gt;&gt; 文件 将命令的错误输出追加到文件 5 标准输出重定向（正确输出+错误输出） 语法 说明 命令 &amp;&gt; 文件 将命令的输出（正确和错误）添加到文件（覆盖） 命令 &amp;&gt;&gt; 文件 将命令的输出（正确和错误）追加到文件 命令 &gt; 文件 2&gt;&amp;1 将命令的输出（正确和错误）添加到文件（覆盖） 命令 &gt;&gt; 文件 2&gt;&amp;1 将命令的输出（正确和错误）追加到文件 命令&gt;文件1 2&gt;文件2 把命令正确的输出添加到文件1中，错误的输出添加到文件2中（覆盖） 命令&gt;&gt;文件1 2&gt;&gt;文件2 把命令正确的输出追加到文件1中，错误的输出追加到文件2中 1. 1&gt;&amp;2 * 把正确输出输出到错误输出中 2. 2&gt;&amp;1 * 把错误输出输出到正确输出中 3. 命令 &gt;&gt; 文件 2&gt;&amp;1 * 没错误就把正确输出追加到文件 * 有错误就先把错误输出到正确输出中，然后一起追加到文件 八 变量8.1 规则 变量名不能以数字开头，由数字，字母，下划线组成 变量默认类型都是字符串，如果要进行数值运算，必须指定变量为数值型 变量赋值时等号两边不能有空格 变量的值有空格，需要单引号或者双引号 8.2 普通变量（局部变量） 只对当前shell有效，临时变量，重启失效 set 查看变量 变量名=值 定义变量 unset 变量名 删除变量 $变量名 取值 8.3 环境变量（全局变量）1 概述 命令行定义时，对当前shell及其子shell有效，临时变量，重启失效 写入配置文件中，根据配置文件决定对哪个shell有效，永久变量 2 命令 env 查询环境变量 export 变量名=值 定义环境变量 unset 变量名 删除变量 $变量名 获取值 3 常见环境变量 环境变量 说明 PATH 定义命令行解释器搜索执行命令的路径 HOME 用户家目录 SHELL 用户使用的 Shell 解释器名称 LANG 系统语言及字符编码 EDITOR 用户默认的文本编辑器 PS1 Shell 的命令提示符 RANDOM 生成一个随机数字 HISTSIZE 输出的历史命令记录条数 HISTFILESIZE 保存的历史命令记录条数 MAIL 邮件保存路径 4 位置参数变量 位置参数变量 说明 $0 代表命令本身 $n 代表第 n 个参数，如果 n&gt;=10，用大括号包含，如 ${10} $# 参数总个数 $@ 获取所有参数，每个参数独立，默认用空格分隔 $* 不加双引号同 $@，加上双引号，把所有参数视为一个整体 $? 获取上一个命令的执行返回值，0 成功，非 0 失败。 $$ 当前脚本的进程号（PID） $! 后台运行的最后一个脚本的进程号（PID） $_ 获取命令行最后一个参数，相当于 ESC . 5 变量值操作 ${} ${变量#pattern} # 从前往后匹配并删除 ## 贪婪匹配 ${变量%pattern} % 从后往前匹配并删除 %% 贪婪匹配 ${变量/oldStr/newStr} 替换一个匹配 ${变量//oldStr/newStr} 替换所有匹配 6 数值运算 $(()) 整数运算 可以用在引号中，不会直接输出 $[] 整数运算 可以用在引号中，不会直接输出 expr 1 + 1 整数运算，需要数字与运算符间要加空格 不能用在引号中，会直接输出 echo 1+1|bc 整数/小数运算 九 Shell 编程9.1 执行脚本方式 sh/bash 脚本 借助解释器执行，脚本可以不用是绝对路径 脚本绝对路径 把脚本当成命令执行（必须赋予执行权限） 9.2 windows 脚本在linux执行 问题 linux 换行符识别为$，而windows 换行符识别为^M$ :set list 在文件中查看 cat -A FIle 在外部查看 解决 安装 dos2unix dos2unix FILE 把文件从 dos 转为 unix，也就修改了换行符 9.3 脚本语法12#!/bin/bash# 注释 9.4 条件表达式1 语法 [ 条件表达式 ] 两侧各有一个空格 条件成立返回 0，反之 1 test 条件表达式 2 文件 表达式 单词 说明 -e FILE exit 判断该文件是否存在 -f FILE file 判断该文件是否存在，且是否是文件 -d FILE directory 判断该文件是否存在，且是否是目录 -l FILE link 判断该文件是否存在，且是否是链接文件 -r FILE read 判断该文件是否存在，且是否有读权限 -w FILE write 判断该文件是否存在，且是否有写权限 -x FILE execute 判断该文件是否存在，且是否有执行权限 FILE1 -ef FILE2 equals file 判断两个文件是否一样（硬链接） FILE1 -nt FILE2 new than 判断文件1是否比文件2新（最后修改时间） FILE1 -ot FILE2 old than 判断文件1是否比文件2旧（最后修改时间） 3 数值 [[表达式]] [表达式] 单词 说明 == -eq equal 等于 != -ne not equal 不等于 &gt; -gt greater than 大于 &gt;= -ge greater equal 大于等于 &lt; -lt less than 小于 &lt;= -le less equal 小于等于 4 字符串 表达式 单词 说明 -z STRING zero 判断字符串长度是否为 0 -n STRING not zero 判断字符串长度是否不为 0 STR1 = STR2 equal 判断字符串是否相等 STR1 != STR2 not equal 判断字符串是否不相等 5 逻辑表达式 表达式 单词 说明 EXPR1 -a EXPR2 and 逻辑与 EXPR1 -o EXPR2 or 逻辑或 ! EXPR not 逻辑非 6 正则表达式（使用 [[]]） 表达式 说明 =~ PATTERN 判断是否匹配 9.5 语句1 if12345678if [条件] then codeelif [条件] then code......else codefi 12345678if [条件]; then codeelif [条件]; then code......else codefi 2 for1234for 变量名 in 取值列表 # 值用空格或换行隔开 do code... done 1234for((初始值;循环条件;变量变换)) do code done 3 while1234while [条件] do code done 4 until1234until [条件] do code done 一直执行直到条件成立，即条件不成立就无限循环，与while相反 5 case12345678910case $变量 in 模式1) code ;; 模式2) code ;; *) code（皆不符合时执行）esac 6 shell 内置语句 continue 跳出本次循环，继续下一次 break 跳出循环 exit 结束，类似 return 9.6 函数1 定义方式1234561function test() &#123; return 返回值&#125;2test() &#123;return 返回值&#125;3function test &#123;return 返回值&#125; 2 变量定义 shell脚本定义的变量默认都是全局的（包括在函数中定义） local 变量=值 使用local表示只在当前作用域有效 let 用来执行算术运算，等价于 ((运算式)) 3 传参12test $1 $2 ...# 注意 $1 指的是脚本传参的顺序 4 外部调用1test.sh test $1 $2 ... 9.7 数组1 定义1arrName=(val1 val2 ... valN) 2 获取属组长度1$&#123;#arrName[*|@]&#125; 3 获取值121 $&#123;arrName[index]&#125; # 获取指定值2 $&#123;arrName[*|@]:startIndex:length&#125; # 获取从startIndex开始的length个值 4 设置值1arrName[index]=value 5 删除121 unset arrName[index] # 删除指定值2 unset arrName # 清空数组 6 替换1$&#123;arrName[@|*]/pattern/new&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://anyeansan.github.io/categories/Linux/"}],"tags":[]},{"title":"Linux 安装和配置","slug":"Linux-安装和配置","date":"2020-03-29T02:09:49.000Z","updated":"2020-03-29T02:10:51.754Z","comments":true,"path":"2020/03/29/Linux-安装和配置/","link":"","permalink":"https://anyeansan.github.io/2020/03/29/Linux-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/","excerpt":"","text":"一 概述1.1 硬件 电源 CPU 路数：即CPU的个数，1 路 = 1 CPU 核数 内存 缓冲（buffer） 写：数据 → 内存 → 磁盘 缓存（cache） 读：磁盘 → 内存 → 数据 磁盘 主板 显卡 声卡 键鼠 1.2 服务器 硬件服务器 机架服务器 刀片服务器 塔式服务器 虚拟服务器 阿里云 亚马逊（AWS） 腾讯云 1.3 操作系统 硬件 + 内核 + shell + 软件 1.4 Linux发展历史 FSF free software foundation 自由软件基金会，主要项目是GNU GNU GNU是“GNU is Not Unix”的递归缩写，目标是建立可自由发布和移值的类unix操作系统 GNU类UNIX操作系统是由一系列应用程序，系统库和开发工具构成的软件集合（如Emacs，gcc，bash，gawk），并加上了用于资源分配和硬件管理的内核。 GPL general public license：通用公共许可，是一个开源许可协议 linux 操作系统 = linux内核 + GNU软件和系统软件 + 必要的应用程序 1.5 Linux 发行版 Fedora 免费，新功能，小白鼠 Red Hat 收费 CentOS 去掉Red Hat的logo，收费软件被重新打包编译 后被Red Hat 收购 Ubuntu 桌面 Debian FreeBSD 安全 稳定 1.6 语录 Linux 一切从根开始 Linux 一切皆文件 Linux 系统中命令行的修改大部分都是临时修改，配置文件是永久修改。 Linux 系统服务配置文件修改后，需要重启服务（重新加载配置文件） 二 CentOS 7 安装2.1 下载镜像 CentoOS project Aliyun mirror 2.2 准备虚拟环境 虚拟软件 VMware Workstation 2.3 安装配置1 软件安装 Minimal Insatll Debugging Tools Compatibility Libraries Development Tools System Administration Tools 2 网络（NAT） 主机名 config General 勾选自动连接 IPv4 settings Method Manual （手动） ip 子网掩码 网关 根据虚拟机网络编辑器中 VMnet8 网卡设置 dns 如 223.5.5.5，8.8.8.8 3 磁盘分区（standard partition） /boot 引导分区，256Mb swap 交换分区， 内存 &gt; 8G，swap = 8G，内存 &lt; 8G，swap = 内存 * 1.5 / 根分区，剩余大小 4 关闭安全策略 KDUMP SECURITY POLICY 三 初始化配置3.1 配置 yum 源1 安装 wget yum install wget -y 2 备份 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 3 下载基本 yum 源 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 4 下载扩展 yum 源 EPEL wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo 3.2 更新系统和软件 yum update -y 3.3 安装企业运维常用基础工具包1 CentOS 6 &amp; 7 都要安装的 yum install tree nmap dos2unix lrzsz nc lsof tcpdump htop iftop iotop sysstat nethogs -y 软件包名 说明 tree 树形结构显示文件和目录 nmap 扫描端口的工具 dos2unix 转换脚本格式的工具 lrzsz 包含上传（rz）和下载（sz）文件工具 nc 文件传输、端口检查工具 lsof 反查端口进程，以及服务开发文件工具 wget 网络下载工具 tcpdump 抓包、监听等重要排错工具 htop 系统进程相关信息查看工具 iftop 主机网卡宽带查看工具 sysstat 含有sar iostat 等重要系统性能查看工具 nethogs 显示进程的网络流量 2 CentOS 7 安装的 yum install psmisc net-tools bash-completion bash-completion-extras vim-enhanced -y 软件包名 说明 psmisc 含有 killalll pstree 等命令 net-tools 含有 netstat ifconfig route arp 等命令 bash-completion tab补全功能工具包 bash-completion-extras tab补全功能扩展工具包 vim-enhanced vim 3.4 修改网卡名称1 安装系统时 菜单界面 按 tab 输入 net.ifnames=0 biosdevname=0 2 安装系统后 修改网卡配置文件内容及文件名 /etc/sysconfig/netword-scripts/ens331234561 修改内容 vim /etc/sysconfig/netword-scripts/ens33 name=eth0 device=eth02 修改文件名 mv /etc/sysconfig/netword-scripts/ens33 /etc/sysconfig/netword-scripts/eth0 修改网卡名称规则内核文件 /etc/default/grub1234567891011121314151617181920vim /etc/default/grubGRUB_CMDLINE_LINUX=&quot;rhgb quiet&quot; 改为GRUB_CMDLINE_LINUX=&quot;net.ifnames=0 biosdevname=0 rhgb quiet&quot;``` 3. 系统重新加载 grup 配置文件 * `grub2-mkconfig -o /boot/grub2/grub.cfg`## 3.5 系统优化### 1 selinux#### 1 概述* `Security-Enhanced Linux` * 它是一个 Linux 内核模块，也是 Linux 的一个安全子系统。 * Selinux 用于对 root 用户的权限进行控制#### 2 操作1. `getenforce` * 查看状态2. `setenforce 0` * 临时关闭3. `/etc/selinux/config` SELINUX=enforcingSELINUX=disabled # 永久关闭123456789101112### 2 关闭防火墙1. `systemctl stop firewalld`2. `systemctl disable firewalld`### 3 字符编码1. 修改环境变量 `LANG`（优先级高）2. 修改 `/etc/locale.conf`3. `localectl set-locale en_US.UTF-8`### 4 优化远程连接速度1. 修改ssh服务配置文件 `/etc/ssh/sshd_config` 79 GSSAPIAuthentication no116 UseDNS no12. 配置本地 hosts 文件 `/etc/hosts` 服务器ip 服务器主机名hostname 168.13.24 anyeansan``` 重启 ssh 服务 systemctl restart sshd 4 配置Shell命令提示符样式 PS11 设置格式 参数 说明 \\h hostname（short） \\H hostname（full） \\w current working directory \\W current working directory（basename） \\t 24小时格式显示时间 HH:MM:SS \\d 日期 weekday month date \\u 当前用户名 \\$ root 显示 # 普通用户显示 $ 2 颜色 \\[\\e[F;Bm\\]内容\\[\\e[0m\\] \\[\\e[F;Bm\\] 颜色开始 F 表示字体颜色，30~37 B 表示背景颜色，40~47 特殊显示 0 关闭颜色 1 高亮 4 下划线 5 闪烁 7 反白 8 颜色不可见 \\[\\e[0m\\] 颜色结束 3 式样 export PS1=&#39;\\[\\e[32;1m\\][\\u@\\h \\W]\\$ \\[\\e[0m\\]&#39; export PS1=&#39;\\[\\e[32;1m\\][\\u@\\h \\[\\e[34;1m\\]\\W\\[\\e[32;1m\\]]\\$ \\[\\e[0m\\]&#39; 四 远程连接4.1 远程连接软件 软件 说明 xShell 免费（实用） ScureCRT 收费 Putty 免费 功能简单 4.2 xShell 相关配置1 窗口外观 2 默认会话属性 3 使用密钥连接 将公钥上传至服务端 ~/.ssh/authorized_keys，权限 600 配置 xShell","categories":[{"name":"Linux","slug":"Linux","permalink":"https://anyeansan.github.io/categories/Linux/"}],"tags":[]},{"title":"Linux 命令","slug":"Linux-命令","date":"2020-03-29T02:04:35.000Z","updated":"2020-03-29T03:12:35.579Z","comments":true,"path":"2020/03/29/Linux-命令/","link":"","permalink":"https://anyeansan.github.io/2020/03/29/Linux-%E5%91%BD%E4%BB%A4/","excerpt":"","text":"一 帮助命令1.1 man（manual） man [OPTION] 命令 查看外部命令的功能 参数 帮助信息等等 OPTION 1 查看命令帮助文档 5 查看配置帮助文档，当命令和配置同名时，使用15来区分，如passwd 文档操作 说明 空格, f 向下翻页 b 向上翻页 回车 向下一行 k 向上一行 /key 向下查找key，n 下一个匹配，N 上一个匹配 ?key 向上查找key 1.2 –help 命令 --help 查看外部命令帮助 1.3 help help 命令 查看shell内置命令的帮助信息，如cd, pwd, history.. 二 开关机命令 命令 说明 shutdown 开启一个一分钟后关机的计划 shutdown -c 取消关机计划 shutdown -h Time 指定时间关机，Time 可以是 now 或具体时间 shutdown -r Time 指定时间重启 systemctl poweroff 关机 systemctl reboot 重启 三 其它命令3.1 echo（display a line of text） echo [OPTION] String 显示文本 OPTION -n 不换行输出 -e 支持转义字符\\b \\t \\r \\n \\e(escape键)... 3.2 xargs xargs [OPTION] &lt; input 将标准输入的所有行一行显示，xargs 会自动忽略别名 OPTION -n num 每一行显示原num行 3.3 column column -t 按表格显示 3.4 tr tr oldStr newStr 从标准输入中替换、缩减或删除字符，并将结果写到标准输出 tr 是一对一的替换 oldStr 字符数 &lt; newStr 字符数，多的新字符忽略，如 echo &quot;abc&quot;|tr &quot;abc&quot; &quot;12345&quot;，结果为 123 oldStr 字符数 &gt; newStr 字符数，多的旧字符都用最后一个新字符替换，如 echo &quot;abcde&quot;|tr &quot;abcde&quot; &quot;123&quot;，结果为 12333 如果 oldStr 中有重复字符则使用最后一个对应的新字符，如echo &quot;abcdba|tr &quot;abcdba&quot; &quot;123456&quot;，结果为 653456 3.5 tee tee [-a] File 读取标准输入的数据，并将其内容输出成文件 -a 追加` 3.6 read read [OPTION] 变量名 接收标准输入并赋值给变量 OPTION -p &quot;提示信息&quot; 在等待read输入时，输出提示信息 -t 秒数 read命令会一直等待用户输入，指定等待时间 -n 字符数 read命令只接受指定的字符数 -s 隐藏输入的数据，适用于机密信息的输入 3.7 cut cut [OPTION] [File] 按“列”提取文本字符 OPTION -f 列号 提取第几列 -d 分隔符 按照指定分隔符分割列 默认为制表符 3.8 sort sort [OPTION] [File] OPTION -f, --ignore-case 忽略大小写 -n, --numeric-sort 依照数值的大小排序 -r, --reverse 反向排序 -t, --field-separator=SEP 指定排序时所用的分隔符 -k n[,m] 按照指定的字段范围排序。从第n字段开始，m字段结束（默认到行尾） 3.9 history history [OPTION] [历史命令保存文件] OPTION -c 清空历史命令 -w 把缓存中的历史命令写入历史命令保存文件 默认用户正常退出后才会保存 默认保存在家目录下~/.bash_history 3.10 dd dd if=输入文件 of=输出文件 bs=块大小 count=块个数 按照指定大小和个数的数据块来复制文件或转换文件 if（input file） 指定输入文件或设备 如果不指定if，默认就会从 stdin 中读取输入 of（output file） 指定输出文件或设备 如果不指定of，默认就会将 stdout 作为默认输出 bs（block size） 数据块 block 大小，默认单位为 byte count 数据块 block 数量 四 文件 &amp; 目录命令4.1 pwd（print working directory） pwd 显示当前工作目录 4.2 cd（change directory） cd dir 切换目录 dir . 当前目录 .. 上级目录 ~ 根目录 - 前一个目录 4.3 mkdir（make directories） mkdir [OPTION] dir 创建一个或多个空目录，linux一切皆文件，目录也是文件，目录与文件不能重名 OPTION -p, --parents 递归创建 目录有多层时，如果父目录不存在，首先创建父目录 4.4 ls（list directory contents） ls [OPTION] [File] 显示文件名或者目录下的内容（默认为当前目录） OPTION -a, --all 显示目录下所有文件，包含隐藏文件（以 . 开头的文件） -A, --almost-all 同 -a 但不包含 . 和 .. -l 显示详细信息 -d, --directory 显示目录本身的信息（而非目录下的内容） -t 根据最后修改时间排序，newest first -r, --reverse 反向排序 -h, --human-readable 以人类可读的信息显示大小 -S 文件从大到小排序 -i, --inode 显示inode number p 区分文件和目录（目录名后添加 /） 4.5 tree（list contents of directories in a tree-like format） tree [OPTION] dir 树形显示目录，需要安装 tree 软件 OPTION -L level 指定显示层级，如-L 1 显示一层 -d 只显示目录 4.6 touch（change file timestamps） touch File 创建一个或多个空文件，如果文件存在则修改文件的最后访问时间和最后修改时间 File 可以使用区间 {begin..end} 如touch {1..10}.txt，即创建1.txt 2.txt ...10.txt10个文件 4.7 cp（copy files and directories） cp [OPTION] Source Destdir 复制一个或多个文件到指定目录 OPTION -r, --recursive 递归复制，用于复制目录 -p 复制时保留文件属性（所有者、权限信息、时间…） -d 复制时保留链接 -a 等同于 -dpr cp test.txt{,.bak} 例用 {} 的结合特性快捷复制，等价于 cp test.txt test.txt.bak 4.8 rm（remove empty directories） rm [OPTION] File 删除一个或多个文件 OPTION -r, --recursive 递归删除，用于删除目录 -f, --force 确认 4.9 mv（move (rename) files） mv Source Dest 如果不在同一个目录则是剪切 如果在同一个目录则是重命名 4.10 cat（concatenate files and print on the standard output） cat [OPTION] File 查看文件内容 OPTION -n, --number 显示行号 tac File 反向查看内容 4.11 more（file perusal filter for crt viewing） more File 分页显示内容，只能向下 4.12 less（opposite of more） less [OPTION] File 分页显示内容，可向上向下 OPTION -N, --LINE-NUMBERS 显示行号 指令 说明 f 下一页 b 上一页 回车 下一行 k 上一行 g 跳到第一行 G 跳到最后一行 p num% 跳到百分之num 4.13 head（output the first part of files） head [OPTION] File 默认显示前10行 OPTION -n 显示前 n 行 4.14 tail（output the last part of files） tail [OPTION] file 默认显示后10行 OPTION -n 显示后n行 -f, --follow 实时监控文件尾部变化，如查看日志 如果文件被删除或移动，没有信息提示，想要监控需要重新追踪 -F 实时监控文件尾部变化 如果文件被删除或移动，有信息提示，如果文件恢复会继续追踪 4.15 file（determine file type） file [OPTION] File 查看文件类型及编码 OPTION -i 查看文件MIME类型及编码 -L 查看软链接文件时，查看的是软链接指向的目标文件的信息 4.16 diff（compare files line by line） diff [OPTION] File 比较文件内容的差异 OPTION -q 仅输出文件是否有差异，不报告详细差异 4.17 stat stat File 查看文件 inode 信息 4.18 wc wc [OPTION] FILE | Input 统计行数、字数、字节数 OPTION -c 统计字节数 -w 统计单词数 -l 统计行数 4.19 rename rename expr replacement File 将替换文件中匹配部分 expr File 中需要重命名的部分 replacement expression 修改成的结果 五 时间命令5.1 date date [OPTION] [Format] 以默认格式查看时间 OPTION -s 修改时间 Format &quot;+%y-%m-%d %H:%M:%S&quot; Y-M-D H:M:S +%F full date 等价于 %Y-%m-%d +%T time 等价于 %H:%M:%S 5.2 ntpdate ntpdate ip 时间同步，需要安装 ntpdate 软件包 ip（ntp 服务器） ntp.aliyun.com cn.pool.ntp.org cn.ntp.org.cn time.asia.apple.com 六 打包压缩解压命令6.1 概述 Linux 中打包文件一般以 .tar 结尾，压缩命令一般以.gz结尾 通常打包和压缩是一起进行的，打包并压缩后的文件后缀一般为 .tar.gz 6.2 打包压缩 tar -zcvf 压缩包 文件 将一个或多个文件打包压缩 -z, --gzip 使用Gzip压缩，后缀名建议.tar.gz -c, --create 创建压缩包文件 -v, --verbose 显示过程 -f, --file= 指定压缩包文件路径 6.3 解压 tar -xvf 压缩包 [-C 解压路径] 默认解压到当前路径 x, --extract, --get 解压 6.4 查看压缩包中的文件 tar -tf 压缩包 -t, --list 七 搜索命令7.1 find（search for files in a directory hierarchy） find [路径] [条件] [操作] 在指定路径根据条件查找文件，并对找到的文件执行指定操作 路径 find 命令查找路径，默认为当前目录 条件 查找的条件，可以有多个 -a 多个条件 逻辑与 关系，默认 -o 逻辑或 -not 逻辑非 操作 -print 打印找到的结果，默认 -exec 命令 {} \\; 对匹配的结果逐个执行命令 {} 代表查到的内容 \\; 匹配的文件可能有多个，即要执行多次命令，用分号隔开 条件 说明 -name Pattern 根据文件名查找（精准匹配，可以用正则） -iname Pattern 根据文件名查找，不区分大小写 -perm Mode 根据文件权限查找 -user User 根据文件属主查找 -group Group 根据文件属组查找 -type Type 根据文件类型查找 -size n/+n/-n 根据文件大小查找 -atime/ctime/mtime n/-n/+n 根据文件时间查找 -inum Num 根据文件 inode 号查找 -maxdepth level 指定目录查找层次深度 7.2 locate（find files by name）1 概述 此命令需要安装 mlocate 软件包 建立文件索引数据库，快速查找文件位置 /var/lib/mlocate/mlocate.db 维护的数据库（文件资料库） /tmp 不在数据库范围 2 使用 updatedb 更新数据库（建立文件和目录结构的对应关系） 如果没有更新过或者是新建立的文件，文件资料库没有，使用locate查找不到 locate File 查找文件绝对路径 7.3 which（shows the full path of (shell) commands） which Command 查看命令文件的绝对路径及别名信息 查找的范围是 PATH 所配置的路径 7.4 whereis（locate the binary, source, and manual page files for a command） whereis Command 查看命令文件的绝对路径及相关帮助文档绝对路径 八 磁盘命令8.1 df（report file system disk space usage） df [OPTION] [File] 查看文件系统的磁盘空间使用信息及挂载信息 OPTION -a, --all 显示所有文件系统信息，包括系统特有的 /proc、/sysfs 等文件系统 -h, --human-readable 使用人们习惯的 KB、MB 或 GB 等单位自行显示容量 -k 以 KB 为单位显示容量（默认） -m 以 MB 为单位显示容量 -T, --print-type 显示文件系统类型 -i, --inodes 不用硬盘容量显示，而是以含有 inode 的数量来显示 8.2 du（disk usage） du [OPTION] [File] 统计目录或文件所占磁盘空间大小 如果是目录，默认显示目录和子目录的磁盘占用量 OPTION -a, --all 显示目录、子目录和子文件的磁盘占用量 -s, --summarize 只统计总磁盘占用量，而不列出子目录和子文件的磁盘占用量 即只显示目录的磁盘占用量 -h, --human-readable 以人类可读的单位显示磁盘占用量 注 ls -l 命令统计的是目录下的子文件名称和子目录名称所占大小 du 命令统计占用磁盘空间 文件大小 文件的实际大小，比如 13KB 文件占用磁盘空间 文件占用磁盘空间取决于文件系统的 block 大小（linux 默认为 4 KB） 1 个block 只能被 1 个文件占用，如果 1 个 block 没有占满，其它空间也不能存储其它文件 1 个文件大小是 13 KB，13 / 4 = 3.25，文件占用磁盘空间就是 4 个block 即 16 KB 九 网络命令9.1 curl 命令 说明 crul url 访问一个网址，获取该网址的文本信息 curl -i url 获取该网址的文本信息以及协议头部信息 curl -I url 只获取请求头 curl -O url 下载指定资源到当前目录，名称默认，--progress 显示进度 curl -o name url 下载指定资源到当前目录，名称name， 9.2 wget 命令 说明 wget url 下载文件 wget -O name url 下载文件并指定名称为name 9.3 net-tools &amp; iproute2 1 netstat 命令 说明 netstat -lntup 查看本机监听的端口 netstat -an 查看本机所有的网络连接 netstat -rn 查看本机路由表 2 route1 查 route [-nee] 查看路由表信息 -n 不使用名字而使用IP和Port -ee 更详细的信息 2 增删默认路由 route add/del default gw 网关 route add/del default dev 接口 3 增删网络路由 route add/del -net 目标网络地址 netmask 子网掩码 gw 网关 route add/del -net 目标网络地址 netmask 子网掩码 dev 接口 4 增删主机路由 route add/del -host 目标主机地址 netmask 子网掩码 gw 网关 route add/del -host 目标主机地址 netmask 子网掩码 dev 接口 3 ip 命令 说明 ip addr show [eth0] 显示网卡及配置的地址信息 ip addr add/del IP/子网掩码 dev 网卡接口 临时添加删除IP ip link set eth0 up/down 启用/禁用网卡 ip route show 查看策略路由，路由表 /etc/iproute2/rt_tables ip route get IP 通过IP地址查询路由包从哪条路由来 ip route add/del default via 网关 增删默认路由 ip route add/del -net 目标网络地址 netmask 子网掩码 via 网关 增删网络路由 ip route add/del -host 目标主机地址 netmask 子网掩码 via 网关 增删主机路由 ip -s link 显示所有网络接口的统计数据 ip -s -s link ls 网卡接口 获取一个特定网络接口的信息 4 ss ss -lntup 查看本机监听的端口 十 三剑客10.1 grep（print lines matching a pattern） grep [OPTION] Pattern [File] 打印匹配行 OPTION 说明 -v, --invert-match 反向选择，即仅列出不匹配的行 -i, --ignore-case 忽略大小写 -n, --line-number 显示在原文件中的行号 -w, --word-regexp 单词必须完全匹配 -c, --count 统计匹配的行数 -o, --only-matching 只输出匹配内容，而非行 -E, --extended-regexp 扩展的grep，等同于 egrep -A num, --after-context=num 显示匹配行及其之后的 num 行 -B num, --before-context=num 显示匹配行及其之前的 num 行 -C num, num, --context=num 显示匹配行及其前后 num 行 10.2 sed（stream editor for filtering and transforming text）1 概述 sed 是一种几乎包括在所有 UNIX 平台的轻量级流编辑器。 sed主要是用来对文本数据增、删、改、查。（以行为单位） 2 原理 Sed默认并不直接修改源文件，而是将一行内容读取到内存中（模式空间 pattern space），然后判断内容是否符合条件，如果不符合则读取下一行，如果符合则执行相应指令。 所有的指令操作执行后，模式空间的内容默认输出至标准输出(即屏幕上) 3 语法 sed [OPTION] [address] command [File] OPTION -n sed 默认会完整输出所有内容 -n 表示只输出经过sed命令处理的行 -e script 允许多个脚本指令被执行 -e script1 -e script2 script1;scrpt2 -f script-file 从文件中读取脚本指令 -r 识别扩展正则表达式 -i[suffix] 慎用，直接修改源文件（将内存中的信息覆盖到磁盘） 注意：i 和 n 一起使用相当于清空，因为 n 不输出内容 suffix 代表为原文件生成一个指定后缀的备份文件 address （默认为全文） -number 指定行号number $ 表示最后一行 -first~step 指定以first开始，步长为step addr1,addr2 匹配从addr1到addr2的所有行 addr1,+N 匹配地址1以及后面的N行 /regexp/ 正则 command p 打印 a 在当前行下一行添加，可以使用 \\n 来添加多行 i 在当前行上一行添加，可以使用 \\n 来添加多行 d 删除指定行 c 替换指定行 s 替换字符串 s/pattern/replacement/flags replacment &amp; 代表正则所匹配的内容 \\num 引用num组 flags g 对一行中所有匹配替换（默认只替换第一个匹配） n 1~512的数字，表示对一行中第n个匹配替换 p 打印模式空间的内容 -w file 将模式空间的内容写到文件file中 10.3 awk（pattern scanning and processing language）1 概述 /usr/bin/awk -&gt; /usr/bin/gawk g 代表GNU组织 awk 不仅仅是强大的文本分析工具，还是一种编程语言 awk 主要用来分析文本（以行为单位） 2 原理 若有 BEGIN 代码块，则执行一次 awk读取一行内容，判断是否符合条件，若符合则使用相应动作进行处理，否则读取下一行。 若有 END 代码块，则执行一次 3 语法 awk [OPTION] BEGIN{} [patten] {action} END{} [file] OPTION -F 指定字段（列）分隔符（默认为空格） 指定分隔符时有加号 + 表示有连续多个分隔符只算一个 -F &quot;[分隔符列表]+&quot; 使用多个分隔符 BEGIN{} 初始化代码块，只在处理数据前执行一次，可以用来修改内置变量等等 END{} 结尾代码块，只在处理数据后执行一次 1 运算符 运算符 说明 ? 条件表达操作符 &#124;&#124; && ! 逻辑或 与 非 ~ 匹配，非精确比较（== 是精确比较） !~ 不匹配，非精确比较 + - * / % ++ -- 算术运算符 = += -= *= /= %= 赋值运算符 &lt; &lt;= &gt; &gt;= == != 比较运算符 2 内置变量 变量 说明 FS 字段分隔符，默认为空格 NF 当前行字段个数，即有多少列，$NF 表示最后一列 NR 已经读取的记录数，即当前行是第几行，从1开始 FNR 记录总数 FILENAME 当前文件名 OFS 输出字段分隔符， 默认是空格 ORS 输出的记录分隔符，默认是换行符 RS 控制记录分隔符，默认为换行符 ARGC 命令行参数个数 ARGV 命令行参数排列 $0 表示整行 $n n&gt;0 代表第n列 自定义变量 awk &#39;name=&quot;zsan&quot;{print name}&#39; file 3 内置函数 函数 说明 gsub(r,s) 在整个$0中用s替代r gsub(r,s,t) 在整个t中用s替代r index(s,t) 返回s中字符串t的第一位置 length(s) 返回s长度 match(s,r) 测试s是否包含匹配r的字符串 split(s,a,fs) 在fs上将s分成序列a sprint(fmt,exp) 返回经fmt格式化后的exp sub(r,s) 用$0中最左边最长的子串代替s substr(s,p) 返回字符串s中从p开始的后缀部分 substr(s,p,n) 返回字符串s中从p开始长度为n的后缀部分 4 print &amp; printf printf 是标准格式输出命令，不会自动换行 print 会自动添加换行符（linux 默认没有print） printf printf &#39;输出类型输出格式&#39; 输出内容 输出类型 %ns 输出字符串。n是数字指输出几个字符 %ni 输出整数。n是数字指输出几个数字 %m.nf 输出浮点数。m和n是数字，指输出总位数(m)和小数位数(n) 输出格式 \\r \\n \\t 水平tab \\v 垂直tab \\b 退格Backspaced \\f 清屏 \\a 输出警告声音 输出内容 $() 使用命令获取内容 不能直接用文件，管道符也不行 print print 输出内容 输出内容如果用逗号隔开则代表显示结果使用空格隔开1234print &apos;a b&apos; # abprint &apos;a,b&apos; # a bprint &apos;a&quot;,&quot;b&apos; # a,bprint &apos;a123b&apos; # a123b","categories":[{"name":"Linux","slug":"Linux","permalink":"https://anyeansan.github.io/categories/Linux/"}],"tags":[]},{"title":"Hexo","slug":"Hexo","date":"2019-11-12T06:41:59.000Z","updated":"2020-03-29T03:34:58.543Z","comments":true,"path":"2019/11/12/Hexo/","link":"","permalink":"https://anyeansan.github.io/2019/11/12/Hexo/","excerpt":"","text":"一 搭建1.1 GitHub 注册账号 创建仓库，名为yourname.github.io 1.2 Git 安装git及gitbash 配置github账号及ssh key 1.3 NodeJs1.4 Hexo1 安装 npm install -g hexo 2 初始化 hexo init12345678node_modules：依赖包public：存放生成的页面scaffolds：命令生成文章等的模板source：用命令创建的各种文章（post下为原始md文件）themes：主题_config.yml：整个博客的配置db.json：source解析所得到的package.json：项目所需模块项目的配置信息 3 root config.yml配置deploy1234deploy: type: git repository: git@github.com:anyeansan/anyeansan.github.io.git branch: master 二 命令2.1 hexo n hexo n xxx 在source/post目录下根据scaffolds/post.md模板创建xxx.md hexo n page xxx 在source目录下根据scaffolds/page.md模板创建xxx文件夹并生成index.md 2.2 hexo clean 删除根下public目录 2.3 hexo g 在根下创建public目录并生成静态文件 source目录下的所有文件都会原样复制（除了md文件会转成html）到public目录 2.4 hexo d 部署到服务端 ERROR Deployer not found: git 需要安装npm install hexo-deployer-git --save 2.5 hexo s 启动服务 http://localhost:4000 三 配置3.1 root _config.yml123456789101112131415161718192021222324# Sitetitle: 安₃subtitle: 我未成名君未嫁 可能俱是不如人description: 一蓑烟雨任平生keywords:author: 安₃language: zh-CNtimezone:# Directoryskip_render: README.md# URLurl: https://anyeansan.github.ioroot: /anyeansan.github.io# Extensionstheme: next# Deploymentdeploy: type: git repository: git@github.com:anyeansan/anyeansan.github.io.git branch: master 3.2 本地搜索local-search npm install hexo-generator-searchdb root _config.yml12345search: path: search.xml field: post content: true format: html _config.yml12local_search: enable: true 3.3 RSS npm install hexo-generator-feed --save root _config.yml1234feed: type: atom path: atom.xml limit: 20 _config.yml1rss: /atom.xml 3.4 目录编号 _config.yml12toc: number: true/false 3.5 文章底部标签和结束语1 底部标签 next/layout/_macro/post.swig中搜索rel=&quot;tag去掉标签或修改标签样式1rel=&quot;tag&quot;&gt; &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125; 2 结束语 next/layout/_macro添加passage-end-tag.swig，内容如下12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #66ccff;font-size:14px;&quot;&gt;-------------The End&amp;nbsp;&amp;nbsp;&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;客官请自便-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div next/layout/_macro/post.swig在post-body和post-footer之间添加12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 3.6 中英文 next/languages/zh-CN.yml酌情修改 3.7 图片1 Logo _config.yml1favicon: 2 头像 _config.yml1234avatar: url: /images/lbb.png 头像 rounded: true 是否为圆形 rotated: true 是否鼠标放上去旋转 3.8 页面底部 _config.yml12345678footer: since: 2019 icon: copyright: powered: theme: beian: creative_commons: 3.9 menu &amp; sidebar _config.yml12menu:sidebar: 四 技巧4.1 博文不显示全部内容 在合适的位置加上&lt;!--more--&gt;即可 4.2 创建tags和categories hexo n page tages source/tages/index.md123title: tagsdate: 2019-11-12 12:46:04type: &quot;tags&quot; 文章中使用 tags为多个标签123456tags:-空格one-空格two-空格three-空格...结果为：#one #two #three #... categorys为层级123456categorys:-空格爷-空格父-空格孙-空格...结果为：爷 &gt; 父 &gt; 孙 &gt;... 4.3 绑定域名1 购买域名 namesilo 2 设置dns dns默认有四个A A A CNAME，只需要两个即可 1 A + A 类型 HOSTNAME ADDRESS TTL A 空 ip 3600 A www ip 3600 * ip通过ping yourname.github.io获取 2 A + CNAME 类型 HOSTNAME ADDRESS TTL A 空 ip 3600 CNAME www yourname.github.io 3600 * 创建CNAME * 在source目录创建CNAME文件，内容为你的域名 3 配置仓库 在yourname.github.io仓库的setting中配置域名 GitHub Pages -&gt; Custom domain 不确定是否必须0.0 4.4 README.md1 原因 hexo g会把source目录下的md文件(包括Readme.md)渲染为html文件并放到public目录下 hexo d会把public目录下所有文件提交到yourname.github.io仓库 由于public目录下并没有README.md而只有Readme.html，所以deploy后yourname.github.io是没有Readme.md的 2 解决 source目录下创建README.md root_config.yml skip_render: README.md 4.5 首页不显示全文 _config.yml123auto_excerpt: enable: false # true 表示根据length显示，false表示显示全文 length: 150 # 预览长度 4.6 文章排序 basedir/node_modules/hexo-generator-index/lib/generator.js123456789101112131415posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章都有top，top大的在前 if(a.top == b.top) return b.date - a.date; // 若top值一样，最新的文章在前面 else return b.top - a.top; // top大的在前面 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面 return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; //都没有top标签，最新的文章在前面&#125;);","categories":[{"name":"技","slug":"技","permalink":"https://anyeansan.github.io/categories/%E6%8A%80/"},{"name":"hexo","slug":"技/hexo","permalink":"https://anyeansan.github.io/categories/%E6%8A%80/hexo/"}],"tags":[]}]}