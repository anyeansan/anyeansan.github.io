{"meta":{"title":"安₃","subtitle":"我未成名君未嫁 可能俱是不如人","description":"一蓑烟雨任平生","author":"安₃","url":"https://anyeansan.github.io","root":"/anyeansan.github.io/"},"pages":[{"title":"categories","date":"2019-11-12T04:47:40.000Z","updated":"2019-11-12T04:48:21.027Z","comments":true,"path":"categories/index.html","permalink":"https://anyeansan.github.io/categories/","excerpt":"","text":""},{"title":"tags","date":"2019-11-12T04:46:04.000Z","updated":"2019-11-12T04:47:01.286Z","comments":true,"path":"tags/index.html","permalink":"https://anyeansan.github.io/tags/","excerpt":"","text":""}],"posts":[{"title":"Mysql备份","slug":"SQL/Mysql备份","date":"2020-11-08T13:14:49.000Z","updated":"2020-11-08T13:15:48.422Z","comments":true,"path":"2020/11/08/SQL/Mysql备份/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/SQL/Mysql%E5%A4%87%E4%BB%BD/","excerpt":"","text":"一 备份策略1.1备份策略 全量备份 完整备份所有数据 增量备份 做一次完全备份，以后每次只备份新增的数据 差异备份 做一次完全备份，以后每次只备份和第一次完全备份不同的数据 1.2 备份周期 根据数据量 自动 1.3 备份类型 热备 在数据库正常业务时,备份数据,并且能够一致性恢复（只能是innodb） 温备 锁表备份,只能查询不能修改（myisam） 冷备 关闭数据库业务,数据库没有任何变更的情况下,进行备份数据. 1.4 备份工具 mysqldump Xtrabackup percona 数据库默认 mysqlbinlog 1.5 备份方式 逻辑（基于 SQL 语句备份） 全备：mysqldump 增量：mysqlbinlog 物理（基于磁盘数据文件备份） 全备：Xtrabackup 增量：Xtrabackup 二 mysqldump2.1 连接数据库 mysqldupm OPTION OPTION -u -p -S -h -P 2.2 基础参数 -A 全备 -B db1 db2 ... 备份多个数据库 db t1 t2 ... 备份指定数据的表 2.3 特殊参数 -R 备份备份存储过程及函数 -E 备份事件 --triggers 备份触发器 -F 在备份开始时,刷新一个新 binlog 日志 --master-data=2 以注释的形式，保存备份开始时间点的 binlog 的状态信息 --single-transaction 不加 ，温备份，所有表都锁定 加上，对 innodb 表进行快照备份（不锁表），对非 innodb 表可以实现自动锁表功能 --set-gtid-purged=auto/on/off --max-allowed-packet=#","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"SQL","slug":"CS/SQL","permalink":"https://anyeansan.github.io/categories/CS/SQL/"}],"tags":[]},{"title":"Mysql日志","slug":"SQL/Mysql日志","date":"2020-11-08T13:14:44.000Z","updated":"2020-11-08T13:16:15.051Z","comments":true,"path":"2020/11/08/SQL/Mysql日志/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/SQL/Mysql%E6%97%A5%E5%BF%97/","excerpt":"","text":"一 日志分类 类型 说明 Error log 错误日志 Binary log 二进制日志 Slow query log 慢查询日志 General query log 常规日志 二 错误日志 默认开启 默认存储位置 datadir/hostname.err select @@log_error 查看错误日志位置 手动配置 /etc/my.cnf 12[mysqld]log_error=路径 三 二进制日志3.1 作用 主从环境必须依赖二进制日志 备份恢复必须依赖二进制日志 3.2 配置 默认没有开启 手动配置 /etc/my.cnf 12345678910111213[mysqld]1 server_id= # 服务ID号 0 ~ 655352 log_bin=1 # 开启二进制日志3 log_bin_basename=/目录/二进制日志文件名前缀 # 设置存储目录及文件前缀4 log_bin=/目录/二进制日志文件名前缀 # 等同于 2,3两步5 binlog_format=row # 二进制日志格式，5.7 默认配置，可以省略6 sync_binlog=1 # 每次提交都立即刷写binlog到磁盘 3.3 二进制日志记录内容1 内容 记录了数据库所有变更类的操作日志 DDL：原封不动的记录当前 DDL（statement 语句方式），即原样记录语句 DCL：原封不动的记录当前 DCL（statement 语句方式） DML：只记录已经提交的事务 DML 2 DML 记录模式 statment SBR（statement based replication）模式 语句模式，原封不动的记录当前DML 可读性较高，日志量少，但是不够严谨 row RBR（ROW based replication）模式 记录数据行的变化（用户看不懂，需要工具分析） 可读性很低，日志量大，足够严谨 mixed MBR（mixed based replication）模式 以上两种模式的混合 3.4 二进制日记记录单元 event1 概述 event 是二进制日志的最小记录单元 DDL DCL 一个语句就是一个 event DML ：只记录已提交的事务 begin 是一个 event DML 语句的 event commit 是一个 event 2 event 组成 事件的开始标识：position 号 事件内容 事件的结束标识：end_log_position 号 3.5 二进制日志 操作1 查看信息 show variables like &#39;%log_bin%&#39; 查看二进制日志路径 show binary logs 查看所有二进制日志 show master status 查看当前使用的二进制日志 show binlog events in &#39;log_name&#39; [from pos] [limit] 查看二进制日志 event 信息 2 查看内容 mysqlbinlog mysqlbinlog [OPTION] 日志路径 --base64-output=decode-rows 以指定格式输出 -vvv 更详细 --start-position 开始位置 --stop-position 结束位置 -d db_name 只查看指定库的日志 3 恢复 mysqlbinlog --start-position= --stop--position= &gt;/tmp/log.sql 将指定位置的二进制日志内容截取出来输出到一个文件，其实就是sql脚本，执行即可 set sql_log_bin=0 临时关闭二进制日志，因为恢复时也会产生二进制日志，没有必要 source /tmp/log.sql set sql_log_bin=1 3.6 GTID 模式管理二进制日志1 概述 GTID Global Transaction ID 对二进制日志中每一个事务，自动生成一个 GTID 号 DDL DCL 一个 event 就是一个事务，就有一个 GTID DML 一个事务（从 begin 到 commit）一个 GTID GTID 幂等性 使用有 GTID 的二进制日志做恢复时，会检查当前系统是否有相同的 GTID，若有则跳过不再执行。 会影响恢复和主从复制 2 配置 默认未开启 /etc/my.cnf 123[mysqld]gtid-mode=onenforce-gtid-consistency=true 3 GTID 组成 server_uuid:transaction_id server_uuid 启动 mysql 自动生成，存储在 datadir/auto.cnf transaction_id 从 1 开始，自增长 4 查看有 GTID 的日志内容 mysqlbinlog [OPTION] 日志路径 OPTION --incude-gtids 包含指定 gtid，多个逗号隔开，连续可以 server_uuid:1-8 --exclude-gtids 排除指定 gtid --skip-gtids 由于 gtid 的幂等性，导出的 sql 执行时会报错，因为已经存在相同 gtid 此选项表示：导出时，忽略原有的 GTID 信息，恢复时当作新事务对待 5 基于 GTID 的恢复 mysqlbinlog --skip-gtids --include-gtids= 日志路径&gt;/tmp/log.sql set sql_log_bin=0 source /tmp/log.sql set sql_log_bin=1 3.7 二进制日志清理1 自动清理 expire_logs_days 二进制日志过期天数，0 表示永不过期 建议至少保留两个全备周期 +1 2 手动清理 purge binary logs to &#39;log_name&#39; 删除指定日志之前的日志 purge binary logs before &#39;time&#39; 删除指定日期之前的日志 3.8 日志滚动 flush logs 重启 mysql 会自动滚动一个新的 日志文件达到 max_binlog_size 四 慢查询日志4.1 概述 记录运行较慢的 SQL语句，优化常用 4.2 配置 默认未开启 /etc/my.cnf 123456789[mysqld]1 slow_query_log=1 # 开启 2 slow_query_log_file=/目录/文件 # 日志文件路径3 long_query_time=0.1 # 设置慢查询时间，超过此时间就算慢，默认 10.000000 10秒，小数位表示粒度4 log_queries_not_using_indexes # 没走索引的语句也记录 4.3 分析 mysqldumpslow -s c -t N 日志路径 -s c sort，按次数排序 -t N top，取前多少个 4.4 相关参数 slow_query_log long_query_time log_throttle_queries_not_using_indexes","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"SQL","slug":"CS/SQL","permalink":"https://anyeansan.github.io/categories/CS/SQL/"}],"tags":[]},{"title":"Mysql触发器","slug":"SQL/Mysql触发器","date":"2020-11-08T13:14:39.000Z","updated":"2020-11-08T13:15:53.128Z","comments":true,"path":"2020/11/08/SQL/Mysql触发器/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/SQL/Mysql%E8%A7%A6%E5%8F%91%E5%99%A8/","excerpt":"","text":"一 概述 事先为某张表绑定好一段代码 ,当表中的某些内容发生改变的时候（增删改）系统会自动触发代码执行 事件类型 增 insert 删 delete 改 update 触发时间 前 before 后 after 一张表最多能有 6 种触发器（事件类型 + 触发事件） 增 前/后 删 前/后 改 前/后 触发对象 表中的每一条记录（行） new/old 可以用来获取新添加的或者删除的记录 二 创建触发器123456789101112-- 1 临时修改语句结束符Delimiter 自定义符号-- 2 Create trigger 触发器名字 触发时间 事件类型 on 表名 for each row-- 3 Begin 触发器的内容End -- 4 语句结束符自定义符号-- 5 将临时修改修正过来Delimiter ; 三 触发器管理 命令 说明 show triggers 查看所有触发器 show create trigger 触发器名 查看触发器创建语句 drop trigger 触发器名 删除触发器 Information_schema.triggers 所有的触发器信息都保存此表中","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"SQL","slug":"CS/SQL","permalink":"https://anyeansan.github.io/categories/CS/SQL/"}],"tags":[]},{"title":"Mysql存储过程","slug":"SQL/Mysql存储过程","date":"2020-11-08T13:14:34.000Z","updated":"2020-11-08T13:15:59.443Z","comments":true,"path":"2020/11/08/SQL/Mysql存储过程/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/SQL/Mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/","excerpt":"","text":"一 Procedure概述 存储过程是一组为了完成特定功能的 sql 语句和流程控制语句的预编译集合，存储在数据库内，可以由应用程序调用。 存储过程的好处 可复用 预编译：只在创建时编译一次，以后调用时不再编译，速度快 减少网络流量：存储过程存储在数据库服务器上，都在数据库服务器上运行，调用存储过程时只需要传递名称和参数即可。 安全：可防止sql注入 二 存储过程和自定义函数的区别 存储过程实现的功能更复杂，函数的针对性更强 存储过程可以返回多个值，函数只能返回一个值 存储过程一般单独执行，函数可以作为其它sql语句的组成部分。 三 语法12345678CREATE [DEFINER = user] PROCEDURE sp_name ([proc_parameter[,...]]) [characteristic ...] routine_bodyproc_parameter: [ IN | OUT | INOUT ] param_name type 四 创建123456789DROP PROCEDURE IF EXISTS 存储过程名;-- 1 修改结束符，自定义，如$$DELIMITER [结束标记]CREATE PROCEDURE 存储过程名([参数列表])BEGIN [存储过程体(一组合法的SQL语句)]END [结束标记]-- 2 将结束符改回分号DELIMITER ; 形参：参数名 参数类型 in 输入参数，调用存储过程时传入的值 可以省略 out 输出参数，可在存储过程内部被改变并返回。 into：使用 into 为out参数赋值 inout 输入输出参数，调用存储过程时传入值，在存储过程内部可以改变并返回。 返回值 存储过程可以有返回值也可以没有返回值。 五 管理 命令 说明 show procedure status 查看所有存储过程 show create procedure 存储过程名 查看存储过程创建语句 drop procedoure [if exists] 存储过程名 删除存储过程 六 调用 call 存储过程名(in参数, @out参数, @inout参数) 存储过程没有返回值（通过out返回），不能用select调用。 实参 in参数：直接传递即可 out参数：定义一个变量接收返回值@变量名 inout参数：在外部定义一个变量，并设置值 123456789// incall inpr(3);// outcall outpr(@name);select @name;// inoutset @age = 10;call inoutpr(@age);select @age;","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"SQL","slug":"CS/SQL","permalink":"https://anyeansan.github.io/categories/CS/SQL/"}],"tags":[]},{"title":"Mysql视图","slug":"SQL/Mysql视图","date":"2020-11-08T13:14:28.000Z","updated":"2020-11-08T13:16:25.952Z","comments":true,"path":"2020/11/08/SQL/Mysql视图/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/SQL/Mysql%E8%A7%86%E5%9B%BE/","excerpt":"","text":"一 View 概述 view可以看作是一张虚拟表，是表通过某种运算得到的一个投影。 视图中并没有真正存储数据。 表的改变会影响视图(视图就好像表的影子一样) 视图的改变也能影响表。(如果可以改变的话) 可以跟基本表一样，进行增删改查操作 二 数据操作 主要是用来查询 增删改操作有条件限制 如果视图的数据与表的数据是一一对应出来的，改变不会影响其它数据，就可以增删改。 如果视图的数据是通过计算得来的，改变则会影响表中的其它数据，不可以增删改。 可更新视图：没有以下语句 distinct 聚合函数 group by / having union with check option 在视图的 select 语句后添加可以防止更新或删除已有的视图数据 三 视图作用 方便操作，特别是查询操作，减少复杂的SQL语句 将一条复杂的查询语句使用视图进行保存: 以后可以直接对视图进行操作 数据安全 视图操作是主要针对查询的, 如果对视图结构进行处理(删除), 不会影响基表数据(相对安全). 可以对外提供有用的数据, 但是隐藏关键(无用)的数据 数据库授权命令不能限定到特定行和特定列，但是通过合理创建视图，可以把权限限定到行列级别 权限控制 不希望用户访问表中某些含敏感信息的列,可以通过view开放某几个列 数据过多时，分表用 四 视图管理 命令 说明 create [or replace] view 视图名 as select语句 创建视图 show create view 视图名 查看视图 desc 视图名 drop view 视图名 删除视图 alter view 视图名 as 新的select语句 视图本身不可修改，但视图来源可以修改 视图是一张虚拟表，表的所有查看方式，视图都能用，且视图比表多一个关键字 view","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"SQL","slug":"CS/SQL","permalink":"https://anyeansan.github.io/categories/CS/SQL/"}],"tags":[]},{"title":"Mysql索引","slug":"SQL/Mysql索引","date":"2020-11-08T13:14:23.000Z","updated":"2020-11-08T13:16:30.696Z","comments":true,"path":"2020/11/08/SQL/Mysql索引/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/SQL/Mysql%E7%B4%A2%E5%BC%95/","excerpt":"","text":"一 概述 系统根据某种算法，将已有的数据（或未来可能新增的数据）单独建立一个文件，此文件能够实现快速的匹配数据，并且能够快速的找到对应表中的记录 几乎所有的索引都是建立在字段之上 索引本身会产生索引文件(有时候有可能比数据文件还大)，会占用磁盘空间. 索引类似书或字典前边的目录，提升查询速度，但是增删改时，索引也要动态的维护，降低了效率。 索引是在存储引擎中实现的，也就是说不同的存储引擎，会使用不同算法的索引 B-tree FullText Hash GIS R-tree 二 作用 优化查询 如果某个字段需要作为查询的条件经常使用，那么可以使用索引 约束数据的有效性 如果某个字段需要进行数据的有效性约束, 也可能使用索引（主键,唯一键 …） 三 索引分类 普通索引 MUL 单列索引 多列索引（联合索引） 前缀索引（建索引时，可以只索引列的一部分内容） 唯一索引 UNI 主键索引 PRI（也叫聚合索引，MySql 会自动将主键索引添加到所有从属索引中） 全文索引 四 索引管理4.1 查 命令 说明 desc 表名 通过表结构可以查看索引 show index in/from 表名 查看索引详细信息 4.2 增 命令 说明 alter table 表名 add index 索引名(字段列表) 添加普通索引 create index 索引名 on 表名(字段列表) 添加普通索引 alter table 表名 add unique index 索引名(字段列表) 添加唯一索引 create unique index 索引名 on 表名(字段列表) 添加唯一索引 alter table 表名 add primary key(字段列表) 添加主键索引 4.3 删 命令 说明 alter table 表名 drop index 索引名 删除索引 drop index 索引名 on 表名 删除索引 五 执行计划5.1 概述 SQL 层解析器会生成多个执行计划，优化器会选择最优的执行计划 执行计划分析 就是在执行前获取这个最优执行计划，查看其计划信息，可以有效的防止性能较差的语句带来的性能问题 5.2 获取执行计划 desc sql语句 explain sql语句 5.3 执行计划分析 table 查询所操作的表 type 全表扫描：all 不走索引 没有查询条件，或者查询条件列无索引 查询结构集是原表中的大部分数据，一般25%以上 ! not 普通索引列 like %xxx 联合索引有时只走部分索引 索引扫描（性能依次变好） index 全索引扫描 无条件查询索引列 select id from t range 索引范围扫描 &gt; &gt;= &lt; &lt;= between and or in() like xxx% ! not 主键索引或唯一索引列 ref 普通索引列的等值查询 eq_ref 在多表连接时，子表（被连接表）使用主键列或者唯一列作为连接条件 consist(system) 主键索引或唯一索引列的等值查询 null possible_key 可能会用到的索引 key 真正使用的索引 key_len 索引最大预留长度 extra using filesort 说明查询中有关排序的条件列没有合理的应用索引，因为索引本身已经是有序的 rows 扫描行数 六 联合索引6.1 联合索引说明 优化器会自动对查询条件按照索引创建时的顺序排序 最终使用的索引列是排序后连续的等值比较查询 也就是说碰到不连续的或者非等值比较查询（&gt; &gt;= &lt; &lt;= like …）就会停止 例：创建联合索引 inx_haha(a,b,c,d) 查询条件是 b= c= a= d=，排序后 a= b= c= d=，最终使用的索引列 abcd 查询条件是 b= a= d=，排序后 a= b= d=，最终使用的索引列 ab 查询条件是 c= a= d=，排序后 a= c= d=，最终使用的索引列 a 查询条件是 b&gt; a= c= d=，排序后 a= b&gt; c= d=，最终使用的索引列 ab 6.2 联合索引优化 创建联合索引时唯一键多的列放在最左侧 创建联合索引时等值比较的列放在最左侧 如果查询中出现多种子句（where group by …），要按照子句的执行顺序建立索引 七 索引应用规范 建表必须有主键，一般是个无关列，自增值 经常需要where 、ORDER BY、GROUP BY,join on等操作的列建立索引， 值长度较长的列，建议使用前缀索引 索引不是越多越好，不要创建无用索引，不常使用的索引要清理 索引维护避开业务繁忙期 小表不建索引 联合索引优化","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"SQL","slug":"CS/SQL","permalink":"https://anyeansan.github.io/categories/CS/SQL/"}],"tags":[]},{"title":"Mysql事务","slug":"SQL/Mysql事务","date":"2020-11-08T13:14:18.000Z","updated":"2020-11-08T13:16:21.003Z","comments":true,"path":"2020/11/08/SQL/Mysql事务/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/SQL/Mysql%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"一 ACID 特性 特性 名称 说明 Atomicity 原子性 一个事务是一个不可分割的单元，事务中的操作要么都成功，要么都取消 Consistency 一致性 事务的执行不能破坏数据库数据的完整性和一致性 Isolation 隔离性 事务之间是互不干扰的 Durability 持久性 一个事务一旦被提交，它对数据库中数据的改变就是永久性的 二 事务的生命周期2.1 标准生命周期 阶段 说明 begin &#124; start transction &#124; set autocommit=0 开启事务 DML（insert update delete） 数据操作 commit &#124; rollback 结束事务 注意：开启事务后，在事务中执行一些语句会触发隐式提交（应避免） DDL（alte create drop truncate） DCL（grant revoke set password） 锁（lock tables unlock tables） … 2.2 自动提交（atutocommit） 默认 atutocommit = 1 即开启自动提交，执行 DML 时会自动开启事务并提交 关闭自动提交 set autocommit = 0 会话级别 set global autocommit = 0 全局级别，影响所有会话，重启失效 vim /etc/my.cnf 中添加 autocommit=0 永久生效 三 隔离级别3.1 概述 对于同时运行的多个事务（多线程并发）, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题 问题的本质就是线程安全问题，共享数据的问题 3.2 问题 问题 说明 脏读 事务 T1 读取到了事务 T2 未提交的数据，如果 T2 回滚，那么 T1 读取到的数据是临时且无效的 不可重复读 事务 T1 读取到了事务 T2 已提交的数据（update），导致 T1 多次读取同一个字段但是结果不同 幻读 事务 T1 读取到了事务 T2 已提交的数据（insert / delete），导致 T1 多次读取同一张表，但记录数不同 3.3 隔离级别分类 隔离级别 脏读 不可重复读 幻读 read uncommitted √ √ √ read committed × √ √ repeatable read × × √ serializable × × × repeatable read 是 MySQl 默认 隔离级别，Mysql 5.0 之后此级别也可以避免幻读? 3.4 隔离级别管理 命令 说明 select @@tx_isolation 查看会话隔离级别 set tx_isolation=隔离级别 设置会话隔离级别，必须在开启事务之前 set [global/session] transaction isolation level 隔离级别 设置下次事务的隔离级别 tx_isolation=隔离级别 在 /etc/my.cnf 中添加，永久设置 四 锁4.1 悲观锁1 概述 数据库提供实现 悲观的认为别人一定会修改我使用的数据，我就未为我使用的数据加锁，防止别人修改 2 锁粒度划分 表锁 开销小，加锁快；不会出现死锁；但锁粒度大，锁冲突概率高，并发度低 行锁 开销大，加锁慢；会出现死锁；锁定粒度小，锁冲突概率低，并发度高。 3 锁机制划分 读锁/共享锁 其他事务可以读，但不能写 写锁/排他锁 其他事务不能读取，也不能写 4.2 乐观锁 需要自己实现 乐观的认为数据一般是不会造成冲突的。只有在提交数据的时候，才会对数据的冲突进行检测 类似与 版本控制（git / svn），会有一个版本号，在提交时会对比版本号，如果冲突则不能提交。 例： id=1 money=100 version=1甲乙同时操作money-10 甲先提交id=1 money=90 version=2提交成功。 乙后提交id=1 money=90 version=2提交失败 乙需要从新查询，然后修改提交id=1 money=80 version=3","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"SQL","slug":"CS/SQL","permalink":"https://anyeansan.github.io/categories/CS/SQL/"}],"tags":[]},{"title":"Mysql语句","slug":"SQL/Mysql语句","date":"2020-11-08T13:14:13.000Z","updated":"2020-11-08T13:16:42.616Z","comments":true,"path":"2020/11/08/SQL/Mysql语句/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/SQL/Mysql%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"一 概述1.1 SQL（Structure Query Language） 结构化查询语言，关系型数据库通用命令 遵循SQL92标准 注释 -- 单行注释 #单行注释（mysql 特有） /* 多行注释 */ 1.2 严格模式（SQL_MODE） set sql_mode = &#39;traditional&#39; 设置严格模式（默认） set sql_mode = &#39;&#39; 关闭严格模式 1.3 规范1 SQL 规范 SQL 语句不区分大小写，关键字和函数名建议大写 值：除了数值类型外都使用单引号 &#39;&#39; 别名建议使用双引号 &quot;&quot;，且不省略 as 关键字 数据库必须设置字符集，表必须设置字符集和存储引擎 列选择合适的数据类型及长度，且要有注释 每列设置 NOT NULL + DEFAULT 数值默认为 0 或其它有效数字 字符串默认为空格字符串 &#39; &#39; 或其它有效字符串 enum 类型不要用于数值，只能用于字符串 主键列最好是无关数值列，且自增长 2 命名规范 库名和表名小写，只能使用 A-Z a-z 0-9，不能以数字开头 不能使用关键字和保留字 1.4 SQL 常用分类 类型 说明 DDL（Data Definition Language） 数据定义语言，如 create alter drop truncate DML（Data Manipulation Language） 数据操作语言，如 insert delete update DQL（Data Query Language） 数据查询语言，如 select show DCL（Data Control Language） 数据控制语言，如 grant revoke 二 库2.1 查 命令 说明 show databases 查看所有库 use 库名 使用指定数据库 select database() 查看正在使用的数据库 show create database db_name 查看建库语句 show variables like &#39;character_set_database&#39; 查看当前数据库字符集 show variables like &#39;collation_database&#39; 查看当前数据库校对集 2.2 增1create database [if not exists] 库名 [default character set 字符集 collate 校对集] character set 都可以简写为 charset 2.3 删1drop database [if exists] 库名 2.4 改1alter database 库名 [charset 字符集 collate 校对集] 库名不可修改 只能修改库属性（字符集和校对集） 三 表3.1 查 命令 说明 show tables [from 库名] 查看库（默认为当前库）中的所有表 show create table 表名 查看建表语句 desc 表名 查看表结构 3.2 增123456789101112// 1 create table [if not exists] 表名( 列名 列属性, ...... 列名 列属性)[engine=INNODB character set 字符集 collate 校对集]// 2 根据已有表结构创建新表create table 新表名 like 旧表名// 3 根据已有表创建新表并添加数据create table 新表名 AS 子查询 3.3 删1drop table [if exists] 表名 3.4 改1 表信息（表名 表属性） 命令 说明 rename table 表名 to 新表名 修改表名 alter table 表名 rename 新表名 修改表名 alter table 表名 表属性 修改表属性 2 表结构（列信息） 命令 说明 alter table 表名 add [column] 列名 列属性 [位置] 默认在最后添加一列，可指定位置：first 或 after 某列 alter table 表名 add [column] (列名 列属性, ...) 在最后添加多列 alter table 表名 drop [column] 列名 删除列 alter table 表名 modify 列名 列属性 修改列属性 alter table 表名 change 列名 新列名 列属性 修改列名和列属性 四 数据4.1 增删改1 insert 命令 说明 insert [into] 表名 values(值列表)[, (值列表)] 向表所有列插入 1 或多条记录，列与值一一对应 insert [into] 表名(字段列表) values(值列表)[, (值列表)] 向表指定列插入 1 或多条记录，列与值一一对应 insert [into] 表名 set 列=值, ... 向表指定列插入 1 条记录，值可以使用子查询 2 update 命令 说明 update 表名 set 列=值 [where 子句] 不加条件会更新所有行 3 delete 命令 说明 delete from 表名 [where 子句] 不加条件会删除所有行 truncate [table] 表名 清空表 truncate 和 delete 区别 DELETE DML 操作，是逻辑性质删除，逐行删除速度慢 删除表中的数据，表结构还在，删除后的数据可以找回 自增长不会重置 TRUNCATE DDL 操作，对表段中的数据页进行清空，速度快 相当于把表扔了又创建一个同样表结构的新表 自增长会重置 4.2 查123456789101112131415161718192021222324252627select [选项] 表达式 [as 列别名] [, [选项] 表达式 [as 列别名], ...][ from 数据源 [as 表别名] [where 子句] [group by 子句] [having 子句] [order by 子句] [limit 子句]][union | union all]select ...// 查询过程1. from - 确定数据源2. where - 从原表中筛选出符合条件的数据形成一个概念中的临时结果集，存入内存3. group by - 按照指定列进行分组4. select - 处理表达式（函数, 别名, 运算 ...），形成结果集5. having - 对结果集进行过滤6. order by - 对过滤后的结果集进行排序7. limit - 对排序后的结果集进行条目限制，形成最终结果集 1 select 子句 选项 all：保留所有结果（默认） distinct：去除重复 distinct row top 表达式 每一个表达式代表一列，可以是列名，*，变量，函数，… 别名 表别名可用于全局 列别名可用于 having 和 order by 2 from 子句 本质上只要数据类似二维表，都可以作为数据源 单表数据源 多表数据源 查询语句 3 where 子句 从原表中的记录中进行筛选 where 是直接对表中数据进行判断，所以只能使用表中的列，且不能使用别名 4 group by 子句1 概述 通常配合聚合函数使用 可以有多个分组列，以逗号分隔 select 中可以查询的列： 分组的列 聚合函数的列 与分组列一对一的列（不报错，但不推荐） 2 group by 原理 先按照分组列排序、去重，形成一张虚拟表 虚拟表的结构：分组列与其它列的对应关系 分组列一对一的列可以直接查询（即与分组列对应的列只有一行记录） 分组列一对多的列不能直接查询（即与分组列对应的列有多行记录） 使用聚合函数将多行记录统计为一行记录 使用 group_concat() 将多行记录合并连接为一行记录 3 聚合函数 函数 说明 max([distinct] expr) 返回 expr 最大值 min([distinct] expr) 返回 expr 最小值 count([distinct] expr) 返回 expr 记录总数 sum([distinct] expr) 返回 expr 总和 avg([distinct] expr) 返回 expr 平均值 group_concat() 将group by产生的同一个分组中的其它列的所有值连接成一个字符串（多行记录变一行） count() count(*) 和 count(常量) 记录总数（包含空行） 此类参数表示数数，有一行记录总数就+1，也就是说总数与记录内容无关 count(*) 效率底不建议 count(列名) 记录总数（不包含空行） 4 with rollup 分组后跟 with rollup 会对分组进行统计 只有 mysql 支持 5 having 子句 having 是对其之前子句筛选出的数据进行条件过滤 6 order by子句 语句 说明 asc 升序（默认） desc 降序 排序依赖校对集 可以有多个排序条件，前一个条件结果相同则比较下一个条件 7 limit 子句 语句 说明 limit [startIndex, ]length 从指定索引（若省略，默认为 0）开始，取 length 条数据 limit length offset startIndex 同上，也可以把索引理解为偏移量（即跳过 startIndex 个） 8 union &amp; union all 语句 说明 union all 合并多个查询结果集，保留所有 union 合并多个查询结果集，去除重复 要合并的查询结果列数必须相同，合并后结果集的列名取决于第一个要合并的查询 一般情况下,会将 in() 或者 OR 语句 改写成 UNION ALL ，来提高性能 五 关联查询（SQL JOIN）5.1 概述1 关联查询结果 关联查询有七种结果（行/记录） 关联查询的列都是两表组合在一起，即 A 表的列 + B 表的列 2 关联查询分类 类型 名称 查询结果 inner/cross join 内连接 A ∩ B left [outer] join 左外连接 A，A - A ∩ B right [outer] join 右外连接 B，B - A ∩ B full [outer] join 全外连接 A ∪ B，A ∪ B - A ∩ B 如果连接的表是同一张表，又称为自连接 mysql 不支持全外连接，可通过 union 实现 5.2 语法12345678910111213141516171819表1 &#123;[inner | cross] | &#123;left | right&#125; [outer]&#125; join表2on 条件表达式[ &#123;[inner | cross] | &#123;left | right&#125; [outer]&#125; join 表3 on 条件表达式 ......][ [where 子句] [group by 子句] [having 子句] [order by 子句] [limit 子句]][union | union all]select ... 5.3 关联条件1 概述 内连接如果没有关联条件，会形成笛卡尔积 外连接如果没有关联条件，会报错 2 笛卡尔积 笛卡儿积是元素相组合，不是数学相乘 数学中的笛卡儿积 集合 A 有 m 个元素，集合 B 有 n 个元素，则笛卡尔积共 m * n个元素 集合 A = {a, b}，集合 B = {0, 1, 2}，笛卡尔积 = {(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)} 数据库中的笛卡儿积 表 A 有 m 条记录，表 B 中有 n 条记录，则笛卡尔积共有 m*n 条记录 3 关联条件的方式 where 用于所有关联查询 join on 只能写关联条件，虽然关联条件可以并到 where 中，但单独写可读性更好 join using(列名列表) 表示两个关联字段值相同，要求两个关联字段列名必须一致 5.4 内连接1 语法12345// 1 隐式from 表1, 表2 where 条件// 2 显式from 表1 [inner | cross] join 表2 on 关联条件 2 结果 5.5 外连接1 左外连接1 语法1表1 left [outer] join 表2 on 条件 2 结果 查出左表所有行，左表中的行在右表没有匹配则右表对应行返回空 查出左表在右表中没有匹配的行，右表肯定都返回空 2 右外连接1 语法1表1 right [outer] join 表2 on 条件 2 结果 查出右表所有行，右表中的行在左表没有匹配则左表对应行返回空 查出右表在左表中没有匹配的行，左表肯定都返回空 3 全外连接1 语法1表1 full [outer] join 表2 on 条件 2 结果 查出左表和右表的所有行，在彼此表中没有匹配的行则返回空 查出在左表和右表中彼此没有匹配的行 5.6 例1 原始表 t1 和 t2 id name 1 a 2 b 3 c id age 2 D 3 E 4 F 2 内连接1select * from t1 inner join t2 on t1.id=t2.id; id name id age 2 a 2 D 3 c 3 E 3 左外连接1select * from t1 left join t2 on t1.id=t2.id; id name id age 1 a null null 2 b 2 D 3 c 3 E 1select * from t1 left join t2 on t1.id!=t2.id; id name id age 1 a null null 4 右外连接1select * from t1 right join t2 on t1.id=t2.id; id name id age 2 b 2 D 3 c 3 E null null 4 F 1select * from t1 right join t2 on t1.id!=t2.id; id name id age null null 4 F 5 全外连接1select * from t1 full join t2 on t1.id=t2.id; id name id age 1 a null null 2 b 2 D 3 c 3 E null null 4 F 1select * from t1 full join t2 on t1.id!=t2.id; id name id age 1 a null null null null 4 F 六 子查询6.1 概述 一个查询需要的条件或数据是另一个查询的结果，即一个查询中嵌套了另一个查询，嵌套在里面的查询就是子查询 6.2 子查询根据位置分类 from 型子查询：子查询必须有别名 from (子查询) 别名 where 型子查询 where 字段 = (子查询) where 字段 in (子查询) ... exists 型子查询 where exists(子查询) 子查询返回记录，则 exists 为 true，添加记录 子查询没有记录，则 exists 为 false，不添加记录 相关子查询：子查询和外部查询有关系 1234567SELECT *FROM invoices iWHERE invoice_total &gt; ( SELECT AVG(invoice_total) FROM invoices WHERE client_id = i.client_id); select 子查询","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"SQL","slug":"CS/SQL","permalink":"https://anyeansan.github.io/categories/CS/SQL/"}],"tags":[]},{"title":"Mysql语法","slug":"SQL/Mysql语法","date":"2020-11-08T13:14:08.000Z","updated":"2020-11-08T13:16:37.821Z","comments":true,"path":"2020/11/08/SQL/Mysql语法/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/SQL/Mysql%E8%AF%AD%E6%B3%95/","excerpt":"","text":"一 元数据1.1 概述 元数据可以简单理解为描述数据的数据，除了存储在数据库中的数据外，其它大多可以理解为元数据 元数据存储在“基表”中，不能直接访问 infomation_schema 数据库中保存了大量元数据查询的视图 show 命令是封装好的，提供元数据查询的基础功能 1.2 information_schema 表 说明 schemata 存储当前 mysql 实例中所有数据库的信息，show databases 命令从这个表获取数据 tables 存储数据库中的表信息（包括视图），show tables [from db_name] 命令从这个表获取结果 columns 存储数据库中每张表的列信息（如属于哪张表哪个库，属性信息…) table_constraints 存储表约束信息 statistics 存储表索引信息 collations 存储了字符集和校对集对照信息 tables 表 列 说明 table_schema 表所在库名 table_name 表名 engine 存储引擎 table_rows 总行数 avg_row_length 行平均长度 index_length 索引长度 表大小 = avg_row_length * table_rows + index_length 1.3 show 命令 说明 show databases 查看所有库名 show tables [from db_name] 查看库中所有表名 show create database db_name 查看建库语句 show create table t_name 查看建表语句 show processlist 查看数据库连接情况 show charset 查看支持的字符集 show collation 查看支持的校对集 show engines 查看支持的存储引擎 show grants for user_name 查看用户权限 shwo variables [like pattern] 查看变量信息 show index from t_name 查看表的索引信息 show engine innodb statsu\\G 查看 innodb 引擎详细状态信息（横向） show status [like pattern] 查看数据库状态信息 show binary logs 查看二进制日志的列表信息 show binlog events in log_name 查看二进制日志的事件信息 show master status 查看 mysql 当前使用的二进制日志信息 show relaylog events in log_name 查看中继日志的事件信息 二 运算符 和 语句2.1 算术运算符 运算符 说明 + 加 - 减 * 乘 / 除 DIV 整除 %, MOD 模 2.2 比较运算符 运算符 说明 &gt; 大于 &gt;= 大于等于 &lt; 小于 &lt;= 小于等于 = 等于，null = null 返回 null &lt;=&gt; 等于，null = null 返回 1 &lt;&gt;, != 不等于 2.3 逻辑运算符 运算符 说明 and, &amp;&amp; 逻辑与 or, &#124;&#124; 逻辑或 not, ! 逻辑非 xor 逻辑异或 and 优先级高于 or 2.4 正则1regexp pattern 符号 说明 ^ 开头 $ 结尾 ` ` [abc] [a-z] 范围 {n} {m,} {m,n} * + ? 数量 2.5 语句 语句 说明 like pattern 模糊查询，pattern 中：% 匹配任意个任意字符，_ 匹配一个任意字符 between ... and ... 在某个范围之间 is null 是否为空 is not null 是否不为空 in() 匹配其中任意一个值，则为 true，类似逻辑或 any() 必须配合比较运算符使用，代表（大于, 小于, …）其中任意一个值则为 true some() 是 any() 的别名 all() 必须配合比较运算符使用，代表（大于, 小于, …）其中所有值则为 true 三 变量3.1 分类 类型 级别 系统变量 全局级别，会话级别 自定义变量 会话级别 3.2 系统变量1 查看系统变量 命令 说明 show global variables 查看全局级别所有系统变量的信息 show session variables 查看会话级别所有系统变量的信息 select @@global.变量名 查看全局级别的指定系统变量的信息 select @@session.变量名 查看会话级别的指定系统变量的信息 select @@变量名 查看会话级别的指定系统变量的信息 2 修改系统变量 命令 说明 set global 变量名=值 修改全局级别的系统变量，影响新会话，重启失效 set @@global.变量名=值 修改全局级别的系统变量，影响新会话，重启失效 set session 变量名=值 修改会话级别的系统变量 set @@session.变量名=值 修改会话级别的系统变量 3.3 自定义变量1 概述 为了区分系统变量, 规定用户自定义变量必须使用一个 @ 符号 所有自定义变量不区分数据库 所有自定义的变量都是会话级别，但根据作用域可以分为 全局变量（user/session variable）: 作用域为当前会话 局部变量（local variable） ：作用域为所在的 begin end 2 全局变量 命令 说明 set @变量名=值 声明并赋值 set @变量名 := 值 声明并赋值 select @变量名 := 值 声明并赋值 select 字段 into @变量名 from t_name 声明并从表中查询数据赋值 select @变量名 查看变量值 全局变量可以不声明直接使用，默认值为 null 3 局部变量 命令 说明 declare 变量名 类型 声明局部变量 declare 变量名 类型 default 默认值 声明局部变量并设置默认值 局部变量需要先声明后使用 局部变量的赋值与查看命令与全局变量完全一致 四 函数4.1 信息函数 函数 说明 user() 返回当前用户及所在主机 database() 返回当前数据库名 version() 返回数据库的版本号 connection_id() 返回连接id last_insert_id() 最后插入记录的id 4.2 数学函数 函数 说明 abs(X) 绝对值 ceil(X) 向上取整 floor(X) 向下取整 round(X, D) 四舍五入，保留D位小数 truncate(X, D) 数字截断，保留D位小数 rand(X) 0~1 的随机数 mod(N, M) 等价于 N % M 或者 N MOD M sort(X) 平方 pow(X,Y) Y次方 conv(X, from_base, to_base) 将X从进制 from_base 转为进制 to_base 的字符串 4.3 字符串函数 函数 说明 md5(str) 返回字符串的 md5 加密版本 password(str) 返回字符串的加密版本，41位的字符串 concat(str1, str2, ...) 连接字符串，有一个参数为 null，则返回 null concat_ws(separator, str1, str2, ...) 使用指定分隔符连接字符串 length(str) 字节数 char_length(str) 字符数 lower(str) 转小写 upper(str) 转大写 format(X, D) 将数字 X 转为 #,###,###.## 形式的字符串，D为小数位数 trim([{both &#124; leading &#124; trailing}] [remstr from] str) 去除两端空格，remstr 默认空格可指定字符 ltrim(str) 去除左端空格 rtrim(str) 去除右端空格 reverse(str) 反转 left(str, len) 返回 str 从左开始 len 个字符的字符串 right(str, len) 返回 str 从右开始 len 个字符的字符串 substring(str, [from] pos, [[for] len]) 返回 str 从 pos 开始的len个字符的字符串 substr() 等价于 substring() locate(substr, str[, pos]) 返回子串在 str 中第一次出现的位置，默认从 1 开始，没有则返回 0 instr(str, substr) 等价于 locate(substr, str) insert(str, pos, len, newstr) 将 str 从 pos 开始的 len 个字符替换为 newstr replace(str, from_str, to_str) 替换 str 的子串 strcmp(expr1,expr2) 比较两个字符串 repeat(str, count) 返回 str 重复 count 次组成的字符串 isnull(expr) 判断表达式是否为空 4.4 日期函数 函数 说明 now() 返回当前日期和时间 yyyy-MM--dd HH:mm:ss curdate() 返回当前日期 yyyy-MM-dd curtime() 返回当前时间 HH:mm:ss date_format(date, format) 日期格式化 year(date)/month(date)/day(date)/hour(time) 返回指定项 extract(year/month/day from now()) 提取日期中的年月日… datediff(expr1, expr2) 返回 expr1 - expr2 的日期差值 dayofyear(date) 返回指定日期是当年的第几天 dayofmonth(date) 返回指定日期是当月的第几天 dayofweek(date) 返回指定日期是当周的第几天（周日是第一天） date_add(date, INTERVAL expr unit) 给日期加上指定值，unit 用来指定日期项，expr 为值 date_sub(date, INTERVAL expr unit) 给日期减去指定值 4.4 JSON 函数 函数 说明 json_array([val[, val ...]]) 返回由参数组成json数组 json_object([key, val[, key, val ...]]) 返回由参数组成的 json 对象，奇数参数是 key，偶数参数是 value json_pretty(json_val) 漂亮的打印 json json_array_append(json_doc, path, val[, path, val ...]) 在 json_doc 指定位置上的值后追加值 json_array_insert(json_doc, path, val[, path, val ...]) 向 json 数组指定位置插入值，返回新数组，不改变原有数组 json_insert(json_doc, path, val[, path, val ...]) 向 json 对象添加新的键值对，返回新对象，不改变原对象 json_set(json_doc, path, val[, path, val ...]) 替换 json_doc 指定位置现有的值，如果不存在则添加 json_replace(json_doc, path, val[, path, val ...]) 仅替换现有的值 json_remove(json_doc, path[, path...]) 删除 json_doc 指定位置的值 json_extract(json_doc, path[, path...]) 获取 json_doc 指定位置的值 json_contains_path(json_doc, one_or_all, path[, path...]) 判断是否包含指定路径（索引或者key） json_contains(target, candidate[, path]) 判断是否包含指定值 json_length(json_doc[, path]) 返回 json_doc 的长度 4.5 自定义函数1 语法1234567891011121314151617CREATE [DEFINER = user] FUNCTION sp_name ([func_parameter[,...]]) RETURNS type [characteristic ...] routine_bodyfunc_parameter: param_name typetype: Any valid MySQL data typecharacteristic: COMMENT &apos;string&apos; | LANGUAGE SQL | [NOT] DETERMINISTIC | &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125; | SQL SECURITY &#123; DEFINER | INVOKER &#125; 2 创建12345678DROP FUNCTION IF EXISTS 函数名;DELIMITER 结束标记CREATE FUNCTION 函数名 ([参数列表]) RETURNS 返回值类型BEGIN 函数体 RETURN 返回值;END 结束标记DELIMITER ; -- 将结束标记改回默认分号 形参 形参名 形参类型 返回值 {STRING | INTEGER | REAL | DECIMAL} 必须有返回值且只有一个 3 查看 show function status [like pattern] 查看所有函数 show create function 函数名 查看函数的创建语句 4 修改/删除 函数 函数不能修改 删除 drop function [if exists] 函数名 五 流程控制语句5.1 if12345If 条件判断 then -- 满足条件要执行的代码;Else -- 不满足条件要执行的代码;End if; 5.2 while123While 条件判断 do -- 循环体End while; 5.3 Iterate &amp; Leave1234循环名:While 条件判断 do -- 循环体 itrate/leave 循环名;End while; Iterate 类似 continue Leave 类似 break","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"SQL","slug":"CS/SQL","permalink":"https://anyeansan.github.io/categories/CS/SQL/"}],"tags":[]},{"title":"Mysql库表列属性","slug":"SQL/Mysql库表列属性","date":"2020-11-08T13:14:02.000Z","updated":"2020-11-08T13:16:04.646Z","comments":true,"path":"2020/11/08/SQL/Mysql库表列属性/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/SQL/Mysql%E5%BA%93%E8%A1%A8%E5%88%97%E5%B1%9E%E6%80%A7/","excerpt":"","text":"一 库表属性1.1 字符集（charset）1 MySQL 的 UTF-8 MySQL 中的 utf8mb4 才是真正的 UTF-8，而 utf8 是 utf8mb3 的别名，是 MySQL 脑残的产物 MySQL 表示未来会删除 utf8mb3，然后 utf8 指代 utf8mb4（真是个小机灵鬼） 2 字符集说明 show charset 查看数据库支持的字符集 show variables like &#39;character%&#39; 查看数据库默认字符集设置 配置 说明 character_set_database 数据库默认字符集，若没设置则使用 character_set_server character_set_client 客户端字符集 character_set_connection 客户端连接数据库使用的字符集 character_set_results 数据库给客户端返回数据使用的字符集 character_set_server 服务器字符集，建议由系统自己管理，不要人为定义 character_set_filesystem 用于将系统文件名转化成此字符集，默认 binary 不做转换（建议不改动） character_set_system 数据库系统用来存储元数据的编码，通常是 utf8（不要改动） character_sets_dir 字符集安装目录 3 乱码问题1 存 数据本身字符集 → 客户端字符集 → 连接字符集 → 数据库字符集 数据本身字符集 = 客户端字符集，若不一致则会乱码 将数据从 客户端字符集 转为 连接字符集，若一致则不转换 将数据从 连接字符集 转为 数据库字符集，若一致则不转换 存数据最终是按照 数据库字符集 存储 结论 保证 数据本身字符集 = 客户端字符集 连接字符集不要太小导致转换损失数据 2 取 数据库字符集 → 连接字符集 → 结果字符集 → 客户端字符集 将数据从 数据库字符集 转为 连接字符集 ，若一致则不转换 将数据从 连接字符集 转为 结果字符集，若一致则不转换 取数据最终是按照结果字符集返回给客户端 比较 结果字符集 与 客户端字符集 是否一致 结论 保证 结果字符集 = 客户端字符集 连接字符集不要太小导致转换损失数据 1.2 校对集（collation）1 概述 校对集，就是数据的比较方式，或者排序规则 只有当数据产生比较的时候，校对集才会生效 必须在没有数据之前声明好校对集，如果有了数据再进行校对集修改，修改无效 校对集依赖字符集，每个字符集都对应 1 或 多个校对集，如 utf8mb4 默认校对集 utf8mb4_general_ci 2 校对集格式 show collation 查看数据库支持的校对集 格式 说明 _bin binary，二进制比较, 大小写敏感（适用比较特殊的数据，如拼音，日文…） _ci case insensitive，大小写不敏感 _cs case sensitive，大小写敏感 1.3 存储引擎（engine）1 概述 MySQL进行存储数据的方式。 每一种存储引擎使用不同的存储机制，索引技巧，锁定水平，最终提供广泛且不同的功能。 2 分类 show engines 查看支持的存储引擎 select @@default_storage_engine 查看默认的存储引擎 alter table 表名 engine=存储引擎 除了修改存储引擎外，还会做碎片整理 存储引擎 说明 InnoDB 新版 MySQL 默认存储引擎 Myisam 速度快，不支持事务，安全性不够 Memory 数据存在内存中，不存在磁盘，一关闭服务器就消失。适合临时数据 XtraDB PerconaDB 默认存储引擎 TokuDB RocksDB MyRocks 第三方存储引擎：共同点是压缩比较高,数据插入性能极高 3 InnoDB1 特性 事务（Transaction） 行级锁（Row-level Lock） 多版本并发控制 MVCC（Multi-Version Concurrency Control） 自动故障安全恢复 ACSR（Auto Crash Safey Recovery） 热备份（Hot Backup） 外键 复制 Replication Group Commit GTID (Global Transaction ID) 多线程（Multi-Threads-SQL） 2 物理存储结构1 共享表空间 文件 说明 idbdata1 系统数据字典信息（统计信息），Undo 回滚日志等数据 ib_logfile0~ib_logfile1 Redo 重做日志文件，事务日志文件 ibtmp1 临时表空间，存储临时表（如 join union 等操作） 2 独立表空间 文件 说明 .frm 存储表列信息（列名，列属性） .ibd 存储表数据行和索引 opt 存储库属性 一张 InnoDB 表 = ibdata1 + frm + ibd（段、区、页） 3 表空间（Tablespace）说明 共享表空间：将所有数据存储到同一个表空间中 ，管理比较混乱 独立表空间：一张表一个 frm 存储列信息，一个 ibd 存储数据行和索引 说明 共享表空间是 5.5 版本出现的管理模式 5.6 版本开始默认使用独立表空间，保留共享表空间，只用来存储：数据字典信息，undo，临时表 5.7 版本临时表被独立出去，共享表空间只存储：数据字典信息，undo 8.0 版本undo也被独立出去，共享表空间只存储：数据字典信息 4 核心参数1 存储引擎 default_storage_engine=innodb 默认存储引擎 2 表空间 innobd_file_pre_table=1 表空间模式，1 独立表空间 innodb_data_file_path=ibdata1:512M:ibdata2:512M:autoextend 共享表空间文件个数和大小 3 缓冲区 innodb_flush_log_at_trx_commit=1 双一标准之一 控制了 innodb 将 log buffer 中的数据写入日志文件并 flush 磁盘的时间点，取值分别为 0、1、2 三个 Innodb_flush_method=(O_DIRECT, fdatasync) 双一标准之一 控制 log buffer 和 data buffer 刷写磁盘的时候是否经过文件系统缓存 OS buffer innodb_max_dirty_pages_pct=75 脏页刷写策略 4 redo 日志 innodb_log_buffer_size innodb_log_file_size innodb_log_files_in_group 二 列属性2.1 数据类型1 数值类型1 整型 类型 大小 无符号范围 有符号范围 tinyint 1 Byte 0 ~ 255 -128 ~ 127 smallint 2 Byte 0 ~ 65535 -215 ~ 215-1 mediumint 3 Byte 0 ~ 224-1` -223 ~ 223-1 int 4 Byte 0 ~ 232-1` -231 ~ 231-1 bigint 8 Byte 0 ~ 264-1` -263 ~ 263-1 int(M) M 与存储无关，只是标识显示长度，且要配合 zerofill 才有意义 2 浮点型 &amp; 定点型 类型 名称 语法 M D float 单精度浮点型 4 Byte float(M,D) 总位数 小数点后的位数（不足用0补，超过则四舍五入） double 双精度浮点型 8 Byte double(M,D) 总位数 小数点后的位数（不足用0补，超过则四舍五入） decimal 定点型，底层使用字符串存储 decimal(M,D) 2 字符串类型 类型 名称 语法 M 说明 char 定长字符串 char(M) 字符数 [1,255] char 会立即分配 M 个字符长度的存储空间，未占满用空格填充 varchar 变长字符串 varchar(M) 最大字符数 [1,65535] varchar 存储前会先判断长度，按需分配空间 tinytext 短文本 text 文本 mediumtext 中长文本 longtext 长文本 1 char 非空 char 的最大长度是 255【字节】 可空 char 的最大长度是 254【字节】，因为允许为空时，系统会自动从整个记录中保留一个字节来存储 NULL 2 varchar 非空 varchar 的最大长度是 65532【字节】 如果存储值小于 255 字节，则使用 1 个字节标记长度 如果存储值超过 255 字节，则使用 2 个字节标记长度 varchar是从第二个字节开始存储的 可空 varchar 的最大长度是 65531【字节】 3 以 utf8 为例比较 类型 可存字符 实存字符 实占字节 利用率 char(M) M n M * 3 n / M varchar(M) M n n * 3 + (1~2) n * 3 / （n * 3 + (1~2)） 3 枚举 enum enum(value1, value2, value3, ...) 建表时在字段上定义枚举列表，按照定义顺序索引值从 1 开始编号 空字符串 &quot;&quot; 索引为 0 null 索引为 null 插入数据时（单选），可以使用索引值或者枚举值 数据库存储时存储索引，读取时再根据枚举列表将索引转为枚举值 4 集合 set set(value1, value2, value3, ...) 建表时在字段上定义集合列表，集合中每个值对应一个二进制位 第一个值对应 1 = 1 第二个值对应 10 = 2 第三个值对应 100 = 4 第四个值对应 1000 = 8 … 也就是说一个二进制数，从低位向高位依次对应集合从 1 开始的值 插入数据时（多选），可以使用二进制对应的十进制数字，插入数字对应的二进制，相应位置为 1 代表插入该值，例如 插入 6，转为二进制 110，即插入第二和第三个值 插入 7，转为二进制 111，即插入前三个值 插入 8，转为二进制 1000，即插入第四个值 5 日期类型 类型 格式 大小 最小值 最大值 零值 说明 datetime yyyy-mm-dd hh:mm:ss 8 Byte 1000-01-01 00:00:00 9999-12-31 23:59:59 0000-00-00 00:00:00 表示日期时间 timestamp yyyy-mm-dd hh:mm:ss 4 Byte 1970-01-01 00:00:00 2038-01-19 03:14:07 0000-00-00 00:00:00 date yyyy-mm-dd 3 Byte 1000-01-01 9999-12-31 0000-00-00 表示日期 time hh:mm:ss 3 Byte -838:59:59 838:59:59 00:00:00 表示时间 datatime 存储日期时间 timestamp 时间戳（从 1970-01-01 00:00:00 到指定时间的毫秒值） 存储毫秒值，显示时，根据毫秒值计算出一个本地化的日期时间（即可以自动根据时区显示） timestamp 因为存储的毫秒值，比较或计算时效率更高 插入时未指定值或插入 null，则会插入系统当前时间 插入 Mysql 的日期时间格式为 yyyy-MM-dd HH:mm:ss 6 二进制类型 类型 说明 tinyblob 最大长度为255B blob 最大长度为64KB mediumblob 最大长度为16MB longblob 最大长度为4GB 二进制数据类型可存储任何数据（甚至包括二进制信息），如图像、多媒体、字处理文档等 2.2 注释 comment &#39;注释&#39; 用于描述字段信息 2.3 unsigned unsigned 将数值类型声明为无符号 MySQL 中的数值默认都是有符号的。 2.4 zerofill zerofill 数值类型的列位数不足时用 0 补填充 如果声明 zerofill，则会自动声明为 unsigned 2.5 自增长1 添加自增长 字段 auto_increment 一张表只能有一个自增长，因为一张表只有一个维护自增长的变量 自增的列必须是整数列 自增的列必须是键列（主键，唯一键，外键） 建表后，增删自增长通过修改列属性来实现 2 使用自增长 自增列指定了值且非 0 null，则使用指定值 如果指定值 &lt; 自增值，则表的自增值不变 如果指定值 &gt; 自增值，则表的自增值会变成指定值 使用自增值 自增列没有指定值 自增列指定值为 0 null default 3 自增长管理 命令 说明 show variables like &#39;auto_increment%&#39; 查看自增长初始值和种子 select last_insert_id() 获取自增的最后一个值 show create database 库名 通过查看表创建语句查看下一次自增长的值 alter table 表名 auto_increment = 值 修改自增长的值，只能比当前自增长的最大值大，不能小（小则不生效） 2.6 约束（Constraint）1 概述 约束 名称 说明 Primary key 主键约束 唯一，非空，一张表只能有一个 Foreign key 外键约束 用于在两表之间建立关系，需指定引用主表的哪一列 Unique key 唯一键约束 唯一，非空，一张表可有多个唯一键 Not Null 非空约束 要求该列值不能为空 Default 默认约束 设置该列默认值 Check 检查约束（Mysql 不支持） 限制该列取值范围是否合适 select * from information_schema.table_constraints where table_name = &#39;表名&#39; 查看某表的约束信息 表的约束信息存储在 information_shcema 数据库的 table_constraints 表中 2 主键约束1 概述 主键列唯一，非空，一张表只能有一个主键 主键分为： 单列主键（单列） 复合主键（多列） 创建主键会自动创建对应的索引，删除主键会自动删除对应的索引 主键无法修改 主键约束名称为 PRIMARY 2 添加主键约束 命令 说明 字段 primaray key 建表时，为当前列添加单列主键 primary key(字段列表) 建表时，单独一行，添加单列主键或复合主键 alter table 表名 add primary key(字段列表) 建表后，添加单列主键或复合主键 3 删除主键约束 命令 说明 alter table 表名 drop primary key 有自增长先要删除自增长，因为自增长的列必须有索引 3 唯一键约束1 概述 唯一约束列唯一，可以为 null，且可以有多个 null，因为 null = null -&gt; false 一张表可以有多个唯一约束 唯一键分为： 单列唯一键（约束名：列名） 复合唯一键（约束名：该多列组合的第一列的列名） 创建唯一键约束会自动创建对应的索引，删除唯一键约束是通过删除对应索引来删除 2 添加唯一键约束 命令 说明 字段 unique key 建表时，为当前列添加单列唯一键 unique key(字段列表) 建表时，单独一行，添加单列唯一键或复合唯一键 alter table 表名 add unique key(字段列表) 建表后，添加单列唯一键或复合唯一键 3 删除唯一键约束 命令 说明 alter table 表名 drop [index/key] 唯一键约束名 通过删除索引删除唯一键约束 4 外键约束1 概述 外键约束建立在从表之上，一个表可以有多个外键约束 主表和从表必须使用相同的存储引擎 InnoDB，且禁止使用临时表 从表的外键列和主表的被引用列的名称可以不同，列属性必须一致 主表被引用列必须是键列 从表添加外键约束时会自动创建索引，删除外键约束不会删除索引 2 外键约束模式1 概述 外键约束同时约束双方行为 主表：update delete 因为从表有可能引用了主表要更新或删除的数据 从表：insert update 从表的数据必须存在于主表之中 建表时：先建主表再建从表，删表时：先删从表再删主表 删除和修改可以分别指定外键约束模式 on update 模式 on delete 模式 2 模式 模式 名称 说明 restrict（默认） 严格模式 如果从表外键列有引用，则主表不能 update/delete 被引用列的值 no action 严格模式 标准 SQL 的关键字，在 MySQL 中同 restrict cascade 级联模式 主表被引用列的值1. update，则从表外键列对应值 update2. delete ，则从表删除对应的整行记录 set null 置空模式 主表被引用列的值 update/delete 时， 从表外键列对应值设为 null（外键列要可以为空） set default 默认值模式 Mysql Innodb不支持 3 添加外键约束 命令 说明 foreign key(从表外键列) references 主表名(被引用列) [on delete 模式 on update 模式] 建表时，单独一行，添加外键约束 alter table 从表名 add foreign key(从表外键列) references 主表名(被引用列) [on delete 模式 on update 模式] 建表后，添加外键约束 4 删除外键约束 命令 说明 alter table 表名 drop foreign key 外键约束名 外键约束名通过系统库 information_schema 的 table_constraints 获取 5 非空约束 not null 列不能为 null，必须插入值，通常配合 default 使用 建表后，增删非空约束通过修改列属性来实现 6 默认约束 字段 default 默认值 使用默认值 对应字段没有插入值 对应字段插入值为 default 建表后，增删默认约束通过修改列属性来实现","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"SQL","slug":"CS/SQL","permalink":"https://anyeansan.github.io/categories/CS/SQL/"}],"tags":[]},{"title":"Mysql前言","slug":"SQL/Mysql前言","date":"2020-11-08T13:13:54.000Z","updated":"2020-11-08T13:16:09.508Z","comments":true,"path":"2020/11/08/SQL/Mysql前言/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/SQL/Mysql%E5%89%8D%E8%A8%80/","excerpt":"","text":"一 概述1.1 概念 DBMS（Database Management System）：数据库管理系统 RDBMS（Relational DBMS） Oracle DB2 Sql-Server Mysql access PG MSSQL NoSQL（Not Only SQL） MongoDB Redis ES（Elasticsearch） memcached NewSQL（分布式） TiDB Spanner AliSQL OB PolarDB DBA（Database Administrator）：数据库管理员 1.2 Mysql GA版本 5.6 5.6.38（2017-09-13） 5.7 5.7.20（2017-09-13） 1.3 数据库设计三大范式 每个单元格都应该是单一值，并且列不重复 每个表都应该是单一功能的，即一个表能且仅能表示一个实体类型，表中所有字段都是用来描述此实体的 一个表中的字段不该由表中其它字段推导而来 二 Mysql 安装与配置2.1 Linux1 下载解压 下载 linux-generic 通用二进制包（类似绿色版） 上传到 linux 并解压 2 卸载 mariadb121 rpm -qa | grep mariadb2 yum remove -y xxx 3 创建用户并授权，用于管理mysql1231 useradd -s /sbin/nologin mysql2 chown -R mysql.mysql basedir3 chown -R mysql.mysql datadir 4 设置环境变量12341 vim /etc/profile2 export PATH=basedir/bin:$PATH3 source /etc/profile4 mysql -V 5 初始化1 无密码1mysqld --initialize-insecure --user=mysql --basedir=xxx --datadir=xxx 2 有密码1mysqld --initialize --user=mysql --basedir=xxx --datadir=xxx 可能会因为缺少 libaio-devel 依赖而报错 --initialize 对密码复杂度进行定制：12位，4种 密码过期时间：180天 给 root@localhost 用户设置临时密码 6 配置文件 /etc/my.cnf123456789[mysqld] user=mysqlbasedir=datadir=socket=/tmp/mysql.sockport=3306server_id=6[mysql]socket=/tmp/mysql.sock 7 MySQL 服务1 服务启动配置1 作用 影响数据库的启动 影响客户端的功能 2 配置方式 配置文件 命令行启动参数：如果参数冲突，命令行参数会优先级高于配置文件 编译安装时配置 3 配置文件1 加载顺序123456// 默认情况下，MySQL启动时，会依序读取配置文件，如果有重复选项，会以最后一个文件设置的为准// 查看配置文件加载顺序mysqld --help --verbose | grep my.cnf// 如果启动时手动配置了配置文件，则默认配置文件都不再读取--defaults-file= 2 格式1234567891011121314151617[module]key=value/* module 1. 服务端 1. [mysqld] 2. [mysqld_safe] 3. [server] * 包括服务端所有 2. 客户端 1. [mysql] 2. [mysqladmin] 3. [mysqldump] 4. [client] * 包括客户端所有*/ 3 样板123456789101112131415161718# -----------------服务端配置-------------------------[mysqld]# 管理用户user=mysql# 软件安装目录basedir=/app/mysql# 数据目录datadir=/data/mysql/data# 服务端保存 socket 文件路径socket=/tmp/mysql.sock# 端口号port=3306# 服务器id号 1~65535server_id=6# -----------------客户端配置-------------------------[mysql]# 客户端登录时寻找 socket 文件路径 socket=/tmp/mysql.sock 2 服务启动方式1 init12345// 1 配置cp basedir/support-files/mysql.server /etc/init.d/mysqld// 2 启动service mysqld start 或者 /etc/init.d/mysqld start 其实是调用了 basedir/support-files/mysql.server 脚本 读取 /etc/my.cnf 配置文件 调用 basedir/bin/mysqld_safe 来启动 mysqld 2 systemd1234567891011121314151617// 1 配置 /etc/systemd/system/mysqld.service[Unit]Description=MySQL ServerDocumentation=man:mysqld(8)Documentation=http://dev.mysql.com/doc/refman/en/using-systemd.htmlAfter=network.targetAfter=syslog.target[Install]WantedBy=multi-user.target[Service]User=mysqlGroup=mysqlExecStart=basedir/bin/mysqld --defaults-file=/etc/my.cnfLimitNOFILE = 5000// 2 启动systemctl start mysqld 其实是加载了 /etc/systemd/system/mysqld.service 读取 /etc/my.cnf 配置文件 启动 mysqld 3 手动12// 维护模式启动mysqld_safe --skip-grant-tables --skip-networking &amp; 2.2 Windows1 配置环境变量2 在MySql目录下创建 .ini 配置文件12345678# 服务端配置[mysqld] basedir =datadir =port = 3306character-set-server=utf8mb4 // 1[mysql]default-character-set=utf8mb4 // 2 配置结果：12皆不配置/配置1/配置2 3 初始化：在 basedir/bin 下执行命令 mysqld --initialize --console 随机密码，并在控制台显示密码 mysqld --initialize-insecure 无密码 4 服务 mysqld --install 安装服务 net start mysql 启动服务 net stop mysql 停止服务 mysqld remove / sc delete mysql 删除服务 三 MySQL 的连接3.1 概述 Mysql 是 C/S 模型 使用 Mysql 需要安装服务端，连接服务端需要通过客户端 3.2 客户端1 MySQL自带的命令行工具 mysql.exe1 连接方式 命令 方式 说明 mysql [-h Host] [-Pport] -uuser -p[password] TCP/IP 方式 本地、远程 mysql -uuser -p[password] [-S /tmp/mysql.sock] Socket 方式 本地 2 mysql [OPTION] （mysql 命令） OPTION 说明 -u user 用户名 -ppassword 密码和 p 之间不能有空格 -h host 主机地址 -P port 端口 -S Socket Socket 文件路径 -e &quot;sql&quot; 免交互执行命令（即不连接数据库） &lt; 脚本路径 导入 sql 脚本 -prompt 提示符 定义 mysql 提示符，默认为 mysql&gt; 3 mysqldump 命令 mysqldump -hhost -Pport -uuser -ppassword --databse 库名 &gt; .sql路径 不登录，导出某个数据库的备份（导出 sql 脚本） 2 图形化工具（GUI） 软件 windows mac linux 功能 免费版 sequelpro &nbsp; √ &nbsp; &nbsp; 有 dbeaver √ √ √ &nbsp; 有 navicat √ √ √ 强 &nbsp; SQLyog √ &nbsp; &nbsp; 强 &nbsp; dbForge √ &nbsp; &nbsp; 强 有 heidisql √ &nbsp; &nbsp; &nbsp; 有 TablePlus 四 MySQL 体系结构4.1 mysql 实例 mysqld（老板） master thread（经理） other thread（员工） 预分配内存（办公区） 4.2 MySQL 逻辑架构1 连接层 提供连接协议：TCP/IP 、SOCKET 提供验证：用户、密码、IP、Port、SOCKET … 提供专用连接线程：接收用户SQL，返回结果 show processlist 查看连接线程 2 SQL 层（服务层） 接收上层传送的SQL语句 语法验证模块：验证语句语法,是否满足SQL_MODE 语义检查：判断SQL语句的类型（DQL、DML …） 权限检查：用户对库表有没有权限 解析器：语句执行前进行预处理，生成解析树(执行计划)，说白了就是生成多种执行方案 优化器：根据解析器得出的多种执行计划，进行判断，选择最优的执行计划 代价模型：资源（CPU IO MEM）的耗损评估性能好坏 执行器：根据最优执行计划，执行SQL语句，产生执行结果（在磁盘上） 提供查询缓存（默认没开启）：会使用redis tair替代查询缓存功能 提供日志记录（默认没开启）：二进制日志 binlog 、审计日志、通用日志 … 3 存储引擎层 根据SQL层执行的结果，从磁盘上拿数据 将16进制的磁盘数据，返回给 SQL 层结构化成表 由连接层的专用线程返回给用户 4.3 MySQL 逻辑存储结构 库（database） 库名 库属性（字符集，校对集(排序规则)） 表（table） 表名 表属性（存储引擎，字符集，校对集(排序规则)） 列（column）/ 字段（field） 列名 列属性（数据类型，约束，…） 行（row）/ 记录（record） 4.4 MySQL 物理存储结构 库（目录） 表 MyISAM .frm ：存储表结构（列名，列属性） .MYD ：存储数据记录 .MYI ：存储索引 InnoDB .frm ：存储表结构（列名，列属性） .ibd ：存储数据记录和索引 .opt ：存储库属性 ibdata1 ：数据字段信息 InnoDB，一般情况下（非分区表） 段：一个表就是一个段，一个段由多个区构成 区：一个区由64个连续的页构造，1M 大小（ 64*16=1024 ） 页：一个页大小为 16 kb 五 用户 &amp; 权限5.1 用户1 用户定义 user@&#39;Host&#39; Host：白名单，即此用户可以在哪个主机连接数据库 Host（例） 说明 localhost 本地 127.0.0.1 本地 % 任意网段 10.0.0.% 10.0.0.0~10.0.0.255 10.0.0.5% 10.0.0.50~10.0.0.59 10.0.0.0/255.255.255.0 10.0.0.0~10.0.0.255 2 用户管理 命令 说明 select user,host,authentication_string from mysql.user 查询用户名，主机，密码（用户信息存储在数据库 mysql 中 的 user 表） create user user@&#39;Host&#39; [identified by &#39;password&#39;] 创建用户 drop user user@&#39;Host&#39; 删除用户 3 修改用户密码 命令 说明 mysqladmin -u用户名 -p[旧密码] password 新密码 不需登录 alter user &#39;用户名&#39; @&#39;localhost&#39; identified by &#39;新密码&#39; 需要登录 set password for 用户名 = &#39;新密码&#39; 修改指定用户密码 set password = &#39;新密码&#39; 修改自己密码 忘记 root 密码 关闭数据库 维护模式启动数据库 mysqld_safe --skip-grant-tables --skip-networking &amp; 登录并修改密码（如果修改密码报错，则刷新权限） flush privileges 5.2 权限1 权限列表123456789// 1 基本权限SELECT，INSERT，UPDATE，DELETE，CREATE，DROP，ALTER，SHOW DATABASES，CREATE USER，CREATE TEMPORARY TABLES，RELOAD，SHUTDOWN，PROCESS，FILE，REFERENCE，INDEX，SUPER，EXECUTE，REPLICATION，SLAVE，REPLICATION，CLIENT，EVENT，TRIGGER，LOCK TABLES，CREATE VIEW，SHOW VIEW，CREATE ROUTINE，ALTER ROUTINE，CREATE TABLESPACE，// 2 特殊权限// 2.1 所有权限ALL privileges// 2.2 可以给别的用户授权的权限，超级管理员才具备with grant option 2 权限管理1 查看权限 show grants [for user@&#39;Host&#39;] 查看自己（或指定用户）的权限 2 授权 grant 权限 on 目标 to 用户 [identified by &#39;password&#39;] [with grant option] 权限 ALL privileges 权限列表，以逗号分隔 目标 *.* 所有数据库的所有表 database.* 指定数据库的所有表 database.table 指定数据库的指定表 3 回收权限 revoke 权限 on 目标 from user@&#39;Host&#39; 六 MySQL 内置命令 命令 说明 help 打印帮助 \\c 放弃本条语句，类似 ctrl + c quit exit ctrl+d \\q 退出 \\G 竖形显示数据 source 脚本路径 导入SQL脚本 tee 路径 将输入的sql语句存储到本地 prompt 提示符 定义 mysql 提示符，默认为 mysql&gt; delimiter 符号 定义结束符，默认为;","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"SQL","slug":"CS/SQL","permalink":"https://anyeansan.github.io/categories/CS/SQL/"}],"tags":[]},{"title":"jQuery","slug":"UI/jQuery","date":"2020-11-08T13:12:55.000Z","updated":"2020-11-08T13:13:22.690Z","comments":true,"path":"2020/11/08/UI/jQuery/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/jQuery/","excerpt":"","text":"一 jQuery 概述1.1 jQuery 中的顶级对象 $ $ 是 jQuery 的别称，在代码中可以使用 jQuery 代替 $ 是 jQuery 的顶级对象，相当于原生 JavaScript 中的 window 1.2 jQuery 对象和 DOM 对象 用原生 JS 获取的是 DOM 对象 jQuery 方法获取的是 jQuery 对象，本质是利用 $ 对 DOM 对象包装后产生的对象，是一个类数组 隐式迭代：对 jQuery 对象执行操作时，会给内部所有 DOM 元素进行操作 转换 方式 DOM → jQuery jQuery = $(DOM) jQuery → DOM DOM = jQuery[0]DOM = jQuery.get(0) 1.3 $() 语法 说明 $() 页面 DOM 加载事件，相当于原生 js 中的 DOMContentLoaded 事件 $(DOM) 将 DOM 对象转为 jQuery 对象 $(selector) 使用选择器获取 jQeury 对象 $(Html) 新建一个指定 Html 标签的 jQury 对象 二 选择器2.1 基础选择器 选择器 说明 * 通配选择器 #id ID 选择器 .class 类选择器 html 标签选择器 s1,s2,... 并集 s1.s2 交集 2.2 层级选择器 语法 说明 A E 后代元素 A &gt; E 子元素 A ~ E 兄弟元素 A + E 下一个兄弟元素 2.3 属性选择器 属性选择器 说明 [attr] 带有 attr 属性的元素 [attr=value] attr 属性值为 value 的元素 [attr!=value] attr 属性值不为 value 的元素 [attr^=value] attr 属性值以 value 开头的元素 [attr$=value] attr 属性值以 value 结尾的元素 [attr*=value] attr 属性值包含 value 的元素 [s1][s2][sN] 相当于 &amp;&amp; 2.4 过滤选择器 过滤选择器 说明 :first 第一个 :last 最后一个 :not(s) 非 :odd 奇数索引 :even 偶数索引 :eq(index) 等于索引 :gt(index) 大于索引 :lt(index) 小于索引 2.5 子元素选择器 子元素选择器 说明 :first-child 第一个子元素 :last-child 最后一个子元素 :only-child 唯一的子元素 :nth-child(expr) expr 可以是 an+b, odd, even 2.6 内容选择器 内容选择器 说明 :empty 不包含子元素或者文本的元素 :contains(text) 包含指定文本的元素 :has(selector) 包含选择器所匹配元素的元素 :parent 含有子元素或者文本的元素 2.7 可见性选择器 可见性选择器 说明 :hidden 所有不可见元素，display:none, type=hidden ... :visible 所有可见元素 2.8 表单选择器 表单选择器 说明 :input 匹配所有 input textarea select button 元素 :Type 匹配 input 指定类型的元素，如 :text :radio ... 2.9 表单属性选择器 表单属性选择器 说明 :enabled 所有可用元素 :disabled 所有不可用元素 :checked 单/复选框的所有选中元素 :selected 下拉框所有选中的 option 元素 2.10 筛选方法1 概述 选择器能完成的，筛选提供相同方法也能完成 区别在于选择器直接获取筛选后的结果，方法先获取原结果，然后再筛选 $(&quot;div:first&quot;)：直接获取第一个 div $(&quot;div&quot;).first()：先获取所有 div，之后筛选出第一个 2 查找 方法 说明 parent() 父元素 childre([selector]) 所有匹配子元素 find(selector) 查找匹配的元素 siblings([selector]) 所有兄弟元素 next([selector]) 下一个兄弟元素 nextAll([selector]) 之后的所有兄弟元素 prev([selector]) 上一个兄弟元素 prevAll([selector]) 之前的所有兄弟元素 3 过滤 方法 说明 eq(index) 获取指定索引元素 first() 第一个 last() 最后一个 filter(expr) 获取匹配的元素 三 文档处理3,1 元素遍历 方法 说明 $(Selector).each(callback) 遍历 jQuery 对象 $.each(obj, callback) 遍历任意对象 12345callback:function(index, domEle) &#123; index：元素的索引 domEle：遍历的元素，相当于 this，是 DOM 对象&#125; 3.2 添删改 方法 说明 append(ele) 追加到元素内尾部，父子关系 prepend(ele) 追加到元素内首部，父子关系 after(ele) 添加到元素后面，兄弟关系 before(ele) 添加到元素前面，兄弟关系 remove() 删除自已及后代节点，移除绑定事件和绑定数据 detach() 删除自已及后代节点，保留绑定事件和绑定数据 empty() 删除所有后代节点 replaceWith(content) 将所有匹配的元素替换成指定的 HTML 或 DOM 元素 replaceAll(selector) 替换所有匹配的元素 3.3 复制 方法 说明 clone() 只复制样式，不复制行为 clone(true) 既复制样式，又复制行为 四 文本 方法 说明 html([value]) 获取或设置元素内容，对应 innerHTML text([value]) 获取或设置元素内容，对应 innerText val([value]) 获取或设置元素 value 属性的值 五 数据缓存 方法 说明 data(key) 获取绑定数据 data(key,value) 绑定数据，页面刷新移除 removeData(key) 移除绑定数据 六 属性 方法 说明 attr(key) 获取属性的值（自定义属性和标准属性） attr(key,value) 设置属性的值 removeAttr(key) 删除属性 prop(key) 获取属性的值（Html 标准属性） prop(key,value) 设置属性的值 removeProp(key) 删除属性 七 CSS7.1 样式 语法 说明 css(key, value) 添加属性和值 css({key:value, key:value, …}) 以对象形式添加多组属性和值 addClass(class) 添加类 removeClass(class) 删除类 toggleClass(class) 切换，有类则删除，无类则添加 hasClass(class) 判断是否有指定类 7.2 位置 方法 说明 offset() 获取元素相对于文档的偏移，返回 JSON 对象，有两个属性 top left offset({top:value, left:value}) 设置元素相对于文档的偏移 position() 获取元素相对于有定位祖先元素的偏移，没有则相对于文档偏移，返回 JSON 对象：top left scrollTop([value]) 获取或设置元素上边被卷去的距离 scrollLeft([value]) 获取或设置元素左边被卷去的距离 7.3 尺寸 方法 说明 width([value]) 获取或设置元素宽度，content-box height([value]) 获取或设置元素高度，content-box innerWidth() 获取 padding-box 宽度 innerHeight() 获取 padding-box 高度 outerWidth() 获取 border-box 宽度 outerHeight() 获取 border-box 高度 outerWidth(true) 获取 margin-box 宽度 outerHeight(true) 获取 margin-box 高度 八 效果8.1 显示隐藏 方法 说明 show([speed], [easing], [callback]) 显示元素 hide([speed], [easing], [callback]) 隐藏元素 speed slow normal fast 毫秒值 easing swing ：默认，慢 → 快 → 慢 linear：匀速 8.2 滑动 方法 说明 slideDown([speed], [easing], [callback]) 向下滑动 slideUp([speed], [easing], [callback]) 向上滑动 slideToggle([speed], [easing], [callback]) 滑动切换 8.3 淡入淡出 方法 说明 fadeIn([speed], [easing], [callback]) 淡入显示 fadeOut([speed], [easing], [callback]) 淡出隐藏 fadeToggle([speed], [easing], [callback]) 淡入淡出切换 fadeTo([speed], opacity, [easing], [callback]) 调整到指定透明度，opacity：0~1，必须 8.4 自定义动画 方法 说明 animate(params, [speed], [easing], [callback]) 创建动画，params：对象形式的样式属性和值 stop([clearQueue], [gotoEnd]) 停止所有在指定元素上正在运行的动画 delay(duration, [queueName]) 动画延迟时间 九 事件9.1 页面加载 语法 说明 $(document).ready(fn) 标准 API，相当于原生 js 中的 DOMContentLoaded 事件 $(fn) 简化版 9.2 事件绑定1 普通方式1$(selector).type(fn); 2 on 一个事件对应一个处理函数 1234567$(selector).on( &#123; type: fn, type: fn, ... &#125;); 多个事件对应一个处理函数 1$(selector).on(&quot;type type type ...&quot;, fn); 事件委托 12$(selector).on(types, childSelector, fn);// 事件绑定在父元素上，但由子元素触发 3 off 解绑元素所有事件 1$(selector).off() 解绑元素指定事件 1$(selector).off(type) 解绑委托事件 1$(selector).off(type, childSelector) 9.3 事件处理 语法 说明 $(selector).hover(over, [out]) mouseenter 触发第一个函数，mouseleave 触发第二个函数，如果只有一个函数，则都触发它 $(selector).trigger(type) 自动触发指定事件 $(selector).triggerHandler(type) 自动触发指定事件，不会触发元素默认行为 十 工具10.1 拷贝对象1$.extend([deep], target, srcObj1, srcOjb2, ...) 10.2 字符串去空格1$.trim(str) 10.3 多库共存12// 修改 $ 为自定义变量let newSymbol = $.noConflict() 十一 AJAX11.1 Ajax 请求1 $.ajax()12345678910111213141516171819$.ajax(&#123; url: &quot;&quot;, type: &quot;&quot;, data: &quot;&quot;, async: true, dataType: &quot;&quot;, contentType: &quot;&quot;, beforeSend: function(XHR) &#123; XHR：XMLHttpRequest 对象 &#125;, success: function(data,textStatus,XHR)&#123; data：响应数据 textStatus：描述状态的字符串 &#125;, error: function(XHR,textStatus,errorThrown)&#123; textStatus：错误信息 errorThrown：异常对象 &#125;&#125;); 属性 说明 type 请求方式，默认 GET url 请求地址 data 请求参数，key=value&amp;key=value 字符串或者 JSON dataType 响应数据类型，xml html json text script jsonp ... async 是否异步，默认 true contentType 请求参数编码类型，默认 application/x-www-form-urlencoded beforeSend 发送请求前修改 XMLHttpRequest 对象的函数 success 请求成功后的回调函数 error 请求失败时调用此函数 2 $.get()1$.get(url, [data], [callback], [dataType]) 3 $.post()1$.get(post, [data], [callback], [dataType]) 11.2 表单序列化1 serialize()1$(&quot;form&quot;).serialize() 必须使用 &lt;form&gt; 元素 表单项必须有 name 属性 将表单中所有项拼凑成一个字符串，格式为 key=value&amp;key=value 2 serializeArray()1$(&quot;form&quot;).serializeArray() 必须使用 &lt;form&gt; 元素 表单项必须有 name 属性 将表单中所有项拼凑成一个 json 数组，格式 [{key:value}, {key:value}] 11.3 Ajax 事件 事件 说明 ajaxStart AJAX 请求开始时触发 ajaxComplete AJAX 请求完成时触发 ajaxSuccess AJAX 请求成功时触发 ajaxError AJAX 请求失败时触发 11.4 跨域 $.getJSON() $.getScript()","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"AJAX","slug":"UI/AJAX","date":"2020-11-08T13:12:47.000Z","updated":"2020-11-08T13:13:12.380Z","comments":true,"path":"2020/11/08/UI/AJAX/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/AJAX/","excerpt":"","text":"一 AJAX 概述 Asynchronous JavaScript And XML AJAX 不是一个技术，是多个技术联合实现的产物，且无论服务端编程语言是哪一种都可以，AJAX 只负责发送请求和接收响应 异步提交下 form 标签的 action 和 method 没有意义 服务端不能使用转发或重定向，因为会让浏览器全面刷新，只能以流的方式响应给浏览器 一个页面可以同时发送多个 AJAX 请求 传统的网页（不使用 AJAX）都是同步的，如果需要更新内容，必需重载整个网页面 客户端 → 请求 → 服务端 服务端 → 响应 → 客户端 Ajax：可以使网页实现异步更新，即在不重新加载整个网页的情况下，对网页的某部分进行更新 客户端 → 请求 → ajax engine → 服务端 服务端 → 响应 → ajax engine → 客户端 Ajax 应用场景 页面向下加载更多数据 列表数据无刷新分页 表单项失去焦点验证 输入框的自动补全（下拉提示） 地图 … 二 XMLHttpRequest2.1 概述 异步通讯对象 老版本的 IE 中是 ActiveXObject 2.2 构造 构造函数 说明 XMLHttpRequest() 创建 XMLHttpRequest 对象 2.3 属性 属性 权限 说明 readyState 只读 XMLHttpRequest 状态码（0-4） status 只读 响应状态码（200 302 404 500 ...） responseType 读写 在open()之后send()之前设置，告诉服务器返回指定类型的数据，默认 text responseText 只读 字符串形式的响应数据 responseXML 只读 XML 形式的响应数据 withCredentials 读写 跨域请求是否携带 cookie，默认 false 1 readyState 状态码 状态 说明 0 unsent 请求未初始化 1 opened 服务器连接已建立 2 headers_received 请求已接收 3 loading 请求处理中 4 done 请求已完成，且响应已就绪 2 responseType 值 说明 &quot;&quot; 同 text &quot;text&quot;（默认） 表示服务器返回文本数据 &quot;json&quot; 表示服务器返回 JSON 数据 &quot;blob&quot; 表示服务器返回二进制对象 &quot;document&quot; 表示服务器返回一个文档对象，HTML 或 XML &quot;arraybuffer&quot; 表示服务器返回二进制数组 2.4 方法 方法 说明 open(method, url, [async], [user], [password]) 初始化一个请求 send([data]) 发送请求 setRequestHeader(key, value) 设置请求头 getResponseHeader(key) 获取响应头信息 getAllResponseHeaders() 获取一个包含所有响应头信息的字符串 overrideMimeType(mimeType) 指定一个MIME类型用于替代服务器指定的类型，必须在 send() 之前调用 1 open() 参数 说明 method 请求方法，GET POST PUT DELETE... url 请求地址 async 是否异步，默认 true user 用于认证的用户名，默认为 null password 用于认证的密码，默认为 null 2.5 事件及对应属性 事件 说明 对应属性 readyStateChange 当 readyState 属性改变时，就会触发此事件 onreadystatechange load 请求成功完成时触发 onload error 请求出错时触发 onerror abort 请求中止时触发 onabort loadend 请求结束时触发，无论成功失败或中止 onloadend timeout 请求超时时触发 ontimeout loadstart 接收到响应数据时触发 onloadstart progress 接收数据开始周期触发，进度条 onprogress 事件对应属性指向一个函数，是对应事件触发时的处理函数 三 AJAX 使用步骤3.1 创建 XMLHttpRequest 对象1234567var ajax;if(window.XMLHttpRequest)&#123; ajax=new XMLHttpRequest();&#125;else&#123; ajax=new ActiveXObject(\"Microsoft.XMLHTTP\");&#125;return ajax; 3.2 初始化请求并发送1 GET12345// 1 初始化请求ajax.open(\"GET\",\"url?name=xxx&amp;age=18\");// 2 发送请求ajax.send(); 2 POST123456789101112// 1 初始化请求ajax.open(\"POST\",\"url\");// 2 设置请求头并发送请求（POST 请求需要使用表单）// 2.1 请求参数格式为 application/x-www-form-urlencodedajax.setRequestHeader(\"content-type\",\"application/x-www-form-urlencoded\");ajax.send(\"name=xxx&amp;age=18\");// 2.2 请求参数格式为 application/jsonajax.setRequestHeader(\"content-type\",\"application/json\");// 请求参数必须是字符串，所以需要把 JSON 对象转为字符串ajax.send(JSON.stringify(&#123;name:\"xxx\", age:18&#125;)); 3.3 注册回调函数接收服务器响应数据 方式 说明 onload（推荐） 不兼容旧 IE，不需要判断状态码，被调用一次 onreadystatechange 兼容旧 IE，需要判断状态码，被调用多次 12345678910111213// 1 onreadystatechangeajax.onload = function() &#123; let res=ajax.responseText; let res=ajax.responseXml;&#125;// 2 onloadajax.onreadystatechange = function()&#123; if (ajax.readyState==4 &amp;&amp; ajax.status==200)&#123; let res=ajax.responseText; let res=ajax.responseXml; &#125;&#125; 3.4 低版本 IE 浏览器缓存问题 问题：在请求地址不变的情况下，只有第一次请求真正发送到服务器，后续请求都从浏览器缓存中获取结果，导致拿到的都是旧数据 解决：发送请求时，添加一个每次都不同的请求参数，如时间戳，随机数 四 FormData4.1 概述 将表单数据的键值对组合，实现表单数据的序列化，减少表单元素拼接 可以通过 send(formData) 发送 4.2 构造 构造函数 说明 FormData(form) 将表单元素构造为 FormData 对象 4.3 方法 方法 说明 get(key) 返回 FormData 对象中与给定键关联的第一个值 getAll(key) 返回 FormData 对象中与给定键关联的所有值的数组 set(key, value) 给 FormData 设置键值对，键不存在则添加，存在则覆盖 append(key, value,[fileName]) 给 formData 追加键值对，键存在也不会覆盖，如果是文件，可以添加文件名 delete(key) 从 FormData 对象里面删除一个键值对 has(key) 判断 FormData 对象是否包含指定键 kes() 返回一个包含所有键的迭代器对象 values() 返回一个包含所有值的迭代器对象 entries() 返回一个包含所有键值对的迭代器对象 五 跨域5.1 同源政策 同源：协议、域名和端口都相同 Ajax 只能向同源服务器发送HTTP 请求，如果发出跨域请求，就会报错 同源政策是为了用户信息安全，防止恶意窃取数据 解决同源的方式有许多，如 JSONP 5.2 JSONP1 概述 json with padding JSONP 不属于 Ajax 请求，但可以模拟 Ajax 请求 是 json 的一种 “使用模式”，可以从别的域请求资源 2 使用 在客户端全局作用域定义一个函数 客户端 &lt;script src=&quot;&quot;&gt; 是不受同源限制的，非同源请求地址写在src 中 在请求地址中将函数名发送给服务器 服务器响应数据必须是客户端所定义函数的调用，真正发给客户端的数据作为函数调用的参数 客户端接收到实参，执行函数 3 动态请求 &lt;script&gt; 标签可以不写死，而是用 JS 动态生成 添加监听事件 onload，在请求完成后，删除 &lt;script src=&quot;&quot;&gt; ，避免多次请求产生多个 &lt;script src=&quot;&quot;&gt; 4 跨域 Cookie withCredentials 设置为 true Access-Control-Allow-Credentials 设置为 true","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"DOM","slug":"UI/DOM","date":"2020-11-08T13:09:31.000Z","updated":"2020-11-08T13:10:45.279Z","comments":true,"path":"2020/11/08/UI/DOM/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/DOM/","excerpt":"","text":"一 DOM 概述 Document Object Model 文档对象模型 DOM 是 HTML 和 XML 文档的编程接口，用于改变文档的结构，样式和内容 DOM 的最小组成单位叫做节点（node），DOM 树由各种不同类型的节点组成 页面中所有内容都是节点（标签，属性，文本，注释等） 二 NodeList &amp; HTMLCollection2.1 NodeList NodeList 是节点的集合，是类数组对象 Node.childNodes 返回的是一个动态集合，即文档中的节点树发生变化，NodeList 也会随之变化 其他的 NodeList 都是静态集合 NodeList 的 length 属性表示其包含的节点数量 NodeList 的遍历 item(index) 获取指定索引的值，可以用 nodeList[index] 代替 for 循环 因为是类数组对象，有索引 forEach() keys() values() entries() 2.2 HTMLCollection HTMLCollection 元素节点的集合，是类数组对象 HTMLCollection 都是动态集合 HTMLCollection 的 length 属性表示其包含的节点数量 HTMLCollection 不能使用 foreach 遍历 三 Node3.1 分类 类型 名称 说明 nodeType nodeName nodeValue Document 文档节点 整个页面 9 #document null Element 元素节点 页面 HTML 标签 1 大写的标签名 null Attr 属性节点 页面标签的属性 2 属性名 属性值 Text 文本节点 页面中的文本 3 #text 文本内容 Comment 注释节点 注释 8 #comment 注释内容 DocumentType 文档类型节点 &lt;!DOCTYPE html&gt; 10 文档的类型 null DocumentFragment 文档片段节点 一个没有父级文件的最小文档对象 11 #document-fragment null 3.2 属性1 节点信息 属性 权限 说明 nodeType 只读 节点类型（整数值） nodeName 只读 节点名 nodeValue 读写 获取或设置当前节点的值 baseURI 只读 当前网页的绝对路径 URI 2 节点结构 属性 权限 说明 parentNode 只读 父节点 childNodes 只读 所有子节点的 NodeList 集合 firstChild 只读 第一个子节点 lastChild 只读 最后一个子节点 nextSibling 只读 弟节点 previousSibling 只读 兄节点 3 元素节点结构 属性 权限 说明 parentElement 只读 父元素节点，若没有父节点或父节点不是元素节点则返回 null children 只读 所有子元素节点，非标准，但推荐使用 firstElementChild 只读 第一个子元素节点，有兼容问题，推荐 children[0] lastElementChild 只读 最后一个子元素节点，有兼容问题，推荐 children[children.length-1] nextElementSibling 只读 弟元素节点，有兼容问题 previousElementSibling 只读 兄元素节点，有兼容问题 3.3 方法 方法 说明 parentNode.appendChild(childNode) 追加子节点 parentNode.removeChild(childNode) 删除子节点 parentNode.replaceChild(newNode, oldNode) 替换子节点 parentNode.insertBefore(childNode, targetNode) 将子节点插入到目标节点之前 node.cloneNode([flag]) 克隆节点，无参或 false 为浅拷贝，true 为深拷贝 node.hasChildNodes() 判断是否有子节点 node.contains(node) 判断是否是其自己或后代节点 四 Document4.1 属性 属性 说明 forms 返回所有 &lt;form&gt; 表单节点的 HTMLCollection 集合 documentURI 文档的 URI location 浏览器地址栏对象 body 获取 &lt;body&gt; 元素节点 documentElement 获取 &lt;html&gt; 元素节点 4.2 方法1 获取 方法 说明 getElementById(id) 根据元素 ID 获取 Element 对象 getElementsByTagName(tagName) 根据标签名获取元素节点的 HTMLCollection 集合 getElementsByClassName(class) 根据 class 属性值获取元素节点的 HTMLCollection 集合 getElementsByName(name) 根据元素 name 属性的值获取节点的 NodeList 集合 querySelector(selector) 返回第一个匹配的节点 querySelectorAll(selector) 返回所有匹配节点的 NodeList 集合 2 创建 方法 说明 createElement(tageName) 创建元素节点 createAttribute(attrName) 创建属性节点 createTextNode(text) 创建文本节点 createComment(comment) 创建注释节点 另外两种创建节点的方式 document.write() 是直接将内容写入页面，如果文档流加载完毕才执行，会导致页面重绘（仍掉原页面，创建新页面且只有写出的内容） innerHTML 创建多个元素通过拼接字符串创建，效率底 创建多个元素通过数组形式拼接，效率高，但复杂 五 Element5.1 属性1 信息属性 属性 权限 说明 id 读写 元素 id tagName 只读 元素标签名 className 读写 返回 class 属性的字符串，多个用空格分隔 classList 只读 返回 class 属性的类数组对象 innerHTML 读写 识别 Html 标签，保留Html 标签、空格和换行，w3c 标准 innerText 读写 不识别 Html 标签，会去除 Html标签以及空格和换行，非标准 dataset 只读 存放了所有以 data- 开头的自定义属性的集合 hiddent 读写 元素是否隐藏 style 读写 元素的行内样式信息，带单位 2 offset 系列属性 属性 权限 说明 offsetParent 只读 返回该元素带有定位的祖先元素，如果没有则返回 body offsetTop 只读 返回元素相对定位祖先元素上方的偏移量，不带单位 offsetLeft 只读 返回元素相对定位祖先元素左方的偏移量，不带单位 offsetWidth 只读 返回 boder-box 的宽度，不带单位 offsetHeight 只读 返回 boder-box 的高度，不带单位 offset &amp; style 的区别 offset style 获取任意样式表的值 获取行内样式表的值 获取的值没有单位 获取的值有单位 offsetWidth = width + padding + border style.width = width 只读 读写 3 client 系列属性 属性 权限 说明 clientTop 只读 元素上边框大小 clientLeft 只读 元素左边框大小 clientWidth 只读 padding-box 的可视宽度，不带单位 clientHeight 只读 padding-box 的可视高度，不带单位 4 scroll 系列属性 属性 权限 说明 scrollLeft 被卷去的上侧距离，不带单位 scrollTop 被卷去的左侧距离，不带单位 scrollWidth padding-box 的实际宽度，不带单位 scrollHeight padding-box 的实际高度，不带单位 5.2 方法 方法 说明 getAttribute(key) 获取属性的值 setAttribute(key, value) 设置属性的值 removeAttribute(key) 删除属性 getAttributeNames() 返回当前元素所有属性名 hasAttribute(key) 某个属性是否存在 hasAttributes() 当前元素是否有属性 click() 模拟鼠标左键单击一个元素 Document 中用来获取元素节点的方法，Element 也能用，只是匹配范围是当前元素而非整个文档 六 事件6.1 EventTarget1 概述 DOM 的事件操作（监听和触发），都定义在 EventTarget 接口 2 API 方法 说明 addEventListener(type, listener [,useCapture]) 添加事件监听 removeEventListener(type, listener [,useCapture]) 移除事件监听 dispatchEvent(event) 触发指定事件 参数 说明 type 事件类型字符串，大小写敏感，如 click focus … listener 监听函数 useCapture 默认 false：冒泡阶段触发，true：捕获阶段触发 6.2 事件绑定和解绑1 传统注册方式1234# 绑定事件element.onEventType = function()&#123;&#125; # 解绑事件element.onclick=null; 利用 on 开头的事件 只在冒泡阶段触发 注册事件的唯一性：同一个元素同一个事件只能定义一个监听函数，多次定义会覆盖 2 方法监听注册方式1234# 绑定事件element.addEventListener(type, listener [,useCapture]) # 解绑事件element.removeEventListener(type, listener [,useCapture]) 同一个元素同一个事件可以添加多个监听函数 能够指定在哪个阶段（捕获阶段 or 冒泡阶段）触发监听函数 是整个 JavaScript 统一的监听函数接口 6.3 DOM 事件流1 概述 事件流描述的是从页面中接收事件的顺序 事件发生时会在元素节点之间按照特定的顺序传播，此传播过程即 DOM 事件流 JS 代码中只能执行捕获或者冒泡中的一个阶段 冒泡阶段更常用，但某些事件没有冒泡阶段，如 focus blur mouseenter mouseleave 2 事件流三个阶段 阶段 名称 说明 capture phase 捕获阶段 从 window 对象传导到目标节点（上层传到底层） target phase 目标阶段 在目标节点上触发 bubbling phase 冒泡阶段 从目标节点传导回 window 对象（从底层传回上层） 3 事件委托（代理/委派） 由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件 优点：只操作一次DOM，性能更高 如果希望事件到某个节点为止，不再传播，event.stopPropagation() 阻止冒泡 获取触发事件的对象 event.target 获取绑定事件的对象 this 6.4 Event1 概述 事件发生以后，系统会自动创建一个事件对象 Event，作为参数传给监听函数 事件对象是一系列与事件相关的数据的集合 Event 有许多字类，如 MouseEvent, KeyboardEvent, TouchEvent... 2 属性 属性 说明 target 触发事件的对象，this ：绑定事件的对象 type 事件类型（名称） returnValue 阻止事件的默认行为，低版本浏览器使用 3 方法 方法 说明 preventDefault() 阻止事件的默认行为（如跳转，提交…） stopPropagation() 阻止事件传播（捕获和冒泡） 4 阻止事件的默认行为方式 方式 说明 returnValue 低版本浏览器 IE678 使用 return false 没有兼容性问题，但是会结束代码，且只限于传统事件注册方式 preventDefault() W3C 标准，低版本可能不支持 6.5 鼠标事件1 事件 事件 说明 click 单击 dblclick 双击 focus 获取焦点，该事件不会冒泡 blur 失去焦点，该事件不会冒泡 mousedown 鼠标键按下 mouseup 鼠标键弹起 mousemove 鼠标移动 mouseenter 鼠标经过，该事件不会冒泡 mouseleave 鼠标离开，该事件不会冒泡 mouseover 鼠标经过 mouseout 鼠标离开 contextmenu 右键菜单，常使用 event.preventDefault() 来禁止右键菜单 selectstart 选中文字，常使用 event.preventDefault() 来禁止选中文字 2 MouseEvent 属性 说明 clientX 鼠标相对于浏览器窗口可视区的 X 坐标 clientY 鼠标相对于浏览器窗口可视区的 Y 坐标 pageX 鼠标相对于文档页面的 X 坐标 pageY 鼠标相对于文档页面的 Y 坐标 screenX 鼠标相对于电脑屏幕的 X 坐标 screenY 鼠标相对于电脑屏幕的 Y 坐标 6.6 键盘事件1 事件 事件 说明 keydown 按下键盘按键之后文字未输入之前触发，顺序在 keypress 之前，不区分大小写 keypress 按下有值的键之后文字未输入之前触发触发，区分大小写，不识别功能键如 → ← ctrl alt shift... keyup 弹起键盘按键触发，不区分大小写 2 KeyboardEvent 属性 说明 keyCode 按键对应的 ASCII 码值 6.7 触屏事件1 事件 事件 说明 touchstart 触摸到一个 DOM 元素时触发 touchmove 在一个 DOM 元素上滑动时触发 touchend 从一个 DOM 元素上移开时触发 2 概念 对象 说明 Touch 单个触摸点。触摸点可能是一根手指，也可能是一根触摸笔 TouchList 多个触摸点的集合 TouchEvent 触摸引发的事件实例 3 TouchEvent 属性 说明 touches TouchList，正在触摸屏幕的触点的列表 targetTouches TouchList，正在触摸当前 DOM 元素的触点的列表 changedTouches TouchList，状态发生改变的触点的列表 4 TouchList 属性 说明 length 节点数量 item(index) 获取指定索引的节点，可以用 list[index] 代替 5 Touch 属性 说明 identifier 返回一个整数，表示触摸点的唯一 ID target 触摸的节点 clientX 触点相对于可见视区左边沿的的 X 坐标 clientY 触点相对于可见视区上边沿的的 Y 坐标. pageX 触点相对于 HTML 文档左边沿的的 X 坐标 pageY 触点相对于 HTML 文档上边沿的的 Y 坐标 screenX 触点相对于屏幕左边沿的的 X 坐标 screenY 触点相对于屏幕上边沿的的 Y 坐标 6.8 表单事件 事件 说明 input 当 &lt;input&gt;、&lt;select&gt;、&lt;textarea&gt; 的值发生变化时触发 change 同 input 区别是如果有连续变化，input 事件会触发多次，而 change 事件只在失去焦点时触发一次 select 在&lt;input&gt;、&lt;textarea&gt; 里面选中文本时触发 invalid 提交表单时，如果表单元素的值不满足校验条件时触发 reset 重置表单时触发 submit 提交表单时触发 七 元素的属性操作7.1 attribute &amp; property 属性 说明 attribute HTML 标准属性和自定义属性 property DOM 属性（HTML 元素的标准属性会自动成为元素节点对象的属性） 7.2 操作方式1 attribute 操作 原生 DOM jQuery 读 element.getAttribute(name) $element.attr(name) 写 element.setAttribute(name, value) $element.attr(name, value) 删 element.removeAttribute(name) $element.removeAttr(name) 2 property 操作 原生 DOM jQuery 读 element.name $element.prop(name) 写 element.name=value $element.prop(name, value) 删 delete element.name $element.removeProp(name) 7.3 总结1 HTML 标准属性 attribute property 2 自定义属性 attribute 能够操作，但是不符合标准，导致网页代码通不过校验 3 HTML5 自定义属性规范 自定义属性名以 data- 开头，如 data-test 获取标准自定义属性有两种方式 如：data-test getAttribute(&#39;data-test&#39;) element.dataset.test 如：data-test-name getAttribute(&#39;data-test-name&#39;) element.dataset.testName 如果名称有多个以 - 连接的单词，使用驼峰","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"BOM","slug":"UI/BOM","date":"2020-11-08T13:09:25.000Z","updated":"2020-11-08T13:10:39.806Z","comments":true,"path":"2020/11/08/UI/BOM/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/BOM/","excerpt":"","text":"一 BOM 概述 Browser Object Model 浏览器对象模型，提供了独立于内容而与浏览器窗口进行交互的对象 BOM 由浏览器厂商各自定义，兼容性较差 BOM 包含 DOM BOM 都有一个顶级对象，不同的环境顶级对象也不同，浏览器环境是 window 二 window2.1 概述 window 是浏览器的顶级对象，是 JS 访问浏览器窗口的一个接口 window 是一个全局对象，定义在全局作用域的变量、函数都会变成 window 对象的属性和方法 2.2 属性 属性 说明 name 窗口名 innerWidth 窗口可视宽度 innerHeight 窗口可视高度 pageXOffset 页面的水平滚动距离 pageYOffset 页面的垂直滚动距离 document 返回 Document 对象 location 返回 Location 对象 navigator 返回 Navigator 对象 history 返回 History 对象 console 返回 Console 对象 screen 返回 Screen 对象 localStorage 本地储存的 localStorage 数据 sessionStorage 本地储存的 sessionStorage 数据 2.3 方法1 弹窗 方法 说明 alert(message) 提示框 confirm(message) 确认框 prompt([message,] value) 输入框 2 定时器 方法 说明 setTimeout(function [, time]) 指定时间后调用一次函数，time：毫秒值，默认为 0 即立即执行；通常会给定时器一个标识符，用于清除 clearTimeout(定时器标识符) 清除定时器 setInterval(function [, time]) 每隔指定时间调用一此函数 clearInterval(定时器标识符) 清除定时器 3 滚动 方法 说明 scrollTo(x-coord, y-coord ) 滚动到指定位置 scrollBy(x-coord, y-coord) 滚动指定距离 2.4 窗口 window 事件 事件 说明 beforeunload 窗口关闭前 unload 窗口关闭 load 窗口加载完毕，包含 dom 元素，图片，flash，css … DOMContentLoaded DOM 加载完毕，不包含其它，事件源为 document error 窗口加载失败 resize 窗口大小改变 scroll 滚动条滚动 三 Location3.1 属性 属性 权限 说明 href 读写 URL，格式 protocal://host[:port]/path/[?query] # fragment protocal 读写 协议 host 读写 主机，如果端口不是默认 80 433，则包含端口 hostname 读写 主机，不含端口 port 读写 端口 pathname 读写 资源路径 search 读写 参数，?key=value&amp;key=value hash 读写 片段，# 后面的内容，如链接 锚点 3.2 方法 方法 说明 assign(url) 重定向，记录浏览历史，可以回退，效果同 href 属性 replace(url) 重定向，不记录浏览历史，不能回退 reload([flag]) 无参或 false 表示刷新 F5，true 表示强制刷新 ctrl + F5 四 Navigator 属性 权限 说明 userAgent 只读 客户端发送给服务器的 user-agent 头部的值 五 History 方法 说明 back() 后退 forward() 前进 go(n) 0 表示刷新，正数表示前进 n 个页面，负数表示后退 n 个页面 六 本地存储（Storage）6.1 概述 数据存储在用户浏览器中，只能存字符串，以键值对的形式存储 Storage 下有两个子接口 localStorage 和 sessionStorage 6.2 属性 属性 说明 length 保存的数据项个数 6.3 方法 方法 说明 setItem(key, value) 存储数据 getItem(key) 获取数据 removeItem(key) 移除数据 clear() 清空 key(index) 返回指定索引的键，从 0 开始 6.4 sessionStorage &amp; localStorage 对象 生命周期 数据共享 容量 sessionStorage 一次会话（窗口关闭结束） 本页面 ≈ 5M localStorage 长期 本页面和其它页面 ≈ 20M","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"Promise","slug":"UI/Promise","date":"2020-11-08T13:09:19.000Z","updated":"2020-11-08T13:12:15.136Z","comments":true,"path":"2020/11/08/UI/Promise/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/Promise/","excerpt":"","text":"二 promise2.1 概述 Promise 对象本质上表示的是一系列操作的中间状态，或者说是未来某时刻一个操作完成或失败后返回的结果。 Promise 的回调函数不是正常的异步任务（宏任务），而是微任务（microtask） 正常异步任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常异步任务 2.2 promise 状态1 三种状态 pending ：初始状态，初始化 promise 时的状态 fulfilled：异步操作成功 rejected：异步操作失败 2 说明 fulfilled 和 rejected 统称 settled resolved promise 已经 settled promise 已经使用另一个promise（B）来resolve 此时promise的状态由B来决定，可能是pending fulfilled rejected 的任何一种 unresolved &amp; resolved unresolved ：promise的状态只能是pending resolved：promise的状态可能是pending、fulfilled、rejected 的任何一种 2.3 Promise API1 构造函数12345new Promise(executor)// executorfunction(resolve, reject) &#123;&#125;// 或(resolve, reject) =&gt; &#123;&#125; executor 指带有 resolve 和 reject 两个参数的函数 Promise构造函数执行时立即调用executor 函数 resolve 和 reject 是JavaScript 提供提供的两个函数 resolve被调用时，将promise的状态改为fulfilled reject被调用时，将promise的状态改为rejected 如果executor内部出错，将promise的状态改为rejected，且忽略executor返回值 2 静态方法 Promise.resolve(value) 返回一个以给定值解析后的Promise 对象。 value 如果该value值为promise，返回这个promise； 如果该value值是thenable（即带有”then” 方法），会将thenable对象包装为promise并返回; 否则，返回的promise将以此value值完成，即此promise的成功值是value，也就是then方法中第一个函数的参数。 Promise.reject(reason) 返回一个带有拒绝原因的Promise对象 reason 拒绝的原因，通常是一个Error对象，也就是then方法中第二个函数的参数 Promise.all(iterable)// TODO 注：iterable中非promise元素会被转为promise 如果参数是一个空的可迭代对象 返回一个已完成（already resolved）的 Promise。 此promise会调用成功回调函数，成功值是空数组 1234Promis.all([]).then( value =&gt; console.log(value), // [] reason =&gt; console.log(reason)); 2. 如果iterable参数不包含任何 promise 1. 返回一个异步完成（asynchronously resolved） Promise 2. 此promise会调用成功回调函数，成功值是由参数的元素构成的数组1234Promis.all(&quot;abc&quot;).then( value =&gt; console.log(value), // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;] reason =&gt; console.log(reason)); 3. 其它情况下返回一个处理中（pending）的Promise 1. 如果iterable参数中包含的所有promise都成功，则此返回的promise调用成功函数，成功值为一个数组，数组元素为所有promise的成功值和非promise的值1234567const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&apos;p1-success&apos;);&#125;);Promis.all([p1, 3, 4, &apos;abc&apos;]).then( value =&gt; console.log(value), // [&apos;p1-success&apos;,3,4,&apos;abc&apos;] reason =&gt; console.log(reason)); 2. 如果iterable参数中 包含的promise 有一个失败，则此返回的promise调用失败函数，失败原因是第一个失败的promise的原因1234567const p1 = new Promise((resolve, reject) =&gt; &#123; reject(&apos;p1-fail&apos;);&#125;);Promis.all([p1, 3, 4, &apos;abc&apos;]).then( value =&gt; console.log(value), reason =&gt; console.log(reason) // p1-fail); Promise.allSettled(iterable) 返回一个fulfilled状态的promise，成功值为一个对象数组，每个对象包含两个属性，表示对应的iterable元素的结果 12&#123;status: &quot;fulfilled&quot;, value: ...&#125;&#123;status: &quot;rejected&quot;, reason: ...&#125; Promise.race(iterable) 返回一个promise，此返回promise的状态取决于iterable参数中promise 成功/失败的最快的那个。 3 原型方法1 then1 语法1234567then(onFulfilled[, onRejected])then(value =&gt; &#123; // fulfillment&#125;, reason =&gt; &#123; // rejection&#125;) 2 参数 onFulfilled ，可选 当 Promise 变成fulfilled状态时调用的函数，参数为 fulfillment value，表示成功的值 如果onFulfilled不是一个函数，会被忽略，内部变成(value) =&gt; value，即将fulfillment value原样返回 onRejected，可选 当 Promise 变成rejected状态时调用的函数，参数为rejection reason，表示失败原因 如果onRejected不是函数，则会在内部被替换为一个 “Thrower” 函数，抛出失败原因 3 返回值 如果then没有参数，或者要执行的回调函数对应的参数不是一个函数，则返回的promise与原promise状态相同，且成功值和失败原因也相同。 如果then没有返回值，则返回的promise，状态为fulfilled，成功值为undefined 如果then返回一个值，则返回的promise，状态为fulfilled，成功值为返回的值 如果then抛出错误，则返回的promise，状态为rejected，失败原因为抛出的错误 如果then返回一个promise（三种状态都有可能），则可以当作是最终返回的promise，即状态，成功值或者失败原因都是一样的 内部返回值 最终返回promise状态 成功的值 失败原因 错误 rejected - 错误 无 fulfilled undefined - 非promise的值 fulfilled 非promise的值 - promise值 同promise值 同promise值 同promise值 2 catch1234catch(onRejected)catch(reason =&gt; &#123;&#125;) 等同于 then(undefined, onRejected) catch之前任一promise状态变为rejected，如果此promise自己没有处理，则会被catch捕获 catch返回一个promise，其状态取决于catch内部onRejected函数 如果onRejected返回一个rejected状态的Promise或着抛出一个错误，则catch返回的promise状态为rejected 否则，catch返回的promise状态为fulfilled 3 finally1234finally(onFinally)finally(() =&gt; &#123;&#125;) onFinally Promise 结束后，无论结果是fulfilled或者是rejected，都会执行onFinally回调函数 返回一个设置了 finally 回调函数的Promise对象 三 async / await3.1 概述 async/await 是promise 的语法糖 async用来声明一个异步函数（async function），await操作符只能用在异步函数中 3.2 async1234567891011async function show()&#123;&#125;let show = async function()&#123;&#125;let obj = &#123; async show()&#123;&#125;&#125;class xxx&#123; async show() &#123;&#125;&#125; 异步函数返回一个promise 如果异步函数正常执行，则返回的promise会调用成功函数，成功值为异步函数内部返回值。 如果异步函数抛出异常，则返回的promise会调用失败函数，失败原因是抛出异常 错误处理 async返回一个promise，可以调用catch来处理错误 3.3 await1[return_value] = await expression; await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成 如果表达式是一个promise，则返回值为promise的处理结果 如果表达式不是一个promise，则返回该值本身 错误处理 await后边的promise出错，相当于async函数返回的promise为reject，所以可以在外部调用catch方法处理 可以在内部用try…catch…处理 await的并行 让promise先执行后再使用await处理结果 使用 Promise.all() 处理多个promise并行执行","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"JS执行机制","slug":"UI/JS执行机制","date":"2020-11-08T13:09:13.000Z","updated":"2020-11-08T13:12:00.907Z","comments":true,"path":"2020/11/08/UI/JS执行机制/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/","excerpt":"","text":"一 概述 JavaScript 是单线程语言 单线程意味着，所有任务都需要排队，前一个任务结束，才会执行后一个任务 HTML 5 提出 Web Worker 标准，允许 JavaScript 创建多线程，于是 JS 中出现了同步和异步 二 JS 任务2.1 任务分类（类型）1 同步任务 在主线程上排队执行的任务，形成一个执行栈 前一个任务执行完毕，才能执行后一个任务 2 异步任务 JS 的异步是通过回调函数实现的 异步任务相关回调函数会进入任务队列（消息队列） 异步任务不具有“堵塞”效应 异步任务通常有三种 普通事件，如 click resize ... 资源加载，如 load, error ... 定时器 2.2 任务分类（机制）1 宏任务（macrotask） 整个脚本代码（第一个宏任务） 定时器（setTimeout setInterval ..） 事件 I/O UI 渲染 … 2 微任务（microtask） promise.then … 三 JS 执行机制3.1 概念 任务队列（task queue） 用于存放异步任务 根据异步任务的类型，可以存在多个任务队列 事件循环（Event Loop） 同步任务执行完毕后，引擎会在任务队列循环检查，如果有可以执行的异步任务，则结束等待状态，进入主线程开始执行 3.2 步骤 脚本代码作为第一个宏任务开始执行，同步任务进入主线程执行栈 异步任务（宏任务和微任务）交给各自异步处理进程，当满足条件时（如 事件触发，定时器到时…） 宏任务进入宏任务队列 macrotask queue 微任务进入微任务队列 microtask queue 同步任务执行完毕后，事件循环微任务队列，依次读入主线程执行栈并执行 微任务队列完毕后，事件循环宏任务队列，每个宏任务与第一个宏任务一样重复以上步骤 3.3 总结1234567891011// 有点类似递归的感觉* 宏任务 * 同步任务 * 异步任务 * 微任务 * 宏任务 * 同步任务 * 异步任务 * 微任务 * 宏任务 * ...","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"JS模块","slug":"UI/JS模块","date":"2020-11-08T13:09:06.000Z","updated":"2020-11-08T13:11:08.529Z","comments":true,"path":"2020/11/08/UI/JS模块/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/JS%E6%A8%A1%E5%9D%97/","excerpt":"","text":"一 概述 网上概述 ES6 之前有许多方式来实现模块 AMD：用于浏览器 CommonJS：用于 Node.js UMD：浏览器/Node.js ES6 JS有了模块 模块就是一个独立的文件，文件内部的变量，函数，类…外部无法获取 使用模块可以解决全局变量冲突 模块需要隐藏内部实现，只对外开发接口 模块可以避免滥用全局变量，造成代码不可控 模块可以被不同的应用使用，提高编码效率 模块默认运行在严格模式 模块都有独立的顶级作用域，不同模块间不能相互访问，类似函数作用域 模块在导入时只执行一次解析，之后的导入不会再执行模块代码，而使用第一次解析结果，并共享数据 三 加载1&lt;script type=&quot;module&quot;&gt;&lt;/script&gt; 异步加载，即模块总是会在所有html解析后才执行 四 export4.1 概述 模块中的功能默认外部无法使用，使用export命令规定模块的对面接口，即将指定功能导出供外部使用。 4.2 导出单个 export 声明语句 1234export let name = &apos;xiaoqiang&apos;;export let obj = &#123;&#125;;export function show() &#123;&#125;;export class User &#123;&#125; 4.3 导出列表 export { name1, name2, …, nameN }; 12345export let name = &apos;xiaoqiang&apos;;export let obj = &#123;&#125;;export function show() &#123;&#125;;export class User &#123;&#125;export &#123;name, obj, show, User&#125;; 4.4 别名 export { variable1 as name1, variable2 as name2, …, nameN }; 4.5 默认导出1234export default expression;export default function (…) &#123; … &#125; // also class, function*export default function name1(…) &#123; … &#125; // also class, function*export &#123; name1 as default, … &#125;; 默认导出接口只能有一个，但默认导出可以与普通导出共存 本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字 默认导出时，函数和类可以具名也可以匿名，变量不能具名 1234export default let a = 1; // 错误let a = 1;export default a; // 正确，相当于把a的值赋予defaultexport default 1; // 正确，相当于直接把值赋予default 五 import（静态导入）5.1 概述 import用于导入其它模块提供的功能。 import导入的变量名要与export导出的一致 import导入的变量是只读的 import命令具有提升效果，会提升到整个模块的头部，首先执行 import是静态导入，不能使用表达式和变量 在浏览器中引用模块必须添加路径，但在打包工具如webpack中则不需要，因为他们有自己的存放方式。 5.2 导入所有导出接口 import * as name from &quot;module-name&quot;; name 导入模块的命名空间 module-name 要导入的模块。通常是包含目标模块的.js文件的相对或绝对路径名，可以不包括.js扩展名。 使用default获取默认导出 5.3 导入指定导出接口 import { export1, export2, ..., exportN } from &quot;module-name&quot;; 5.4 别名 import { export1 as alias1, export2, ..., exportN } from &quot;module-name&quot;; 5.5 导入默认导出 import defaultExport from &quot;module-name&quot;; 导入默认导出时名称任意 由于默认导出只有一个，所以不需要{} 5.6 混合导入 import defaultExport, { export1, export2, ..., exportN} from &quot;module-name&quot;; 六 export default6.1 概述 使用import命令时，需要知道export导出的变量名。 export default 本质是导出一个名为defualt的变量，使用import导入时可以以任意名称导入。 一个模块只能有一个默认输出，可以与普通导出共存 6.2 语法 export default expression 将expression表达式的值赋给default导出 1234let a = 1;export default a; // 将a的值1赋给defaultexport default 1; // 将1赋给defaultexport default let a = 1; // 错误 因为let a = 1不能计算出一个值 export default function(){} // also class, function* 导出匿名函数/类，名称为default export default function name(…) { … } // also class, function* 导出具名函数/类，名称为default，原有名称会被忽略 export { name1 as default, … }; 由于 export default 本质是导出一个名为default的变量 可以使用export导出一个别名为default的变量 七 export + import7.1 概述 可以将导入的模块再次导出 如果export和import结合在一起，其实就相当于一个转发，并没有导入到当前模块，即当前模块不能使用导入导出的功能。 7.2 语法1234export * from …;export &#123; name1, name2, …, nameN &#125; from …;export &#123; import1 as name1, import2 as name2, …, nameN &#125; from …;export &#123; default &#125; from …; 八 import()（动态导入） 接收参数与静态导入一致 使用import() 函数可以动态导入模块，它返回一个 promise 对象，可以按需加载 import() 函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块 九 工具 转译器 Transpiler：将现代 JS 代码翻译成所有浏览器都能看懂的代码 Babel 打包器 Bundler WebPack","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"JS类","slug":"UI/JS类","date":"2020-11-08T13:09:01.000Z","updated":"2020-11-08T13:11:03.140Z","comments":true,"path":"2020/11/08/UI/JS类/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/JS%E7%B1%BB/","excerpt":"","text":"一 概述 class 只是语法糖，为了让类的声明与继承更加简洁清晰，底层实现机制依然是原型继承，与其它语言的 class 不一样 class 其实就是函数，typeof 类 -&gt; function class 内部代码始终以严格模式执行 class 不存在变量提升 class 中的属性名可以采用表达式[] class 中定义的属性都是实例属性，定义的方法都是原型方法且不可枚举 二 语法2.1 类1234567// 1 类声明class 类名 &#123;&#125;// 2 类表达式let 类名= class&#123;&#125;// 两种方式都不会提升 2.2 构造函数12345678910// 构造函数语法constructor(参数列表) &#123;&#125;// 基类默认构造函数constructor() &#123;&#125;// 派生类默认构造函数constructor(...args) &#123; super(...args);&#125; 使用类 new 一个对象时会自动调用构造函数 如果省略，则会有默认构造函数 constructor 默认返回实例对象（即 this），可以改为返回另一个对象 类的原型的 constructor 属性指向类本身：类.prototype.constructor = 类 2.3 属性 &amp; 方法1 实例属性 使用this. 定义在constructor中 12345class User &#123; constructor(age) &#123; this.age = age; &#125;&#125; 在类中直接定义的属性就是实例属性 123class User &#123; age = 18; &#125; 2 原型方法 在类的原型上定义方法，是可枚举的 1User.prototype.show = function()&#123;&#125; 在类中直接定义的方法就是原型方法，且不可枚举（non-enumerable） 123class User &#123; show()&#123;&#125;&#125; 3 静态属性/方法 定义在类上 12User.age = 10;User.show() = function()&#123;&#125;; 在类中定义的属性/方法前加static关键字 12345class User &#123; static age = 10; // 静态方法可以包含 this 关键字，this 指的是类本身，而不是实例对象 static show() &#123;&#125;&#125; 4 私有属性 / 方法1 利用 Symbol12345678910const _name = Symbol();const _show = Symbol();class User &#123; constructor(name) &#123; this[_name] = name; &#125; [_show]()&#123;&#125;&#125; 2 利用集合123456789const _name = new WeakMap();const _show = new WeakMap();class User &#123; constructor(name) &#123; _name.set(this, name); _show.set(this, () =&gt; &#123;&#125;); &#125;&#125; 3 约定 私有属性：在属性名前加 # 123class User &#123; #phone = '13800000000'; &#125; 私有方法：以表达式形式定义方法并在方法前加# ，可以理解为就是定义私有属性，不过属性的值是一个函数 123class User &#123; #say = function() &#123;&#125; &#125; 5 受保护属性 / 方法 在属性/方法名前加 _，这只是约定不是语法也不是规范 可以通过 symbol weakmap ... 人为实现保护 2.4 访问器 getter/setter 类中同样可以使用访问器，且访问器也是定义在属性的属性描述符上 三 class 的继承3.1 extends1234567891011class Fu &#123; constructor() &#123; &#125;&#125;class Zi extends Fu &#123; constructor() &#123; // 子类构造函数第一行必须先调用父类构造函数 super(); &#125;&#125; 3.2 super1 问题123456789// 1 子 父：在子类中调用父类方法子：this.__proto__.__proto__// 2 子 父 爷：在子类中调用父类方法，父类方法中又调用了父类的父类的方法子：this.__proto__.__proto__父：this.__proto__// 3 父 爷：直接在父类中调用父类的父类的方法父：this.__proto__.__proto__ 如果只有双层继承，使用 this是可以的，如果有多重继承，同一个类中的代码不同情况是不一样的 2 用法1 概述 super 只能在类或对象的方法中使用，而不能在函数中使用 使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。 12// 错误，无法看出是函数还是对象console.log(super); 2 调用父类构造12// 此时 super 代表父类的构造函数super([arguments]); 3 调用父类方法12// 此时 super 代表父类原型对象，如果是静态方法则 super 代表父类本身super.functionOnParent([arguments]); 3.3 原生构造函数的继承 之前，这些内置的构造函数如Object() Array() ... 是无法继承的 ES6 允许继承 3.4 mixin 创建一个 mixin 类，包含许多供其它类使用的方法 将 mixin 类合并到要使用功能的类的原型上","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"JS原型","slug":"UI/JS原型","date":"2020-11-08T13:08:56.000Z","updated":"2020-11-08T13:11:55.179Z","comments":true,"path":"2020/11/08/UI/JS原型/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/JS%E5%8E%9F%E5%9E%8B/","excerpt":"","text":"一 概述1.1 原型 1 __proto__ __proto__ 是浏览器实现的非 JavaScript 标准的属性，在ES6写入了附录，用于获取或设置对象的原型，由于非标准，浏览器有这个属性，其它环境未必有。建议使用 Object中 的方法 替代__proto__ 123- Object.getPrototypeOf(obj)- Object.setPrototypeOf(obj, prototype)- Object.create(proto[, propertiesObject]) obj.__proto__ 并非是普通的属性访问方式，而是通过 getter/setter 访问器，可以理解为 prototype 属性的 getter/setter 实现 每个对象都有 __proto__ 属性，指向它的构造函数的原型对象，即如果A对象是由B函数构造的，则 A.__proto__ === B.prototype 普通对象的构造函数是其对应的构造函数，原型对象也是普通对象，其默认构造函数是 Object，则 对象.__proto__ === 构造函数.prototype 原型对象.__proto__ === Object.prototype 原型对象中有两个特殊 Object.prototype：它是原型链的顶端，Object.prototype.__proto__ === null Function.prototype 它是原型对象，但不属于普通对象而属于函数对象 它是函数对象，但它没有 prototype 属性 函数对象（包括 Function 自身）的构造函数是 Function，则 函数.__proto__ === Function.prototype Function.__proto__ === Function.prototype 2 prototype 每个构造函数都有 prototype 属性，指向其原型对象，原型对象用于所有实例共享属性和方法 函数作为对象有 __proto__ 属性，又可以作为构造函数有prototype 属性 原型的作用是让该构造函数所实例化的对象们都可以找到公用的属性和方法，所以 JS 的继承是通过 prototype 实现的 3 constructor 只有原型对象才有 constructor 属性，指向对应构造函数 实例对象.__proto__ === 原型对象 构造函数.prototype === 原型对象 原型对象.constructor === 构造函数 1.2 原型链 对象有自己的原型对象，而对象又可以充当其他对象的原型，就会形成一个“原型链”（prototype chain） 1.3 new1 new的执行过程 创建一个空对象 let obj = {}; 将新建对象的 __proto__ 指向构造函数的原型对象，obj.__proto__ = 构造函数.prototype 将新建对象作为构造函数执行的上下文，即将构造函数内部的 this 指向新建对象 执行构造函数，如果构造函数没有返回引用类型的值，则返回新建对象 2 自定义 new1234567let myNew = function(cons, args) &#123; let obj = &#123;&#125;; // 步骤1 obj.__proto__ = cons.prototype; // 步骤2 // let obj = Object.create(cons.prototype); 步骤1，2合在一起 let result = cons.apply(obj, args); // 步骤3 return result instanceof Object ? result : obj; // 步骤4&#125;; 3 new.target 属性 用来检测函数是否通过new或者Reflect.construct()调用的 如果在普通函数中使用，返回 undefined 在构造函数中使用指向被 new 调用的构造函数 在 class 的 constructor 函数中使用指向被 new 调用的 class 二 构造函数中的属性和方法12345678910function User(name) &#123; let age = 18; // 私有属性 let test = function()&#123;&#125;; // 私有方法 this.name = name; // 实例属性 this.show = function()&#123;&#125;// 实例方法&#125;User.country = '中国'; // 静态属性User.sayHello = function()&#123;&#125;; // 静态方法User.prototype.gender = '男'; // 原型属性User.prototype.change = function()&#123;&#125;; // 原型方法 概念 说明 私有属性 / 方法 在对象内部使用 var/let/const声明的属性/方法（严格来说只是内部的局部变量不属于对象） 实例属性 / 方法 在对象内部使用this.声明的属性/方法 静态属性 / 方法 定义在构造函数上的属性/方法 原型属性 / 方法 定义在构造函数原型上的属性/方法 ，原型方法默认可枚举 三 继承3.1 继承原理 1 -&gt; 2：将子类构造函数的原型对象的原型指向父类构造函数的原型对象 3.2 设置原型方式 设置构造函数原型，使用函数的 prototype 属性 设置对象的原型 Object 的方法，创建对象时指定原型（只是定义无法获取）：Object.create(proto[, propertiesObject]) 使用对象的属性__proto__ 获取或设置原型，在浏览器之外的环境可能不行。 Object 的方法，与__proto__效果一样，但是是 JS 标准 12Object.getPrototypeOf(obj)Object.setPrototypeOf(obj, prototype) 3.3 实现继承的方式1 原型链-1 1A.prototype.__proto__ = B.prototype; 将子类构造函数的原型对象的原型直接指向父类构造函数的原型 好处 父类原型在子类原型链上，则子类可以继承父类的原型属性/方法 弊端 创建子类时不会调用父类构造函数，无法继承父类的实例属性/方法 2 构造函数 在子类构造函数中通过call/apply调用父类构造函数，并指定this为子类对象 12345678910function Fu(name, age) &#123; this.name = name; this.age = age; this.show = function()&#123;&#125;;&#125;;function Zi(name, age) &#123; Fu(name,age); // 不行，因为直接调用时，父类构造函数this是指向window的 Fu.call(this, name, age); Fu.apply(this, [name, age])&#125; 好处 创建的子类实例具备父类实例属性/方法 弊端 只是子类的实例，不是父类的实例（只是通过调用父类构造函数模拟继承） 无法继承父类原型属性/方法 3 原型链-21 说明 1A.prototype = new B(); 将子类构造函数的原型对象修改为一个父类实例（舍弃原有原型对象） 好处 父类实例对象具有父类的实例属性/方法，父类实例对象的原型又指向父类构造函数原型，所以父类的实例属性/方法 和 原型属性/方法，子类都可以继承 弊端 父类的实例属性/方法是在子类原型对象上，这就导致父类的实例属性/方法实际上变成了子类的原型属性/方法。 需要手动为新的子类原型对象添加 constructor属性 2 对新增对象的影响 如果新增对象在修改原型操作之前，那就意味着，新增对象指向的原型还是原来被舍弃的原型，所以这种方式只对修改原型操作之后新增的对象有效 3 对constructor的影响 由于这种方式是将子类原型修改成了一个新的对象，而这个新对象中是没有constructor属性的，所以需要手动为新对象添加constructor属性，并指向子类构造函数 直接添加（有一个弊端，就是constructor属性默认可遍历） 1A.prototype.constructor = A; 使用Object的 defineProperty() 添加 1234Object.defineProperty(A.prototype, \"constructor\", &#123; value: A, enumerable: false&#125;); 4 组合继承1（构造函数+原型链2）123456789101112function B(name) &#123; this.name = name;&#125;B.prototype.gender = 'nan';B.prototype.eat = function() &#123;&#125;;function A(age) &#123; B.call(this, '小猫'); // 第一次调用 this.age = age;&#125;A.prototype = new B('小狗'); // 第二次调用A.prototype.constructor = A; 好处 通过构造函数方式可以继承到父类的实例属性/方法 通过原型链方式可以继承到父类的原型属性/方法 弊端 父类的实例属性会在子类实例和子类原型上都定义一份，不过不影响，因为会先使用实例自己的属性 会调用两次父类构造函数 需要手动为新的子类原型对象添加 constructor属性 子类原有的原型对象上的属性和方法没有了 5 组合继承2（构造函数+原型链1）1234567891011function B(name) &#123; this.name = name;&#125;B.prototype.gender = 'nan';B.prototype.eat = function() &#123;&#125;;function A(age) &#123; B.call(this, '小猫'); this.age = age;&#125;A.prototype.__proto__ = B.prototype 好处 通过构造函数方式可以继承到父类的实例属性/方法 通过原型链方式可以继承到父类的原型属性/方法 弊端 __proto__ 在浏览器之外的环境可能不行。 B.prototype 中的 constructor 指向的是父类构造函数 6 最终方式12345678910111213141516171819// 父类function B(name) &#123; this.name = name;&#125;B.prototype.gender = 'nan';B.prototype.eat = function() &#123;&#125;;function A(age) &#123; // 1 继承父类实例属性/方法 B.call(this, '小猫'); this.age = age;&#125;// 2 设置子类原型对象A.prototype = Object.create(B.prototype);// 3 为子类原型对象添加 constructorObject.defineProperty(A.prototype, \"constructor\", &#123; value: A, enumerable: false&#125;); 3.4 对象工厂12345678function Fu(name)&#123; this.name = name;&#125;function createObj(...args) &#123; const obj = Object.create(Fu.prototype); Fu.call(obj, ...args); //通过调用父类 return obj;&#125; 与继承方式类似，只是通过对象工厂创建子类对象，不需要子类构造函数 创建一个以父类原型为原型的对象，相当于继承了父类原型属性/方法 调用父类构造函数，并设置this为新建对象，即相当于继承了父类实例属性 返回新建对象 3.5 静态属性/方法的继承 静态属性/方法即在构造函数上定义的属性/方法，继承原理都是一样的，函数也是对象，把子类构造函数看作对象，设置其原型为父类构造函数，即可继承静态属性/方法 1234567function Fu() &#123;&#125;Fu.haha = \"wangcai\";Fu.show = function() &#123; console.log('fu static show')&#125;function Zi() &#123;&#125;Zi.__proto__ = Fu; 3.6 Mixin 模式 JS 不支持多继承，也没有接口实现，如果要使用多个类的方法时可以使用 mixin 混合模式来完成 Mixin模式 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口 Mixin 可以看作是一个包含许多功能的对象，使用时将这些功能合并到要使用功能的对象原型上即可 例 12345678910let myMix = &#123; sayHi() &#123;&#125;, sayBye() &#123;&#125;, eat()&#123;&#125;&#125;;function User() &#123;&#125;// 合并之后，User的实例就有了myMix的所有功能了Object.assign(User.prototype, myMix);// 手动添加某个功能User.prototype.eat = myHix.eat;","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"JS闭包","slug":"UI/JS闭包","date":"2020-11-08T13:08:50.000Z","updated":"2020-11-08T13:10:52.134Z","comments":true,"path":"2020/11/08/UI/JS闭包/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/JS%E9%97%AD%E5%8C%85/","excerpt":"","text":"一 概述1.1 作用域 函数作用域内可以访问全局变量，函数作用域外不能访问函数作用域中的局部变量 函数执行完毕（弹栈），函数作用域中的变量也随之销毁 作用域是临时的，而闭包是永久的 1.2 闭包 closure 有一个单独的作用域，此作用域中定义一个函数，则这个函数与它能在此作用域中所有能访问的变量构成了闭包。在此作用域外调用函数时，函数能够使用此作用域中的变量 闭包可以在外部作用域中访问到函数作用域中的局部变量，延长了变量的生命周期和作用范围 二 如何形成闭包2.1 条件 单独的作用域：为了创建局部变量 内部定义一个函数：形成闭包 在外部访问函数 2.2 例12345678function outer() &#123; let i = 0; return function() &#123; console.log(i++); &#125;&#125;let inner = outer(); // 执行外部函数，返回内部函数inner(); // 外部函数执行完毕后，依然可以访问到外部函数中的变量 三 应用3.1 事件12345678910111213141516// 有 5 个 li ，添加点击事件，打印索引for(let i = 0; i &lt; 5; i++) &#123; lis[i].onclick = function() &#123; console.log(i); // 最终结果每个 li 都打印 4，因为循环是同步的，而点击事件是异步的 &#125; &#125;// 利用闭包for(let i = 0; i &lt; 5; i++) &#123; (function(index)&#123; lis[i].onclick = function() &#123; console.log(index); &#125; &#125;)(i);&#125;// 1. 立即执行函数是一个单独作用域// 2. 事件处理函数和立即执行函数中的局部变量 index 形成了闭包 3.2 定时任务12345678910111213for(let i = 0; i &lt; 5; i++) &#123; setTimeout(function()&#123; console.log(i);// 最终结果都打印 4，因为循环是同步的，而定时任务是异步的 &#125;);&#125;// 利用闭包------for(let i = 0; i &lt; 5; i++) &#123; (function(index)&#123; setTimeout(function()&#123; console.log(index); &#125;); &#125;)(i);&#125;","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"JS内置对象","slug":"UI/JS内置对象","date":"2020-11-08T13:08:44.000Z","updated":"2020-11-08T13:11:14.669Z","comments":true,"path":"2020/11/08/UI/JS内置对象/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/JS%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"一 Math1.1 静态属性 静态属性 说明 Math.E 欧拉常数 e Math.PI π 1.2 静态方法 静态方法 说明 Math.abs(x) 绝对值 Math.ceil(x) 向上取整 Math.floor(x) 向下取整 Math.pow(x, y) 返回 x 的 y 次幂 Math.random() 返回 [0-1)之间的伪随机数 Math.round(x) 四舍五入 Math.sqrt(x) 平方 Math.log(x) 对数 Math.exp(x) e 的指数，即 ex Math.min([value1[,value2, ...]]) 返回一组数字中的最小值。如果有任一参数不能转换为数值，则返回 NaN Math.max(value1[,value2, ...]) 返回一组数字中的最大值。如果有任一参数不能转换为数值，则返回 NaN Math.sin(x) 正弦 Math.cos(x) 余弦 Math.tan(x) 正切 二 Date2.1 构造函数 方法 类型 说明 Date([value]) 普通函数 无论有没有参数，都返回当前日期和时间的字符串 new Date() 构造函数 创建一个当前日期和时间的 Date 对象 new Date(stamp) 构造函数 创建一个指定时间戳的 Date 对象 new Date(dateString) 构造函数 创建一个 Date 对象，时间由 dateString 决定，该字符串能被 Date.parse()正确识别 2.2 静态方法 静态方法 说明 Date.now() 返回当前时间距离时间零点的毫秒数 Date.parse(dateString) 解析日期字符串，返回该时间距离时间零点的毫秒数 2.3 原型方法 Date.prototype.1 to 原型方法 说明 toString() 返回日期时间字符串字符串 toLocaleString() 返回本地日期时间字符串 toUTCString() 返回 UTC 日期时间字符串 toISOString() 返回 ISO8601 写法的日期时间字符串，通常用于网络服务 toJSON() 与toISOString()方法的返回结果完全相同 2 get 原型方法 说明 getTime 返回距离事件元点的毫秒数 getFullYear 年（四位数） getMonth() 月 0-11 getDate() 日 1-31 getDay() 星期 0-6 getHours() 时 0-23 getMinutes() 分 0-59 getSeconds() 秒 0-59 getMilliseconds() 毫秒 0-999 3 set set 与 get 一一相对应，除了没有 setDay()，因为星期是算的 三 RegExp3.1 构造函数 方法 说明 new RegExp(pattern [, flags]) 创建 RegExp 对象，flags：可以是g i m u y s的任意组合 RegExp() 同 new RegExp() 3.2 字面量 /pattern/flags / 斜杠表示开始和结束 3.3 原型属性 RegExp.prototype. 原型属性 权限 说明 global 只读 返回一个布尔值，判断是否设置了修饰符g ignoreCase 只读 返回一个布尔值，判断是否设置了修饰符i multiline 只读 返回一个布尔值，判断是否设置了修饰符m unicode 只读 返回一个布尔值，判断是否设置了修饰符y sticky 只读 返回一个布尔值，判断是否设置了修饰符y dotAll 只读 返回一个布尔值，判断是否设置了修饰符s flags 只读 返回一个字符串，包含已经设置的所有修饰符，按字母排序 source 只读 返回正则表达式文本字符串，该字符串不包含正则字面量两边的斜杠以及任何的标志字符 lastIndex 读写 指定下一次匹配的起始索引。正则表达式必须有 g 3.4 原型方法 RegExp.prototype. 原型方法 说明 test(str) 判断是否匹配，会更新正则对象的 lastIndex 属性 exec(str) 返回一个包含匹配项的数组（包含附加属性），若匹配失败返回 null，并将 lastIndex 重置为 0 四 JSON4.1 语法 属性：必须是双引号括起来的字符串；最后一个属性后不能有逗号 基本类型的值 字符串 数值（必须十进制，NaN 不行） 布尔值 null（ undefined 不行） 引用类型的值 数组 对象 4.2 静态方法 JSON.stringify(value[, replacer [, space]]) 将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被parse()方法还原。 value 要被序列化的对象 如果对象有自定义的toJSON()方法，那么JSON.stringify()会使用toJSON()方法的返回值作为参数 replacer 如果是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的处理 如果是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中 space： 指定缩进用的空白字符串，用于美化输出（pretty-print）增加可读性。 如果是数字，表示每个属性前面添加的空格（不超过10个） 如果是字符串（不超过10个字符），则该字符串会添加在每行前面 JSON.parse(text[, reviver]) 将 JSON 字符串转换成对应的对象 reviver(currentKey, currentValue) 转换器，此函数调用时机在 parse 函数返回之前，用于在返回之前对所得到的对象执行操作 转成的对象的所有属性都会调用 reviver 函数，并且会将 reviver 返回值作为新的属性值，如果 reviver 返回 undefined，会删除当前属性 五 Error5.1 概述 当代码运行时的发生错误，会创建新的Error 对象，并将其抛出 5.2 构造函数 new Error([message]) 5.3 原型属性 message 错误信息 name error 类型的名称.初始值为 Error 5.4 其它类型的错误构造函数 类型 错误原因 EvalError 与 eval() 有关 RangeError 数值变量或参数超出其有效范围 ReferenceError 无效引用 SyntaxError 语法错误 TypeError 变量或参数不属于有效类型 URIError 给 encodeURI() 或 decodeURl() 传递的参数无效 六 集合6.1 Set1 概述 Set 中的元素有序（存取顺序一致） 唯一 可以存储基本数据类型和引用数据类型（包括 NaN undefined null） 判断元素相等： 基于 sameValueZero 算法 类似 ===，除了 NaN，NaN === NaN 返回 false，但是在 Set 中看作相等 2 构造函数 new Set([iterable]) iterable 可迭代对象，它的所有元素将不重复地被添加到 Set 中。 如果省略或其值为 null，则新的 Set 为空 3 原型属性 Set.prototype. 原型属性 说明 size Set 集合的元素个数 4 原型方法 Set.prototype. 原型方法 说明 add(value) 向 Set 末尾添加元素，返回 Set delete(value) 从 Set 中删除指定元素，成功删除返回 true，否则返回 false has(value) 判断 Set 中是否有指定的元素 clear() 清空 Set keys() 由于 Set 结构没有键只有值，keys() 与 values() 完全一样 values() 返回值的迭代器对象，值就是 Set 元素 entries() 返回键值对的迭代器对象，键值对形式为[value, value]，Set 中的元素即是键也是值 forEach(callback[, thisArg]) 遍历 Set，按插入顺序依次执行回调函数 callback([currentValue[, currentKey[, set]]]) currentValue 当前元素 currentKey 由于 Set 没有键，currentKey 与 currentValue 永远都一样，也是当前元素 set 当前Set 5 Set ↔ 数组 方式 转换 说明 [...set] Set → 数组 展开语法，可以展开可迭代对象 Array.from(set) Set → 数组 数组静态方法，将可迭代对象转为数组 new Set(arr) 数组 → Set Set 构造方法，将数组转为 Set 6.2 WeakSet 用法同 Set 大致相同 与 Set 的区别 WeakSet 只能存引用数据类型 WeakSet 是弱引用 当对象引用数量为 0 时，会被垃圾回收掉，弱引用的意思就是不会增加对象的引用数量。 WeakSet 不可遍历 因为WeakSet 是弱引用，其中的对象随时有可能别垃圾回收掉 没有size 属性 原型方法只有 add() delete() has() 6.3 Map1 概述 Map 是键值对的集合，且键有序（存取一致） 对象的键只能是字符串，Map 的键可以是任何值 如果键相等，后边的值回覆盖前边 判断键相等 基于 sameValueZero 算法 类似 ===，除了NaN，NaN === NaN返回 false，但是在 Map 中看作相等 2 构造函数 new Map([iterable]) iterable 可迭代对象，其元素为键值对。 如数组为 [[&#39;name&#39;,&#39;xiaoming&#39;],[&#39;age&#39;,18]] 3 原型属性 Map.prototype. 原型属性 说明 size Map 集合中键值对的个数 4 原型方法 Map.prototype. 原型方法 说明 set(key, value) 向 Map 添加键值对，返回 Map get(key) 根据 key 获取 value，没有返回 undefined delete(key) 根据 key 删除键值对，删除成功返回 true，否则返回 false clear() 清空 Map has(key) 判断指定 key 的元素是否存在 keys() 返回键的迭代器对象 values() 返回值的迭代器对象 entries() 返回键值对的迭代器对象，键值对形式为[key, value] forEach(callback[, thisArg]) 遍历 Map，按键插入顺序依次执行回调函数 5 Map ↔ 数组 方式 转换 说明 [...map] Map → 数组 展开语法，可以展开可迭代对象 Array.from(map) Map → 数组 数组静态方法，将可迭代对象转为数组 new Map([[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]]) 数组 → Map 将一个二维键值对数组转换成一个 Map 对象 6.4 WeakMap 用法同Map大致相同 与Map的区别 WeakMap 的键只能是引用数据类型（不能为 null ） WeakMap 的键是弱引用 WeakMap 不能遍历 WeakMap 没有size属性 WeakMap 原型方法只有 set() get() delete() has()","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"JS引用类型-函数","slug":"UI/JS引用类型-函数","date":"2020-11-08T13:08:36.000Z","updated":"2020-11-08T13:11:33.026Z","comments":true,"path":"2020/11/08/UI/JS引用类型-函数/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/JS%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-%E5%87%BD%E6%95%B0/","excerpt":"","text":"一 概述 每个 JavaScript 函数都是一个 Function 实例 函数作为对象中的属性通常称为方法 二 定义函数2.1 方式1 函数声明123function 函数名(参数列表) &#123; 函数体&#125; 函数提升（提升优先级高于 var 变量提升），所以可以在定义函数之前的位置调用函数 声明的函数会添加到 window 对象中 优先级高于函数表达式 2 函数表达式123var/let/const 函数名 = function (参数列表) &#123; 函数体&#125; var 会有变量提升，但不会赋值，即相当于函数没有提升，所以不可以在定义函数之前的位置调用函数 var 声明的函数会添加到 window 对象中，但 let/const 则不会 3 Function 构造函数1var/let/const 函数名 = new Function(&quot;参数列表&quot;,&quot;函数体&quot;); var 会有变量提升，但不会赋值，即相当于函数没有提升 var 声明的函数会添加到 window 对象中，但 let/const 则不会 2.2 参数1 概述 形参 parameter ；实参 argument 形参是默认声明的，不需用 var/let/const 修饰 实参数量小于形参时，没有传递的形参值为 undefined 实参数量大于形参时，多余的实参将忽略并不会报错 在形参上可以直接定义参数默认值，当对应实参没有值或值为 undefined 时，使用默认值 1function sum(a, b = 2) &#123;&#125; 2 arguments arguments 对象是一个类数组对象，存储了传递的所有实参 arguments 是所有函数中都可用的局部变量，箭头函数除外 3 剩余参数1 概述 剩余参数是一个数组，用于接收形参外的所有参数（类似于 java 可变参数） 剩余参数必须是最后一个参数 2 语法123function(a, b, ...theArgs) &#123; // ...&#125; 4 剩余参数和 arguments 对象的区别 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。 arguments 对象不是一个真正的数组，而剩余参数是真正的 Array 实例，即剩余参数可以使用所有的数组方法 三 立即执行函数 IIFE3.1 概述 Imdiately Invoked Function Expression 不必为函数命名 形成单独的作用域，封装遍历，避免重名… 3.2 语法123456789// 1( function(形参列表)&#123;&#125;(实参列表))// 2( function(形参列表)&#123;&#125;)(实参列表) 四 箭头函数（lambda）4.1 概述 箭头函数内部的this 是固定的，指向定义时所在的环境的 this 箭头函数不可以当作构造函数，也就是说，不可以使用 new 命令 箭头函数内部不存在 arguments 对象 箭头函数不可以使用yield命令，因此箭头函数不能用作 Generator 函数 4.2 语法 基础语法 1(param1, param2, …, paramN) =&gt; &#123; statements &#125; 没有参数 1() =&gt; &#123; statements &#125; 当且仅当只有一个参数时，小括号可以省略 1singleParam =&gt; &#123; statements &#125; 函数体只有一句且是返回语句时，return、分号和大括号都可以省略 123456(param1, param2, …, paramN) =&gt;&#123; return expression; &#125;// 简写(param1, param2, …, paramN) =&gt; expression// 注意：如果返回的是一个对象，要用()包括，因为&#123;&#125;会被认为是一个代码块(param1, param2, …, paramN) =&gt; (&#123;name: 'xiaoming'&#125;) 五 Function5.1 构造函数 new Function (variableStr, functionBodyStr) variableStr 形参字符串，字符串中多个参数用逗号分隔 functionBodyStr 函数体的字符串 5.2 实例属性 实例属性 说明 length 函数的形参个数 name 函数的名称 5.3 原型方法 Function.prototype. 原型方法 说明 作用 call(thisArg, arg1, arg2, ...) 使用指定的 this 值和实参列表来调用此函数 执行函数 apply(thisArg, [argsArray]) 同call()，不同的是接受的是一个实参数组 执行函数 bind(thisArg[, arg1[, arg2[, ...]]]) 使用指定的 this 和实参列表创建一个原函数的拷贝并返回，bind 实参优先级高于调用实参 创建函数","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"JS引用类型-数组","slug":"UI/JS引用类型-数组","date":"2020-11-08T13:08:32.000Z","updated":"2020-11-08T13:11:38.810Z","comments":true,"path":"2020/11/08/UI/JS引用类型-数组/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/JS%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-%E6%95%B0%E7%BB%84/","excerpt":"","text":"一 概述 数组都是 Array 的实例 数组可以存任意类型的数据 数组长度可变 ES6 明确数组中空位值为 undefined 二 数组管理2.1 创建数组1234// 1 数组字面量let arr = [ele0, ele1, ..., eleN];// 2 Array 构造函数 2.2 清空数组1234567891011121314151617// 1 将原数组指向一个空数组let arr = [1,2,3];arr = [];// 2 将数组长度置为 0let arr = [1,2,3];arr.length = 0;// 3 使用 splice() 方法let arr = [1,2,3];arr.splice(0, arr.length);// 4 循环一个个删let arr = [1,2,3];while (arr.length &gt; 0) &#123; arr.pop(); &#125; 三 Array3.1 构造函数 方法 说明 new Array(arrayLength) 创建一个指定长度的数组，arrayLength ：0-232-1 之间的整数 new Array(ele0, ele1[, ...[, eleN]]) 创建一个包含指定元素的数组 Array(...) 和 new Array(...) 是等同的 3.2 实例属性 实例属性 权限 说明 length 读写 数组元素个数 3.3 静态方法 Array.isArray(obj) 如果值是 Array，则返回true，否则返回false 用来弥补typeof，因为typeof 数组 返回的是object Array.of(element0[, element1[, ...[, elementN]]]) 将一组值转换为数组 用来弥补构造函数，构造函数参数个数不同会导致结果不同。 Array.from(arrayLike[, mapFn[, thisArg]]) 从一个类数组对象或可迭代对象创建一个新的浅拷贝的数组实例并返回 mapFn 如果指定了该参数，新数组中的每个元素都会执行该回调函数 thisArg 执行回调函数 mapFn 时的 this 对象 3.4 原型方法1 获取 valueOf() 返回数组本身 toString() 返回数组的字符串形式 join([separator]) 以指定分隔符（默认为逗号）将所有数组成员连接为一个字符串返回 2 增删改 push(element1, ..., elementN) 将一个或多个元素添加到数组的末尾，并返回该数组的新长度，改变原数组 如果参数为数组，把数组作为元素添加到数组中。(二维数组) pop() 删除并返回最后一个元素，改变原数组 unshift(element1, ..., elementN) 将一个或多个元素添加到数组的开头，并返回该数组的新长度，改变原数组 参数可以是数组（二维数组） shift() 删除并返回第一个元素，改变原数组 fill(value[, start[, end]]) 使用指定值填充数组，可指定开始结束索引，返回修改后的数组 splice(start[, deleteCount[, item1[, item2[, ...]]]]) 删除目标数组的一部分成员，并可以在删除的位置添加新的数组成员，返回被删除的元素组成的数组，改变原数组 slice([begin[, end]]) 提取目标数组的一部分，返回一个浅拷贝新数组，原数组不变 concat(value1, value2, ..., valueN) 将一个或多个值合并到数组中，返回新数组，不改变原数组 copyWithin(target[, start[, end]]) 复制数组的一部分到数组指定位置（覆盖原有成员），并返回数组，改变原数组但不改变数组长度（因为会覆盖原有成员） target 目标位置 start 复制的起始索引，默认为0 end 复制的终止索引（不含），默认为尾部 flat([depth]) 将数组降维，返回新数组，不改变原数组 depth 指定结构深度，默认值为 1，即只可以将二维数组合并成一维数组 flatMap(callback[, thisArg]) 对数组中每一个元素执行回调函数，然后对返回值组成的数组执行flat()方法，结构深度 depth 值为1，返回新数组 callback(currentValue[, index[, array]]) currentValue：当前遍历的元素 index：当前遍历到的索引 array：当前数组 3 查 indexOf(searchElement[, fromIndex]) 返回第一个匹配索引，如果不存在，则返回 -1 lastIndexOf(searchElement[, fromIndex]) 返回从后往前的第一个匹配索引，如果不存在，则返回 -1 includes(valueToFind[, fromIndex]) 判断数组是否包含指定元素 find(callback[, thisArg]) 返回数组中第一个满足所提供测试函数（返回true）的元素的值，否则返回 undefined callback(element[, index[, array]]) element：当前遍历的元素 index：当前遍历到的索引 array：当前数组 thisArg 执行回调时函数时this 指向的对象。 findIndex(callback[, thisArg]) 返回数组中第一个满足所提供测试函数（返回true）的元素的索引，否则返回 -1 4 排序 reverse() 反转数组并返回，改变原数组 sort([compareFunction]) 默认是按照字典顺序排序，返回排序后的数组，改变原数组 compareFunction(value1, value2) 返回一个数字，如果小于0则value1排在value2之前 5 循环遍历 forEach(callback[, thisArg]) callback(currentValue[, index[, array]]) currentValue：当前遍历的元素 index：当前遍历到的索引 array：当前数组 keys() 返回数组元素键的迭代器对象 values() 返回数组元素值的迭代器对象 entries() 返回数组元素键值对的迭代器对象 6 扩展方法 every(callback[, thisArg]) 判断数组元素是否全部能通过指定测试函数，返回布尔值，一个元素返回 false，则 every()立即返回 false callback(currentValue[, index[, array]]) currentValue：当前遍历的元素 index：当前遍历到的索引 array：当前数组 some(callback[, thisArg]) 数组中有至少一个元素通过回调函数的测试就会返回 true； filter(callback[, thisArg]) 返回一个新的由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组 map(callback[, thisArg]) 对数组中每一个元素执行回调函数，返回每一个回调函数结果组成的新数组 reduce(callback[, initialValue]) 返回回调函数累计处理的结果 callback(accumulator, currentValue[, index[, array]]) accumulator 第一次循环 有initialValue，则为initialValue 无initialValue，则为数组第一个元素 从第二次循环往后为回调函数返回值 currentValue 数组中当前循环的元素 第一次循环时，如果没有initialValue，由于accumulator是数组第一个元素，则currentValue会从第二个元素开始循环 index 数组中当前循环的元素的索引 array 当前数组 reduceRight(callback[, initialValue]) 与reduce()相似，只是从右向左遍历数组","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"JS引用类型-对象","slug":"UI/JS引用类型-对象","date":"2020-11-08T13:08:26.000Z","updated":"2020-11-08T13:11:27.392Z","comments":true,"path":"2020/11/08/UI/JS引用类型-对象/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/JS%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"一 创建对象1.1 Object 构造函数1new Object([value]) 1.2 对象字面量1 概述 对象字面量内部调用了 Object 的构造函数 对象字面量与 json 的区别 json 属性只能是字符串 json 值不能是函数和 undefined 2 语法123456789101112131415161718192021222324252627282930// 1 标准形式let obj = &#123; key: value, key: function()&#123;&#125; ...&#125;;// 2 方法定义可以简化let obj = &#123; key: value, key()&#123;&#125; ...&#125;;// 3 如果属性名是一个表达式，则使用[]包裹，意思是取表达式的值let obj = &#123; [expr]: value, key()&#123;&#125; ...&#125;;// 4 如果属性名和属性值与外部变量名和值都相同，可以简写let name = \"mm\";let obj = &#123; name: name, // 可以简写 name, key()&#123;&#125; ...&#125;; 1.3 Object 的 create 方法12// 这种方式可以指定原型Object.create(proto[, propertiesObject]) 1.4 构造函数1 内置构造函数1234new Array()new Function()new String()... 2 自定义构造函数12345678// 1 定义构造函数，构造函数名首字母大写function 构造函数名(形参列表) &#123; this.属性 = 值; this.方法 = function() &#123;&#125;&#125;// 2 使用自定义构造创建对象new 构造函数名(实参列表); 1.5 工厂函数123456789101112function userFactory(name) &#123; let obj = &#123;&#125;; // 1 obj.name = name; obj.show = function()&#123;&#125;; return obj; // 2 简写 return &#123; name, show()&#123;&#125; &#125;;&#125; 与自定义构造函数方式的区别 工厂函数是函数调用，自定义构造是 new 工厂函数是函数名称小写，自定义构造名称大写 工厂函数内部需要显式创建一个对象，然后根据参数赋值后再显式返 自定义构造根据参数自动创建一个对象并返回 二 对象属性2.1 属性描述符1 概述 property descriptor JS 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为属性描述符，或者叫属性描述对象 元属性：属性描述符中的属性，用来描述对象属性的元信息，即描述对象属性的属性 2 分类（只能取其一） 分类 可以具有的元属性 数据描述符 configurable enumerable value writable 存取描述符 configurable enumerable get set 3 元属性 元属性 说明 默认值 value 表示该属性的值 undefined writable 表示该属性是否可写 true enumerable 表示该属性是否可遍历 true configurable 1 该属性是否可删除2 该属性的属性描述符是否可修改 true get 表示该属性的取值函数 getter undefined set 表示该属性的存值函数 setter undefined 2.2 属性管理1 读写 方式 说明 obj.property 必须是确定的属性名，且名称不特殊（数字、空格…） obj[&#39;property&#39;] 属性名可以是表达式和变量，或者名称比较特殊 2 判断 方式 说明 prop in obj 对象中是否有指定属性 3 删除 方式 说明 delete object.property 删除属性，所有情况都返回 true delete object[&#39;property&#39;] 删除属性，所有情况都返回 true 4 访问器（getter/setter）1 概述 JS 中 getter/setter 的调用是当成属性来访问，自动调用方法 调用方式与属性访问方式一样 obj.访问器名 obj[&#39;访问器名&#39;] 2 语法 语法 说明 get prop() { ... } 访问器名称是一个有效标识符 get [expression]() { ... } 访问器名称可以是一个表达式 set prop(val) { . . . } 访问器名称是一个有效标识符 set [expression](val) { . . . } 访问器名称可以是一个表达式 3 定义方式 通过配置属性描述符的元属性定义访问器 12345678910111213let obj = &#123; name : '小明';&#125;Object.defineProperty(obj, 'name', &#123; get() &#123; return obj.name; // 注意：此处跟取值方式一样，也会调用get，会无限循环 &#125;, set(value) &#123; obj.name = value; &#125;&#125;;obj.name; // 调用get取值obj.name = '旺财'; // 调用set设置值 对象字面量中直接定义 123456789let obj = &#123; _name: '小明', get name() &#123; return this._name; &#125;, set name(value) &#123; this._name = value; &#125;&#125; 三 对象拷贝3.1 概念 浅拷贝 如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 一个对象修改可能会影响到另一个对象 深拷贝 将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象 一个对象修改不会影响到另一个对象 3.2 浅拷贝方式1 for... in 创建新对象，然后使用for...in遍历原对象属性并连同值一起添加到新对象上 1234567let source = &#123;name:'an3', age:18&#125;;let cp = &#123;&#125;;for (const key in source)&#123; if(source.hasOwnProperty(key)&#123; cp[key] = source[key]; &#125;&#125; 2 Object.assign(target, ...sources) 将目标对象设为空对象，就相当于返回了原对象的浅拷贝 12let source = &#123;name:'an3', age:18&#125;;let cp = Object.assign(&#123;&#125;, source); 3 展开语法12let source = &#123;name:'an3', age:18&#125;;let cp = &#123;...source&#125;; 3.3 深拷贝方式1 JSON 步骤 JSON.stringify()：将一个对象序列成一个字符串 JSON.parse()：将字符串反序列化生成深拷贝对象 注意 拷贝的对象的值中如果有 函数、undefined、symbol 则经过 JSON.stringify() 序列化后的 JSON 字符串中这个键值对会消失 无法拷贝不可枚举的属性，无法拷贝对象的原型链 拷贝 Date 引用类型会变成字符串 拷贝 RegExp 引用类型会变成空对象 对象中含有 NaN、Infinity、-Infinity ，则序列化的结果会变成 null 无法拷贝对象的循环应用，即 obj[key] = obj 2 递归 原理就是浅拷贝只拷贝一层，利用递归，如果这一层属性的值是引用类型，就再拷贝一层 … 12345678910function deepCopy(obj) &#123; // 对象的属性值有可能是数组，判断一下防止递归时把数组变成了对象 let cpObj = obj instanceof Array ? [] : &#123;&#125;; // Object.entries()方法对于对象和数组返回结果形式是一样的 for(const [k, v] of Object.entries(obj)) &#123; // 判断对象属性如果是引用类型就递归拷贝 cpObj[k] = typeof v == 'object' ? deepCopy(v) : v; &#125; return cpObj;&#125;; 四 Object4.1 构造函数 方法 类型 说明 new Object([value]) 构造函数 创建一个对象 Object([value]) 类型转换函数 将 value 转成一个对象 value ： 为空或者是 undefined null，返回一个空对象 是基本类型的值则返回其包装对象 是引用类型则直接返回 4.2 静态方法1 属性 静态方法 说明 Object.keys(obj) 返回对象自身可枚举属性键的数组 Object.values(obj) 返回对象自身可枚举属性值的数组 Object.entries(obj) 返回对象自身可枚举属性键值对的数组 Object.getOwnPropertyNames(obj) 返回对象自身的所有属性（包含可枚举和不可枚举属性，不包含 Symbol 属性）键的数组 Object.getOwnPropertySymbols(obj) 返回对象自身的所有 Symbol 属性的数组 2 属性描述符 静态方法 说明 Object.getOwnPropertyDescriptor(obj, prop) 获取对象自身某个属性的属性描述符 Object.getOwnPropertyDescriptors(obj) 获取对象自身所有属性的属性描述符 Object.defineProperty(obj, prop, descriptor) 如果对象自身存在指定属性，则修改它的属性描述符，否则为对象添加指定属性并定义属性描述符，返回该对象 Object.defineProperties(obj, props) 修改或添加对象多个属性的属性描述对象，返回该对象 3 创建对象 静态方法 说明 Object.create(proto[, propertiesObject]) 根据原型对象和属性（使用属性描述符定义），创建一个新的对象 Object.fromEntries(iterable) 把键值对列表转换为一个对象，是 Object.entries() 的反转 Object.assign(target, ...sources) 将 n 个源对象的所有可枚举属性复制到目标对象，并返回目标对象 Object.assign(target, ...sources) 如果目标对象与源对象有同名属性，或多个源对象有同名属性，后边覆盖前边 Object.assign 方法实行的是浅拷贝 数组会被当作对象，即相同索引会覆盖 如果属性值是取值函数，会计算后再复制 4 原型对象 静态方法 说明 Object.getPrototypeOf(obj) 获取对象的原型对象，即obj.__proto__ Object.setPrototypeOf(obj, prototype) 获取对象的原型对象 5 比较 Object.is(value1, value2) 判断两个值是否相等，不会作类型转换 与===的区别 === 认为-0和+0相等，此方法认为不相等 === 认为NaN和NaN不相等，此方法认为相等 6 状态 静态方法 说明 Object.preventExtensions(obj) 让一个对象变的不可扩展，即永远不能添加新的属性 Object.isExtensible(obj) 判断一个对象是否可扩展 Object.seal(obj) 封闭一个对象，此对象不可扩展且对象所有自身属性的configurable标记为 false，即不能添加、删除属性，属性修饰符不可配置 Object.isSealed(obj) 判断一个对象是否被封闭 Object.freeze(obj) 冻结一个对象，此对象不可扩展且对象所有自身属性 writable configurable 标记为 false，即不能添加、修改和删除属性，属性修饰符不可配置 Object.isFrozen(obj) 判断一个对象是否被冻结 4.3 原型方法 Object.prototype. 原型方法 说明 toString() 默认返回 [object type]，通常会覆盖 toLocaleString() 默认返回 toString() 的结果，可以覆盖 hasOwnProperty(prop) 判断对象自身是否含有某个属性 propertyIsEnumerable(prop) 判断某个属性是否可枚举 isPrototypeOf(object) 判断调用对象是否在另一个对象的原型链上 valueOf() 返回对象原始值，若没有原始值，返回对象本身，通常会覆盖 isPrototypeOf(object) 和 instanceof 的区别 A instanceof B ：判断 B.prototype是否在 A 的原型链上 B.isPrototypeOf(A)：判断 B 是否在 A 的原型链上 valueOf() 返回值 对象 返回值 Number 数值 Boolean 布尔值 String 字符串值 Object 对象本身 Array 数组本身 Function 函数本身 Date 距离1970-01-01 00:00:00 的毫秒数 五 代理5.1 概述 代理（拦截器）是对象的访问控制 setter/getter 访问器是对对象属性的访问控制 5.2 Proxy（代理对象）1 构造函数 new Proxy(target, handler) 返回一个代理对象 target 用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理） handler 处理器对象，有许多拦截相应操作的函数，如果没有配置，则执行默认操作 注意：处理操作都是针对代理对象的，目标对象无效。 2 handler（处理器对象） get(target, property, receiver) 参数 target 目标对象 property 获取的属性名 reveiver Proxy或者继承Proxy的对象 说明 get 方法拦截属性的获取，可以返回任何值 set(target, property, value, receiver) 参数 value 被设置的新值 说明 set 方法拦截属性的设置 严格模式下 set 必须返回布尔值，且如果返回false会报错 apply(target, thisArg, argumentsList) 参数 target 目标函数 thisArg 被调用时的上下文对象 argumentsList 被调用时的参数数组 说明 apply 方法拦截函数调用，可以返回任何值 直接调用 Function.prototype.call() 方式调用 Function.prototype.apply() 方式调用 Reflet.apply() 方式调用 has(target, prop) 参数 target 目标对象 prop 需要检查是否存在的属性. 说明 拦截 prop in object 语句，返回布尔值 construct(target, argumentsList, newTarget) 参数 target 目标构造函数 argumentsList constructor的参数列表 newTarget 生成的代理对象（即代理构造函数） 说明 拦截new操作，必须返回一个对象 deleteProperty(target, prop) 拦截delete 操作，必须返回布尔值 defineProperty(target, property, descriptor) 拦截Object.defineProperty()，必须返回布尔值 getOwnPropertyDescriptor(target, prop) 拦截 Object.getOwnPropertyDescriptor()，必须返回一个对象或undefined getPrototypeOf(target) 拦截获取原型操作 setPrototypeOf(target, prototype) 拦截设置原型操作，返回布尔值 preventExtensions(target) 拦截Object.preventExtensions()，返回一个布尔值 isExtensible(target) 拦截Object.isExtensible()，必须返回布尔值 ownKeys(target) 拦截对象获取自身属性的操作 六 Reflect6.1 概述 Reflect 不是一个构造函数，不能 new，Reflect 的所有属性和方法都是静态的 将 Object 对象的一些明显属于语言内部的方法（如Object.defineProperty()），放到 Reflect 对象上 修改某些 Object 方法的返回结果，让其变得更合理 如 Object.defineProperty()无法定义属性时，会抛出错误，而Reflect.defineProperty()会返回false 让 Object 操作都变成函数行为 如 prop in object ，对应Reflect.has(obj, prop) delete obj.prop，对应Reflect.deleteProperty(obj, prop) Reflect 对象与 Proxy 的 handler 方法完全一致，在使用代理拦截某些操作时，使用 Reflect 的方法可以保证原生行为能正常执行。 6.2 静态方法 见 Proxy handler 七 this 场景 this 指向 全局作用域，普通函数 非严格模式 window严格模式 undefined 对象中 当前对象 对象方法中 调用该方法的对象 原型对象方法中 调用该方法的对象 构造函数中 正在构造的新对象 箭头函数中 与箭头函数所在作用域的 this 指向一致 DOM 事件处理函数中 绑定事件的元素 回调函数 window 内联事件处理函数中 window 立即执行函数 window","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"JS基本类型及包装类","slug":"UI/JS基本类型及包装类","date":"2020-11-08T13:08:14.000Z","updated":"2020-11-08T13:10:57.578Z","comments":true,"path":"2020/11/08/UI/JS基本类型及包装类/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/JS%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%8C%85%E8%A3%85%E7%B1%BB/","excerpt":"","text":"一 number1.1 说明 值 说明 任意数字 整数或者浮点数 +Infinity 正无穷 -Infinity 负无穷 NaN not a number 一个不是数字的数字类型 JavaScript 的 number 类型为双精度IEEE 754 64位浮点类型。范围（-253- 253） JavaScript 内部，整数和浮点数采用的是同样的储存方法。所以1===1.0 为true 进制 十进制 二进制：以 0b 开头 八进制：以 0o开头 十六进制：以 0x 开头 1.2 Number（包装类）1 构造函数 方法 类型 说明 new Number([value]) 构造函数 创建一个 Number 对象 Number([value]) 类型转换函数 将 value 转成一个 number 2 静态属性 静态属性 说明 Number.POSITIVE_INFINITY 正无穷，指向 +Infinity Number.NEGATIVE_INFINITY 负无穷，指向 -Infinity Number.NaN NaN Number.MIN_VALUE 最小正值 Number.MAX_VALUE 最大数值 Number.MIN_SAFE_INTEGER JS 中能够准确表示的整数范围下限 Number.MAX_SAFE_INTEGER JS 中能够准确表示的整数范围上限 Number.EPSILON 表示 1 与大于 1 的最小的浮点数之间的差值，即 JS 的精度 3 静态方法 静态方法 说明 Number.isNaN(value) 判断是否是 NaN Number.isFinite(value) 判断否是有穷数 Number.isInteger(value) 判断是否是整数 Number.parseInt(string[, radix]) 将一个字符串转换成指定进制的整数，radix ：进制 2-36，默认 10 Number.parseFloat(string) 将一个字符串转换成浮点数 Number.isNaN(value) &amp; window.isNaN() 全局函数 isNaN() 会先将非数值转换为数值，再进行判断 Number.isNaN() 只对数值有效，非数值直接返回 false Number.isFinite(value) &amp; window.isFinite() 全局函数 isFinite() 会先将非数值转换为数值，再进行判断 Number.isFinite() 只对数值有效，非数值直接返回 false 4 原型方法 Number.prototype. 原型方法 说明 valueOf() 返回 number 值 toString([radix]) 返回字符串形式 toFixed([digits]) 返回保留指定位数浮点数的字符串 二 boolean2.1 说明 项 值 boolean（布尔值） false, true Falsy（类假值） false, 0, &#39;&#39;, undefined, null, NaN Truthy（类真值） 非 Falsy 的值 隐式转换 Falsy 可以隐式转换为 false；Truthy 可以隐式转换为 true 注意：值和布尔值是不同的概念 显式转换 Boolean() !! new Boolean() 不推荐，因为返回一个对象，而对象是 Truthy 转为布尔值必为 true 2.2 Boolean（包装类）1 构造函数 方法 类型 说明 new Boolean([value]) 构造函数 创建一个 Boolean 对象 Boolean([value]) 类型转换函数 将 value 转成一个布尔值 2 原型方法 Boolean.prototype. 原型方法 说明 toString() 返回布尔值的字符串形式 valueOf() 返回布尔值 三 string3.1 说明1 字符串字面量 语法 说明 &quot;&quot; &#39;&#39; 单/双引号，特殊字符使用 \\ 转义 &#96;&#96; 反引号，模板字面量，特殊字符（反引号自身需要\\转义）可以直接使用 \\uxxxx 只限 Unicode 编码在 \\u0000~\\uFFFF（0-65535）之间的字符 \\u{xxxx} 大于\\uFFFF的字符也能正确表示 2 模板字面量1 概述 模板字面量是增强版的字符串，它用反引号标识 空格换行等都会原样输出 ${表达式} 占位符就如同一个普通字符串一样，可以插入到字符串中的任意位置 作用是取表达式的值 反引号可以嵌套 2 模板字面量标签 模板字面量标签通常是一个函数 调用标签函数，将它放在模板字面量前面即可 123451 内置函数alert`hello`;2 自定义函数function myTag (strings, ...values)&#123;&#125;myTag`hello` 调用标签函数时，会将模板字面量处理成参数，传递给函数 1234let name = &apos;xiaoming&apos;, age = 18;alert`hello$&#123;name&#125;,ni$&#123;18&#125;了吗`; // 相当于alert ([&apos;hello&apos;, &apos;,ni&apos;, &apos;了吗&apos;], &apos;xiaoming&apos;, 18); 第一个参数是数组，存储模板字面量中占位符${}两侧的字符串 第二个参数是可变参数，存储占位符${}的返回值 3 字符串换行 末尾加\\ 加号连接 反引号 3.2 String（包装类）1 构造函数 方法 类型 说明 new String([value]) 构造函数 创建一个 String 对象 String([value]) 类型转换函数 将 value 转成一个字符串 由于字符串的不可变性，字符串中的所有方法都不改变原字符串 2 实例属性 实例属性 说明 length 字符数 3 静态方法 静态方法 说明 String.fromCharCode(charCode1, ..., charCodeN) 返回使用指定的 Unicode 编码创建的字符串，不能识别大于0xFFFF的字符 String.fromCodePoint(num1[, ...[, numN]]) 返回使用指定的 Unicode 编码创建的字符串，识别大于0xFFFF的字符 String.raw&#96;templateString&#96; 返回模板字符串的原始字符串 4 原型方法 String.prototype.1 查 原型方法 说明 charAt(index) 返回指定索引的字符 str[index] 等效于 charAt(index) charCodeAt(index) 返回指定索引字符的 Unicode 码，只能获取两个字节的字符 codePointAt(index) 返回指定索引字符的 Unicode 码 indexOf(searchValue[, fromIndex]) 返回第一次出现的索引，未找到返回 -1 lastIndexOf(searchValue[, fromIndex]) 返回从后往前第一次出现的索引，未找到返回 -1 2 获取 原型方法 说明 valueOf() 返回字符串对象的原始字符串 repeat(count) 返回当前字符串重复 count 次组成的新字符串 concat(str1, str2[, ..., strN]) 连接字符串并返回 slice(beginIndex[, endIndex]) 提取 [begin,end) 索引之间的字符串并返回，索引可以为负 substring(beginIndex[, endIndex]) 提取 [begin,end) 索引之间的字符串并返回， 3 改 原型方法 说明 toLowerCase() 转小写 toUpperCase() 转大写 trim() 去除字符串两端的空格 padStart(targetLength [, padString]) 以指定字符串 padString 在原字符串开头补充，以达到目标长度 targetLength padEnd(targetLength [, padString]) 以指定字符串 padString 在原字符串末尾补充，以达到目标长度 targetLength 4 判断 原型方法 说明 includes(searchString[, fromIndex]) 判断是否包含指定字符串 startsWith(searchString[, fromIndex]) 判断是否以指定字符串开头 endsWith(searchString[, length]) 判断是否以指定字符串结尾，length 表示只判断原字符串指定长度 5 正则 原型方法 说明 split([separator[, limit]]) 按照给定规则分割字符串，返回一个由分割出来的子字符串以指定分隔符组成的数组 search(regexp) 返回首次匹配项的索引，无匹配返回 -1 match(regexp) 正则有 g，则返回所有匹配结果的数组（无附加属性），正则无 g，则返回只有第一个匹配结果的数组（有附加属性），无匹配返回 null matchAll(regexp) 返回所有匹配结果的迭代器（包含附加属性） 6 替换 replace(regexp|substr, newSubStr|function) regexp|substr 正则匹配的内容或者指定的内容 newSubStr 使用新的字符串替换，替换时可以插入特殊变量 function 使用函数返回的字符串替换 特殊变量 说明 $$ 插入一个 “$” $&amp; 插入匹配的子串 $` 插入当前匹配的子串左边的内容 $&#39; 插入当前匹配的子串右边的内容 $n 如果第一个参数是RegExp对象，表示插入第n组的内容 函数参数 说明 match 匹配的子串。（对应$&amp;。） p1,p2,... 如果第一个参数是RegExp对象，表示第n组的内容（对应$n） offset 匹配到的子字符串在原字符串中起始索引 string 被匹配的原字符串 NamedCaptureGroup 命名捕获组匹配的对象 四 undefined undefined 是一种类型，且只有一个值 undefined 一个变量没有指定类型（没有赋值则不能确定类型），则默认为 undefined 类型，其值也是 undefined 变量或者对象属性没有赋值，默认值为 undefined 调用函数时，没有传值的参数默认值为 undefined 函数没有返回值时，默认返回 undefined 五 symbol5.1 说明 symbol 的值是唯一的，独一无二的，不会重复的 symbol 值作为对象属性名时，不能用点运算符，只能使用[] 不会被for...in for... of遍历到 不会被 Object.keys() Object.getOwnPropertyNames() JSON.stringify() 返回 使用Object.getOwnPropertySymbols()可以获取 symbol 值不能与其他类型的值进行运算，可以转为字符串和布尔值 5.2 Symbol（包装类）1 构造函数 方法 说明 Symbol([description]) 返回一个唯一的 symbol 值，不会放入全局 symbol 注册表，description：只是描述，不影响 symbol 值 new Symbol() 不支持此语法 2 静态属性 ES6 提供了 11 个内置的 symbol 值，指向语言内部使用的方法 静态属性 说明 Symbol.hasInstance A instanceof B 实际调用的是 B[Symbol.hasInstance](A) Symbol.iterator 指向一个返回对象迭代器的方法, Obj[Symbol.iterator]() 获取此方法并执行，返回对象的迭代器，被 for... of 使用 3 实例属性 实例属性 说明 description 只读属性，返回 Symbol 对象的可选的描述字符串 4 静态方法 静态方法 说明 Symbol.for(key) 根据 key 从全局 symbol 注册表查询，找到则返回，否则创建一个与 key 关联的 symbol 值并放入全局 symbol注册表 Symbol.keyFor(sym) 获取全局 symbol 注册表中与指定 symbole 值关联的 key","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"JS语法","slug":"UI/JS语法","date":"2020-11-08T13:08:04.000Z","updated":"2020-11-08T13:11:48.318Z","comments":true,"path":"2020/11/08/UI/JS语法/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/JS%E8%AF%AD%E6%B3%95/","excerpt":"","text":"一 注释 / 单行注释 / /* 多行注释，不能嵌套 */ 二 作用域 全局作用域：&lt;script&gt; 标签中或外部 .js 文件中 函数作用域：函数内部 块作用域：ES 6 之后才有，{} 内部，如 {}, if, for, while, ... 三 声明关键字 关键字 初始化 变量提升 作用域 window 同一作用域重复声明 var 可选 有 全局，函数 全局声明会添加到 window 对象 可以，后者覆盖前者 let 可选 无 全局，函数，块 全局声明不会添加到 window 对象 不能 const 必须 无 全局，函数，块 全局声明不会添加到 window 对象 不能 JS 引擎运行分为两步：预解析和代码执行 预解析：将脚本中所有 var 和 function 语句提升到其作用域的最前面（hoisting） 变量提升 var：将变量的声明提升到其作用域最前面，赋值操作不会提升 函数提升 function：将函数的声明提升到其作用域最前面 var 的问题： 在函数及其子作用域声明的变量作用域都是函数 全局声明会添加到 windows 中 暂时性死区 TDZ temporal dead zone 从作用域开始到声明语句之间区域，如果使用声明的变量就会会导致 ReferenceError，这块区域称为暂时性死区。 说白了就是要先声明后使用 暂时性死区不会查找全局变量（我觉得应该是特殊情况下） 12345let num = 10;if (true) &#123; console.log(num); // 报错 let num = 20;&#125; 四 变量 变量的声明和赋值，是分开的两个步骤 1234let a = 1; // 其实是下边两步let a;a = 1; 同一条声明语句中可以声明多个变量 JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。 变量标识符命名规则 A-Za-z 0-9 _ $ 不能用数字开头 不能使用 js 关键字和保留字 五 数据类型5.1 数据类型分类 内置对象 说明 Object 对象都是 Object 的实例 Array 数组都是 Array 的实例 Function 函数都是 Function 的实例 Map Set WeakMap WeakSet 集合 Number Boolean String Symbol BigInt 基本类型包装类 Math 数学运算 Date 日期 JSON Json RegExp 正则表达式都是 RegExp 的实例 Error 错误 5.2 数据类型判断1 方式 方式 语法 说明 typeof typeof operand 返回数据类型的字符串形式 instanceof obj instanceof constructor 检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上 2 typeof 返回值 type typeof Result number &quot;number&quot; bigint &quot;bigint&quot; string &quot;string&quot; boolean &quot;boolean&quot; undefined &quot;undefined&quot; null &quot;object&quot; symbol &quot;symbol&quot; function object (implements [[Call]]) &quot;function&quot; any other object &quot;object&quot; typeof null返回object是历史原因 六 运算符6.1 赋值运算符 运算符 名称 运算式 等价于 = 赋值 x = y x = y += 加赋值 x += y x = x + y -= 减赋值 x -= y x = x - y *= 乘赋值 x *= y x = x * y /= 除赋值 x /= y x = x / y %= 模赋值 x %= y x = x % y **= 指数赋值 x **= y x = x ** y &lt;&lt;= 左移赋值 x &lt;&lt;= y x = x &lt;&lt; y &gt;&gt;= 右移赋值 x &gt;&gt;= y x = x &gt;&gt; y &gt;&gt;&gt;= 无符号右移赋值 x &gt;&gt;&gt;= y x = x &gt;&gt;&gt; y &amp;= 按位与赋值 x &amp;= y x = x &amp; y &#124;= 按位或赋值 x &#124;= y x = x &#124; y ^= 按位异或赋值 x ^= y x = x ^ y 6.2 算术运算符 运算符 名称 运算式 + 加法 x + y - 减法 x - y * 乘法 x * y / 除法 x / y % 求余 x % y ** 幂 x ** y ++ 自增 x++ 或 ++x -- 自减 x-- 或 --x + 一元正号 +x - 一元负号 -x 1 加法 遇到字符串会变成连接 对象相加，会先转成原始类型的值 1234var obj = &#123; p: 1 &#125;;obj + 2 // \"[object Object]2\"// obj.valueOf() 结果为&#123;p:1&#125;// obj.valueOf().toString() 结果为\"[object object]\" 2 一元加号/减号1234// 一元加号/减号运算符的作用在于可以将任何值转为数值+true // 1+[] // 0+&#123;&#125; // NaN 3 幂运算符 前一个运算子是底数，后一个运算子是指数 幂运算符是右结合：即多个指数运算符连用时，先进行最右边的计算。 122 ** 3 ** 2// 512 相当于 2 ** (3 ** 2) 即先求3的2次方=9 再求2的9次方 6.3 比较运算符 运算符 名称 运算式 &gt; 大于 x &gt; y &lt; 小于 x &lt; y &gt;= 大于等于 x &gt;= y &lt;= 小于等于 x &lt;= y == 相等 x == y === 严格相等 x === y != 不相等 x != y !== 严格不相等 x !== y 1 说明 基本类型 非字符串：先转成数值再比较 字符串：按照字典顺序比较（实际上是比较 Unicode 码点） 引用类型 先转为基本类型的值，再进行比较 严格相等（全等）：符号两边的值类型和值都相等 2 总结 方式 NaN undefined null +0 和 -0 说明 == 不等于任何值 等于 undefined 和 null 等于 undefined 和 null 相等 先进行类型转换，之后使用 === 比较 === 不等于任何值 等于 undefined 等于 null 相等 类型不同即为 false Object.is(value1, value2) 等于 NaN 等于 undefined 等于 null 不相等 类型不同即为 false 6.4 逻辑运算符 运算符 名称 运算式 说明 &amp;&amp; 逻辑与 expr1 &amp;&amp; expr2 若expr1为 true，则返回expr2的值，否则，返回expr1的值，且不再计算expr2 （短路） &#124;&#124; 逻辑或 expr1 &#124;&#124; expr2 若expr1为 false，则返回expr2的值，否则，返回expr1的值，且不再计算expr2 （短路） ! 逻辑非 !expr 若expr 为 true，则返回 false，否则，返回true !! 双重非 !!expr 显式地将任意值强制转换为其对应的布尔值 JS 中逻辑运算符返回的不一定是布尔值，而是表达式的值 6.5 按位运算符 运算符 名称 运算式 说明 &amp; 按位与 x &amp; y 有0则0 &#124; 按位或 x &#124; y 有1则1 ~ 按位非 ~x 1变0，0变1 ^ 按位异或 x ^ y 相同则0，不同则1 &lt;&lt; 左移 x &lt;&lt; y 低位补0，相当于x * 2y &gt;&gt; 右移 x &gt;&gt; y 舍去低位，正数高位补 0，负数高位补 1，相当于x / 2y &gt;&gt;&gt; 无符号右移 x &gt;&gt;&gt; y 舍去低位，高位补 0，相当于x / 2y 6.6 三元运算符 condition ? exprIfTrue : exprIfFalse 若condition 为true，返回exprIfTrue的值，否则，返回exprIfFalse的值 和 if else 的区别：if…else是语句，没有返回值；三元运算符是表达式，具有返回值。 6.7 void运算符 void expression 对给定的表达式进行求值，然后返回 undefined void 运算符通常只用于获取 undefined 的原始值，一般使用 void(0)（等同于void 0） 应用 javascript: void(0); () =&gt; void doSomething(); 6.8 逗号运算符 expr1, expr2, expr3... 从左到右依次计算每个表达式，并返回最后一个表达式的值 123'a', 'b' // \"b\"var x = 0;var y = (x++, 10); // x=1 y=10 七 语句7.1 条件1 if … else1234567if (condition) &#123; statement&#125; else if (condition) &#123; statement&#125; else &#123; statement&#125; 2 switch … case123456789101112// switch 内部采用严格相等switch (variable) &#123; case value1: statement break; case value2: statement break; ... default: statement&#125; 7.2 循环1 for123for (初始化条件【可以有多个】; 循环条件【boolean类型】; 循环迭代条件) &#123; 循环体;&#125; 2 while123while (condition) &#123; statement&#125; 3 do … while1234do &#123; statement&#125;while (condition) 4 for … in123for (let key in object)&#123; statement&#125; 遍历对象（推荐） 遍历对象的所有可枚举属性（包括它的原型链上的可枚举属性），属性是否可枚举由属性描述符的enumerable决定 每次循环获取的是属性名 遍历数组（不推荐） 数组键名是数字，但每次循环获取的是索引的字符串 除了遍历数组元素外，数组本身以及原型链上的可枚举属性也会被遍历到 某些情况下，不能保证按顺序返回索引 语句 说明 {} 声明块作用域 prop in obj 判断对象或其原型链上是否包含某个属性 5 for … of1 语法123for (let value of iterable) &#123; statement&#125; 用来遍历可迭代对象，每次循环取出的是值 for… of 内部就是调用了可迭代对象的 Symbol.iterator 生成了迭代器 2 迭代器 迭代器就是具有指定next()方法的对象 此指定 next() ：返回一个对象，返回对象拥有两个属性 value：当前迭代的值 done：布尔值，迭代是否结束。 false 表示没结束，可以省略 true 表示结束，此时 value为 undefined，value 可以省略 3 可迭代对象1 概述 一个可迭代对象必须实现 @@iterator 方法，这意味着对象（或其原型链上的某个对象）必须有一个键为 @@iterator 的属性 @@iterator 属性可以通过 Symbol.iterator 访问 对象（或者其原型链）上拥有 Symbol.iterator 属性，就是可迭代对象 2 Symbol.iterator Symbol.iterator 属性指向一个函数，此函数返回对象的迭代器 obj[Symbol.iterator] 返回对象用于获取迭代器的函数 3 JS 内置可迭代对象 内置可迭代对象 说明 String 字符串 Array 数组 Set / Map 集合 arguments 类数组对象 DOM NodeList 类数组对象 Generator 生成器对象 TypedArray 类型化数组 可枚举属性：属性描述符 enumerable: true 的属性 普通对象：没有数字键和 length 属性的对象 类数组对象：存在数值键名和 length 属性的对象 4 自定义 for … of1234567891011function myForOf(arr) &#123; // 1 获取迭代器 let it = arr[Symbol.iterator](); // 2 判断迭代是否结束 let res = it.next(); while(!res.done) &#123; // 3 获取值 console.log(res.value); res = it.next(); &#125;&#125; 7.3 label12label（label可自定义名称）: statement 相当于定位符，用于跳转到程序的任意位置，通常配合 break 和 continue 使用 break [label] continue [label] 八 展开语法（Spread syntax）8.1 概述 展开语法用 ... 表示 展开语法在函数调用或构造字面量数组时, 将可迭代对象在语法层面展开 展开语法在构造字面量对象时, 将对象按 key:value 的方式展开 8.2 应用1 函数调用123function show(x, y, z) &#123; &#125;let args = [0, 1, 2];show(...args); // 等价于 show(0, 1, 2) 2 构造字面量数组123let arr1 = [0, 1, 2];let arr2 = [3, 4, 5];let arr3 = [...arr1, ...arr2]; // [0,1,2,3,4,5] 3 构造字面量对象1234let obj1 = &#123; foo: &apos;bar&apos;, x: 42 &#125;;let obj2 = &#123; foo: &apos;baz&apos;, y: 13 &#125;;let clonedObj = &#123; ...obj1 &#125;; // 克隆后的对象: &#123; foo: &quot;bar&quot;, x: 42 &#125;let mergedObj = &#123; ...obj1, ...obj2 &#125;; // 合并后的对象: &#123; foo: &quot;baz&quot;, x: 42, y: 13 &#125; 九 解构赋值9.1 概述 解构赋值：从数组和对象中提取值，对变量进行赋值 解构对象时会查找原型链（如果属性不在对象自身，将从原型链中查找） 9.2 解构数组1234567891011121314151617181920// 1 先声明后赋值的解构let a, b;[a, b] = [10, 20]; // a=10 b=20// 2 声明并赋值的解构let [a,b] = [10, 20]; // a=10 b=20// 3 有默认值的解构let [a = 3, b = 4] = [1]; // a=1 b=4// 4 变量数量小于数组值数量时，忽略多余值let [a, b] = [1, 2, 3, 4]; // a =1 b = 2// 5 可用于交换变量let a =1;let b = 2;[a, b] = [b, a]; // a=2 b=1// 6 剩余参数let [a, ...b] = [1, 2, 3]; // a=1 b=[2,3] 9.3 解构对象123456789101112131415161718192021222324252627282930// 1 基本语法let &#123;key:变量&#125; = &#123;key:value&#125;;// 2 变量名与属性名相同可以简写let &#123;key:key&#125; = &#123;key:value&#125;;let &#123;key&#125; = &#123;key:value&#125;; // 简写// 3 先声明后赋值的解构let name, age;// 错误： 赋值时必须使用 `()` 包括，因为左边`&#123;name, age&#125;`会被认为是块而不是对象字面量&#123;name,age&#125; = &#123;name:'an3', age:18&#125;); // 正确：name='an3' age=18(&#123;name, age&#125; = &#123;name:'an3', age:18&#125;); // 4 有默认值的解构let &#123;name='haha', age=10&#125; = &#123;name:'an3'&#125;; // name='an3' age=10let &#123;name:n='haha' age:a=10&#125; = &#123;name:'an3'&#125;; // n='an3' a=10// 5 变量数量小于对象键值对数量时，忽略多余值let &#123;name='haha', age=10&#125; = &#123;name:'an3',age:10,sex:1&#125;; // name='an3' age=18// 6 解构嵌套let user = &#123; name:'xiaoming', lesson:&#123; title:'js', score:90 &#125;&#125;;let &#123;name,lesson:&#123;title,score&#125;&#125; = user; 十 全局函数 全局函数 说明 encodeURI(URI) 使用 UTF-8 编码，编码后的格式为UTF-8编码的每个字节前加 %，如 安 编码后 %E5%AE%89 decodeURI(encodedURI) encodeURI(URI) 对应的解码函数 encodeURIComponent(str) 类似encodeURI()，区别在于不会编码的字符 decodeURIComponent(encodedURI) encodeURIComponent()对应的解码函数 isFinite(value) 同 Number.isFinite(value) isNaN(value) 同 Number.isNaN(value) parseInt(string[, radix]) 同 Number.parseInt(string[, radix]) parseFloat(string) 同 Number.parseFloat(string) eval(string)（不要使用） 将传入的字符串当做 JavaScript 代码进行执行 encodeURI(URI) 和 encodeURIComponent(str) 区别 encodeURI(URI) 不会编码的字符 ; , / ? : @ &amp; = + $ 字母 数字 - _ . ! ~ * &#39; ( ) # encodeURIComponent(str) 不会编码的字符 字母 数字 - _ . ! ~ * &#39; ( ) 使用场景 对整个 URI 编码，使用 encodeURI(URI) 对 URI 中的参数编码，使用 encodeURIComponent(str)","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"JS前言","slug":"UI/JS前言","date":"2020-11-08T13:07:58.000Z","updated":"2020-11-08T13:11:21.275Z","comments":true,"path":"2020/11/08/UI/JS前言/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/JS%E5%89%8D%E8%A8%80/","excerpt":"","text":"一 概述 JavaScript 是运行在客户端的解释性脚本语言，不需要编译，由 JS 引擎逐行解释并执行 浏览器分成两个部分： 渲染引擎：用来解析 HTML 和 CSS，俗称内核 JS 引擎：专门处理 JavaScript 脚本的虚拟机，也称 JS 解释器 chrome v8 firefox SpiderMonkey edge chakra Opera Carakan …… 原本 JS 只运行在浏览器上，后来出现了 Node（包含了chrome v8 的 C++ 程序），JS 可以使用 Node 运行在浏览器之外 ECMAScript 是规范，JavaScript 是实现 二 引入 JavaScript 脚本2.1 网页加载流程 - 前端 浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。 css 和 html 是并行加载的，过程中如果遇到css 或者 img，则会向浏览器返回一个请求，待资源返回后，将其添加到dom的相应位置中 解析过程中，浏览器发现&lt;script&gt;元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎（原因是 JavaScript 代码可以修改 DOM，所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题。） 如果&lt;script&gt;元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。 JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页 2.2 JavaScript 脚本位置 浏览器加载 JavaScript 脚本，主要通过&lt;script&gt;元素完成，&lt;script&gt; 最好放在页面底部（&lt;body&gt; 标签后） 如果外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。脚本放在页面底部，即使遇到脚本失去响应，网页主体的渲染也已经完成了，用户至少可以看到内容 JS 通常要操作页面中的元素，如果在 DOM 结构生成之前就调用 DOM 节点，JavaScript 会报错，脚本放在页面底部，就不存在这个问题，因为这时 DOM 肯定已经生成了。 2.3 JavaScript 脚本引入方式1 内联脚本123456789// 1 第一种：直接写脚本&lt;button onclick=\"alert('xxx')\"&gt;&lt;/button&gt;// 2 第二种：传递脚本&lt;button onclick=\"fn()\"&gt;&lt;/button&gt;&lt;script&gt; function fn() &#123; alert('xxx'); &#125;&lt;/script&gt; 2 内部脚本1234&lt;script type=\"text/javascript\"&gt; // 1 type 可以省略，默认 text/javascript // 2 新的浏览器可以写 application/javascript&lt;script&gt; 3 外部脚本1&lt;script src=\"xxx.js&gt;&lt;/script&gt; 标签体不能有内容，&lt;/script&gt;不能省略 src 默认是http协议 外部的 .js 脚本文件中不能包含 &lt;script&gt; 标签。 三 顶层对象 环境 顶层对象 ES2020 浏览器 window，self globalThis Web Worker self globalThis Node global globalThis JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。 顶层对象在各种实现里面是不统一的 ES2020 标准中，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的 四 严格模式4.1 启用123\"use strict;\"// 1 放在脚本文件的第一行，整个脚本都将以严格模式运行// 2 放在函数体的第一行，则整个函数以严格模式运行 4.2 严格模式中的变化1 显式报错 严格模式会使引起静默失败(silently fail，不报错也没有任何效果)的赋值操作抛出异常，如只读属性的写操作，不可扩展对象扩展操作 严格模式下，试图删除不可删除的属性时会抛出异常 严格模式下禁止对象属性重名 严格模式下禁止函数参数重名 严格模式禁止八进制数字语法 2 安全措施 严格模式下，变量必须先声明，然后再使用 禁止 this 关键字指向全局对象 window 严格模式禁止删除声明变量 3 静态绑定 js允许动态绑定，即属性或方法属于哪个对象不是编译时确定的，而是在运行时确定 严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定，即编译时就确定属性或方法属于哪个对象。 4 其它 严格模式禁用 with语句 创设 eval 作用域 正常模式下，eval语句的作用域，取决于它处于全局作用域，还是函数作用域。 严格模式下，eval语句本身就是一个作用域，即eval所生成的变量只能用于eval内部 arguments 不再追踪参数的变化 变量arguments代表函数的参数。 严格模式下，函数内部改变参数与arguments的联系被切断了，两者不再存在联动关系","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"Less","slug":"UI/Less","date":"2020-11-08T13:03:13.000Z","updated":"2020-11-08T13:07:15.592Z","comments":true,"path":"2020/11/08/UI/Less/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/Less/","excerpt":"","text":"一 Less 概述 Leaner Style Sheets Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。 Less 可以运行在 Node 或浏览器端 二 变量1@变量名: 值; 三 嵌套 使用选择器嵌套结构即可实现选择器层次关系 12345.fu &#123; div &#123; &#125;&#125;// .fu div &#123;&#125; &amp; 代表当前选择器，类似于 this 12345div &#123; &amp;::after&#123; &#125;&#125;// div::after &#123;&#125; 四 运算 算术运算符 +、-、*、/ 可以对任何数字、颜色或变量进行运算 计算的结果以最左侧操作数的单位类型为准 运算符两侧必须加空格","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"CSS媒体查询","slug":"UI/CSS媒体查询","date":"2020-11-08T13:03:06.000Z","updated":"2020-11-08T13:05:16.192Z","comments":true,"path":"2020/11/08/UI/CSS媒体查询/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/CSS%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"一 媒体查询概述 Media Querie 可以针对不同的媒体类型定义不同的样式 二 媒体查询语法 @media12345&lt;style&gt; @media meidatype and|not|only (media feature) &#123; css code; &#125;&lt;/style&gt; 语法 名称 meidatype 媒体类型 and 逻辑与 not 逻辑非，必须写在查询的最前面，表示对整个条件取反 only 必须写在查询的最前面，指定某个特定媒体类型 media feature 媒体特性 三 媒体类型 mediatype 说明 all（默认） 所有媒体类型 screen 用于电脑屏幕，平板电脑，智能手机等 print 打印设备 speech 应用于屏幕阅读器等发声设备 多媒体支持 可以用逗号分隔同时支持多个媒体设备 如 screen, print 四 媒体特性 媒体特性 说明 orientation: landscape/portrait 横屏/竖屏 width 设备宽度 height 设备高度 min-width 最小宽度 max-width 最大宽度 min-height 最小高度 max-height 最大高度 五 引入资源1 &lt;style&gt;123&lt;style media=&quot;meidatype and|not|only (media feature)&gt; // 满足条件则使用此内部样式&lt;/style&gt; 2 &lt;link&gt;12&lt;link rel=&quot;&quot; href=&quot;&quot; media=&quot;meidatype and|not|only (media feature)&quot;&gt;// 满足条件则使用导入的外部样式 3 &lt;link&gt; + @import1234567// test.html&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;// style.css@import url(1.css) all;@import url(2.css) screen;@import url(3.css) print;...... 通过&lt;link&gt;指定媒体类型需要导入不同的css文件，导致&lt;link&gt;语句过多，可以使用外部 css 文件一起导入","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"CSS动画","slug":"UI/CSS动画","date":"2020-11-08T13:03:00.000Z","updated":"2020-11-08T13:04:11.904Z","comments":true,"path":"2020/11/08/UI/CSS动画/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/CSS%E5%8A%A8%E7%94%BB/","excerpt":"","text":"一 概述 过渡是两个状态间的变化，动画可以理解为帧之间的过渡 制作动画步骤 定义动画 @keyframes 使用动画 animation 二 @keyframes12345678910@keyframes 动画名称 &#123; from &#123; margin-left: 100%; width: 300%; &#125; to &#123; margin-left: 0%; width: 100%; &#125;&#125; 每个动画中定义一个动画序列，每个动画序列包含 n 个关键帧 关键帧 说明 num% 表示此关键帧处于动画的哪个阶段 from 相当于 0%，即动画的开始，未设置则使用元素现有状态作为动画开始状态 to 相当于 100%，即动画的结束，未设置则使用元素现有状态作为动画结束状态 三 animation（简写属性） 属性 说明 animation-name 使用的动画，多个动画用逗号隔开，多个动画有相同属性时，后者优先使用 animation-duration 动画播放时间，即动画序列的所有帧执行一遍的时间，默认 0s animation-timing-function 动画播放速度曲线，值与过渡一样，默认 ease animation-delay 动画延迟时间，即多久后开始播放 animation-iteration-count 动画重复次数，infinite：表示无限循环 animation-direction 动画运行的方向 animation-play-state 动画运行状态，running （默认），paused：暂停，不包含在 animation 简写中，常配合事件使用 animation-fill-mode 动画在执行之前和之后如何将样式应用于目标 3.1 animation-direction 值 说明 normal（默认） 0% → 100% reverse 100% → 0% alternate 0% → 100% → 0% alternate-reverse 100% → 0% → 100% 3.2 animation-fill-mode 值 动画执行前 动画执行后 none（默认） 目标在默认初始状态，延迟结束，起始帧才应用 回到默认初始状态 backwards 目标在起始帧状态 回到默认初始状态 forwards 目标在默认初始状态 停留在最后一帧 both 目标在起始帧状态 停止在最后一帧","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"CSS变形","slug":"UI/CSS变形","date":"2020-11-08T13:02:55.000Z","updated":"2020-11-08T13:03:45.779Z","comments":true,"path":"2020/11/08/UI/CSS变形/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/CSS%E5%8F%98%E5%BD%A2/","excerpt":"","text":"一 坐标轴 二 transform（变形）2.1 取值 值 说明 none 无变形 &lt;transform-function&gt; 移动，缩放，旋转，倾斜 … 变形操作定义多次，则每次都是相对于原始状态变化 变形操作一次定义多个，使用空格隔开，每个相对于上一个结果变化，有顺序，有位移的建议放前面 行内元素不产生变形效果 变形不会影响其它元素位置 2.2 &lt;transform-function&gt;1 移动 translate 值 说明 translate(tx [, ty]) 定义 x，y 轴偏移量 translateX(t) 定义 x 轴偏移量 translateY(t) 定义 y 轴偏移量 translateZ(t) 定义 z 轴偏移量 translate3d(tx, ty, tz) 定义 x，y，z 轴偏移量 偏移量 t 为 &lt;length&gt;，x,y 轴可以使用百分比（相对于元素宽高） 2 缩放 scale 值 说明 scale(sx [, sy]) 定义 x，y 轴的缩放比例，默认缩放基点是元素中心 scaleX(sx) 定义 x 轴的缩放比例 scaleY(sy) 定义 y 轴的缩放比例 scaleZ(sz) 定义 z 轴的缩放比例 scale3d(sx, sy, sz) 定义 x，y，z 轴的缩放比例 缩放比例 s 为 &lt;number&gt;（相对于元素原方向上尺寸） 3 旋转 选项 说明 rotate(angle) 定义 2D 旋转，默认旋转基点是元素中心 rotateX(angle) 定义沿着 X 轴的 3D 旋转，等价于 rotate3D(1, 0, 0, angle) rotateY(angle) 定义沿着 Y 轴的 3D 旋转，等价于 rotate3D(0, 1, 0, angle) rotateZ(angle) 定义沿着 Z 轴的 3D 旋转，等价于 rotate3D(0, 0, 1, angle) rotate3d(x,y,z,angle) 定义 3D 旋转，(x,y,z) 确定一个向量轴 4 倾斜 选项 说明 skewX(angle) 定义沿着 X 轴的 2D 倾斜。 skewY(angle) 定义沿着 Y 轴的 2D 倾斜。 skew(x-angle,y-angle) 定义沿着 X 和 Y 轴的 2D 倾斜。 三 transform-origin（变形基点）3.1 语法 语法 说明 transform-origin: offset 定义 x , y 轴的偏移量 transform-origin: x-offset, y-offset 分别定义 x , y 轴的偏移量 transform-origin: x-offset, y-offset, z-offset 定义 x , y, z 轴的偏移量 3.2 取值 值 说明 &lt;length&gt; x, y, z 轴都可以使用长度作为偏移量 &lt;percentage&gt; x, y 轴可以使用百分比作为偏移量（相对于元素宽高） 关键字 left right top bottom center 四 perspective（透视：3d眼镜）4.1 概述 perspective 指定了观察者与 z=0 平面的距离，使具有三维位置变换的元素产生透视效果 眼镜看物体远小近大，即透视值越小，说明离得越近，物体越大，反之亦然 取值为 &lt;lenght&gt; 4.2 透视使用 语法 名称 说明 perspective: 100px 舞台透视 定义在父级，影响子元素且子元素透视效果不一，就好像在一个地方去观察一排杯子一样 transform: perspective(100px) 单独透视 为每个元素单独设置透视 五 transform-style（3D 呈现） 选项 说明 flat（默认） 2D 效果 preserve-3d 开启 3D立体环境，定义在父级，影响子元素 六 观看视角 perspective-origin 选项 说明 x-axis 定义该视图在 x 轴上的位置。默认值：50%。可能的值：left、center、right、length、% y-axis 定义该视图在 y 轴上的位置。默认值：50%。可能的值：top、center、bottom、length、% perspective-origin用于控制视线的落点。就好像我们看车展，可以让车转，也可以我们自己转(perspective-origin) 需要设置 perspective 透视后才可以看到效果 一般设置在舞台元素上来控制子元素 七 隐藏背面 backface-visibility 选项 说明 visible 背面可见 hidden 背面隐藏 使用 backface-visibility 用于控制是否可以看到元素的背面 一般设置在元素上而不是舞台元素上 如果设置在舞台元素（父级元素）需要设置 transform-style: preserve-3d","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"CSS过渡","slug":"UI/CSS过渡","date":"2020-11-08T13:02:49.000Z","updated":"2020-11-08T13:04:35.658Z","comments":true,"path":"2020/11/08/UI/CSS过渡/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/CSS%E8%BF%87%E6%B8%A1/","excerpt":"","text":"一 概述 默认情况下 CSS 属性的变化是瞬间完成的 不是所有 css 属性都有过渡效果，一般来讲有中间值的属性都可以设置动画如宽度、透明度等。 二 transitionend 过渡完成后触发的事件 属性 说明 propertyName 结束过渡样式 elapsedTime 过渡需要的时间 pseudoElement 过渡的伪元素 isTrusted true 用户触发，false 脚本触发 三 transition（简写属性） 属性 说明 transition-property 指定应用过渡的属性，对于简写属性如 background，其完整版属性都应用过渡 transition-duration 过渡时间，默认 0s （即不出现过渡动画），不能为负 transition-timing-function 过渡速度曲线 transition-delay 过渡延迟时间，必须在延迟时间后面 3.1 transition-property 值 说明 all（默认） 所有可过渡的属性都使用过渡 none 没有过渡 &lt;custom-ident&gt; 属性名称，多个用逗号隔开 3.2 transition-duration 一个值时，所有属性使用同样的时间 多个值时，如果属性数量大于值数量，超出的属性再从第一个时间开始重复使用 3.3 transition-timing-function1 曲线 值 说明 ease（默认） 慢 → 快 → 慢 → 非常慢（等价于 cubic-bezier(0.25,0.1,0.25,1)） linear 匀速（等价于 cubic-bezier(0,0,1,1)）。 ease-in 慢 → 快（等价于cubic-bezier(0.42,0,1,1)） ease-out 快 → 慢 （等价于 cubic-bezier(0,0,0.58,1)） ease-in-out 慢 → 快 → 慢（等价于 cubic-bezier(0.42,0,0.58,1)） cubic-bezier(n,n,n,n) 三次贝塞尔曲线 2 步进 值 说明 steps(n, start) 将过渡过程分为 n 个阶段，每个阶段从阶段开始就变化，即每个阶段一开始就是此阶段结束时的效果 steps(n, end) 将过渡过程分为 n 个阶段，每个阶段到阶段结束才变化，即每个阶段一开始是此阶段开始时的效果 step-start 同 steps(1, start) step-end 同steps(1,end) 3.4 transition-delay 延迟时间，即等待多久后开始过渡，必须在过渡时间之后 默认为 0s，即立刻开始过渡 值可以为负数，如-3s，表示直接显示在 3s 时的效果 过渡属性数量大于时间数量时，后面的属性从第一个时间开始重复使用","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"CSS栅格布局","slug":"UI/CSS栅格布局","date":"2020-11-08T13:02:39.000Z","updated":"2020-11-08T13:06:40.164Z","comments":true,"path":"2020/11/08/UI/CSS栅格布局/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/CSS%E6%A0%85%E6%A0%BC%E5%B8%83%E5%B1%80/","excerpt":"","text":"一 Grid 概述 将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局 Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是二维布局 设为网格布局以后，容器子元素（项目）的float、vertical-align等设置都将失效 二 基本概念 概念 名称 说明 Grid Container 栅格容器 采用 grid 布局的元素 Grid Item 栅格项目 栅格容器中采用网格定位的子元素 Grid Line 栅格线 划分网格的线 Grid Track 栅格轨道 两条相邻网格线之间的空间，即行（row）和列（column） Grid Cell 栅格单元格 行和列的交叉区域 Grid Area 栅格区域 由任意数量单元格组成的区域（必须为矩形） 三 声明容器 语法 说明 display: grid 块级栅格容器 display: inline-grid 内联栅格容器 四 容器属性4.1 grid-template1grid-template: grid-template-rows grid-template-columns grid-template-areas 属性 说明 grid-template-rows 定义每一行的高度 grid-template-columns 定义每一列的宽度 grid-template-areas 定义栅格区域 1 grid-template-rows &amp; grid-template-columns12[ &lt;line-names&gt;? [ &lt;track-size&gt; | &lt;track-repeat&gt; ] ]+ &lt;line-names&gt;? 1 &lt;line-names&gt; 指定删格线名称，格式：[name1 name2 ...] 可以省略，则名称按顺序分配为 1 2 3 ... 2 &lt;track-size&gt; 值 说明 auto 表示由浏览器自己决定长度 &lt;length&gt; 长度单位 &lt;percentage&gt; 栅格容器宽/高的百分比 fr 网格剩余空间比例单位（fraction 的缩写，意为”片段”） minmax(min, max) 尺寸在min和max之间，若min&gt;max，则max的值会被忽略 3 &lt;track-repeat&gt; repeat( count, [ &lt;line-names&gt;? &lt;track-size&gt; ]+ &lt;line-names&gt;? ) count：重复次数，如果重复次数不确定可以使用 auto-fill 关键字 auto-fit 关键字 2 grid-template-areas 区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end 1 为每个单元格设置区域（假如三行三列9个单元格）123grid-template-areas: &quot;a b c&quot; &quot;d e f&quot; &quot;g h i&quot;; 2 多个单元格合并成一个区域：区域名相同即可123456grid-template-areas: &quot;a a a&quot; &quot;b b b&quot; &quot;c c c&quot;;grid-template-areas: &quot;header header header&quot; &quot;main main sidebar&quot; &quot;footer footer footer&quot;; 3 区域占位符（点）：表示没有用到该单元格，或者该单元格不属于任何区域123grid-template-areas: &quot;a . c&quot; &quot;. . f&quot; &quot;g h .&quot;; 4.2 grap1grap: row-gap column-gap # 如果省略了第二个值，则等于第一个值 属性 说明 row-gap 设置行与行的间隔（行间距） column-gap 设置列与列的间隔（列间距） 4.3 grid-auto-flow 划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。 取值 说明 row（默认） 先行后列 column 先列后行 row dense 先行后列，并且尽量填满空格 column dense 先列后行，并且尽量填满空格 尽量填满的意思是比如第2个元素太宽第一行放不下，可以先放第3,4…个 4.4 place-items1place-items: align-items justify-items # 如果省略了第二个值，则等于第一个值 1 属性 属性 说明 justify-items 单元格中的元素在单元格中的水平对齐方式（针对所有单元格） align-items 单元格中的元素的在单元格中垂直对齐方式（针对所有单元格） 2 取值 取值 说明 stretch（默认） 拉伸，占满单元格的整个宽度 start 对齐单元格的起始边缘 end 对齐单元格的结束边缘 center 单元格内部居中 4.5 place-content1place-content: align-content justify-content # 如果省略了第二个值，则等于第一个值 1 属性 属性 说明 justify-content 所有单元格（整个内容区域）在容器中的水平对齐方式 align-content 所有单元格（整个内容区域）在容器中的垂直对齐方式 2 取值 取值 说明 stretch（默认） 拉伸，占满单元格的整个宽度 start 对齐单元格的起始边缘 end 对齐单元格的结束边缘 center 单元格内部居中 space-between 两端对齐，两端紧挨边框中间平均分配 space-around 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍 space-evenly 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔 4.6 grid-auto-columns &amp; grid-auto-rows 属性 说明 grid-auto-columns 浏览器自动创建的多余网格的列宽 grid-auto-rows 浏览器自动创建的多余网格的行高 有时，一些项目的指定位置在现有网格的外部，比如网格只有三行，但是有一个项目在第五行，这时，浏览器会自动生成多余的网格，以便放置项目。 如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高 4.7 grid1grid: grid-template-rows grid-template-columns grid-template-areas grid-auto-rows grid-auto-columns grid-auto-flow 五 项目属性5.1 项目定位 属性 说明 grid-row-start 行开始栅格线（上边框） grid-row-end 行结束栅格线（下边框） grid-column-start 列开始栅格线（左边框） grid-column-end 列结束栅格线（右边框） 1 根据栅格线1234grid-column-start: 1;grid-column-end: 3;grid-row-start: 2;grid-row-end: 4; 设置栅格线来定位，设置的数值可以是正数和负数 2 根据栅格命名 固定命名 12grid-column-start: header-start;grid-column-end: header-end; 自动命名 123// 后边数字表示第几个grid-column-start: c-start 1;grid-column-end: c-end 3; 3 根据偏移量12grid-row-end: span 1;grid-column-end: span 1; span 可以设置移动单元格数量（即开始栅格线和结束栅格线之间有几个单元格），数值只能为正数 5.2 grid-column &amp; grid-row 属性 说明 grid-row grid-row-start / grid-row-end grid-column grid-column-start / grid-column-end 设置起始栅格线 12grid-column: 1 / 3;grid-row: 1 / 2; 使用span 1234grid-column: 1 / span 3;grid-row: 1 / span 2;// 如果省略斜杠及后面部分，表示span值为1grid-row: 1; 5.3 grid-area121. grid-area: 区域名;2. grid-area: grid-row-start / grid-column-start / grid-row-end / grid-column-end 5.4 place-self1place-self: align-self justify-self # 如果省略了第二个值，则等于第一个值 属性 说明 justify-self 单元格中的元素在单元格中的水平对齐方式（针对单个单元格），用法同 justify-items align-self 单元格中的元素在单元格中的垂直对齐方式（针对单个单元格），用法同 align-items","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"CSS弹性布局","slug":"UI/CSS弹性布局","date":"2020-11-08T13:02:32.000Z","updated":"2020-11-08T13:03:59.768Z","comments":true,"path":"2020/11/08/UI/CSS弹性布局/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/CSS%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/","excerpt":"","text":"一 Flex 概述 是 Flexible Box 的缩写，意为”弹性布局” 任何一个容器都可以指定为 Flex 布局 设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效 绝对定位的弹性元素不参与弹性布局 二 基本概念 概念 名称 说明 flex container Flex 容器 采用 Flex 布局的元素 flex item Flex 项目 Flex 容器中的子元素 main axis 主轴 默认水平轴为主轴，单个项目占据的主轴空间叫 main size cross axis 交叉轴 默认垂直轴为交叉轴，单个项目占据的主轴空间叫 cross size 三 声明容器 语法 说明 display:flex 块级弹性盒子 display:inline-flex 内联级弹性盒子 四 容器属性4.1 flex-flow1flex-flow: flex-direction || flex-wrap 4.2 flex-direction 决定主轴的方向 取值 说明 row（默认） 主轴为水平方向，起点在左端（从左到右） row-reverse 主轴为水平方向，起点在右端（从右到左） column 主轴为垂直方向，起点在上沿（从上到下） column-reverse 主轴为垂直方向，起点在下沿（从下到上） 4.3 flex-wrap 定义如果项目一条轴线排不下，如何换行 取值 水平主轴 垂直主轴 nowrap（默认） 不换行，会缩小项目来摆放 不换列 wrap 换行，新行在下 换列，新列在右 wrap-reverse 换行，新行在上 换列，新列在左 4.4 justify-content 定义项目在主轴上的对齐方式 取值 说明 flex-start（默认） 主轴起点对齐 flex-end 主轴终点对齐 center 主轴居中对齐 space-between 主轴两端对齐，左右项目紧挨边框，中间项目间距相等 space-around 每个项目两侧的间距相等。即项目之间的间隔是项目与边框的间隔的2倍 space-evenly 所有间距都相等 4.5 align-items 定义项目在交叉轴上的对齐方式（单行） 取值 说明 stretch（默认） 如果项目未设置高度或设为auto，将占满整个容器的高度 center 交叉轴居中对齐 flex-start 交叉轴起点对齐 flex-end 交叉轴终点对齐 baseline 项目的第一行文字的基线对齐 4.6 align-content 定义项目在交叉轴上的对齐方式（多行），项目有换行，单行无效 取值 说明 stretch（默认） 轴线占满整个交叉轴 flex-start 交叉轴起点对齐 flex-end 交叉轴终点对齐 center 交叉轴居中对齐 space-between 交叉轴两端对齐，两侧轴线紧挨边框，中间轴线间距相等 space-around 每根轴线两侧的间距都相等。所以，轴线之间的间距是轴线与边框的 2 倍 space-evenly 所有间距相等 五 项目属性5.1 flex-grow 当所有项目宽度之和小于容器宽度，即容器有剩余空间 剩余空间 = 容器宽度 - 项目宽度之和 所有项目的 flex-grow 之和等于 n ，则把剩余空间分为 n 份 然后根据每个项目 flex-grow 所占比例放大项目 值 说明 &lt;number&gt; 放大比例，默认为 0，不能为负 5.2 flex-shrink 当所有项目宽度之和大于容器宽度，即容器不足，溢出空间 = 项目宽度之和 - 容器宽度 根据计算规则算出每个项目的大小（很复杂） 值 说明 &lt;number&gt; 缩小比例，默认为 1，不能为负 5.3 flex-basis 指定了 项目在主轴方向上的初始大小。 优先级 min-width max width / min-height max-height &gt; flex-basis &gt; width / heifht 值 说明 auto（默认） 项目的本来大小（参照 width 和 height 属性） &lt;length&gt; 长度单位 &lt;percentage&gt; 相对于弹性容器主轴尺寸的百分比 content 基于项目的内容自动调整大小 5.4 flex1flex: flex-grow flex-shrink? || flex-basis 值 说明 0 1 auto（默认） 即三个属性分别的默认值 auto 相当于 1 1 auto none 相当于 0 0 auto 5.5 align-self 单独定义项目自己在交叉轴上对齐方式 值 说明 auto（默认） 设置为父元素的 align-items 值，如果该元素没有父元素的话，就设置为 stretch strech 如果项目未设置高度或设为 auto，将占满整个容器的高度 flex-start 交叉轴起点对齐 flex-end 交叉轴终点对齐 center 交叉轴居中对齐 baseline 项目的第一行文字的基线对齐 5.6 order 定义项目的排列顺序。数值越小，排列越靠前 值 说明 &lt;integer&gt; 默认为 0，可以为负","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"CSS继承和层叠","slug":"UI/CSS继承和层叠","date":"2020-11-08T13:02:25.000Z","updated":"2020-11-08T13:05:05.648Z","comments":true,"path":"2020/11/08/UI/CSS继承和层叠/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/CSS%E7%BB%A7%E6%89%BF%E5%92%8C%E5%B1%82%E5%8F%A0/","excerpt":"","text":"一 继承1.1 控制继承 CSS 提供了四个通用属性值来控制继承，元素的每个属性都可以设置这四个值 值 说明 inherit 开启继承 initial 设置 CSS 属性为它的默认值 unset 如果该属性默认可继承，该值等同于 inherit，如果该属性是非继承属性，该值等同于 initial revert 只有很少的浏览器支持 1.2 元素可继承属性12345678azimuth border-collapse border-spacing caption-side color cursordirection elevation empty-cells font-family font-size font-style font-variant font-weight font letter-spacing line-height list-style-image list-style-position list-style-type list-styleorphans pitch-range pitch quotes richness speak-headerspeak-numeral speak-punctuation speak speech-rate stresstext-align text-indent text-transform visibility voice-family volumewhite-space widows word-spacing font-*， color text-* line-height list-* visibility cursor letter-spacing 和 word-spacing 二 层叠2.1 概述 概念 名称 说明 stacking context 层叠上下文 层叠上下文是一个概念，可以想象成 z 轴上的一个层叠结界 stacking level 层叠等级 决定了同一个层叠上下文中元素在 z 轴上的显示顺序 2.2 层叠上下文1 层叠上下文特性 层叠上下文的层叠水平要比普通元素高。 层叠上下文可以阻断元素的混合模式 层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。 每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。 每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中 2 创建层叠上下文 页面根元素&lt;html&gt;天生具有层叠上下文，称为根层叠上下文。 定位元素（position非static）的 z-index 不是auto，会创建层叠上下文 其它css3属性创建层叠上下文 元素为 flex 布局元素（即父元素 display:flex / inline-flex），同时 z-index值不是 auto。 元素的 opacity 值不是 1。 元素的 transform 值不是 none。 元素 mix-blend-mode 值不是 normal。 元素的 filter 值不是 none。 元素的 isolation 值是 isolate。 元素的 will-change 属性值为上面 2～6 的任意一个（如willchange:opacity、will-chang:transform 等）。 元素的-webkit-overflow-scrolling 设为 touch。 2.3 层叠等级 1 同一个层叠上下文中的七层 层叠上下文的背景和边框 层叠上下文中z-index值为负的层叠上下文元素 层叠上下文中块级普通元素 层叠上下文中浮动元素 层级上下文中内联普通元素 此层包含三种 层叠上下文中不依赖z-index 的层叠上下文元素（即元素创建层叠上下文时不是用的z-index） 层叠上下文中z-index值为 0 的层叠上下文元素 层叠上下文中z-index值为 auto 的普通定位元素 元素一旦成为定位元素，其z-index就会自动生效，默认为auto 定位元素的z-index值为数值时才是层叠上下文，所以此时是普通定位元素，并非层叠上下文 层叠上下文中z-index值为负的层叠上下文元素 2 比较步骤 首先查看两个元素是否在同一个层叠上下文 否，则查看它们所在的层叠上下文是否在同一个层叠上下文，如果还不是，继续往上…直到两个层叠上下文在同一个层叠上下文中，最终肯定在同一个层叠上下文，因为有根层叠上下文。 是，则根据它们的层叠水平，在层叠顺序中找到位置。 如果在层叠顺序中位置相同 如果明显的层叠水平标识的，如生效的 z-index，则谁大谁在上 如果没有明显的层叠水平标识的，则后来居上（即在 DOM 流中处于后面的元素会覆盖前面的元素） 2.4 z-index 只能用在 定位元素 和 flex 布局中的项目 值 说明 auto（默认） 不会创建一个新的本地堆叠上下文 &lt;integer&gt; 创建层叠上下文，可以为负","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"CSS浮动定位","slug":"UI/CSS浮动定位","date":"2020-11-08T13:02:17.000Z","updated":"2020-11-08T13:04:24.532Z","comments":true,"path":"2020/11/08/UI/CSS浮动定位/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/CSS%E6%B5%AE%E5%8A%A8%E5%AE%9A%E4%BD%8D/","excerpt":"","text":"一 概述 CSS 有三种机制摆放盒子 正常文档流（标准流） 块级元素自上而下，独占一行 行内元素从左到右，碰到父元素自动换行 浮动 元素在正常流元素之上 定位 元素在正常流元素和浮动元素之上 二 浮动2.1 浮动的作用 浮动原本是为了实现文字环绕效果 让块级盒子排成一行 盒子左右对齐 2.2 浮动的特性1 破坏文档流 浮动会使元素脱离正常文档流，漂浮在正常文档流上方且不再占据正常文档流位置，直到左边缘或右边缘触及包含块或另一个浮动框的边缘 浮动元素不会超过父盒子的边框或内边距 浮动元素的上一个兄弟元素： 是浮动元素，则当前浮动元素跟随它，一行显示，放不下自动换行 是文档流块级元素，则由于块级元素占据一行，所以那一行没有当前浮动元素的位置了，只能在其下边浮动 是文档流行内或行内块元素，如果行内或行内块元素占满了一行，那么没有当前浮动元素的位置了，只能在其下边浮动；反之，有当前浮动元素的位置，由于浮动元素只会在触及到包含块或另一个浮动的边缘才会停止，所以当前浮动元素会一直浮到行内或行内块元素的前边 浮动元素的下一个兄弟元素： 是文档流块级元素，则由于浮动元素不占据原位置，所以块级元素会上移 是文档流行内或行内块元素或文字，会环绕 浮动元素只会影响当前和后面的正常文档流中的元素，不影响前面 2 块状化元素 浮动会将元素的 display 值改为 block，但是其表现如同行内块 inline-block 元素，不同之处在于行内块元素与其它元素之间默认有空隙，浮动元素紧挨着其它元素 2.3 float（浮动） 取值 说明 none（默认） 无浮动 left 左浮动 right 右浮动 2.4 clear（清除浮动）1 为何要清除浮动 由于浮动元素会影响后边正常文档流中的元素，所以通常会把浮动元素放在一个处于正常文档流的父元素中 父元素通常不会固定高度，而是根据子元素高度来撑开高度，而浮动元素脱离文档流，不占据文档流的位置，就会导致父元素高度塌陷 清除浮动就是为了解决父级元素因为子级浮动引起内部高度为 0 的问题 2 clear 取值 取值 说明 none（默认） 允许浮动元素出现在两侧。 left 在左侧不允许浮动元素。 right 在右侧不允许浮动元素。 both 在左右两侧均不允许浮动元素。 CSS 的清除浮动只能影响清除浮动的元素本身，无法影响其它元素 clear 属性只对块级元素有效 3 清除浮动的方式 方式 说明 父元素显式定义高度 height 不推荐，只适合高度固定时使用 父元素末尾添加一个空标签 clear 清除浮动 不推荐，增加不必要的标签 父元素创建伪元素 clear 清除浮动 推荐 父元素 overflow: hidden 父元素触发 BFC 1 父元素创建伪元素的方式12345678// 父元素添加 class=&quot;.clearfix&quot;.clearfix::after &#123; content: &apos;&apos;; display: block; // clear 只对块级元素有效，伪元素默认为内联元素 height: 0; clear: both; visibility: hidden;&#125; 2 BFC（Block Formatting Context）1 BFC 概念 概念 说明 FC（formattion context） 格式化上下文，就是正常文档流 BFC（Block Formatting Context） 块级格式化上下文 IFC（inline formattion context） 行内格式化上下文 GFC（grid formattion context） 栅格格式化上下文 块级格式化上下文，是 css 布局的一个概念，是一块区域，一个环境 2 BFC 触发条件 元素 说明 根元素 &lt;html&gt; 浮动元素 float: left / right 绝对定位元素 position: absolute / fixed overflow 不为 visible overflow: hidden / auto / scroll display display: inline-block / table-cell / table-caption / flex / inline-flex 3 BFC 布局规则 计算 BFC 的高度时，浮动元素也参与计算（用来清除浮动影响） BFC 会形成一个隔离的独立容器，容器中的子元素不会影响到外面的元素；外面的元素也不会影响到容器中的子元素 BFC 中每个子元素的 margin-box 的左边会接触 BFC容器的左边，无论子元素是否浮动 BFC 的区域不会与 float box 重叠 4 BFC 应用1 清除浮动 由于 BFC 容器计算高度会计算浮动元素，所以只需父元素触发 BFC 即可清除浮动 2 两栏自适应布局 左边元素浮动，右边元素触发 BFC即可，因为 BFC 的区域不会与 float box 重叠，如图文两栏布局 图文排列时，图片浮动，就形成文字环绕 如果想让图片在左，文字在右的两列布局，只需文字容器触发 BFC 即可 3 解决相邻元素 margin 合并 由于 BFC 与外界元素不会相互影响，所以只需相邻元素不在同一个 BFC 容器中即可 三 定位3.1 概述 定位 = 定位模式 + 边偏移 绝对定位会块级化元素，表现如同行内块：包裹性和自适应性 3.2 边偏移 方位属性 说明 top 顶部偏移量（CSS 中 X 轴向右为正，Y 轴向下为正） bottom 底部偏移量 left 左侧部偏移量 right 右侧部偏移量 3.3 position 取值 名称 基点 特点 元素块级化（行内块） static（默认） 静态定位，无定位 正常标准流 没有边偏移 × relative 相对定位 相对于元素原来在标准流中的位置定位 占据标准流位置 × absolute 绝对定位 1. 相对于离元素最近的带定位的祖先元素定位2. 若没有，则相对于 &lt;html&gt; 定位 不占据标准流位置，会随着滚动条滚动 √ fixed 固定定位（绝对定位的一种特殊形式） 相对于浏览器可视窗口定位 不占据标准流位置，不会随着滚动条滚动 √ sticky 粘性定位 1 static 元素在正常的流中，按照标准流特性摆放位置 没有边偏移，即忽略 top, bottom, left, right, z-index 2 sticky sticky会产生动态效果，很像relative和fixed的结合：一些时候是relative定位（定位基点是自身默认位置），另一些时候自动变成fixed定位（定位基点是视口） sticky生效的前提是，必须搭配top、bottom、left、right这四个属性中的一个或多个一起使用（看滚动方向），不能省略，否则等同于relative定位，不产生”动态固定”的效果 不能有任何祖先元素设置overflow:hidden，否则没有粘滞效果。因为改变了滚动容器（即使没有出现滚动条） 父元素的高度不能低于sticky元素的高度 sticky元素仅在其父元素内生效，不会超出父元素，滚动时会随着父元素一起消失 当页面滚动，父元素开始脱离视口时（即部分不可见），只要与sticky元素的距离达到生效门槛（设置的top/bottom/left/right），relative定位自动切换为fixed定位，等到父元素完全脱离视口时，fixed定位恢复成relative定位 同一个父容器中的sticky元素，如果定位值相等，则会重叠；如果属于不同父元素，则会随着父元素不再完整占据sticky元素的固定区域以后，再由其他父元素的sticky子元素占据固定位置 我的理解就是设置了粘性定位的元素，没到达所设置的偏移量时，为相对定位，到达后就变为固定定位，但只局限在父元素在视口内，如果父元素都滚走了，也会一同滚走（当然此时为相对定位） 3.4 绝对定位元素居中的两种方式123456// 1 position: absolute;// 1.1 首先向右向下移动父元素宽高的一半left: 50%; top: 50%;// 1.2 由于参照点是子元素的左上角，所以要向左向上分别移动子元素宽高的一半（margin或者transform:translate）margin-left: -50%; margin-top: -50%; 123456// 2position: absolute;// 2.1 使水平和垂直方向具有填充特性left: 0; right: 0; top:0; bottom:0;// 2.2 margin:auto 触发计算，自动平分margin: auto;","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"CSS盒子模型","slug":"UI/CSS盒子模型","date":"2020-11-08T13:02:10.000Z","updated":"2020-11-08T13:04:52.694Z","comments":true,"path":"2020/11/08/UI/CSS盒子模型/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"一 组成 组成 盒子名称 content content-box padding padding-box border border-box margin 没有名称 二 content box2.1 content1 概述 content 属性插入的内容都是匿名替换元素，替换元素都是内联元素 content 属性通常用在::before / ::after 这两个伪元素中 content 属性生成的内容特点 无法选中、无法复制的 content 无法影响:empty 选择器（即有content还是适配:empty） content 动态生成值无法获取，如计数器 2 取值 值 说明 none 不会产生伪元素 normal ::before 和 ::after 中会被当作none &lt;string&gt; 字符串 &lt;url&gt; 图片可以是png、jpg、ico、svg文件以及 base64URL，但不支持 CSS3 渐变背景图 attr() 获取原生 html 属性或者自定义属性的值，属性不要加引号 &lt;counter&gt; 计数器 open-quote / close-quote 开闭引号 no-open-quote / no-close-quote 不要开闭引号 3 应用1 content 辅助元素生成 核心点不在于 content 生成的内容，而是伪元素本身，如 最常用的清除浮动，clear只能用在块级元素上，所以要改变display 12345.clear::after &#123; content: &apos;&apos;; display: block; clear: both;&#125; 2 计数器1234567891011// 1 定义计数器conter-reset: 计数器名 初始值（默认 0）// 2 定义计数器递增规则counter-increment: 计数器名 递增值（默认 1）// 3 使用计数器counter(counterName, style) style：即 list-style-type 支持的值，默认是数字 显示结果：1 2 3 ...counters(counterName, string, style) string：指定序号和子序号之间的符号 显示结果：1.1 1.2 2.1 ... 2.2 width 值 说明 auto（默认） 浏览器将会为指定的元素计算并选择一个宽度. &lt;length&gt; 指定值 &lt;percentage&gt; 指定为包含块宽度的百分比 fill-available 元素宽度自动填满可用空间 fit-content 元素宽度包裹内容，文本内容正常换行。如浮动、绝对定位、inline-block 元素或 table 元素 min-content 元素宽度为内部元素”首选最小宽度”最大的那一行的宽度 max-content 元素宽度为内部元素宽度值最大的那个元素的宽度 1 min-content 首选最小宽度 指的是元素最适合的最小宽度 类似图片这样的替换元素的最小宽度就是该元素内容本身的宽度 文本 CJK（中日韩）可以任意断行，最小宽度就是每个字符的宽度 non-CJK一般在空格、短横线、问号以及其他非英文字符等断行，最小宽度由连续的英文字符单元决定 2 fit-content 和 max-content 区别 两者的元素宽度其实都是内部元素最大的那个宽度 区别在于fit-content内部元素文字可以正常换行，而max-content内部元素文字不换行 3 CSS 流体布局下的宽度分离原则 宽度分离原则即CSS 中的 width 属性不与影响宽度的 padding/border（有时候包括 margin）属性共存 应该width 独立占用一层标签，而padding、border、margin 利用流动性在内部自适应呈现 2.3 height 值 说明 auto（默认） 浏览器将会为指定的元素计算并选择一个高度. &lt;length&gt; 指定值 &lt;percentage&gt; 指定为包含块高度的百分比 fill-available 充分利用可用空间 fit-content 收缩到包裹内容 min-content 收缩到最小 max-content 最大内容高度 2.4 min-width / max-width 和 min-height / max-height1 与众不同的初始值 width / height 的默认值是 auto min-width / min-height 的默认值是auto（w3c/mdn上是0） max-width / max-height的默认值是none 2 权重（width / height 规则相同） width，min-width，max-width只有其中一个，则最终宽度为其值 有width 和 max-width，则最终宽度不能大于max-width width &lt; max-width 时，最终宽度为width的值 width &gt; max-widht 时，最终宽度为max-width的值 有width 和 min-width，则最终宽度不能小于min-width width &gt; min-width 时，最终宽度为width的值 width &lt; min-widht 时，最终宽度为min-width的值 有min-width和max-width，则最终宽度为二者中较大的那个值 min-width &lt; max-width 时，则最终宽度为max-width的值 min-width &gt; max-width 时，则最终宽度为min-width的值 有width，min-width，max-width min-width &gt; max-width，无论width值如何，最终宽度都是min-width的值 min-width &lt; max-width，根据width取值，最终宽度在最小和最大宽度之间 width &lt; min-width &lt; max-width，则最终宽度为min-width的值 min-width &lt; width &lt; max-width，则最终宽度为width的值 min-width &lt; max-width &lt; width，则最终宽度为max-width的值 三 padding box3.1 padding1 概述 块级元素 替换内联元素 非替换内联元素 有影响 有影响 水平方向有影响，垂直方向不改变元素高度，但是改变背景高度 如果不指定 width 或 height，padding 不会撑开对应方向的盒子 2 取值 值 说明 &lt;length&gt; 指定值 &lt;percentage&gt; 相对于宽度的百分比 3 设置值规则 值数量 说明 一个值 同时设置四个边内边距 二个值 上下，左右 三个值 上，左右，下 四个值 上，右，下，左 3.2 四个边单独的 padding 属性 padding-top padding-right padding-bottom padding-left 四 border box4.1 border123boder-color ||boder-style ||border-width 1 border-width 值 说明 &lt;legnth&gt; 指定值 thin 薄，等同于 1px medium（默认） 薄厚均匀，等同于 3px thick 厚，等同于 4px 2 border-style 值 说明 none（默认） 不显示边框，none 值优先级最低，如果存在其他的重叠边框，则会显示为那个边框 hidden 不显示边框，hidden 值优先级最高，如果存在其他的重叠边框，边框也不会显示。 solid 单实线 double 双实线，边框宽最少3px才有效果 dotted 点画线 dashed 虚线 groove 雕刻效果，与 ridge 相反 ridge 浮雕效果，与 groove 相反 inset 陷入效果 outset 突出效果 3 border-color 值 说明 currentColor（默认） 默认为字体颜色 &lt;color&gt; 颜色值 4.2 四个边单独的 border 属性 border-top border-top-color border-top-style border-top-width border-right border-right-color border-right-style border-right-width border-bottom border-bottom-color border-bottom-style border-bottom-width border-left border-left-color border-left-style border-left-width 4.3 border-radius（圆角）1 取值 值 说明 &lt;percentage&gt; 相对于 border box 的百分比 &lt;length&gt; 长度 2 设置值语法1第一组值（水平半径）/ 第二组值（垂直半径） # 垂直省略表示同水平一致 每组值的数量 说明 一个值 四个角 二个值 左上角右下角，右上角左下角 三个值 左上角，右上角左下角，右下角 四个值 左上角，右上角，右下角，左下角 3 每个角单独设置 border-垂直-水平-radius: 水平半径 垂直半径（可省略） border-top-left-radius border-top-right-radius border-bottom-right-radius border-bottom-left-radius 4 最大尺寸 &amp; 等比缩放 图形尺寸是有限的，所以圆角半径设置过大时，也只会按照最大尺寸来算，且值会根据设置时的比例变化 例如 border box 宽200px，高300px，此时设置 border-radius: 300px; 水平半径最大只能到200px，所以按200px算，垂直半径虽然能到300px，但是设置时300:300水平与垂直比例是1:1，垂直半径也要跟着变化，结果水平和垂直半径都是200px 五 margin box5.1 margin1 概述 margin 对块级元素有影响，且垂直方向有 margin 合并 margin 对替换内联元素有影响，且垂直方向无 margin 合并 margin 对非替换内联元素水平方向有影响，垂直方向无影响 2 取值 值 说明 auto 浏览器会自动选择一个合适的margin来应用 &lt;length&gt; 指定值 &lt;percentage&gt; 相对于宽度的百分比 3 设置值规则 值数量 说明 一个值 同时设置四个边外边距 二个值 上下，左右 三个值 上，左右，下 四个值 上，右，下，左 4 margin: atuo1 计算规则 如果一侧定值，一侧 auto，则 auto 为剩余空间大小。 如果两侧均是 auto，则平分剩余空间 2 触发计算前提条件 width 或 height 为 auto 时，元素是具有对应方向的自动填充特性 自动填充特性 块级元素 width 为 auto 时，水平方向会自动填充 绝对定位元素 如果设置 left 和 right 为 0，则水平方向填充特性 如果设置 top 和 bottom 为 0，则垂直方向有填充特性 5 margin 合并1 概述 块级元素的上外边距（margin-top）与下外边距（margin-bottom）有时会合并为单个外边距 不包括浮动和绝对定位元素，尽管浮动和绝对定位可以让元素块状化 2 场景 相邻兄弟元素 margin 合并 父级和第一个/最后一个子元素 margin 合并（子元素的 margin 表现得如同作用在父元素上） 解决margin-top 合并 父元素设置为块状格式化上下文元素 父元素设置 border-top 值 父元素设置 padding-top 值 父元素和第一个子元素之间添加内联元素进行分隔 解决margin-bottom 合并 父元素设置为块状格式化上下文元素 父元素设置 border-bottom 值 父元素设置 padding-bottom 值 父元素和最后一个子元素之间添加内联元素进行分隔 父元素设置 height、min-height 或 max-height 空块级元素的 margin 合并 解决 设置垂直方向的 border； 设置垂直方向的 padding； 里面添加内联元素（直接 Space 键空格是没用的）； 设置 height 或者 min-height。 3 计算规则 如果合并外边距皆为正，取最大值 如果合并外边距皆为负，取最小值（即绝对值最大值） 如果合并外边距有正有负，取最大正外边距与最小负外边距之和 4 margin 无效的场景 非替换内联元素的垂直方向 &lt;tr&gt;&lt;td&gt;标签或者 display为 table-row table-cell 的元素 绝对定位元素非定位方位的 margin 值表面“无效” 5.2 四个边单独的 margin 属性 margin-top margin-right margin-bottom margin-left 5.3 应用 块级盒子水平居中 盒子指定了宽度 width 盒子左右外边距都为 auto 行内或行内块水平居中，只需父盒子设置 text-align: center 六 box-sizing 改变盒子模型 值 说明 content-box（默认） 盒子模型为 内容盒子 border-box 盒子模型为 边框盒子 七 box-shadow1234567[ inset? [&lt;offset-x&gt; &lt;offset-y&gt;] &lt;blur-radius&gt;? &lt;spred-radius&gt;? &lt;color&gt;? ]# 属性 说明 inset? 默认阴影向外扩散 outset，inset 设置为向内扩散 [&lt;offset-x&gt; &lt;offset-y&gt;] 阴影 X 轴和 Y 轴的偏移量（必须），&lt;length&gt; &lt;blur-radius&gt;? 模糊半径，即阴影的虚实程度，&lt;length&gt; &lt;spred-radius&gt;? 阴影扩散半径，默认为0，取正值时，阴影扩大；取负值时，阴影收缩 &lt;color&gt;? 阴影颜色","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"CSS内联盒模型","slug":"UI/CSS内联盒模型","date":"2020-11-08T13:02:03.000Z","updated":"2020-11-08T13:05:29.654Z","comments":true,"path":"2020/11/08/UI/CSS内联盒模型/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/CSS%E5%86%85%E8%81%94%E7%9B%92%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"一 内联盒模型组成1.1 内容区域 content area 文字内容区域可以理解为选中文字时的区域 content area 高度由 font-size 和 font-family 决定 font-family 为 simsun(宋体) 时，content area = font-size 图片这样的替换元素，内容区域可以看成元素自身 1.2 内联盒子 inline box 内联盒子：内联元素都有一个内联盒子 匿名内联盒子：纯文本 注意：并不是所有光秃秃的文字都是“匿名内联盒子”，关键要看前后的标签是内联还是块级 1.3 行框盒子 line box 由连续的“内联盒子”组成的一行就是行框盒子 inline 内联元素形成行框盒子的是内部的文字，如果内部为空，就形不成行框盒子 inline-block 内联元素形成行框盒子的是元素本身，内部为空也能形成行框盒子 行框盒子的高度是由高度最高的那个“内联盒子”决定 1.4 空白幽灵节点 strut 每个 line-box 起始位置都有一个具有该元素的字体和行高属性的 0 宽度的内联盒，此内联盒叫做strut（支柱）。 永远透明，无法获取，表现如同文本节点一样，也是个盒子 二 行高2.1 概念 概念 说明 x-height 小写字母 x 的高度，即基线与中线的距离，CSS 中单位为 ex content area ≈ font-size line-height 行高，即两基线之间的距离，等价于 font-size + 行间距 基线 文本内联元素的基线就是小写 x 的下边缘 类似图片这样的元素的基线就是其下边缘 inline-block 元素 如果该元素中有内联元素，基线就是最后一行内联元素的基线 如果该元素内没有内联元素或者 overflow 不是 visible，其基线就是 margin 的底边缘 2.2 line-height &amp; font-size1 line-height &lt; font-size 此时间距为负，会发生重叠 2 line-height = font-size 此时间距为 0，刚好不重叠，所以最好设置 line-height &gt; font-size 2.3 line-height &amp; height（包含元素的高度）1 line-height &lt; height 此时文字在包含元素中偏上的位置 2 line-height = height 此时文字在包含元素中垂直居中 3 line-height &gt; height 此时文字在包含元素中偏下的位置 2.4 line-height 元素 说明 非替换内联元素 line-height 决定高度 替换元素 line-height 无影响 块级元素 line-height 无影响 2.5 vertical-align 用来指定内联元素（inline inline-block inline-table）或表格单元格（table-cell）元素的垂直对齐方式 内联元素默认都会受到 line-height 和 vertical-align 的影响 相对其父元素垂直对齐 值 说明 baseline（默认） 使元素的基线与父元素的基线对齐 sub 使元素的基线与父元素的下标基线对齐 super 使元素的基线与父元素的上标基线对齐 text-top 使元素的顶部与父元素的字体顶部对齐 text-bottom 使元素的底部与父元素的字体底部对齐 middle 使元素的中部与父元素的基线加上父元素x-height的一半对齐 &lt;length&gt; 使元素的基线对齐到父元素的基线之上的给定长度。可以是负数 &lt;percentage&gt; 使元素的基线对齐到父元素的基线之上的给定百分比，该百分比是line-height属性的百分比。可以是负数 相对整行垂直对齐 值 说明 top 使元素及其后代元素的顶部与整行的顶部对齐 bottom 使元素及其后代元素的底部与整行的底部对齐 三 对几个现象的理解3.1123&lt;div&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt; inline 内联元素形成行框盒子的是内部的文字，内部为空，没有形成行框盒子，所以 div 的内部 span 高度为 0，则 div 的高度也为 0 123&lt;div&gt; &lt;span style=&quot;display: inline-block;&quot;&gt;&lt;/span&gt;&lt;/div&gt; inline-block 内联元素形成行框盒子的是元素本身，内部为空也能形成行框盒子，既有了幽灵节点 strut 虽然 span 的高度还是 0，但幽灵节点 strut 默认是有行高的，所以 div 的高度不为 0 3.2123456789&lt;style&gt; div &#123; background: #ddd; border: 1px solid #000; &#125;&lt;/style&gt;&lt;div&gt; &lt;img src=&quot;mm.jpg&quot;&gt;&lt;/div&gt; 底部有空隙的原因 img 形成了行框盒子，所以出现了 strut vertical-align 默认为 base-line 对齐，strut 的 base-line 为 x 的下边缘，img 的 base-line 为底部 而对于文字而言，内容区域高度是顶线与基线的距离，而不是文字上线边缘，所以底部出现空隙 1 在图片前边添加文本现象是一样的 2 解决方式 img 块级化，vertical-align 对块级元素无效（且没有了行框盒子，也就没有了 strut） 修改 vertical-align 为其他值比如 bottom top middle ... 如 bottom，指的是文字内容区域的下边缘和图片的下边缘，自然就没了空隙 减小 line-height 的值，也就是减小行间距，会造成文字向下移动 3.3 单行未必垂直居中 如果包含块没有设置高度，则只要设置 line-height 即可 如果包含块设置了高度，则设置 line-height = height 3.4 多行文本垂直居中 与单行文本居中，原理一样，使用 span 包含多行文本，将此 span 看成单行文本 设置包含块 line-height = height span 设置 display: inline-block vertical-align: middle 为了让 span 在 div 中居中 一个合适的 line-height 作用于 span 内部文本的显示 为何 span 要设置 display: inline-block ? span的display为默认的inline时，形成行框盒子的是span的内容，由于div的line-height会作用于行框盒子的strut，且div的line-height大于span的line-height，所以行框应用的是div的line-height，也就是说span的内容应用的是div的line-height，就会导致文字行距很大 span的display设置为line-block时，形成行框盒子的是span本身，span的内部还会形成一个行框盒子，这时span设置的line-height就会对内部的行框盒子起作用，即span应用的是div的line-height，sanp的内容应用的是span自身的line-height，所以文字就能正常显示","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"CSS元素","slug":"UI/CSS元素","date":"2020-11-08T13:01:51.000Z","updated":"2020-11-08T13:06:28.851Z","comments":true,"path":"2020/11/08/UI/CSS元素/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/CSS%E5%85%83%E7%B4%A0/","excerpt":"","text":"一 display1.1 语法12345[ &lt;display-outside&gt; || &lt;display-inside&gt; ]&lt;display-listitem&gt; | &lt;display-internal&gt; |&lt;display-box&gt; |&lt;display-legacy&gt; 1.2 属性说明1 &lt;display-outside&gt; 决定了元素类型 值 说明 block 块级元素 inline 行内元素 2 &lt;display-inside&gt; 决定了内部元素布局方式 值 说明 flow-root 触发 BFC table 表现如同 &lt;table&gt; flex 弹性布局 grid 栅格布局 flow 了解 ruby 了解，可以加旁注标记，如中文的拼音 3 &lt;display-box&gt; 值 说明 none 不显示，就好像不存在一样，不占空间 4 &lt;display-legacy&gt; 值 说明 inline-block 行内块 inline-table 行表格 inline-flex 行弹性 inline-grid 行栅格 5 &lt;display-listitem&gt;1&lt;display-outside&gt;? &amp;&amp; [ flow | flow-root ]? &amp;&amp; list-item 值 说明 list-item 表现如同 &lt;li&gt;，可以搭配 list-style-type 和 list-style-position 使用 6 &lt;display-internal&gt; 内部属性值 类似 table 和 ruby 等有复杂内部结构的布局模块，它们的子孙有不同的填充方式 值 说明 table-header-group 同 &lt;thead&gt; table-row-group 同 &lt;tbody&gt; table-footer-group 同 &lt;tfoot&gt; table-caption 同 &lt;caption&gt; table-row 同 &lt;tr&gt; table-cell 同 &lt;td&gt; table-column-group 同 &lt;colgroup&gt; table-column 同 &lt;col&gt; ruby-base 同 &lt;rb&gt; ruby-text 同 &lt;rt&gt; ruby-base-container 同 &lt;rbc&gt; ruby-text-container 同 &lt;rtc&gt; 1.3 单值语法 &amp; 双值语法 single value two value block block flow flow-root block flow-root inline inline flow inline-block inline flow-root flex block flex inline-flex inline flex grid block grid inline-grid inline grid table block table inline-table inline table 双值语法未广泛支持，但可以帮助理解单值语法时 &lt;display-outside&gt; 和 &lt;display-inside&gt; 的默认值 二 元素类型2.1 概述 类型 单值 双值 块级元素 block block flow 行内元素 inline inline flow 内联块元素 inline-block inline inline-block 2.2 块级元素1 特点 独占一行，自上而下排列 宽度、高度和内外边距可以直接设置 宽度：默认为父元素宽度的 100% 高度：默认为 0，高度与其内容高度一致 块级元素是一个容器或盒子，可以容纳行内元素或块级元素 p h1~6 dt 等文字类块级元素内部不能放块级元素 2 默认块级元素 默认块级元素 display &lt;div&gt; block &lt;header&gt; &lt;main&gt; &lt;footer&gt; block &lt;article&gt; &lt;aside&gt; &lt;section&gt; block &lt;h1&gt;~&lt;h6&gt; block &lt;p&gt; block &lt;ul&gt; &lt;ol&gt; block &lt;li&gt; list-item &lt;dl&gt; &lt;dt&gt; &lt;dd&gt; block &lt;hr&gt; block &lt;table&gt; table &lt;form&gt; block &lt;option&gt; block &lt;address&gt; block &lt;blockquote&gt; block &lt;pre&gt; block &lt;menu&gt; block 2.3 行内元素1 特点 包裹性：默认宽高就是它本身内容的宽高 自适应性：在一行显示，从左至右排列，如果一行不足以容纳，会换行 直接设置宽高无效 只能容纳文本或行内元素 &lt;a&gt; 中不能容纳 &lt;a&gt; &lt;a&gt; 中可以容纳块级元素 2 默认内联元素 默认内联元素 display &lt;span&gt; inline &lt;a&gt; inline &lt;strong&gt; inline &lt;em&gt; inline &lt;del&gt; inline &lt;ins&gt; inline &lt;br&gt; inline &lt;label&gt; inline 2.4 行内块元素1 特点 包裹性：默认宽高就是它本身内容的宽高 自适应性：在一行显示，从左至右排列（和其它行内或行内块元素之间会有空白缝隙），如果一行不足以容纳，会换行 宽度、高度和内外边距可以直接设置 2 默认行内块元素 默认行内块元素 display &lt;img&gt; inline &lt;input&gt; inline-block（type=hidden 时是 none） &lt;button&gt; inline-block &lt;select&gt; inline-block &lt;textarea&gt; inline-block &lt;td&gt; table-cell 三 非替换元素 &amp; 替换元素3.1 概述 根据 “外在盒子” 把元素分为内联元素和块级元素 根据是否具有可替换内容，把元素分为替换元素和非替换元素 3.2 非替换元素 如果元素的内容包含在文档中，则称之为非替换元素 html 的大多数元素是不可替换元素，即其内容直接表现给浏览器 如 &lt;p&gt; 文档内容是什么，显示结果就是什么 3.3 替换元素1 说明 浏览器根据元素的标签和属性，来决定元素的具体显示内容（即content box内容可替换，对应的 CSS 属性是 content） 如 &lt;img&gt; &lt;object&gt; &lt;video&gt; &lt;iframe&gt; &lt;textarea&gt; &lt;input&gt; &lt;img&gt;，修改src属性就会改变显示结果 匿名可替换元素 通过 CSS content 属性来插入的对象 被称作 匿名可替换元素 所有的替换元素都是内联元素 2 替换元素的特性1 内容的外观不受页面上的 CSS 的影响 替换元素是一种外部对象，它们外观的渲染，是独立于 CSS 的 样式表现在css作用域之外，如果要替换元素本身的外观，需要类似appearance的属性。或者是浏览器本身暴露的接口。但是直接input[type=&#39;checkbox&#39;]{}没办法改变内间距背景色等特性 2 有自己的尺寸 在 Web 中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是 300 像素×150 像素 如 &lt;video&gt; &lt;iframe&gt; &lt;canvas&gt; 少部分替换元素为 0 像素，如&lt;img&gt; 表单元素的替换元素的尺寸则和浏览器有关，没有明显的规律 3 在很多 CSS 属性上有自己的一套表现规则 如 vertical-align 默认值的 baseline ，但对于替换元素，默认为元素的下边缘 3 替换元素的尺寸计算规则1 尺寸类型 固有尺寸 指的是替换内容原本的尺寸 如图片，视频都有自身的尺寸 HTML 尺寸 HTML 尺寸只能通过HTML 原生属性改变 HTML 原生属性，如&lt;img&gt;的 width 和 height 属性、&lt;input&gt;的 size 属性、&lt;textarea&gt;的 cols 和 rows 属性等 CSS 尺寸 可以通过 CSS 的 width 和 height 或者 max-width/min-width 和max-height/min-height 设置的尺寸 对应盒尺寸中的 content box 2 计算规则 没有 CSS 尺寸和 HTML 尺寸，则使用固有尺寸作为最终的宽高 没有 CSS 尺寸，则使用 HTML尺寸作为最终的宽高 有 CSS 尺寸，则最终尺寸由 CSS 属性决定 如果固有尺寸含有固有的宽高比，css尺寸和html尺寸如果只设置了宽高中的一个，则另一个值根据固有尺寸宽高比变化 如果以上都不符合，则最终宽度表现为 300 像素，高度为 150 像素 &lt;img&gt; 较为特殊 chrome下默认为0*0 firefox下默认为0*22，且firfox下如果省略src属性，则&lt;img&gt;不是替换元素，而是一个普通的内联元素 内联替换元素和块级替换元素使用上面同一套尺寸计算规则 即内联替换元素块级化，计算规则不变 无法改变替换元素内容的固有尺寸 我们为&lt;img&gt;设置宽高，好像是覆盖了固有尺寸，其实改变的是content box的宽高，而&lt;img&gt;的content box替换内容默认适配方式是填充（fill） css3替换元素的替换内容的适配方式可以通过object-fit 属性修改","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"CSS样式","slug":"UI/CSS样式","date":"2020-11-08T13:01:44.000Z","updated":"2020-11-08T13:06:03.223Z","comments":true,"path":"2020/11/08/UI/CSS样式/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/CSS%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"一 background（背景）1.1 语法123456background-color ||background-image ||background-position [ / background-size]? || background-repeat ||background-attachment ||[background-origin background-clip?] 1.2 属性说明1 background-color 值 说明 transparent（默认） 透明 currentColor 当前元素的字体颜色 &lt;color&gt; 设置颜色 2 background-image 值 说明 none（默认） 无背景图 url url(地址不提倡加引号) &lt;gradient&gt; 渐变 3 background-repeat css3 定义时使用两个值，如果只设置一个，也会被解析成两个 单值 说明 双值 repeat（默认） 平铺 repeat repeat repeat-x x 轴平铺 repeat no-repeat repeat-y y 轴平铺 no-repeat repeat no-repeat 不平铺 no-repeat no-repeat space 两端对齐平铺，多出来的空间用空白代替 space space round 两端对齐平铺，多出来空间通过自身的拉伸来填充 round round 4 background-position x轴 y轴，如果只设置一个值，另一个默认居中 值 说明 关键字 left right top bottom center &lt;length&gt; 长度 px em ... &lt;percentage&gt; 百分比 5 background-size 宽 高，如果只设置一个值，另一个值为 auto，保持宽高比 值 说明 auto（默认） 以背景图片的比例缩放背景图片 cover 缩放背景图片以完全覆盖背景区，可能背景图片部分看不见 contain 缩放背景图片以完全装入背景区，可能背景区部分空白 &lt;length&gt; 长度 &lt;percentage&gt; 背景图片相对背景区的百分比 6 background-attachment 决定背景图像的位置是在视口内固定，还是随着包含它的区块滚动。 值 说明 元素滚动条 页面滚动条 scroll（默认） 背景相对于元素本身固定，融为一体 背景不动 背景会动 fixed 背景相对于视口固定 背景不动 背景不动 local 背景相对于元素的内容固定 背景会动 背景会动 7 background-origin 决定背景图片相对于哪个盒子定位 值 说明 padding-box（默认） 相对于 padding-box 定位 content-box 相对于 content-box 定位 border-box 相对于 border-box 定位 8 background-clip 设置元素的背景切割范围，相对于哪个盒子定位不变 值 说明 border-box（默认） 背景延伸至边框外沿（但是在边框下层） content-box 背景被裁剪至内容区外沿 padding-box 背景延伸至内边距外沿 二 list-style（列表）2.1 语法123list-style-type ||list-style-image ||list-style-position 2.2 属性说明1 list-style-type 值 说明 disc（默认） 实心圆点 none 无样式 circle 空心圆点 square 实心方块 decimal 从1开始的数字 ...... 还有许多样式 2 list-style-image 值 说明 none（默认） 会使用 list-style-type &lt;url&gt; url(地址不提倡加引号) 3 list-style-position 值 说明 outside（默认） 标记盒 ::marker 在主块盒之外 inside 标记盒 ::marker 在主块盒之内，是主块盒中的第一个行内盒 三 表格3.1 border-collapse 值 说明 separate（默认） 分离，HTML 表格的传统模式，相邻单元格都拥有独立的边框 collapse 合并，表格中相邻单元格共享边框 3.2 border-spacing（单元格内边距） 只有 border-collapse: separate 时才有效 单元格没有外边距，有边框和内边距 &lt;length&gt; &lt;length&gt;?：水平 垂直 如果省略垂直则与水平间距相等 3.3 empty-cells 值 说明 show（默认） 空单元格的背景和边框正常显示 hide 空单元格的背景和边框隐藏 3.4 caption-side 值 说明 top（默认） 标题在表格顶部，标题是在表格外面的 bottom 标题在表格底部，标题是在表格外面的 3.5 table-layout 值 说明 auto（默认） 表格及单元格的宽度取决于其包含的内容 fixed 表格和列的宽度通过表格的宽度来设置，某一列的宽度仅由该列首行的单元格决定 四 元素的显示和隐藏4.1 方式 方式 说明 display: none 该元素以及它的所有后代元素都会隐藏，不保留位置，不影响计数器的值 visibility: hidden 隐藏元素，如果后代元素 visibility: visible，则后代元素依然可见，保留位置，会影响计数器的值 4.2 visibility（元素可见性） 值 说明 visible（默认） 元素正常显示 hidden 隐藏元素，但是其他元素的布局不改变，相当于此元素变成透明。若其子元素设为visible，则子元素依然可见 collapse 用于 &lt;table&gt; 行、列、列组和行组，隐藏表格的行或列，并且不占用任何空间，就好像折叠了单元格一般（效果同 display:none ） 五 overflow（元素溢出） 值 说明 visible（默认） 内容不会被修剪，超出内容可见 hidden 内容会被修剪，超出内容不可见 scroll 内容会被修剪，浏览器会显示滚动条以便查看超出内容 auto 如果内容超出，就显示滚动条，反之则不显示 六 opacity（元素透明度） 值 说明 1（默认） 元素完全不透明 0~1 元素半透明 0 元素完全透明 七 用户界面样式7.1 cursor（鼠标样式） 定义鼠标悬浮在元素上方时的样式 值 说明 auto（默认） 浏览器根据内容类别自动选择光标形状 default 箭头 pointer 小手 move 移动 text 文本 not-allowed 禁止 none 隐藏光标，比如看视频时 help 帮助 ... 还有很多样式 7.2 outline（轮廓线）1 语法123outline-style ||outline-width ||outline-color 轮廓线不占据空间 通常不使用轮廓线 outline: none; 2 outline-width 值 说明 &lt;legnth&gt; 指定值 thin 薄 medium 中等 thick 厚 3 outline-style 值 说明 none 无轮廓线 solid 单实线 double 双实线 dotted 点画线 dashed 虚线 groove 雕刻效果，与ridge相反 ridge 浮雕效果，与groove相反 inset 陷入效果 outset 突出效果 7.3 resize resize：是否可以调整元素大小 文本域 textarea 默认是可以调整的，通常会 resize: none; 值 说明 none 不允许用户缩放元素 both 允许用户在水平和垂直方向上调整元素的大小 horizontal 允许用户在水平方向上调整元素的大小 vertical 允许用户在垂直方向上调整元素的大小 八 技巧8.1 CSS 精灵技术1 概述 为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度 CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），这样只需要一次请求即可 CSS 精灵技术主要针对于背景图片，插入的图片 img 是不需要这个技术的 2 使用1234* background-image* background-repeat* background-position * 最关键的是使用background-position 属性精确地定位精灵图中的指定部分 精确测量每个小背景图片的大小和位置 与小背景图大小相同的盒子，并给盒子指定背景图位置 给盒子指定小背景图片时， 背景定位基本都是 负值。 8.2 推拉门123&lt;a&gt; &lt;span&gt;首页&lt;/span&gt;&lt;/a&gt; a 设置 背景左侧，padding撑开合适宽度。 span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。 之所以a包含span就是因为 整个导航都是可以点击的。 8.3 margin 负值 盒子浮动后两个边框挨在一起，设置 margin-left: -1 即可压住一个边 8.4 css 图形1 三角形 宽高为 0 4 个边框都要写， 只保留需要的边框颜色，其余的都改为 transparent透明 8.5 浏览器私有前缀 为了兼容老版本 前缀 浏览器 -webkit- chrome safari -moz- firefox -ms- ie -o- Opera","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"CSS文本","slug":"UI/CSS文本","date":"2020-11-08T13:01:39.000Z","updated":"2020-11-08T13:05:40.388Z","comments":true,"path":"2020/11/08/UI/CSS文本/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/CSS%E6%96%87%E6%9C%AC/","excerpt":"","text":"一 字体1.1 @font face1 作用 自定义字体或字体集 它允许网页开发者为其网页指定在线字体，可以消除对用户电脑字体的依赖 2 语法1234567891011@font-face &#123; [ font-family: &lt;family-name&gt;; ] || [ src: &lt;src&gt;; ] || [ unicode-range: &lt;unicode-range&gt;; ] || [ font-variant: &lt;font-variant&gt;; ] || [ font-feature-settings: &lt;font-feature-settings&gt;; ] || [ font-variation-settings: &lt;font-variation-settings&gt;; ] || [ font-stretch: &lt;font-stretch&gt;; ] || [ font-weight: &lt;font-weight&gt;; ] || [ font-style: &lt;font-style&gt;; ]&#125; 属性 说明 font-family 自定义字体的名称，特殊符号必须使用引号 src 指定在线字体或本地字体，fromat(&#39;woff2&#39;) 转换字体格式，用于浏览器识别 unicode-range 可以让特定的字符或者字符片段使用特定的字体 字体格式 说明 TrueType（.ttf） Windows和Mac上常见的字体格式，是一种原始格式，因此它并没有为网页进行优化处理 OpenType（.otf） 以TrueType为基础，也是一种原始格式，但提供更多的功能 Web Open Font（.woff） 针对网页进行特殊优化，因此是Web字体中最佳格式 SVG（.svg） 基于SVG字体渲染的格式 Embedded Open Type（.eot） IE专用字体格式，可以从TrueType格式创建此格式字体 1.2 font123[ font-style || font-variant || font-weight || font-stretch ]? font-size [ / line-height ]? font-family 1 font-size 值 说明 关键字 xx-small, x-small, small, medium, large, x-large, xx-large, xxx-large, larger, smaller &lt;length&gt; 长度，如 px em ex rem &lt;percentage&gt; 相对父元素字体大小的百分比 2 line-height 值 说明 normal（默认） 与 font-family 有关，不同浏览器和系统字体不同，默认值就不同，所以通常需要重新设置 &lt;number&gt; 推荐，字体大小的倍数。 &lt;length&gt; 长度值（如 px，em） &lt;percentage&gt; 字体大小的百分比 line-height:1.5、line-height:150% 和 line-height:1.5em 计算方式相同： line-height = font-size * 1.5 继承时数值继承的是数值本身，长度和百分比继承的是计算结果，即对于子元素 数值：line-height = 子元素font-size * 1.5 长度和百分比：line-height = 父元素font-size * 1.5 3 font-family 值 说明 &lt;family-name&gt; 字体名称，多个用逗号隔开 &lt;generic-name&gt; 字体系列名称 通用字体系列 说明 monospace 等宽字体，即字体中每个字宽度相同 sans-serif 无衬线字体，即笔画结尾是平滑的字体 serif 带衬线字体，笔画结尾有特殊的装饰线或衬线 cursive 草书字体 fantasy 艺术字体 4 font-style 值 说明 normal（默认） 常规 italic 斜体 oblique &lt;angle&gt;? 倾斜体 可以附加角度 5 font-weight 值 说明 normal（默认） 常规，相当于 400 bold 加粗，相当于 700 lighter 较细 bolder 较粗 &lt;number&gt; 介于 1 和 1000 (包含) 之间 6 font-variant &amp; font-stretch 更像是专为英文设计的，默认即可 1.3 Unicode 字体 字体名称 英文名称 Unicode 编码 宋体 SimSun \\5B8B\\4F53 微软雅黑 Microsoft YaHei \\5FAE\\8F6F\\96C5\\9ED1 新宋体 NSimSun \\65B0\\5B8B\\4F53 黑体 SimHei \\9ED1\\4F53 楷体_GB2312 KaiTi_GB2312 \\6977\\4F53_GB2312 隶书 LiSu \\96B6\\4E66 幼园 YouYuan \\5E7C\\5706 华文细黑 STXihei \\534E\\6587\\7EC6\\9ED1 细明体 MingLiU \\7EC6\\660E\\4F53 新细明体 PMingLiU \\65B0\\7EC6\\660E\\4F53 1.4 color（字体颜色） 值 说明 关键字 black red green blue ... 十六进制 #000 # FFF # 66CCFF ... RGB rgb(r, g, b [, a])，a 透明度（0~1） HSL hsl(h, s, l [,a] transparent 透明，可以近似认为是 rgba(0,0,0,0)的缩写 二 文本排版2.1 text-indent 首行缩进量 值 说明 &lt;length&gt; 长度值 px em ...，允许为负 &lt;percentage&gt; 使用包含块宽度的百分比作为缩进 2.2 text-align 定义 文字、行内元素（inline，inline-block） 相对它的包围块元素水平对齐方式 值 说明 left 左对齐 right 右对齐 center 居中对齐 justify 两端对齐，对最后一行无效 2.3 vertical-align 定义 文字、行内元素（inline，inline-block，inline-table，table-cell）的垂直对齐方式 值 说明 baseline（默认） 相对于父元素基线对齐 middle 相对于与父元素中部对齐，中部 = 基线 + x-heifht/2 top 相对于整行的顶部对齐 bottom 相对于整行底部对齐 2.4 text-overflow 值 说明 clip（默认） 将溢出的文本裁减掉 ellipsis 将溢出的文本用省略号 ... 来表示 2.5 overflow-wrap 原 word-wrap，指定一个不可分割的字符串过长，超过容器盒的宽时应该如何处理 值 CJK（中日韩） non-CJK normal（默认） 单个字符之间换行 在正常的单词结束处换行，保留完整性，可能会溢出容器） break-word 单个字符之间换行 内容将在边界内换行。如果需要，单词内部允许断行 2.6 white-space 设置如何处理空白（空格 space，制表符 tab，换行符 enter） 值 空白 换行 normal（默认） 空格、制表符、换行符合并成一个空格 文本自动换行 nowrap 空格、制表符、换行符合并成一个空格 文本不换行，即强制一行显示 pre 所有东西原样输出 文本不换行 pre-wrap 所有东西原样输出 文本换行 pre-line 空格、制表符合并成一个空格，换行符不变 文本换行 break-spaces 同pre-wrap，但有一些区别 2.7 word-break 控制单词如何被拆分 值 CJK（中日韩） non-CJK normal（默认） 可在任意 2 个字符间断行 只能再空白符处断行 keep-all 只能在空白符处断行 只能在空白符处断行 break-all 可在任意位置断行 可在任意位置断行 2.8 word-spacing 设置单词之间的距离，中文无效 值 说明 normal（默认） 常规 &lt;length&gt; 长度 px em ... &lt;percentage&gt; 百分比 2.9 letter-spacing 设置字符之间的距离，中文有效 值 说明 normal（默认） 常规 &lt;length&gt; 长度 px em ... 三 文本装饰3.1 text-decoration1234text-decoration-line ||text-decoration-style ||text-decoration-color ||text-decoration-thickness 1 text-decoration-line 值 说明 none（默认） 无线 underline 下划线 overline 上划线 line-through 删除线 2 text-decoration-style 值 说明 solid（默认） 单实线 double 双实线 dotted 点划线 dashed 虚线 wavy 波浪线 3 text-decoration-color 值 说明 &lt;color&gt; 设置装饰线的颜色 4 text-decoration-thickness 值 说明 auto 浏览器为文本装饰线选择合适的宽度 from-font 如果字体文件中包含了首选的宽度值，则使用此字体文件的宽度值，否则同auto &lt;length&gt; 指定装饰线宽度 px em ... 3.2 text-transform 值 说明 none（默认） 无影响 capitalize 每个单词首字母大写 uppercase 所有字母大写 lowercase 所有字母小写 3.3 text-shadow123[&lt;length&gt; &lt;length&gt;] // 元素在 X 和 Y 方向的偏移量（必须）&lt;length&gt;? || // 模糊半径（可选）color? // 阴影颜色（可选）","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"CSS选择器","slug":"UI/CSS选择器","date":"2020-11-08T13:01:33.000Z","updated":"2020-11-08T13:05:52.045Z","comments":true,"path":"2020/11/08/UI/CSS选择器/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/CSS%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"","text":"一 权重 规则 粒度 !important ∞ 行内样式 style 1, 0, 0, 0 id 0, 1, 0, 0 class，伪类，属性 0, 0, 1, 0 标签，伪元素 0, 0, 0, 1 * 0, 0, 0, 0 继承 null（继承没有权重，比 0 小） 比较样式的优先级：算出所有选择器权重之和，然后从左到右比较大小 注意四个数有低位高位的概念，但不会进位，如 0,0,0,8 + 0,0,0,7 = 0,0,0,15 二 基础选择器 选择器 说明 html 标签选择器 #id id 选择器 .class class 选择器 * 通配选择器 S₁, S₂, S₃, ... 并集 S₁S₂S₃... 交集 三 关系选择器 关系选择器 说明 A E E 为 A 的后代元素 A &gt; E E 为 A 的子元素 A ~ E E 为 A 的兄弟元素 A + E E 为 A 的下一个兄弟元素 三 属性选择器 属性选择器 说明 [attr] 带有 attr 属性的元素 [attr=value] attr 属性值为 value 的元素 [attr^=value] attr 属性值以 value 开头的元素 [attr$=value] attr 属性值以 value 结尾的元素 [attr*=value] attr 属性值包含 value 的元素 四 伪类选择器4.1 链接伪类 选择器 说明 :link 未访问 :visited 已访问 :hover 悬停 :active 点击 只能用于 &lt;a&gt; &lt;button&gt;，且按顺序 LVHA 其它标签也能用，但有兼容性问题 4.2 结构伪类 所有类型子元素从 1 开始编号（可以指定类型，如 E:nth-child(3)，但对应编号必须是此类型，否则取不到） 选择器 说明 :first-child 第一个子元素 :last-child 最后一个子元素 :noly-child 唯一子元素 :nth-child(表达式) 从前向后匹配符合表达式结果的子元素 :nth-last-child(表达式) 从后向前匹配符合表达式结果的子元素 所有指定类型子元素从 1 开始编号（若不指定类型则默认父元素类型） 选择器 说明 :fitst-of-type 第一个指定类型的子元素 :last-of-type 最后一个指定类型的子元素 :noly-of-type 唯一指定类型的子元素 :nth-of-type(表达式) 从前向后匹配符合表达式结果的指定类型的子元素 :nth-last-of-type(表达式) 从后向前匹配符合表达式结果的指定类型的子元素 表达式 说明 An+B A B 为整数，n 为 非负整数 odd 奇数 even 偶数 4.3 状态伪类 选择器 说明 :checked 选中的 radio checkbox option :default 默认选中的 radio checkbox option :disabled 禁用的元素 :enabled 启用的元素 :empty 没有子元素的元素 :focus 获取焦点的元素 :not() 非（权重由括号内决定，自身0，不支持复杂选择器） 五 伪元素选择器 伪元素选择器 说明 ::before 创建一个伪元素（行内元素），作为元素的第一个子元素 ::after 创建一个伪元素（行内元素），作为元素的最后一个子元素 ::first-letter 匹配块级元素第一行的第一个字母 ::first-line 匹配块级元素第一行 ::selection 匹配被用户选中或者处于高亮状态的部分 ::before, ::after 必须有 content 属性","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"CSS语法","slug":"UI/CSS语法","date":"2020-11-08T13:01:26.000Z","updated":"2020-11-08T13:06:17.439Z","comments":true,"path":"2020/11/08/UI/CSS语法/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/CSS%E8%AF%AD%E6%B3%95/","excerpt":"","text":"一 概述1.1 CSS Cascading Style Sheets 层叠样式表 负责页面的布局和样式 1.2 相关 名称 说明 CSS1 &amp; CSS2 单一规范 CSS3 内容增多，CSS 划分了多个模块 less css 一种简化的功能更多的 css 语言 sass 一种简化的功能更多的 css 语言 postcss 一种 css 处理程序 二 CSS 样式2.1 语法123456/* CSS 注释 */选择器 &#123; 属性 : 值; 属性 : 值1 值2 值3 ...; ...&#125; 2.2 Html 引入 CSS的方式 行内样式（内联样式）：每个 html 标签都有一个 style 属性，该属性的值就是 css 样式 内部样式（内嵌样式）：在当前页面的 &lt;style&gt; 标签中书写 css 样式 外部样式（外链样式）：在外部 .css 文件中书写 css 样式，之后导入当前页面 12345/* 方式 1 */&lt;link rel=\"stylesheet\" type=\"text/css\" href=\".css 文件路径\"&gt;/* 方式 2 */@import url(\".css 文件路径\") link 和 @import 方式的区别 link 属于 HTML 标签，而 @import 是 CSS 提供的，需要写在 &lt;style&gt; 中 @import 只在 IE 5 以上才能识别，而 link 是 HTML 标签，无兼容问题 页面被加载时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载 link 方式的样式的权重高于 @import 权重 @import 不支持js的动态修改 一般推荐link，@import 补充使用 三 CSS 文档语法中的符号说明 符号 说明 [] 表示组 &nbsp; 空格前后的各部分必须按顺序出现 &amp;&amp; 各部分必须出现，但可以不按顺序 &#124;&#124; 各部分至少出现一个，可以不按顺序 &#124; 各部分只能出现一个 &lt;&gt; 值类型 * 任意次数 ? 零次或一次 + 一次或多次 # 一次或多次，多次出现必须以逗号分隔 {m,n} 至少m次，至多n次 ! 组后面的叹号表示该组是必需的，并且至少产生一个值；即使组内项目的语法允许省略全部的值，也至少要保留一个值 四 CSS 属性值单位4.1 &lt;length&gt; 单位 说明 px 像素 rem 相对于根元素的字体大小 &lt;html&gt; em 相对于父元素的字体大小 ex 相对于小写字母 x 的高度即 x-height ch 相对于字符数字 0 的宽度 vw 相对于视窗的宽度：视窗宽度是100 vw vh 相对于视窗的高度：视窗高度是100 vh vmin 等于 vh 和 vw 中较小的值 vmax 等于 vh 和 vw 中较大的值 4.2 &lt;angle&gt; 单位 说明 deg 角度，一个完整圆角度是 360deg rad 弧度，一个完整圆弧度是 2π turn 圈数，一个完整圆圈数是 1turn 4.3 &lt;time&gt; 单位 说明 s 秒 ms 毫秒 4.4 &lt;frequency&gt; （频率） 单位 说明 Hz 赫兹 kHz 千赫兹 4.5 &lt;resolution&gt; （分辨率） 单位 说明 dpi 表示每英寸点数 dpcm 表示每厘米点数 dppx 表示每像素点数 x dppx 的别名 五 CSS 属性值类型5.1 文本类型 类型 取值 &lt;string&gt; &#39;&#39;, &quot;&quot; &lt;url&gt; url(绝对/相对地址，地址不建议加引号) 5.2 数值类型 类型 取值 &lt;integer&gt; 整数，可以有正负 + - &lt;number&gt; 整数或小数，可以有正负 + - &lt;percentage&gt; % &lt;dimension&gt; 尺寸，由数字和单位构成，即 &lt;number&gt; + unit = &lt;dimension&gt; 5.3 &lt;color&gt; 取值 说明 颜色关键字 black red green blue white yelow ... transparent 透明，可以近似认为是 rgba(0,0,0,0)的缩写 currentColor 当前元素的字体颜色，即 color 的值 #十六进制 #000 #FFF #1234AB ... RGB rgb(r, g, b)，可以使用数值和百分比 RGBA rgba(r, g, b, a)，a：alpha，透明度（0~1） HSL hsl(h, s, l)，色调（0360），饱和度（0%100%），亮度（0%~100%） HSLA hsla(h, s, l, a) 5.4 &lt;color-stop&gt;12/* 使用长度或百分比指定颜色起止位置，如果省略，默认 50% */&lt;color&gt; [ &lt;length&gt; | &lt;percentage&gt; ]? 5.5 &lt;image&gt; 值 说明 &lt;url&gt; url(绝对/相对地址，地址不建议加引号) &lt;gradient&gt; 使用渐变 element() 可以把页面元素当作背景图片 5.6 &lt;position&gt; x轴 y轴，如果只设置一个值，则另一个默认居中 值 说明 位置关键字 left right top bottom center &lt;length&gt; 指定长度 &lt;percentage&gt; 指定百分比 5.7 &lt;gradient&gt; 值 说明 linear-gradient() 线性渐变，颜色值沿着一条隐式的直线逐渐过渡 radial-gradient() 径向渐变，颜色值由一个中心点（原点）向外扩散并逐渐过渡到其他颜色值 repeating-linear-gradient() 重复线性渐变，重复多次渐变图案直到足够填满指定元素 repeating-radial-gradient() 重复径向渐变 conic-gradient() 锥形渐变，颜色值围绕圆逐渐过渡 1 线性渐变12[&lt;angle&gt; | [to [ left | right ] || [ top | bottom ]] ,]?&lt;color-stop&gt; [, &lt;color-stop&gt;]+ 1 第一行用于指定渐变方向1 角度 例 说明 0deg 向上，即 to top 45deg 右上，即 to right top 90deg 向右，即 to right 180deg 向下，即 to bottom 2 方向关键字 例 说明 to left 向左 to left top 左上 to left bottom 左下 to right 向右 to right top 右上 to right bottom 右下 to top 向上 to bottom 向下 2 第二行指定颜色以及颜色起止位置 例 说明 &lt;color&gt;, &lt;color&gt;, ... 至少有两个颜色，不指定位置则颜色平均分配 &lt;color&gt; &lt;length&gt;, &lt;color&gt; &lt;percentage&gt;, ... 可以使用长度或百分比指定颜色所占的范围 2 径向渐变12[[ &lt;ending-shape&gt; || &lt;size&gt; ]? [ at &lt;position&gt; ]? ,]? &lt;color-stop&gt; [, &lt;color-stop&gt;]+ 1 第一行指定渐变形状大小和位置1 形状 ending-shape 形状 说明 ellipse（默认） 椭圆 circle 圆形 2 大小 size 大小 说明 closest-side 近边 farthest-side 远边 closest-corner 近角 farthest-corner 远角 六 CSS 属性书写顺序 顺序 说明 1 布局定位属性 display position float clear visibility overflow 2 自身属性 width height margin padding border background 3 文本属性 color font text-decoration text-align vertical-align white-space break-word 4 其它属性（CSS 3） content cursor border-raduis box-shadow text-shadow 渐变","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"Emmet","slug":"UI/Emmet","date":"2020-11-08T13:00:11.000Z","updated":"2020-11-08T13:06:51.594Z","comments":true,"path":"2020/11/08/UI/Emmet/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/Emmet/","excerpt":"","text":"一 概述 Emmet (前身为 Zen Coding) 是一个能大幅度提高前端开发效率的一个工具 语法默认以 tab 结束 二 语法2.1 Html1 元素 快速生成Html模板 12!html:5 使用元素名称生成html标签：元素名 12// div&lt;div&gt;&lt;/div&gt; 数量：元素名*num 1234// li*3&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt; 自增符号：$ 123456789101112131415// div.$*3&lt;div class=&quot;1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;2&quot;&gt;&lt;/div&gt;&lt;div class=&quot;3&quot;&gt;&lt;/div&gt;// div.$$*3&lt;div class=&quot;01&quot;&gt;&lt;/div&gt;&lt;div class=&quot;02&quot;&gt;&lt;/div&gt;&lt;div class=&quot;03&quot;&gt;&lt;/div&gt;// 使用`@`来表示从第几开始// div.$@4*3&lt;div class=&quot;4&quot;&gt;&lt;/div&gt;&lt;div class=&quot;5&quot;&gt;&lt;/div&gt;&lt;div class=&quot;6&quot;&gt;&lt;/div&gt; 2 层级 父子：父元素&gt;子元素 12345678// div&gt;ul&gt;li&gt;a&lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;a&gt;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 兄弟：兄元素+弟元素 1234// div+span+p&lt;div&gt;&lt;/div&gt;&lt;span&gt;&lt;/span&gt;&lt;p&gt;&lt;/p&gt; 注意：会先算兄弟后算父子 12345// div&gt;p+a&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/div&gt; 优先级：() 12345678910// div&gt;(header&gt;ul&gt;li*2)+footer&lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/div&gt; 3 属性 创建带 id 的标签：元素名#id 12// div#test&lt;div id=&quot;test&quot;&gt;&lt;/div&gt; 创建带 class 的标签：元素名.class 12345// div.test&lt;div class=&quot;test&quot;&gt;&lt;/div&gt;// div.test1.test2.test3&lt;div class=&quot;test1 test2 test3&quot;&gt;&lt;/div&gt; 创建带属性的标签：元素名[属性名=&#39;属性值&#39;] 12// div[girl=&quot;beauty&quot;]&lt;div girl=&quot;beauty&quot;&gt;&lt;/div&gt; 创建带内容的标签：元素名{内容} 12// div&#123;haha&#125;&lt;div&gt;haha&lt;/div&gt; 隐式标签 12345678910// #test&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;// .test&lt;div class=&quot;test&quot;&gt;&lt;/div&gt;// ul&gt;.class &lt;ul&gt; &lt;li class=&quot;class&quot;&gt;&lt;/li&gt;&lt;/ul&gt; 2.2 CSS 常见的CSS样式可以使用省略写法 12// w20width: 20px;","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"HTML","slug":"UI/HTML","date":"2020-11-08T12:59:42.000Z","updated":"2020-11-08T13:07:02.955Z","comments":true,"path":"2020/11/08/UI/HTML/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/UI/HTML/","excerpt":"","text":"一 概述 HTML（Hyper Text Markup Language）：超文本标记语言 XHTML：可扩展超文本标记语言，是更严格更纯净的 HTML 版本 WEB 标准：W3C 组织及其它标准化组织制定的一系列标准的集合 结构：Html 表现：Css 行为：Javascript 二 标签2.1 文档声明12&lt;!-- 告诉浏览器使用哪个 Html 版本显示 --&gt;&lt;!DOCTYPE html&gt; 2.2 结构标签1234&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; 1 &lt;html&gt;1&lt;html lang=\"\"&gt; lang 属性 作用 搜索引擎无法判断页面中的内容是什么语言，需要我们告诉它 浏览器会将读取到的页面语言和本地语言进行比较判断，如果一致，不做处理，否则提示是否需要翻译（如果有此功能），有时候明明页面是中文由于设置的 lang=&quot;en&quot;，还会提示是否翻译，就是此原因 取值 英文 en 中文 zh-CN 用的最多其实已过时 zh-Hans 简体中文 zh-cmn-Hans 以简体中文书写的普通话用词 zh-yue-Hans 以简体中文书写的粤语用词 2 &lt;head&gt;1234567891011121314151617&lt;!-- 文档元数据定义在 head 标签中 --&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;!-- width：视口 viewport 宽度 initial-scale：初始缩放比 maximum-scale：最大缩放比 minimum-scale：最小缩放比 user-scalable：是否可以缩放 --&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximu-scale=1.0, minimum-scale=1.0, user-scalable=n0\"&gt; &lt;meta http-equiv=\"\" content=\"\"&gt; &lt;base href=\"此页面中所有相对 URL 的根 URL\" target=\"此页面新连接的打开方式 _self 或 _blank\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link&gt; &lt;style&gt;&lt;/head&gt; 2.4 &lt;body&gt; 中的标签1 语义化标签 标签 说明 &lt;header&gt; 头部标签 &lt;nav&gt; 导航栏标签 &lt;main&gt; 文档主体，只能有一个 &lt;artical&gt; 内容标签 &lt;section&gt; 区块标签 &lt;aside&gt; 侧边栏标签 &lt;footer&gt; 尾部标签 2 排版标签 标签 说明 &lt;!-- --&gt; 注释 &lt;br&gt; 换行 &lt;hr&gt; 横线 &lt;h1&gt;~&lt;h6&gt; 标题标签 &lt;div&gt; 块标签 &lt;span&gt; 行内标签 &lt;p&gt; 段落标签 3 文本格式化标签 标签 说明 &lt;strong&gt; 强调，加粗显示 &lt;em&gt; 着重，斜体显示 &lt;del&gt; 删除线 &lt;ins&gt; 下划线 &lt;pre&gt; 原样显示文本内容包括空白、换行等 &lt;abbr&gt; 缩写 &lt;sub&gt; 下标 &lt;sup&gt; 上标 &lt;blockquote&gt; 块引用 &lt;q&gt; 行内引用文本 &lt;progress&gt; 进度条 3 图片标签1&lt;img src=\"图片地址\" alt=\"图片无法正常显示时的替换文字\" title=\"鼠标悬浮时的提示文字\" width=\"\" height=\"\" border=\"\"&gt; 4 超链接标签12&lt;!-- 超链接标签可以用在网页中的各种元素，如文本、图像、表格、音频、视频等等 --&gt;&lt;a href=\"\" target=\"\" title=\"链接提示文本\"&gt; 链接显示文本 &lt;/a&gt; href 说明 url 外部链接：如&lt;a href=&quot;www.baidu.com&quot;&gt;内部链接：如 &lt;a href=&quot;index.html&quot;&gt;下载链接：url 是一个文件（如 exe, zip…） #id 锚点，跳转到当前页面指定位置 # 跳转到当前页面 javascript:void(0); 不跳转 javascript:; 不跳转 target 说明 _selt（默认） 当前窗口打开 _blank 新窗口打开 _parent 父级窗口打开 _top 祖先窗口打开 5 表格标签123456789101112131415161718&lt;table cellspacing=\"单元格边框之间的距离\" cellpadding=\"单元格内容和边框的距离\" align=\"水平对齐方式\"&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;表头单元格，内容默认居中，加粗&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td colspan=\"列合并\" rowspan=\"行合并\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; 使用&lt;thead&gt;&lt;tbody&gt;&lt;tfoot&gt;的好处是规定位置，即使代码的顺序是乱的，显示也是正确的。 &lt;thead&gt;&lt;tfoot&gt;可以没有，&lt;tbody&gt;不写也存在，且可以有多个 6 列表标签123456789101112131415161718192021&lt;!-- 1 无序列表 unorder list --&gt;&lt;ul&gt; &lt;li&gt;ul中只能容纳li，li中可以容纳所有元素&lt;/li&gt; &lt;li&gt;&lt;/li&gt; ...&lt;/ul&gt;&lt;!-- 2 有序列表 order list --&gt;&lt;ol&gt; &lt;li type=\"1、A、a、I、i\" start=\"首项从第几个开始\"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; ...&lt;/ol&gt;&lt;!-- 3 定义列表 definition list --&gt;&lt;dl&gt; &lt;dt&gt;名词：孙悟空&lt;/dt&gt; &lt;dd&gt;解释1：美猴王&lt;/dd&gt; &lt;dd&gt;解释2：齐天大圣&lt;/dd&gt; &lt;dd&gt;解释3：斗战胜佛&lt;/dd&gt;&lt;/dl&gt; 7 表单标签12345678&lt;form action=\"\" method=\"\"&gt; &lt;input type=\"\" name=\"提交key\" value=\"\"&gt; &lt;select name=\"提交key\"&gt; &lt;option value=\"提交值\" selected=\"\"&gt;页面显示值&lt;/option&gt; &lt;/select&gt; &lt;textarea name=\"提交key\" cols=\"每行字符数\" rows=\"显示的行数\"&gt;&lt;/textarea&gt; &lt;button&gt;&lt;/button&gt;&lt;/form&gt; 1 概述 标签 说明 &lt;label&gt; 用于描述表单元素，点击时可以使表单元素获取焦点 &lt;button&gt; 按钮 &lt;input&gt; 表单交互式元素 &lt;select&gt; 下拉菜单 &lt;textarea&gt; 文本域 &lt;datalist&gt; 为表单输入框准备一些选项列表 2 &lt;form&gt; 属性 说明 action 提交 url 地址 method 提交方式，默认 get enctype post 提交时表单内容提交给服务器的 MIME 类型 name 表单名称，用于区分同一个页面中的多个表单 enctype 取值 说明 application/x-www-form-urlencoded（默认） 在发送前编码所有字符，空格转换为 + 加号 ，特殊字符转换为 ASCII HEX 值 multipart/form-data 不对字符编码，用于文件上传 text/plain 空格转换为 + 加号，但不对特殊字符编码 3 &lt;label&gt;12345678&lt;!-- 1 直接包裹要描述的表单元素 --&gt;&lt;label&gt; 描述 &lt;input&gt;&lt;/label&gt;&lt;!-- 2 使用 for-id --&gt;&lt;label for=\"test\"&gt;描述&lt;/label&gt;&lt;input id=\"test\"&gt; 4 &lt;input&gt;1 属性 属性 适用于 说明 type All 表单类型，默认为 text name All 提交的键名 value All 默认值 disabled All 表单控件是否被禁用 checked radio checkbox 单/复选框是否选中 selecked option 下拉框是否选中 placeholder text password ... 提示文本内容，得到焦点不会消失，一输入值就消失 multiple file email select 是否允许多选 required almost All 必须输入 readonly almost All 只读，不能修改值，可提交到后台 minlength text password ... value 的最小长度（最小字符数目） maxlength text password ... value 的最大长度（最大字符数目） autocomplete All 表单的自动填充功能，off / on 2 type 属性 type 说明 text（默认） 文本框 password 密码框 radio 单选框，name 相同的是一个组，value 为提交值 checkbox 复选框，name 相同的是一个组，value 为提交值 file 上传文件，multiple=&quot;multiple&quot; 支持多选 button 没有默认行为的按钮，value 显示值 image 图片提交按钮 hidden 隐藏域 submit 提交按钮，不指定服务端会提交到当前页面 reset 复位按钮 number 数字框 tel 用于输入电话号码的控件 search 搜索框 email 邮件框 url URL 框 color 颜色选择框 datetime-local 输入日期和时间的控件 date 日期 time 时间 month 月 week 周 3 表单提交方式12345678&lt;!-- 1 如果设置了name，按钮数据也会提交到后台，如果有多个表单项可以判断是哪个表单提交的 --&gt;&lt;input type=\"submit\" name=\"\" value=\"点我提交\"&gt;&lt;!-- 2 html5 推荐使用&lt;button&gt; 而不是表单的 &lt;input type=button&gt; --&gt;&lt;button type=\"submit\"&gt;点我提交&lt;/button&gt;&lt;!-- 3 图片也能提交 --&gt;&lt;input type=\"image\"&gt; 5 &lt;select&gt;123456789&lt;select name=\"\" multiple&gt; &lt;option value=\"提交值\"&gt;显示值&lt;/option&gt; // optfroup 仅仅是将 option 分了一下组 &lt;optgroup label=\"体育\"&gt; &lt;option value=\"lanqiu\"&gt;篮球&lt;/option&gt; &lt;option value=\"zuqiu\"&gt;足球&lt;/option&gt; &lt;option value=\"wangqiu\" selected&gt;网球&lt;/option&gt; &lt;/optgroup&gt;&lt;/select&gt; 5 &lt;button&gt;1&lt;button type=\"\"&gt;&lt;/button&gt; type 说明 submit（默认） 提交按钮 reset 重置按钮 button 纯按钮，没有默认行为 6 &lt;textarea&gt;1&lt;textarea cols=\"每行中的字符数\" rows=\"显示的行数\"&gt;&lt;/textarea&gt; 7 &lt;datalist&gt;1234567&lt;!-- 表示从已有数据中选择数据，而不是自定义输入 --&gt;&lt;input type=\"text\" list=\"dataID\"&gt;&lt;datalist id=\"dataID\"&gt; &lt;option value=\"\"&gt;&lt;/option&gt; &lt;option value=\"\"&gt;&lt;/option&gt; &lt;option value=\"\"&gt;&lt;/option&gt;&lt;/datalist&gt; 8 多媒体标签1 &lt;audio&gt; 属性 值 说明 src url 音频源 autoplay autoplay 自动播放，默认 false controls controls 显示控件 loop loop 循环播放 muted muted 静音，默认 false preload metadata 预加载 volume 0.0~1.0 音量 2 &lt;video&gt; 属性 值 说明 src url 视频源 autoplay autoplay 自动播放，默认 false，需要静音才生效 controls controls 显示控件 loop loop 循环播放 muted muted 静音，默认 false poster url 视频封面图 preload metadata 预加载 width px 视频宽度 height px 视频高度 三 特殊字符 字符 名称 字符代码 码点 &nbsp; 空格 &amp;nbsp; &amp;#160; &gt; 大于号 &amp;gt; &amp;#62; &lt; 小于号 &amp;lt; &amp;#60; &amp; 与 &amp;amp; &amp;#38; “ 双引号 &amp;quot; &amp;#34; ‘ 单引号 &nbsp; &amp;#39; &#96; 反引号 &nbsp; &amp;#96; &#124; 竖线 &nbsp; &amp;#124 © 版权 &amp;copy; &amp;#169; ® 注册 &amp;reg; &amp;#174; ™ 商标 &amp;trade; &amp;#8482; ℃ 摄氏度 &amp;deg; &nbsp; ± 正负 &amp;plusmn; &nbsp; × 乘号 &amp;times; &amp;#215; ÷ 除号 &amp;divide; &amp;#247; 四 前端字符的表示方式 Html 中使用 &amp;#码点; 码点 指字符在编码表中对应的编码值 Unicode 采用十六制书写并加上前缀 \\u CSS 伪元素的 content 属性，直接使用 \\u码点 JavaScript 文件中为防止乱码转义，使用 \\u码点 unicode-range 是 U+码点","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"UI","slug":"CS/UI","permalink":"https://anyeansan.github.io/categories/CS/UI/"}],"tags":[]},{"title":"SSM","slug":"框架/SSM","date":"2020-11-08T12:58:13.000Z","updated":"2020-11-08T12:58:28.322Z","comments":true,"path":"2020/11/08/框架/SSM/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/%E6%A1%86%E6%9E%B6/SSM/","excerpt":"","text":"一 包 Spring + SpringMVC 12345678910111201 spring-core02 spring-beans03 spring-context04 spring-expression05 spring-jcl（commons-logging）06 spring-aop07 spring-aspects08 aspectjweaver09 spring-web10 spring-webmvc11 spring-tx12 spring-jdbc mybatis 1201 mybatis02 mybatis-spring SQL 1201 连接池：c3p0 dbcp druid ...02 数据库驱动 日志 1log4j2 slf4j ... JSON 1JackSon GSON FastSon ... 二 Spring + Springmvc2.1 概述 SpringMVC 扫描控制层 Spring 扫描所有并排除控制层，避免创建两次 Bean Spring 的 IOC 容器包含 SpringMVC 的 IOC 容器，即 Spring 的容器是父级 SpringMVC 的 IOC 容器可以获取 Spring IOC 容器中的 Bean Spring 的 IOC 容器不能获取 SpringMVC IOC 容器中的 Bean 2.2 配置1 web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!--1 配置 ContextLoaderListener--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--2 配置 DispatcherServlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!--3 配置编码过滤器 CharacterEncodingFilter--&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;!--4 配置 RestFul 请求处理过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 2 springMVC.xml1234567891011&lt;!-- 1 扫描控制层--&gt;&lt;context:component-scan base-package=&quot;cn.an.controller&quot;/&gt;&lt;!-- 2 注解驱动--&gt;&lt;mvc:annotation-driven/&gt;&lt;!-- 3 静态资源--&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!-- 4 视图解析器--&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt; 3 applicationContext.xml1234&lt;!-- 扫描控制层之外的注解--&gt;&lt;context:component-scan base-package=&quot;cn.an&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; 三 Spring + Mybatis3.1 概述 Mybatis 只配置自己特有的东西 主配置： setting ... 映射配置 交给 Spring 管理： 数据源和事务 SqlSession 对象的创建和管理 mybatis-spring 中的 SqlSessionFactoryBean Mapper 接口代理实现类对象的创建和管理 mybatis-spring 中的 MapperScannerConfigurer 3.2 配置1 mybatis-config.xml12345678910&lt;configuration&gt; &lt;settings&gt; &lt;!--开启懒加载 --&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!--开启时，任一方法的调用都会加载该对象的所有延迟加载属性 --&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;true&quot;/&gt; &lt;!--开启数据库下划线和Java属性驼峰命名的映射--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt;&lt;/configuration&gt; 2 applicationContext.xml1 数据源和事务1234567891011121314151617181920&lt;!-- 1 引入资源文件--&gt;&lt;context:property-placeholder location=&quot;classpath:druid.properties&quot;/&gt;&lt;!-- 2 配置数据源--&gt;&lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;druid.driverClassName&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;druid.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;druid.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;druid.password&#125;&quot;/&gt; &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;druid.initialSize&#125;&quot;/&gt; &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;druid.maxActive&#125;&quot;/&gt; &lt;property name=&quot;minIdle&quot; value=&quot;$&#123;druid.minIdle&#125;&quot;/&gt; &lt;property name=&quot;maxWait&quot; value=&quot;$&#123;druid.maxWait&#125;&quot;/&gt;&lt;/bean&gt;&lt;!-- 3 事务--&gt;&lt;!-- 3.1 事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt;&lt;/bean&gt;&lt;!--3.2 开启事务注解驱动--&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 2 管理 SqlSession12345678910&lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--1 数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt; &lt;!--2 mybatis 主配置文件位置--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;!--3 mybatis 映射配置文件位置--&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:cn/an/mapper/*.xml&quot;/&gt; &lt;!--4 为包及其子包配置别名--&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;&quot;/&gt;&lt;/bean&gt; 3 管理 Mapper 接口代理实现类1 单个配置123456&lt;bean class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt; // 指定 Mapper 接口 &lt;property name=&quot;mapperInterface&quot; value=&quot;&quot;/&gt; // 注入 SqlSessionFactory &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;&quot;/&gt;&lt;/bean&gt; 2 批量配置123456&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; // 为包下所有 Mapper 接口生成代理实现类，并由 Spring 容器管理 &lt;property name=&quot;basePackage&quot; value=&quot;cn.an.mapper&quot;/&gt; // 注入 SqlSessionFactory &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;&quot;/&gt;&lt;/bean&gt; 代理实现类默认 BeanID 为接口名首字母小写 SqlSessionFactory 全局只有一个，所以可以省略","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Frame","slug":"CS/Frame","permalink":"https://anyeansan.github.io/categories/CS/Frame/"}],"tags":[]},{"title":"SpringMVC","slug":"框架/SpringMVC","date":"2020-11-08T12:56:26.000Z","updated":"2020-11-08T12:57:16.084Z","comments":true,"path":"2020/11/08/框架/SpringMVC/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/%E6%A1%86%E6%9E%B6/SpringMVC/","excerpt":"","text":"一 概述 轻量级的控制层 MVC 框架 与 Spring 无缝结合，功能强大：RESTful，数据验证，格式化，本地化，主题… 二 执行流程 客户端发送请求，DispatcherServlet 捕获请求 DispatcherServlet 根据请求从映射器获取 Handler 以及 Handler 对应的拦截器，以 HandlerExcutionChain 的形式返回 映射器中存储了控制器及其能够处理的请求信息 如果映射不存在，如静态资源，会判断是否配置了 mvc:default-servlet-handler DispatcherServlet 根据 Handler 选择适配器执行它，并返回 ModelAndView 正向执行拦截器链的 preHandler() 执行 Handler 逆向执行拦截器链的 postHandler() 使用视图解析器解析 ModelAndView 渲染视图 逆向执行拦截器链的 AfterCompletion() 响应 三 前端控制器 DispatcherServlet3.1 配置12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 默认加载的配置文件为 WEB-INF/&lt;servlet-name&gt;-servlet.xml &lt;url-pattern&gt; /（建议） 拦截所有，不包含.jsp /*（不建议） 拦截所有 3.2 组件1 概述 一启动就会初始化所有组件，去容器中寻找，如果没有配置则使用默认 默认加载的组件在 DispatcherServlet.properties中 2 分类 组件 说明 List&lt;HandlerMapping&gt; 处理器映射器 List&lt;HandlerAdapter&gt; 处理器适配器 List&lt;ViewResolver&gt; 视图解析器 MultipartResolver 文件上传解析器 List&lt;HandlerExceptionResolver&gt; 异常解析器 LocaleResolver 区域信息解析器，国际化相关 FlashMapManager 重定向携带数据的功能 ThemeResolver 主题解析器 RequestToViewNameTranslator 请求到视图名转换器 3 处理器映射器 HandlerMapping 映射器 说明 BeanNameUrlHandlerMapping 请求 URL 与处理器 BeanID 进行匹配，BeanID 必须以 / 开头 SimpleUrlHandlerMaping 请求 URL 与配置的 key 进行匹配获取 value 即为处理器 BeanID RequestMappingHandlerMapping 注解映射器 4 处理器适配器 HandlerAdapter 适配器 说明 HttpRequestHandlerAdapter Controller 必须实现 HttpRequesHandler接口 SimpleControllerHandlerAdapter Controller 必须实现 Controller 接口 RequestMappingHandlerAdapter 注解适配器 5 视图解析器 ViewResolver1 概述 无论处理器返回值是什么，最终都会变成 ModelAndView 被视图解析器解析 SpringMVC 借助视图解析器得到视图对象 View，最终的视图可以是 Jsp Excel JFreeChart ... 所有视图解析器都必须实现 ViewResolve 接口，常用视图解析器 InternalResourceViewResolver BeanNameViewResolver 视图对象才能真正的转发（会将模型数据全部取出存到请求域中）或重定向 视图对象才能真正的渲染视图，将模型中的数据以某种形式呈现给用户 2 InternalResourceViewResolver 配置1234&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt; 物理视图 = 前缀(prefix) + 逻辑视图 + 后缀(suffix) 3 &lt;mvc:view-controller&gt;1&lt;mvc:view-controller path=&quot;请求路径&quot; view-name=&quot;响应的页面&quot;/&gt; 无需经过控制器来执行结果，直接响应 SpringMVC 渲染的页面 6 控制器 Controller &amp; 处理器 Handler Controller：指控制器类 Handler：控制器类中的方法 五 配置5.1 静态资源处理1 概述 所有项目的 web.xml 都继承了 Tomcat 的 web.xml，所以相同配置会覆盖 Tomcat 的 web.xml 中 DefaultServlet：url-pattern = / JspServlet：url-pattern = *.jsp DispatcheServlet 的 url-pattern = /*，表示所有请求都由 SpringMVC 处理 静态资源请求：没有对应的处理器，会报错 .jsp 请求：没有对应的处理器，会报错 DispatcheServlet 的 url-pattern = /，表示除了 .jsp 外的请求由 SpringMVC 处理 静态资源请求：没有对应的处理器，会报错 .jsp 请求：由 Tomcat 的 JspServlet 处理，没有问题 2 解决1 在 SpringMVC 核心配置文件中配置1&lt;mvc:default-servlet-handler default-servlet-name=&quot;&quot;/&gt; 将在 SpringMVC上下文中定义一个 DefaultServletHttpRequestHandler，它会对进入 DispatcheServlet 的请求进行筛选 如果不是静态资源的请求，由 DispatcheServlet 处理 如果是静态资源的请求，即没有匹配映射的请求，则交给 WEB应用服务器默认的 Servlet 处理 default-servlet-name 一般 WEB应用服务器（如 Tomcat）默认的 Servlet 名称都是 default，此属性可以省略，否则需要手动配置 2 在 SpringMVC 核心配置文件中配置12&lt;!--配置静态资源访问 **表示的包含自身包和子包的所有文件--&gt;&lt;mvc:resources mapping=&quot;/statics/**&quot; location=&quot;/statics/&quot; &gt;&lt;/mvc:resources&gt; 5.2 &lt;mvc:annotation-driven/&gt; 注册 RequestMappingHandlerMapping 注册RequestMappingHandlerAdapter 注册ExceptionHandlerExceptionResolver 支持 ConversionService @NumberFormat annotation 、@DateTimeFormat完成数据类型格式化 @Valid 对 JavaBean 进行 JSR303 校验 @RequestBody 和 @ResponseBody 六 原生 Servlet 想获取谁直接在方法上添加相应的形参即可获取 默认支持： HttpServletRequest HttpServletResponse HttpSession java.security.Principal Locale InputStream OutputStream Reader Writer 七 请求7.1 概述 注解 说明 @RequestMapping 请求映射，即确定处理指定请求的方法 @PathVariable 请求路径占位符映射 @RequestParam 请求参数映射 @RequestHeader 获取请求头中的值 @RequestBody 获取请求体中的值 @CookieValue 获取 Cookie中的值 @RequestAttribute 获取 request 域中的值 @SessionAttribute 获取 session 域中的值 7.2 请求映射1 @RequestMapping1 说明 定义在类上：第一级的访问路径 定义在方法上：第二级的访问路径 2 属性 属性 说明 String[] value() default {} 同 path() String[] path() default {} 指定请求路径 RequestMethod[] method() default {} 指定请求方法，值为枚举类 RequestMethod 的值 GET POST... String[] params() default {} 指定必须匹配的请求参数，支持简单表达式 String[] headers() default {} 指定必须包含的请求头 2 其它映射注解12345// 请求方法确定可以直接使用以下注解代替 @RequestMapping@GetMapping@PostMapping@PutMapping@DeleteMapping 7.3 请求路径占位符1 @PathVariable1 说明 定义在形参上：映射请求 URL 中的占位符，即指定形参与占位符进行匹配的名称 占位符：/usr/{id} 2 属性 属性 说明 String value() default &quot;&quot; 同 name() String name() default &quot;&quot; 指定占位符映射名称 boolean required() default true 请求是否必须包含指定占位符 2 RESTFul 风格1 请求格式1234增: /user POST删: /user/1 DELETE改: /user/1 PUT查: /user/1 GET 2 发送 put delete 请求 使用 Spring 提供的过滤器 HiddenHttpMethodFilter 创建一个 POST 请求的表单 表单项包含一个 name=&quot;_method&quot; value=&quot;put delete...中的一个&quot; 可以自动将 Post 请求转换成 _method 指定的请求 7.4 请求参数1 @RequestParam1 说明 定义在形参上：将指定名称的请求参数的值赋给形参 2 属性 属性 说明 String value() default &quot;&quot; 同 name() String name() default &quot;&quot; 指定请求参数名称 boolean required() default true 请求参数中是否必须包含此参数 String defaultValue() default ValueConstants.DEFAULT_NONE 指定默认值来取代 null 2 请求参数绑定1 绑定机制 表单提交数据都是 k=v 格式 SpringMVC 请求参数绑定：指控制器中方法的形参与请求参数绑定，即用形参获取请求参数 2 获取请求参数的方式1 直接获取 方法形参名称与请求参数名称（表单 name）一致 如果不一致，使用 @RequestParam 指定 2 封装对象 如果请求参数过多，可以用 JavaBean 接收，会自动封装 方法形参名称任意，类型为 JavaBean 类型，JavaBean 中的属性名称与请求参数名称（表单 name）一致 7.5 请求头：@RequestHeader 属性 说明 String value() default &quot;&quot; 同 name() String name() default &quot;&quot; 指定请求头的键 boolean required() default true 请求头是否必须包含指定键 定义在形参上：将请求头中指定键的值赋给形参 7.7 Cookie：@CookieValue 属性 说明 String value() default &quot;&quot; 同 name() String name() default &quot;&quot; 指定 Cookie 中的键 boolean required() default true Cookie 是否必须包含指定键 定义在形参上：将 Cookie 中指定键的值赋给形参 7.8 域1 request 域：@RequestAttribute 属性 说明 String value() default &quot;&quot; 同 name() String name() default &quot;&quot; 指定 request 域的键 boolean required() default true request 域是否必须包含指定键 定义在形参上：将 request 域中指定键的值赋给形参 2 session 域：@SessionAttribute 属性 说明 String value() default &quot;&quot; 同 name() String name() default &quot;&quot; 指定 session域的键 boolean required() default true session域是否必须包含指定键 定义在形参上：将 session 域中指定键的值赋给形参 7.9 POST 请求乱码 在web.xml中配置 Spring 提供的过滤器 CharacterEncodingFilter 123456789101112&lt;filter&gt; &lt;filter-name&gt;characterFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 八 响应8.1 响应数据1 Map Model ModelMap 形参声明对应类型，之后添加数据即可 12Model addAttribute(String attributeName, Object attributeValue)Model addAllAttributes(Map&lt;String, ?&gt; attributes) 这三种类型最终都是使用 BindingAwareModelMap 数据保存在 request 域中 2 ModelAndView 创建 ModelAndView，之后添加数据，设置视图，最后返回即可 数据保存在 request 域中 处理器无论返回值是什么，其实最终返回的都是 ModelAndView 添加数据 12ModelAndView addObject(String attributeName, Object attributeValue)ModelAndView addAllObjects(@Nullable Map&lt;String, ?&gt; modelMap) 设置视图 12void setViewName(String viewName)void setView(View view) 3 @SessionAttributes1 说明 定义在类上 根据配置（属性名称或类型）将存储在 BindingAwareModelMap （即使用 Map Model ModelMap）中的数据，存储一份到 session 域中 2 属性 属性 说明 String[] value() default {} 同 names() String[] names() default {} 指定被存入 session 域的 key 名称 Class&lt;?&gt;[] types() default {} 指定被存入 session 域的 value 类型 4 @ModelAttribute1 说明 定义在方法上：则当前方法会在 Controller 中每个方法执行前执行 定义在形参上：以指定 key 从 BindingAwareModelMap 获取数据 2 属性 属性 说明 String value() default &quot;&quot; 同 name() String name() default &quot;&quot; 指定 key 3 应用场景1 说明 更新操作时，使用实体类接收表单请求数据，而有些字段并不想修改，所以表单提交的数据可能不是全字段，那么封装的实体类中没有提交的字段就为空，如果此时执行更新操作，就会导致数据库丢失相应字段的原有数据 例如，更新用户的 name，表单提交数据只有 name 的值，使用实体类 name age 接收，则 age 为空，更新之后，就会导致数据库中用户丢失原有 age 值 解决方式 使用隐藏域（不安全，字段多麻烦） 在处理方法中，更新前手动设置（麻烦） 不使用新封装的实体类对象，而是从数据库中查询对应对象，需要更新的字段使用提交的更新数据，不需要更新的字段使用数据库中原有数据（店长推荐） 2 步骤 @ModelAttribute 定义在一个方法上，此方法会在目标方法执行前执行，所以可以在此方法中从数据库查询数据，并存入 BindingAwareModelMap 在目标方法中，使用 @ModelAttribute 修饰形参，则 SpringMVC 不会直接创建相应对象，而是从 BindingAwareModelMap 获取，则使用的就是从数据库中查询到的实体类对象 8.2 转发和重定向 处理器返回指定前缀的字符串 forward:转发路径：转发 redirect:重定向路径：重定向 SpringMVC 会自动为重定向路径添加应用名，所以不用加应用名 带有前缀时，不会走视图解析器 九 JSON9.1 HttpMessageConverter&lt;T&gt;1 概述 Spring3.0 新添加的接口 负责将请求信息转换为 T 类型，或将 T 类型输出为响应信息 DispatcherServlet 默认装配 RequestMappingHandlerAdapter，而 RequestMappingHandlerAdapter 默认装配了一些 HttpMessageConverter 的实现 如果导入了 JackSon 的包，RequestMappingHandlerAdapter 就会多装配一个 MappingJackson2HttpMessageConverter 2 实现类 实现类 说明 StringHttpMessageConverter 读写 String ByteArrayHttpMessageConverter 读写二进制数据 MappingJackson2HttpMessageConverter 利用 JackSon 的 ObjectMapper 读写 JSON 数据 9.2 @ResponseBody 定义在类上或方法上 添加了此注解，则方法不再响应视图，而是直接响应数据 如果想响应 JSON 数据，在方法内部转为 JSON 并返回即可 9.3 @RequestBody 属性 说明 boolean required() default true 是否必须有请求体 定义在形参上：用于获取请求体的内容（GET 不可用） 9.4 @RestController 定义在类上 相当于同时添加了 @Controller 和 @ResponseBody 9.5 JSON 处理 配置 &lt;mvc:annotation-driven/&gt;，为了支持 @RequestBody 和 @ResponseBody 在处理方法上添加 @ResponseBody 注解 导入所使用的工具包： JackSon SpringMVC 内部有 JackSon 转换器，添加了 JackSon 的依赖后，会自动将返回值转为 JSON GSON FastJson ... 在方法内部手动转为 JSON 并返回 注意： 当使用分步查询时，如果开启了延迟加载，关联属性没有值会导致转 json 异常 1select s.s_id,s.s_name,s.gender,s.hobby,s.birthday,s.t_id,t.t_id,t.t_name,t.gender sex from student s,teacher t where s.s_id=#&#123;id&#125; and s.t_id=t.t_id 十 数据绑定的处理10.1 概述 数据绑定的核心部件是 DataBinder ConversionService：数据类型转换和格式化 Validator：数据校验 10.2 类型转换1 概述 页面提交的数据都是字符串，而 JavaBean 中属性有各种各样的类型 SpringMVC 提供了许多转换器可以完成大多数的转换，如果有特殊需求可以自定义转换器 2 自定义转换器 Spring 定义了 3 中类型转换接口，实现任意一种 Converter&lt;S,T&gt; ConverterFactory GenericConverter 配置 ConversionService 1234567&lt;bean id=&quot;转换器工厂id&quot; class=&quot;org.springframework.format.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;bean class=&quot;自定义转换器全类名&quot;/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 让 SpringMVC 使用自定义 ConversionService 1&lt;mvc:annotation-driven conversion-service=“转换器工厂id”/&gt; 10.3 格式化1 FormattingConversionService 既具有 类 型 转换功能又具有格式化功能 2 FormattingConversionServiceFactroyBean &lt;mvc:annotation-driven/&gt; 默认创建的 ConversionService 实例即为此工厂 bean @DateTiemFormat @NumberFormat 10.4 校验1 JSR303 java 为 bean 数据合法校验提供的标准框架，包含在 javaee6.0 中 通过在字段上加注解 @Null @NotNull @Pattern(value) ... 2 Spring 的校验 Spring 有自己的校验框架，同时支持 jsr303 LocalValidatorFactoryBean 实现了 Spring 的 Validator接口，也实现了 jsr303 的 Validator 接口 &lt;mvc:annotation-driver/&gt; 默认会装配好一个此对象 十一 拦截器11.1 概述 过滤器是 JavaWeb 技术，而拦截器是 SpringMVC 独有的 过滤器可以过滤任意请求，而拦截器只拦截 Controller 中的目标方法 11.2 HandlerInterceptor1 API boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) 目标方法执行前调用，true：放行，false：不放行 void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) 目标方法执行后，渲染视图前调用 void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) 渲染视图后调用，即到达目标页面之后 ` 2 多个拦截器执行顺序 按照配置顺序 正序 preHandler 目标方法 逆序 postHandler 渲染视图后 逆序 afterCompletion 假如有三个拦截器 `1 2 3`` pre1 pre2 pre3 handler post3 post2 post1 after3 after2 after1 11.3 自定义拦截器 实现HandlerInterceptor 或 继承HandlerInterceptorAdapter 在 SpringMVC 配置文件中注册拦截器 拦截所有方法 123456&lt;mvc:interceptors&gt; // 1 注册拦截器 &lt;bean class=&quot;自定义拦截器全类名&quot;/&gt; // 2 注册拦截器 &lt;ref bean=&quot;bean的id&quot;/&gt;&lt;/mvc:interceptors&gt; 自定义拦截规则 1234567891011&lt;mvc:interceptors&gt; // 一个拦截器对应一个 &lt;mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!-- 哪些方法进行拦截 --&gt; &lt;mvc:mapping path=&quot;/user/*&quot;/&gt; &lt;!-- 哪些方法不进行拦截 --&gt; &lt;mvc:exclude-mapping path=&quot;&quot;/&gt; &lt;!-- 注册拦截器--&gt; &lt;bean class=&quot;自定义拦截器全类名&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 十二 异常处理12.1 异常解析器 SpringMVC 的 DispatcherServlet 组件中有异常解析器HandlerExceptionResolver dao，service，controller... 出现异常都往上抛，最后抛给DispatcherServlet DispatcherServlet 有异常解析器，则交给异常解析器，能处理则处理，不能处理则继续抛 无异常解析器，则什么都不做直接响应到页面 12.2 默认装配解析器 异常解析器 说明 ExceptionHandlerExcptionResolver 处理标有 @ExceptionHandler 注解的异常 ResponseStatusExceptionResolver 处理标有 @ResponseStatues 注解的异常 DefaultHandlerExceptionResolver 处理 SpringMVC 自己的异常 1 @ExceptionHandler1 说明 定义在方法上，对当前类有效 表示此方法用来处理此类发生的指定异常 用形参 Exception e 接收异常 携带异常信息只能使用 ModelAndView ，String Model Map... 不行 2 属性 属性 说明 Class&lt;? extends Throwable&gt;[] value() default {} 指定处理哪些异常 3 @ControllerAdvice 定义在类上，全局有效 表示此类是一个全局的异常处理类 在类中用 @ExceptionHandler 定义异常处理方法 2 @ResponseStatues 定义在方法上：方法发生异常时就会触发 定义在自定义异常类上：发生此自定义异常时就会触发 属性 value：状态码 reason：错误信息 12.3 手动装配解析器SimpleMappingExceptionResolver123456789&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; // 配置哪些异常去哪些页面 &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;异常全类名&quot;&gt;页面视图名&lt;/prop&gt; &lt;/property&gt; // 错误信息 &lt;property name=&quot;exceptionAttribute&quot; value=&quot;自定义request域的key&quot;/&gt;&lt;/bean&gt; 为每个异常指定特定页面，会自动将异常存入request域默认key为exception，也可以自定义 123456789&lt;bean class=&quot;SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;exceptionAttribute&quot; value=&quot;自定义request域的key&quot;/&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;java.lang.NullPointException&quot;&gt;error1&lt;/prop&gt; &lt;prop key=&quot;java.lang.IndexOutOfBoundsException&quot;&gt;error2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 处理步骤 使用自定义异常类 或 已有异常类 用于设置异常信息 异常处理器 使用内置异常处理器 内置异常处理器有相应注解来实现携带异常信息跳到特定页面等 自定义异常处理器 实现HandlerExceptionResoler 在自定义处理器中携带异常信息跳到特定页面 在springmvc.xml中配置异常处理器bean 文件上传 &amp; 下载上传 其实也是一种参数绑定(安) 使用的是MultipartResolver接口，实现使用的是commons-fileupload 实现 form表单post请求，enctype=multipart/form-data 配置MultipartResolver接口实现类CommonsMultipartResolver bean id 必须为multipartResolver 依赖commons-fileupload和commons-io 上传方法中形参MultipartFile file file为表单上传name属性名 使用MultipartFile可以获取文件名，输入流，保存文件等等 MultipartFile getOriginalFilename() getInputStream() void transferTo(File file) default void transferTo(Path path) 下载基于ResponseEntity实现 返回一个ResponseEntity Java通用下载实现 设置响应头告诉浏览器是下载文件 response.setHeader(&quot;content-disposition&quot;, &quot;attachment;filename=&quot;+fileName); 设置响应头说明是文件类型 response.setHeader(&quot;content-type&quot;, &quot;image/jpeg&quot;); 设置文件类型是图片 response.setContentType(this.getServletContext().getMimeType(fileName)) 设置类型为根据文件名获取的类型","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Frame","slug":"CS/Frame","permalink":"https://anyeansan.github.io/categories/CS/Frame/"}],"tags":[]},{"title":"Spring","slug":"框架/Spring","date":"2020-11-08T12:56:21.000Z","updated":"2020-11-08T12:57:25.382Z","comments":true,"path":"2020/11/08/框架/Spring/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/%E6%A1%86%E6%9E%B6/Spring/","excerpt":"","text":"一 概述 Spring 是一个轻量级的控制反转 IOD(DI) 和 面向切面编程 AOP 的开源框架 下载 https://repo.spring.io/webapp/#/home 1artifacts → libs-release-loacl → springframework → spring 二 Spring 优良特性 非侵入式 基于Spring开发的应用中的对象可以不依赖于 Spring 的 API 依赖注入 DI——Dependency Injection，反转控制（IOC）最经典的实现 面向切面编程 Aspect Oriented Programming——AOP 容器 Spring 是一个容器，因为它包含并且管理应用对象的生命周期 组件化 Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML 和 Java 注解组合这些对象 一站式 在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库（实际上 Spring 自身也提供了表述层的 SpringMVC 和持久层的 Spring JDBC） 三 Spring 模块 四 IOC4.1 概述 Inversion of Control 控制反转 控制：资源的获取方式 主动式：需要什么资源自己创建 被动式：资源不是自己创建的，而是由容器来创建和管理，需要什么资源由容器注入 控制反转：主动的创建资源变为被动的接受资源 4.2 DI Dependency Injection 依赖注入 IOC 是一种思想，DI 是 IOC 的一种实现 bean 之间的关系 依赖： has a 继承： is a 容器通过反射为组件（类）注入运行时所依赖的其它组件 4.3 IOC 容器1 BeanFactory1 概述 IOC 容器的基本实现，Spring 最底层的接口，负责 Bean 的创建 延迟加载，第一次获取对象 getBean() 时才实例化 Bean 2 API 方法 说明 Object getBean(String name) 根据名称获取 Bean 对象 T getBean(String name, Class&lt;T&gt; requiredType) 根据名称和类型获取 Bean 对象 2 ApplicationContext1 概述 BeanFactory 子接口，更多的负责容器功能的实现 立即加载，创建容器时就会实例化配置的所有 Bean 2 小弟 小弟 说明 ClassPathXmlApplicationContext 加载类路径下的 XML 配置创建容器 AnnotationConfigApplicationContext 加载注解配置创建容器 FileSystemXmlApplicaitonContext 加载磁盘路径下的 XML 配置创建容器 WebApplicationContext WEB 容器 五 XML 配置5.1 配置1 import1&lt;import resource=&quot;导入其它配置文件&quot;/&gt; 2 bean1&lt;bean id=&quot;&quot; name=&quot;&quot; class=&quot;&quot; scope=&quot;&quot; autowire=&quot;&quot; parent=&quot;&quot; abstract=&quot;&quot; depends-on=&quot;&quot; init-method=&quot;&quot; destroy-method=&quot;&quot;&gt; 属性 说明 id 唯一标识 name 别名，可以有多个用逗号隔开 class 全限定类名 scope 作用域 autowire 自动导入 parent 指定当前 Bean 的配置信息继承于哪个 Bean，注意：只是配置信息的继承 abstract 表示当前 Bean 是抽象的，不能创建实例，用来被其它 Bean 继承 depends-on 表示当前 Bean 依赖于哪些 Bean，多个用逗号隔开，只是改变实例化顺序（默认按配置顺序实例化） init-method 自定义初始化方法 destroy-method 自定义销毁方法 3 引入资源文件123456// 1&lt;context:property-placeholder location=&quot;&quot;/&gt;// 2&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value=&quot;&quot;/&gt;&lt;/bean&gt; 5.2 Bean 实例化1 构造方法1 无参构造1&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt; 2 有参构造12345&lt;bean id=&quot;&quot; class=&quot;&quot;&gt; &lt;constructor-arg name=&quot;构造参数名&quot; value=&quot;&quot;/&gt; &lt;constructor-arg index=&quot;构造参数索引，从0开始&quot; value=&quot;&quot;/&gt; &lt;constructor-arg type=&quot;构造参数类型&quot; value=&quot;&quot;/&gt;&lt;/bean&gt; 2 静态工厂1234&lt;bean id=&quot;&quot; class=&quot;静态工厂全类名&quot; factory-method=&quot;静态工厂中获取 bean的静态方法&quot;&gt; // 方法传参 &lt;property&gt;&lt;/bean&gt; 3 实例工厂123456// 必须先有工厂实例对象，通过工厂实例对象创建对象&lt;bean id=&quot;&quot; class=&quot;工厂全限定类名&quot;&gt;&lt;bean id=&quot;&quot; factory-bean=&quot;工厂beanID&quot; factory-method=&quot;工厂中获取 bean 的方法&quot;&gt; // 方法传参 &lt;property&gt;&lt;/bean&gt; 4 FactoryBean1 API 方法 说明 T getObject() Spring 自动调用，返回创建对象 Class&lt;?&gt; getObjectType() Spring 自动调用，获取创建对象的类型 boolean isSingleton() Spring 自动调用，确定是否是单例 2 说明 对于实现了 FactoryBean 接口的类，Spring 会把它当成一个工厂 factory bean 配置工厂 Bean 不会返回此工厂本身，而是返回其 getObject() 方法返回的Bean 对象 5.3 Bean 作用域1&lt;bean id=&quot;&quot; class=&quot;&quot; scope=&quot;&quot;&gt; scope 说明 创建时机 singleton（默认） 并非 bean 本身是单例的，而是指 bean 在 IOC 容器中是单例的 IOC 容器创建时就会创建 bean prototype 多例 每次获取时创建一个新的 bean request 请求范围，仅适用于 WebApplicationContext 环境 每次 HTTP 请求共享一个bean session 会话范围，仅适用于 WebApplicationContext 环境 每个 session 共享一个 bean application 应用范围，仅适用于 WebApplicationContext 环境 每个 application 共享一个 bean 5.4 依赖注入方式1 手动装配1 构造器注入（有参构造）2 set 注入1234&lt;bean id=&quot;&quot; class=&quot;&quot;&gt; &lt;property name=&quot;&quot; value=&quot;基本类型&quot;/&gt; &lt;property name=&quot;&quot; ref=&quot;引用类型&quot;/&gt;&lt;/bean&gt; 3 c 命名空间1&lt;bean id=&quot;&quot; class=&quot;&quot; c:name=value c:name-ref=value&gt; 用 c 替换构造注入中的 &lt;constructor-arg&gt;，直接注入构造参数 4 P 命名空间1&lt;bean id=&quot;&quot; class=&quot;&quot; p:name=value p:name-ref=value&gt; 用 p 替换 set 注入中的 &lt;property&gt; 标签，直接注入属性值 &lt;property name=&quot;key&quot; value=&quot;value&quot;/&gt; → p:key=&quot;value&quot; &lt;property name=&quot;key&quot; ref=&quot;value&quot;&gt; → p:key-ref=&quot;value&quot; 5 SpEL123&lt;bean id=&quot;&quot; class=&quot;&quot;&gt; &lt;property name=&quot;&quot; value=&quot;#&#123;spEL表达式&#125;&quot;&gt;&lt;/bean&gt; 语法 说明 #{123} 数字 #{&#39;abc&#39;} 字符串 #{beanId} bean #{beanId.propName} bean 的属性 #{beanId.method()} 执行 bean 的方法 #{xx?.method()} 如果 xx 不为空则调用方法，否则不调用 #{Type.field/method()} 静态属性/方法 2 自动装配 autowire1&lt;bean id=&quot;&quot; name=&quot;&quot; class=&quot;&quot; autowire=&quot;&quot;&gt; autowire 说明 default/no 默认，不自动装配 byName 查找与 set 方法后边的值（第一个字母小写） 相同的 beanID byType 查找与属性类型相同的 bean ，如果此类型有多个会报错 constructor 按照构造器注入 5.5 依赖注入类型1 null12345&lt;bean&gt; &lt;property name=&quot;&quot;&gt; &lt;null/&gt; &lt;/property&gt;&lt;/bean&gt; 2 基本类型及其包装类，String123&lt;bean&gt; &lt;property name=&quot;&quot; value=&quot;&quot;/&gt;&lt;/bean&gt; 3 Java Bean12345678910// 1 外部 bean&lt;bean&gt; &lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;&lt;/bean&gt;// 2 内部 bean&lt;bean&gt; &lt;property name=&quot;&quot;&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 4 数组/集合1 数组123456789101112&lt;bean&gt; &lt;property name=&quot;&quot;&gt; &lt;array&gt; // 1 简单类型值 &lt;value&gt;&lt;/value&gt; // 2 外部 bean &lt;ref bean=&quot;&quot;/&gt; // 3 内部 bean &lt;bean&gt;&lt;/bean&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 2 List123456789&lt;bean&gt; &lt;property name=&quot;&quot;&gt; &lt;list&gt; &lt;value&gt;&lt;/value&gt; &lt;ref bean=&quot;&quot;/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 3 Set123456789&lt;bean&gt; &lt;property name=&quot;&quot;&gt; &lt;set&gt; &lt;value&gt;&lt;/value&gt; &lt;ref bean=&quot;&quot;/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 4 Map1234567891011&lt;bean&gt; &lt;property name=&quot;&quot;&gt; &lt;map&gt; &lt;entry key=&quot;&quot; value=&quot;&quot;/&gt; &lt;entry key=&quot;&quot; value-ref=&quot;&quot;/&gt; &lt;entry key=&quot;&quot;&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 5 Properties1234567&lt;bean&gt; &lt;property name=&quot;&quot;&gt; &lt;props&gt; &lt;prop key=&quot;&quot;&gt;value&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 6 util 名称空间12345// 使用 Util 名称空间创建集合类型的 bean，方便其它人引用&lt;util:list id=&quot;&quot;&gt;&lt;/util:list&gt;&lt;util:set id=&quot;&quot;&gt;&lt;/util:set&gt;&lt;util:map id=&quot;&quot;&gt;&lt;/util:map&gt;&lt;util:properties id=&quot;&quot;&gt;&lt;/util:properties&gt; 5.6 Bean 生命周期 1 BeanPostProcessor1 概述 后置处理器 spring 提供的工厂勾子，用于修改实例对象，如可以生成代理对象，是AOP 底层 只要实现此接口，并将实现类提供给 spring 容器，则会自动针对 spring 容器中的所有 bean，如果要针对某一个目标类，可以利用方法中的 beanName （即 BeanID）参数 2 API 方法 说明 Object postProcessBeforeInitialization(Object bean, String beanName) 初始化方法前执行 Object postProcessAfterInitialization(Object bean, String beanName) 初始化方法后执行 3 类创建流程 一般过程 1234A a=new A()a.init()a.add()a.destroy() 现有一类 B 实现了 BeanPostProcessor 接口 1234567A a=new A()// 在后处理 Bean 方法前后都可以返回代理对象a/aProxy=B.postProcessBeforeInitialization(a)a.init()a/aproxy=B.postProcessAfterInitialization(a)a.add()a.destroy() 六 注解配置6.1 配置1 开启注解1&lt;context:annotation-config/&gt; 2 注解扫描1234&lt;context:component-scan base-package=&quot;&quot; use-default-filters=&quot;&quot;&gt; &lt;context:include-filter type=&quot;&quot; expression=&quot;&quot;/&gt; &lt;context:exclude-filter type=&quot;&quot; expression=&quot;&quot;/&gt;&lt;/context:component-scan&gt; 配置了注解扫描则会开启注解，即不需要再配置 &lt;context:annotation-config/&gt; use-default-filters true，默认，表示使用 exclude，排除某些类 false，表示使用 include，仅扫描某些类 type annotation，则 expression 为注解全限定类名 assignable，则 expression 为 bean 全限定类名 6.2 Bean 实例化1 分类 注解 说明 @Component 用在任意层，不指定 beanID 则默认为类名首字母小写 @Controller 用在 WEB 层，不指定 beanID 则默认为类名首字母小写 @Service 用在 Service 层，不指定 beanID 则默认为类名首字母小写 @Repository 用在 DAO 层，不指定 beanID 则默认为类名首字母小写 2 实例化注解属性 属性 说明 String value() default &quot;&quot; 指定 beanID 6.3 Bean 作用域 @Scope 属性 说明 String scopeName() default &quot;&quot; 作用域名，singleton prototype ... String value() default &quot;&quot; 同 scopeName() 6.4 依赖注入1 @value 属性 说明 String value() 注入基本数据类型和 String，值可以使用 ${spEL} 表达式 2 @Autowired 属性 说明 boolean required() default true true 表示此属性必须注入值，false 表示若没有注入则为 null 可用在 构造 属性 方法 形参 上，如果定义在方法上，则此方法会在 Bean 创建时自动运行，且为每个形参自动注入 首先按照 byType 注入，如果有多个相同类型则再按照 byName 注入 3 @Qualifier 属性 说明 String value() default &quot;&quot; 值为 beanID 作用在属性上 不能单独使用，要配合 @autowire 按照类型注入且指定 beanID 作用在 set 方法上 可单独使用 按照 beanID 注入 4 @Resource 属性 说明 String name() default &quot;&quot; beanID Class&lt;?&gt; type default Object.class bean 的类型 JDK 中的注解 指定 name 和 type 则 Spring 查找指定 beanID 且为指定类型的 bean 指定 name 则 Spring 查找指定 beanID 的 bean 指定 type 则 Spring 查找指定类型的 bean 都不指定 则首先按照 byName 注入，若找不到则按照 byType 注入 6.5 生命周期 注解 说明 @PostConstruct 初始化 @PreDestroy 销毁 这两个注解包括 @Resource 都是 JDK 中的注解，在 JDK11 之后移除了，想要使用需要 javax.annotation-api 6.6 其它注解1 @Configuration 属性 说明 String value() default &quot;&quot; 指定配置类的字节码 定义配置类，用于代替 XML 配置文件 相当于 &lt;beans&gt; 标签 创建容器要使用 ApplicationContext 的注解实现类AnnotationApplicationContext 2 @Bean 属性 说明 String[] name() default {} 为当前方法创建的 bean 指定 beanID，默认 beanID 为方法名 String[] value() default {} 等价于 name() @Configuration + @Bean @Bean 定义在方法上，相当于 &lt;bean&gt; 标签，将当前方法的返回值作为 Bean 存入 Spring 容器 3 @ComponentScan 属性 说明 String[] basePackages() default {} 指定要扫描的包 String[] value() default {} 等价于 basePackages() 4 @PropertySource 属性 说明 String[] value() 指定 .properties 文件路径 5 @Import 属性 说明 Class&lt;?&gt;[] value() 指定其他配置类的字节码 七 AOP7.1 概述 Aspect Oriented Programming 面向切面编程 运行期间，将某段代码动态的切入到指定方法的指定位置 AOP 采取横向抽取机制，取代了传统纵向继承体系重复性代码，将核心业务与外围业务（如日志记录、权限校验、异常处理、事务控制…）分离，提高模块化，降低耦合度 7.2 AOP 术语 术语 说明 横切关注点 从每个方法中抽取出来的同一类非核心业务 Target 目标类，需要被代理的类 Joinpoint 连接点，目标类中能够被增强的方法 PointCut 切入点，已经被增强的连接点 Advice 通知，即增强的代码，一个方法 Aspect 切面，通知+切入点 ，一个类 Weaving 织入，把切面应用到目标对象并创建新的代理对象的过程 proxy 代理对象 7.3 AspectJ &amp; Spring-AOP1 概述 AOP 是一种思想，AOP 的底层是动态代理 AspectJ 和 Spring-AOP 是 AOP 的实现框架 Spring-AOP 借用了 AspectJ的配置语法 AspectJ 是静态织入： 在编译期使用 Aspect J的 acj 编译器(类似javac)把aspect 类编译成 class 字节码后，在 java 目标类编译时织入 Spring-AOP 是动态织入： 在运行时动态将要增强的代码织入到目标类中 2 包 spring-aop.jar aop 实现，依赖于 aop 联盟包 aopalliance.jar（已经集成） spring-aspects.jar 集成 AspectJ，依赖于 aspect 规范包 aspectjweaver.jar 3 通知 Advice1 概述 AOP 联盟的通知类型 org.aopalliance.aop.Advice 不同的接口代表不同的通知类型 自定义通知实现指定接口即代表此类通知 AspectJ 的通知类型 每种通知类型有特定的方法格式 自定义通知首先定义指定格式的方法，然后配置为指定类型的通知 2 AOP 联盟通知类型 类型 接口 前置通知 org.springframework.aop.MethodBeforeAdvice 后置通知 org.springframework.aop.AfterReturningAdvice 环绕通知 org.aopalliance.intercept.MethodInterceptor 异常通知 org.springframework.aop.ThrowsAdvice 引介通知 org.springframework.aop.IntroductionInterceptor 1 环绕通知 因为环绕通知是在目标方法前后执行，而系统无法判断哪些代码在前哪些在后，所以需要在环绕通知中手动执行目标方法，用以区分前后 2 执行顺序 前置通知 环绕通知（前） 目标方法 环绕通知（后） 后置通知 3 AspectJ 通知类型 类型 方法格式 前置通知 before 方法名([JoinPoint jp]) 后置通知 afterReturning 方法名([JoinPoint jp], [Object obj])，obj：目标方法返回值 环绕通知 round 方法名(ProceedingJoinPoint pjp) 异常通知 afterThrowing 方法名([JoinPoint jp], [Throwable e]) 最终通知 after 方法名([JoinPoint jp]) 1 org.aspectj.lang.JoinPoint 方法 说明 Signature getSignature() 获取封装了署名信息的对象，该对象可以获取到目标方法名，所属类的 Class 等信息 Object getTarget() 获取目标对象 Ojbect getThis() 获取代理对象 Object[] getArgs() 获取目标方法的形参 2 org.aspectj.lang.ProceedingJoinPoint extends JoinPoint 方法 说明 Object proceed() 执行目标方法 Object proceed(Object[] args) 使用新的参数执行目标方法 4 AspectJ 切入点表达式 语法 说明 execution(修饰符 返回值 包.类.方法(参数)throws 异常) 匹配符合的方法 within(包) 匹配包或子包中的方法 this(接口全限定名) 匹配实现接口的代理对象中的方法 target(接口全限定名) 匹配实现接口的目标对象中的方法 args(参数) 匹配符合参数格式的方法 bean(&quot;beanId&quot;) 匹配指定 bean 中的所有方法 execution1execution(修饰符 返回值 包.类.方法(参数)throws 异常) 语法 说明 值 修饰符 一般省略 *：任意public：公有 返回值 不可省略 *：任意void String ... 包 不可省略 *：任意..：当前包及其子包 类 不可省略 *：任意XXX *XXX XXX* 方法 不可省略 *：任意XXX *XXX XXX* 参数 不可省略 ..：任意类型参数，有无参数皆可*：任意类型参数，且必须有参数int：基本类型直接写名称java.lang.String：引用类型写全限定名 异常 一般省略 7.4 AOP 实现1 代理模式 静态代理 动态代理 2 Spring-AOP1 编程式 ProxyFactory12345ProxyFactory factory = new ProxyFactory();factory.setTarget();factory.setInterfaces();factory.addAdvice();factory.getProxy(); 2 配置式 ProxyFactoryBean12345&lt;bean id=&quot;&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;property name=&quot;interfaces&quot; value=&quot;&quot;/&gt; &lt;property name=&quot;target&quot; ref=&quot;&quot;/&gt; &lt;property name=&quot;interceptorNames&quot; value=&quot;&quot;/&gt;&lt;/bean&gt; 3 Spring-AOP + AspectJ1 AOP 联盟的通知类型123456&lt;aop:config proxy-target-class=&quot;&quot;&gt; // 配置切入点，可以被此 AOP 配置下的所有配置引用 &lt;aop:pointcut id=&quot;&quot; expression=&quot;&quot;/&gt; // 特殊的切面，只有一个通知 和 一个切入点 &lt;aop:advisor advice-ref=&quot;&quot; pointcut-ref=&quot;&quot; order=&quot;切面优先级&quot;/&gt;&lt;/aop:config&gt; proxy-target-class false：默认，使用 JDK 代理 true：使用 cglib 代理 2 AspectJ 的通知类型1 XML 配置1234567891011&lt;aop:config proxy-target-class=&quot;&quot;&gt; &lt;aop:aspect ref=&quot;引入通知&quot; order=&quot;切面优先级&quot;&gt; // 配置切入点，只能被当前 aspect 引用 &lt;aop:pointcut id=&quot;&quot; expression=&quot;&quot;/&gt; &lt;aop:before method=&quot;&quot; pointcut-ref=&quot;&quot;/&gt; &lt;aop:after-returning method=&quot;&quot; pointcut-ref=&quot;&quot; returning=&quot;&quot;/&gt; &lt;aop:around method=&quot;&quot; pointcut-ref=&quot;&quot;/&gt; &lt;aop:after method=&quot;&quot; pointcut-ref=&quot;&quot;/&gt; &lt;aop:after-throwing method=&quot;&quot; pointcut-ref=&quot;&quot; throwing=&quot;&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 2 注解1 开启 AOP 注解 xml 配置 1&lt;aop:aspectj-autoproxy proxy-target-class=&quot;默认false&quot;/&gt; 注解 12// 作用在配置类上（带有 @Configuraction 的类）@EnableAspectJAutoProxy 2 通知类上 注解 说明 @Aspect 声明切面，等价于 &lt;aop:aspect&gt; @Order 切面的优先级 3 通知方法上 注解 说明 @PointCut execution()：声明切入点，ID 为方法名方法名()：引入切入点 @Before 前置通知 @AfterReturning 后置通知 @Around 环绕通知 @After 最终通知 @AfterThrowing 异常通知 八 JdbcTemplate8.1 概述 Spring 提供用于操作JDBC工具类，类似：DBUtils 依赖 DataSource （数据源） 8.2 API1 构造 JdbcTemplate() JdbcTemplate(DataSource dataSource) JdbcTemplate(DataSource dataSource, boolean lazyInit) 2 增删改 int update(String sql, Object... args) int batchUpdate(String sql, List&lt;Object[]&gt; batchArgs) 3 查 方法 说明 List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper, Object... args) 将查询结果封装为对象并存储到 List 集合中 T queryForObject(String sql, Class&lt;T&gt; requiredType, Object... args) 查询单个值 T queryForObject(String sql, RowMapper&lt;T&gt; rowMapper, Object... args) 查询单行数据，返回一个对象 Map&lt;String, Object&gt; queryForMap(String sql, Object... args) 查询的结果集封装为 map 集合，此方法查询结果集长度只能是 1 List&lt;Map&lt;String, Object&gt;&gt; queryForList(String sql, Object... args) 将每一条记录封装为 map 集合，然后将 map 集合存到到 list 集合中 4 RowMapper1 概述 类似于 DBUtils 的 ResultSetHandler 可以自己实现，也可使用 spring 提供的 2 方法 T mapRow(ResultSet rs, int rowNum) 3 Srpng 的实现 实现 说明 BeanPropertyRowMapper 将结果集封装为对象 8.3 使用1 手动方式 创建数据源 创建 JdbcTemplate，并设置数据源（构造或者 set 方法） 使用 JdbcTemplate 操作 2 Spring IOC 之 JdbcTemplate 配置数据源 Bean 配置 JdbcTemplate Bean ，并注入数据源 将 JdbcTemplate 注入到 DAO 中进行操作 3 Spring IOC 之 JdbcDaoSupport1 API 方法 说明 private JdbcTemplate jdbcTemplate 内部有一个 JdbcTemplate 属性 void setDataSource(DataSource dataSource) 如果内部 JdbcTemplate 为空或非此数据源创建的，则使用此数据源创建一个新的 JdbcTemplate JdbcTemplate createJdbcTemplate(DataSource dataSource) 使用数据源创建一个新的 JdbcTemplate DataSource getDataSource() 获取 JdbcTemplate 的数据源 void setJdbcTemplate(JdbcTemplate jdbcTemplate) 设置 JdbcTemplate JdbcTemplate getJdbcTemplate() 获取 JdbcTemplate 2 使用 JdbcDaoSupport 中只需注入数据源，会自动根据数据源创建 JdbcTemplate DAO 继承 JdbcDaoSupport 配置数据源 Bean 将数据源注入到 DAO 中，在 DAO 中获取 JdbcTemplate 进行操作 九 事务管理9.1 结构 1 PlatformTransactionManager1 概述 平台事务管理器在 spring-tx.jar 中 因为不同平台，操作事务的代码各不相同，spring 提供了此接口 spring 要管理事务，必须使用事务管理器 2 API 方法 说明 TransactionStatus getTransaction(TransactionDefinition definition) 获取事务状态 TransactionStatus void commit(TransactionStatus status) 根据状态提交 void rollback(TransactionStatus status) 根据状态回滚 3 实现 实现 说明 DataSourceTransactionManager jdbc 事务管理器，采用 JdbcTemplate，在 spring-jdbc.jar 中 HibernateTransactionManager Hibernate 事务管理器，在 spring-orm.jar 中 2 TransactionDefinition1 概述 事务详情（或叫事务定义、事务属性），如隔离级别，传播行为，是否只读，超时时间… 进行事务配置时，必须配置事务详情，Spring 将配置封装到此对象实例 2 API 方法 说明 int getIsolationLevel() 获取隔离级别 int getPropagationBehavior() 获取传播行为 String getName() 获取事务名称 boolean isReadOnly() 事务是否只读，默认 false int getTimeout() 获取超时时间 3 传播行为1 概述 如果有多个事务嵌套运行，子事务是否与大事务共用一个事务 一个方法运行在了一个开启了事务的方法中时，当前方法是使用原来的事务还是开启一个新的事务 2 分类 名称 int 值 说明 PROPAGATION_REQUIRED（默认） 0 如果调用者 A 有事务，则被调用者 B 使用该事务，反之 B 创建一个新事务 PROPAGATION_SUPPORTS 1 如果 A 有事务，则 B 使用此事务，反之 B 不使用事务 PROPAGATION_MANDATORY 2 如果 A 有事务，则 B 使用此事务，反之 B 抛异常 PROPAGATION_REQUIRES_NEW 3 无论 A 是否有事务，B 都创建一个新事务 PROPAGATION_NOT_SUPPORTED 4 无论 A 是否有事务，B 都不使用事务 PROPAGATION_NEVER 5 如果 A 有事务，则 B 抛异常，反之 B 不使用事务 PROPAGATION_NESTED 6 A 和 B 底层采用保存点机制，形成嵌套事务 4 隔离级别 名称 int 值 说明 ISOLATION_DEFAULT（默认） -1 使用数据库的默认隔离级别 ISOLATION_READ_UNCOMMITTED 1 读未提交 ISOLATION_READ_COMMITTED 2 读已提交 ISOLATION_REPEATABLE_READ 4 可重复度 ISOLATION_SERIALIZABLE 8 串行化 3 TransactionStatus1 概述 事务状态 spring 用于记录当前事务运行状态，如是否有保存点，是否完成… 2 API 方法 说明 boolean isNewTransaction() 是否是新事务 boolean hasSavepoint() 事务是否有保存点 void setRollbackOnly() 设置事务 rollback-only boolean isRollbackOnly() 事务是否设置了 rollback-only boolean isCompleted() 事务是否完成 void flush() 刷新事务 9.2 事务管理1 概述 Spring 使用 TransactionTemplate 模板管理事务 模板需要注入事务管理器，事务管理器需要事务，事务从连接 Connection 中获取，而无论直接创建连接还是从连接池中获取连接都需要数据源 先给事务管理器注入数据源，之后再将事务管理器注入到模板中 2 管理事务方式1 手动管理事务（了解） 配置 TransactionTemplate ，并注入 Service 中 在 Service 中使用事务模板操作 transactionTemplate.execute(); 2 TransactionProxyFactoryBean（半自动管理事务）1 概述 spring 提供的管理事务的 FactoryBean 使用此 FactoryBean 生成代理，为代理对象注入事务管理器及事务详情 使用代理对象执行业务方法 2 配置1234567891011&lt;bean id=&quot;代理对象ID&quot; class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt; &lt;property name=&quot;proxyInterfaces&quot; value=&quot;目标接口&quot;/&gt; &lt;property name=&quot;target&quot; ref=&quot;目标对象&quot;/&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;事务管理器&quot;/&gt; // 事务详情 &lt;property name=&quot;transactionAttributes&quot;&gt; &lt;props&gt; &lt;prop key=&quot;方法名&quot;&gt;格式：PROPAGATION,ISOLATION,readOnly,-Exception,+Exception&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 3 AOP （自动管理事务）1 XML123456789101112131415&lt;!--1 配置事务管理器--&gt;&lt;bean id=&quot;&quot; class=&quot;&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;&quot;/&gt;&lt;/bean&gt;&lt;!--2 配置事务详情--&gt;&lt;tx:advice id=&quot;&quot; transaction-manager=&quot;&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;&quot; propagation=&quot;&quot; isolation=&quot;&quot; readOnly=&quot;&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--3 AOP 配置--&gt;&lt;aop:config&gt; &lt;aop:pointcut id=&quot;&quot; expression=&quot;&quot;/&gt; &lt;aop:advisor advice-ref=&quot;&quot; pointcut-ref=&quot;&quot;/&gt;&lt;/aop:config&gt; 2 注解1 配置123456&lt;!--1 配置事务管理器 --&gt;&lt;bean id=&quot;&quot; class=&quot;&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;&quot;/&gt;&lt;/bean&gt;&lt;!--2 开启事务注解--&gt;&lt;tx:annotation-driven transaction-manager=&quot;&quot;/&gt; 2 @Transactional 属性 说明 String transactionManager() default &quot;&quot; 事务管理器 String value() default &quot;&quot; 同 transactionManager() Propagation propagation() default Propagation.REQUIRED 事务传播行为 Isolation isolation() default Isolation.DEFAULT 事务隔离级别 boolean readOnly() default false 事务是否只读 int timeout() default TransactionDefinition.TIMEOUT_DEFAULT 事务超时时间，超过事务自动终止并回滚 rollbackFor/rollbackForClassName 遇到指定类型的异常回滚，Spring 默认运行时异常回滚，编译时异常不会滚 noRollbackFor/noRollbackForClassName 遇到指定类型的异常不回滚 作用在类上：所有方法都开启事务 作用在方法上：当前方法开启事务 10.1 Spring + Junit1 包 Junit 的包 Spring 的包 spring-core spring-beans spring-context spring-expression spring-jcl spring-test 2 使用1 @RunWith1@RunWith(SpringJunit4ClassRunner.class) Junit 的注解，作用在类上 替换原有运行器 2 @ContextConfiguration 属性 说明 String[] locations() default {} 指定 spring 配置文件的位置 String[] value() default {} 同 locations() Class&lt;?&gt;[] classes() default {} 指定注解配置类 3 通过 @Autowired 注入即可10.2 Spring + Web1 概述 普通 Java 项目：需要手动读取 Spring 配置，创建 Spring 容器 Web 项目：服务器启动就创建 Spring 容器 Web 技术中启动服务器救加载配置文件的方式 Servlet Filter Listener 2 Web 技术：服务器启动就加载配置文件1 Servlet12345init(ServletConfig config)// 配置一启动就初始化 Servlet&lt;Servlet&gt; &lt;load-on-startup&gt;&lt;/Servlet&gt; 2 Filter123init(FilterConfig config)// 注册过滤器自动调用初始化&lt;Filter&gt;&lt;/Filter&gt; 3 Listener1注册监听器 ServletContextListener 3 Spring + Web1 概述 WebApplicationContext：Spring Web 容器 Spring 初始化 WebApplicationContext ： ContextLoaderServlet ContextLoaderListener 2 web.xml 配置 Spring 监听器1234567&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 此监听器默认加载的是 WEB-INF/applicationContext.xml 而配置文件通常是 WEB-INF/classes/applicationContext.cml 4 手动获取 Spring 容器 一个应用中只有一个 Spring 容器，存放在 ServletContext 域中，key 为 WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE 从域中手动获取 1this.getServletContext().getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) 工具类 WebApplicationContextUtils，封装了手动获取 1WebApplicationContextUtils.getWebApplicationContext(this.getServletContext()) ContextLoader 1ContextLoader.getCurrentWebApplicationContext()","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Frame","slug":"CS/Frame","permalink":"https://anyeansan.github.io/categories/CS/Frame/"}],"tags":[]},{"title":"MyBatis","slug":"框架/MyBatis","date":"2020-11-08T12:56:14.000Z","updated":"2020-11-08T12:57:06.521Z","comments":true,"path":"2020/11/08/框架/MyBatis/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/%E6%A1%86%E6%9E%B6/MyBatis/","excerpt":"","text":"一 概述 MyBatis 是一个持久层框架，是一个不完全的 orm 框架 MyBatis 让程序员只关注 SQL 本身，而不需要去关注 其它 JDBC 代码以及设置参数和获取结果集的工作 MyBatis 支持自定义 SQL、存储过程以及高级映射 JDBC 的问题 在创建连接时，存在硬编码，解决：配置文件（全局配置文件） 在执行 statement 时存在硬编码，解决：配置文件（映射文件） 频繁开关数据库连接，解决：数据库连接池（全局配置文件） 二 API2.1 概述 类/接口 说明 推荐作用域 SqlSessionFactoryBuilder 用于创建 SqlSessionFactory 方法作用域 SqlSessionFactory 一个应用只存在一个，单例 应用作用域 SqlSession 每个线程都应该有它自己的 SqlSession 实例，提供了在数据库执行 SQL 命令所需的所有方法 请求作用域 映射器实例 XxxMapper 绑定映射语句的接口，从 SqlSession 中获取 方法作用域 2.2 SqlSessionFactoryBuilder12345SqlSessionFactory build(InputStream inputStream)SqlSessionFactory build(InputStream inputStream, String environment)SqlSessionFactory build(InputStream inputStream, Properties properties)SqlSessionFactory build(InputStream inputStream, String env, Properties props)SqlSessionFactory build(Configuration config) 2.3 SqlSessionFactory SqlSession openSession() 事务作用域将会开启（也就是不自动提交） 由当前环境配置的 DataSource 实例中获取 Connection 对象 事务隔离级别将会使用驱动或数据源的默认设置 预处理语句不会被复用，也不会批量处理更新 SqlSession openSession(boolean autoCommit) true ：开启自动提交 SqlSession openSession(Connection connection) 使用指定的 Connection 实例 2.4 SqlSession1 增删改查 方法 说明 int insert(String statement, Object parameter) 增，statement：为 namespace.id int delete(String statement, Object parameter) 删 int update(String statement, Object parameter) 改 T selectOne(String statement, Object parameter) 返回一个对象或 null List&lt;E&gt; selectList(String statement, Object parameter) 返回 n 个对象的 List 集合 Map&lt;K, V&gt; selectMap(String statement, Object parameter, String mapKey) 对象某个属性作为 key，对象作为 value 2 其它 方法 说明 T getMapper(Class&lt;T&gt; type) 获取映射器 Mapper Connection getConnection() 获取连接 void commit() 提交 void rollback() 回滚 void close() 关闭 3 关闭模板123try (SqlSession session = sqlSessionFactory.openSession()) &#123; // 你的应用逻辑代码&#125; 4 Mybatis 应用方式1 直接使用 SqlSession 的 API123try (SqlSession session = sqlSessionFactory.openSession()) &#123; Blog blog = (Blog) session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);&#125; 2 使用 Mapper 接口1234try (SqlSession session = sqlSessionFactory.openSession()) &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(101);&#125; 三 Mapper 接口规范 Mapper 接口的全限定名要和 Mapper 映射文件的 namespace 值一致 Mapper 接口的方法名要和 Mapper 映射文件的 statement 的 id 一致 Mapper 接口的方法参数类型要和 Mapper 映射文件的 statement 的 parameterType 一致，且它的参数是一个 Mapper 接口的方法返回值类型要和 Mapper 映射文件的 statement 的 resultType 一致 四 全局配置文件1234567891011121314&lt;configuration&gt; * properties （属性） * settings （设置） * typeAliases （类型别名） * typeHandlers （类型处理器） * objectFactory （对象工厂） * plugins （插件） * environments （环境） * environment （环境变量） * transactionManager （事务管理器） * dataSource （数据源） * databaseIdProvider （数据库厂商标识） * mappers （映射器）&lt;/configuration&gt; 4.1 properties1 引入外部资源文件1&lt;properties resource=&quot;类路径资源文件&quot; url=&quot;网络或磁盘资源文件&quot;&gt; 2 在配置文件内部定义属性1234&lt;properties&gt; &lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&gt;&lt;/properties&gt; 3 动态配置属性1 方式 内部定义属性 外部资源文件中定义属性 SqlSessionFactoryBuilder 构造 SqlSessionFactory 时 build() 方法中传递属性 2 说明 动态属性可以在配置文件中使用 ${属性名} 优先级：后加载覆盖前边的，所以 3 &gt; 2 &gt; 1 4.2 settings123&lt;settings&gt; &lt;setting name=&quot;&quot; value=&quot;&quot;/&gt;&lt;/settings&gt; 属性 说明 cacheEnabled 是否开启缓存，默认 true lazyLoadingEnabled 是否开启懒加载，默认 false aggressiveLazyLoading true：任一方法的调用都会加载该对象的所有延迟加载属性，默认 false：按需加载延迟属性 autoMappingBehavior 自动映射，默认 partial：只会自动映射没有定义嵌套结果映射的字段 mapUnderscoreToCamelCase 是否开启驼峰命名自动映射，即属性 userName 对应列 USER_NAME，默认 false logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找 4.3 typeAliases1 单个定义1 XML1234&lt;typeAliases&gt; &lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&gt; &lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&gt;&lt;/typeAliases&gt; 2 注解1@Alias(&quot;别名&quot;) 2 批量定义123&lt;typeAliases&gt; &lt;package name=&quot;domain.blog&quot;/&gt;&lt;/typeAliases&gt; 为包及其子包下的类配置别名 默认别名为首字母小写的非限定类名 3 内置别名 类型 别名 基本类型 _基本类型，如 int：_int 基本类型包装类 对应基本类型，如 Integer：int 引用类型 对应类型首字母小写，如 string list map... 4.4 plugins mybatis-pluse mybatis-generator-core … 4.5 environments12345678910111213&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt; &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt; &lt;/transactionManager&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 1 environments 可以配置多个环境，但 每个 SqlSessionFactory 实例只能选择一种环境，即 每个数据库对应一个 SqlSessionFactory 实例 default 通过 &lt;enviroment&gt; 的 id 指定使用哪个环境 2 transactionManager 事务管理器，type 有两种类型 JDBC MANAGED Spring + MyBatis 没有必要配置事务管理器，因为 Spring 模块会使用自带的管理器来覆盖前面的配置 3 dataSource 数据源，type 有三种类型 UNPOOLED UnpooledDataSourceFactory 采用传统的获取连接的方式，虽然也实现了 javax.sql.DataSource 接口，但并没有使用池的思想 POOLED PooledDataSourceFactory 采用传统的 javax.sql.DataSource 规范中的连接池，mybatis 中有规范的实现 JNDI PooledDataSourceFactory 采用服务器提供的JNDI技术实现，来获取 DataSource ，不同的服务器所能拿到的 DataSource 是不同的 数据源交给 Spring 配置 4.6 databaseIdProvider1 配置1234&lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt; &lt;property name=&quot;MySQL&quot; value=&quot;别名&quot;/&gt; &lt;property name=&quot;Oracle&quot; value=&quot;别名&quot;/&gt;&lt;/databaseIdProvider&gt; 2 作用 获取数据库厂商标识（驱动 getDatabaseProductName()），mybatis 就能根据数据库厂商标识执行不同 sql 在映射配置文件中的增删改查配置 databaseId：数据库标识别名，表示该 crud 操作是针对哪个数据库的 4.7 mappers1 作用 注册映射器，即告诉 MyBatis 到哪里去找映射文件 2 方式1 使用相对于类路径的资源引用123&lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;&lt;/mappers&gt; 2 使用完全限定资源定位符（磁盘或网络 URL）123&lt;mappers&gt; &lt;mapper url=&quot;file:///&quot;/&gt;&lt;/mappers&gt; 3 使用映射器接口的全限定名123&lt;mappers&gt; &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;&lt;/mappers&gt; 要求 Mapper 接口和 Mapper 映射文件名称相同且在同一个目录下 4 包名123&lt;mappers&gt; &lt;package name=&quot;org.mybatis.builder&quot;/&gt;&lt;/mappers&gt; 将包内的映射器接口实现全部注册为映射器 要求 Mapper 接口和 Mapper 映射文件名称相同且在同一个目录下 五 映射配置文件12345678910&lt;mapper namespace=&quot;Mapper接口全限定名&quot;&gt; * cache – 该命名空间的缓存配置 * cache-ref – 引用其它命名空间的缓存配置 * resultMap – 描述如何从数据库结果集中加载对象 * sql – 可被其它语句引用的可重用语句块 * insert – 映射插入语句 * update – 映射更新语句 * delete – 映射删除语句 * select – 映射查询语句&lt;/mapper&gt; 5.1 select123&lt;select id=&quot;&quot; parameterType=&quot;&quot; resultType=&quot;&quot; resultMap=&quot;&quot;&gt; SELECT * FROM PERSON WHERE ID = #&#123;id&#125;&lt;/select&gt; 属性 说明 id 在命名空间中唯一的标识符，可以被用来引用这条语句 parameterType 参数的类全限定名或别名 resultType 返回结果的类全限定名或别名，如果返回集合，应设置为集合包含的类型 resultMap 对外部 resultMap 的命名引用，resultType 和 resultMap 只能选其一 useCache true：本条语句的结果会被二级缓存缓存起来，默认 ：对 select 元素为 true flushCache true：只要语句被调用，都会导致本地缓存和二级缓存被清空，默认 false 5.2 insert update delete 属性 说明 id 在命名空间中唯一的标识符，可以被用来引用这条语句 parameterType 参数的类全限定名或别名 useGeneratedKeys （仅适用于 insert 和 update）MyBatis 使用 JDBC 的 getGeneratedKeys() 方法来取出由数据库内部生成的主键，默认 false keyProperty （仅适用于 insert 和 update）指定用对象的哪个属性保存主键，Mybatis 使用 getGeneratedKeys() 的返回值或 insert 语句的 selectKey 子元素设置它的值 flushCache true：只要语句被调用，都会导致本地缓存和二级缓存被清空，默认 true 1 selectKey1234&lt;insert id=&quot;&quot; parameterType=&quot;&quot;&gt; &lt;selectKey keyProperty=&quot;&quot; resultType=&quot;&quot; order=&quot;AFTER&quot;&gt; &lt;/selectKey&gt;&lt;/insert&gt; 属性 说明 keyProperty selectKey 语句结果应该被设置到的目标属性 keyColumn 返回结果集中生成列属性的列名 resultType 结果的类型 order BEFORE：先生成主键，设置 keyProperty，再执行插入语句AFTER：先执行插入语句，然后是 selectKey 中的语句 2 insert update 获取主键1 支持自动生成主键（Mysql, Sql Server）123456789// 1 将生成的主键赋值给 keyProperty 指定的属性&lt;insert id=&quot;&quot; parameterType=&quot;&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;&quot;&gt;&lt;/insert&gt;// 2&lt;insert id=&quot;&quot; parameterType=&quot;&quot;&gt; &lt;selectKey keyProperty=&quot;&quot; resultType=&quot;&quot; order=&quot;AFTER&quot;&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt;&lt;/insert&gt; 2 不支持自动生成主键（oracle）1234&lt;insert id=&quot;&quot; parameterType=&quot;&quot;&gt; &lt;selectKey keyProperty=&quot;&quot; resultType=&quot;&quot; order=&quot;before&quot;&gt; &lt;/selectKey&gt;&lt;/insert&gt; 5.3 sql1 作用 用来定义可重用的 SQL 代码片段，以便在其它语句中使用 定义时可以确定参数，引用时插入值 2 定义123&lt;sql id=&quot;&quot;&gt; $&#123;alias&#125;.id,$&#123;alias&#125;.username&lt;/sql&gt; 3 引用123&lt;include refid=&quot;&quot;&gt; &lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt;&lt;/include&gt; 5.4 动态 SQL1 if12345678910111213&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE &lt;if test=&quot;state != null&quot;&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt;&lt;/select&gt; 2 where123456789101112131415&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=&quot;state != null&quot;&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; if 标签的问题： 如果条件全都匹配不上，则最终语句 SELECT * FROM BLOG WHERE 如果仅第二个匹配上，则最终语句 SELECT * FROM BLOG WHERE AND title like ‘someTitle’ 3 trim1234&lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;&quot; suffix=&quot;&quot; suffixOverrides=&quot;and | or&quot;&gt;&lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt; ...&lt;/trim&gt; 属性 说明 prefix 添加一个前缀 prefixOverrides 去掉一个前缀 suffix 添加一个后缀 suffixOverrides 去掉一个后缀 trim ：可以实现 where 和 set 的功能 4 set12345678910&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt; update Author &lt;set&gt; &lt;if test=&quot;username != null&quot;&gt;username=#&#123;username&#125;,&lt;/if&gt; &lt;if test=&quot;password != null&quot;&gt;password=#&#123;password&#125;,&lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test=&quot;bio != null&quot;&gt;bio=#&#123;bio&#125;&lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt; set 会动态地在行首插入 SET 关键字，并会删掉额外的逗号 5 choose（when/otherwise）123456789101112131415&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; 6 foreach123456789&lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; 属性 说明 collection 对象：属性名，数组：array，集合：collection/list item 遍历变量名 index 元素索引或键 open 遍历开始时拼接的字符串 close 遍历结束时拼接的字符串 separator 拼接的连接符 5.5 输入映射（参数）1 参数获取方式 语法 说明 使用场景 基本类型（包装类）和 String #{} 表示一个占位符，PreparedStatement：预编译 能用就用 #{任意名称} ${} 表示 SQL 连接，Statement：将接收到参数的内容直接拼接到 sql 语句上，存在 sql 注入 原生 JDBC 不支持占位符的地方 ${value} 或 ${_参数名} #{} 扩展：规定参数的一些规则 javaType，jdbcType，mode(存储过程)，numericScale resultMap，typeHandler，jdbcTypeName... jdbcType 当数据为 null 时，Mybatis 默认映射的是原生 jdbc 的 OTHER 类型 有些数据库（如Oracle）可能不识别 Mybatis 对 null 的默认处理，错误信息：JdbcType OTHER: 无效的类型 解决 取值时可以指定 jdbcType：#{xxx, jdbcType=NULL} 在全局配置中的setting的jdbcTypeForNull设置为NULL 2 参数传递1 单个参数1 类型 获取 基本类型，基本类型包装类，String #{任意名} JavaBean #{JavaBean.属性名} Map #{key} 2 Collection / Array Mybatis 对 Collection List Array 类型的参数做了特殊处理，封装到了 Map 中，不用配置 parameterType，使用 &lt;foreach&gt; 标签获取 Key Collection（List/Set）：collection List：list Array：array 2 多个参数 方式 key 默认 1 0,1...n2 param1,param2...paramn @param 1 自定义2 param1,param2...paramn Mybatis 将多个参数封装到了 Map 中，获取： #{key} @param ：使用此注解在 Mapper 接口方法的形参上自定义 key 1insertUser(@param(&quot;id&quot;)int id, @param(&quot;name&quot;)String name)&#123;&#125; 5.6 输出映射（结果）1 resultType1 概述 resultType 结果映射时查询出的列名与映射属性名一致，才能赋值成功 如果查询的列有别名，则按照别名匹配 2 类型 resultType 值 基本类型 对应基本类型 JavaBean 对应 JavaBean 类型 Collection, Array 集合或数组中的元素类型 3 Map1 单行结果映射 resultType：map/java.util.Map Map&lt;String, Object&gt; key：列名 value：列值 2 多行结果映射 resultType：Map 中 value 的类型 Map&lt;自定义, Object&gt; key：@MapKey 在方法上定义哪个属性作为 key value：一行数据封装的对象 2 resultMap123456&lt;resultMap id=&quot;&quot; type=&quot;结果集封装的类型&quot;&gt; &lt;id property=&quot;javabean中的属性名&quot; column=&quot;结果集的列名&quot; /&gt; &lt;result property=&quot;&quot; column=&quot;&quot;/&gt; &lt;association&gt; &lt;collection&gt;&lt;/resultMap&gt; 子标签 说明 &lt;id&gt; 完成主键列的映射 &lt;result&gt; 1 完成普通列的映射2 通过对象导航图也能完成高级映射 &lt;association&gt; 完成 多对一（一对一）的映射 &lt;collection&gt; 完成 一对多（多对多）的映射 1 &lt;association&gt;1 直接查询12345&lt;association property=&quot;&quot; javaType=&quot;&quot; fetchType=&quot;&quot;&gt; &lt;!-- id标签：建议在关联查询时必须写上，不写不会报错，但是会影响性能 --&gt; &lt;id column=&quot;&quot; property=&quot;&quot; /&gt; &lt;result column=&quot;&quot; property=&quot;&quot; /&gt;&lt;/association&gt; fetchType： 值 lazy：本次查询使用懒加载 eager：本次查询不使用懒加载 设置此属性则忽略全局配置 lazyLoadingEnabled 2 分步查询1&lt;association property=&quot;关联属性&quot; column=&quot;关联属性中的关联列&quot; select=&quot;引入一个&lt;select&gt;&quot;&gt; column 作为分步查询 select 的参数，是本次查询查出的值 select 的结果会赋值给 property 我发现直接查询，即使字段可以自动映射也必须配置，分步查询能自动映射则不用配置 为何用分步查询？ 通常每个实体都有对应的 CURD，所以既然有了就拿来用 懒加载 4 &lt;collection&gt;1 直接查询1234&lt;collection property=&quot;&quot; ofType=&quot;属性中封装的类型（集合泛型）&quot;&gt; &lt;id column=&quot;&quot; property=&quot;&quot; /&gt; &lt;result column=&quot;&quot; property=&quot;&quot; /&gt;&lt;/collection&gt; 2 分步查询1&lt;collection property=&quot;关联属性&quot; column=&quot;关联属性中的关联列&quot; select=&quot;&quot;&gt; 5.7 模糊查询1 传参时手动拼接1mapper.getUser(&quot;%安%&quot;) 2 映射配置文件中配置1 不推荐，存在 sql 注入123like &apos;%#&#123;name&#125;%&apos; // 错误，#&#123;&#125; 在字符串中不能识别like &apos;%&apos;#&#123;name&#125;&apos;%&apos;like &apos;%$&#123;name&#125;%&apos; 2 推荐12like concat(&apos;%&apos;, #&#123;name&#125;, &apos;%&apos;)like concat(&apos;%&apos;, &apos;$&#123;name&#125;&apos;, &apos;%&apos;) 六 注解 注解 说明 @Param 用在 Mapper 接口方法的参数上，自定义参数名 @Insert 用在 Mapper 接口方法上，等价于 &lt;insert&gt; @Update 用在 Mapper 接口方法上，等价于 &lt;update&gt; @Delete 用在 Mapper 接口方法上，等价于 &lt;delete&gt; @Select 用在 Mapper 接口方法上，等价于 &lt;select&gt; @ResultMap 引用 XML 中定义的 &lt;resultMap&gt; 七 日志7.1 配置日志（全局配置中）123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;&quot;/&gt;&lt;/settings&gt; 7.2 值 STDOUT_LOGGING：标准日志，配置即可使用 SLF4J LOG4J, LOG4J2 JDK_LOGGING COMMONS_LOGGING NO_LOGGING 八 分页8.1 SQL 语句 limit 实现 物理分页：直接从数据库中获取所需数据 物理分页每次都要访问数据库 物理分页每次获取的数据都是最新的 物理分页占用内存小 8.2 RowBounds 构造 说明 RowBounds() 默认 offset=0，limit=Integer.MAX_VALUE RowBounds(int offset, int limit) offset：起始行，limit：获取行数 逻辑分页：从数据库中拿出所有符合要求的数据，然后再从这些数据中获取所需的分页数据 逻辑分页只需访问一次数据库 逻辑分页的数据有可能滞后 逻辑分页占用内存多 8.3 分页插件九 缓存9.1 概述 缓存即存于内存中的临时数据，为了减少和数据库的交互次数，提高效率 适合缓存的数据 经常使用且不经常改变的 数据正确与否对最终结果影响不大的 Mybatis 使用到了两种缓存 本地缓存（local cache），或者叫一级缓存 二级缓存（second level cache） 9.2 本地缓存1 概述 本地缓存指定是 SqlSession 对象的缓存，是一个 Map 结构 每当一个新的 SqlSession 创建，MyBatis 就会创建一个与之相关联的本地缓存 任何查询结果都会被保存在本地缓存中 key：由 sql语句、条件、statement 等信息组成一个唯一值 value：查询结果 2 清除缓存 增删改：insert update delete 事务提交或回滚：commit rollback SqlSession 关闭：close SqlSession 手动清理：void clearCache() 9.3 二级缓存1 概述 二级缓存指的是 SqlSessionFactory对象的缓存，默认关闭 同一个 SqlSessionFactory 创建的 SqlSession 共享缓存数据 二级缓存是事务性的，即每个 SqlSession 提交或关闭时才会将数据写入二级缓存 二级缓存的对象必须实现 Serializable 接口 二级缓存获取的对象可能不能，但数据一样 2 开启 &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 全局配置文件，缓存总开关，默认 true &lt;cache type=&quot;org.apache.ibatis.cache.impl.PerpetualCache&quot;/&gt; 映射配置文件，二级缓存开关， type 默认 PerpetualCache，可省略 可使用自定义缓存或第三方缓存 缓存效果 映射语句文件中的所有 select 语句的结果将会被缓存 映射语句文件中的所有 insert、update、delete 语句会刷新缓存 缓存不会定时进行刷新","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Frame","slug":"CS/Frame","permalink":"https://anyeansan.github.io/categories/CS/Frame/"}],"tags":[]},{"title":"过滤器和监听器","slug":"JavaWeb/过滤器和监听器","date":"2020-11-08T12:52:35.000Z","updated":"2020-11-08T12:54:22.693Z","comments":true,"path":"2020/11/08/JavaWeb/过滤器和监听器/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/JavaWeb/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/","excerpt":"","text":"一 过滤器 Filter1.1 概述 过滤器可以过滤客户端和 WEB 资源之间的请求和响应信息 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤… 过滤器都需要直接或间接实现 javax.servlet.Filter 接口 创建过滤器可以继承 javax.servlet.http.HttpFilter 1.2 API1 javax.servlet.Filter 修饰 方法 说明 void init(FilterConfig config) 初始化 void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) 过滤方法 void destroy() 销毁 2 javax.servlet.http.HttpFilter 修饰 方法 说明 void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) 重写方法，会调用特有方法 void doFilter(HttpServletRequest req, HttpServletResponse res, FilterChain chain) 特有的过滤方法 FilterConfig getFilterConfig() 获取 FilterConfig 3 javax.servlet.FilterChain 修饰 方法 说明 void doFilter(ServletRequest req, ServletResponse res) 放行 4 javax.servlet.FilterConfig 修饰 方法 说明 String getFilterName() 获取过滤器名称 String getInitParameter(String name) 根据键获取初始化参数的值 Enumeration&lt;String&gt; getInitParameterNames() 获取所有初始化参数键的枚举 ServletContext getServletContext() 获取 ServletContext 1.3 Filter 配置1 xml 方式：web.xml12345678910&lt;filter&gt; &lt;filter-name&gt;&lt;/filter-name&gt; &lt;filter-class&gt;&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;&lt;/filter-name&gt; &lt;url-pattern&gt;过滤指定 url&lt;/url-pattern&gt; &lt;servlet-name&gt;过滤指定 servlet&lt;/servlet-name&gt; &lt;dispatcher&gt;过滤哪种模式的请求，必须写在最后&lt;/dispatcher&gt;&lt;filter-mapping&gt; 过滤器链执行顺序由 &lt;filter-mapping&gt; 配置顺序决定 2 注解：@WebFilter 属性 说明 等价于 String filterName() 过滤器名称 &lt;filter-name&gt; String[] urlPatterns() 映射 &lt;url-pattern&gt; String[] value() 同 urlPatterns &lt;url-pattern&gt; String[] servletNames() 过滤哪些Servlet &lt;servlet-name&gt; DispatcherType dispatcherTypes() 过滤哪种模式的请求 &lt;dispatcher&gt; WebInitParam[] initParams() 初始化参数 &lt;init-param&gt; 按照类名的字符串比较规则比较，值小的先执行 3 映射规则 &lt;url-pattern&gt; 优先级 高 → 低 说明 /XXX/XX 精确匹配 /* 任意路径 *.do 任意扩展名 4 &lt;dispatcher&gt; 值 过滤 REQUEST （默认） 直接请求，重定向请求 FORWARD 转发请求 INCLUDE 包含请求 ERROR 声明式异常处理请求 1.4 Filter 生命周期 阶段 方法 执行时机 执行次数 1 实例化 构造函数 启动服务器时 执行一次 2 初始化 init() 启动服务器时 执行一次 3 过滤 doFilter() 过滤请求时 每次过滤都执行，且在请求处理前后各执行一次 4 销毁 destroy() 关闭服务器时 执行一次 1.5 Filter 执行流程 请求 正序执行过滤器链中各个过滤器放行前的代码 处理请求 倒叙执行过滤器链中各个过滤器放行后的代码 响应 二 监听器 Listener2.1 概述 监听器用于监听 WEB 程序中的事件 域对象 HttpRequest HttpSession ServletContext 的创建，属性变化，销毁 Session 域中对象的绑定 Session 的钝化活化 监听器基于观察者设计模式 2.2 事件监听机制 概念 说明 事件源 监听的对象 事件 监听的事件 监听器 监听器 注册监听 将事件源、事件、监听器绑定，当事件源上发生某个事件时，执行监听器代码 2.3 注册监听器1 XML 方式 web.xml123&lt;listener&gt; &lt;listener-class&gt;&lt;/listener-class&gt;&lt;/listener&gt; 2 注解 @WebListener12@WebListener// 在监听器类上添加此注解即可 2.4 常见监听器1 监听域对象的创建与销毁1 ServletRequestListener 修饰 方法 说明 void requestInitialized(ServletRequestEvent event) 监听 ServletRequest 域的创建 void requestDestroyed(ServletRequestEvent event) 监听 ServletRequest 域的销毁 2 HttpSessionListener 修饰 方法 说明 void sessionCreated(HttpSessionEvent event) 监听 HttpSession 域的创建 void sessionDestroyed(HttpSessionEvent event) 监听 HttpSession 域的销毁 3 ServletContextListener 修饰 方法 说明 void contextInitialized(ServletContextEvent event) 监听 ServletContext 域的创建 void contextDestroyed(ServletContextEvent event) 监听 ServletContext 域的销毁 2 监听域对象的属性变化1 ServletRequestAttributeListener 修饰 方法 说明 void attributeAdded(ServletRequestAttributeEvent event) 监听 ServletRequest 域中属性的添加 void attributeRemoved(ServletRequestAttributeEvent event) 监听 ServletRequest 域中属性的删除 void attributeReplaced(ServletRequestAttributeEvent event) 监听 ServletRequest 域中属性的修改 2 HttpSessionAttributeListener 修饰 方法 说明 void attributeAdded(HttpSessionBindingEvent event) 监听 HttpSession 域中属性的添加 void attributeRemoved(HttpSessionBindingEvent event) 监听 HttpSession 域中属性的删除 void attributeReplaced(HttpSessionBindingEvent event) 监听 HttpSession域中属性的修改 3 ServletContextAttributeListener 修饰 方法 说明 void attributeAdded(ServletContextAttributeEvent event) 监听 ServletContext 域中属性的添加 void attributeRemoved(ServletContextAttributeEvent event) 监听 ServletContext 域中属性的删除 void attributeReplaced(ServletContextAttributeEvent event) 监听 ServletContext 域中属性的修改 3 监听 HttpSession 域中的对象1 概述 此类监听器不用注册 要用被监听对象实现此类监听器 2 HttpSessionBindingListener 修饰 方法 说明 void valueBound(HttpSessionBindingEvent event) 对象绑定到 HttpSession 域中时触发 void valueUnBound(HttpSessionBindingEvent event) 对象从 HttpSession 域中解绑时触发 3 HttpSessionActivationListener 修饰 方法 说明 void sessionDidActivate(HttpSessionEvetn event) 监听 HttpSession 的钝化 void sessionWillPassivate(HttpSessionEvetn event) 监听 HttpSession 的活化","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"JavaWeb","slug":"CS/JavaWeb","permalink":"https://anyeansan.github.io/categories/CS/JavaWeb/"}],"tags":[]},{"title":"文件上传和下载","slug":"JavaWeb/文件上传和下载","date":"2020-11-08T12:52:23.000Z","updated":"2020-11-08T12:54:33.642Z","comments":true,"path":"2020/11/08/JavaWeb/文件上传和下载/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/JavaWeb/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/","excerpt":"","text":"一 上传1.1 文件上传前提123&lt;form method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"\"&gt;&lt;/form&gt; form 表单，包含文本域 &lt;input type=&quot;file&quot;&gt; method = post enctype = multipart/form-data 1.2 文件上传原理 enctype=multipart/form-data 时，使用 request.getParameter(key)取不到表单数据 通过流解析请求体，获取上传文件 1.3 Apache Commons Fileupload1 API 类/接口 说明 DiskFileItemFactory 工厂类，用来创建 ServletFileUpload ServletFileUpload 解析器对象 FileItem 对应一个表单项，分为普通字段和文件字段 1 DiskFileItemFactory1 构造 构造函数 说明 DiskFileItemFactory() 创建工厂类 DiskFileItemFactory(int sizeThreshold, File repository) 创建工厂类，并指定缓存文件的大小和临时文件的位置 2 方法 修饰 方法 说明 void setSizeThreshold(int sizeThreshold) 设置缓存文件的大小 void setRepository((File repository)) 设置临时文件位置 2 ServletFileUpload1 构造 构造函数 说明 ServletFileUpload() 创建解析器 ServletFileUpload(FileItemFactory factory) 根据工厂创建解析器 2 方法 修饰 方法 说明 boolean isMultipartContent(HttpServletRequest request) 判断请求是否包含上传 List&lt;FileItem&gt; parseRequest(HttpServletRequest request) 解析请求 void setFileSizeMax(long fileSizeMax) 单个上传文件大小最大值 void setSizeMax(long sizeMax) 多上传文件总大小最大值 3 FileItem 修饰 方法 说明 boolean isFormField() 判断是否是普通表单项，false ：表示是文件字段 String getFieldName() 获取字段名 String getName() 获取文件名 String getContentType() 获取文件的 MIME 类型 String getString([String encoding]) 普通字段：返回 value，文件字段：返回内容 int getSize() 获取文件大小 void write(File file) 保存上传文件到指定文件 InputStream getInputStream() 获取上传文件对应的字节输入流 OutputStream getOutputStream() 获取上传文件对应的字节输出流 void delete() 清理临时文件 2 使用12345678910// 1. 创建工厂类 DiskFileItemFactoryDiskFileItemFactory factory = new DiskFileItemFactory()// 2. 根据工厂创建解析器 ServletFileUpload ServletFileUpload fileUpload = new ServletFileUpload(factory)// 3. 解析请求List&lt;FileItem&gt; list = fileUpload.parseRequest(request)// 4. 获取文件名和文件内容。。。，保存文件 3 文件上传注意事项 上传的文件名是全路径，有的浏览器会自动处理，有的不会，最好处理一下 存储的文件名唯一，避免文件被覆盖 多目录，避免同一目录文件过多 限制文件的大小：web 方式不适合上传大的文件 临时文件 DiskFileItemFactory 内部有一个默认 10KB 的缓存，如果上传文件超过缓存大小，会用磁盘作为缓存 存放缓存文件的目录即临时文件目录 如果自己用 IO 流实现的文件上传，要在流关闭后，清理临时文件 1.4 Apache Commons IO1 FilenameUtils2 IOUtils 修饰 方法 说明 int copy(InputStream in, OutputStream out, [int bufferSize]) 从字节输入流向字节输出流拷贝 int copy(Reader in, writer out) 从字符输入流向字符输出流拷贝 void copy(InputStream in, Writer out, String inEncoding) 从字节输入流向字符输出流拷贝 void copy(Reader in, OutputStream out, String outEncoding) 从字符输入流向字节输出流拷贝 二 下载2.1 原理 Content-disposition 响应头，服务器告诉客户端以什么格式打开响应体数据 in-line：默认值，在当前页面内打开 attachment;filename=：以附件形式打开响应体（文件下载） 2.2 文件下载步骤 发送请求，包含要下载的文件名 获取文件在服务器的真实路径 根据文件路径创建输入流 设置响应头 下载文件 1response.setHeader(&quot;content-disposition&quot;, &quot;attachment;filename=&quot;+fileName) 文件类型 1234// 1 手动设置类型response.setHeader(&quot;content-type&quot;, &quot;image/jpeg&quot;);// 2 根据文件名获取类型response.setContentType(this.getServletContext().getMimeType(fileName)) 获取响应输出流，不断读写 2.3 下载文件名中文问题123456789101112131415161718// agent就是请求头 User-Agent 的值public class DownLoadUtils &#123; public static String getFileName(String agent, String filename) throws UnsupportedEncodingException &#123; if (agent.contains(&quot;MSIE&quot;)) &#123; // IE浏览器 filename = URLEncoder.encode(filename, &quot;utf-8&quot;); filename = filename.replace(&quot;+&quot;, &quot; &quot;); &#125; else if (agent.contains(&quot;Firefox&quot;)) &#123; // 火狐浏览器 BASE64Encoder base64Encoder = new BASE64Encoder(); filename = &quot;=?utf-8?B?&quot; + base64Encoder.encode(filename.getBytes(&quot;utf-8&quot;)) + &quot;?=&quot;; &#125; else &#123; // 其它浏览器 filename = URLEncoder.encode(filename, &quot;utf-8&quot;); &#125; return filename; &#125;&#125;","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"JavaWeb","slug":"CS/JavaWeb","permalink":"https://anyeansan.github.io/categories/CS/JavaWeb/"}],"tags":[]},{"title":"会话","slug":"JavaWeb/会话","date":"2020-11-08T12:52:10.000Z","updated":"2020-11-08T12:54:27.405Z","comments":true,"path":"2020/11/08/JavaWeb/会话/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/JavaWeb/%E4%BC%9A%E8%AF%9D/","excerpt":"","text":"一 概述 打开浏览器，不管是多标签，还是多窗口，直到全部关闭，是一次会话 本质上：从 Session 对象的创建到最终 Session 的销毁，才是真正意义上的一次完整会话 保存会话数据有两种技术： Cookie Session 二 Cookie2.1 概述 Cookie 基于响应头 set-cookie 和请求头 cookie 实现 Cookie 是由服务器创建，响应给客户端的（一次可响应多个） 可以保存在浏览器缓存中（默认），浏览器关闭则 Cookie 消失 可以保存在客户端硬盘中（设置有效时间），浏览器关闭 Cookie 还在，直到失效 Cookie 只能存储字符串 Cookie 是与请求路径绑定的，只有有效路径的请求才会携带 Cookie，默认有效路径为创建 Cookie 那个请求路径的父路径 流程 12345678// 1. 在服务端创建 CookieCookie cookie=new Cookie(String name,String value)// 2. 设置有效时间cookie.setMaxAge(3600)// 3. 响应给客户端，可响应多个 Cookieresponse.addCookie(cookie)// 4. 再次请求时获取 CookieCookie[] cs=request.getCookies() 第一次请求时，服务器创建 Cookie，然后响应给客户端，并保存在客户端 之后的请求会携带 Cookie，服务器可以获取 Cookie 信息 2.2 javax.servlet.http.Cookie1 构造 构造 说明 Cookie(String name, String value) 创建 Cookie，指定键值 2 方法 修饰 方法 说明 String getName() 获取 Cookie 的键 String getValue() 获取 Cookie 的值 void setValue(String newVal) 修改 Cookie 的值 void setPath(String url) 设置 Cookie 有效路径，只有以此路径开头的请求才可以携带 String getPath() 获取 Cookie 有效路径 void setMaxAge(int second) 设置有效时间（默认会话结束则消失），正表示有效时间，负表示不保存，0 表示删除 void setDomain(String domain) 设置 Cookie 一级域名 String getDomain() 获取 Cookie 一级域名 2.3 Cookie 存中文 Tomcat 8 之前，不可以，需要 URL 编码 Tomcat 8 之后，键可以，但特殊字符不支持，还是建议 URL 编码 URL 编码：使用 URLEncoder 的 encode() 和 decode() 方法 2.4 Cookie 共享 同一个服务器下的多个项目 Cookie 默认 path 是创建时的项目的虚拟路径，所以其它项目是访问不到的 通过 setPath(&quot;/&quot;) 实现共享 不同服务器的共享 setDomain(String path) 如果设置一级域名相同，那么多个服务器间的 Cookie 可以共享 setDomain(&quot;.baidu.com&quot;) 则 tieba.baidu.com和 news.baidu.com…之间就可以共享 三 Session3.1 原理 第一次请求服务器时，服务器创建 HttpSession 对象，并创建一个特殊的 Cookie，此特殊 Cookie： 键： JSessionID 值： Session 的 id 将 Cookie 响应到客户端 再次请求时携带此 Cookie，服务器就可以获取 Session 的 id 服务器中维护了一个 Session 列表，根据获取的 Session 的 id 就可以获取对应的 HttpSession 对象 3.2 javax.servlet.http.HttpSession 修饰 方法 说明 String getId() 获取 Session 的 id void setMaxInactiveInterval(int second) 设置 Session 有效期，默认 30 分钟 int getMaxInactiveInterval() 获取 Session 有效时间 void invalidate 销毁 Session 3.3 Session 的创建/获取12345// 若存在则获取，不存在则创建HttpSession session = request.getSession()HttpSession session = request.getSession(true)// 若存在则获取，不存在则返回 nullHttpSession session = request.getSession(false) 3.4 Session 的有效期 虽然 Session 默认有效期为 30 分钟，但 Session 依赖于 Cookie，而 Cookie 默认是会话级别的，所以 Session 默认也是会话级别 设置 Session 的有效期，需要同时设置 Cookie 和 Session 3.5 Session 的销毁 服务器关闭 调用invalidate() Tomcat 的 /conf/web.xml 中的配置 &lt;session-config&gt;，默认是 30 分钟，可修改 3.6 Session 的钝化和活化 当服务器关闭再开启时，由于对象的地址是随机性的，可能导致两次的 Session 不一致，通过 Session 的钝化和活化可以解决此问题 钝化 将 Session 对象和对象中的数据从内存序列化到硬盘的过程 钝化时机：服务器关闭 活化 将 Session 对象和对象中的数据从硬盘反序列化到内存的过程 活化时机：服务器重启 Tomcat DOS 命令下，正常关闭 Tomcat ，会自动钝化 Session，在 work 目录下生成 SESSIONS.ser 文件，再次启动，会活化 IDEA 中，正常关闭 Tomcat ，也会钝化，但由于 IDEA 采用虚拟目录方式部署应用，重启 Tomcat 时，IDEA会先删除虚拟目录中的 work 目录，即钝化文件被删除了，也就无法活化了","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"JavaWeb","slug":"CS/JavaWeb","permalink":"https://anyeansan.github.io/categories/CS/JavaWeb/"}],"tags":[]},{"title":"JSP","slug":"JavaWeb/JSP","date":"2020-11-08T12:52:02.000Z","updated":"2020-11-08T12:54:43.521Z","comments":true,"path":"2020/11/08/JavaWeb/JSP/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/JavaWeb/JSP/","excerpt":"","text":"一 概述 Java Server Pages Jsp 本质是 Servlet .jsp 翻译成的 .java 文件继承了 HttpJspBase HttpJspBase 继承了 HttpServlet 二 执行过程 第一次访问会把 .jsp 先翻译成 .java 文件 .java编译成.class文件 此后访问直接只需 .class 文件 如果 .jsp 发生变化，则视为第一次访问，从头开始 三 语法3.1 注释 注释 说明 &lt;!-- --&gt; 不能注释脚本，会被写到最终页面 &lt;%-- --%&gt; 可以注释脚本，不会被写到最终页面 3.2 脚本 语法 名称 最终位置 页面内容（HTML, CSS, JS, 文本…） service() 方法中： out.write(&quot;翻译到这里&quot;) &lt;% %&gt; 脚本 service() 方法中 &lt;%= %&gt; 表达式 service() 方法中： out.write(&quot;翻译到这里&quot;) &lt;%! %&gt; 声明 .java 文件下成员位置 3.3 指令1 语法1&lt;%@指令名 属性1=\"值\" 属性2=\"值\"... %&gt; jsp 指令不直接产生任何可见输出，而只告诉 jsp 引擎如何处理 jsp 页面中的内容。 页面中可出现多次 2 分类 指令 说明 page 用于定义 jsp 页面的各种属性 taglib 在 JSP 页面中导入标签库 include 静态包含 1 page 属性 作用 说明 import 导包 jsp 默认导入的包：java.lang.*，javax.servlet.*，javax.servlet.http.*，javax.servlet.jsp.* language 语言 默认 java pageEncoding 设置响应编码方式 告诉服务器用什么编码把 .jsp 翻译成 .java 文件 contentType 设置响应内容，同时可以设置响应编码方式 等价于response.setContentType(&quot;text/html;charset=utf-8&quot;);，如果不设置则使用 pageEncoding 的编码 session 当前页面是否启用 session 默认 true buffer 输出数据的缓存大小(out 的缓冲区) 默认 8KB errorPage 配置错误页面 jsp 页面出现错误跳转的页面 isErrorPage 是否是错误页面，即是否可以使用内置对象 exception 默认 false isELIgnored 是否忽略 EL 表达式 默认 false 2 taglib1&lt;%@ taglib uri=&quot;库地址&quot; prefix=&quot;页面使用库所用的前缀&quot; %&gt; 3 include1&lt;%@ include file=&quot;&quot; %&gt; 静态包含，被包含文件可以是任意网络资源 先合并成一个文件，再翻译，所以被包含的文件不会单独翻译和编译 3.4 jsp 编码问题1 jsp 编解码过程 .jsp的存储编码，pageEncoding 要与此编码一致否则翻译就会乱码 .jsp → .java 使用 pageEncoding 指定的编码 .java→ .class jvm 使用 utf-8 编译，不可修改 浏览器解析 使用的是 contentType 指定的编码 2 解决乱码 想要不乱码，保证以下三码一致即可 .jsp的存储编码 pageEncoding的编码 contentType的编码 由于 contentType 不设置会使用 pageEncoding 的编码，所以保证 .jsp的存储编码和 pageEncoding 的编码一致即可 ide 通常设置为 utf-8，即存储编码为 utf-8，所以只需设置 pageEncoding=&quot;utf-8&quot; 即可 3.5 动作 动作 语法 说明 动态包含 &lt;jsp:include page=&quot;&quot;&gt; 不会合并文件，当执行到时，才包含另一个文件的内容；被包含文件也会被翻译和编译 转发 &lt;jsp:forward page=&quot;path&quot;/&gt; 相当于 req.getRequestDispatcher(path).forward(req,res); 请求参数 &lt;jsp:param name=&quot;&quot; value=&quot;&quot; /&gt; 相当于 url?name=value 创建对象 &lt;jsp:useBean id=&quot;p&quot; class=&quot;a.Person&quot;&gt; 相当于 a.Person p = new a.Person() 为对象属性赋值 &lt;jsp:setProperty property=&quot;age&quot; name=&quot;p&quot; value=&quot;8&quot;/&gt; 相当于 p.setAge(8) 获取对象属性值 &lt;jsp:getProperty property=&quot;age&quot; name=&quot;p&quot;/&gt; 相当于 p.getAge() 四 内置对象4.1 概述 对象名 类型 说明 request javax.servlet.http.HttpServletRequest 请求对象 response javax.servlet.http.HttpServletResponse 响应对象 session javax.servlet.http.HttpSession 会话对象 application javax.servlet.ServletContext ServletContext 对象 pageContext javax.servlet.jsp.PageContext PageContext 对象 exception java.lang.Throwable 页面异常对象 page java.lang.Object 当前 servlet 实例，即 this config javax.servlet.ServletConfig ServletConfig 对象 out javax.servlet.jsp.JspWriter 字符输出流 内置对象即 service() 方法中的局部变量，在 &lt;%= %&gt; 和 &lt;% %&gt; 中可以直接使用 4.2 out123456/** 1. tomcat 会先从 response 中获取数据，然后才从 out 中获取数据* 2. 所以无论何时，总是 response 先输出*/out.write()response.getWriter().write() 4.3 pageContext1 获取其它内置对象 修饰 方法 说明 ServletRequest getRequest() 获取 request ServletResponse getResponse() 获取 response ServletContext getServletContext() 获取 application ServletConfig getServletConfig() 获取 config HttpSession getSession() 获取 session Object getPage() 获取 page Exception getException 获取 exception 2 域对象 修饰 方法 说明 void setAttribute(String name, Object value) 向 page 域中设置键值对 Object getAttribute(String name) 根据键获取page域中键值对的值 void removeAttribute(String name) 根据键移除page域中键值对 3 操作其它域对象 修饰 方法 说明 void setAttribute(String name, Object value, int scope) 向指定域中设置键值对 Object getAttribute(String name, int scope) 根据键获取指定域中键值对的值 void removeAttribute(String name, int scope) 根据键移除指定域中键值对 Object findAttribute(String name) 按照 page request session application 的顺序查找 scope 说明 PageContext.PAGE_SCOPE page 域 PageContext.REQUEST_SCOPE request 域 PageContext.SESSION_SCOPE response 域 PageContext.APPLICATION_SCOPE application 域 4 转发 &amp; 包含 修饰 方法 说明 void forward(String relativeUrlPath) 转发 void include(String relativeUrlPath, [boolean flush]) 动态包含 五 EL 表达式5.1 概述 expression language EL 是 jsp 的内置表达式语言，可用于获取域中的值，简单的运算或判断操作 EL 表达式只能从域中获取数据，且只能读不能写 EL 获取的值若为 null 会显示为 &quot;&quot; EL 用于代替 jsp 表达式 &lt;%= %&gt; EL 会自动作类型转换 语法：${表达式} 5.2 语法1 运算 运算符 说明 算术运算符 + - * /(div) %(mod) 比较运算符 &gt; &lt; &gt;= &lt;= == != 逻辑运算符 && || ! 空运算符 empty，null &quot;&quot; 空集合 这三种情况为 true 三元运算符 ${empty key?&quot;为空&quot;:&quot;不为空&quot;} 2 获取域中数据 语法 说明 ${key} 相当于 pageContext.findAttribute()，从四个域中依次查找 ${scope.key} 从指定域中查找 5.3 EL 中的隐式对象 隐式对象 类型 对应 jsp 内置对象 说明 pageContext javax.servlet.jsp.PageContex pageContext 二者一样 pageScope java.util.Map&lt;String,Object&gt; 无 page 域 requestScope java.util.Map&lt;String,Object&gt; 无 request 域 sessionScope java.util.Map&lt;String,Object&gt; 无 session 域 applicationScope java.util.Map&lt;String,Object&gt; 无 application 域 param java.util.Map&lt;String,String&gt; 无 请求参数 paramValues java.util.Map&lt;String,String[]&gt; 无 请求参数有多个值 header java.util.Map&lt;String,String&gt; 无 请求消息头 headerValues java.util.Map&lt;String,String[] 无 请求消息头有多个值 initParam java.util.Map&lt;String,String&gt; 无 初始化参数 cookie java.util.Map&lt;String,Cookie&gt; 无 cookie 六 JSTL6.1 概述 JavaServerPages Standard Tag Library JSP 标准标签库，由五个库组成，用于替代 jsp 脚本 EL 用于简化数据获取方面的 java 代码，而 JSTL 用于简化逻辑方面的 java 代码 6.2 组成 功能 URI 前缀 核心 Core http://java.sun.com/jsp/jstl/core c 格式化 I18N http://java.sun.com/jsp/jstl/fmt fmt 函数 Function http://java.sun.com/jsp/jstl/functions fn 数据库 SQL http://java.sun.com/jsp/jstl/sql sql XML http://java.sun.com/jsp/jstl/xml x 6.3 使用 JSTL 导包 12taglibs-standard-spec-1.2.5.jar (规范包)taglibs-standard-impl-1.2.5.jar（实现包） 引入 JSTL 核心库 1&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;自定义&quot; %&gt; 6.4 标签1 通用标签1 set1&lt;c:set var=&quot;num&quot; value=&quot;10&quot; scope=&quot;session&quot; /&gt; 声明变量并赋值，存入指定域中 相当于 setAttribute(String name, Object value, int scope) 2 out1&lt;c:out value=&quot;$&#123;num&#125;&quot; scope=&quot;session&quot;/&gt; 从指定域中获取值，value要使用 EL 相当于 getAttribute(String name, int scope) 可以直接使用 EL 代替 out 标签 3 remove1&lt;c:remove var=&quot;num&quot; scope=&quot;session&quot;/&gt; 从指定域中删除 相当于 removeAttribute(String name, int Scopte) 2 条件标签1 if1&lt;c:if test=&quot;&quot;&gt;&lt;/c:if&gt; 2 choose123456&lt;c:choose&gt; &lt;c:when test=&quot;&quot;&gt;&lt;/c:when&gt; &lt;c:when test=&quot;&quot;&gt;&lt;/c:when&gt; ... &lt;c:otherwise&gt;&lt;/c:otherwise&gt;&lt;/c:choose&gt; 3 迭代标签 forEach1 普通循环1&lt;c:forEach var=&quot;&quot; begin=&quot;&quot; end=&quot;&quot; step=&quot;&quot; varStatus=&quot;vs&quot;&gt;&lt;/c:forEach&gt; 2 增强循环1&lt;c:forEach items=&quot;&quot; var=&quot;&quot; varStatus=&quot;vs&quot;&gt;&lt;/c:forEach&gt; 3 varStatus 指向一个对象，此对象记录着当前遍历元素的信息 通过 EL 可以获取当前遍历元素的信息 语法 说明 ${vs.index} 获取当前元素索引，索引从 0 开始 ${vs.count} 获取当前元素是第几个，计数从 1 开始 ${vs.current} 获取当前元素 ${vs.first} 判断当前元素是否是第一个 ${vs.last} 判断当前元素是否是最后一个 七 域对象 域 对象 生命周期 page PageContext 当前页面 request ServletRequest 一次请求 session HttpSession 一次会话 application ServletContext 整个应用","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"JavaWeb","slug":"CS/JavaWeb","permalink":"https://anyeansan.github.io/categories/CS/JavaWeb/"}],"tags":[]},{"title":"Servlet","slug":"JavaWeb/Servlet","date":"2020-11-08T12:51:55.000Z","updated":"2020-11-08T12:54:50.024Z","comments":true,"path":"2020/11/08/JavaWeb/Servlet/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/JavaWeb/Servlet/","excerpt":"","text":"一 概述1.1 JavaEE Java 企业版 SUN 公司提供的一套庞大类库，用于企业级开发，可以认为是平台或者规范 13 种技术规范 Servlet JSP：Java Server Pages JDBC：Java Data Base Connectivity XML：Extensible Markup Language JNDI：Java Naming and Directory Interfaces EJB：Enterprise Java Beans RMI：Remote Method Invocation Java IDL/CORBA：Java Interface Definiyion Language/Common Object Request Broker Architecture JMS：Java Message Service JTA：Java Transaction API JTS：Java Transaction Service JavaMail JAF：JavaBeans Activation Framework 1.2 MVC MVC 是一种概念 Model &quot;什么&quot; 数据模型 View &quot;怎么显示什么 显示数据 Controller &quot;怎么操作什么&quot; 处理数据 三层架构是一种应用 表现层 业务层 持久层 1.3 Servlet Server Applet，用 java 编写的运行在服务端的小程序，作为 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层 Servlet 必须运行在 Servlet 容器中（如 Tomcat…） Servlet 对象是单例的（但不符合单例模式，单例模式构造方法是私有的），Tomcat 服务器支持多线程，所以 Servlet 是在单实例多线程的环境下运行的，如果 Servlet 中有实例变量，会存在线程安全问题，所以不建议使用实例变量 所有 Servlet 都要直接或间接实现 javax.servlet.Servlet 接口，所以 Servlet 本质就是一种规范，所有实现 Servlet 的类，或者说，所有想要处理网络请求的类，都需要回答这三个问题： 你初始化时要做什么 你销毁时要做什么 你接受到请求时要做什么 Web 服务器和 Servlet 容器 Web 服务器的作用说穿了就是：将某个主机上的资源映射为一个URL供外界访问 通过 URL 访问 Web 服务器资源，通常有三个过程 接收请求 处理请求 响应请求 其中接收请求和响应请求是共性功能，可以抽取由 Web 服务器完成，而处理请求的逻辑各不相同，抽取出来做成Servlet，交给程序员自己编写 Servlet 容器：顾名思义即用来存放 Servlet 对象 所以 Servlet 并不会直接和客户端打交道，而是由 Tomcat 监听端口，接收请求，然后根据 URL 等信息决定交给哪个 Servlet 处理，之后再由 Tomcat 响应请求 二 配置2.1 映射规则 优先级（高 →低） 说明 /xxx/xx/x 绝对匹配 /* 所有 *.do 指定扩展名 / 除了 .jsp 之外的 / 和 /*1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 上述为 tomcat 的 web.xml 中的配置，可以看到服务器中的所有资源（包括静态）都会经过 Servlet .jsp 外的资源有匹配则走匹配，没有匹配的 Servlet 则会走默认的 DefaultServlet .jsp 会走 JspServlet 如果自定义 Servlet 的映射设置为 /，会覆盖默认设置，则结果是 .jsp 外的资源有匹配则走匹配，没有匹配的 Servlet 则会走此自定义 Servlet .jsp 会走 JspServlet 如果自定义 servlet 的映射设置为 /*，由于 /* 优先级高于 *.jsp 和 /，则结果是 所有资源如果没有匹配的 Servlet 则都会走此自定义 Servlet 3.2 xml 配置：web.xml123456789&lt;servlet&gt; &lt;servlet-name&gt;&lt;/servlet-name&gt; &lt;servlet-class&gt;&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;&lt;/servlet-name&gt; &lt;!-- &lt;url-pattern&gt; 可以写多个 --&gt; &lt;url-pattern&gt;&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3.3 注解配置：@WebServlet @WebServlet 注解用在类或接口上，仅在运行阶段生效 属性 说明 等价于 String name() default &quot;&quot; servlet 名称 &lt;Servlet-name&gt; String[] urlPatterns() default {} 映射 url &lt;url-pattern&gt; String[] value() default {} 同 urlPatterns() &lt;url-pattern&gt; int loadOnStartup() default -1 实例化顺序 &lt;load-on-startup&gt; WebInitParam[] initParams() default {} 初始化参数 &lt;init-param&gt; 12345678@WebServlet(name=\"\", urlPatterns=&#123;\"\", \"\", ...&#125;)/*1. 由于注解直接作用在类上，所以可以省略 name2. value 等价于 urlPatterns，所以可以使用 value 代替 3. 注解中只有一个属性且为 value 时可以省略属性名4. 最终简化版*/@WebServlet(\"\", \"\", ...) 三 体系 每个 Servlet 都对应一个 ServletConfig 所有 Servlet 共享一个 ServletContext 3.1 Servlet1 API 修饰 方法 说明 void init(ServletConfig config) 初始化 void destroy() 销毁 void service(ServletRequest req, ServletResponse res) 处理请求 ServletConfig getServletConfig() 获取 ServletConfig（每个 Servlet 对应一个 ） String getServletInfo() 获取 servlet 信息，如作者，版本，版权… 2 生命周期 阶段 方法 执行时机 执行次数 1 实例化 构造函数 默认第一接收请求时 只执行一次 2 初始化 init(ServletConfig config) 默认第一接收请求时 只执行一次 3 处理请求 service(ServletRequest req, ServletResponse res) 接收请求时 每次请求都会执行 4 销毁 destroy() 关闭服务器 只执行一次 Servlet 的生命周期，包括其相关方法的调用，都是由 Web 容器来管理的，程序员无权干涉 配置 web.xml 或注解实现服务器一启动就实例化 servlet 1234&lt;servlet&gt; &lt;!-- Num &gt; 0，web 容器启动时实例化顺序是由小到大 --&gt; &lt;load-on-startup&gt;Num&lt;/load-on-startup&gt;&lt;/servlet&gt; 3.2 ServletConfig1 API 修饰 方法 说明 ServletContext getServletContext() 获取 ServletContext（所有 Servlet 共享一个） String getInitParameter(String name) 获取 Servlet 初始化配置中指定键的值 Enumeration&lt;String&gt; getInitParameterNames() 获取 Servlet 初始化配置所有键的枚举 String getServletName() 获取 Servlet 的名称 2 初始化配置1 web.xml 中123456&lt;servelt&gt; &lt;init-param&gt; &lt;param-name&gt;&lt;/param-name&gt; &lt;param-value&gt;&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servelt&gt; 2 注解中3.3 GenericServlet 修饰 方法 说明 void init(ServletConfig config) 重写 Servlet 的 初始化方法，内部调用了 init() void init() 特有方法，内容为空，可自定义一些初始化内容 3.4 HttpServlet 修饰 方法 说明 void service(ServletRequest req, ServletResponse res) 重写 Servlet 的方法 protected void service(HttpServletRequest req, HttpServletResponse resp) 特有方法 protected void doXxx(HttpServletRequest req, HttpServletResponse resp) 处理 GET POST PUT DELETE ... 1234567891011121314151617181920/** 1 重写的 service() 方法，内部判断是否是 HTTP 请求，不是则抛异常，是则强转后调用特有的 service() 方法* 2 特有的 service() 方法，内部根据请求方法的类型，调用对应的 doXxx() 方法* 3 所以继承 HtttpServlet 的 Servlet 只需要重写 doXxx() 方法即可（模板方法设计模式）*/@Overridepublic void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; HttpServletRequest request; HttpServletResponse response; try &#123; request = (HttpServletRequest) req; response = (HttpServletResponse) res; &#125; catch (ClassCastException e) &#123; throw new ServletException(lStrings.getString(\"http.non_http\")); &#125; service(request, response);&#125; 3.5 ServletContext1 API1 获取 修饰 方法 说明 String getInitParameter(String name) 获取全局配置中指定键的值 Enumeration&lt;String&gt; getInitParameterNames() 获取全局配置所有键的枚举 String getRealPath(String path) 获取资源的绝对路径，path 要以 / 开头 RequestDispatcher getRequestDispatcher(String path) 获取 RequestDispatcher，path 为要转发到的请求路径 String getMimeType(String file) 获取文件的 MIME 类型 2 域对象 修饰 方法 说明 Object getAttribute(String name) 获取 ServletContext 域中指定键的值 void setAttribute(String name, Object obj) 添加或修改 ServletContext 域中指定键的键值对 void removeAttribute(String name) 移除 ServletContext 域中指定键的键值对 2 全局配置：web.xml 中1234&lt;context-param&gt; &lt;param-name&gt;&lt;/param-name&gt; &lt;param-value&gt;&lt;/param-value&gt;&lt;/context-param&gt; 3.6 RequestDispatcher 修饰 方法 说明 void forward(ServletRequest req, ServletResponse res) 请求转发 void include(ServletRequest req, ServletResponse res) 请求包含 3.7 HttpServletRequest1 请求信息1 请求行 修饰 方法 说明 String getContextPath() 获取 webapp 根路径，ROOT 为 &quot;&quot; String getServletPath() 获取 Servlet 路径，&lt;url-pattern&gt; 配置的路径 String getMethod() 获取请求方法名 StringBuffer getRequestURL() 获取请求 URL String getRequestURI() 获取请求 URI String getQueryString() 获取请求 URL 中的请求参数 String getProtocol() 获取协议 String getRemoteAddr() 获取请求客户端的 IP 2 请求头 修饰 方法 说明 String getHeader(String name) 获取请求头中指定键的值 Enumeration&lt;String&gt; getHeaderNames() 获取请求头所有键的枚举 3 请求体 修饰 方法 说明 BufferedReader getReader() 获取字符输入流 ServletInputStream getInputStream() 获取字节输入流 2 请求参数 修饰 方法 说明 String getParameter(String name) 获取请求参数中指定键的值 String[] getParameterValues(String name) 获取请求参数中指定键的值的数组 Map&lt;String,String[]&gt; getParameterMap() 获取请求参数的所有键值map Enumeration&lt;String&gt; getParameterNames() 获取请求参数所有键的枚举 void setCharacterEncoding(String env) 获取请求参数前进行设置，告诉服务器用什么编码接收请求参数（只对 POST 有效） * 请求参数乱码问题 不管哪个国家的文字，在浏览器发给服务器时，都采用 ISO-8859-1 编码，Tomcat 服务器默认编码和解码为 iso-8859-1，可通过 CATALINA_HOME/conf/server.xml 修改 客户端编码为 &lt;meta charset=&quot;UTF-8&quot;&gt; ，默认解码为 GBK 解决请求乱码 POST 12// 在获取参数前，设置解码与客户端编码一致即可 request.setCharacterEncoding(\"UTF-8\") GET 和 POST 123456// 1.1 获取请求参数，获取的是由服务器默认 `iso-8859-1` 解码的参数String name = request.getParameter(\"name\");// 1.2 使用 `iso-8859-1` 编码，获取原始数据byte[] bytes = name.getBytes(\"iso-8859-1\");// 1.3 使用与客户端编码（假如是 utf-8）一致的码表解码即可name = new String(bytes, \"utf-8\"); GET 12&lt;!-- 修改 tomcat 的 server.xml 配置 --&gt; &lt;Connector URIEncoding=\"UTF-8\"&gt; 3 获取 修饰 方法 说明 RequestDispatcher getRequestDispatcher(String path) 获取 RequestDispatcher，path 为要转发到的请求路径 ServletContext getServletContext() 获取 ServletContext Cookie[] getCookies() 获取 Cookie HttpSession getSession() 获取或创建 Session 4 域对象 修饰 方法 说明 Object getAttribute(String name) 获取 request 域中指定键的值 void setAttribute(String name, Object obj) 添加或修改 request 域中指定键的键值对 void removeAttribute(String name) 移除 request 域中指定键的键值对 3.8 HttpServletResponse1 响应信息 修饰 方法 说明 void setStatus(int sc) 设置响应状态码 void setHeader(String name, String value) 设置响应头 `void setChracterEncoding(String charset) 设置响应数据编码 void setContentType(String type) 设置响应数据 MIME 类型及编码 PrintWriter getWriter() 获取字符输出流 ServletOutputStream getOutputStream() 获取字节输出流 * 响应乱码 响应乱码原因 响应流不是我们自己创建的，而是由 tomcat 获取的，默认码表是iso-8859-1 浏览器解码的码表不确定，可能与响应数据码表不一致 解决乱码原则 设置响应数据的编码 设置浏览器解码与响应数据编码一致 编码设置 123456// 1. 设置响应数据类型及浏览编码方式response.setheader(\"content-type\",\"text/html;charset=utf-8\")// 2. 设置响应数据编码方式response.setChracterEncoding(\"utf-8\")// 3. 简化以上两步response.setContentType(\"text/html;charset=utf-8\") 2 重定向 修饰 方法 说明 void sendRedirect(String location) 重定向，location 要加项目名 123456// 1. 设置状态码，告诉客户端需要重定向response.setStatus(302)// 2. 告诉客户端重定向的地址response.setHeander(\"location\", String location)// 3. 简化以上两步response.sendRedirect(String location) 3 Cookie 修饰 方法 说明 void addCookie(Cookie cookie) 将 cookie 响应给客户端 四 转发 &amp; 重定向4.1 对比 转发 重定向 request 转发 response 重定向 一次请求 二次请求 浏览器地址栏不变 浏览器地址栏改变 只能访问当前应用下的资源 可以访问其它站点下的资源 注：重定向或者转发后，后边的代码还会执行，但通常不会写 重定向可以解决浏览器刷新问题 4.2 路径 以 / 开头的叫做绝对路径 由服务器解析，代表当前项目路径 http://localhost:8080/应用名 web.xml 中的 / 路径 转发中的 / 路径 servletContext.getRealPath(&quot;/&quot;) 由客户端解析，代表当前服务器路径 http://localhost:8080，也就是需要手动添加项目名 html 中的 / 路径 重定向中的 / 路径 &lt;form action=&quot;/&quot;&gt; 五 web.xml5.1 概述 全局配置：CATALINA_HOMT/conf/web.xml 局部配置：CATALINA_HOME/webapps/webapp/WEB-INF/web.xml 5.2 欢迎页面（首页）12345&lt;welcome-file-list&gt; &lt;welcome-file&gt;&lt;/welcome-file&gt; &lt;welcome-file&gt;&lt;/welcome-file&gt; ...&lt;/welcome-file-list&gt; 如果不配置，则使用全局配置 index.html index.htm index.jsp 欢迎页面可以有多个，前边优先级高，前边找不到则向下查找 欢迎页面不一定是 HTML，可以是任意资源 路径不需要以 / 开头 5.3 错误页面1234&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error.html&lt;/location&gt;&lt;/error-page&gt;","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"JavaWeb","slug":"CS/JavaWeb","permalink":"https://anyeansan.github.io/categories/CS/JavaWeb/"}],"tags":[]},{"title":"XML","slug":"JavaWeb/XML","date":"2020-11-08T12:51:45.000Z","updated":"2020-11-08T12:54:56.362Z","comments":true,"path":"2020/11/08/JavaWeb/XML/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/JavaWeb/XML/","excerpt":"","text":"一 概述 Extensible Markup Language 可扩展标记语言 XML 中全部是自定义标签 二 语法2.1 文档声明1&lt;?xml version=\"1.0\" encoding=\"默认iso-8859-1\" ?&gt; 2.2 规范 只有一个根元素 元素正确闭合，嵌套 元素名区分大小写，不能以数字开头 属性值必须用引号&#39;&#39;或&quot;&quot; 注释&lt;!-- --&gt; 2.3 原样输出数据1&lt;![CDATA[要输出的数据]]&gt; 三 约束3.1 概述 约束就是 xml 的书写规则 根元素是什么，可以写哪些标签，有哪些属性，顺序…. 3.2 分类1 dtd 约束 内部 dtd：将约束规则定义在 xml 文档中 外部 dtd：将约束的规则定义在外部的 dtd 文件中 本地 dtd 1&lt;!DOCTYPE 根标签名 SYSTEM \"dtd文件位置\"&gt; 网络 dtd 1&lt;!DOCTYPE 根标签名 PUBLIC \"名称空间(dtd文件名)\" \"dtd文件位置\"&gt; 2 schema 约束 引入实例名称空间， xsi 前缀 1xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" 引入名称空间 12xsi:schemaLocation=\"xsd地址\"// 如果不声明别名，使用标签格式：&lt;地址值:标签名&gt; 命名空间声明：为每一个名称空间设置别名 12341. 默认xmlns=\"...\"2. 别名xmlns:别名=\"...\" 四 解析4.1 解析方式 方式 说明 DOM 将文档加载进内存形成 DOM 树，可以增删改查，但占内存，解析速度慢 SAX 逐行读取，基于事件驱动，不占内存，解析速度快，只能往下读，不能写 4.2 解析器 解析器 说明 JAXP sun 公司提供的解析，支持 dom 和 sax PULL android 内置的解析器，sax 方式 DOM4J dom for java，民间方式，但好用，dom 方式 xpath XML 路径语言，它是一种用来确定 XML 文档中某部分位置的语言，专门用于查询 Jsoup 可以解析 html 或 xml 1 DOM4J 导入 dom4j.jar 创建解析器 1SAXReader reader = new SAXReader(); 解析 xml 获得 document 对象 1Document document = reader.read(url); 2 Jsoup 类 说明 Jsoup 工具类，可以解析 html 或 xml 文档，返回 Document 对象 Document 文档对象，继承 Element Element 元素对象，继承 Node Elements 元素集合 Node 节点对象 1 Jsoup 方法 说明 static Document parse(File file, String character) 解析 html 或 xml文件 static Document parse(String html) 解析 html 或 xml 字符串 static Document parse(Url url, int timoutMillis) 解析网络上的 html 或 xml 2 Document 方法 说明 Element getElementById(String id) 根据 id 获取元素对象 Elements getElementsByClass(String className) 根据 class 获取元素对象集合 Elements getElementsByTag(String tagName) 根据标签名获取元素对象集合 Elements getElementsByAttribute(String key) 根据属性名获取元素对象集合 Elements getElementsByAttribute(String key, String value) 根据属性名和值获取元素对象集合 3 Element 方法 说明 String attr(String key) 根据属性名获取值 String text() 获取标签体文本内容 String html() 获取标签体所有内容","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"JavaWeb","slug":"CS/JavaWeb","permalink":"https://anyeansan.github.io/categories/CS/JavaWeb/"}],"tags":[]},{"title":"服务器","slug":"JavaWeb/服务器","date":"2020-11-08T12:51:29.000Z","updated":"2020-11-08T12:53:37.734Z","comments":true,"path":"2020/11/08/JavaWeb/服务器/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/JavaWeb/%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"一 概述1.1 服务器分类 类型 作用 例 WEB 服务器 HTTP Server 解析静态资源 apache, nginx, ... 应用服务器 Application Server 解析静态资源和动态资源 tomcat, jetty, weblogic, ... 1.2 前后端分离1 Servlet Servlet 即负责业务逻辑又负责页面展示 Servlet 页面展示要多痛苦有多痛苦：通过代码将数据和 HTML 响应给客户端 2 JSP JSP 即负责业务逻辑又负责页面展示 JSP 即能写 java 代码又能使用标签，但会造成 JSP 庞大而混乱 3 Servlet + JSP Servlet 负责业务逻辑，JSP 负责页面展示 Servlet 将响应数据存在域对象中，JSP 也是 Servlet ，可以从域中获取响应数据 问题： JSP 要获取数据还是要在 &lt;% %&gt; 中写 java 代码，于是出现了 EL 表达式 用于获取数据 一些复杂的展示逻辑如循环，判断，也需要在 &lt;% %&gt; 中写 java 代码，于是出现了 JSTL 用于页面展示逻辑 最终就是 Servlet + JSP + EL + JSTL 4 Servlet + HTML + AJAX + JSON + JS Servlet 负责业务逻辑 AJAX 负责请求动态数据，通常是 JSON JS 负责 DOM，展示 HTML 1.3 动静分离 静态资源部署在 nginx 服务器上，动态资源部署在 tomcat 应用服务器上 如果请求静态资源，则直接请求 nginx 如果请求动态资源，则 nginx 利用 反向代理 将请求交给 tomcat 二 JavaWeb项目2.1 标准目录结构123456部署项目名 资源文件（html、js、css、img ...） WEB-INF classes lib web.xml 2.2 源代码目录结构1234567891011121314151617181920212223242526// 1 IDEA开发项目名 src web WEB-INF classes lib web.xml// 2 Eclipse开发项目名 src WebContent WEB-INF classes lib web.xml // 3 MyEclipse开发项目名 src WebRoot WEB-INF classes lib web.xml src 目录下的文件，编译后放在 /WEB-INF/classes 下 web/WebContent/WebRoot 就相当于标准目录结构 二 Tomcat2.1 概述 服务器接收客户端请求封装 HttpServletRequest 对象，并传递给 web 应用 web 应用处理请求 服务器将处理结果封装到 HttpServletResponse 对象，响应给客户端 2.2 Tomcat 目录结构1234567891011121314151617├── bin│ ├── startup.sh │ ├── shutdown.sh│ ├── catalina.sh # Tomcat核心管理脚本│ └── version.sh # Tomcat版本信息脚本├── conf │ ├── Catalina│ ├── context.xml│ ├── server.xml│ ├── web.xml│ └── tomcat-users.xml # Tomcat管理用户配置文件├── logs│ ├── catalina.out # 启动信息日志│ └── localhost_access_log.2020-03-25.txt # 访问日志├── lib # 存放web应用能访问的JAR包├── webapps # Web应用程序根目录└── work # 编译目录 bin 和 lib 目录可以被多个 Tomcat 实例共用 conf、logs、temp、webapps 和 work 目录每个 Tomcat 实例必须拥有自己独立的一份 2.3 Tomcat 管理1 概述 Tomcat 管理功能用于对 Tomcat 自身以及部署在 Tomcat 的应用进行管理 测试用，生产环境禁用（默认禁止） 开启管理功能需要配置管理用户 2 配置管理用户 basedir/conf/tomcat-users.xml 1234567891011&lt;tomcat-users xmlns=&quot;http://tomcat.apache.org/xml&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://tomcat.apache.org/xml tomcat-users.xsd&quot; version=&quot;1.0&quot;&gt;# 配置角色&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;role rolename=&quot;admin-gui&quot;/&gt;&lt;role rolename=&quot;host-gui&quot;/&gt;# 配置用户和密码并分配角色&lt;user username=&quot;&quot; password=&quot;&quot; roles=&quot;manager-gui,admin-gui,host-gui&quot;/&gt;&lt;/tomcat-users&gt; 3 允许访问 basedir/webapps/[host-]manager/META-INF/context.xml 12345&lt;Context antiResourceLocking=&quot;false&quot; privileged=&quot;true&quot; &gt; # allow：允许指定 ip 和 端口 &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;127\\.\\d+\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1&quot; /&gt;&lt;/Context&gt; 2.4 配置文件1 web.xml Web 应用程序描述文件，都是关于是 Web 应用程序的配置文件 所有 Web 应用的 web.xml 文件的父文件 2 context.xml Tomcat 公用的环境配置，tomcat 服务器会定时去扫描这个文件 一旦发现文件被修改（时间戳改变了），就会自动重新加载这个文件，而不需要重启服务器 3 server.xml1234567891011&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt; &lt;Service name=&quot;Catalina&quot;&gt; &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt; &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt; &lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt; &lt;Context/&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;/Server&gt; 1 &lt;Server&gt; 顶层元素，表示一个运行于JVM中的 tomcat 实例 一个 Server 可以有多个 Service &lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt; port：表示接收 shutdown 指令的端口号 shutdonw：表示关闭此 Server 的指令 2 &lt;Service&gt; 将连接器 Connector 关联至引擎 Engine 一个 Service 可以有多个 Connector，但只能有一个 Engine 3 &lt;Connector&gt; 用于从客户端接收请求，之后将请求分配给引擎进行处理 HTTP 协议 1&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 表示客户端可以通过 8080 端口使用 HTTP 协议访问 tomcat connectionTimeout：超时时间 redirectPort：表示当强制要求 https 而请求却是 http 时，重定向至端口号为 8443 的 Connector AJP协议 1&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt; 表示客户端可以通过 8009 端口使用 AJP 协议访问 tomcat AJP 协议负责和其他的 Http 服务器（如Apache）建立连接，在把 Tomcat 与其他服务器集成时，就需要用到这个连接器（动静分离） 4 &lt;Engine&gt; 用于从一个或多个 Connector 中接收请求，然后转至对应的虚拟主机 Host 处理请求，并将响应返回给 Connector，最终传递给客户端 一个 Engine 中可以有多个 Host &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt; name 用于日志和错误信息，在整个 Server 中应该是唯一的 defaultHost 当发往本机的请求指定的 host 不存在时，一律使用 defaultHost 指定的 host 进行处理 因此，defaultHost 的值，必须与 Engine 中的一个 Host 组件的 name 属性值匹配 5 &lt;Host&gt; 一个 Host 组件代表 Engine 中的一个虚拟主机 一个 Host 可以有多个 Context &lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt; name 虚拟主机的主机名 一个 Engine 有且只有一个 Host 组件的 name 属性和 Engine 的 defaultHost 属性相匹配 appBase Web 应用默认所在目录 unpackWARS 是否将代表 Web 应用的 WAR 文件解压 true 通过解压后的文件结构运行该Web应用 false 直接使用WAR文件运行Web应用 autoDeploy 是否自动部署 6 &lt;Context&gt; 一个 Context 代表在虚拟主机上运行的一个Web应用 &lt;Context docBase=&quot;&quot; path=&quot;&quot; reloadable=&quot;&quot;/&gt; docBase 指定了该Web应用使用的WAR包路径或应用目录 自动部署时 如果 docBase 指定的WAR包或应用目录就在 appBase 中，不要指定 docBase 否则，需要指定 docBase path 指定了访问该Web应用的上下文路径，会与请求URI进行匹配 path=&quot;&quot; 表示这个 Context 是虚拟主机的默认 Web 应用，当请求的URI与所有的path都不匹配时，使用该默认Web应用来处理 自动部署时 如果没有XML配置文件且应用不在 appBase 下，则需要配置 path 否则，不需配置 path，而是根据配置文件名、WAR文件名或应用目录名推导而出，例： xmlBase/test.xml 则 path=&quot;test&quot; appBase/test.WAR 则 path=&quot;test&quot; appBase/test/ 则 path=&quot;test&quot; 如果上述文件名为 ROOT 则 path=&quot;&quot; reloadable 指示 tomcat 是否在运行时监控 WEB-INF/classes 和 WEB-INF/lib 目录下变动 true 当有变动时，会触发 Web 应用的重新加载 开发环境下，方便调试 false 默认，因为在生产环境中设置为 true 会给服务器带来性能压力 2.5 Tomcat 请求流程 请求此 Server 根据 Connector 配置协议和端口号选定 Service 和 Engine 根据域名和 IP 选定 Host 根据 URI 选定 Context/Web应用 2.6 Tomcat 部署应用1 部署形式 应用目录 WAR包 2 部署方式1 静态部署 在 server.xml 中通过 &lt;context&gt; 元素静态部署Web应用 不推荐静态部署，因为 server.xml 是不可动态重加载的资源，服务器一旦启动，要修改这个文件，就得重启服务器才能重新加载。 自动部署可以在 Tomcat 运行时通过定期的扫描来实现重新部署应用，不需要重启服务器 2 自动部署1 开启自动部署 要开启自动部署，需要配置所在的虚拟主机，即 server.xml 中的 &lt;Host&gt; &lt;Host xmlBase=&quot;&quot; appBase=&quot;&quot; autoDeploy=&quot;true&quot; deployOnStartup=&quot;true&quot; xmlBase 指定Web应用的XML配置文件所在的目录，默认值 basedir/conf/&lt;engine_name&gt;/&lt;host_name&gt; appBase 指定Web应用所在的目录，默认值 webapps autoDeploy=&quot;true&quot; 表示 Tomcat 在运行时定期检查新的Web应用或Web应用的更新 deployOnStartup=&quot;true&quot; 表示 Tomcat 在启动时检查Web应用，且将所有检测到的Web应用视作新应用 开启自动部署之后，通过检查 xmlBase 和 appBase 指定的目录是否有新的或更新的应用来实现自动部署，检查顺序 xmlBase 下的 XML 配置文件 appBase 下的 WAR 文件 appBase 下的应用目录 2 自动部署实现方式 WAR 文件或应用目录直接添加到 tomcat 的 appBase 指定的目录下 WAR 文件或应用目录在别处，通过在 basedir/conf/server.xml 中配置 Conctext 指明应用路径 由于要配置 server.xml ，所以重新部署需要重启 WAR 文件或应用目录在别处，通过配置 xmlBase 下的 XML 配置文件指明应用路径 重新部署不需要重启 3 IDE 的自动部署1 MyEclipse MyEclipse 使用方式一 直接将 WAR 文件或应用目录复制到 basedir/webapps 下 因为应用就在 appBase 中，所以不需要配置 Context 2 Eclipse Eclipse 使用方式二 Eclipse 本质是在其 workspace 下映射了一个 tomcat 的镜像，每创建一个 tomcat，就生成文件名为 tmp编号 的 tomcat 镜像，Eclipse 通过这个镜像 tomcat 运行应用 Catalina_Base 1workspace/.metadata/.plugins/org.eclipse.wst.server.core/tmp0/wtpwebapps basedir/conf/server.xml 123&lt;Host&gt; &lt;Context docBase=&quot;应用的真实路径&quot; path=&quot;网络访问的虚拟路径名(自定义)&quot; /&gt;&lt;/Host&gt; 3 Intellij Intellij 使用方式三 Intellij 在 configdir/system/tomcat/ 创建了新的 tomcat 实例 部署应用时，会在 tomcat 实例的 conf/catalina/localhost 目录下自动创建 XML 配置文件 1&lt;Context docBase=&quot;应用的真实路径&quot; path=&quot;与 XML 配置文件名相同，其实不用配置&quot;/&gt; 如果部署时指定了应用名，如 /test，则 XML 配置文件名称为 test.xml，paht=&quot;test&quot; 如果部署时省略了应用名，即 /，则 XML 配置文件名称为 ROOT.xml，paht=&quot;&quot; 2.7 Tomcat 启动 &amp; 访问1 概述1 CATALINA_HOME 是 Tomcat 的安装目录 指向公用信息的位置，就是 bin 和 lib 目录的父目录 2 CATALINA_BASE 是 Tomcat 的工作目录 指向每个 Tomcat 目录私有信息的位置，即 conf、logs、temp、webapps 和 work 目录的父目录 一个 CATALINA_BASE 就代表一个 Tomcat 实例 如果 CATALINA_BASE 没有值的话，则默认值就是 CATALINA_HOME 2 启动 执行 startup.bat ，其实最终是执行 catalina.bat Tomcat 启动时，需要查找 CATALINA_HOME 这个环境变量，并判断是否为空 CATALINA_HOME 不为空，则根据值查找 bin/catalina.bat ，找到就执行，找不到报错 CATALINA_HOME 为空 就将当前目录设为 CATALINA_HOME 的值，接着判断当前目录下是否存在 bin/catalina.bat 如果不存在，将当前目录的父目录设为 CATALINA_HOME 的值，继续判断 bin/catalina.bat，一直循环 最后如果找到就执行，找不到就报错 3 访问1http://ip:port/path/source port 省略则访问 80 端口 path 省略则访问 ROOT source 省略则访问首页 三 Nginx3.1 安装 配置官方yum源（官网查看） 123456789vim /etc/yum.repos.d/nginx.repo[nginx-stable]name=nginx stable repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=1enabled=1gpgkey=https://nginx.org/keys/nginx_signing.keymodule_hotfixes=true 安装 1yum install nginx -y 3.2 目录结构 目录 说明 /etc/logrotate.d/nginx 实现nginx日志切割 /etc/nginx 配置文件所在目录 /var/log/nginx 日志目录 var/cache/nginx 缓存目录 /usr/sbin/nginx 命令文件 /usr/sbin/nginx-debug debug命令文件 /usr/share/nginx/html 默认站点目录（图片 音视频 附件… ） 3.3 配置文件1 /etc/nginx/nginx.conf（主配置文件）12345678910111213141516171819202122231 基本配置user nginx; # 定义 worker_process 的管理用户，所有请求都会映射成此用户worker_processes 1; # 定义有几个worder_process（建议=cpu核数）error_log /var/log/nginx/error.log warn; # 定义错误日志路径信息pid /var/run/nginx.pid; # 定义pid文件路径信息2 事件区域配置events &#123; worker_connections 1024; # 1 个worker process可以同时接收1024访问请求&#125;# http区域配置http &#123; include /etc/nginx/mime.types; # 加载一个配置文件 default_type application/octet-stream; # 指定默认识别文件类型 log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; # 定义日志的格式 access_log /var/log/nginx/access.log main; # 指定日志路径（main 表示使用main定义的格式） sendfile on; #tcp_nopush on; keepalive_timeout 65; # 超时时间 #gzip on; include /etc/nginx/conf.d/*.conf; # 加载一个配置文件&#125; Nginx 有两个进程 master process 管理服务是否正常运行 worker process 处理用户的访问请求 2 /etc/nginx/conf.d/default.conf（扩展配置(默认虚拟主机配置文件)）123456789101112134 server区域信息（配置一个网站，即一个虚拟主机）server &#123; listen 80; # 监听端口 server_name localhost; # 网站域名 location / &#123; # 表示匹配URI以 / 开头的请求 root /usr/share/nginx/html; # 定义站点目录的位置 index index.html index.htm; # 定义首页文件 &#125; error_page 500 502 503 504 /50x.html; # 优雅显示错误页面信息 location = /50x.html &#123; root /usr/share/nginx/html; &#125;&#125; 3.4 利用 Nginx 搭建网站 创建虚拟主机配置文件 /etc/nginx/conf.d/xxx.conf 12345678910111213server &#123; listen 8090; server_name www.iisfive.com; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125;&#125;一个端口可配置多个域名 www、blog、bbs... 网站代码文件 DNS 配置 真实域名，在域名网站配置 模拟域名，在 Windows 的 hosts 文件配置 3.5 虚拟主机访问方式 基于域名访问 基于地址访问 服务器可能有多个IP，在虚拟主机配置的server中指定只能访问指定地址 listen ip:port 基于端口访问 3.6 模块 Module ngx_http_access_module 根据访问的服务器地址进行指定资源的控制 ngx_http_auth_basic_module 访问认证 ngx_http_autoindex_module 文件共享 ngx_http_stub_status_module 状态监控 ngx_http_rewrite_module 页面跳转 ngx_http_upstream_module 负载均衡 ngx_http_proxy_module 反向代理 ngx_http_core_module 核心模块 location location = / 精确匹配 location / 默认匹配，没有匹配时匹配默认 location = /test 目录匹配 location ^~ /text 优先匹配 location ~* \\.jpg 扩展名 3.7 负载均衡 集群 完成相同任务的一组服务器 负载均衡 对用户访问请求进行调度分配，实现用户访问压力分担 正向代理 &amp; 反向代理 正向代理 正向代理代理的对象是客户端 客户端明确知道要访问的目标服务器，但由于一些原因不能直接访问，则通过代理服务器来访问。 正向代理隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求 反向代理 反向代理代理的对象是服务端 客户端请求代理服务器，代理服务器帮客户端把请求转发到真实的服务器那里去 反向代理隐藏了真实的服务端，可能有许多台服务器提供服务，客户端并不知道也不需要知道具体是哪一台服务器处理此次请求。","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"JavaWeb","slug":"CS/JavaWeb","permalink":"https://anyeansan.github.io/categories/CS/JavaWeb/"}],"tags":[]},{"title":"JDBC","slug":"JavaWeb/JDBC","date":"2020-11-08T12:49:09.000Z","updated":"2020-11-08T12:54:04.482Z","comments":true,"path":"2020/11/08/JavaWeb/JDBC/","link":"","permalink":"https://anyeansan.github.io/2020/11/08/JavaWeb/JDBC/","excerpt":"","text":"一 概述 Java Database Connectivity JDBC 是 SUN 公司提供的一套访问数据库的标准规范，由各个数据库厂商来实现（数据库驱动） Java 开发时面向接口编程，运行时加载对应的数据库驱动即可 JDBC 主要完成三件事 建立连接 发送SQL语句 处理返回的结果 二 API2.1 概述 接口/类 说明 java.sql.DriverManager 驱动管理类，用于注册驱动 java.sql.Connection 连接 java.sql.Statement 执行 SQL 语句 java.sql.PreparedStatement Statement 子接口，预编译 java.sql.ResultSet 结果集，提供一个游标，默认指向结果集第一行之前 2.2 DriverManager 修饰 方法 说明 static void registerDriver​(Driver driver) 注册驱动 static Connection getConnection​(String url) 获取连接 static Connection getConnection​(String url, String user, String password) 获取连接 static Connection getConnection​(String url, Properties info) 获取连接 2.3 Connection 修饰 方法 说明 Statement createStatement() 获取 Statement PreparedStatement prepareStatement​(String sql) 获取 PreparedStatement CallableStatement prepareCall​(String sql) 获取 CallableStatement void setAutoCommit​(boolean autoCommit) 是否开启自动提交 void setTransactionIsolation​(int level) 设置隔离级别 void rollback() 回滚 void commit() 提交 2.4 Statement1 方法 修饰 方法 说明 ResultSet executeQuery​(String sql) 执行 DQL select，返回结果集 int executeUpdate​(String sql) 执行 DML insert update delete 返回影响行数，执行 DDL 返回 0 boolean execute​(String sql) 执行任意 SQL 语句，仅当执行 DQL 且有结果集时返回 true 2 Statement 的问题 SQL 拼接，各种单引号和双引号嵌套，很麻烦 SQL 注入 使用字符串拼接，导致 SQL 语句判断条件总是为 true，安全隐患 如 select * from test where name = &#39;wangcai&#39; or 1=1 无法处理 blob 等二进制类型数据 2.5 PreparedStatement1 方法 修饰 方法 说明 ResultSet executeQuery() 执行 DQL select，返回结果集 int executeUpdate() 执行 DML insert update delete 返回影响行数，执行 DDL 返回 0 boolean execute() 执行任意 SQL 语句，仅当执行 DQL 且有结果集时返回 true void setInt​(int parameterIndex, int x) 为指定类型占位符赋值，根据占位符顺序，从 1 开始 有一系列的 setXxx() 重载方法，为不同的类型赋值 2 解决 Statement 的问题 SQL 语句使用 ? 占位符，不需要手动拼接，从而也避免了 SQL 注入 为占位符赋值时可以使用二进制 3 插入数据后获取自增长的值123456// 1// autoGeneratedKeys：Statement 中定义的常量，其中 RETURN_GENERATED_KEYS 可以获取自增值的值PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)// 2 设置之后，插入时可以使用 PreparedStatement 对象获取一个结果集ResultSet getGeneratedKeys() 2.6 ResultSet 修饰 方法 说明 boolean next() 将游标从当前位置向下移一行 int getInt​(int columnIndex) 根据索引获取指定类型的值，索引从 1 开始 int getInt​(String columnLabel) 根据列名获取指定类型的值 Object getObject​(int columnIndex) 不清楚类型可以使用Object Object getObject​(String columnLabel) 不清楚类型可以使用Object ResultSetMetaData getMetaData() 获取结果集元数据，包含记录数，字段信息（个数，类型，名称 …） 有一系列的各种数据类型的 getXxx() 重载方法，且都有根据列名和索引获取两种方式 三 Mysql 和 java 类型3.1 java.sql.ResultSetMetaData（结果集元数据） 修饰 方法 说明 int getColumnCount() 获取记录数 String getColumnTypeName​(int column) 获取字段对应的数据库类型，编号从 1 开始 String getColumnClassName​(int column) 获取字段对应的 java 类型，编号从 1 开始 String getColumnName​(int column) 获取字段在数据库中的名称 String getColumnLabel​(int column) 获取字段别名 使用反射根据属性名获取 Field 对象时，如果数据库字段名和类属性名不一致，就获取不到 可以使用别名，让别名=类属性名 类属性名建议都是用引用类型，因为数据库数据可能为空 3.2 类型对照 Mysql Type name（数据库设计类型） GetColumnTypeName（数据库类型） GetColumnClassName（java 类型） INT INTEGER java.lang.Integer INT UNSIGNED INTEGER UNSIGNED java.lang.Long CHAR(M) CHAR java.lang.String VARCHAR(M) VARCHAR java.lang.String ENUM(&#39;value1&#39;,&#39;value2&#39;,...) CHAR java.lang.String SET(&#39;value1&#39;,&#39;value2&#39;,...) CHAR java.lang.String DATE DATE java.sql.Date DATETIME DATETIME java.sql.Timestamp TIMESTAMP TIMESTAMP java.sql.Timestamp 四 JDBC 步骤 导入数据库驱动包 注册驱动 手动注册（不推荐） 1void DriverManager.registerDriver(Driver driver) 对具体的驱动类产生了依赖，不方便扩展 驱动重复注册 调用此方法注册一次 加载 Driver 类又注册一次，因为 Driver 类中的静态代码块就是调用了此方法 反射注册（推荐） 12// 通过反射加载 Driver 类时执行静态代码块，注册驱动Class.forName(\"com.mysql..cj.jdbc.Driver\") 获取连接 1Connection conn = DriverManager.getConnection(url,user.passwd) 执行 SQL 语句，获取结果集 Statement（不推荐） 编写静态 SQL 语句 根据连接获取 Statement 对象 使用 Statement 对象执行 SQL，获取结果集 PreparedStatement（推荐） 编写动态 SQL 语句（参数使用 ? 作为占位符） 根据连接获取 PreparedStatement 对象 使用 PreparedStatement 对象为 SQL 占位符赋值 使用 PreparedStatement 对象执行，获取结果集 处理结果集 关闭资源（ResultSet Statement Connection） 五 批处理5.1 概述 当需要成批插入或者更新记录时，可以采用 Java 的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。 通常情况下比单独提交处理更有效率，类似缓冲区的效果 5.2 使用 Mysql 服务器默认是关闭批处理的，需要url 配置 rewriteBatchedStatements=true 来开启 void addBatch() 将需要批量处理的SQL语句或参数添加到批处理组中，类似添加到缓冲区 int[] executeBatch() 执行批处理 六 JDBC 事务123456789// 1 关闭自动提交：开启事务conn.setAutoCommit(false)// 2 回滚或提交conn.rollback()conn.commit()// 3 关闭连接前恢复自动提交，因为连接通常从连接池中获取，是重复使用的conn.setAutoCommit(true) 七 MySQL 数据库驱动7.1 Connector/J 5 属性 语法 driver com.mysql.jdbc.Driver url jdbc:mysql://localhost:3306/db_name 7.2 Connector/J 8 属性 语法 例 driver com.mysql.cj.jdbc.Driver com.mysql.cj.jdbc.Driver url protocol//[hosts][/database][?properties] jdbc:mysql://localhost:3306/db_name?useSSL=false&amp;serverTimezone=GMT%2B8&amp;characterEncoding=UTF-8 7.3 Connector/J 8 中 url 的 properties1 概述 格式 key=value，多个之间使用 &amp; 连接 在 Xml 中应该使用字符的特殊编码：&amp; 对应 &amp;amp; 2 key key 说明 useSSL 是否使用 SSL 连接，默认 true characterEncoding 设置字符集 serverTimezone 设置时区 rewriteBatchedStatements 是否开启批处理，默认 false 1 SSL （Secure Socket Layer） 安全套接字层，用于安全连接，但是影响性能 若要使用 SSL 需要在 Mysql 服务端配置 Mysql 8.0 之前 5.5.45+，5.6.26+，5.7.6+ 默认为 true 其它默认为 false Mysql 8.0 之后，默认为 true 2 serverTimezone UTC 世界标准时间，0 时区时间 GMT+8 ，url 中写为 GMT%2B8 东八区时间，比 UTC 快 8 个小时 如果不想时间有差异：接收的类型使用的时区和连接设置的时区要相同，因为不管数据库时区和连接时区是什么，从数据库获取的值是不变的，只是所代表的时区会改变 timestamp dateTime localDateTime ... 等类型使用的时区是本地系统时区，所以使用这些类型接收时，serverTimezone 要与本地系统时区一致 Instant 是 UTC 时间，使用 Instant 接收时，serverTimezone 要设置为 UTC 3 关于时区的例子 数据库都设置为东八区时间 00:00:00 serverTimezone=UTC，从数据库获取的就是 UTC 时间 00:00:00 timestamp dateTime localDateTime ... 这些类型接收会转换为东八区时间，也就是要+8，最终结果为 08:00:00 Instant 使用的是 UTC 时间，不用转换，最终结果为 00:00:00 serverTimezone=GMT%2B8，从数据库获取的就是 东八区 时间 00:00:00 使用 timestamp dateTime localDateTime ... 接收不需要转换 使用 Instant 接收需要转为 UTC 时间，也就是要 - 8，最终结果是前一天的 16:00:00","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"JavaWeb","slug":"CS/JavaWeb","permalink":"https://anyeansan.github.io/categories/CS/JavaWeb/"}],"tags":[]},{"title":"Java-日志","slug":"Java/Java-日志","date":"2020-09-29T08:04:53.000Z","updated":"2020-09-29T08:05:08.331Z","comments":true,"path":"2020/09/29/Java/Java-日志/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-%E6%97%A5%E5%BF%97/","excerpt":"","text":"一 概述 日志门面（接口）： JCL（jakarta commons logging） slf4j（simple logging facade for java） 日志实现 JUL（Java util Logging） logback log4j log4j2 二 日志门面2.1 JCL1 概述 Jakarta Commons Logging 包： commons-looging.jar Apache 提供的一个通用日志接口，它是为 “所有的 Java 日志实现”提供一个统一的接口，它自身也提供一个日志的实现 SimpleLog，但是功能非常弱 通过动态查找的机制，在程序运行时自动找出真正使用的日志库，如果未提供任何第三方实现，则默认使用 JUL 2 API Log：日志记录器 LogFactory：负责创建 Log 2.2 slf4j1 概述 Simple Logging Facade For Java SLF4J 主要是为了给 Java 日志访问提供一套标准、规范的 API 框架，其主要意义在于提供接口，具体的实现可以交由其他日志框架 slf4j 内置一个简单的日志实现 slf4j-simple ，不过很少使用 通常 slf4j 作为门面，配上具体的实现框架，中接使用桥接器完成桥接 主要功能： 日志框架的绑定 日志框架的桥接 slf4j-api.jar 核心 API 包 日志级别 1OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL 2 绑定日志实现1 步骤 添加 slf4j 的依赖包 slf4j-api.jar 绑定具体的日志实现框架 已经实现 slf4j 的日志框架，如 logback，直接添加其依赖即可 没有实现 slf4j 的日志框架，如 JUL log4j log4j2，除了日志框架的依赖包外，还需要适配器（包） 如果绑定了多个实现，默认使用第一个 2 包1 slf4j + JUL12slf4j-api.jarslf4j-jdk14.jar 2 slf4j + log4j123slf4j-api.jarlog4j.jarslf4j-log4j12.jar 3 slf4j + log4j21234slf4j-api.jarlog4j-api.jarlog4j-core.jarlog4j-slf4j-impl.jar 4 slf4j + logback123slf4j-api.jarlogback-core.jarlogback-classic.jar 3 桥接旧的日志框架1 步骤 去除旧的日志依赖 配置桥接器（包） 绑定新的日志实现 2 桥接器 jul-to-slf4j.jar 将 JUL 的日志桥接到 slf4j ，即不再使用 JUL，而使用新的日志实现 log4j-over-slf4j.jar 将 log4j 的日志桥接到 slf4j jcl-over-slf4j.jar 将 JCL 的日志桥接到 slf4j 4 API12Logger LoggerFactory.getLogger(字节码文件)Logger LoggerFactory.getLogger(全限定类名) 三 日志实现3.1 log4j21 配置 默认加载类路径下 log4j2.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!-- 日志级别： OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL 日期格式： %d 输出的时间 %t 输出当前线程名称 %F 输出所在的类文件名 %L 输出行号 %M 输出所在方法名 %n 换行 %-5level 输出日志级别，-5表示左对齐并且固定输出5个字符，如果不足在右边补0 %logger 输出logger名称，Root Logger没有名称 %l 输出语句所在的行数, 包括类名、方法名、文件名、行数--&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!--status：设置log4j2自身内部的信息输出，可以不设置monitorInterval：指定每隔多久重新读取配置文件，可以不重启应用的情况下修改配置--&gt;&lt;configuration status=\"WARN\" monitorInterval=\"30\"&gt; &lt;!-- 1 定义属性--&gt; &lt;properties&gt; &lt;property name=\"\"&gt;&lt;/property&gt; &lt;/properties&gt; &lt;!-- 2 配置 appender--&gt; &lt;appenders&gt; &lt;!-- 2.1 console--&gt; &lt;console name=\"\" target=\"SYSTEM_OUT\"&gt; &lt;!--输出日志格式--&gt; &lt;PatternLayout pattern=\"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n\"/&gt; &lt;/console&gt; &lt;!-- 2.2 file--&gt; &lt;File name=\"\" fileName=\"文件路径\" append=\"是否追加\"&gt; &lt;!--输出日志格式--&gt; &lt;PatternLayout pattern=\"\"/&gt; &lt;/File&gt; &lt;!-- 2.3 rollingFile--&gt; &lt;RollingFile name=\"\" fileName=\"\" filePattern=\"指定当发生Rolling时，文件的转移和重命名规则\"&gt; &lt;!--输出日志格式--&gt; &lt;PatternLayout pattern=\"\"/&gt; &lt;!-- 过滤器--&gt; &lt;ThresholdFilter level=\"\" onMatch=\"ACCEPT\" onMismatch=\"DENY\"/&gt; &lt;!-- 日志拆分规则--&gt; &lt;Policies&gt; &lt;!-- 系统启动就触发拆分规则，产生一个新的日志文件--&gt; &lt;OnStartupTriggeringPolicy/&gt; &lt;!-- 按照时间节点拆分，根据 filePattern 的配置，如最小时间粒度是HH，则表示每小时产生一个新的日志文件--&gt; &lt;TimeBasedTriggeringPolicy/&gt; &lt;!-- 按照文件大小拆分，超过大小就产生一个新的--&gt; &lt;SizeBasedTriggeringPolicy size=\"\"/&gt; &lt;/Policies&gt; &lt;!--同一目录最多保存的文件个数，超过则覆盖--&gt; &lt;DefaultRolloverStrategy max=\"\"/&gt; &lt;/RollingFile&gt; &lt;/appenders&gt; &lt;!-- 3 logger 只有定义了logger并引入的appender，appender才会生效--&gt; &lt;loggers&gt; &lt;!--3.1 root--&gt; &lt;root level=\"\"&gt; &lt;appender-ref ref=\"\"/&gt; &lt;/root&gt; &lt;!--3.2 自定义 logger--&gt; &lt;logger name=\"\" level=\"\" additivity=\"\"&gt; &lt;appender-ref ref=\"\"/&gt; &lt;/logger&gt; &lt;/loggers&gt;&lt;/configuration&gt; 2 异步日志1 概述 异步日志需要添加依赖 com.lmax.disruptor 有两种实现方式 AsyncLogger（官方推荐）：全局+混合 AsyncAppender 注意三种方式不要同时使用 2 AsyncLogger1 全局异步 所有的日志都异步的记录，在配置文件上不用做任何改动，只需要添加一个 log4j2.component.properties 配置 log4j2.component.properties 1Log4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector 2 混合异步 同时使用同步日志和异步日志，通过配置指定哪些同步哪些异步 配置 123456789&lt;Loggers&gt; &lt;!-- 自定义异步 logger includeLocation：是否包含日志记录的行号信息，要关闭 --&gt; &lt;AsyncLogger name=\"\" level=\"\" includeLocation=\"false\" additivity=\"false\"&gt; &lt;AppenderRef ref=\"\"/&gt; &lt;/AsyncLogger&gt;&lt;/Loggers&gt; 3 AsyncAppender123456// 定义异步 appender ，之后引入 logger 即可&lt;Appenders&gt; &lt;Async name=\"\"&gt; &lt;AppenderRef ref=\"\"/&gt; &lt;/Async&gt;&lt;/Appenders&gt; 3.2 logback1 模块 logback-core：其它两个模块的基础模块 logback-classic：它是 log4j 的一个改良版本，同时它完整实现了slf4j API logback-access：访问模块与 Servlet 容器集成提供通过 Http 来访问日志的功能 2 配置1 依次读取 logback.groovy logback-test.xml logback.xml 2 详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;!-- 1 配置集中管理属性，获取value语法 $&#123;name&#125; --&gt; &lt;property name=\"\" value=\"\"/&gt; &lt;!-- 2 Appdender 配置 --&gt; &lt;!-- 2.1 console --&gt; &lt;appender name=\"\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!--输出流对象 默认 System.out--&gt; &lt;target&gt;&lt;/target&gt; &lt;!--日志输出格式--&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;pattern&gt;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 2.2 file --&gt; &lt;appender name=\"\" class=\"ch.qos.logback.core.FileAppender\"&gt; &lt;!--日志输出路径--&gt; &lt;file&gt;&lt;/file&gt; &lt;!--日志输出格式--&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;pattern&gt;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 2.3 htmlFile --&gt; &lt;appender name=\"\" class=\"ch.qos.logback.core.FileAppender\"&gt; &lt;!--日志输出路径--&gt; &lt;file&gt;&lt;/file&gt; &lt;!--日志输出格式--&gt; &lt;encoder class=\"ch.qos.logback.core.encoder.LayoutWrappingEncoder\"&gt; &lt;layout class=\"ch.qos.logback.classic.html.HTMLLayout\"&gt; &lt;pattern&gt;&lt;/pattern&gt; &lt;/layout&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 2.4 rollingFile --&gt; &lt;appender name=\"\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!--日志输出路径--&gt; &lt;file&gt;&lt;/file&gt; &lt;!--日志输出格式--&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;pattern&gt;&lt;/pattern&gt; &lt;/encoder&gt; &lt;!--指定日志文件拆分和压缩规则--&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\"&gt; &lt;!--按照时间和压缩格式声明拆分的文件名--&gt; &lt;fileNamePattern&gt;&lt;/fileNamePattern&gt; &lt;!--按照文件大小拆分--&gt; &lt;maxFileSize&gt;&lt;/maxFileSize&gt; &lt;/rollingPolicy&gt; &lt;!--日志级别过滤器--&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;!--过滤规则--&gt; &lt;level&gt;&lt;/level&gt; // 超过指定级别放行还是拦截 &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; // 低于指定级别放行还是拦截 &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 2.5 异步 async --&gt; &lt;appender name=\"\" class=\"ch.qos.logback.classic.AsyncAppender\"&gt; &lt;appender-ref ref=\"\"/&gt; &lt;/appender&gt; &lt;!-- 3 root Logger 配置--&gt; &lt;root level=\"默认debug\"&gt; &lt;appender-ref ref=\"console\"/&gt; &lt;/root&gt; &lt;!--4 自定义 logger --&gt; &lt;logger name=\"com.itheima\" level=\"debug\" additivity=\"是否继承rootLogger，默认true\"&gt; &lt;appender-ref ref=\"\"/&gt; &lt;/logger&gt;&lt;/configuration&gt; 3.3 JUL1 概述 Java util Logging 是 Java 原生的日志框架，使用时不需要另外引用第三方类库 配置文件：$JAVA_HOME\\conf\\logging.properties 所在包：java.util.logging 2 架构 对象 说明 Logger 日志记录器，程序通过此对象的 API 来发布日志，每个 Logger 可以关联多个 Appender / Handler Appender / Handler 日志处理器，决定日志记录的位置，如 控制台、文件… Layout / Formatter 负责日志记录的数据转换和格式化 Level 日志级别 2 API1 Logger 修饰 方法 说明 static Logger getLogger(String name) 获取或创建 Logger 对象 void log(Level, String msg) 输出指定级别的信息 void info(String msg) 输出指定级别的信息，还有其它级别方法 void addHandler(Handler handler) 关联 Handler void setUseParentHandlers(Boolean useParentHandlers) 是否会输出到父 Logger void setLevel(Level newLevel) 设置日志级别 Logger 之间存在父子关系，根据名称会自动继承，如 com.cn.an 和 com.cn 和 com 最顶层是一个 RootLogger 子 Logger 输出会同时传递给父 Logger 输出 2 Lever 静态属性 说明 ALL 启用所有级别信息 OFF 关闭日志 SEVERE 错误 WARNING 警告 INFO（默认） 信息 CONFIG 配置 FINE FINER FINEST debug 详细 较详细 非常详细 3 Handler 修饰 方法 说明 void setLevel(Level newLevel) 设置日志级别 void setForMatter(Formater newFormatter) 关联 Formatter 3.4 Log4j1 配置文件123456# 指定日志级别和使用的输出端appender：console为自定义名称log4j.rootLogger=INFO,console# 控制台输出配置log4j.appender.console=org.apache.log4j.ConsoleAppenderlog4j.appender.console.layout=org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n 名称：log4j.properties 将配置文件放在类路径下，会自动读取 2 组件1 Looger Log4j 有一个根 Logger：root 其它所有的 Logger 都会直接或间接继承 root 2 Appender ConsoleAppender FileAppender DailyRollingFileAppender RollingFileAppender JDBCAppender 3 Layout HTMLLayout SimpleLayout PatternLayout 配置文件log4j2.xml12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;Configuration status=\"WARN\" monitorInterval=\"100\"&gt; &lt;Appenders&gt; &lt;Console name=\"Console\" target=\"SYSTEM_OUT\"&gt; &lt;PatternLayout pattern=\"%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n\" /&gt; &lt;/Console&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level=\"info\"&gt; &lt;AppenderRef ref=\"Console\" /&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; log4j2默认会在classpath目录下寻找log4j.json、log4j.jsn、log4j2.xml等名称的文件，如果都没有找到，则会按默认配置输出，也就是输出到控制台。 status 表示log4j2本身的日志信息打印级别 用于设置log4j2自身内部的信息输出,可以不设置,当设置成trace时,会看到log4j2内部各种详细输出 monitorInterval Log4j能够自动检测修改配置文件和重新配置本身, 设置间隔秒数。 Appender 定义日志的输出目的地 Console 定义输出到控制台的Appender name 指定Appender的名字 target SYSTEM_OUT 或 SYSTEM_ERR,一般只设置默认:SYSTEM_OUT. PatternLayout 输出格式，不设置默认为:%m%n. File 定义输出到指定位置的文件的Appender name 指定Appender的名字 fileName 指定输出日志的目的文件带全路径的文件名 PatternLayout 输出格式，不设置默认为:%m%n. RollingFile 定义超过指定大小自动删除旧的创建新的的Appender. name 指定Appender的名字 fileName 指定输出日志的目的文件带全路径的文件名 PatternLayout 输出格式，不设置默认为:%m%n. filePattern 指定新建日志文件的名称格式. Policies 指定滚动日志的策略，就是什么时候进行新建日志文件输出日志 TimeBasedTriggeringPolicy 基于时间的滚动策略 interval 指定多久滚动一次，默认是1 hour modulate =true用来调整时间 比如现在是早上3am，interval是4，那么第一次滚动是在4am，接着是8am，12am…而不是7am SizeBasedTriggeringPolicy 基于指定文件大小的滚动策略 size 定义每个日志文件的大小 DefaultRolloverStrategy 指定同一个文件夹下最多有几个日志文件时开始删除最旧的，创建新的 max 配置最多日志文件数 Loggers Root 指定项目的根日志，如果没有单独指定Logger，那么就会默认使用该Root日志输出 level 日志输出级别，共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF AppenderRef 指定该日志输出到哪个Appender Logger 单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等 level name 指定该Logger所适用的类或者类所在的包全路径,继承自Root节点 AppenderRef 指定该日志输出到哪个Appender,如果没有指定，就会默认继承自Root.如果指定了，那么会在指定的这个Appender和Root的Appender中都会输出。 若设置Logger的additivity=”false”只在自定义的Appender中进行输出。","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-时间日期","slug":"Java/Java-时间日期","date":"2020-09-29T08:04:17.000Z","updated":"2020-09-29T08:04:27.752Z","comments":true,"path":"2020/09/29/Java/Java-时间日期/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F/","excerpt":"","text":"一 JDK8 之前的日期时间1.1 java.util.Date1 构造方法 构造方法 说明 Date() 当前时间，使用的是当前时间到 1970-01-01 00:00:00 的毫秒值创建 Date​(long date) 使用指定毫秒值 2 方法 方法 说明 long getTime() 获取 1970-01-01 00:00:00 到此时间的毫秒值 1.2 java.util.Calendar1 概述 Calendar 类是一个抽象类，提供了很多关于日期时间计算的方法 GregorianCalendar（公历）是 Calendar 的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统 2 方法 方法 说明 static Calendar getInstance() 使用默认时区和语言环境获得一个日历 static Calendar getInstance​(TimeZone zone, Locale aLocale) 使用指定时区和语言环境获得一个日历 1.3 java.text.SimpleDateFormat 方法 说明 SimpleDateFormat​(String pattern) 指定格式创建对象 String format​(Date date) 日期 → 字符串 Date parse​(String source) 字符串 → 日期 二 JDK8 的日期时间 包 说明 java.time 基础包，使用标准的 iso-8601 历法（公历） java.time.format 格式化和解析日期时间 java.time.temporal 包括底层框架和扩展特性 java.time.chrono 提供对不同的日历系统的访问 java.time.zone 包含支持不同时区以及相关规定的类 三 java.time 包3.1 概述 类 说明 LocalDateTime 本地日期时间（不包含时区） LocalDate 本地日期 LocalTime 本地时间 Instant 瞬时（时间戳），是 UTC 时间，没有时区概念 Period 日期间隔 Duration 时间间隔 ZoneOffset 时区偏移量 ZonedDateTime 指定时区的日期时间 ZoneId 包含了所有的时区信息，格式 区域/城市 Clock 时钟 3.2 LocalDateTime &amp; LocalDate &amp; LocalTime1 创建（now，of） 修饰 方法 说明 static LocalDateTime now() 获取当前日期时间（默认时区） static LocalDateTime now​(ZoneId zone) 获取当前日期时间（指定时区） static LocalDateTime of(xxx) 获取指定日期时间（一系列重载） 2 获取（get） 修饰 方法 说明 int getYear() 获取年份 Month getMonth() 获取月份（Month 是枚举类） int getMonthValue() 获取一年中的第几个月 1 ~ 12 int getDayOfYear() 获取一年中的第几天 1 ~ 365/366 int getDayOfMonth() 获取一月中的第几天 1 ~ 31 DayOfWeek getDayOfWeek() 获取星期几（DayOfWeek 是枚举类） int getHour() 获取时 int getMinute() 获取分 int getSecond() 获取秒 int getNano() 获取纳秒 3 格式化和解析（format，parse） 修饰 方法 说明 String format​(DateTimeFormatter formatter) 日期时间转成指定格式的字符串 static LocalDateTime parse​(CharSequence text) 解析默认格式字序列 static LocalDateTime parse​(CharSequence text, DateTimeFormatter formatter) 解析指定格式字符序列 4 判断（is） 修饰 方法 说明 boolean isAfter​(ChronoLocalDate other) 是否在之后 boolean isBefore(ChronoLocalDate other) 是否在之前 boolean isEqual(ChronoLocalDate other) 是否相等 boolean isLeapYear() 是否是闰年 5 修改（with） 修饰 方法 说明 LocalDateTime with​(TemporalAdjuster adjuster) 将当前日期时间设置为校对器指定的日期时间 LocalDateTime withYear(int year) 修改年 LocalDateTime withMonth(int month) 修改月 LocalDateTime withDayOfYear(int dayOfYear) 修改年第几天 LocalDateTime withDayOfMonth(int dayOfMonth) 修改月第几天 LocalDateTime withHour(int hour) 修改时 LocalDateTime withMinute(int minute) 修改分 LocalDateTime withSecond(int second) 修改秒 6 计算 plus，minus 修饰 方法 说明 LocalDateTime minus(TemporalAmount amountToSubtract) 减去一个 Duration 或 Period LocalDateTime plus(TemporalAmount amountToAdd) 添加一个 Duration 或 Period LocalDateTime plusYears(long years) 当前日期时间加指定年 LocalDateTime plusMonths(long months) 当前日期时间加指定月 LocalDateTime plusDays(long days) 当前日期时间加指定日 LocalDateTime plusWeeks(long weeks) 当前日期时间加指定周 LocalDateTime plusHours(long hours) 当前日期时间加指定时 LocalDateTime plusMinutes(long minutes) 当前日期时间加指定分 LocalDateTime plusSeconds(long seconds) 当前日期时间加指定秒 7 转换（to） 修饰 方法 说明 String toString() 获取字符串 LocalDate toLocalDate() 获取日期 LocalTime toLocalTime() 获取时间 3.3 Instant 修饰 方法 说明 static Instant now() 获取当前UTC时间的时间戳 static Instant ofEpochMilli​(long epochMilli) 获取指定毫秒值距元时间的时间戳 long toEpochMilli() 获取距元时间的毫秒数 OffsetDateTime atOffset​(ZoneOffset offset) 结合时区偏移创建 OffsetDateTime 3.4 Period 修饰 方法 说明 static Period between​(LocalDate startDateInclusive, LocalDate endDateExclusive) 获取两个日期的间隔对象 Period int getYears() 相隔年份 int getMonths() 相隔月份（只比较月字段） int getDays() 相隔天数（只比较日字段） long toTotalMonths() 相隔总月份 3.5 Duration 修饰 方法 说明 static Duration between​(Temporal startInclusive, Temporal endExclusive) 获取两个时间的间隔对象 Duration long toDays() 相隔总天数 long toHours() 相隔总小时数 long toMinutes() 相隔总分钟数 long toSeconds() 相隔总秒数 long toMillis() 相隔总毫秒数 long toNanos() 相隔总纳秒数 3.6 ZoneId 修饰 方法 说明 static Set&lt;String&gt; getAvailableZoneIds() 获取所有时区ID，格式区域/城市 static ZoneId systemDefault() 获取系统默认时区 static ZoneId of​(String zoneId) 根据时区ID获取时区 四 DateTimeFormatter4.1 预定义标准格式 字段 说明 ISO_LOCAL_DATE_TIME YYYY-MM-DD HH:MM:SS ISO_LOCAL_DATE YYYY-MM-DD ISO_LOCAL_TIME HH:MM:SS ... ... 4.2 本地化相关格式 修饰 方法 说明 static DateTimeFormatter ofLocalizedDateTime​(FormatStyle dateTimeStyle) FormatStyle 是枚举类，其中 FULL，LONG适用于 DateTime static DateTimeFormatter ofLocalizedDate​(FormatStyle dateStyle) MEDIUM，SHORT 适用于 Date static DateTimeFormatter ofLocalizedTime​(FormatStyle timeStyle) MEDIUM，SHORT 适用于 Time 4.3 自定义格式 修饰 方法 说明 static DateTimeFormatter ofPattern​(String pattern) 使用自定义格式和默认地区 static DateTimeFormatter ofPattern​(String pattern, Locale locale) 使用自定义格式和指定地区 五 TemporalAdjusters5.1 概述 时间校正器工具类 获取时间校正器对象，之后可以通过日期时间对象的 with 方法来调整 5.2 API1234static TemporalAdjuster firstXxx()static TemporalAdjuster lastXxx()static TemporalAdjuster nextXxx()static TemporalAdjuster previousXxx() 六 新旧日期时间的转换 旧类 新类 旧 → 新 新 → 旧 java.util.Date java.time.Instant date.toInstant() Date.from(instant) java.sql.Timestamp java.time.Instant timestamp.toInstant() Timestamp.from(instant) java.sql.Timestamp java.time.LocalDateTime timestamp.toLocalDateTime() Timestamp.valueOf(localDateTIme) java.sql.Date java.time.LocalDate date.toLocalDate() Date.valueOf(LocalDate) java.sql.Time java.time.LocalTime time.toLocalTime() TIme.valueOf(LocalTime) 旧转为新 to 新转为旧 from，valueOf","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-常用API","slug":"Java/Java-常用API","date":"2020-09-29T08:03:31.000Z","updated":"2020-09-29T08:03:47.268Z","comments":true,"path":"2020/09/29/Java/Java-常用API/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-%E5%B8%B8%E7%94%A8API/","excerpt":"","text":"一 java.lang.Object 修饰 方法 说明 int hashCode() 返回该对象的哈希码值 boolean equals(Object obj) 默认比较对象的地址值 Class&lt;?&gt; getClass() 返回此对象的字节码对象 String toString() getClass().getName() + &#39;@&#39; + Integer.toHexString(hashCode()) protected Object clone() 浅拷贝 void wait() 无限等待直到被唤醒，相当于 wait(0) void wait(long timeoutMillis) 等待指定时间或被唤醒 void wait(long timeoutMillis, int nanos) 等待指定时间或被唤醒 void notify() 唤醒一个 void notifyAll() 唤醒所有 1.1 == 和 equals() 比较符 基本数据类型 引用数据类型 == 比较值，== 是运算符所以同样适用基本类型运算时的类型转换 byte short char -&gt; int -&gt; long -&gt; float -&gt; double 比较地址值 equals() &nbsp; 比较地址值 1.2 重写 equals() 时也要重写 hashCode() 判断元素是否相同： 判断两个元素哈希值是否相同（判断的是对象的 hashCode() 如果哈希值相同判断内容是否相同（判断的是对象的 equals()） 两个对象相同则哈希值一定相同，如果只重写 equals() 方法，结果返回 true 时，hashCode() 返回值可能不一样 二 java.util.Objects 修饰 方法 说明 static boolean equals​(Object a, Object b) 判断是否是同一对象 static boolean isNull​(Object obj) 判断对象是否为空 static boolean nonNull​(Object obj) 判断对象是否不为空 static &lt;T&gt; T requireNonNull​(T obj [, String message]) 如果对象不为空则返回，为空则抛空指针异常（可指定异常信息） static &lt;T&gt; int compare​(T a, T b, Comparator&lt;? super T&gt; c) 如果 a==b 返回 0，否则使用比较器比较 static String toString​(Object o) 如果对象不为空则调用 toString()，为空则返回 &quot;null&quot; 三 基本类型包装类3.1 包装类 基本数据类型 包装类（java.lang） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 除了 Character 和 Boolean 外，都是 Number 类的子类 3.2 自动装箱和拆箱 装箱：基本数据类型 → 包装类对象 拆箱：包装类对象 → 基本数据类型 3.3 包装类的缓存 包装类 缓存范围 Boolean true false Byte Short Long -128~127 Integer -128~127（上限可以调整） Character 0~127 （最早的 ASCII 码的128个字符） Double Float 没有缓存 自动装箱时，如果在缓存范围内，则不会创建新对象，而是使用缓存 1234567891011121314Integer i1 = new Integer(127);Integer i2 = new Integer(127);i1 == i2; // false ，因为不是同一个对象i1.equals(i2); // true ，Integer重写了equals方法，比较的是数值Integer i1 = 127;Integer i2 = 127;i1 == i2; // true ，因为缓存，指向同一个地址i1.equals(i2); // true Integer i1 = 128;Integer i2 = 128;i1 == i2; // false ，不在缓存范围，则需要重新 new 是两个不同的地址i1.equals(i2); // true 3.4 基本类型及其包装类与字符串的转换 int/Integer -&gt; string + &quot;&quot; toString() String.valueOf() String -&gt; int/Integer Integer.parseInt(String s) 四 比较器4.1 java.lang.Comparable 实现此接口的类具有比较性 实现 int compareTo(T o) 方法 如果当前对象大于形参对象则返回正整数 如果当前对象等于形参对象则返回 0 如果当前对象小于形参对象则返回负整数 4.2 java.util.Comparator 比较器接口，实现此接口创建新的比较器 实现 int compare(T o1, T o2) 方法 o1 &gt; o2 返回正整数 o1 == o2 返回 0 o1 &lt; o2 返回负整数 五 java.lang.System5.1 属性 字段 说明 in 标准输入 out 标准输出 err 标准错误输出 5.2 方法 修饰 方法 说明 static long currentTimeMillis() 1970-01-01 00:00:00 到当前时间的毫秒值 static Properties getProperties() 获取系统属性值 static String getProperty(String key) 获取系统指定属性的值 static void gc() 运行垃圾回收器 static void exit(int status) 终止当前正在运行的 Java 虚拟机， 0 表示正常终止，非 0 异常退出 static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 拷贝数组 static void setIn​(InputStream in) 重新分配标准输入 static void setOut​(PrintStream out) 重新分配标准输出 static void setErr​(PrintStream err) 重新分配标准错误输出 六 java.util.Scanner6.1 构造 构造方法 说明 Scanner(File source [, String charsetName]) 扫描文件 Scanner​(InputStream source [, String charsetName]) 扫描字节输入流 Scanner​(String source) 扫描字符串 6.2 方法 修饰 方法 说明 boolean hasNext() 是否有下一个字符串 String next() 获取下一个字符串，遇到空白符结束（空格 制表符 回车） String nextLine() 获取下一个字符串，遇到换行符结束 boolean hasNextXxx() 是否有下一个指定类型的数据，hasNextInt ()hasNextDouble() ... Xxx nextXxx() 获取下一个指定类型的数据，nextInt() nextDouble() ... 当 nextXxx() 和 nextLine() 连用时的问题 比如输入 8 ，实际输入的是 8\\r\\n，而 nextInt() 读到 8 就结束了，下一个使用 nextLine() 读到 \\r\\n 直接就结束了 解决 在语句之后加一个 nextLine() 语句用来读取没有读到的 \\r\\n 都使用 nextLine()，输入字符串，需要数字就转换。 七 java.util.Random7.1 构造 构造方法 说明 Random() 默认种子是系统时间的纳秒值 Random​(long seed) 指定种子，种子相同，多次执行获得的随机数是一样的 7.2 方法 修饰 方法 说明 int nextInt() 获取 int 范围内的随机数 int nextInt(int bound) 获取 0&lt; x &lt; bound 的随机数 八 Arrays8.1 数组 → 集合 修饰 方法 说明 static &lt;T&gt; List&lt;T&gt; asList(T... a) 数组 → List 数组长度固定，所以转成的集合的增删方法不能使用 集合中只能存储引用数据类型，所以： 如果数组中的元素是引用类型，则直接作为集合元素 如果数组中的元素是基本类型，则将数组作为集合元素 8.2 二分查找 修饰 方法 说明 static int binarySearch(T[] a, T key) 找到则返回索引，没找到返回 -插入点-1 static int binarySearch(T[] a, int fromIndex, int toIndex, T key) 指定范围 [from, to) static &lt;T&gt; int binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c) 指定比较器 static &lt;T&gt; int binarySearch(T[] a, int fromIndex, int toIndex, T key, Comparator&lt;? super T&gt; c) 指定比较器，并指定范围 [from, to) 8.3 排序 修饰 方法 说明 static void sort(T[] a) 数组排序 static void sort(T[] a, int fromIndex, int toIndex) 指定范围 [from, to) static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) 指定比较器 static &lt;T&gt; void sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; c) 指定比较器，并指定范围 [from, to) 8.4 复制 修饰 方法 说明 static &lt;T&gt; T[] copyOf(T[] original, int newLength) 将原数组复制到新数组并指定新数组长度，新数组长度大的话根据类型使用 0 false null 填充 static &lt;T&gt; T[] copyOfRange(T[] original, int from, int to) 复制原数组指定内容到新数组 8.5 填充 修饰 方法 说明 static void fill(T[], T val) 将数组所有元素用 val 替换 static void fill(T[], int fromIndex, int toIndex, T val) 将数组 [from, to) 范围的元素用 val 替换 8.6 相等比较 修饰 方法 说明 static boolean equals(T[] a1, T[] a2) 比较两个数组的长度和元素是否相等 static boolean deepEquals(Object[] a1, Object[] a2) 深度相等比较 8.7 toString 修饰 方法 说明 static String toString(T[] arr) 将数组元素以 [元素1, 元素2 ...] 格式拼接成一个字符串 8.8 流 修饰 方法 static IntStream stream(int[] array) static IntStream stream(int[] array, int startInclusive, int endExclusive) static LongStream stream(long[] array) static LongStream stream(long[] array, int startInclusive, int endExclusive) static DoubleStream stream(double[] array) static DoubleStream stream(double[] array, int startInclusive, int endExclusive) static &lt;T&gt; Stream&lt;T&gt; stream(T[] array) static &lt;T&gt; Stream&lt;T&gt; stream(T[] array, int startInclusive, int endExclusive)","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-Stream","slug":"Java/Java-Stream","date":"2020-09-29T08:02:42.000Z","updated":"2020-09-29T08:02:54.837Z","comments":true,"path":"2020/09/29/Java/Java-Stream/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-Stream/","excerpt":"","text":"一 概述 java.util.stream 包 流：从支持数据处理操作的源生成的元素序列 流不存储元素，只是对数据进行处理 流的操作不会修改数据源，而是返回一个持有结果的新流 惰性求值：流的中间操作形成一条流水线，但不会真正执行，只有在执行终端操作时才会一次性全部处理 流只能消费一次 集合关注的是数据存储，与内存打交道 流关注的是数据运算，与CPU打交道 二 流的操作2.1 特点 流水线 内部迭代 使用集合：需要用户去做迭代，这称为外部迭代 使用流：数据处理完全是在库内部进行的，这称为内部迭代 2.2 流程 流程 说明 1 创建流 通过一个数据源（如：集合、数组），获取一个流 2 中间操作 对数据源的数据进行 n 次处理，多个中间操作形成操作链（在终端操作前，并不会真正执行中间操作链） 3 终端操作 一旦执行终端操作，就执行中间操作链，最终产生结果并结束流 三 创建流3.1 由值创建流：java.util.stream.Stream 修饰 方法 说明 static &lt;T&gt; Stream&lt;T&gt; ofNullable(T t) 若 t 为 null ，则返回空流，否则返回包含 t 的流 static &lt;T&gt; Stream&lt;T&gt; empty() 获取一个不包含任何元素的空流 static &lt;T&gt; Stream&lt;T&gt; of(T... values) 获取一个有限流，元素固定 static &lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;? extends T&gt; s) 获取一个无限流，元素通过反复调用 s 生成 static &lt;T&gt; Stream&lt;T&gt; iterate(T seed, UnaryOperator&lt;T&gt; f) 获取一个无限流，元素： seed 为初始值，之后依次由上一个值通过 f 生成下一个值 static &lt;T&gt; Stream&lt;T&gt; iterate(T seed, Predicate&lt;? super T&gt; hasNext, UnaryOperator&lt;T&gt; f) 获取一个有限流，和无限流的区别是会在某个元素不满足 hasNext 时停止 3.2 由集合创建流： java.util.Collection&lt;E&gt; 修饰 方法 说明 default Stream&lt;E&gt; stream() 获取一个顺序流 default Stream&lt;E&gt; parallelStream() 获取一个并行流 3.3 由数组创建流：java.util.Arrays 修饰 方法 说明 static &lt;T&gt; Stream&lt;T&gt; stream(T[] array[, int start, int end]) 获取 Stream 流，可指定范围 [start, end) static IntStream stream(int[] array[, int start, int end]) 获取 IntStream 流，可指定范围 [start, end) static LongStream stream(long[] array[, int start, int end]) 获取 LongStream 流，可指定范围 [start, end) static DoubleStream stream(double[] array[, int start, int end]) 获取 DoubleStream 流，可指定范围 [start, end) 3.4 由文件生成流：java.nio.file.Files 修饰 方法 说明 static Stream&lt;String&gt; lines(Path path) 流元素为文件中的行，字符集默认为 UTF-8 static Stream&lt;String&gt; lines(Path path, Charset cs) 流元素为文件中的行，可指定字符集 四 中间操作4.1 筛选和切片 修饰 方法 说明 Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) 由所有符合条件的元素构成一个流 Stream&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate) 从第一个元素开始匹配，遇到不匹配就停止，由所有筛选出的元素构成一个流 Stream&lt;T&gt; dropWhile(Predicate&lt;? super T&gt; predicate) 从第一个元素开始匹配，由第一个不匹配的元素及其之后的所有元素构成一个流 Stream&lt;T&gt; distinct() 去重 Stream&lt;T&gt; limit(long maxSize) 限制数量 Stream&lt;T&gt; skip(long n) 跳过前 n 个元素，若数量不够则返回空流 4.2 排序 修饰 方法 说明 Stream&lt;T&gt; sorted() 自然排序 Stream&lt;T&gt; sorted​(Comparator&lt;? super T&gt; comparator) 定制排序 4.3 映射 修饰 方法 说明 &lt;R&gt; Stream&lt;R&gt; map​(Function&lt;? super T,​? extends R&gt; mapper) 流中每个元素映射为一个新元素，所有新元素组成流，新旧流元素个数相同 &lt;R&gt; Stream&lt;R&gt; flatMap​(Function&lt;? super T,​? extends Stream&lt;? extends R&gt;&gt; mapper) 流中每个元素都映射为一个流，所有流连接为一个新流（即映射成的每个流中的元素组成新流），新旧流元素个数可能不同 4.4 操作 修饰 方法 说明 Stream&lt;T&gt; peek​(Consumer&lt;? super T&gt; action) 流中元素不变，对每个元素进行一些操作 static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) 由流 a 的一个元素后跟流 b 的一个元素组成的元素构成一个流 五 终止操作5.1 迭代 修饰 方法 说明 void forEach​(Consumer&lt;? super T&gt; action) 迭代流中元素 Iterator&lt;T&gt; iterator() 旧式迭代器 5.2 统计 修饰 方法 说明 long count() 统计流中元素个数 5.3 匹配 修饰 方法 说明 boolean anyMatch​(Predicate&lt;? super T&gt; predicate) 是否有任意元素匹配 boolean allMatch​(Predicate&lt;? super T&gt; predicate) 是否全部元素都匹配 boolean noneMatch​(Predicate&lt;? super T&gt; predicate) 是否没有元素匹配 5.4 查找 修饰 方法 说明 Optional&lt;T&gt; findFirst() 返回流中第一个元素 Optional&lt;T&gt; findAny() 返回流中任意一个元素（如果是稳定流，也返回第一个元素） Optional&lt;T&gt; max​(Comparator&lt;? super T&gt; comparator) 返回流中最大元素，使用给定比较器定义的排序规则 Optional&lt;T&gt; min​(Comparator&lt;? super T&gt; comparator) 返回流中最小元素 5.5 归约 修饰 方法 说明 Optional&lt;T&gt; reduce​(BinaryOperator&lt;T&gt; accumulator) 元素1和元素2运算获取累计结果，结果再和下一个元素运算获取累计结果…，直到获取最终结果，由于流可能没有元素，所以返回 Optional T reduce​(T identity, BinaryOperator&lt;T&gt; accumulator) 同上，只是指定一个初始元素，由于肯定有值，所以不用返回 Optional 5.6 收集 修饰 方法 说明 &lt;R,A&gt; R collect​(Collector&lt;? super T,​A,​R&gt; collector) 使用指定收集器收集流中元素 Object[] toArray[] 收集到对象数组中 &lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator) 传入 A[]::new 收集到 A[] 类型数组中 六 流收集器6.1 收集器接口：Collector&lt;T,A,R&gt;12345678Supplier&lt;A&gt; supplier();BiConsumer&lt;A, T&gt; accumulator();Function&lt;A, R&gt; finisher();BinaryOperator&lt;A&gt; combiner();Set&lt;Characteristics&gt; characteristics();T：是流中要收集的元素的泛型。A：是累加器的类型，累加器是在收集过程中用于累积部分结果的对象。R 是收集操作得到的对象（通常但并不一定是集合）的类型 1 supplier：建立新的结果容器 supplier 方法必须返回一个结果为空的 Supplier ，调用此 Supplier 时创建一个空的累加器实例（结果容器），供数据收集过程使用 累加器类型为 A 2 accumulator：将元素添加到结果容器 accumulator 方法会返回执行归约操作的函数 返回的函数有两个参数（假设遍历到流中第 n 个元素） 保存归约结果的累加器（已收集了流中的前 n - 1 个项目） 第 n 个元素本身 3 finisher：对结果容器应用最终转换 在遍历完流后， finisher 方法必须返回在累积过程的最后要调用的一个函数，以便将累加器对象转换为整个集合操作的最终结果 如果累加器对象恰好符合预期的最终结果，则无需进行转换，只需返回 Function.identity() 4 combiner：合并两个结果容器 combiner 方法会返回一个供归约操作使用的函数，它定义了对流的各个子部分进行并行处理时，各个子部分归约所得的累加器要如何合并 并行流使用，将多个线程产生的结果容器合并 5 characteristics characteristics 会返回一个不可变的 Characteristics 集合，它定义了收集器的行为——尤其是关于流是否可以并行归约，以及可以使用哪些优化的提示 Characteristics 是一个包含三个项目的枚举 UNORDERED 归约结果不受流中元素的遍历和累积顺序的影响 CONCURRENT accumulator 函数可以从多个线程同时调用，且该收集器可以并行归约流 如果收集器没有标为 UNORDERED ，那它仅在用于无序数据源时才可以并行归约 IDENTITY_FINISH 表明完成器方法返回的函数是一个恒等函数，可以跳过。 这种情况下，累加器对象将会直接用作归约过程的最终结果。这也意味着，将累加器 A 不加检查地转换为结果 R 是安全的 6.2 预定于收集器：Collectors1 收集12345static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()static &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()toMap()toConcurrentMap()static &lt;T, C extends Collection&lt;T&gt;&gt; Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory) 工厂方法 返回类型 说明 toList List&lt;T&gt; 把流中所有项目收集到一个 List（类型不确定） toSet Set&lt;T&gt; 把流中所有项目收集到一个 Set（类型不确定），删除重复项 toCollection Collection&lt;T&gt; 把流中所有项目收集到给定的供应源创建的集合，既可以指定集合具体类型 2 归约和汇总1 统计个数，最小/大值123static &lt;T&gt; Collector&lt;T, ?, Long&gt; counting()static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; minBy(Comparator&lt;? super T&gt; comparator)static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? super T&gt; comparator) 工厂方法 返回类型 说明 counting Long 计算流中元素的个数 minBy Optional&lt;T&gt; 一个包裹了流中按照给定比较器选出的最小元素的 Optional ，或如果流为空则为 Optional.empty() maxBy Optional&lt;T&gt; 一个包裹了流中按照给定比较器选出的最大元素的 Optional ，或如果流为空则为 Optional.empty() 2 和/平均值1234567static &lt;T&gt; Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? super T&gt; mapper)static &lt;T&gt; Collector&lt;T, ?, Long&gt; summingLong(ToLongFunction&lt;? super T&gt; mapper)static &lt;T&gt; Collector&lt;T, ?, Double&gt; summingDouble(ToDoubleFunction&lt;? super T&gt; mapper)static &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingInt(ToIntFunction&lt;? super T&gt; mapper)static &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingLong(ToLongFunction&lt;? super T&gt; mapper)static &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;? super T&gt; mapper) 工厂方法 返回类型 说明 summingInt Integer 对流中元素的一个整数属性求和 summingLong Long 对流中元素的一个长整型属性求和 summingDouble Double 对流中元素的一个浮点型属性求和 averagingInt Double 对流中元素的一个整数属性求平均值 averagingLong Double 对流中元素的一个长整型属性求平均值 averagingDouble Double 对流中元素的一个浮点型属性求平均值 3 统计个数 + 最小/大值 + 和/平均值123static &lt;T&gt; Collector&lt;T, ?, IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;? super T&gt; mapper)static &lt;T&gt; Collector&lt;T, ?, LongSummaryStatistics&gt; summarizingLong(ToLongFunction&lt;? super T&gt; mapper)static &lt;T&gt; Collector&lt;T, ?, DoubleSummaryStatistics&gt; summarizingDouble(ToDoubleFunction&lt;? super T&gt; mapper) 工厂方法 返回类型 说明 summarizingInt IntSummaryStatistics 收集流中元素统计个数 + 最小/大值 + 和/平均值 summarizingLong LongSummaryStatistics 收集流中元素统计个数 + 最小/大值 + 和/平均值 summarizingDouble DoubleSummaryStatistics 收集流中元素统计个数 + 最小/大值 + 和/平均值 返回类型中提供了相应的 getter 方法 12345getCount()getMin()getMax()getSum()getAverage() 4 连接字符串123static Collector&lt;CharSequence, ?, String&gt; joining()static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter)static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix) 工厂方法 返回类型 说明 joining String 连接对流中每个元素调用 toString 方法所生成的字符串，可指定分隔符、前缀、后缀 5 广义的归约汇总123static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; reducing(BinaryOperator&lt;T&gt; op)static &lt;T&gt; Collector&lt;T, ?, T&gt; reducing(T identity, BinaryOperator&lt;T&gt; op)static &lt;T, U&gt; Collector&lt;T, ?, U&gt; reducing(U identity, Function&lt;? super T, ? extends U&gt; mapper, BinaryOperator&lt;U&gt; op) 工厂方法 返回类型 说明 reducing 归约操作产生的类型 从一个作为累加器的初始值开始，利用 BinaryOperator 与流中的元素逐个结合，从而将流归约为单个值 以上所有归约和汇总收集器都是 reducing 工厂方法定义的归约过程的特殊情况而已，仅仅是为了方便程序员使用而已 三个参数 初始值 转换函数 累计函数 3 分组1 分组123456// 一级分组：根据 T 的某个属性 K 分组，返回 Map&lt;K, list&lt;T&gt;&gt;static &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier)// 多级分组：根据 T 的某个属性 K 分组，返回 Map&lt;K, list&lt;T&gt;&gt;，之后使用第三个参数队属性 K 收集，返回 Map&lt;K, D&gt;static &lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Collector&lt;? super T, A, D&gt; downstream)// 多级分组：可以自己提供 Map 类型static &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt; Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Supplier&lt;M&gt; mapFactory, Collector&lt;? super T, A, D&gt; downstream) 工厂方法 返回类型 说明 groupingBy Map&lt;K, List&lt;T&gt;&gt; 根据元素某个属性映射的值分组，并作为键，元素收集到 List 中作为值（单参数的 groupingBy 其实第二个参数省略了 Collectors.toList()） groupingBy Map&lt;K, D&gt; 根据元素某个属性映射的值分组，并作为键，第二个收集器返回值作为值 groupingByConcurrent 返回的是 ConcurrentMap 2 常与分组联合使用的收集器1 collectingAndThen12// 将第一个参数（旧收集器）的结果传入第二个参数（转换函数）返回新的类型static &lt;T, A, R, RR&gt; Collector&lt;T, A, RR&gt; collectingAndThen(Collector&lt;T, A, R&gt; downstream, Function&lt;R, RR&gt; finisher) 工厂方法 返回类型 说明 collectingAndThen 转换函数返回的类型 包裹另一个收集器，对其结果应用转换函数 2 mapping1static &lt;T, U, A, R&gt; Collector&lt;T, ?, R&gt; mapping(Function&lt;? super T, ? extends U&gt; mapper, Collector&lt;? super U, A, R&gt; downstream) 工厂方法 返回类型 说明 mapping 转换函数返回的类型 原收集器中的每个元素映射为一个新值，并使用一个新收集器收集 4 分区1234// 一级分区static &lt;T&gt; Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate)// 多级分区static &lt;T, D, A&gt; Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate, Collector&lt;? super T, A, D&gt; downstream) 工厂方法 返回类型 说明 partitioningBy Map&lt;Boolean,List&lt;T&gt;&gt; 根据对流中每个元素应用谓词的结果来对元素进行分区 分区是分组的特殊情况：由一个谓词（返回一个布尔值的函数）作为分类函数，它称分区函数 分区函数返回一个布尔值，这意味着得到的分组 Map 的键类型是 Boolean ，即最多可以分为两组—— true 是一组， false 是一组 七 基本类型流7.1 概述 流操作基本类型时暗含装箱操作，Java8 提供了基本类型流来解决 IntStream：byte short char int boolean DoubleStream：float double LongStream：long IntStream DoubleStream LongStream 分别将流中的元素转为 int double long ，从而避免了暗含的装箱成本，且每个接口有新的常用数值归约方法以及转回对象流的方法 7.2 对象流与基本类型流的转换1 对象流 → 基本类型流123IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper)DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper)LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper) 2 基本类型流 → 对象流1234Stream&lt;Integer&gt; boxed()Stream&lt;Double&gt; boxed()Stream&lt;Long&gt; boxed()&lt;U&gt; Stream&lt;U&gt; mapToObj(IntFunction&lt;? extends U&gt; mapper) 7.3 IntStream 修饰 方法 说明 static IntStream range(int start, int end) [start, end) 范围内数值构成流 static IntStream rangeClosed(int start, int end) [start, end] 范围内数值构成流 int sum() 求和 OptionalInt max() 求最大值 OptionalInt min() 求最小值 long count() 统计个数 八 并行流8.1 概述 并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流 并行流背后使用的基础架构是 Java 7 中引入的分支/合并框架（Fork/Join） 8.2 转换 parallel()：顺序流 → 并行流 sequential()：并行流 → 顺序流 8.3 Spliterator&lt;T&gt; 1 概述 Spliterator 是 Java 8中加入的一个新接口；这个名字代表“可分迭代器”（splitable iterator） 和 Iterator 一样， Spliterator 也用于遍历数据源中的元素，但它是为了并行执行而设计的 Java 8 为集合框架中包含的所有数据结构提供了一个默认的 Spliterator 实现 2 API 修饰 方法 说明 boolean tryAdvance(Consumer&lt;? super T&gt; action) 按顺序一个一个使用 Spliterator 中的元素，并且如果还有元素要遍历就返回 true Spliterator&lt;T&gt; trySplit() 把一些元素划出去分给第二个 Spliterator （由该方法返回），让它们两个并行处理。当返回 null 时 ，表明它处理的数据结构不能再分割 long estimateSize() 估计还剩下多少元素要遍历 int characteristics() 返回一个 int ，代表 Spliterator 本身特性集的编码 3 特性 特性 int 说明 ORDERED 元素有既定的顺序（例如 List ），因此 Spliterator 在遍历和划分时也会遵循这一顺序 DISTINCT 对于任意一对遍历过的元素 x 和 y ， x.equals(y) 返回 false SORTED 遍历的元素按照一个预定义的顺序排序 SIZED 该 Spliterator 由一个已知大小的源建立（例如 Set ），因此 estimatedSize() 返回的是准确值 NONNULL 保证遍历的元素不会为 null IMMUTABLE Spliterator 的数据源不能修改。这意味着在遍历时不能添加、删除或修改任何元素 CONCURRENT 该 Spliterator 的数据源可以被其他线程同时修改而无需同步 SUBSIZED 该 Spliterator 和所有从它拆分出来的 Spliterator 都是 SIZED 九 java.util.Optional&lt;T&gt;9.1 概述 Optional&lt;T&gt; 是一种包装器对象，且只包装一个对象：T 或 null 对象存在时，则返回封装对象的 Optional 对象不存在时，由方法 Optional.empty() 返回一个空的 Optional 使用原则 不能为 null 的属性正常声明 T 可能为 null 的属性声明为 Optional&lt;T&gt; Optional&lt;T&gt; 也有三个基本类型版本：OptionalInt、OptionalDouble、OptionalLong 9.2 API1 创建 Optional 修饰 方法 说明 static &lt;T&gt; Optional&lt;T&gt; empty() 返回空的 Optional static &lt;T&gt; Optional&lt;T&gt; of​(T t) 将指定值用 Optional 封装之后返回，如果该值为 null ，则抛出一个 NullPointerException 异常 static &lt;T&gt; Optional&lt;T&gt; ofNullable​(T t) 将指定值用 Optional 封装之后返回，如果该值为 null ，则返回一个空的 Optional 对象 2 获取 Optional 容器中的值 修饰 方法 说明 T get() 如果值存在则返回，否则抛 NoSuchElementException 异常 T orElse​(T other) 如果值存在则返回，否则返回 other T orElseGet​(Supplier&lt;? extends T&gt; supplier) 如果值存在则返回，否则返回由 Supplier 提供的值 &lt;X extends Throwable&gt; T orElseThrow​(Supplier&lt;? extends X&gt; exceptionSupplier) 如果值存在则返回，否则抛出由 Supplier 提供的异常 3 操作 Optional 中的值 修饰 方法 说明 boolean isPresent() 如果值存在就返回 true ，否则返回 false void ifPresent​(Consumer&lt;? super T&gt; action) 如果值存在则传递给 action 执行；否则就不进行任何操作 void ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction) 如果值存在则传递给 action 执行；否则调用 emptyAction &lt;U&gt; Optional&lt;U&gt; map​(Function&lt;? super T,​? extends U&gt; mapper) 如果值存在则映射一个新值（如果映射值为 null 会空指针异常），然后返回存储新值的 Optional；否则返回空的 Optional &lt;U&gt; Optional&lt;U&gt; flatMap​(Function&lt;? super T,​? extends Optional&lt;? extends U&gt;&gt; mapper) map 方法的问题在于如果映射成的值还是一个 Optional，会形成多层 Optional&lt;Optional&lt;T&gt;&gt;，此方法能将多层的 Optional 合并为一个 Optional&lt;T&gt; filter​(Predicate&lt;? super T&gt; predicate) 如果值存在并且满足提供的谓词，就返回包含该值的 Optional 对象；否则返回空的 Optional 对象 Optional&lt;T&gt; or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier) 如果值存在，则返回存储此值的 Optional，否则返回由 Supplier 提供的 Optional 4 其它 修饰 方法 说明 Stream&lt;T&gt; stream() 如果值存在则获取只包含此元素的流，否则获取空流","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-Lambda","slug":"Java/Java-Lambda","date":"2020-09-29T08:01:27.000Z","updated":"2020-09-29T08:01:40.791Z","comments":true,"path":"2020/09/29/Java/Java-Lambda/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-Lambda/","excerpt":"","text":"一 Lambda 概述 Lambda 是一个匿名函数，但在 Java 中 Lambda 表达式的本质是函数式接口的一个实例，也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用 Lambda 表达式来表示 Lambda 需要函数式接口的支持 闭包 在 Lambda 表达式中引用了局部变量，会形成闭包，延长局部变量声明周期 此被引用的局部变量会变成 final 的 二 Lambda 语法2.1 基础语法123(形参列表) -&gt; &#123;方法体&#125;// 形参列表：对应函数式接口中抽象方法的形参列表// 方法体：即重写的函数式接口中抽象方法的方法体 参数类型可以省略（类型推断） 当且仅当参数只有一个时，可以省略小括号 如果方法体只有一句，可以省略大括号 如果方法体只有一句且是返回语句，大括号和 return 要一致 省略大括号的同时必须省略 return 关键字 不省略大括号那么也不能省略 return 关键字 2.2 方法引用1 概述 方法引用即将 Lambda 表达式的实现指向一个已经实现的方法，也就是说通过调用一个现有的方法来完成功能 方法引用其实返回的就是一个函数式接口的实例 1234// 只要符合条件就能当成对应函数式接口的实例// 所谓的符合条件：引用的方法与函数式接口的抽象方法有着相同形参和返回值，比如接收一个类型的参数，返回另一个类型...Consumer consumer = System.out::println;Runable runable = System.out::println; 条件 引用方法的形参列表（数量、顺序和类型）必须与接口中的方法一致 特殊情况：接口中方法的第一个形参是方法的调用者，剩余形参与引用方法一致（即指向类的实例方法的方法引用） 引用方法的返回值必须和接口中的方法一致 2 语法1234567// 语法方法隶属者::方法名// 有三种使用情况对象::实例方法名类::静态方法名类::实例方法名 指向对象的实例方法的方法引用 12(args) -&gt; expr.instanceMethod(args)expr::instanceMethod 指向类的静态方法的方法引用 12(args) -&gt; ClassName.staticMethod(args)CLassName::staticMethod 指向类的实例方法的方法引用 123(arg0, rest) -&gt; arg0.instanceMethod(rest)CLassName::instanceMethod// arg0 是 ClassName 类型的实例，即是实例方法的调用者又是方法的第一个参数 2.3 构造器引用1类::new 构造器形参列表要与函数式接口中抽象方法的形参列表一致 新创建的对象与函数式接口中抽象方法的返回值一致 2.4 数组引用1数组类型[]::new 可以把数组看作一个构造器 三 函数式接口3.1 概述 SAM：Simple Abstract Method 有且仅有一个抽象方法的接口就是函数式接口，可以有其它方法（静态，默认…） @FunctionalInterface：此注解用来标识函数式接口 java.lang.util.function 包下定义了许多函数式接口 3.2 常用函数式接口 函数式接口 参数类型 返回类型 接口方法 说明 原始类型特化 Predicate&lt;T&gt; T boolean boolean test(T t) 传入 T，返回布尔值 IntPredicateLongPredicateDoublePredicate BiPredicate&lt;T, U&gt; T, U boolean boolean test(T t, U u) 传入 T U，返回布尔值 Consumer&lt;T&gt; T void void accept(T t) 传入 T，无返回 IntConsumerLongConsumerDoubleConsumer BiConsumer&lt;T, U&gt; T, U void void accept(T t, U u) 传入 T U，无返回 ObjIntConsumer&lt;T&gt;ObjLongConsumer&lt;T&gt;ObjDoubleConsumer&lt;T&gt; Supplier&lt;T&gt; 无 T T get() 无传入，返回 T IntSupplierBooleanSupplierLongSupplierDoubleSupplier Function&lt;T, R&gt; T R R apply(T t) 传入 T，返回 R IntFunction&lt;R&gt;LongFunction&lt;R&gt;DoubleFunction&lt;R&gt;ToIntFunction&lt;T&gt;ToLongFunction&lt;T&gt;ToDoubleFunction&lt;T&gt;IntToLongFunctionIntToDoubleFunctionLongToIntFunctionLongToDoubleFunction UnaryOperator&lt;T&gt; T T T apply(T t) 传入 T，返回 T，继承 Function&lt;T, T&gt; 接口 IntUnaryOperatorLongUnaryOperatorDoubleUnaryOperator BiFunction&lt;T, U, R&gt; T, U R R apply(T t, U u) 传入 T U ，返回 R ToIntBiFunction&lt;T,U&gt;ToLongBiFunction&lt;T,U&gt;ToDoubleBiFunction&lt;T,U&gt; BinaryOperator&lt;T&gt; T, T T T apply(T t1, T t2) 传入 T T ，返回 T，继承 BiFunction&lt;T, T, T&gt; 接口 IntBinaryOperatorLongBinaryOperatorDoubleBinaryOperator Runnable 无 void void run() 无传入，无返回 Comparator&lt;T&gt; T, T int int compare(T t1, T t2) 传入 T T，返回 int 3.3 复合 Lambda 表达式的有用方法1 比较器复合12逆序：reversed比较器链：thenComparing 2 谓词复合123非：negate与：and或：or 3 函数复合1234andThen f.anThen(g)：先执行 f 后 执行 g，即 g(f(x))compose f.compose(g)：先执行 g 后 执行 f，即 f(g(x))","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-网络编程","slug":"Java/Java-网络编程","date":"2020-09-29T08:00:45.000Z","updated":"2020-09-29T08:01:02.601Z","comments":true,"path":"2020/09/29/Java/Java-网络编程/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"一 概述1.1 网络模型1 OSI（Open System Interconnection） 层 说明 相关协议 应用层 网络服务和最终用户的接口 HTTP HTTPS FTP SMTP POP3 DNS ... 表示层 数据的表示、安全、压缩 会话层 建立、管理和终止会话 传输层 定义传输数据的协议端口号，以及流量控制和差错校验 TCP UDP 网络层 进行逻辑地址寻找，实现不同网络间的路径选择 IP ARP RARP ICMP IGMP ... 数据链路层 建立逻辑连接、进行硬件地址寻址、差错校验等功能 MAC 地址 物理层 建立，维护，断开物理连接 2 TCP/IP 分层模型 层 相关协议 应用层 HTTP HTTPS FTP DNS ... 传输层 TCP UDP 网络层 IP ARP ICMP... 物理+数据链路层 硬件层面 1.2 网络编程 目的：直接或间接的通过网络协议与其它计算机通信，进行数据交换 两个问题： 如何准确定位网络上的一台或多台主机，以及如果定位主机上特定的应用 定位后，如何可靠高速的进行数据传输 1.3 网络通信三要素 IP 地址：确定设备 端口：确定设备上的程序 网络协议 1.4 常见端口 服务 端口 HTTP 80 HTTPS 443 SSH 22 Tomcat 8080 MySQL 3306 Oracle 1521 SMTP 25 POP3 110 二 java.net.InetAddress2.1 概述 用来包装 IP 地址对象 子类 Inet4Address Inet6Address 2.2 方法1 获取 IP 对象 修饰 方法 说明 static InetAddress getLocalHost() 获取本地主机 IP 对象，等价于 getByName(&quot;127.0.0.1&quot;) static InetAddress getByName​(String host) 根据主机名（ip 或 域名）获取 IP 对象 2 获取主机信息 修饰 方法 说明 String getHostName() 获取主机名（域名） String getHostAddress() 获取主机 IP 地址 三 Socket3.1 概述 IP 和端口组合得出一个网络套接字：Socket Socket 是网络通信的一种机制，是两台机器间通信的端点 分类 流套接字（TCP） 数据报套接字（UDP） 类 说明 java.net.Socket TCP 客户端 Socket java.net.ServerSocket TCP 服务端 Socket java.net.DatagramSocket UDP Socket java.net.DatagramPacket UDP 数据包 3.2 TCP1 java.net.Socket（客户端）1 构造 构造 说明 Socket​(String host, int port) 指定服务端主机地址，以及要连接的服务端口 Socket​(InetAddress address, int port) 指定服务端主机 IP 地址对象，以及要连接的服务端口 2 方法 修饰 方法 说明 InputStream getInputStream() 获取字节输入流 OutputStream getOutputStream() 获取字节输出流 InetAddress getLocalAddress() 获取 Socket 绑定的本地主机 IP 对象 InetAddress getInetAddress() 获取 Socket 连接的主机 IP 对象 void shutdownInput() 关闭 Socket 输入通道 void shutdownOutput() 关闭 Socket 输出通道 void close() 关闭 Socket，会自动关闭流 2 java.net.ServerSocket（服务端）1 构造 构造 说明 ServerSocket​(int port) 指定服务监听端口 2 方法 修饰 方法 说明 Socket accept() 等待并接收客户端连接，阻塞方法 void close() 关闭 Socket，会自动关闭流 3 应用1 客户端 创建 Socket 对象 使用 Socket 对象获取输入输出流来读写 关闭 Socket 2 服务端 创建 ServerSocket 对象，指定监听端口 使用 ServerSokcet 接收客户端 Socket 使用 Socket 对象获取输入输出流来读写 关闭 Socket 4 注意：如果服务端和客户端都等待 数据没有刷新，使用 BufferedReader 包装字节输入流时，readLIne() 结束标记是换行符 使用 PrintStream 包装字节输出流，可以自动刷新，如使用 println() 使用 PrintWrter 包装字节输出流，使用 println() 需要手动刷新或者构造函数中设置自动刷新 使用 BufferedWriter 包装字节输出流，输出后需要 newLine() 阻塞式方法没有结束标记 void shutdownInput() ``void shutdownOutput()` 5 服务端接收多个客户端连接 将每个客户端的业务封装为线程任务 使用多线程实现 12345ServerSocket ss=new ServerSocket(8866);while (true) &#123; Socket socket = ss.accept(); new ClientTask(socket).start();&#125; 3.3 UDP1 java.net.DatagramSocket1 构造 构造 说明 DatagramSocket() 发送端不用指定端口 DatagramSocket(int port) 接收端需要指定端口 2 方法 修饰 方法 说明 void send(DatagramPacket p) 发送数据包 void receive(DatagramPacket p) 接收数据包 void close() 关闭 Socket，会自动关闭流 2 java.net.DatagramPacket1 构造 构造 说明 DatagramPacket​(byte[] buf, int length) 接收端接收数据包 DatagramPacket​(byte[] buf, int length, InetAddress address, int port) 发送端打包需要指定接收端 IP 和 Port 2 方法 修饰 方法 说明 byte[] getData() 接收的数据 int getLength() 接收的数据实际长度 3 应用1 发送端 创建 DatagramSocket，不需端口 创建 DatagramPacket 数据包，指定数据存储数组，长度，接收端 IP 和 Port 发送数据包 关闭 DatagramSocket 2 接收端 创建 DatagramSocket，指定端口 创建 DatagramPacket，指定数据存储数组，长度 接收数据包 从数据包提取数据 关闭 DatagramSocket 四 java.net.URL4.1 构造 构造 说明 URL​(String spec) 根据 URL 地址字符串构造 URL 对象 URL​(String protocol, String host, int port, String file) 根据指定 protocol、host、port 号和 file 创建 URL 对象 4.2 方法 修饰 方法 说明 String getProtocol() 获取此 URL 的协议名称 String getHost() 获取此 URL 的主机地址 int getPort() 获取此 URL 的端口号 String getFile() 获取此 URL 的文件资源路径（完整 URI） String getPath() 获取此 URL 的路径部分（URI不带参数） String getQuery() 获取此 URL 的查询部分（参数） URLConnection openConnection() 返回一个 URLConnection 对象，它表示到 URL 所引用的远程对象的连接 InputStream openStream() 打开到此 URL 的连接并返回一个用于从该连接读入的 InputStream 五 java.net.URLConnection5.1 概述 URL 连接器对象 表示与 URL 建立的通信连接 5.2 方法 修饰 方法 说明 URL getURL() 获取此链接的 URL 对象 abstract void connect() 连接 InputStream getInputStream() 获取此链接的字节输入流 OutputStream getOutputStream() 获取此连接的字节输出流","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-反射","slug":"Java/Java-反射","date":"2020-09-29T07:59:44.000Z","updated":"2020-09-29T08:00:02.273Z","comments":true,"path":"2020/09/29/Java/Java-反射/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-%E5%8F%8D%E5%B0%84/","excerpt":"","text":"一 反射1.1 概述 反射 Reflection 允许程序在运行期间： 获取任意类型的详细信息 创建任意类型的对象 读写任意对象的任意属性 调用任意对象的任意方法 读取某个注解信息 读取某个类的泛型信息 生成动态代理 。。。 加载完类之后，在方法区中旧产生了一个 Class 对象（一个类对应一个），此对象包含了类的完整结构信息 1.2 动态语言 &amp; 静态语言 动态语言： 运行时可以根据某些条件改变自身结构 Object-C、C#、JavaScript、PHP、Python、Erlang 静态语言： 运行时结构不可变 Java、C、C++ Java 不是动态语言，但有一定的动态性（利用反射） 二 Java 类型2.1 概述 类型 说明 例 Type Java 中所有类型的公共高级接口 Class 普通类型（类，接口，数组，枚举，注解，基本数据类型，void），没有泛型信息 Person ParameterizedType 参数化类型（即泛型） Map&lt;String, Integer&gt;，List&lt;T&gt; GenericArrayType 泛型数组类型 T[]，List&lt;T&gt;[] TypeVariable&lt;D&gt; 类型变量（即泛型中的变量） T K V WildcardType 带通配符 ? 的类型 List&lt;?&gt;，List&lt;? extends Object&gt; 2.2 ParameterizedType 修饰 方法 说明 Type[] getActualTypeArguments() 获取泛型的实际类型，泛型可能有多个，所以返回数组（该方法只返回最外层的&lt;&gt;中的类型，无论该&lt;&gt;内有多少个&lt;&gt;） Type getRawType() 获取声明泛型的类或者接口，也就是泛型中&lt;&gt;前面的那个值 Type getOwnerType() 获取泛型的拥有者，例如： Map 就是 Map.Entry&lt;String,String&gt; 的拥有者 三 java.lang.ClassLoader3.1 获取 ClassLoader123456789// 1 获取当前类的 ClassLoaderclazz.getClassLoader()// 2 获取当前线程上下文的 ClassLoaderThread.currentThread().getContextClassLoader()// 3 获取系统的 ClassLoaderClassLoader.getSystemClassLoader()// 4 获取调用者的 ClassLoaderDriverManager.getCallClassLoader()Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len) 3.2 API 修饰 方法 说明 Class&lt;?&gt; loadClass​(String name) 加载指定全限定名的类，返回 Class 对象 protected Class&lt;?&gt; findClass(String name) 查找指定全限定名的类，返回 Class 对象 protected Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len) 将字节数组转为一个 Class 对象 InputStream getResourceAsStream​(String name) 获取指定资源文件的流 URL getResource​(String name) 获取指定资源文件的 URL 对象 ClassLoader getParent() 获取父加载器 3.3 Class 和 ClassLoader 获取资源1 说明123456789101112131415// 编译前App src a b Test.java hello.xml// 编译后App WEB-INF classes a b Test.class hello.xml Class 和 ClassLoader 资源路径都是相对于编译后的工程结构来说 getResource() 和 getResourceAsStream() 两个方法路径用法是一样的 2 Class 相对路径：相对于当前类的 .class 文件路径 1class.getResouce(\"hello.xml\") 绝对路径：/ 代表 classpath 根路径，即 classes 目录 1class.getResource(\"/a/b/hello.xml\") 3 ClassLoader 默认就是从 classpath 下寻找资源，所以不能写 / 1classLoader.getResource(\"a/b/hello.xml\") 4 文件流 文件流是相对于当前工程 四 java.lang.Class4.1 获取 Class 对象的方式 方式 说明 类.class 编译期这个类型就要存在 类对象.getClass() 需要先创建对象 Class.forName(&quot;全限定类名&quot;) 类型可以在编译期未知，类名可以在代码中或配置文件中等等 类加载器对象.loadClass(&quot;全限定类名&quot;) 一般用在自定义类加载器去加载指定路径的类 4.2 API1 获取 Class 和 ClassLoader 修饰 方法 说明 static Class&lt;?&gt; forName​(String className) 根据全限定类名获取 Class 对象 ClassLoader getClassLoader() 获取类加载器对象 2 获取类信息 修饰 方法 说明 Package getPackage() 获取包 String getPackageName() 获取包名 String getName() 获取类名 int getModifiers() 获取类修饰符编号 mod Class&lt;? super T&gt; getSuperclass() 获取父类（不带泛型） Type getGenericSuperclass() 获取带泛型的父类 Class&lt;?&gt;[] getInterfaces() 获取所有实现的接口（不带泛型） Type[] getGenericInterfaces() 获取所有实现接口（带泛型） 3 获取构造器 Constructor 修饰 方法 说明 Constructor&lt;?&gt;[] getConstructors() 获取本类所有 public 构造器 Constructor&lt;?&gt;[] getDeclaredConstructors() 获取本类所有构造器 Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 获取本类指定参数类型的 public 构造器 Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) 获取本类指定参数类型的构造器 4 获取属性 Field 修饰 方法 说明 Field[] getFields() 获取本类及父类的所有 public 属性 Field[] getDeclaredFields() 获取本类的所有属性 Field getField​(String name) 获取本类及父类中指定名称的 public 属性 Field getDeclaredField​(String name) 获取本类中指定名称的属性 5 获取方法 Method 修饰 方法 说明 Method[] getMethods() 获取本类及父类的所有 public 方法 Method[] getDeclaredMethods() 获取本类的所有方法 Method getMethod​(String name, Class&lt;?&gt;... parameterTypes) 获取本类及父类中指定方法名和参数类型的 public 方法 Method getDeclaredMethod​(String name, Class&lt;?&gt;... parameterTypes) 获取本类中指定方法名和参数类型的方法 6 获取注解 Annotation 修饰 方法 说明 Annotation[] getAnnotations() 获取类上的所有注解 &lt;A extends Annotation&gt; A getAnnotation​(Class&lt;A&gt; annotationClass) 获取类上指定注解类型的注解 五 java.lang.reflect 包5.1 概述 类 说明 AccessibleObject 访问修饰符控制 Modifier 修饰符 Constructor&lt;T&gt; 构造器 Field 属性 Method 方法 Proxy 代理 5.2 Modifier1 属性 修饰 属性 static int PUBLIC static int PRIVATE ... 此类为修饰符定义了常量值 123public static final int PUBLIC = 0x00000001;public static final int PRIVATE = 0x00000002;... 2 方法 修饰 方法 说明 static String toString(int mod) 获取编号对应的修饰符 5.3 AccessibleObject 修饰 方法 说明 Annotation[] getAnnotations() 获取当前元素（构造、属性、方法）上的所有注解 &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) 获取当前元素上的指定类型的注解 void setAccessible​(boolean flag) true 表示不启用 Java 访问修饰符的检查，可以访问非 public 修饰的成员 5.4 Constructor1 构造器信息 修饰 方法 说明 int getModifiers() 获取构造方法修饰符 String getName() 获取构造方法名 Class&lt;?&gt;[] getParameterTypes() 获取构造方法形参类型列表 2 构造器操作 修饰 方法 说明 T newInstance​(Object... initargs) 使用构造器创建对象 5.4 Field1 属性信息 修饰 方法 说明 int getModifiers() 获取属性修饰符 Class&lt;?&gt; getType() 获取属性类型 String getName() 获取属性名 2 属性操作 修饰 方法 说明 Object get​(Object obj) 获取指定对象此属性的值 void set​(Object obj, Object value) 为指定对象设置此属性的值 5.5 Method1 方法信息 修饰 方法 说明 int getModifiers() 获取方法修饰符 Class&lt;?&gt; getReturnType() 获取返回值类型 String getName() 获取方法名 Class&lt;?&gt;[] getParameterTypes() 获取方法形参类型列表 Class&lt;?&gt;[] getExceptionTypes() 获取抛出异常类型列表 2 方法操作 修饰 方法 说明 Object invoke​(Object obj, Object... args) 调用非静态方法传入指定对象，调用静态方法传入 null 或 类.class 5.6 Proxy 修饰 方法 说明 static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 创建代理对象 六 应用 List&lt;Integer&gt; 中添加字符串 123456// 泛型只在编译期，在运行期通过反射即可实现ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();Class&lt;?&gt; clazz = Class.forName(\"java.util.ArrayList\");Method method = clazz.getMethod(\"add\", Object.class);method.invoke(list, \"哈哈哈\");System.out.println(list);","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-多线程","slug":"Java/Java-多线程","date":"2020-09-29T07:57:44.000Z","updated":"2020-09-29T07:57:58.922Z","comments":true,"path":"2020/09/29/Java/Java-多线程/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"一 概念1.1 同步（Synchronous）&amp; 异步（Asynchronous） 同步和异步都用来形容一次方法调用 同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为 异步方法调用一旦开始，方法调用会立即返回，调用者可以继续后续操作，而异步方法通常会在另一个线程中 “真实” 的执行。异步调用的整个过程不会阻碍调用者的工作，如果异步调用需要返回结果，那么当此异步调用真正完成时，会通知调用者。 1.2 并发（Concurrency）&amp; 并行（Parallelism） 并发： 同一时间多个任务交替执行，只是切换速度较快，看起来是同时执行而并非真正同时执行 同一时间应对多件事情的能力 并行： 同一时间多个任务真正的同时执行 同一时间做多件事情的能力 1.3 进程（Process）&amp; 线程（Thread） 进程： 正在运行的程序的实例，是系统进行资源分配的基本单位 进程是容纳线程的容器 线程： 线程是调度 CPU 的基本单位 进程中的一条执行路径，一个进程至少有一个线程 线程是程序执行的最小单位 二 体系 Runnable 和 Callable 都可以作为线程的任务 Runnable 没有返回值，不能抛异常 Callable 有返回值，能抛异常，主要用于线程池 Future 用来存储将会产生的结果 FutureTask 技能存储结果也能作为任务，相当于 Future + Runnable 三 Thread3.1 创建线程12345678910// 1 使用 Thread 自身的任务Thread()Thread(String name)Thread(ThreadGroup group, String name)// 2 使用 Runnable 任务Thread(Runnable target)Thread(Runnable target, String name)Thread(ThreadGroup group, Runnable target)Thread(ThreadGroup group, Runnable target, String name) 若不指定线程名称，默认为 Thread-0,1,2... 若不指定线程组，默认为父线程（创建此线程的线程）的线程组 构造函数中的 statcksize 代表该线程占用的栈大小，如果未指定，默认为 0，0 代表忽略该参数，该参数会被 JNI 函数去使用。（该参数有些平台有效，有些则无效） 3.2 启动线程 修饰 方法 说明 void start() 启动线程 void run() 子类必须重写，任务方法 static void sleep(long millis)` 控制线程休眠若干毫秒 3.3 线程信息 修饰 方法 说明 String getName() 获取线程名称 void setName(String name) 设置线程名字 long getId() 获取线程 ID Thread.state getState() 获取线程状态 static Thread currentThread() 获取当前线程对象 3.4 加入线程 修饰 方法 说明 void join() 当前线程阻塞，等待插入线程执行完毕 void join(long millis) 当前线程阻塞，等待插入线程执行完毕，但最多只等待指定时间 void join(long millis, int nanos) 时间更精确一点 3.5 中断线程 修饰 方法 说明 void interrupt() 1 运行线程： 设置中断标志位，不代表会退出线程2 阻塞线程（ wait join sleep）：终止阻塞状态并抛出 InterruptedException 异常，且清除中断标志位 static boolean interrupted() 判断当前线程是否被中断，会清除中断标志位 boolean isInterrupted() 判断此线程是否中断，不会清除中断标志位 每个线程都有一个表示 中断状态 的 boolean 标记 每个线程都应该不时检查此标记，以判断线程是否被中断 3.6 守护线程 修饰 方法 说明 void setDaemon(boolean on) 是否将线程设置为守护线程，必须在线程启动前调用 boolean isDaemon 判断是否是守护线程 3.7 礼让线程 修饰 方法 说明 static void yield() 让出本次 CPU 执行权，加入下一次的抢夺中，效果不明显 3.8 线程组 修饰 方法 说明 ThreadGroup getThreadGroup() 获取线程所在线程组 1 概述 线程组可以对一批线程进行分类管理，Java 允许程序直接对线程组进行控制 创建线程对象时，如果未指定线程组，则默认为父线程的线程组 主线程的线程组为 main 2 ThreadGroup1 构造 构造 说明 ThreadGroup(String name) 创建线程组并指定名称 ThreadGroup(ThreadGroup parent, String name) 创建线程组并指定父线程组及名称 2 方法 修饰 方法 说明 String getName() 获取线程组名称 ThreadGroup getParent() 获取线程组的父线程组 int activeCount() 获取线程组中活动线程数 int enumerate(Thread[] list) 枚举线程组中的活动线程 3.9 线程优先级 修饰 方法 说明 int getPriority() 获取线程优先级 void setPriority(int newPriority) 设置线程优先级 1-10，仅仅是概率增加了，玄不改命 Thread.MIN_PRIORITY 最小优先级 1 Thread.NORM_PRIORITY 默认优先级 5 Thread.MAX_PRIORITY 最大优先级 10 四 线程状态 状态 说明 New 新建状态 Runnable 可运行状态：一个线程可能正在运行也可能没有运行 Blocked 阻塞状态 Waiting 无限等待 Timed waiting 限时等待 Terminated 终止状态：正常结束或异常意外终止 五 终止线程 stop() 已过时 stop() 方法过于暴力，会强行把执行到一半的线程终止，可能会引起一些数据不一致的问题 suspend() resume() 已过时 挂起和恢复线程这两个方法同样会破坏同步 定义标记，自行决定线程何时退出 Two Phase Termination：两阶段终止模式 通过中断标记实现 volatile 实现 六 JMM6.1 CPU 缓存1 概述 读写速度（离 CPU 越近，速度越快）：寄存器 &gt; cache L1 &gt; cache L2 &gt; cache L3 &gt; 内存 &gt; 硬盘 cache line 是 cache 的最小存储单元 在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，这就有了缓存一致性（CacheCoherence）问题 为了解决一致性的问题，有许多协议，如 MSI、MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol，等等 2 MESI 缓存一致性协议 状态 说明 M（Modified） 该 cache line 有效，数据被修改了，和内存中的数据不一致，数据只存在于本 Cache 中 E（Exclusive） 该 cache line 有效，数据和内存中的数据一致，数据只存在于本 Cache 中 S（Shared） 该 cache line 有效，数据和内存中的数据一致，数据存在于多个 Cache 中 I（Invalid） 该 cache line 无效 内存中数据，只有一个 cache 中有，则为独占状态 E 当不止一个 cache 中有时，则全为共享状态 S 当某个 cache 修改了数据，则其变为修改状态 M，且其它 cache 变为无效状态 I 多个 CPU 从主内存读取同一个数据到各自的高速缓存，当其中某个 CPU 修改了缓存里的数据，该数据会马上同步回主内存，其它 CPU 通过 总线嗅探机制 （类似于事件监听）可以感知到数据的变化从而将自己缓存里的数据失效 底层实现通过汇编 lock 指令 锁定这块内存区域的缓存（缓存行锁定），并立即将修改数据写回系统内存 这个写回内存的操作会引起在其它 CPU 里缓存了该内存地址的数据无效 6.2 JMM 概述 Java Memory Model Java内存模型是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式 实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享，受到内存模型控制 局部变量，方法参数，异常处理参数不会在线程之间共享，不受内存模型影响 相关概念 临界区 Critical Section 表示一种公共资源或共享数据，可以被多个线程使用，但每次只能有一个线程使用，一旦临界区资源被占用，其它线程就必须等待 一段代码内如果存在对共享数据的多线程读写操作，则这段代码称为临界区 竞态条件 Race Condition 多个线程在临界区内执行，由于代码执行序列不同而导致结果无法预测，称为发生了竞态条件 为避免临界区的竞态条件发生 阻塞式解决方案：synchronized, Lock 非阻塞式解决方案：原子变量 CAS 同步和互斥 同步：是由于线程执行的顺序不同，需要一个线程等待其它线程运行到某个点 互斥：保证同一时刻只有一个线程执行临界区代码 6.3 JMM 内存交互操作（原子操作） 操作 作用对象 说明 read 主内存 从主内存读取数据到工作内存中 load 工作内存 将 read 读取的数据载入工作内存变量副本中 use 工作内存 从工作内存读取数据传递给执行引擎计算 assign 工作内存 将执行引擎计算好的值重新赋值给工作内存 store 工作内存 将工作内存数据传送到主内存 write 工作内存 将 stroe 传送的数据赋值给主内存的变量 lock 主内存 将主内存变量加锁，标记为线程独占状态 unlock 主内存 将主内存变量解锁，解锁后才可以被其他线程锁定 6.4 JMM 特性1 原子性 Atomicity 原子性指一个操作是不可分割的单元，是不可中断的，要嘛都执行，要嘛都不执行 一个原子性操作一旦开始，就不会被其它线程干扰，而一个非原子性操作，在多线程环境下有可能被其它线程所干扰 从一个线程观察另外一个线程的时候，看到的都是一个个原子性的操作 例 1234567synchronized (this) &#123; a = 1; b = 2;&#125;从一个线程观察另一个线程执行上述代码，只有两种结果 1 a,b 都被赋值成功 2 a,b 都未被赋值 2 可见性 Visibility 可见性指当一个线程修改了某个共享变量后，其他线程是否能够立即知道这个修改 每个线程都有自己的工作内存，所以当线程修改完某个变量之后，在其他的线程中，未必能观察到该变量已经被修改 3 有序性 Ordering 指令重排序 JVM 在不影响正确性的前提下，可以调整指令的执行顺序，这种特性称之为『指令重排』，指令重排可以提高 CPU 的处理性能 as-if-serial 语义：不管如何重排序，必须保证串行语义一致，即单线程下，程序的执行结果不会改变 指令重排在多线程下有可能影响正确性 6.5 Happens-Before 规则1 概述 happens-before 规则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据 可以通过此规则分析一个并发程序是否安全 如果 A happens-bofore B，则 A 操作先于 B 操作发生，且 A 操作的结果对 B 可见 2 规则 规则 说明 程序顺序规则（Program Order Rule） 一个线程内保证语义的串行性，即按照代码顺序执行，前面的操作 happens-before 后续的任何操作 管程锁定规则（Monitor Lock Rule） 同一个锁的解锁操作 happens-before 后续对这个锁的加锁操作 volatile 变量规则（volatile Variable Rule） volatile 变量的写操作，happens-before 后续对这个变量的读操作 线程启动规则（Thread Start Rule） 线程 start() 方法 happens-before 线程中的每一个操作 线程终止规则（Thread Termination Rule） 线程的所有操作 happens-before 线程的终结 线程中断规则（Thread Interruption Rule） 线程 interrupt() 方法的调用 happens—before 被中断线程的代码检测到中断事件的发生 对象终结规则（Finalizer Rule） 一个对象的初始化完成（构造函数执行）happens—before 它的 finalize() 方法 传递性（Transitivity） 如果 A happens-before B，B happens-before C，那么 A happens-before C 6.6 volatile1 概述 volatile 是Java虚拟机提供的轻量级的同步机制 volatile 有两个作用： 保证可见性 禁止指令重排序 volatile 无法保证原子性 内存屏障 Memory Barrier 对 volatile 变量的写指令后会加入写屏障 storefence 对volatile 变量的读指令前会加入读屏障 loadfence 2 Volatile 可见性 硬件层面：MESI 当某个线程修改了被 volatile 修饰的共享变量的值，会马上同步到主内存，而开启了 CPU 总线嗅探机制的线程就会得知此修改，然后将自己工作内存中的共享变量副本失效，这样使用时就需要重新从主内存中读取 JVM 层面：Memory Barrier 写屏障保证在该屏障之前的，对共享变量的改动，都同步到主内存当中 读屏障保证在该屏障之后，对共享变量的读取，加载的是主内存中最新数据 3 Volatile 有序性 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前 6.7 synchronized1 概述 synchronized 内置锁是一种对象锁（锁的是对象而非引用），作用粒度是对象，可以用来实现对临界资源的同步互斥访问，是可重入的 synchronized 可以保证原子性和可见性，不能保证有序性，但如果共享变量完全被 synchronized 控制，则不会出现有序性问题 2 同步代码块1234synchronized(锁) &#123; 1. 同步代码块的锁可以是任意对象 2. 不要使用 String Integer Long 作为锁对象&#125; 3 同步函数1234修饰符 synchronized 返回值 方法名(形参列表)&#123; 1. 非静态同步函数的锁是 this 2. 静态同步函数的锁是当前类的字节码对象 类.class&#125; 4 synchronized 原理1 对象头 2 Monitor：监视器/管程 属性 说明 Owner 当一个线程获取锁，并正常执行，则将 Owner 指向此线程，Owner 只能有一个值 EntryList 尝试获取此锁的线程如果获取不到，会阻塞进入 EntryList WaitSet 已经获取锁但条件不满足，进入等待状态的线程会进入 WaitSet 3 原理 每个 Java 对象都有一个自己的 Monitor 对象，当给对象上锁（重量级锁）后，该对象头的 Mark Word 就会指向 Monitor Monitor 的实现依赖底层操作系统的 Mutex lock（互斥锁）实现，它是一个重量级锁性能较低 synchronized JVM内置锁通过内部对象 Monitor 实现，基于进入与退出 Monitor 对象实现方法与代码块同步 synchronized 关键字被编译成字节码后会被翻译成 monitorenter 和 monitorexit 两条指令分别在同步块逻辑代码的起始位置与结束位置 4 锁优化1 锁粗化1234567891011121314151617181920212223242526272829StringBuffer sb = new StringBuffer;public void test() &#123; sb.append(1); sb.append(2); sb.append(3); sb.append(4);&#125;/* StringBuffer是线程安全的，append方法有sychronized修饰，那么调用了4次append方法，就相当于有了四个同步块 sychronized()&#123; append(1); &#125; sychronized()&#123; append(2); &#125; sychronized()&#123; append(3); &#125; sychronized()&#123; append(4); &#125;而这是没有必要的，锁粗化相当于 sychronized()&#123; append(1); append(2); append(3); append(4); &#125;/* 2 锁消除 Java虚拟机在 JIT 编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间 3 锁膨胀升级1 概述 偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁 轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争 重量级锁：有实际竞争，且锁竞争时间长 2 偏向锁 在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁（会涉及到一些 CAS 操作）的代价而引入偏向锁 偏向锁核心思想：如果一个线程获得了锁，那么锁就进入偏向模式，此时 Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作（即获取锁的过程），这样就省去了大量有关锁申请的操作 偏向锁默认开启，但有延迟 调用了对象的 hashCode ，会导致偏向锁被撤销 如果发生了竞争，则偏向锁会失效，会膨胀为轻量级锁 3 轻量级锁 轻量级锁所适应的场景是线程交替执行同步块的场合 轻量级锁在没有竞争时，每次锁重入仍需要执行 CAS 操作 如果在尝试加轻量级锁的过程中，CAS 操作无法成功，一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），则轻量级锁会失败，轻量级锁失败后并不会立即膨胀为重量级锁，而是会先使用锁自旋的优化手段 自旋锁 在大多数情况下，线程持有锁的时间都不会太长，如果当前线程获取轻量级锁失败后直接挂起，可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高 自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，将轻量级锁膨胀为重量级锁 5 锁活跃性 死锁：一个线程需要同时获取多把锁，这时就容易发生死锁（例如锁嵌套） 活锁：两个线程互相改变对方的结束条件，导致谁也无法结束 饥饿：一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束 6.8 常见线程安全类1234567StringIntegerStringBufferRandomVectorHashtablejava.util.concurrent.* 线程安全指的是多个线程调用这些类的同一实例的同一方法是线程安全的 它们每个方法是原子的，但多个方法的组合不是原子的 七 等待唤醒机制7.1 wait/notify1 概述 只有重量级锁才有等待唤醒方法 wait()：相当于 wait(0)，无限等待直到被唤醒 wait(long timeout)：等待指定时间或被唤醒 notify() notifyAll() 获取锁之后才能调用等待唤醒方法，即等待唤醒的方法要在同步代码中执行，且需要同一个锁对象来调用 等待时释放锁，进入 Monitor 的 WaitSet，唤醒之后不会立即获取锁，而是进入 Monitor 的 EntrySet 重新竞争 2 wait &amp; sleep 方法 所属 参数 锁 使用 wait() Object 无参：无限等待有参：有限等待 释放锁 必须先获取锁，在同步代码中使用 sleep() Thread 有参：有限睡眠 不释放锁 可直接使用 3 模式 同步模式之保护性暂停 Guarded Suspension：用在一个线程等待另一个线程的执行结果 结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject 产生结果的线程与消费结果的线程需要一一对应 JDK 中，join 的实现、Future 的实现，采用的就是此模式 异步模式之生产者/消费者 产生结果的线程与消费结果的线程不需要一一对应 JDK 中各种阻塞队列，采用的就是这种模式 7.2 park/unpark1 与 wait &amp; notify 相比 wait &amp; notify 必须配合 Object Monitor 使用，park &amp; unpark 则不必 wait &amp; notify 只能随机唤醒等待线程，park &amp; unpark 是以线程为单位来等待唤醒的，所以精确 wait &amp; notify 不能先 notify，park &amp; unpark 可以先 unpark，即先 unpark 也能恢复 park 的线程 2 原理 每个线程都有自己的一个 Parker 对象，由三部分组成 _counter _cond _mutex park() 判断 _counter _counter == 0 则等待 _counter == 1 则继续运行 将 _counter 设置为 0 unpark() 将 _counter 设置为 1 判断线程状态 如果线程正在等待，则唤醒线程 如果线程正在运行，则继续运行，且由于 _counter 设置为了 1 ，线程下次调用 park() 时，会继续执行 八 CAS8.1 概述 Compare And Swap 或 Compare And Set CAS 是一种无锁算法，体现的是无锁并发、无阻塞并发 CAS 必须借助 volatile ，因为需要保证可见性来读取最新值 内部通过 Unsafe 实现，Unsafe 直接操作虚拟机内存，类似 C C++ 的指针 ABA 问题：version 8.2 原理 CAS 包含三个操作数： 内存值 V 预估值 A 更新值 B 第一次读取内存值记录为 A，之后进行一些操作 当真正写入数据时，再次读取内存值 V，当且仅当 V == A 时，才会更新 V = B 九 java.util.concurrent.atomic9.1 概述 类型 名称 基本类型原子类 AtomicIntegerAtomicBooleanAtomicLong 引用类型原子类 AtomicReference&lt;V&gt;AtomicStampedReference&lt;V&gt;AtomicMarkableReference&lt;V&gt; 数组类型原子类 AtomicIntegerArrayAtomicLongArrayAtomicReferenceArray&lt;E&gt; 原子字段更新器 AtomicIntegerFieldUpdater&lt;T&gt;AtomicLongFieldUpdater&lt;T&gt;AtomicReferenceFieldUpdater&lt;T, V&gt; 原子累加器 LongAdderDoubleAdderLongAccumulatorDoubleAccumulator AtomicReference&lt;V&gt; 只关心当前值和预期值是否相等，不知道值是否被修改过（ABA问题），如 A → B → C → A AtomicStampedReference&lt;V&gt; 增加一个版本号属性，每次修改都使版本号 + 1，可以知道值被修改过几次 AtomicMarkableReference&lt;V&gt; 增加要给布尔属性，判断值是否被修改过 9.2 AtomicInteger1 构造 构造 说明 AtomicInteger() 使用默认值 0 AtomicInteger(int initialValue) 使用指定值 2 方法 修饰 方法 说明 int get() 获取当前值 boolean compareAndSet(int expectedValue, int newValue) 如果当前值与预期值相等，则将当前值设置为新值并返回 true int getAndIncrement() i++ int incrementAndGet() ++i int getAndDecrement() i-- int decrementAndGet() --i int getAndAdd(int delta) 返回原值，之后将值加上指定值 int addAndGet(int delta) 将值加上指定值并返回 int getAndUpdate(IntUnaryOperator updateFunction) 获取原值并计算 int updateAndGet(IntUnaryOperator updateFunction) 计算并返回 十 java.util.concurrent.locks 10.1 Lock1 API 修饰 方法 说明 void lock() 获取锁 void unlock() 释放锁 boolean tryLock() 尝试获取锁 boolean tryLock(long time, TimeUnit unit) 尝试获取锁，会尝试指定时间 void lockInterruptibly() 功能同 locak，如果线程被中断会抛出异常 Condition newCondition() 创建一个该锁的 Condition 对象 2 典型使用1 lock()1234567Lock l = ...;l.lock(); // 获取锁后要紧跟 trytry &#123; // access the resource protected by this lock&#125; finally &#123; l.unlock(); // 释放锁要在 finally 的第一行&#125; 2 tryLock()12345678910Lock lock = ...;if (lock.tryLock()) &#123; try &#123; // manipulate protected state &#125; finally &#123; lock.unlock(); &#125;&#125; else &#123; // perform alternative actions&#125; 3 ReentrantLock1 构造 构造 说明 ReentrantLock() 默认为非公平锁 ReentrantLock(boolean fair) 可创建公平锁（但没有必要，会降低并发度） 2 与 synchronized 比较 在 synchronized 未优化之前，皆为重量级锁，所以才引入 ReentrantLock，ReentrantLock 提供了更丰富的 API synchronized 和 ReetrantLock 都是可重入锁 synchronized 获取不到锁会一直阻塞；ReentrantLock 获取不到锁可以被中断或超时 ReetrantLock 可设置公平锁 synchronized只有一个条件，不满足时进入 WaitSet 等待；ReetrantLock 一个锁可以对应多个 Condition 10.2 Condition 修饰 方法 说明 void await() 当前线程等待，直到被打断或被唤醒 boolean await(long time, TimeUnit unit) 当前线程等待，直到被打断或被唤醒或超时 long awaitNanos(long nanosTimeout) 当前线程等待，直到被打断或被唤醒或超时 void awaitUninterruptibly() 当前线程等待，直到被唤醒 void signal() 唤醒一个等待线程 void signalAll() 唤醒所有等待线程 10.3 ReadWriteLock1 概述 读写锁，将锁更细粒度的划分： 共享锁（读） 排他锁（写） 读锁可以被多个线程共享（当读操作多时，多个读线程可以并发执行，提高效率），写锁则只能一个线程独占 ReentrantReadWriteLock：唯一实现类 StampedLock：能力更强的读写锁 2 API 修饰 方法 说明 Lock readLock() 获取读锁 Lock writeLock() 获取写锁 10.4 LockSupport 修饰 方法 static Object getBlocker(Thread t) static void park() static void park(Object blocker) static void parkNanos(long nanos) static void parkNanos(Object blocker, long nanos) static void parkUntil(long deadline) static void parkUntil(Object blocker, long deadline) static void unpark(Thread thread) 十一 辅助工具类11.1 Semaphore1 概述 Semaphore 是一个计数信号量，必须由获取它的线程释放 用来控制同时访问资源的线程数量（限流） 2 构造 构造 说明 Semaphore(int permits) 创建具有给定许可数的计数信号量，默认为非公平信号量 Semaphore(int permits, boolean fair) 创建具有给定许可数的计数信号量，可设置为公平信号量 3 方法 修饰 方法 说明 void acquire() 从信号量中获取一个许可，在提供一个可用许可之前一直等待 void acquire(int permits) 从信号量中获取指定数量的许可 void release() 释放一个许可，将其返回给信号量 void release(int permits) 释放指定数量的许可，将其返回给信号量 int availablePermits() 获取当前可用的许可个数 boolean hasQueuedThreads() 是否有线程在等待获取许可 `int getQueueLength() 获取正在等待获取许可的线程数 protected Collection&lt;Thread&gt; getQueuedThreads() 获取所有等待获取许可的线程集合 int drainPermits() 获取可用许可个数，并将可用许可置为 0 11.2 CountDownLatch1 概述 用来进行线程同步写作，等待所有线程完成倒计时 允许一个或多个线程等待其他线程完成操作 2 构造 构造 说明 CountDownLatch(int count) 构造时传入一个计数 3 方法 修饰 方法 说明 void countDown() 计数减 1 void await() 当前线程等待，当计数归 0，当前线程继续执行 boolean await(long timeout, TimeUnit unit) 当前线程等待，当计数归 0 或者超时，当前线程继续执行 11.3 CyclicBarrier1 概述 循环栅栏，用来进行线程协作，等待线程满足某个计数 阻塞一组线程直到某个事件的发生 CountDownLatch 只能拦截一轮，CyclicBarrier 可以实现循环拦截 构造时设置计数，每个线程执行到某个需要同步的时刻则等待，当等待的线程数满足计数时，继续执行 2 构造 构造 说明 CyclicBarrier(int parties) 构造时传入一个计数，表示需要等待的线程数 CyclicBarrier(int parties, Runnable barrierAction) barrierAction：等待线程数达到时首先执行的任务 3 方法 修饰 方法 说明 void await() 当前线程等待，直到等待线程数达到初始计数 int await(long timeout, TimeUnit unit) 当前线程等待，直到等待线程数达到初始计数或超时 十二 线程池12.1 线程池体系 12.2 线程池执行过程 12.3 线程池状态 状态 高 3 位 说明 Running 111 接收新任务，能处理已添加任务 Shutdown 000 不接收新任务，能处理已添加任务 Stop 001 不接收新任务，不处理已添加任务，且中断正在处理的任务 Tidying 010 所有任务已终止，ctl 记录的活动线程为 0，即将进入终结 Terminated 011 线程池彻底终止 线程池的运行状态和活动线程数信息存储在一个原子变量 AtomicInteger ctl 中，目的是将线程池状态和线程个数合二为一，这样就可以用一次 CAS 原子操作进行赋值 ctl 高 3 位表示线程池状态，低 29 位表示线程池数量 12.4 线程池数量 Nthreds = NCPU * UCPU * (1 + W/C) NCPU ：CPU 的核数 UCPU ：CPU 期望利用率 (0, 1] W/C ：等待时间和计算时间比率 CPU 密集型运算：线程数 = CPU核数 + 1 I/O 密集型运算：线程数 = CPU核数 * 期望CPU利用率 *（CPU计算时间 + 等待时间）/ CPU计算时间 12.5 ThreadPoolExecutor1 构造1234567ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 参数 说明 int corePoolSize 核心线程数 int maximumPoolSize 最大线程数 long keepAliveTime 线程最大空闲时间，如果线程池中线程数量超过 corePoolSize，超出线程空闲时间超过 keepAliveTime 会被终止 TimeUnit unit 空闲时间单位 BlockingQueue&lt;Runnable&gt; workQueue 任务阻塞队列 ThreadFactory threadFactory 线程工厂 RejectedExecutionHandler handler 拒绝策略 1 Enum TimeUnit1 枚举项：时间粒度 粒度 名称 说明 NANOSECONDS 纳秒 ns 1 s = 109 ns MICROSECONDS 微秒 μs 1 s = 106 μs MILLISECONDS 毫秒 ms 1 s = 103 ms SECONDS 秒 s MINUTES 分 min HOURS 时 h DAYS 日 d 2 方法：线程 修饰 方法 说明 void sleep(long timeout) 当前线程睡眠当前粒度的 timout，替代 Thread.sleep(timeout) void timedJoin(Thread thread, long timeout) 指定线程 join 当前粒度的 timeout，替代 t.join(timout) void timedWait(Object obj, long timeout) 锁对象 obj 等待当前粒度的 timout，替代 obj.wait(timout) 3 方法：时间粒度转换 修饰 方法 说明 long convert(Duration duration) 将指定时间间隔 duration 转换为当前粒度 long convert(long sourceDuration, TimeUnit sourceUnit) 将指定数值 sourceDuration 的指定粒度 sourceUnit 转换为当前粒度 long toNanos(long duration) 将指定数值 duration 的当前粒度转换为纳秒 long toMicros(long duration) 将指定数值 duration 的当前粒度转换为微秒 long toMillis(long duration) 将指定数值 duration 的当前粒度转换为毫秒 long toSeconds(long duration) 将指定数值 duration 的当前粒度转换为秒 long toMinutes(long duration) 将指定数值 duration 的当前粒度转换为分 long toHours(long duration) 将指定数值 duration 的当前粒度转换为时 long toDays(long duration) 将指定数值 duration 的当前粒度转换为日 2 ThreadFactory 默认使用 Executors.defaultThreadFactory() 自定义线程工厂实现此接口 使用不同的工厂，可以更改线程名称，线程组，优先级，守护线程状态等等 3 RejectedExecutionHandler 内置拒绝策略 说明 AbortPolicy（默认） 放弃本次任务，抛 RejectedExecutionException 异常 DiscardPolicy 放弃本次任务 DiscardOldestPolicy 放弃队列中最早的任务，本次任务取而代之 CallerRunsPolicy 让调用者处理任务 自定义拒绝策略实现此接口 Dubbo 的实现：抛 异常之前会记录日志，并 dump 线程栈信息，方便定位 Netty 的实现：创建一个新线程来执行任务 ActiveMQ 的实现：带超时等待（60s）尝试放入队列 PinPoint 的实现：使用了一个拒绝策略链，会逐一尝试 2 方法1 提交任务 修饰 方法 说明 `void execute(Runnable command) 执行任务 Runnable 任务 &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) 提交 Callable 任务，使用 Future 获取任务执行结果 Future&lt;?&gt; submit(Runnable task) 提交 Runnbale 任务，使用 Future 获取任务执行结果 ` Future submit(Runnable task, T result) 提交带返回值的 Runnbale 任务，使用 Future 获取任务执行结果 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) 提交多个任务 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) 提交多个任务，带超时时间 &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) 提交多个任务，哪个任务先成功执行完毕则返回其结果，其它任务取消 &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) 提交多个任务，哪个任务先成功执行完毕则返回其结果，其它任务取消，带超时时间 2 关闭线程池 修饰 方法 说明 void shutdown() 线程池状态变为 Shutdown，不再接收新任务，已提交任务会被执行完，此方法不会阻塞调用线程的执行 List&lt;Runnable&gt; shutdownNow() 线程池状态变为 Stop，不再接收新任务，用 interrupt() 中断正在执行的任务，返回队列中等待执行的任务 boolean isShutdown() 测试线程池是否关闭，线程池状态不为 Running，都会返回 true boolean isTerminated() 测试是否所有任务都执行完毕了，线程池状态为 Terminated，返回 true boolean awaitTermination(long timeout, TimeUnit unit) 由于调用 shutdown 后，调用线程并不会等待所有任务执行完毕，可以使用此方法等待线程池状态变为 Terminated 12.6 Executors1 固定大小线程池12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 核心线程数 = 最大线程数，即不会有救急线程被创建，也就没有超时时间 阻塞队列 LinkedBlockingQueue 最大为 Integer.MAX_VALUE 适合任务量已知，相对耗时的任务 2 带缓冲线程池12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 核心线程数为 0，最大线程数为 Integer.MAX_VALUE，意味着全为救急线程，且超时时间为 60s 阻塞队列 SynchronousQueue 没有容量，读写操作一一对应，意味着提交一个任务就必须马上执行 适合任务数比较密集，但每个任务耗时较短的情况 3 单线程线程池123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService( new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 核心线程数 = 最大线程数 = 1，即线程数固定为 1 适合多个任务排队执行 单线程线程池 &amp; 自己创建一个线程的区别 自己创建一个线程，如果某个任务执行失败而终止，那么没有任何补救措施 单线程线程池会新创建一个线程，保证池中始终有一个工作线程，且线程池有任务阻塞队列 单线程线程池 &amp; 数量为 1 的固定大小线程池的区别 固定大小线程池对外暴漏的是 ThreadPoolExecutor 对象，所以可以使用其方法修改核心线程数 单线程线程池 FinalizableDelegatedExecutorService 使用的是装饰着模式，只对外暴漏了 ExecutorService 的方法，不能使用 ThreadPoolExecutor 的特有方法，无法修改 4 任务调度线程池123456789public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue());&#125; 没有任务调度线程池之前，java.util.Timer 可以用来实现定时功能，缺点： 所有任务由一个线程调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行 如果某一个任务出现异常，会影响到之后的任务 任务调度线程池可以由不同的线程来执行任务，且某个任务出现异常也不会影响其它任务 12.7 ScheduledThreadPoolExecutor 修饰 方法 说明 ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit) 指定延迟后，执行 Runnable 任务 &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit) 指定延迟后，执行 Callable 任务 ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) 初始延迟时间后开始执行任务，到达 period 间隔时间后，判断上一个任务是否执行完毕，若执行完毕则执行下一个任务，否则等待其执行完毕 ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) 初始延迟时间后开始执行任务，上一个任务执行完毕后延迟指定时间再开始执行下一个任务 12.8 Fork/Join1 概述 Fork/Join 是 JDK 7 加入的新的线程池实现，体现的是一种分治思想，适用于能够进行任务拆分的 CPU 密集型运算 分支/合并框架的目的是以递归方式将可以并行的任务拆分成更小的任务，然后将每个子任务的结果合并起来生成整体结果 Fork/Join 是 ExecutorService 接口的一个实现，它把子任务分配给线程池（称为 ForkJoinPool ）中的工作线程 2 任务1 概述 提交给 Fork/Join 线程池的任务需要继承 ForkJoinTask&lt;V&gt; RecursiveTask&lt;V&gt;：有返回值，V是并行化任务（以及所有子任务）产生的结果类型 RecursiveAction：无返回值 定义的任务， 只需实现它唯一的抽象方法 V compute()，此方法同时定义了： 将任务拆分成子任务的逻辑 无法再拆分或不方便再拆分时，生成单个子任务结果的逻辑 compute() 伪代码 1234567if (任务足够小或不可分) &#123; 顺序计算该任务&#125; else &#123; 将任务分成两个子任务 递归调用本方法，拆分每个子任务，等待所有子任务完成 合并每个子任务的结果&#125; 2 ForkJoinTask&lt;V&gt;12ForkJoinTask&lt;V&gt; fork()：使用 ForkJoinPool 中另一个线程异步执行子任务V join()：获取子任务结果，如果尚未完成就等待 3 工作窃取 理想情况下，划分并行任务时，应该让每个任务都用完全相同的时间完成，让所有的CPU内核都同样繁忙。不幸的是，实际中，每个子任务所花的时间可能天差地别 分支/合并框架工程用一种称为工作窃取（work stealing）的技术来解决这个问题 工作窃取算法用于在池中的工作线程之间重新分配和平衡任务 每个线程都为分配给它的任务保存一个双向链式队列，每完成一个任务，就会从队列头上取出下一个任务开始执行 某个线程可能早早完成了分配给它的所有任务，也就是它的队列已经空了，而其他的线程还很忙。这时，这个线程并没有闲下来，而是随机选了一个别的线程，从其队列的尾巴上“偷走”一个任务 这个过程一直继续下去，直到所有的任务都执行完毕，所有的队列都清空 4 ForkJoinPool1 构造 构造 说明 ForkJoinPool() 默认会创建和 CPU 核心数相同大小的线程池 ForkJoinPool(int parallelism) 指定线程数 2 方法123&lt;T&gt; T invoke(ForkJoinTask&lt;T&gt; task)void execute(ForkJoinTask&lt;?&gt; task)&lt;T&gt; ForkJoinTask&lt;T&gt; submit(ForkJoinTask&lt;T&gt; task) 十三 线程安全集合13.1 概述 遗留的线程安全集合如 Hashtable ， Vector 使用 Collections 装饰的线程安全集合 12345678Collections.synchronizedCollectionCollections.synchronizedListCollections.synchronizedMapCollections.synchronizedSetCollections.synchronizedNavigableMapCollections.synchronizedNavigableSetCollections.synchronizedSortedMapCollections.synchronizedSortedSet java.util.concurrent.* Blocking：大部分实现基于锁，并提供用来阻塞的方法 CopyOnWrite：写开销相对较重 Concurrent： 内部很多操作使用 CAS 优化，一般可以提供较高吞吐量 弱一致性 遍历时弱一致性：当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，但这时内容是旧的（非安全容器会抛异常） 求大小弱一致性：size 操作未必是 100% 准确 读取弱一致性 13.2 ConcurrentHashMap&lt;K,V&gt;1 概述 JDK 7 中非线程安全的 Map 集合当元素下标相同时，会添加到链表的头部，而 JDK 8 则是添加到链表的尾部 JDK 7 中在多线程环境使用非线程安全的 Map 集合，当扩容时可能出现并发死链，JDK 8 虽然将扩容算法做了调整，但还是会出现其他问题，如扩容丢数据 2 重要属性和内部类1234567891011121314151617181920212223242526// 默认为 0// 当初始化时, 为 -1// 当扩容时, 为 -(1 + 扩容线程数)// 当初始化或扩容完成后，为 下一次的扩容的阈值大小private transient volatile int sizeCtl;// 整个 ConcurrentHashMap 就是一个 Node[]static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;&#125;// hash 表transient volatile Node&lt;K,V&gt;[] table;// 扩容时的 新 hash 表private transient volatile Node&lt;K,V&gt;[] nextTable;// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Nodestatic final class ReservationNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;// 作为 treebin 的头节点, 存储 root 和 firststatic final class TreeBin&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;// 作为 treebin 的节点, 存储 parent, left, rightstatic final class TreeNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125; 3 重要方法12345678// 获取 Node[] 中第 i 个 Nodestatic final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i)// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) 13.3 CopyOnWriteArrayList ArrayList 每次写入时都会复制一个新的容器再写入 在迭代并添加时没有并发修改异常 每次写入都会复制，效率低，适合并发迭代 十四 java.lang.ThreadLocal&lt;T&gt;14.1 概述123456789101112131415161718192021// 1 ThreadLocalpublic class ThreadLocal&lt;T&gt; &#123; static class ThreadLocalMap &#123; private Entry[] table; static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; &#125;&#125;// 2 Threadpublic class Thread implements Runnable &#123; ThreadLocal.ThreadLocalMap threadLocals = null;&#125; ThreadLocal 中有一个静态内部类 ThreadLocalMap，ThreadLocalMap 中有一个静态内部类 Entry，且维护了一个 Entry 类型的数组，其实数据最终存储在了 Entry[] 中 TheadLocalMap 的键为 ThreaLoal 本身，值为自定义添加的值 一个 ThreadLocalMap 可以存储 n 个 ThreadLocal，所以存储时，会根据不同的 ThreadLocal 计算出不同的索引，此索引即存储到 ThreadLocalMap 中的 Entry[] 中的位置 每个线程对应一个 ThreadLoaclMap ，不同线程互不干扰 每个线程可以有多个不同的 ThreadLocal（如 ThreadLocal&lt;A&gt;, ThreadLoacl&lt;B&gt;...），所有 ThreadLocal 使用同一个 ThreadLocalMap Entry 是一个弱引用 如果是强引用，即使 ThreadLocal tl = null ，Entry 中的键依然指向 ThreadLocal ，会导致内存泄漏 弱引用还是有内存泄漏问题：当 ThreadLocal 为 null 被当成垃圾回收，但 ThreadLocalMap 生命周期和 Thread 一样，它不会回收，即 Entry 中的键为 null 了，而值还存在，但无法访问到了，所以使用完 ThreadLocal 后，执行 remove() 操作 14.2 API 修饰 方法 说明 void set(T value) 此 ThreadLocal 作为键，value 作为值，存储到当前线程的 ThreadLoaclMap 中 T get() 从当前线程的 ThreadLoaclMap 中，获取键 ThreadLocal 对应的值 void remove() 从当前线程的 ThreadLoaclMap 中，移除此 ThreadLocal 的键值对 1 set123456789101112131415161718public void set(T value) &#123; Thread t = Thread.currentThread(); // 获取当前线程的 ThreadLocalMap，如果已存在则直接使用，否则创建一个 ThreadLocalMap map = getMap(t); if (map != null) &#123; map.set(this, value); &#125; else &#123; createMap(t, value); &#125;&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 2 get12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125;","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-集合","slug":"Java/Java-集合","date":"2020-09-29T07:54:08.000Z","updated":"2020-09-29T07:54:24.623Z","comments":true,"path":"2020/09/29/Java/Java-集合/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-%E9%9B%86%E5%90%88/","excerpt":"","text":"一 java.util.Collection&lt;E&gt; 1.1 API1 增 修饰 方法 说明 boolean add(E e) 添加一个元素 boolean addAll(Collection&lt;? extends E&gt; c) 添加一个集合的元素 2 删 修饰 方法 说明 boolean remove(Object o) 删除一个元素 boolean removeAll(Collection&lt;?&gt; c) 删除交集 default boolean removeIf(Predicate&lt;? super E&gt; filter) 删除符合条件的元素 void clear() 清空集合 3 判断 修饰 方法 说明 boolean contains(Object o) 判断是否包含指定元素 boolean containsAll(Collection&lt;?&gt; c) 判断是否包含指定集合 boolean isEmpty() 判断是否为空 4 获取 修饰 方法 说明 int size() 获取元素个数 boolean retainAll(Collection&lt;?&gt; c) 取交集 5 转换 修饰 方法 说明 Object[] toArray() 集合 → 数组 &lt;T&gt; T[] toArray(T[] a) 集合 → 指定类型的数组（建议传入数组 length = size） default &lt;T&gt; T[] toArray(IntFunction&lt;T[]&gt; generator) 集合 → 指定类型的数组（由函数生成） 6 遍历 修饰 方法 说明 Iterator&lt;E&gt; iterator() 获取迭代器 default Spliterator&lt;E&gt; spliterator() 获取并行迭代器 7 流 修饰 方法 说明 default Stream&lt;E&gt; stream() 获取顺序流 default Stream&lt;E&gt; parallelStream() 获取并行流 1.2 java.util.List&lt;E&gt;1 概述 元素有序（存取顺序一致） 元素有索引 元素可以重复 2 API1 增 修饰 方法 说明 void add(int index, E element) 在指定位置插入元素 boolean addAll(int index, Collection&lt;? extends E&gt; c) 在指定位置插入一个集合的元素 2 删 修饰 方法 说明 E remove(int index) 删除指定位置的元素并返回 3 改 修饰 方法 说明 E set(int index, E element) 修改指定位置的元素 4 查 修饰 方法 说明 int indexOf(Object o) 从头开始查询元素第一次出现的索引 int lastIndexOf(Object o) 从尾开始查询元素第一次出现的索引 5 获取 修饰 方法 说明 E get(int index) 获取指定位置的元素 List&lt;E&gt; subList(int fromIndex, int toIndex) 截取集合 [from, to) static &lt;E&gt; List&lt;E&gt; of(E... elements) 获取包含指定元素的不可修改（只读）的 List 集合 static &lt;E&gt; List&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll) 如果传入的集合是不可变的则直接返回，否则通过 of 创建一个包含其元素的不可修改的 List 集合（顺序为指定集合元素的迭代顺序） 6 遍历 修饰 方法 说明 ListIterator&lt;E&gt; listIterator() 获取 ListIterator 迭代器 ListIterator&lt;E&gt; listIterator(int index) 获取 ListIterator 迭代器，从指定索引开始 3 ArrayList1 构造 构造 说明 ArrayList() 默认容量为 10，每次扩容为原容量的 1.5 倍（JDK8以后，创建时 {}，第一次添加时才创建容量 10 的数组） ArrayList(int initialCapacity) 指定容量 ArrayList(Collection&lt;? extends E&gt; c) 包含指定集合元素 2 ArrayList VS Vector ArrayList 非同步，Vector 同步 ArrayList 扩容是原来的 1.5 倍，Vector 扩容是原来的 2 倍 Vector 支持 Enumeration 4 Stack 修饰 方法 说明 boolean empty() 判断是否为空 E peek() 获取但不弹出栈顶元素 E pop() 弹栈（获取并弹出栈顶元素） E push(E item) 压栈（将元素添加到栈顶） int serach(Object o) 返回指定元素的位置编号（栈顶为 1） 1.3 java.util.Set&lt;E&gt;1 概述 元素唯一，不保证存取顺序 HashSet：元素存取无序 LinkedHashSet：元素存取有序 TreeSet：元素存取无序但会排序 Set 集合底层依赖于 Map 集合，添加到 Set 中的元素作为键，一个内部的共享对象作为值 2 API 修饰 方法 说明 static &lt;E&gt; Set&lt;E&gt; of(E... elements) 获取包含指定元素的不可修改的 Set 集合 static &lt;E&gt; Set&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll) 获取包含指定集合中所有元素的不可修改的 Set 集合 3 HashSet &amp; LinkedHashSet 添加元素时，首先 hashCode() 获取元素的哈希值，然后根据某种算法，算出底层数组中的存放位置 如果此位置上没有元素，则添加成功 如果此位置上有元素 首先比较哈希值，如果哈希值不同，则添加成功 如果哈希值相同，则比较 equals() 元素要存入 HashSet 需要重写 hashCode() 和 equals() 方法 一个位置多个元素以链表形式存储多个元素，七上八下： jdk7：新元素在上，指向旧元素 jdk8：新元素在下，旧元素指向新元素 4 TreeSet 元素具有比较性，元素实现 Comparable 接口 集合具有比较性，集合传入一个实现了 Comparator 接口的比较器 TreeSet 判断元素是否相同，就是看到比较结果 1.4 Queue&lt;E&gt;1 API 修饰 方法 说明 boolean add(E e) 向队列末尾添加元素，如果队列已满则抛异常 IllegalStateException boolean offer(E e) 向队列末尾添加元素，如果队列已满则返回 false E element() 获取但不移除队列第一个元素，如果队列为空则抛异常 NoSuchElementEsxception E peek() 获取但不移除队列第一个元素，如果队列为空则返回 null E remove() 获取并移除队列第一个元素，如果队列为空则则抛异常 NoSuchElementEsxception E poll() 获取并移除队列第一个元素，如果队列为空则返回 null 2 Deque&lt;E&gt; 修饰 方法 说明 void addFirst(E e) 向队列首部添加元素，如果队列已满则抛异常 IllegalStateException boolean offerFirst(E e) 向队列首部添加元素，如果队列已满则返回 false void addLast(E e) 向队列尾部添加元素，如果队列已满则抛异常 IllegalStateException boolean offerLast(E e) 向队列尾部添加元素，如果队列已满则返回 false E getFirst() 获取但不移除队列第一个元素，如果队列为空则抛异常 NoSuchElementEsxception E peekFirst() 获取但不移除队列第一个元素，如果队列为空则返回 null E getLast() 获取但不移除队列最后一个元素，如果队列为空则抛异常 NoSuchElementEsxception E peekLast() 获取但不移除队列最后一个元素，如果队列为空则返回 null E removeFirst() 获取并移除队列第一个元素，如果队列为空则则抛异常 NoSuchElementEsxception E pollFirst() 获取并移除队列第一个元素，如果队列为空则返回 null E removeLast() 获取并移除队列最后一个元素，如果队列为空则则抛异常 NoSuchElementEsxception E pollLast() 获取并移除队列最后一个元素，如果队列为空则返回 null 3 BlockingQueue&lt;E&gt;1 API 修饰 方法 说明 boolean add(E e) 向队列末尾添加元素，如果队列已满则抛异常 IllegalStateException boolean offer(E e) 向队列末尾添加元素，如果队列已满则返回 false boolean offer(E e, long timeout, TimeUnit unit) 向队列末尾添加元素，如果队列已满会尝试指定时间，超时则返回 false void put(E e) 向队列末尾添加元素，如果队列已满则阻塞等待 E remove() 获取并移除队列第一个元素，如果队列为空则则抛异常 NoSuchElementEsxception E poll() 获取并移除队列第一个元素，如果队列为空则返回 null E poll(long timeout, TimeUnit unit) 获取并移除队列第一个元素，如果队列为空会尝试指定时间，超时则返回 null E take() 获取并移除队列第一个元素，如果队列为空则阻塞等待 E element() 获取但不移除队列第一个元素，如果队列为空则抛异常 NoSuchElementEsxception E peek() 获取但不移除队列第一个元素，如果队列为空则返回 null Throws exception Special value Times out Blocks 增加 add(e) offer(e) offer(e, time, unit) put(e) 删除 remove() poll() poll(time, unit) take() 检测队首元素 element() peek() 2 实现类 类 说明 ArrayBlockingQueue 数组结构的有界阻塞队列 LinkedBlockingQueue 链表结构的有界阻塞队列（默认 Integer.MAX_VALUE，也可以看作是无界的） SynchronousQueue 容量为 0，是一个不存储元素的阻塞队列，读写操作配对出现，只有一个时会阻塞等待 DelayQueue 优先级堆支持的，基于时间的调度队列（元素按阻塞程度排序，会先获取阻塞低的元素） PriorityBlockingQueue 优先级堆支持的无界优先级队列（内部使用二叉树排好了序） 二 java.util.Map&lt;K,V&gt;2.1 概述 类 说明 HashMap 键唯一，存取无序，null 可以作为键和值，线程不安全（非同步） HashTable 键唯一，存取无序，null 不能作为键和值，线程安全（同步） LinkedHashMap 键唯一，存取有序 Properties 键唯一，存取无序，键值必须是字符串 TreeMap 键唯一，存取无序，元素根据键排序 2.2 键唯一性1 HashMap HashTable LinkedHashMap Properties hashCode() equals() 2 TreeMap 键具有比较性 集合传入比较器 2.3 API1 增 修饰 方法 说明 V put​(K key, V value) 添加键值对，若 key 已存在返回 value，否则返回 null void putAll(Map m) 添加一个集合的键值对 default V putIfAbsent(K key, V value) 如果指定的 key 没有值或值为 null，则将其值设置为指定 value，否则返回已有的值 2 删 修饰 方法 说明 V remove(Object key) 根据指定 key 删除并返回 value，若不存在则返回 null default boolean remove(Object key, Object value) 删除指定键值对 void clear() 清空集合 3 获取 修饰 方法 说明 V get(Object key) 根据指定 key 获取 value，若不存在则返回 null default V getOrDefault(Object key, V defaultValue) 根据指定 key 获取 value，若不存在则返回 defaultValue int size() 获取键值对个数 static &lt;K, V&gt; Map&lt;K, V&gt; copyOf(Map&lt;? extends K, ? extends V&gt; map) 获取包含指定集合键值对的不可修改的 Map 集合 4 判断 修饰 方法 说明 boolean isEmpty() 是否为空 boolean containsKey(Object key) 是否包含指定 key boolean containsValue(Object value) 是否包含指定 value 5 遍历 修饰 方法 说明 Set&lt;K&gt; keySet() 获取所有 key 的 Set 集合 Collection&lt;V&gt; values() 获取所有 value 的集合 Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() 获取所有键值对映射关系的 Set 集合 default void forEach(BiConsumer&lt;? super K, ? super V&gt; action) 遍历键值对并消费 2.4 HashMap1 JDK7：数组 + 链表1 相关概念 DEFAULT_INITIAL_CAPACITY = 16 默认初始容量 DEFAULT_LOAD_FACTOR = 0.75f 默认加载因子 threshold = capacity * loadFactor 阈值/临界值，到达此值数组需要扩容 2 过程 构造时，初始化一个长度为 16 的 Entry[] 数组，并算出 threshold 阈值 每次 put() 添加时，先获取 key 的哈希值，然后根据某种算法计算出在 Entry[] 数组中的存放位置 如果此位置没有数据，则将键值对构建为 Entry 对象添加成功 如果此位置有数据，则比较新加 key 与已存在 key 的哈希值 如果不同，则添加成功 如果相同，则继续比较 key 的 equals() 如果不同，则添加成功 如果相同，则覆盖 value key 不重复时，当大于等于阈值且要存储的位置没有数据时需要扩容（默认变为原容量 2 倍），且集合元素重新计算位置 同一位置的多个数据以链表形式存在，新元素在上边，旧元素会作为新元素的 next 2 JDK8：数组 + 链表/红黑树1 相关概念 DEFAULT_INITIAL_CAPACITY = 16 默认初始容量 DEFAULT_LOAD_FACTOR = 0.75f 默认加载因子 MAXIMUM_CAPACITY = 1 &lt;&lt; 30 最大容量 TREEIFY_THRESHOLD = 8 树化阈值，当链表长度达到此长度时，要考虑树化 UNTREEIFY_THRESHOLD = 6 反树化阈值，当树中的节点个数到达此值时，要考虑变为链表 MIN_TREEIFY_CAPACITY = 64 最小树化容量，当达到树化阈值且容量不小于次之时，才会树化 threshold = capacity * loadFactor 阈值/临界值，当已用容量到达此值数值时，要考虑扩容 2 过程 构造时，没有初始化数组 第一次 put() 添加时，将数组初始化为长度为 16 的 Node[] 数组，并算出 threshold 阈值 添加时过程相同，区别在于链表存储时七上八下，jdk8新的元素在下边，旧元素的 next 指向新元素 添加时还需要判断该索引下是否已经是树结构 如果不是，则判断是否需要树化，当达到树化阈值及树化容量时，会将链表变为红黑树 如果是，则添加 添加时还需要判断扩容问题 2.5 Properties 修饰 方法 说明 String getProperty(String key) 根据 key 获取 value，若不存在则返回 null String getProperty(String key, String defaultValue) 根据 key 获取 value，若不存在则返回 defaultValue Object setProperty(String key, String value) 添加键值对，调用的 HashTable 的 put 方法 Set&lt;String&gt; stringPropertyNames() 获取所有 key 的 Set 集合 Enumeration&lt;?&gt; propertyNames() 获取所有 key 的枚举 void load(InputStream inStream) 从字节输入流中读取键值对数据 void load(Reader reader) 从字符输入流中读取键值对数据 void store(OutputStream out, String comments) 将键值对数据写入字节输出流，comment 为描述信息 void store(Writer writer, String comments) 将键值对数据写入字符输出流 三 集合遍历3.1 java.lang.Iterable&lt;T&gt; 修饰 方法 说明 Iterator&lt;T&gt; iterator() 获取迭代器 default Spliterator&lt;T&gt; spliterator() 获取并行迭代器 default void forEach(Consumer&lt;? super T&gt; action) 增强 for 循环 3.2 java.util.Iterator&lt;E&gt; 修饰 方法 说明 boolean hasNext() 判断是否有下一个元素 E next() 获取下一个元素 default void remove() 删除 next() 获取的元素，即删除之前要先获取 default void forEachRemaining​(Consumer&lt;? super E&gt; action) 遍历并消费元素 3.3 java.util.ListIterator&lt;E&gt;1 说明 ListIterator 是 Iterator 的子接口 在迭代时可以添加修改元素，且可以往回迭代 2 API 修饰 方法 说明 boolean hasNext() 判断是否有下一个元素 E next() 获取下一个元素 int nextIndex() 获取下一个元素的索引 boolean hasPrevious() 判断是否有上一个元素 E previous() 获取上一个元素 int previousIndex() 获取上一个元素的索引 void add(E e) 添加元素 void remove() 删除 next() 或 previous() 获取的元素 void set(E e) 修改 next() 或 previous() 获取的元素 3.4 集合遍历的方式1 集合转为数组，使用普通 for 循环 遍历时可以增删，索引要相应变化 2 迭代器 遍历时如果增会发生并发修改异常 ConcurrentModifyException 遍历时可以使用迭代器的删除方法进行删除 3 增强 for 循环 Iterable 接口的子类或子接口都可以使用 foreach，如数组，集合 遍历时不能增删，因为增强 for 循环底层还是迭代器，增删会发生并发修改异常 3.5 modCount 在 ArrayList，LinkedList，HashMap... 等集合中有此属性，用来记录集合被修改的次数（添加 删除） 使用迭代器或 foreach 遍历集合时，会记录遍历开始时的 modCount 遍历时使用迭代器自身的增删方法修改集合，不会改变 modCount 遍历时使用集合的增删方法，会修改 modCount，前后 modCount 不一致，说明有两个线程在同时操作集合，这种操作有风险，为了保证安全性就会报异常 四 泛型（Generics）4.1 概述 如果没有泛型，就意味着你并不知道集合中存储的是什么类型的数据，那就只能认为都是 Object，所以在使用时，你想要把数据当作某种具体的类型来使用 需要强制类型转换 有可能 ClassCastException 异常 泛型就是一种可以在使用时明确数据类型的功能（类似形参实参） 定义时声明了泛型 使用时就可以使用泛型这种功能来明确数据类型 泛型的好处 明确了数据类型，使用时就不用再做类型转换 限定了数据类型，就意味着如果不合法，编译通不过，把运行期的错误提前到了编译期 泛型：参数化类型 Parameterized type &lt;引用数据类型&gt; 4.2 泛型定义1 定义语法 目标 语法 泛型类 修饰符 class 类名&lt;泛型形参列表&gt;{} 泛型接口 修饰符 interface 接口名&lt;泛型形参列表&gt;{} 泛型方法 修饰符 &lt;泛型形参列表&gt; 返回值类型 方法名(形参列表) {} 泛型形参可以为任意标识符，如 E T K V ... 泛型定义时可以限定使用时的类型上下限 T extends 上限 T super 下限 类/接口上定义的泛型，内部非静态成员可以直接使用 创建对象时指定具体类型 子类上指定具体类型 静态成员不能使用泛型，因为静态比泛型确定具体类型的时机要早 方法上定义的泛型，可以在方法形参和内部使用 调用方法时指定具体类型 泛型方法可以是静态的，因为是调用时确定的类型 方法上的泛型与类或接口没有关系 2 泛型类/接口的子类1 明确数据类型12修饰符 class 子类名 extends 父类&lt;具体类型&gt; &#123;&#125;修饰符 class 子类名 implements 接口&lt;具体类型&gt; &#123;&#125; 2 不明确数据类型12修饰符 class 子类名&lt;泛型形参列表&gt; extends 父类&lt;泛型形参列表&gt; &#123;&#125;修饰符 class 子类名&lt;泛型形参列表&gt; implements 接口&lt;泛型形参列表&gt; &#123;&#125; 4.3 泛型通配符 通配符 说明 &lt;?&gt; 写入时只能添加 null，读取时读取的类型为 Object ? extends E 设定上限，必须是 E 及其子类 ? super E 设定下限，必须是 E 及其父类 A 和 B 是子父类关系，G&lt;A&gt; 和 G&lt;B&gt; 没有关系，它们共同父类是 G&lt;?&gt; 为什么使用 ? 而不能用 Object 123456789101 public void show(Collection&lt;?&gt; c) &#123;&#125; // 正确 /* 因为使用时，ArrayList&lt;String&gt; 就意味着将通配符指定为 String 则 ArrayList&lt;String&gt; = new ArrayList&lt;String&gt;(); 没问题 */2 public void show(Collection&lt;Object&gt; c) &#123;&#125; // 错误 /* 因为使用时， ArrayList&lt;String&gt; = new ArrayList&lt;Number&gt;(); 由于接收的是 Object 所以理论上是没有问题的，但泛型前后必须一致，所以错误 */ 五 java.util.Collections1.1 增删改查 修饰 方法 说明 static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements) 添加多个元素到指定集合 static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) 将 List 集合 src 中的元素拷贝到 dest 中 static &lt;T&gt; boolean replaceAll(List&lt;T&gt; list, T oldVal, T newVal) 将 List 中所有的 oldVal 替换为 newVal static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) List 集合二分查找，要求 List 中的元素有比较性 static &lt;T&gt; int binarySearch(List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c) List 集合二分查找，使用指定比较器 static int frequency(Collection&lt;?&gt; c, Object o) 获取指定元素在集合中出现的次数 1.2 排序 修饰 方法 说明 static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) 按照元素自然顺序对 List 集合排序 static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) 使用指定比较器对 List 集合排序 static void reverse(List&lt;?&gt; list) 反转 LIst 集合 static void shuffle(List&lt;?&gt; list) 随机洗牌 static void swap(List&lt;?&gt; list, int i, int j) 交换 LIst 集合指定索引的元素 1.3 获取集合1 immutable 修饰 方法 说明 static &lt;T&gt; List&lt;T&gt; singletonList(T o) 返回不可变的只包含一个元素的 List 集合 static &lt;T&gt; Set&lt;T&gt; singleton(T o) 返回不可变的只包含一个元素的 Set 集合 static &lt;K, V&gt; Map&lt;K, V&gt; singletonMap(K key, V value) 返回不可变的只包含一对键值的 Map 集合 2 synchronized 修饰 方法 static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c) static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s) static &lt;T&gt; NavigableSet&lt;T&gt; synchronizedNavigableSet(NavigableSet&lt;T&gt; s) static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s) static &lt;K, V&gt; Map&lt;K, V&gt; synchronizedMap(Map&lt;K, V&gt; m) static &lt;K, V&gt; NavigableMap&lt;K, V&gt; synchronizedNavigableMap(NavigableMap&lt;K, V&gt; m) static &lt;K, V&gt; SortedMap&lt;K, V&gt; synchronizedSortedMap(SortedMap&lt;K, V&gt; m) 3 Unmodifiable（只读） 修饰 方法 static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c) static &lt;T&gt; List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list) static &lt;T&gt; Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; s) static &lt;T&gt; NavigableSet&lt;T&gt; unmodifiableNavigableSet(NavigableSet&lt;T&gt; s) static &lt;T&gt; SortedSet&lt;T&gt; unmodifiableSortedSet(SortedSet&lt;T&gt; s) static &lt;K, V&gt; Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m) static &lt;K, V&gt; NavigableMap&lt;K, V&gt; unmodifiableNavigableMap(NavigableMap&lt;K, ? extends V&gt; m) static &lt;K, V&gt; SortedMap&lt;K, V&gt; unmodifiableSortedMap(SortedMap&lt;K, ? extends V&gt; m)","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-IO","slug":"Java/Java-IO","date":"2020-09-29T07:52:03.000Z","updated":"2020-09-29T07:53:01.952Z","comments":true,"path":"2020/09/29/Java/Java-IO/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-IO/","excerpt":"","text":"一 File1.1 概述 File 类代表了一个文件或一个目录 File 类中涉及到的关于文件或目录的创建、删除、修改等方法，并未涉及到写入或读取文件内容的操作。如需读写文件内容，必须通过 IO 流来完成 1.2 属性 修饰 属性 说明 static char separatorChar 路径分隔符；unix &#39;/&#39;，windows &#39;\\\\&#39; static String separator &quot;&quot; + separatorChar static char pathSeparatorChar 多个路径之间的分隔符；unix : ，windows ; static String pathSeparator &quot;&quot; + pathSeparatorChar 1.3 构造 构造 说明 File​(String pathname) 根据路径字符串构造 File File​(String parent, String child) 根据父路径字符串和子路径字符串构造 File File​(File parent, String child) 根据父 File 和 子路径字符串构造 File File(URI uri) 根据 uri 构造 File 1.4 方法1 创建 修饰 方法 说明 boolean createNewFile() 创建文件，已存在则不创建 boolean mkdir() 创建目录，已存在则不创建 boolean mkdirs() 递归创建目录 2 删除 修饰 方法 说明 boolean delete() 删除文件或空目录（不走回收站） boolean renameTo(File dest) 路径相同则重命名，路径不同则剪切 3 判断 修饰 方法 说明 boolean exists() 是否存在 boolean isDirectory() 是否是目录 boolean isFile() 是否是文件 boolean canRead() 是否可读 boolean canWrite() 是否可写 boolean isHidden() 是否是隐藏 boolean isAbsolute() 是否是绝对路径 4 获取 修饰 方法 说明 String getName() 获取文件名 String getPath() 获取构造 File 对象时指定的路径 String getAbsolutePath() 获取绝对路径 String getCanonicalPath() 获取规范路径（自动解析 . ..） long length() 获取文件大小 long lastModified() 获取文件最后修改时间 String getParent() 获取父目录路径的字符串 File getParentFile() 获取父目录路径的 File 对象 5 遍历目录 修饰 方法 说明 static File[] listRoots() 获取系统可用盘符 String[] list() 获取目录下所有文件和目录的字符串名称的数组 String[] list(FilenameFilter filter) 文件名过滤器 File[] listFiles() 获取目录下所有文件和目录的 File 对象的数组 File[] listFiles(FileFilter filter) 文件过滤器 File[] listFiles(FilenameFilter filter) 文件名过滤器 二 IO 流的异常处理2.1 JDK 7123456789101112131415InputStream in = null;try&#123; in = new FileInputStream(\"test.txt\"); 业务代码;&#125; catch(IOException e) &#123; 异常处理;&#125; finally&#123; if(in!=null)&#123; try&#123; in.close(); &#125;catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 2.2 JDK 81234567try ( 需要关闭的资源;) &#123; 业务代码;&#125; catch (IOException e)&#123; 异常处理&#125; 实现了 java.lang.AutoCloseble 的资源可以使用此语法自动关闭（无论是否发生异常） IO 流体系实现了此接口 JDK9 以后要关闭的资源可以在 try 外边初始化 三 基础流3.1 字节输入流1 体系 2 InputStream 修饰 方法 说明 abstract int read() 读取单个字节，返回字节的 int 值，流末尾返回 -1 int read​(byte[] b) 读取字节并存储到数组中，返回读取的字节个数，流末尾返回 -1 int read​(byte[] b, int off, int len) 读取字节并存储到数组指定位置，返回读取的字节个数，流末尾返回 -1 byte[] readAllBytes() 读取流中所有字节 long transferTo(OutputStream out) 将当前输入流中所有数据传递给输出流，并返回传递字节数 void close() 关闭流 字节流读取中文 使用 read() 读取一个字节肯定乱码 使用 read(byte[] b) 缓存数组读取有可能乱码，因为数组长度与数据的字节个数未必恰好吻合，有可能会出现一个字符多个字节但只读取到部分的情况 3.2 字节输出流1 体系 2 OutputStream 修饰 方法 说明 abstract void write​(int b) 写单个字节 void write(byte[] b) 写字节数组 void write(byte[] b, int off, int len) 写字节数组的指定部分 void flush() 刷新，即将缓冲区数据写到目的地，刷新后还可以继续写 void close() 关闭前会自动刷新 3.3 字符输入流1 体系 2 Reader 修饰 方法 说明 int read() 读取单个字符，返回 Unicode 码元（0~65535），流末尾返回 -1 int read(char[] cbuf) 读取字符并存储到数组中，返回读取的字符个数，流末尾返回 -1 abstract int read​(char[] cbuf, int off, int len) 读取字符并存储到数组指定位置，返回读取的字符个数，流末尾返回 -1 abstract void close() 关闭流 字符流一次读取一个字符，字符流怎么知道几个字节是一个字符呢？ 跟字符集有关，如GBK中中文都是1开头的 字符流编码转换过程 read() 按照指定字符集读取 → 查询 unicode 中对应的码点（因为 java 为 unicode） 比如文件内容为一个字 “北”，假如使用的码表为GBK，字符流读取结果为 十进制：21271，转为十六进制为 \\u5317，先读取文件根据GBK转成了 “北”，然后查“北”在 Unicode 中的码点 3.4 字符输出流1 体系 2 Writer 修饰 方法 说明 void write(int c) 写单个字符 void write(String str) 写字符串 void write(String str, int off, int len) 写字符串的指定部分 void write(char[] cbuf) 写字符数组 abstract void write(char[] cbuf, int off, int len) 写字符数组的指定部分 abstract void flush() 刷新 abstract void close() 关闭前会自动刷新 四 文件流4.1 FileInputStream 构造方法 说明 FileInputStream(File file) 根据 File 对象创建，文件必须存在 FileInputStream(String name) 根据文件路径创建，文件必须存在 4.2 FileOutputStream 构造方法 说明 FileOutputStream(File file [, boolean append]) 文件不存在会创建，文件存在会清空 FileOutputStream(String name [, boolean append]) 文件不存在会创建，文件存在会清空 五 缓冲流5.1 概述 缓存流和定义数组哪个快？ 定义数组快，因为读写操作的都是同一个数组，而缓存流分输入和输出，操作的是两个数组 关闭流时，先关外层，再关内层，而关外层流时内层流会自动关闭 5.2 字节缓冲流1 BufferedInputStream 构造方法 说明 BufferedInputStream​(InputStream in [, int size]) 默认缓存区大小为 8192 字节 2 BufferedOutputStream 构造方法 说明 BufferedOutputStream(OutputStream out, int size) 默认缓存区大小为 8192 字节 5.3 字符缓冲流1 BufferedReader 构造方法 说明 BufferedReader​(Reader in [, int sz]) 默认缓存区大小 8192 字符 修饰 方法 说明 String readLine() 读取一行并返回（不包括换行符），流末尾返回 null 2 BufferedWriter 构造方法 说明 BufferedWriter​(Writer out [, int sz]) 默认缓存区大小 8192 字符 修饰 方法 说明 void newLine() 写出换行符（可跨平台） 六 转换流6.1 概述 转换流属于字符流，提供了字节流和字符流之间的转换 InputStreamReader：InputStream → Reader OutputStreamWriter：Writer → OutputStream 字符流原理就是转换流使用平台默认字符集将字节流转换成了字符流 12FileWriter fw = new FileWriter(\"test.txt\");OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"test.txt\"),\"utf-8\"); 字符流 = 转换流(字节流 + 默认字符集) 如果默认字符集是 utf-8 ，则上述两句是等价的 6.2 InputStreamReader 构造方法 说明 InputStreamReader​(InputStream in [, String charsetName)] 字节流到字符流的桥梁，使用指定字符集解码 使用字节流读取文本数据时，先读取字节数据，然后使用字符集解码 InputStreamReader：读取字节数据并使用字符集解码 6.3 OutputStreamWriter 构造方法 说明 OutputStreamWriter​(OutputStream out [, String charsetName]) 字符流到字节流的桥梁，使用指定字符集编码 使用字节流写出文本数据时，先使用字符集编码，然后写出字节数据 OutputStreamWriter：使用字符集编码并写出字节数据 6.4 两种方法实现键盘录入123456// 1BufferedReader br=new BufferedReader(new InputStreamReader(System.in))BUfferedWriter bw=new BufferedWriter(new OutputStreamWriter(System.out)) // 2Scanner sc=new Scanner(System.in); 七 打印流7.1 概述 可以对多种数据类型进行打印，并保持数据的表示形式 write(int) ：只会写出 1 个字节 print(int) ：可以写出 4 个字节 不抛出 IOException 打印原理 基本数据类型先变成字符串再打印 引用数据类型非 null 就调用对象的 toString()，null 就打印 null PrintWriter &amp; printStream PrintStream 能做的 PrintWriter 也都能实现且功能更强大，但 PrintStream 出现较早，System.out 使用的是 PrintStream 来实现的，所以为了兼容并没有废弃 PrintStream 二者都提供了一系列重载的 print println 方法 PringtStream 打印的所有字符都使用平台默认的字符集来编码为字节数据，打印字符时，建议使用 PrintWriter PrintWriter &amp; printStream 都可以设置自动刷新 printStream：写入字节数组、任何重载版本的 println() 被调用、一个换行符（char）被写入、一个换行符的字节存储（\\n）被写入 PrintWriter： 自动刷新只对 println() printf() format() 这些方法有效 7.2 PrintStream 构造 说明 PrintStream​(File file [, String charsetName]) 接收 File 对象 PrintStream​(String fileName [, String charsetName]) 接收字符串路径 PrintStream​(OutputStream out [, boolean autoFlush [, String encoding]]) 接收字节输出流 7.3 PrintWriter 构造 说明 PrintWriter​(File file [, String charsetName]) 接收 File 对象 PrintWriter​(String fileName [, String charsetName]) 接收字符串路径 PrintWriter​(OutputStream out [, boolean autoFlush [, Charset charset]]) 接收字节输出流 PrintWriter​(Writer out [, boolean autoFlush]) 接收字符输出流 7.4 标准输入输出流 流 类型 说明 设备 System.in InputStream 标准输入 键盘 System.out PrintStream 标准输出 显示器（控制台） System.err PrintStream 标准错误输出 显示器（控制台） 八 序列化流（对象流）8.1 概述 序列化 &amp; 反序列化 序列化：写出一个对象 反序列化：读取一个对象 对象序列化机制：好处在于将对象转化为字节数据，使其在保存和传输时可被还原 允许把内存中的 Java 对象转换成平台无关的二进制流，从而把这种二进制流持久的保存在磁盘上或通过网络进行传输 当其它程序获取这种二进制流，就可以恢复成原来的 Java 对象 对象序列化的条件： 对象必须实现序列化接口 Serializable ：序列化标记接口，对象序列化内容和顺序都是默认的 Externalizable ：Serializable 的子接口，可定制序列号内容和顺序 对象的所有属性也必须可序列化 引用类型的属性也必须实现序列化接口 基本类型属性默认可序列化 对象不会序列化的属性 transient 关键字修饰的属性 static 关键字修饰的属性 序列化ID ：serialVersionUID 用于判断类和对象是否是同一个版本 建议实现序列化接口时就指定，否则每次重新编译类，序列化ID都会变化 8.2 ObjectInputStream1 构造 构造 说明 ObjectInputStream​(InputStream in) 装饰字节输入流 2 方法 修饰 方法 说明 Object readObject() 读取对象 8.3 ObjectOutputStream1 构造 构造 说明 ObjectOutputStream(OutputStream out) 装饰字节输出流 2 方法 修饰 方法 说明 void writeObject(Object obj) 写出对象 九 数据流9.1 概述 数据流主要用来操作基本类型和 String 类型的数据，这些数据如果使用其它流读写，可能会出问题 以二进制形式读写数组，字符，字符串，布尔… 9.2 DataInputStream1 构造 构造 说明 DataInputStream​(InputStream in) 装饰字节输入流 2 方法 修饰 方法 说明 String readUTF() 读字符串 T readT() 读指定类型数据，readInt() readDouble() ... 9.3 DataOutputStream1 构造 构造 说明 DataOutputStream​(OutputStream out) 装饰字节输出流 修饰 方法 说明 void writeUTF​(String str) 写字符串 void writeT(T t) 写指定类型数据，writeInt(int i) writeDouble(double d) ... 十 内存流10.1 概述 操作字节数组 流关闭无效，不抛 IOException 向内存中读写数组 字节流读取中文时，可能会乱码，可以使用内存输出流先写到内存中，然后一次性获取所有数据 10.2 ByteArrayInputStream1 构造 构造 说明 ByteArrayInputStream(byte[] buf [, int offset, int length]) 把字节数组作为缓冲数组 2 方法 修饰 方法 说明 int read() 读取一个字节 int read(byte[] b, int off, int len) 读取字节并存储在数组中 10.3 ByteArrayOutputStream1 构造 构造 说明 ByteArrayOutputStream([int size]) 可以指定缓冲区大小 2 方法 修饰 方法 说明 void write(int b) 写出一个字节 void write(byte[] b, int off, int len) 写出数组指定数据 byte[] toByteArray() 将缓冲区的数据全部取出，获取一个字节数组 String toString() 将缓冲区的数据用平台默认编码转为字符串","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-异常","slug":"Java/Java-异常","date":"2020-09-29T07:50:06.000Z","updated":"2020-09-29T07:52:42.321Z","comments":true,"path":"2020/09/29/Java/Java-异常/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-%E5%BC%82%E5%B8%B8/","excerpt":"","text":"一 异常体系 非受检异常： Unchecked Exception Error 在你的控制范围之外 一般指 JVM 系统内部错误或资源耗尽等严重问题，一般不编写针对性的代码进行处理 RuntimeException 一般是程序员所犯的错误，由于代码不够健壮引起的异常，如果出现 RuntimeException 那么一定是你的问题 不应该处理，而是一开始就应该避免 受检异常：Checked Exception 非受检异常 Error 和 RuntimeException 外的所有异常都是受检异常，或叫编译时异常 编译时异常一般是由程序的运行环境导致的，程序可能被运行在各种未知的环境下，而程序员无法干预用户的使用环境 检查型异常需要处理：声明或捕获 二 异常处理（抛抓模型）2.1 “抛” 过程1. 概述 程序出现异常时，会在异常代码处创建一个异常对象（包含内容，原因，位置 …），并将此对象抛出 一旦抛出异常对象后，其后的代码就不再执行 抛出异常有两种方式 系统自动生成并抛出的异常 手动抛出异常 throw 2 throw1throw 异常对象实例; throw 用在在方法中，抛出异常 非受检异常 throw 后可以不用处理 受检异常 throw 后必须处理：try-catch 或 throws throw 会终止程序，代替 return 2.2 “抓” 过程1 概述 可以理解为异常的处理方式 共有两种： try-catch-finally throws 2 try-catch12345678910111213try( // 可能出现异常的代码) catch(异常类型1 变量名1) &#123; // 异常处理;&#125; catch(异常类型2 变量名2) &#123; // 异常处理;&#125; catch(异常类型3 变量名3) &#123; // 异常处理;&#125; ...finally &#123; // 可选&#125; try catch 处理异常后，程序可以继续运行 多 catch 时，大的异常要放在后边，因为会依次匹配，匹配到就停止 try 中的代码发生异常相当于创建了一个异常对象，然后赋值给 catch 后边括号中的变量 3 throws1void test() throws 异常1, 异常2, ... &#123;&#125; throws 用在方法上，声明此方法可能抛出的异常 可以声明多个，逗号分隔 一旦出现异常，把异常对象抛给此方法的调用者，若调用者也没有处理，则一直抛直到 main 函数，如果 main 函数也没有处理，则抛给 JVM 处理，JVM 默认异常处理机制：printStackTrace() 三 java.lang.Throwable3.1 构造 构造 Throwable() Throwable(String message) Throwable(Throwable cause) Throwable(String message, Throwable cause) 3.2 方法 修饰 方法 说明 String toString() 返回异常类名和异常信息的字符串 String getMessage() 获取异常信息 void printStackTrace() 打印异常类名和异常信息，以及异常出现在程序中的位置 Throwable getCause() 获取原因 Throwable initCause(Throwable cause) 为异常对象设置原因，如果已有原因则抛出一个异常 StackTraceElement[] getStackTrace() 获取构造异常对象时调用堆栈的轨迹 四 自定义异常1234567891011class MyException extends RuntimeException &#123; statci final long serialVersionUID = xxxxx; public MyException() &#123; super(); &#125; public MyException(String message) &#123; super(message); &#125;&#125; 继承现有异常结构： Exception 或 RuntimeException 提供重载构造器：建议保留无参构造和带 message 的有参构造 由于 Throwable 实现了 Serializable 接口，建议自定义异常时指定 serialVersionUID 五 思考 return 与 finally 混用 执行到了 return，已经把要返回的结果准备好了。这时先去执行 finally 中的代码，然后再 return 如果 finally 中改变了要 return 的值，最终返回结果也不会改变，因为 return 的值已经缓存好了，改变了也没用。 如果 finally 中也有 return，那么最后返回的是 finally中的返回值 六 断言6.1 语法 assert condition; 如果 condition 为 false 则抛出 AssertionError 异常 assert condition: expression; 如果 condition 为 false 则抛出 AssertionError 异常，且 expression 会传入 AssertionError 构造器，并转为一个消息字符串 6.2 启用/禁用断言 断言默认是禁用的 运行时使用 -enableassertions 或 -ea 启用 12java -ea Test 打开某个类的断言java -ea:xxx.xx.x Test 打开包下所有类的断言 -disableassertions 或 -da 禁用断言","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-面向对象","slug":"Java/Java-面向对象","date":"2020-09-29T07:45:40.000Z","updated":"2020-11-04T12:46:15.280Z","comments":true,"path":"2020/09/29/Java/Java-面向对象/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"一 概述1.1 编程范式 programming paradigm 术语 说明 Procedural programming 面向过程 Object-Oriented Programming 面向对象 Functional Programming 函数式 Event-driven Programming 事件驱动 Aspect-oriented Programming 面向切面 Logic Programming 逻辑 1.2 面向对象和面向过程 把大象装进冰箱 面向过程 POP（Process Oriented Programming） 打开冰箱门 把大象放进去 关上冰箱门 面向对象 OOP（Object Oriented Programming） 冰箱（开门，关门） 大象（进冰箱） 人（指挥冰箱开门，指挥大象进去，指挥冰箱关门） 区别 面向过程 强调的是功能行为，以函数为最小单位，考虑怎么做 性能相对较好，但耦合性高，不易维护、复用和扩展 面向对象 强调具备了功能的对象，以类/对象为最小单位，考虑谁来做 耦合度低，易维护、易复用、易扩展 二 类2.1 概念 概念 说明 类 class 对一类事物的描述，模板 对象 object 某类事物的个体，也叫实例（instance） 属性 field 类的成员变量，也叫字段，域 方法 method 类的成员函数，也叫行为 2.2 类成员1234567修饰符 class 类名 &#123; 属性列表 代码块 构造器列表 方法列表 内部类&#125; 1 构造器 构造函数的名称必须与类名相同 一个类可以有多个构造器，彼此构成重载 若类中没有显式定义构造函数，则会有一个默认空参构造函数（修饰符与类一致 public 或 default） 构造函数第一行一定直接或间接调用父类构造函数，即如果在构造器首行没有显式的使用 this(形参列表) 或 super(形参列表) ，则默认调用了 super() 2 属性1 语法12修饰符 数据类型 属性名; // 默认初始值修饰符 数据类型 属性名 = 值; // 显式初始值 2 成员变量（实例变量/静态变量）和局部变量 变量 声明位置 初始值 存储位置 实例变量 类中 有 堆 静态变量 类中 有 方法区 局部变量 方法形参、方法内、代码块内、构造形参、构造内 无 栈 3 方法1 语法123修饰符 返回值 方法名(形参列表) &#123; 方法体;&#125; 2 形参列表 参数1, 参数2, ... 参数类型 ... 参数名 （可变参数） 可以传递 0 到 多个参数 可变参数必须在形参的最后声明 3 参数传递 Java 参数传递是值传递 基本数据类型实参赋值给形参的是实参真实存储的数据值 引用数据类型实参赋值给形参的是实参存储数据的地址值 java 在传递参数时，将实际参数的副本（拷贝一份）传入方法内，而参数本身不受影响 4 方法的重载（Overload） 同一个类中，方法名相同，形参列表不同（个数、顺序或类型）即为重载 4 代码块1 构造代码块12345&#123; 构造代码块： 1 每次创建类实例都会在构造器之前执行 2 如果有多个，按照声明顺序执行&#125; 2 静态代码块12345static &#123; 静态代码块： 1 随着类的加载而执行，且仅在加载类字节码文件时执行一次 2 如果有多个，按照声明顺序执行 &#125; 5 内部类1 分类 类型 分类 声明位置 成员内部类 非静态成员内部类（成员内部类）静态成员内部类（静态内部类） 类中 局部内部类 非匿名局部内部类（局部内部类）匿名局部内部类（匿名内部类） 方法中，代码块中，构造器中 2 成员内部类1 概述 当描述一个事物时，发现内部还有一个完整的结构需要一个类来描述，且此内部结构独立存在没有意义，必须依附外部类。就可以定义内部类。如身体和心脏。 内部类作为外部类的成员 访问外部类 内部类可以直接访问外部类的成员（包括私有），内部类持有一个外部类的引用 外部类名.this 外部类要访问内部类的成员，必须创建对象 可以被 4 种权限修饰符修饰 可以被 static 修饰：只要内部类不需要访问外部类对象，就应该使用静态内部类 内部类作为一个类 可以定义属性、方法、构造器等等 可以被 abstract final 修饰 2 非静态成员内部类（成员内部类） 成员内部类中不能有任何 static 的定义 成员内部类的访问 123456// 1 首先要创建外部类对象Outer out = new Outer();// 2 使用外部对象创建内部类对象Out.inner in = out.new Inner()// 简写Outer.Inner in=new Outer().new Inner(); 3 静态成员内部类（静态内部类） 静态内部类可以定义所有普通类可以定义的内容 静态内部类不会随着外部类的加载而加载，只有使用时才会加载 静态内部类的访问 12// 创建静态内部类对象Outer.Inner in=new Outer.Inner() 3 局部内部类1 概述 局部内部类修饰符只能有 final 和 abstract 局部内部类访问其所在方法的局部变量时，要求此局部变量必须是 final 因为当调用这个方法时，如果方法中的局部变量不是 final 的，那么方法弹栈此局部变量也就消失了，而此时局部内部类对象可能还存在，就会访问不到此局部变量 JDK 8 可以不加 final，但实际还是 final 的 2 非匿名局部内部类（局部内部类）12345public void method() &#123; class A&#123; &#125;&#125; 3 匿名局部内部类（匿名内部类）12345public void method() &#123; new 父类/父接口() &#123; 重写方法; &#125;&#125; 2.3 对象实例化过程 加载 class 文件（有父类先加载父类） 静态变量和静态代码块（谁在前谁先执行，只执行一次） 属性默认初始化 构造函数第一行（调用父类构造） 属性显式初始化和构造代码块（谁在前谁先执行，每次创建对象都会执行） 构造函数剩余行 三 面向对象特征3.1 权限修饰符 修饰符 本类 同一个包(子类+无关类) 不同包(子类) 不同包(无关类) private √ × × × default √ √ × × protected √ √ √ × public √ √ √ √ 权限修饰符是用来限定该类实例对象对该类成员的访问权限 在不同包的类中严格来说我认为只能访问 public 修饰的成员，特殊情况是不同包的子类中能使用子类实例访问到父类 protected 修饰的成员（使用父类实例是访问不到的），是因为继承的关系，在自己类中访问自己继承的东西当然可以访问到。 12345// 在子类 A 中this.clone() // 正确new A().clone() // 正确new Object().clone() // 错误new B().clone() // 错误 3.2 封装（Encapsulation） 封装即隐藏该隐藏的，暴露该暴露的 隐藏对象内部的复杂性，之对外公开简单接口，便于外界调用，提高维护性和扩展性 封装性的体现 private 私有化属性而提供公共的 getter/setter 方法 不对外暴漏的私有方法 单例… 3.3 继承（Inheritance）1 概述 好处 提高代码的复用性 便于功能的扩展 让类与类产生关系，是多态的前提 弊端 类的耦合性增强了 开发原则：高内聚，低耦合 耦合：类与类的关系 内聚：自己完成某件事的能力 2 特点 子类会继承父类所有的属性和方法，私有的也会继承，只是不能直接访问 Java 是单继承，一个类只能有一个父类 3 重写（Override） 方法名一致 形参列表一致 返回值 基本数据类型和 void，必须完全一致 引用数据类型，一致或者其子类 权限修饰符 子类重写方法访问权限不能小于父类方法 异常 子类重写方法抛出的异常只能是父类方法抛出的异常或者其子类 子类重写方法不能抛出父类方法没有抛出的异常 不能被重写的方法 final 修饰的方法 static 修饰的方法 子类不能访问的方法 private 修饰的方法 跨包时默认修饰权限的方法 4 类型转换 只能在继承层次内进行类型转换 向上转型（upcasting）：子类转父类，多态，自动转换 向下转型（downcasting）：父类转子类，强制类型转换 强制类型转换前，应使用 instanceof 检查 12x instanceof A// 判断 x 对象所属类是否是 A 类或 A 类的子类 3.4 多态（Polymorphism）1 概述 一个对象变量可以指向多种实际类型的现象称为多态 编译时类型和运行时类型不一致，就出现了多态 编译时类型由声明时的类型决定 运行时类型由实际对象类型决定 虚拟方法调用：子类中定义了与父类同名同参的方法（重写），多态情况下，将父类方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法，这样的方法调用编译器是无法确定的 在运行时能自动的选择适当的方法称为动态绑定 dynamic binding 如果是 private static final 方法或构造器，编译器可以准确的知道调用哪个方法，称为静态绑定 static binding 2 多态前提 继承或实现 重写 父类引用指向了子类对象 3 多态性 成员 多态性 说明 成员变量（属性） 无 编译运行都看左边 非静态成员方法 有 编译看左边，运行看右边（动态绑定） 静态成员方法 无 编译运行都看左边 对象的多态性只适用于方法，不适用于属性 非静态成员方法：虚拟方法调用 编译时：查看声明类型所属类（父类）是否有此方法，有则编译通过，没有则报错 运行时：查看对象实例所属类（子类）是否有父类中此方法对应的重写方法，有则执行，没有则向上查找 例 12345678910111213141516public class Cat &#123; private void eatFish() &#123; System.out.println(\"猫吃鱼\"); &#125; public static void main(String[] args) &#123; Cat cat = new SmallCat(); cat.eatFish(); // 结果是 \"猫吃鱼\" &#125;&#125;class SmallCat extends Cat &#123; public void eatFish() &#123; System.out.println(\"小猫吃奶\"); &#125;&#125;// 因为父类是private，子类访问不到，所以并非是重写// 成员方法运行时调用的是子类重写方法，没有则会调用父类方法，所以结果是调用的父类方法 四 关键字4.1 this 方法中：代表调用该方法的对象 构造器中：代表正在初始化的对象 构造器中：调用本类其它构造器 4.2 super 构造器或方法中：访问父类属性或方法 构造器中：调用父类构造 4.3 static 随着类的加载而加载 优先于对象存在 被类的所有实例共享 直接使用类名调用 静态上下文只能访问静态，不能访问非静态，静态上下文中没有 this super 非静态上下文可以访问静态和非静态 4.4 final 修饰对象 说明 类 类不能被继承，一个类被声明为 final 则其方法自动变为 final 变量 变量就变成了常量，必须初始化且只能被赋值一次，大写 方法 方法不能被重写 4.5 abstract1 只能修饰类和方法 抽象类有构造方法，但不能实例化 抽象类可以有抽象方法也可以有一般方法（包括静态和非静态方法） 有抽象方法的一定是抽象类，抽象类不一定有抽象方法 2 abstract 不共存的关键字（抽象是为了重写） static 类直接调用一个抽象方法没有意义 private private 修饰的方法子类无法访问，也就无法重写，一个不能被重写的抽象方法没有意义 final final 修饰的类无法继承，一个不能被继承的抽象类没有意义 final 修饰方法无法重写，一个不能被重写的方法没有意义 native 因为 native 本身就没有方法体，不明确是什么情况 4.6 native native 修饰的方法，看不到方法体，不是 Java 语言实现的，而是调用了底层 C/C++ 的实现，存储在本地方法栈 native 方法正常调用即可，且可以重写 4.7 包1 package1package x.x.x; 同一个包下类/接口不能重名 用于控制访问权限 用于划分项目的结构层次，通常将功能相近的类划分到同一个包中 2 import12import java.util.*import static java.util.Math.*; 如果在源文件中，使用了不同包下的同名的类，则只有一个可以导入，其它需要使用全类名的方式 xxx.* 表示可以使用 xxx 包下的所有结构，但其子包下还需要导入 3 JDK 主要包说明 包 说明 java.lang Java语言的核心类/接口 java.io IO 功能相关类/接口 java.net 网络相关类/接口 java.util 实用工具类 java.text 格式化相关的类 java.sql JDBC数据库编程的相关类/接口 java.awt GUI 相关 java.applet applet 运行所需的类 五 main() 方法说明 作为程序的入口 可以当作普通的静态方法 String[] args 可以用来接收控制台参数（以空格隔开） 六 接口 Interface6.1 语法1234修饰符 interface 接口名 &#123; 接口属性列表; 接口方法列表;&#125; 接口没有构造器，不能创建对象 类可以多实现，接口可以继承接口 接口实现类必须实现所有的接口方法，否则仍是抽象类 6.2 成员 接口成员 修饰符 说明 全局常量 public static final 修饰符可以省略 抽象方法 public abstract 修饰符可以省略 静态方法 public static public 可以省略 默认方法 public default public 可以省略 私有方法 private 修饰符不能省略 JDK 8 以后接口为何新增静态方法? 因为一般工具类中都是静态方法，而这些静态方法通常都是为某个接口服务的，如 Collection Collections 把静态方法直接定义在接口中，可以避免增加额外的工具类 JDK 8 以后接口为何新增默认方法? 因为有时候，一个接口的多数实现类对接口的抽象方法的实现是一样的 把这样的抽象方法定义为默认方法，可以减少实现类的重复工作 如果实现类实现多个接口，出现了默认方法冲突（会报错） 从其中选择一个，重写默认方法（去掉 default） 都不用，重写默认方法（去掉 default） 如果实现类继承父类实现接口，出现了默认方法冲突（不会报错） 默认使用父类 手动改选接口 完全重写 Java 9 中 接口中可以有 private 方法 七 枚举 Enum7.1 概述 类的对象只有确定的有限个 枚举即将其所有可用对象直接在内部列出来 枚举不需要创建对象，构造函数默认即为私有的 当需要定义一组常量时，强烈建议使用枚举类 枚举也可以实现接口 7.2 自定义枚举1 手动实现枚举（JDK5 之前） 私有化构造函数 在类中创建所有可用的实例对象，定义为公有静态常量 public static final 2 enum 关键字1234修饰符 enum 枚举类名 &#123; 枚举项列表; 其它成员列表;&#125; 默认继承 java.lang.Enum 枚举项必须定义在首行，以逗号分隔，最后一个以分号结束 枚举项即为枚举类的实例 构造函数有参数，枚举项也要有参数 123enum Week&#123; MON(\"星期一\"),TUS(\"星期二\"),SUN(\"星期日\");&#125; 枚举类有抽象方法，枚举项也要实现 1234567enum Week &#123; Mon(\"星期一\")&#123; @Override public void show() &#123; &#125; &#125;;&#125; 7.3 java.lang.Enum1 构造 构造 protected Enum(String name, int ordinal) 此构造方法不是程序员调用的，而是由编译器调用的 所以不能在枚举类中手动调用父类构造 2 方法 修饰 方法 说明 String toString() 返回此枚举项的名称 int ordinal() 返回枚举项的编号 String name() 返回此枚举项的名称 int compareTo(E o) 比较枚举项的编号 static &lt;T extends Enum&lt;T&gt;&gt; valueOf(Class&lt;T&gt; enumType, String name) 返回指定类型中指定名称的枚举项 static T[] values() Enum 没有，所有枚举类都有，获取所有枚举项 static T valueOf(String name) Enum 没有，所有枚举类都有，返回指定名称的枚举项 八 注解 Annotation8.1 概述 注解是针对程序的注释，是给程序看的，用于描述程序如何运行及在什么阶段来运行。 注解在实际开发中，最大的功能是用于替换配置文件 一个完整的注解由三部分组成 声明 使用 读取 Java 把枚举看作类，把注解看作接口 所有注解都继承了 java.lang.annotation.Annotation 8.2 JDK 中三个基本注解 注解 说明 @Override 检查重写方法是否合法 @Deprecated 表示已过时 @SuppressWarnings({警告类型列表/all}) 抑制警告 8.3 文档注释相关注解 注解 说明 格式 @author 作者 @author 作者名 @version 版本 @version 1.0 @see 另请参阅 @see 另请参阅信息 @since 从 xx 版本开始引入 @since xx @param 参数信息，一对一 @param 形参名 形参类型 注释 @return 返回值信息 @return 返回值类型 注释 @throws 抛出异常信息 @throws 异常类型 注释 8.4 自定义注解1 声明12345修饰符 @interface 注解名&#123; 数据类型 属性名(); // 注解的属性类似方法 int age(); String name() default \"haha\"; // 可以设置默认值&#125; 注解数据类型 八种基本数据类型 String 类型 enum 枚举类型 Annotation 注解类型 Class 类型 以上类型的一维数组类型 如果注解没有成员，通常是标识作用 如果注解只有一个成员，建议属性名 value 2 使用12@Xxx(name=\"\") //非数组类型注解赋值@Xxx(name=&#123;\"\", \"\", \"\"&#125;) // 数组类型注解赋值 使用注解时注解中的所有属性都要赋值，有默认值的可以省略使用默认值 如果使用注解时最终配置的属性只有一个 value，则可以省略属性名 3 读取 使用反射读取注解 8.5 元注解（用在注解上的注解） 元注解 格式 说明 @target @target(ElementType.xxx) 标记此注解的使用位置 @Retention @Retention(RetentionPolicy.xxx) 标记此注解的生命周期 @Documented @Documented 标记此注解可以被 javadoc.exe 读取到 API @Inherited @Inherited 标记此注解可以被子类继承 1 ElementType 是一个枚举类，用于枚举注解使用的位置 枚举项 使用位置 TYPE 类，接口（包括注解）或枚举 FIELD 属性 METHOD 方法 PARAMETER 形参 CONSTRUCTOR 构造函数 LOCAL_VARIABLE 局部变量 ANNOTATION_TYPE 注解 PACKAGE 包 TYPE_PARAMETER 类型变量的声明语句（如泛型声明） TYPE_USE 使用类型的任何语句 2 RetentionPolicy 是一个枚举类，用于枚举注解的存活阶段 枚举项 说明 SOURCE 源代码阶段有效（即.java源文件保留），会被编译器舍弃，即编译后的字节码文件不保留 CLASS（默认） 字节码阶段有效（即 .class 文件保留），运行时不会保留 RUNTIME 运行阶段有效（即运行时保留），可通过反射获取 8.6 JDK8 新特新 可重复注解 @Repeatable 类型注解","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-语法","slug":"Java/Java-语法","date":"2020-09-29T06:29:26.000Z","updated":"2020-09-29T07:52:46.555Z","comments":true,"path":"2020/09/29/Java/Java-语法/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-%E8%AF%AD%E6%B3%95/","excerpt":"","text":"一 前言1.1 概述 术语 缩写 说明 Java Development Kit JDK Java 开发工具包，编写 Java 程序的程序员使用的软件 Java Runtime Environment JRE Java 运行时环境，运行 Java 程序的用户使用的软件 Standard Edition SE 标准版，用于桌面或简单服务器应用的 Java 平台 Enterprise Edition EE 企业版，用于复杂服务器应用的 Java 平台 Micro Edition ME 微型版，用于小型设备的 Java 平台 Java Virtual Machine JVM Java 虚拟机，Java 程序运行在虚拟机上而非操作系统上 Oracle JDK - 官方 Java SE Open JDK - Java SE 的一个免费开源实现 Software Development Kit SDK 过时，用于描述 1998 ~ 2006 年之间的 JDK NetBeans - Oracle 公司的集成开发环境 path - 为了在任意地方使用所配置路径下的命令 classpath - 寻找 .class 文件的路径 1.2 编译 &amp; 运行1 编译1javac a/b/c/test.java 执行 javac.exe 命令所在的目录 + 输入的 .java 文件路径 = .java 文件绝对路径 .java 文件可以有多个类，但只能有零或一个 public 类且必须与文件名相同 2 运行1java 字节码文件名 必须在类的全限定名所在的路径下执行 java.exe 命令，因为 classpath 不设置时，默认在当前路径寻找 .class 文件 二 注释2.1 单行注释1// 单行注释 2.2 多行注释123/* 多行注释禁止嵌套*/ 2.3 文档注释1234567891011/*** @author 作者* @see 另请参阅* @since 从 xxx 版本开始引入* @param 参数* @return 返回值* @throws 异常*/// 生成文档javadoc -d 文件夹名称 -encoding UTF-8 -charset UTF-8 -author -version xxx.java 三 标识符3.1 定义规则 合法字符 A~Za~z 0~9 _ $ 不能以数字开头，不能使用空格 不能使用关键字和保留字，但可以包含 严格区分大小写，长度无限制 3.2 命名规范 对象 规范 包名 所有单词小写 类名, 接口名 所有单词的首字母大写 变量名, 方法名 第一个单词首字母小写，后边首字母大写 常量名 所有单词大写，单词之间使用 _ 连接 四 数据类型4.1 概述 4.2 基本数据类型1 整型 类型 大小 无符号范围 有符号范围 默认初始值 byte 1 字节 0 ~ 255 -128 ~ 127 0 short 2 字节 0 ~ 65535 -215 ~ 215-1 0 int（默认） 4 字节 0 ~ 232-1 -231 ~ 231-1 0 long 8 字节 0 ~ 264-1 -263 ~ 263-1 0L Java 都是有符号的，整形默认为 int，long 类型声明时需要加 l 或 L 长度计算公式（n 为字节数） 有符号：-28n-1~ 28n-1-1 无符号：0~28n-1 进制表示： 二进制：0b 开头 八进制：0 开头 十进制：0x 开头 数字字面量可添加下划线，为了可读性，编译器会自动去除 10_000_000 常量优化机制：Java 中整数默认为 int 型，当把整数值赋值给非 int 的整型时，JVM 会判断整数值是否超过此类型的范围 没有超过，则自动进行隐式转换，如 byte b = 127 超过，则报错，如 byte b = 128 2 浮点型 类型 大小 默认初始值 float 4 字节 0.0F double（默认） 8 字节 0.0D 浮点型默认为 double ，float 类型声明时需要加 f 或 F 浮点型常量有两种表示形式 十进制数形式，如 3.14 3.14F .314 科学计数法形式，如 3.14e2 314E2 100E-2 3 布尔型 类型 取值 默认初始值 boolean true false false 4 字符型 类型 大小 范围 默认初始值 char 2 字节 \\u0000 ~ \\uffff（ 0 ~ 65535 ） \\u0000（空） 字符型：由单引号包裹的单个字符（汉字、字母、数字、符号） &#39;&#39;：错误，不能是空单引号 &#39; &#39;：正确，空格字符 字符型三种表现形式 单引号包裹的单个字符 转义符转义的特殊字符，如 &#39;\\n&#39; Unicode 值 Java 中字符使用 Unicode 字符集，编码规则为 UTF-16 ，表示形式为 \\u0000： \\u：转义序列，表示是 Unicode 0000：字符在 Unicode 中的码点对应的十六进制数 4.3 基本数据类型转换 自动类型转换（隐式转换）：低容量类型 → 高容量类型 强制类型转换：高容量类型 → 低容量类型，可能损失精度 boolean 类型与其他基本类型不能进行类型转换 运算时，会先将两个操作数转为同一类型 byte short char 都会先转为 int int → long → float → double：碰到靠右的则先转为其类型 4.4 大数 如果基本整数和浮点数精度不满足需求，可以使用 java.math 包下的类 BigInteger：可以实现任意精度的整数运算 BigDecimal：可以实现任意精度的浮点数运算 将数值转为大数 12BigInteger.valueOf(100)new BigInteger(String num) 4.5 字符串1 概述 Java 字符串即 Unicode 字符序列，如 &quot;Java\\u5B89&quot; 由 5 个 Unicode 字符组成 J a v a 安 字符串：由双引号包裹的 0 到 多个字符 每个字符串都是 java.lang.String 的一个实例 2 字符串常量池1 概述 字符串常量池中不会存储相同内容的字符串 String pool 是一个固定大小的 Hashtable，可通过 -XX:StringTableSize 设置长度 JDK6 默认长度是 1009，设置无要求 JDK7 默认长度是 60013，设置无要求 JDK8 开始默认长度是 60013，1009 是可设置的最小长度 2 创建字符串 字面量 字符串存储在常量池中 new new String(&quot;a&quot;) 对象1：new String(&quot;a&quot;) 对象2：常量池中的 &quot;a&quot; new String(&quot;a&quot;) + new String(&quot;b&quot;) 对象1：new StringBuilder() 对象2：new String(&quot;a&quot;) 对象3：常量池中的 &quot;a&quot; 对象4：new String(&quot;b&quot;) 对象5：常量池中的 &quot;b&quot; 对象6：new String(&quot;ab&quot;) StringBuilder.toString() 的底层实际是 new 了一个字符串 注意：&quot;ab&quot; 并不会存入常量池中 String 类的 intern() 当调用的字符串在字符串常量池中已存在，则直接返回池中对象的地址引用 当调用的字符串在字符串常量池中不存在 JDK6 会复制一个新的字符串对象放入常量池中，并返回池中对象的地址引用 JDK7 及以后，会将此字符串的地址放入常量池中，并返回池中对象的地址引用 3 拼接字符串 常量和常量拼接结果在常量池，原理是编译器优化 如果拼接中出现了变量，则相当于在堆中 new String()，结果就在堆中，原理是 StringBuilder 3 java.lang.String 不可变（immutable）的字符序列 不可变性：指对字符串重新赋值，连接，替换等操作时，都不会改变原有字符串序列，就好比 3 永远是 3，”hello” 永远是 “hello” 对字符串的改变，其实是将变量指向了另一个字符串，而非改变原有字符串 123String s = &quot;hello&quot;;s = &quot;hehe&quot;;// 改变了 s 的指向，而非改变字符串 &quot;hello&quot; 不可变的优点：可以共享 String 类在JDK8 及之前内部定义了 char[] 用来存储数据，从 JDK9 开始： 字符串全为单字节字符则使用 byte[] 实现，否则使用 char[] 实现 因为字符串实际使用的大部分字符只占一个字节，使用字符数组就占用了两个字节，浪费空间 4.6 数组1 概述 数组是多个相同类型数据按一定顺序排列的集合 数组既可以存基本数据类型，也可以存引用数据类型 数组长度一旦确定，就不能修改 数组相关概念 数组名 元素 element：数组中的每个数据 索引（角标/下标）index：从 0 开始 长度 lenght：数组中元素个数称为数组的元素 数组的存储 数组会在内存中（堆）开辟一块连续的空间，数组名引用的是这块连续空间的首地址 下标表示此元素距离首地址的偏移量 2 声明数组1 一维数组123456789101112// 1 静态初始化：数组的初始化和元素赋值同时进行// 1.1int[] arr = new int[]&#123;1, 3, 5&#125;// 1.2int[] arr = &#123;1, 3, 5&#125;// 2 动态初始化：数组的初始化和元素赋值分别进行int[] arr = new int[3]arr[0] = 0;arr[1] = 0;arr[2] = 0; 2 多维数组12345678910111213141516// 1 静态初始化// 1.1int[][] arr = new int[][]&#123;&#123;2, 3, 4&#125;, &#123;3, 6&#125;, &#123;3, 4, 5, 6&#125;&#125;// 1.2int[][] arr = &#123;&#123;2, 3, 4&#125;, &#123;3, 6&#125;, &#123;3, 4, 5, 6&#125;&#125;// 2 动态初始化// 2.1 二维数组中有 3 个元素（每个元素都是一维数组），每个一维数组中有 4 个元素，这种方式一维数组元素个数都一样int[][] arr = new int[3][4]// 2.2 二维数组中有 3 个元素，没有指定一维数组中元素的个数，可以分别指定，这种方式一维数组元素个数可以不一样int[][] arr = new int[3][]arr[0] = new int[2]arr[1] = new int[3]arr[2] = new int[4] 3 数组默认值1 一维数组 元素类型 默认值 byte short int long 0 char 0 或 \\u0000，并非是 &#39;0&#39; float double 0.0 boolean false 引用类型 null 2 二维数组 int[][] arr = new int[3][4] 外层初始值为内层数组元素的地址值 内层初始值为对应类型的初始值 int[][] arr = new int[3][] 外层初始值为 null 内层还没有元素 五 运算5.1 运算符1 赋值运算符 运算符 名称 运算式 等价于 = 赋值 x = y x = y += 加赋值 x += y x = x + y -= 减赋值 x -= y x = x - y *= 乘赋值 x *= y x = x * y /= 除赋值 x /= y x = x / y %= 模赋值 x %= y x = x % y 支持连续赋值 在使用扩展赋值运算符（非 =）时，不会改变变量的数据类型，即会把结果强制转换为变量的类型 12345678910// 1 ----------------------------------short s = 3;s += 1; // 结果是 4// 等价于s = (short)(s + 1); // 2 ----------------------------------int i = 1;i *= 0.1; // 结果是 0// 等价于i = (int)(i * 0.1); 2 算术运算符 运算符 名称 运算式 + 加法 x + y - 减法 x - y * 乘法 x * y / 除法 x / y % 取模 x % y ++ 自增 x++ 或 ++x -- 自减 x-- 或 --x 自增和自减不会改变变量数据类型 负数的取模运算：只有被除数（左边的数）的负号才有影响 3 比较运算符 运算符 名称 运算式 == 等于 x == y != 不等于 x != y &gt; 大于 x &gt; y &lt; 小于 x &lt; y &gt;= 大于等于 x &gt;= y &lt;= 小于等于 x &lt;= y instanceof 是否是某类对象 obj instanceof Object 4 逻辑运算符 运算符 名称 运算式 说明 &amp; 逻辑与 expr1 &amp; expr2 有 false 则 false，且两个表达式都会计算 &amp;&amp; 短路与 expr1 &amp;&amp; expr2 有 false 则 false，且若前边表达式为 false，则不再计算后边表达式 &#124; 逻辑或 expr1 &#124; expr2 有 true 则 true，且两个表达式都会计算 &#124;&#124; 短路或 expr1 &#124;&#124; expr2 有 true 则 true，且若前边表达式为 true，则不再计算后边表达式 ! 逻辑非 !expr true 变 false，false 变 true ^ 逻辑异或 expr1 ^ expr2 相同则 false，不同则 true 5 位运算符 运算符 名称 运算式 说明 &amp; 按位与 x &amp; y 有 0 则 0 &#124; 按位或 x &#124; y 有 1 则 1 ~ 按位非 ~x 1 变 0，0 变 1 ^ 按位异或 x ^ y 相同则 0，不同则 1 &lt;&lt; 左移 x &lt;&lt; y 舍去高位，低位补0，相当于x * 2y &gt;&gt; 右移 x &gt;&gt; y 舍去低位，正数高位补 0，负数高位补 1，相当于x / 2y &gt;&gt;&gt; 无符号右移 x &gt;&gt;&gt; y 舍去低位，高位补 0，相当于x / 2y 6 三元运算符 语法 说明 条件表达式 ? exprIfTrue : exprIfFalse 最终执行的表达式必须有返回值 三元运算符编译时要求两个表达式是同一个类型 1234Object o = true ? new Integer(1) : new Double(2.0);System.out.println(o);// 结果是 1.0// 因为要求两个表达式类型一样，所以暗含一个类型提升 5.2 运算符优先级 优先级 运算符 结合性 1 () [] {} 左 → 右 2 ! +(正) -(负) ~ ++ -- 右 → 左 3 * / % 左 → 右 4 +(加) -(减) 左 → 右 5 &lt;&lt; &gt;&gt; &gt;&gt;&gt; 左 → 右 6 &lt; &lt;= &gt; &gt;= instanceof 左 → 右 7 == != 左 → 右 8 &amp; 左 → 右 9 ^ 左 → 右 10 &#124; 左 → 右 11 &amp;&amp; 左 → 右 12 &#124;&#124; 左 → 右 13 ?:(三元) 右 → 左 14 = += -= *= /= ... 右 → 左 结合性：在几个操作符具有相同的优先级时决定先执行哪一个 += 是右结合，从右到左运算，所以 a += b += c 等价于 a += (b += c) 六 语句6.1 条件语句1 if else1234567if (condition) &#123; statement;&#125; else if (condition) &#123; statement;&#125; else &#123; statement; &#125; 2 switch1234567891011switch(表达式) &#123; case 值1: code; break; case 值2: code; break; default: code; break;&#125; 表达式 基本类型（可以自动提升为 int 的） byte short char int 引用数据类型 枚举（jdk5） 字符串字面量（jdk7） case 后边必须是常量且不能相同，不能是变量 default 可以放到任意位置，但是总是最后当所有 case 都不匹配时才执行 break 如果省略，会出现 case 穿透现象，下一个 case 不再判断，直接执行 最后一个可以省略 6.2 循环语句1 for123for (初始化条件【可以有多个】; 循环条件【boolean类型】; 循环迭代条件) &#123; 循环体;&#125; 2 for each123for (variable: collection) &#123; statement;&#125; 3 while123while (condition) &#123; statement;&#125; 4 do while1234do &#123; statement;&#125;while (condition) 6.3 中断语句 语句 说明 continue 用于循环：跳出当次循环，继续下一次循环 break 用于 switch ... case：结束 switch用于循环：跳出当前循环，继续下边代码 return 任意位置：结束 cntinue 和 break 可以使用标签标记位置：label:","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]}]}