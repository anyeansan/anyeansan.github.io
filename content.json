{"meta":{"title":"安₃","subtitle":"我未成名君未嫁 可能俱是不如人","description":"一蓑烟雨任平生","author":"安₃","url":"https://anyeansan.github.io","root":"/anyeansan.github.io/"},"pages":[{"title":"categories","date":"2019-11-12T04:47:40.000Z","updated":"2019-11-12T04:48:21.027Z","comments":true,"path":"categories/index.html","permalink":"https://anyeansan.github.io/categories/","excerpt":"","text":""},{"title":"tags","date":"2019-11-12T04:46:04.000Z","updated":"2019-11-12T04:47:01.286Z","comments":true,"path":"tags/index.html","permalink":"https://anyeansan.github.io/tags/","excerpt":"","text":""}],"posts":[{"title":"Java面向对象","slug":"Java面向对象","date":"2020-09-29T06:55:42.000Z","updated":"2020-09-29T06:55:42.981Z","comments":true,"path":"2020/09/29/Java面向对象/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"","categories":[{"name":"父","slug":"父","permalink":"https://anyeansan.github.io/categories/%E7%88%B6/"},{"name":"子","slug":"父/子","permalink":"https://anyeansan.github.io/categories/%E7%88%B6/%E5%AD%90/"}],"tags":[]},{"title":"Java语法","slug":"Java/Java语法","date":"2020-09-29T06:29:26.000Z","updated":"2020-09-29T06:56:17.336Z","comments":true,"path":"2020/09/29/Java/Java语法/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java%E8%AF%AD%E6%B3%95/","excerpt":"","text":"一 前言1.1 概述 术语 缩写 说明 Java Development Kit JDK Java 开发工具包，编写 Java 程序的程序员使用的软件 Java Runtime Environment JRE Java 运行时环境，运行 Java 程序的用户使用的软件 Standard Edition SE 标准版，用于桌面或简单服务器应用的 Java 平台 Enterprise Edition EE 企业版，用于复杂服务器应用的 Java 平台 Micro Edition ME 微型版，用于小型设备的 Java 平台 Java Virtual Machine JVM Java 虚拟机，Java 程序运行在虚拟机上而非操作系统上 Oracle JDK - 官方 Java SE Open JDK - Java SE 的一个免费开源实现 Software Development Kit SDK 过时，用于描述 1998 ~ 2006 年之间的 JDK NetBeans - Oracle 公司的集成开发环境 path - 为了在任意地方使用所配置路径下的命令 classpath - 寻找 .class 文件的路径 1.2 编译 &amp; 运行1 编译1javac a/b/c/test.java 执行 javac.exe 命令所在的目录 + 输入的 .java 文件路径 = .java 文件绝对路径 .java 文件可以有多个类，但只能有零或一个 public 类且必须与文件名相同 2 运行1java 字节码文件名 必须在类的全限定名所在的路径下执行 java.exe 命令，因为 classpath 不设置时，默认在当前路径寻找 .class 文件 二 注释2.1 单行注释1// 单行注释 2.2 多行注释123/* 多行注释禁止嵌套*/ 2.3 文档注释1234567891011/*** @author 作者* @see 另请参阅* @since 从 xxx 版本开始引入* @param 参数* @return 返回值* @throws 异常*/// 生成文档javadoc -d 文件夹名称 -encoding UTF-8 -charset UTF-8 -author -version xxx.java 三 标识符3.1 定义规则 合法字符 A~Za~z 0~9 _ $ 不能以数字开头，不能使用空格 不能使用关键字和保留字，但可以包含 严格区分大小写，长度无限制 3.2 命名规范 对象 规范 包名 所有单词小写 类名, 接口名 所有单词的首字母大写 变量名, 方法名 第一个单词首字母小写，后边首字母大写 常量名 所有单词大写，单词之间使用 _ 连接 四 数据类型4.1 概述 4.2 基本数据类型1 整型 类型 大小 无符号范围 有符号范围 默认初始值 byte 1 字节 0 ~ 255 -128 ~ 127 0 short 2 字节 0 ~ 65535 -215 ~ 215-1 0 int（默认） 4 字节 0 ~ 232-1 -231 ~ 231-1 0 long 8 字节 0 ~ 264-1 -263 ~ 263-1 0L Java 都是有符号的，整形默认为 int，long 类型声明时需要加 l 或 L 长度计算公式（n 为字节数） 有符号：-28n-1~ 28n-1-1 无符号：0~28n-1 进制表示： 二进制：0b 开头 八进制：0 开头 十进制：0x 开头 数字字面量可添加下划线，为了可读性，编译器会自动去除 10_000_000 常量优化机制：Java 中整数默认为 int 型，当把整数值赋值给非 int 的整型时，JVM 会判断整数值是否超过此类型的范围 没有超过，则自动进行隐式转换，如 byte b = 127 超过，则报错，如 byte b = 128 2 浮点型 类型 大小 默认初始值 float 4 字节 0.0F double（默认） 8 字节 0.0D 浮点型默认为 double ，float 类型声明时需要加 f 或 F 浮点型常量有两种表示形式 十进制数形式，如 3.14 3.14F .314 科学计数法形式，如 3.14e2 314E2 100E-2 3 布尔型 类型 取值 默认初始值 boolean true false false 4 字符型 类型 大小 范围 默认初始值 char 2 字节 \\u0000 ~ \\uffff（ 0 ~ 65535 ） \\u0000（空） 字符型：由单引号包裹的单个字符（汉字、字母、数字、符号） &#39;&#39;：错误，不能是空单引号 &#39; &#39;：正确，空格字符 字符型三种表现形式 单引号包裹的单个字符 转义符转义的特殊字符，如 &#39;\\n&#39; Unicode 值 Java 中字符使用 Unicode 字符集，编码规则为 UTF-16 ，表示形式为 \\u0000： \\u：转义序列，表示是 Unicode 0000：字符在 Unicode 中的码点对应的十六进制数 4.3 基本数据类型转换 自动类型转换（隐式转换）：低容量类型 → 高容量类型 强制类型转换：高容量类型 → 低容量类型，可能损失精度 boolean 类型与其他基本类型不能进行类型转换 运算时，会先将两个操作数转为同一类型 byte short char 都会先转为 int int → long → float → double：碰到靠右的则先转为其类型 4.4 大数 如果基本整数和浮点数精度不满足需求，可以使用 java.math 包下的类 BigInteger：可以实现任意精度的整数运算 BigDecimal：可以实现任意精度的浮点数运算 将数值转为大数 12BigInteger.valueOf(100)new BigInteger(String num) 4.5 字符串1 概述 Java 字符串即 Unicode 字符序列，如 &quot;Java\\u5B89&quot; 由 5 个 Unicode 字符组成 J a v a 安 字符串：由双引号包裹的 0 到 多个字符 每个字符串都是 java.lang.String 的一个实例 2 字符串常量池1 概述 字符串常量池中不会存储相同内容的字符串 String pool 是一个固定大小的 Hashtable，可通过 -XX:StringTableSize 设置长度 JDK6 默认长度是 1009，设置无要求 JDK7 默认长度是 60013，设置无要求 JDK8 开始默认长度是 60013，1009 是可设置的最小长度 2 创建字符串 字面量 字符串存储在常量池中 new new String(&quot;a&quot;) 对象1：new String(&quot;a&quot;) 对象2：常量池中的 &quot;a&quot; new String(&quot;a&quot;) + new String(&quot;b&quot;) 对象1：new StringBuilder() 对象2：new String(&quot;a&quot;) 对象3：常量池中的 &quot;a&quot; 对象4：new String(&quot;b&quot;) 对象5：常量池中的 &quot;b&quot; 对象6：new String(&quot;ab&quot;) StringBuilder.toString() 的底层实际是 new 了一个字符串 注意：&quot;ab&quot; 并不会存入常量池中 String 类的 intern() 当调用的字符串在字符串常量池中已存在，则直接返回池中对象的地址引用 当调用的字符串在字符串常量池中不存在 JDK6 会复制一个新的字符串对象放入常量池中，并返回池中对象的地址引用 JDK7 及以后，会将此字符串的地址放入常量池中，并返回池中对象的地址引用 3 拼接字符串 常量和常量拼接结果在常量池，原理是编译器优化 如果拼接中出现了变量，则相当于在堆中 new String()，结果就在堆中，原理是 StringBuilder 3 java.lang.String 不可变（immutable）的字符序列 不可变性：指对字符串重新赋值，连接，替换等操作时，都不会改变原有字符串序列，就好比 3 永远是 3，”hello” 永远是 “hello” 对字符串的改变，其实是将变量指向了另一个字符串，而非改变原有字符串 123String s = &quot;hello&quot;;s = &quot;hehe&quot;;// 改变了 s 的指向，而非改变字符串 &quot;hello&quot; 不可变的优点：可以共享 String 类在JDK8 及之前内部定义了 char[] 用来存储数据，从 JDK9 开始： 字符串全为单字节字符则使用 byte[] 实现，否则使用 char[] 实现 因为字符串实际使用的大部分字符只占一个字节，使用字符数组就占用了两个字节，浪费空间 4.6 数组1 概述 数组是多个相同类型数据按一定顺序排列的集合 数组既可以存基本数据类型，也可以存引用数据类型 数组长度一旦确定，就不能修改 数组相关概念 数组名 元素 element：数组中的每个数据 索引（角标/下标）index：从 0 开始 长度 lenght：数组中元素个数称为数组的元素 数组的存储 数组会在内存中（堆）开辟一块连续的空间，数组名引用的是这块连续空间的首地址 下标表示此元素距离首地址的偏移量 2 声明数组1 一维数组123456789101112// 1 静态初始化：数组的初始化和元素赋值同时进行// 1.1int[] arr = new int[]&#123;1, 3, 5&#125;// 1.2int[] arr = &#123;1, 3, 5&#125;// 2 动态初始化：数组的初始化和元素赋值分别进行int[] arr = new int[3]arr[0] = 0;arr[1] = 0;arr[2] = 0; 2 多维数组12345678910111213141516// 1 静态初始化// 1.1int[][] arr = new int[][]&#123;&#123;2, 3, 4&#125;, &#123;3, 6&#125;, &#123;3, 4, 5, 6&#125;&#125;// 1.2int[][] arr = &#123;&#123;2, 3, 4&#125;, &#123;3, 6&#125;, &#123;3, 4, 5, 6&#125;&#125;// 2 动态初始化// 2.1 二维数组中有 3 个元素（每个元素都是一维数组），每个一维数组中有 4 个元素，这种方式一维数组元素个数都一样int[][] arr = new int[3][4]// 2.2 二维数组中有 3 个元素，没有指定一维数组中元素的个数，可以分别指定，这种方式一维数组元素个数可以不一样int[][] arr = new int[3][]arr[0] = new int[2]arr[1] = new int[3]arr[2] = new int[4] 3 数组默认值1 一维数组 元素类型 默认值 byte short int long 0 char 0 或 \\u0000，并非是 &#39;0&#39; float double 0.0 boolean false 引用类型 null 2 二维数组 int[][] arr = new int[3][4] 外层初始值为内层数组元素的地址值 内层初始值为对应类型的初始值 int[][] arr = new int[3][] 外层初始值为 null 内层还没有元素 五 运算5.1 运算符1 赋值运算符 运算符 名称 运算式 等价于 = 赋值 x = y x = y += 加赋值 x += y x = x + y -= 减赋值 x -= y x = x - y *= 乘赋值 x *= y x = x * y /= 除赋值 x /= y x = x / y %= 模赋值 x %= y x = x % y 支持连续赋值 在使用扩展赋值运算符（非 =）时，不会改变变量的数据类型，即会把结果强制转换为变量的类型 12345678910// 1 ----------------------------------short s = 3;s += 1; // 结果是 4// 等价于s = (short)(s + 1); // 2 ----------------------------------int i = 1;i *= 0.1; // 结果是 0// 等价于i = (int)(i * 0.1); 2 算术运算符 运算符 名称 运算式 + 加法 x + y - 减法 x - y * 乘法 x * y / 除法 x / y % 取模 x % y ++ 自增 x++ 或 ++x -- 自减 x-- 或 --x 自增和自减不会改变变量数据类型 负数的取模运算：只有被除数（左边的数）的负号才有影响 3 比较运算符 运算符 名称 运算式 == 等于 x == y != 不等于 x != y &gt; 大于 x &gt; y &lt; 小于 x &lt; y &gt;= 大于等于 x &gt;= y &lt;= 小于等于 x &lt;= y instanceof 是否是某类对象 obj instanceof Object 4 逻辑运算符 运算符 名称 运算式 说明 &amp; 逻辑与 expr1 &amp; expr2 有 false 则 false，且两个表达式都会计算 &amp;&amp; 短路与 expr1 &amp;&amp; expr2 有 false 则 false，且若前边表达式为 false，则不再计算后边表达式 &#124; 逻辑或 expr1 &#124; expr2 有 true 则 true，且两个表达式都会计算 &#124;&#124; 短路或 expr1 &#124;&#124; expr2 有 true 则 true，且若前边表达式为 true，则不再计算后边表达式 ! 逻辑非 !expr true 变 false，false 变 true ^ 逻辑异或 expr1 ^ expr2 相同则 false，不同则 true 5 位运算符 运算符 名称 运算式 说明 &amp; 按位与 x &amp; y 有 0 则 0 &#124; 按位或 x &#124; y 有 1 则 1 ~ 按位非 ~x 1 变 0，0 变 1 ^ 按位异或 x ^ y 相同则 0，不同则 1 &lt;&lt; 左移 x &lt;&lt; y 舍去高位，低位补0，相当于x * 2y &gt;&gt; 右移 x &gt;&gt; y 舍去低位，正数高位补 0，负数高位补 1，相当于x / 2y &gt;&gt;&gt; 无符号右移 x &gt;&gt;&gt; y 舍去低位，高位补 0，相当于x / 2y 6 三元运算符 语法 说明 条件表达式 ? exprIfTrue : exprIfFalse 最终执行的表达式必须有返回值 三元运算符编译时要求两个表达式是同一个类型 1234Object o = true ? new Integer(1) : new Double(2.0);System.out.println(o);// 结果是 1.0// 因为要求两个表达式类型一样，所以暗含一个类型提升 5.2 运算符优先级 优先级 运算符 结合性 1 () [] {} 左 → 右 2 ! +(正) -(负) ~ ++ -- 右 → 左 3 * / % 左 → 右 4 +(加) -(减) 左 → 右 5 &lt;&lt; &gt;&gt; &gt;&gt;&gt; 左 → 右 6 &lt; &lt;= &gt; &gt;= instanceof 左 → 右 7 == != 左 → 右 8 &amp; 左 → 右 9 ^ 左 → 右 10 &#124; 左 → 右 11 &amp;&amp; 左 → 右 12 &#124;&#124; 左 → 右 13 ?:(三元) 右 → 左 14 = += -= *= /= ... 右 → 左 结合性：在几个操作符具有相同的优先级时决定先执行哪一个 += 是右结合，从右到左运算，所以 a += b += c 等价于 a += (b += c) 六 语句6.1 条件语句1 if else1234567if (condition) &#123; statement;&#125; else if (condition) &#123; statement;&#125; else &#123; statement; &#125; 2 switch1234567891011switch(表达式) &#123; case 值1: code; break; case 值2: code; break; default: code; break;&#125; 表达式 基本类型（可以自动提升为 int 的） byte short char int 引用数据类型 枚举（jdk5） 字符串字面量（jdk7） case 后边必须是常量且不能相同，不能是变量 default 可以放到任意位置，但是总是最后当所有 case 都不匹配时才执行 break 如果省略，会出现 case 穿透现象，下一个 case 不再判断，直接执行 最后一个可以省略 6.2 循环语句1 for123for (初始化条件【可以有多个】; 循环条件【boolean类型】; 循环迭代条件) &#123; 循环体;&#125; 2 for each123for (variable: collection) &#123; statement;&#125; 3 while123while (condition) &#123; statement;&#125; 4 do while1234do &#123; statement;&#125;while (condition) 6.3 中断语句 语句 说明 continue 用于循环：跳出当次循环，继续下一次循环 break 用于 switch ... case：结束 switch用于循环：跳出当前循环，继续下边代码 return 任意位置：结束 cntinue 和 break 可以使用标签标记位置：label:","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]}]}