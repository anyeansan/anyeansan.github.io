{"meta":{"title":"安₃","subtitle":"我未成名君未嫁 可能俱是不如人","description":"一蓑烟雨任平生","author":"安₃","url":"https://anyeansan.github.io","root":"/anyeansan.github.io/"},"pages":[{"title":"categories","date":"2019-11-12T04:47:40.000Z","updated":"2019-11-12T04:48:21.027Z","comments":true,"path":"categories/index.html","permalink":"https://anyeansan.github.io/categories/","excerpt":"","text":""},{"title":"tags","date":"2019-11-12T04:46:04.000Z","updated":"2019-11-12T04:47:01.286Z","comments":true,"path":"tags/index.html","permalink":"https://anyeansan.github.io/tags/","excerpt":"","text":""}],"posts":[{"title":"Java-日志","slug":"Java/Java-日志","date":"2020-09-29T08:04:53.000Z","updated":"2020-09-29T08:05:08.331Z","comments":true,"path":"2020/09/29/Java/Java-日志/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-%E6%97%A5%E5%BF%97/","excerpt":"","text":"一 概述 日志门面（接口）： JCL（jakarta commons logging） slf4j（simple logging facade for java） 日志实现 JUL（Java util Logging） logback log4j log4j2 二 日志门面2.1 JCL1 概述 Jakarta Commons Logging 包： commons-looging.jar Apache 提供的一个通用日志接口，它是为 “所有的 Java 日志实现”提供一个统一的接口，它自身也提供一个日志的实现 SimpleLog，但是功能非常弱 通过动态查找的机制，在程序运行时自动找出真正使用的日志库，如果未提供任何第三方实现，则默认使用 JUL 2 API Log：日志记录器 LogFactory：负责创建 Log 2.2 slf4j1 概述 Simple Logging Facade For Java SLF4J 主要是为了给 Java 日志访问提供一套标准、规范的 API 框架，其主要意义在于提供接口，具体的实现可以交由其他日志框架 slf4j 内置一个简单的日志实现 slf4j-simple ，不过很少使用 通常 slf4j 作为门面，配上具体的实现框架，中接使用桥接器完成桥接 主要功能： 日志框架的绑定 日志框架的桥接 slf4j-api.jar 核心 API 包 日志级别 1OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL 2 绑定日志实现1 步骤 添加 slf4j 的依赖包 slf4j-api.jar 绑定具体的日志实现框架 已经实现 slf4j 的日志框架，如 logback，直接添加其依赖即可 没有实现 slf4j 的日志框架，如 JUL log4j log4j2，除了日志框架的依赖包外，还需要适配器（包） 如果绑定了多个实现，默认使用第一个 2 包1 slf4j + JUL12slf4j-api.jarslf4j-jdk14.jar 2 slf4j + log4j123slf4j-api.jarlog4j.jarslf4j-log4j12.jar 3 slf4j + log4j21234slf4j-api.jarlog4j-api.jarlog4j-core.jarlog4j-slf4j-impl.jar 4 slf4j + logback123slf4j-api.jarlogback-core.jarlogback-classic.jar 3 桥接旧的日志框架1 步骤 去除旧的日志依赖 配置桥接器（包） 绑定新的日志实现 2 桥接器 jul-to-slf4j.jar 将 JUL 的日志桥接到 slf4j ，即不再使用 JUL，而使用新的日志实现 log4j-over-slf4j.jar 将 log4j 的日志桥接到 slf4j jcl-over-slf4j.jar 将 JCL 的日志桥接到 slf4j 4 API12Logger LoggerFactory.getLogger(字节码文件)Logger LoggerFactory.getLogger(全限定类名) 三 日志实现3.1 log4j21 配置 默认加载类路径下 log4j2.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!-- 日志级别： OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL 日期格式： %d 输出的时间 %t 输出当前线程名称 %F 输出所在的类文件名 %L 输出行号 %M 输出所在方法名 %n 换行 %-5level 输出日志级别，-5表示左对齐并且固定输出5个字符，如果不足在右边补0 %logger 输出logger名称，Root Logger没有名称 %l 输出语句所在的行数, 包括类名、方法名、文件名、行数--&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!--status：设置log4j2自身内部的信息输出，可以不设置monitorInterval：指定每隔多久重新读取配置文件，可以不重启应用的情况下修改配置--&gt;&lt;configuration status=\"WARN\" monitorInterval=\"30\"&gt; &lt;!-- 1 定义属性--&gt; &lt;properties&gt; &lt;property name=\"\"&gt;&lt;/property&gt; &lt;/properties&gt; &lt;!-- 2 配置 appender--&gt; &lt;appenders&gt; &lt;!-- 2.1 console--&gt; &lt;console name=\"\" target=\"SYSTEM_OUT\"&gt; &lt;!--输出日志格式--&gt; &lt;PatternLayout pattern=\"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n\"/&gt; &lt;/console&gt; &lt;!-- 2.2 file--&gt; &lt;File name=\"\" fileName=\"文件路径\" append=\"是否追加\"&gt; &lt;!--输出日志格式--&gt; &lt;PatternLayout pattern=\"\"/&gt; &lt;/File&gt; &lt;!-- 2.3 rollingFile--&gt; &lt;RollingFile name=\"\" fileName=\"\" filePattern=\"指定当发生Rolling时，文件的转移和重命名规则\"&gt; &lt;!--输出日志格式--&gt; &lt;PatternLayout pattern=\"\"/&gt; &lt;!-- 过滤器--&gt; &lt;ThresholdFilter level=\"\" onMatch=\"ACCEPT\" onMismatch=\"DENY\"/&gt; &lt;!-- 日志拆分规则--&gt; &lt;Policies&gt; &lt;!-- 系统启动就触发拆分规则，产生一个新的日志文件--&gt; &lt;OnStartupTriggeringPolicy/&gt; &lt;!-- 按照时间节点拆分，根据 filePattern 的配置，如最小时间粒度是HH，则表示每小时产生一个新的日志文件--&gt; &lt;TimeBasedTriggeringPolicy/&gt; &lt;!-- 按照文件大小拆分，超过大小就产生一个新的--&gt; &lt;SizeBasedTriggeringPolicy size=\"\"/&gt; &lt;/Policies&gt; &lt;!--同一目录最多保存的文件个数，超过则覆盖--&gt; &lt;DefaultRolloverStrategy max=\"\"/&gt; &lt;/RollingFile&gt; &lt;/appenders&gt; &lt;!-- 3 logger 只有定义了logger并引入的appender，appender才会生效--&gt; &lt;loggers&gt; &lt;!--3.1 root--&gt; &lt;root level=\"\"&gt; &lt;appender-ref ref=\"\"/&gt; &lt;/root&gt; &lt;!--3.2 自定义 logger--&gt; &lt;logger name=\"\" level=\"\" additivity=\"\"&gt; &lt;appender-ref ref=\"\"/&gt; &lt;/logger&gt; &lt;/loggers&gt;&lt;/configuration&gt; 2 异步日志1 概述 异步日志需要添加依赖 com.lmax.disruptor 有两种实现方式 AsyncLogger（官方推荐）：全局+混合 AsyncAppender 注意三种方式不要同时使用 2 AsyncLogger1 全局异步 所有的日志都异步的记录，在配置文件上不用做任何改动，只需要添加一个 log4j2.component.properties 配置 log4j2.component.properties 1Log4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector 2 混合异步 同时使用同步日志和异步日志，通过配置指定哪些同步哪些异步 配置 123456789&lt;Loggers&gt; &lt;!-- 自定义异步 logger includeLocation：是否包含日志记录的行号信息，要关闭 --&gt; &lt;AsyncLogger name=\"\" level=\"\" includeLocation=\"false\" additivity=\"false\"&gt; &lt;AppenderRef ref=\"\"/&gt; &lt;/AsyncLogger&gt;&lt;/Loggers&gt; 3 AsyncAppender123456// 定义异步 appender ，之后引入 logger 即可&lt;Appenders&gt; &lt;Async name=\"\"&gt; &lt;AppenderRef ref=\"\"/&gt; &lt;/Async&gt;&lt;/Appenders&gt; 3.2 logback1 模块 logback-core：其它两个模块的基础模块 logback-classic：它是 log4j 的一个改良版本，同时它完整实现了slf4j API logback-access：访问模块与 Servlet 容器集成提供通过 Http 来访问日志的功能 2 配置1 依次读取 logback.groovy logback-test.xml logback.xml 2 详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;!-- 1 配置集中管理属性，获取value语法 $&#123;name&#125; --&gt; &lt;property name=\"\" value=\"\"/&gt; &lt;!-- 2 Appdender 配置 --&gt; &lt;!-- 2.1 console --&gt; &lt;appender name=\"\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!--输出流对象 默认 System.out--&gt; &lt;target&gt;&lt;/target&gt; &lt;!--日志输出格式--&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;pattern&gt;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 2.2 file --&gt; &lt;appender name=\"\" class=\"ch.qos.logback.core.FileAppender\"&gt; &lt;!--日志输出路径--&gt; &lt;file&gt;&lt;/file&gt; &lt;!--日志输出格式--&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;pattern&gt;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 2.3 htmlFile --&gt; &lt;appender name=\"\" class=\"ch.qos.logback.core.FileAppender\"&gt; &lt;!--日志输出路径--&gt; &lt;file&gt;&lt;/file&gt; &lt;!--日志输出格式--&gt; &lt;encoder class=\"ch.qos.logback.core.encoder.LayoutWrappingEncoder\"&gt; &lt;layout class=\"ch.qos.logback.classic.html.HTMLLayout\"&gt; &lt;pattern&gt;&lt;/pattern&gt; &lt;/layout&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 2.4 rollingFile --&gt; &lt;appender name=\"\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!--日志输出路径--&gt; &lt;file&gt;&lt;/file&gt; &lt;!--日志输出格式--&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;pattern&gt;&lt;/pattern&gt; &lt;/encoder&gt; &lt;!--指定日志文件拆分和压缩规则--&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\"&gt; &lt;!--按照时间和压缩格式声明拆分的文件名--&gt; &lt;fileNamePattern&gt;&lt;/fileNamePattern&gt; &lt;!--按照文件大小拆分--&gt; &lt;maxFileSize&gt;&lt;/maxFileSize&gt; &lt;/rollingPolicy&gt; &lt;!--日志级别过滤器--&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;!--过滤规则--&gt; &lt;level&gt;&lt;/level&gt; // 超过指定级别放行还是拦截 &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; // 低于指定级别放行还是拦截 &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 2.5 异步 async --&gt; &lt;appender name=\"\" class=\"ch.qos.logback.classic.AsyncAppender\"&gt; &lt;appender-ref ref=\"\"/&gt; &lt;/appender&gt; &lt;!-- 3 root Logger 配置--&gt; &lt;root level=\"默认debug\"&gt; &lt;appender-ref ref=\"console\"/&gt; &lt;/root&gt; &lt;!--4 自定义 logger --&gt; &lt;logger name=\"com.itheima\" level=\"debug\" additivity=\"是否继承rootLogger，默认true\"&gt; &lt;appender-ref ref=\"\"/&gt; &lt;/logger&gt;&lt;/configuration&gt; 3.3 JUL1 概述 Java util Logging 是 Java 原生的日志框架，使用时不需要另外引用第三方类库 配置文件：$JAVA_HOME\\conf\\logging.properties 所在包：java.util.logging 2 架构 对象 说明 Logger 日志记录器，程序通过此对象的 API 来发布日志，每个 Logger 可以关联多个 Appender / Handler Appender / Handler 日志处理器，决定日志记录的位置，如 控制台、文件… Layout / Formatter 负责日志记录的数据转换和格式化 Level 日志级别 2 API1 Logger 修饰 方法 说明 static Logger getLogger(String name) 获取或创建 Logger 对象 void log(Level, String msg) 输出指定级别的信息 void info(String msg) 输出指定级别的信息，还有其它级别方法 void addHandler(Handler handler) 关联 Handler void setUseParentHandlers(Boolean useParentHandlers) 是否会输出到父 Logger void setLevel(Level newLevel) 设置日志级别 Logger 之间存在父子关系，根据名称会自动继承，如 com.cn.an 和 com.cn 和 com 最顶层是一个 RootLogger 子 Logger 输出会同时传递给父 Logger 输出 2 Lever 静态属性 说明 ALL 启用所有级别信息 OFF 关闭日志 SEVERE 错误 WARNING 警告 INFO（默认） 信息 CONFIG 配置 FINE FINER FINEST debug 详细 较详细 非常详细 3 Handler 修饰 方法 说明 void setLevel(Level newLevel) 设置日志级别 void setForMatter(Formater newFormatter) 关联 Formatter 3.4 Log4j1 配置文件123456# 指定日志级别和使用的输出端appender：console为自定义名称log4j.rootLogger=INFO,console# 控制台输出配置log4j.appender.console=org.apache.log4j.ConsoleAppenderlog4j.appender.console.layout=org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n 名称：log4j.properties 将配置文件放在类路径下，会自动读取 2 组件1 Looger Log4j 有一个根 Logger：root 其它所有的 Logger 都会直接或间接继承 root 2 Appender ConsoleAppender FileAppender DailyRollingFileAppender RollingFileAppender JDBCAppender 3 Layout HTMLLayout SimpleLayout PatternLayout 配置文件log4j2.xml12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;Configuration status=\"WARN\" monitorInterval=\"100\"&gt; &lt;Appenders&gt; &lt;Console name=\"Console\" target=\"SYSTEM_OUT\"&gt; &lt;PatternLayout pattern=\"%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n\" /&gt; &lt;/Console&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level=\"info\"&gt; &lt;AppenderRef ref=\"Console\" /&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; log4j2默认会在classpath目录下寻找log4j.json、log4j.jsn、log4j2.xml等名称的文件，如果都没有找到，则会按默认配置输出，也就是输出到控制台。 status 表示log4j2本身的日志信息打印级别 用于设置log4j2自身内部的信息输出,可以不设置,当设置成trace时,会看到log4j2内部各种详细输出 monitorInterval Log4j能够自动检测修改配置文件和重新配置本身, 设置间隔秒数。 Appender 定义日志的输出目的地 Console 定义输出到控制台的Appender name 指定Appender的名字 target SYSTEM_OUT 或 SYSTEM_ERR,一般只设置默认:SYSTEM_OUT. PatternLayout 输出格式，不设置默认为:%m%n. File 定义输出到指定位置的文件的Appender name 指定Appender的名字 fileName 指定输出日志的目的文件带全路径的文件名 PatternLayout 输出格式，不设置默认为:%m%n. RollingFile 定义超过指定大小自动删除旧的创建新的的Appender. name 指定Appender的名字 fileName 指定输出日志的目的文件带全路径的文件名 PatternLayout 输出格式，不设置默认为:%m%n. filePattern 指定新建日志文件的名称格式. Policies 指定滚动日志的策略，就是什么时候进行新建日志文件输出日志 TimeBasedTriggeringPolicy 基于时间的滚动策略 interval 指定多久滚动一次，默认是1 hour modulate =true用来调整时间 比如现在是早上3am，interval是4，那么第一次滚动是在4am，接着是8am，12am…而不是7am SizeBasedTriggeringPolicy 基于指定文件大小的滚动策略 size 定义每个日志文件的大小 DefaultRolloverStrategy 指定同一个文件夹下最多有几个日志文件时开始删除最旧的，创建新的 max 配置最多日志文件数 Loggers Root 指定项目的根日志，如果没有单独指定Logger，那么就会默认使用该Root日志输出 level 日志输出级别，共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF AppenderRef 指定该日志输出到哪个Appender Logger 单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等 level name 指定该Logger所适用的类或者类所在的包全路径,继承自Root节点 AppenderRef 指定该日志输出到哪个Appender,如果没有指定，就会默认继承自Root.如果指定了，那么会在指定的这个Appender和Root的Appender中都会输出。 若设置Logger的additivity=”false”只在自定义的Appender中进行输出。","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-时间日期","slug":"Java/Java-时间日期","date":"2020-09-29T08:04:17.000Z","updated":"2020-09-29T08:04:27.752Z","comments":true,"path":"2020/09/29/Java/Java-时间日期/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F/","excerpt":"","text":"一 JDK8 之前的日期时间1.1 java.util.Date1 构造方法 构造方法 说明 Date() 当前时间，使用的是当前时间到 1970-01-01 00:00:00 的毫秒值创建 Date​(long date) 使用指定毫秒值 2 方法 方法 说明 long getTime() 获取 1970-01-01 00:00:00 到此时间的毫秒值 1.2 java.util.Calendar1 概述 Calendar 类是一个抽象类，提供了很多关于日期时间计算的方法 GregorianCalendar（公历）是 Calendar 的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统 2 方法 方法 说明 static Calendar getInstance() 使用默认时区和语言环境获得一个日历 static Calendar getInstance​(TimeZone zone, Locale aLocale) 使用指定时区和语言环境获得一个日历 1.3 java.text.SimpleDateFormat 方法 说明 SimpleDateFormat​(String pattern) 指定格式创建对象 String format​(Date date) 日期 → 字符串 Date parse​(String source) 字符串 → 日期 二 JDK8 的日期时间 包 说明 java.time 基础包，使用标准的 iso-8601 历法（公历） java.time.format 格式化和解析日期时间 java.time.temporal 包括底层框架和扩展特性 java.time.chrono 提供对不同的日历系统的访问 java.time.zone 包含支持不同时区以及相关规定的类 三 java.time 包3.1 概述 类 说明 LocalDateTime 本地日期时间（不包含时区） LocalDate 本地日期 LocalTime 本地时间 Instant 瞬时（时间戳），是 UTC 时间，没有时区概念 Period 日期间隔 Duration 时间间隔 ZoneOffset 时区偏移量 ZonedDateTime 指定时区的日期时间 ZoneId 包含了所有的时区信息，格式 区域/城市 Clock 时钟 3.2 LocalDateTime &amp; LocalDate &amp; LocalTime1 创建（now，of） 修饰 方法 说明 static LocalDateTime now() 获取当前日期时间（默认时区） static LocalDateTime now​(ZoneId zone) 获取当前日期时间（指定时区） static LocalDateTime of(xxx) 获取指定日期时间（一系列重载） 2 获取（get） 修饰 方法 说明 int getYear() 获取年份 Month getMonth() 获取月份（Month 是枚举类） int getMonthValue() 获取一年中的第几个月 1 ~ 12 int getDayOfYear() 获取一年中的第几天 1 ~ 365/366 int getDayOfMonth() 获取一月中的第几天 1 ~ 31 DayOfWeek getDayOfWeek() 获取星期几（DayOfWeek 是枚举类） int getHour() 获取时 int getMinute() 获取分 int getSecond() 获取秒 int getNano() 获取纳秒 3 格式化和解析（format，parse） 修饰 方法 说明 String format​(DateTimeFormatter formatter) 日期时间转成指定格式的字符串 static LocalDateTime parse​(CharSequence text) 解析默认格式字序列 static LocalDateTime parse​(CharSequence text, DateTimeFormatter formatter) 解析指定格式字符序列 4 判断（is） 修饰 方法 说明 boolean isAfter​(ChronoLocalDate other) 是否在之后 boolean isBefore(ChronoLocalDate other) 是否在之前 boolean isEqual(ChronoLocalDate other) 是否相等 boolean isLeapYear() 是否是闰年 5 修改（with） 修饰 方法 说明 LocalDateTime with​(TemporalAdjuster adjuster) 将当前日期时间设置为校对器指定的日期时间 LocalDateTime withYear(int year) 修改年 LocalDateTime withMonth(int month) 修改月 LocalDateTime withDayOfYear(int dayOfYear) 修改年第几天 LocalDateTime withDayOfMonth(int dayOfMonth) 修改月第几天 LocalDateTime withHour(int hour) 修改时 LocalDateTime withMinute(int minute) 修改分 LocalDateTime withSecond(int second) 修改秒 6 计算 plus，minus 修饰 方法 说明 LocalDateTime minus(TemporalAmount amountToSubtract) 减去一个 Duration 或 Period LocalDateTime plus(TemporalAmount amountToAdd) 添加一个 Duration 或 Period LocalDateTime plusYears(long years) 当前日期时间加指定年 LocalDateTime plusMonths(long months) 当前日期时间加指定月 LocalDateTime plusDays(long days) 当前日期时间加指定日 LocalDateTime plusWeeks(long weeks) 当前日期时间加指定周 LocalDateTime plusHours(long hours) 当前日期时间加指定时 LocalDateTime plusMinutes(long minutes) 当前日期时间加指定分 LocalDateTime plusSeconds(long seconds) 当前日期时间加指定秒 7 转换（to） 修饰 方法 说明 String toString() 获取字符串 LocalDate toLocalDate() 获取日期 LocalTime toLocalTime() 获取时间 3.3 Instant 修饰 方法 说明 static Instant now() 获取当前UTC时间的时间戳 static Instant ofEpochMilli​(long epochMilli) 获取指定毫秒值距元时间的时间戳 long toEpochMilli() 获取距元时间的毫秒数 OffsetDateTime atOffset​(ZoneOffset offset) 结合时区偏移创建 OffsetDateTime 3.4 Period 修饰 方法 说明 static Period between​(LocalDate startDateInclusive, LocalDate endDateExclusive) 获取两个日期的间隔对象 Period int getYears() 相隔年份 int getMonths() 相隔月份（只比较月字段） int getDays() 相隔天数（只比较日字段） long toTotalMonths() 相隔总月份 3.5 Duration 修饰 方法 说明 static Duration between​(Temporal startInclusive, Temporal endExclusive) 获取两个时间的间隔对象 Duration long toDays() 相隔总天数 long toHours() 相隔总小时数 long toMinutes() 相隔总分钟数 long toSeconds() 相隔总秒数 long toMillis() 相隔总毫秒数 long toNanos() 相隔总纳秒数 3.6 ZoneId 修饰 方法 说明 static Set&lt;String&gt; getAvailableZoneIds() 获取所有时区ID，格式区域/城市 static ZoneId systemDefault() 获取系统默认时区 static ZoneId of​(String zoneId) 根据时区ID获取时区 四 DateTimeFormatter4.1 预定义标准格式 字段 说明 ISO_LOCAL_DATE_TIME YYYY-MM-DD HH:MM:SS ISO_LOCAL_DATE YYYY-MM-DD ISO_LOCAL_TIME HH:MM:SS ... ... 4.2 本地化相关格式 修饰 方法 说明 static DateTimeFormatter ofLocalizedDateTime​(FormatStyle dateTimeStyle) FormatStyle 是枚举类，其中 FULL，LONG适用于 DateTime static DateTimeFormatter ofLocalizedDate​(FormatStyle dateStyle) MEDIUM，SHORT 适用于 Date static DateTimeFormatter ofLocalizedTime​(FormatStyle timeStyle) MEDIUM，SHORT 适用于 Time 4.3 自定义格式 修饰 方法 说明 static DateTimeFormatter ofPattern​(String pattern) 使用自定义格式和默认地区 static DateTimeFormatter ofPattern​(String pattern, Locale locale) 使用自定义格式和指定地区 五 TemporalAdjusters5.1 概述 时间校正器工具类 获取时间校正器对象，之后可以通过日期时间对象的 with 方法来调整 5.2 API1234static TemporalAdjuster firstXxx()static TemporalAdjuster lastXxx()static TemporalAdjuster nextXxx()static TemporalAdjuster previousXxx() 六 新旧日期时间的转换 旧类 新类 旧 → 新 新 → 旧 java.util.Date java.time.Instant date.toInstant() Date.from(instant) java.sql.Timestamp java.time.Instant timestamp.toInstant() Timestamp.from(instant) java.sql.Timestamp java.time.LocalDateTime timestamp.toLocalDateTime() Timestamp.valueOf(localDateTIme) java.sql.Date java.time.LocalDate date.toLocalDate() Date.valueOf(LocalDate) java.sql.Time java.time.LocalTime time.toLocalTime() TIme.valueOf(LocalTime) 旧转为新 to 新转为旧 from，valueOf","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-常用API","slug":"Java/Java-常用API","date":"2020-09-29T08:03:31.000Z","updated":"2020-09-29T08:03:47.268Z","comments":true,"path":"2020/09/29/Java/Java-常用API/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-%E5%B8%B8%E7%94%A8API/","excerpt":"","text":"一 java.lang.Object 修饰 方法 说明 int hashCode() 返回该对象的哈希码值 boolean equals(Object obj) 默认比较对象的地址值 Class&lt;?&gt; getClass() 返回此对象的字节码对象 String toString() getClass().getName() + &#39;@&#39; + Integer.toHexString(hashCode()) protected Object clone() 浅拷贝 void wait() 无限等待直到被唤醒，相当于 wait(0) void wait(long timeoutMillis) 等待指定时间或被唤醒 void wait(long timeoutMillis, int nanos) 等待指定时间或被唤醒 void notify() 唤醒一个 void notifyAll() 唤醒所有 1.1 == 和 equals() 比较符 基本数据类型 引用数据类型 == 比较值，== 是运算符所以同样适用基本类型运算时的类型转换 byte short char -&gt; int -&gt; long -&gt; float -&gt; double 比较地址值 equals() &nbsp; 比较地址值 1.2 重写 equals() 时也要重写 hashCode() 判断元素是否相同： 判断两个元素哈希值是否相同（判断的是对象的 hashCode() 如果哈希值相同判断内容是否相同（判断的是对象的 equals()） 两个对象相同则哈希值一定相同，如果只重写 equals() 方法，结果返回 true 时，hashCode() 返回值可能不一样 二 java.util.Objects 修饰 方法 说明 static boolean equals​(Object a, Object b) 判断是否是同一对象 static boolean isNull​(Object obj) 判断对象是否为空 static boolean nonNull​(Object obj) 判断对象是否不为空 static &lt;T&gt; T requireNonNull​(T obj [, String message]) 如果对象不为空则返回，为空则抛空指针异常（可指定异常信息） static &lt;T&gt; int compare​(T a, T b, Comparator&lt;? super T&gt; c) 如果 a==b 返回 0，否则使用比较器比较 static String toString​(Object o) 如果对象不为空则调用 toString()，为空则返回 &quot;null&quot; 三 基本类型包装类3.1 包装类 基本数据类型 包装类（java.lang） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 除了 Character 和 Boolean 外，都是 Number 类的子类 3.2 自动装箱和拆箱 装箱：基本数据类型 → 包装类对象 拆箱：包装类对象 → 基本数据类型 3.3 包装类的缓存 包装类 缓存范围 Boolean true false Byte Short Long -128~127 Integer -128~127（上限可以调整） Character 0~127 （最早的 ASCII 码的128个字符） Double Float 没有缓存 自动装箱时，如果在缓存范围内，则不会创建新对象，而是使用缓存 1234567891011121314Integer i1 = new Integer(127);Integer i2 = new Integer(127);i1 == i2; // false ，因为不是同一个对象i1.equals(i2); // true ，Integer重写了equals方法，比较的是数值Integer i1 = 127;Integer i2 = 127;i1 == i2; // true ，因为缓存，指向同一个地址i1.equals(i2); // true Integer i1 = 128;Integer i2 = 128;i1 == i2; // false ，不在缓存范围，则需要重新 new 是两个不同的地址i1.equals(i2); // true 3.4 基本类型及其包装类与字符串的转换 int/Integer -&gt; string + &quot;&quot; toString() String.valueOf() String -&gt; int/Integer Integer.parseInt(String s) 四 比较器4.1 java.lang.Comparable 实现此接口的类具有比较性 实现 int compareTo(T o) 方法 如果当前对象大于形参对象则返回正整数 如果当前对象等于形参对象则返回 0 如果当前对象小于形参对象则返回负整数 4.2 java.util.Comparator 比较器接口，实现此接口创建新的比较器 实现 int compare(T o1, T o2) 方法 o1 &gt; o2 返回正整数 o1 == o2 返回 0 o1 &lt; o2 返回负整数 五 java.lang.System5.1 属性 字段 说明 in 标准输入 out 标准输出 err 标准错误输出 5.2 方法 修饰 方法 说明 static long currentTimeMillis() 1970-01-01 00:00:00 到当前时间的毫秒值 static Properties getProperties() 获取系统属性值 static String getProperty(String key) 获取系统指定属性的值 static void gc() 运行垃圾回收器 static void exit(int status) 终止当前正在运行的 Java 虚拟机， 0 表示正常终止，非 0 异常退出 static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 拷贝数组 static void setIn​(InputStream in) 重新分配标准输入 static void setOut​(PrintStream out) 重新分配标准输出 static void setErr​(PrintStream err) 重新分配标准错误输出 六 java.util.Scanner6.1 构造 构造方法 说明 Scanner(File source [, String charsetName]) 扫描文件 Scanner​(InputStream source [, String charsetName]) 扫描字节输入流 Scanner​(String source) 扫描字符串 6.2 方法 修饰 方法 说明 boolean hasNext() 是否有下一个字符串 String next() 获取下一个字符串，遇到空白符结束（空格 制表符 回车） String nextLine() 获取下一个字符串，遇到换行符结束 boolean hasNextXxx() 是否有下一个指定类型的数据，hasNextInt ()hasNextDouble() ... Xxx nextXxx() 获取下一个指定类型的数据，nextInt() nextDouble() ... 当 nextXxx() 和 nextLine() 连用时的问题 比如输入 8 ，实际输入的是 8\\r\\n，而 nextInt() 读到 8 就结束了，下一个使用 nextLine() 读到 \\r\\n 直接就结束了 解决 在语句之后加一个 nextLine() 语句用来读取没有读到的 \\r\\n 都使用 nextLine()，输入字符串，需要数字就转换。 七 java.util.Random7.1 构造 构造方法 说明 Random() 默认种子是系统时间的纳秒值 Random​(long seed) 指定种子，种子相同，多次执行获得的随机数是一样的 7.2 方法 修饰 方法 说明 int nextInt() 获取 int 范围内的随机数 int nextInt(int bound) 获取 0&lt; x &lt; bound 的随机数 八 Arrays8.1 数组 → 集合 修饰 方法 说明 static &lt;T&gt; List&lt;T&gt; asList(T... a) 数组 → List 数组长度固定，所以转成的集合的增删方法不能使用 集合中只能存储引用数据类型，所以： 如果数组中的元素是引用类型，则直接作为集合元素 如果数组中的元素是基本类型，则将数组作为集合元素 8.2 二分查找 修饰 方法 说明 static int binarySearch(T[] a, T key) 找到则返回索引，没找到返回 -插入点-1 static int binarySearch(T[] a, int fromIndex, int toIndex, T key) 指定范围 [from, to) static &lt;T&gt; int binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c) 指定比较器 static &lt;T&gt; int binarySearch(T[] a, int fromIndex, int toIndex, T key, Comparator&lt;? super T&gt; c) 指定比较器，并指定范围 [from, to) 8.3 排序 修饰 方法 说明 static void sort(T[] a) 数组排序 static void sort(T[] a, int fromIndex, int toIndex) 指定范围 [from, to) static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) 指定比较器 static &lt;T&gt; void sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; c) 指定比较器，并指定范围 [from, to) 8.4 复制 修饰 方法 说明 static &lt;T&gt; T[] copyOf(T[] original, int newLength) 将原数组复制到新数组并指定新数组长度，新数组长度大的话根据类型使用 0 false null 填充 static &lt;T&gt; T[] copyOfRange(T[] original, int from, int to) 复制原数组指定内容到新数组 8.5 填充 修饰 方法 说明 static void fill(T[], T val) 将数组所有元素用 val 替换 static void fill(T[], int fromIndex, int toIndex, T val) 将数组 [from, to) 范围的元素用 val 替换 8.6 相等比较 修饰 方法 说明 static boolean equals(T[] a1, T[] a2) 比较两个数组的长度和元素是否相等 static boolean deepEquals(Object[] a1, Object[] a2) 深度相等比较 8.7 toString 修饰 方法 说明 static String toString(T[] arr) 将数组元素以 [元素1, 元素2 ...] 格式拼接成一个字符串 8.8 流 修饰 方法 static IntStream stream(int[] array) static IntStream stream(int[] array, int startInclusive, int endExclusive) static LongStream stream(long[] array) static LongStream stream(long[] array, int startInclusive, int endExclusive) static DoubleStream stream(double[] array) static DoubleStream stream(double[] array, int startInclusive, int endExclusive) static &lt;T&gt; Stream&lt;T&gt; stream(T[] array) static &lt;T&gt; Stream&lt;T&gt; stream(T[] array, int startInclusive, int endExclusive)","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-Stream","slug":"Java/Java-Stream","date":"2020-09-29T08:02:42.000Z","updated":"2020-09-29T08:02:54.837Z","comments":true,"path":"2020/09/29/Java/Java-Stream/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-Stream/","excerpt":"","text":"一 概述 java.util.stream 包 流：从支持数据处理操作的源生成的元素序列 流不存储元素，只是对数据进行处理 流的操作不会修改数据源，而是返回一个持有结果的新流 惰性求值：流的中间操作形成一条流水线，但不会真正执行，只有在执行终端操作时才会一次性全部处理 流只能消费一次 集合关注的是数据存储，与内存打交道 流关注的是数据运算，与CPU打交道 二 流的操作2.1 特点 流水线 内部迭代 使用集合：需要用户去做迭代，这称为外部迭代 使用流：数据处理完全是在库内部进行的，这称为内部迭代 2.2 流程 流程 说明 1 创建流 通过一个数据源（如：集合、数组），获取一个流 2 中间操作 对数据源的数据进行 n 次处理，多个中间操作形成操作链（在终端操作前，并不会真正执行中间操作链） 3 终端操作 一旦执行终端操作，就执行中间操作链，最终产生结果并结束流 三 创建流3.1 由值创建流：java.util.stream.Stream 修饰 方法 说明 static &lt;T&gt; Stream&lt;T&gt; ofNullable(T t) 若 t 为 null ，则返回空流，否则返回包含 t 的流 static &lt;T&gt; Stream&lt;T&gt; empty() 获取一个不包含任何元素的空流 static &lt;T&gt; Stream&lt;T&gt; of(T... values) 获取一个有限流，元素固定 static &lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;? extends T&gt; s) 获取一个无限流，元素通过反复调用 s 生成 static &lt;T&gt; Stream&lt;T&gt; iterate(T seed, UnaryOperator&lt;T&gt; f) 获取一个无限流，元素： seed 为初始值，之后依次由上一个值通过 f 生成下一个值 static &lt;T&gt; Stream&lt;T&gt; iterate(T seed, Predicate&lt;? super T&gt; hasNext, UnaryOperator&lt;T&gt; f) 获取一个有限流，和无限流的区别是会在某个元素不满足 hasNext 时停止 3.2 由集合创建流： java.util.Collection&lt;E&gt; 修饰 方法 说明 default Stream&lt;E&gt; stream() 获取一个顺序流 default Stream&lt;E&gt; parallelStream() 获取一个并行流 3.3 由数组创建流：java.util.Arrays 修饰 方法 说明 static &lt;T&gt; Stream&lt;T&gt; stream(T[] array[, int start, int end]) 获取 Stream 流，可指定范围 [start, end) static IntStream stream(int[] array[, int start, int end]) 获取 IntStream 流，可指定范围 [start, end) static LongStream stream(long[] array[, int start, int end]) 获取 LongStream 流，可指定范围 [start, end) static DoubleStream stream(double[] array[, int start, int end]) 获取 DoubleStream 流，可指定范围 [start, end) 3.4 由文件生成流：java.nio.file.Files 修饰 方法 说明 static Stream&lt;String&gt; lines(Path path) 流元素为文件中的行，字符集默认为 UTF-8 static Stream&lt;String&gt; lines(Path path, Charset cs) 流元素为文件中的行，可指定字符集 四 中间操作4.1 筛选和切片 修饰 方法 说明 Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) 由所有符合条件的元素构成一个流 Stream&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate) 从第一个元素开始匹配，遇到不匹配就停止，由所有筛选出的元素构成一个流 Stream&lt;T&gt; dropWhile(Predicate&lt;? super T&gt; predicate) 从第一个元素开始匹配，由第一个不匹配的元素及其之后的所有元素构成一个流 Stream&lt;T&gt; distinct() 去重 Stream&lt;T&gt; limit(long maxSize) 限制数量 Stream&lt;T&gt; skip(long n) 跳过前 n 个元素，若数量不够则返回空流 4.2 排序 修饰 方法 说明 Stream&lt;T&gt; sorted() 自然排序 Stream&lt;T&gt; sorted​(Comparator&lt;? super T&gt; comparator) 定制排序 4.3 映射 修饰 方法 说明 &lt;R&gt; Stream&lt;R&gt; map​(Function&lt;? super T,​? extends R&gt; mapper) 流中每个元素映射为一个新元素，所有新元素组成流，新旧流元素个数相同 &lt;R&gt; Stream&lt;R&gt; flatMap​(Function&lt;? super T,​? extends Stream&lt;? extends R&gt;&gt; mapper) 流中每个元素都映射为一个流，所有流连接为一个新流（即映射成的每个流中的元素组成新流），新旧流元素个数可能不同 4.4 操作 修饰 方法 说明 Stream&lt;T&gt; peek​(Consumer&lt;? super T&gt; action) 流中元素不变，对每个元素进行一些操作 static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) 由流 a 的一个元素后跟流 b 的一个元素组成的元素构成一个流 五 终止操作5.1 迭代 修饰 方法 说明 void forEach​(Consumer&lt;? super T&gt; action) 迭代流中元素 Iterator&lt;T&gt; iterator() 旧式迭代器 5.2 统计 修饰 方法 说明 long count() 统计流中元素个数 5.3 匹配 修饰 方法 说明 boolean anyMatch​(Predicate&lt;? super T&gt; predicate) 是否有任意元素匹配 boolean allMatch​(Predicate&lt;? super T&gt; predicate) 是否全部元素都匹配 boolean noneMatch​(Predicate&lt;? super T&gt; predicate) 是否没有元素匹配 5.4 查找 修饰 方法 说明 Optional&lt;T&gt; findFirst() 返回流中第一个元素 Optional&lt;T&gt; findAny() 返回流中任意一个元素（如果是稳定流，也返回第一个元素） Optional&lt;T&gt; max​(Comparator&lt;? super T&gt; comparator) 返回流中最大元素，使用给定比较器定义的排序规则 Optional&lt;T&gt; min​(Comparator&lt;? super T&gt; comparator) 返回流中最小元素 5.5 归约 修饰 方法 说明 Optional&lt;T&gt; reduce​(BinaryOperator&lt;T&gt; accumulator) 元素1和元素2运算获取累计结果，结果再和下一个元素运算获取累计结果…，直到获取最终结果，由于流可能没有元素，所以返回 Optional T reduce​(T identity, BinaryOperator&lt;T&gt; accumulator) 同上，只是指定一个初始元素，由于肯定有值，所以不用返回 Optional 5.6 收集 修饰 方法 说明 &lt;R,A&gt; R collect​(Collector&lt;? super T,​A,​R&gt; collector) 使用指定收集器收集流中元素 Object[] toArray[] 收集到对象数组中 &lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator) 传入 A[]::new 收集到 A[] 类型数组中 六 流收集器6.1 收集器接口：Collector&lt;T,A,R&gt;12345678Supplier&lt;A&gt; supplier();BiConsumer&lt;A, T&gt; accumulator();Function&lt;A, R&gt; finisher();BinaryOperator&lt;A&gt; combiner();Set&lt;Characteristics&gt; characteristics();T：是流中要收集的元素的泛型。A：是累加器的类型，累加器是在收集过程中用于累积部分结果的对象。R 是收集操作得到的对象（通常但并不一定是集合）的类型 1 supplier：建立新的结果容器 supplier 方法必须返回一个结果为空的 Supplier ，调用此 Supplier 时创建一个空的累加器实例（结果容器），供数据收集过程使用 累加器类型为 A 2 accumulator：将元素添加到结果容器 accumulator 方法会返回执行归约操作的函数 返回的函数有两个参数（假设遍历到流中第 n 个元素） 保存归约结果的累加器（已收集了流中的前 n - 1 个项目） 第 n 个元素本身 3 finisher：对结果容器应用最终转换 在遍历完流后， finisher 方法必须返回在累积过程的最后要调用的一个函数，以便将累加器对象转换为整个集合操作的最终结果 如果累加器对象恰好符合预期的最终结果，则无需进行转换，只需返回 Function.identity() 4 combiner：合并两个结果容器 combiner 方法会返回一个供归约操作使用的函数，它定义了对流的各个子部分进行并行处理时，各个子部分归约所得的累加器要如何合并 并行流使用，将多个线程产生的结果容器合并 5 characteristics characteristics 会返回一个不可变的 Characteristics 集合，它定义了收集器的行为——尤其是关于流是否可以并行归约，以及可以使用哪些优化的提示 Characteristics 是一个包含三个项目的枚举 UNORDERED 归约结果不受流中元素的遍历和累积顺序的影响 CONCURRENT accumulator 函数可以从多个线程同时调用，且该收集器可以并行归约流 如果收集器没有标为 UNORDERED ，那它仅在用于无序数据源时才可以并行归约 IDENTITY_FINISH 表明完成器方法返回的函数是一个恒等函数，可以跳过。 这种情况下，累加器对象将会直接用作归约过程的最终结果。这也意味着，将累加器 A 不加检查地转换为结果 R 是安全的 6.2 预定于收集器：Collectors1 收集12345static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()static &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()toMap()toConcurrentMap()static &lt;T, C extends Collection&lt;T&gt;&gt; Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory) 工厂方法 返回类型 说明 toList List&lt;T&gt; 把流中所有项目收集到一个 List（类型不确定） toSet Set&lt;T&gt; 把流中所有项目收集到一个 Set（类型不确定），删除重复项 toCollection Collection&lt;T&gt; 把流中所有项目收集到给定的供应源创建的集合，既可以指定集合具体类型 2 归约和汇总1 统计个数，最小/大值123static &lt;T&gt; Collector&lt;T, ?, Long&gt; counting()static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; minBy(Comparator&lt;? super T&gt; comparator)static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? super T&gt; comparator) 工厂方法 返回类型 说明 counting Long 计算流中元素的个数 minBy Optional&lt;T&gt; 一个包裹了流中按照给定比较器选出的最小元素的 Optional ，或如果流为空则为 Optional.empty() maxBy Optional&lt;T&gt; 一个包裹了流中按照给定比较器选出的最大元素的 Optional ，或如果流为空则为 Optional.empty() 2 和/平均值1234567static &lt;T&gt; Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? super T&gt; mapper)static &lt;T&gt; Collector&lt;T, ?, Long&gt; summingLong(ToLongFunction&lt;? super T&gt; mapper)static &lt;T&gt; Collector&lt;T, ?, Double&gt; summingDouble(ToDoubleFunction&lt;? super T&gt; mapper)static &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingInt(ToIntFunction&lt;? super T&gt; mapper)static &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingLong(ToLongFunction&lt;? super T&gt; mapper)static &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;? super T&gt; mapper) 工厂方法 返回类型 说明 summingInt Integer 对流中元素的一个整数属性求和 summingLong Long 对流中元素的一个长整型属性求和 summingDouble Double 对流中元素的一个浮点型属性求和 averagingInt Double 对流中元素的一个整数属性求平均值 averagingLong Double 对流中元素的一个长整型属性求平均值 averagingDouble Double 对流中元素的一个浮点型属性求平均值 3 统计个数 + 最小/大值 + 和/平均值123static &lt;T&gt; Collector&lt;T, ?, IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;? super T&gt; mapper)static &lt;T&gt; Collector&lt;T, ?, LongSummaryStatistics&gt; summarizingLong(ToLongFunction&lt;? super T&gt; mapper)static &lt;T&gt; Collector&lt;T, ?, DoubleSummaryStatistics&gt; summarizingDouble(ToDoubleFunction&lt;? super T&gt; mapper) 工厂方法 返回类型 说明 summarizingInt IntSummaryStatistics 收集流中元素统计个数 + 最小/大值 + 和/平均值 summarizingLong LongSummaryStatistics 收集流中元素统计个数 + 最小/大值 + 和/平均值 summarizingDouble DoubleSummaryStatistics 收集流中元素统计个数 + 最小/大值 + 和/平均值 返回类型中提供了相应的 getter 方法 12345getCount()getMin()getMax()getSum()getAverage() 4 连接字符串123static Collector&lt;CharSequence, ?, String&gt; joining()static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter)static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix) 工厂方法 返回类型 说明 joining String 连接对流中每个元素调用 toString 方法所生成的字符串，可指定分隔符、前缀、后缀 5 广义的归约汇总123static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; reducing(BinaryOperator&lt;T&gt; op)static &lt;T&gt; Collector&lt;T, ?, T&gt; reducing(T identity, BinaryOperator&lt;T&gt; op)static &lt;T, U&gt; Collector&lt;T, ?, U&gt; reducing(U identity, Function&lt;? super T, ? extends U&gt; mapper, BinaryOperator&lt;U&gt; op) 工厂方法 返回类型 说明 reducing 归约操作产生的类型 从一个作为累加器的初始值开始，利用 BinaryOperator 与流中的元素逐个结合，从而将流归约为单个值 以上所有归约和汇总收集器都是 reducing 工厂方法定义的归约过程的特殊情况而已，仅仅是为了方便程序员使用而已 三个参数 初始值 转换函数 累计函数 3 分组1 分组123456// 一级分组：根据 T 的某个属性 K 分组，返回 Map&lt;K, list&lt;T&gt;&gt;static &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier)// 多级分组：根据 T 的某个属性 K 分组，返回 Map&lt;K, list&lt;T&gt;&gt;，之后使用第三个参数队属性 K 收集，返回 Map&lt;K, D&gt;static &lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Collector&lt;? super T, A, D&gt; downstream)// 多级分组：可以自己提供 Map 类型static &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt; Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Supplier&lt;M&gt; mapFactory, Collector&lt;? super T, A, D&gt; downstream) 工厂方法 返回类型 说明 groupingBy Map&lt;K, List&lt;T&gt;&gt; 根据元素某个属性映射的值分组，并作为键，元素收集到 List 中作为值（单参数的 groupingBy 其实第二个参数省略了 Collectors.toList()） groupingBy Map&lt;K, D&gt; 根据元素某个属性映射的值分组，并作为键，第二个收集器返回值作为值 groupingByConcurrent 返回的是 ConcurrentMap 2 常与分组联合使用的收集器1 collectingAndThen12// 将第一个参数（旧收集器）的结果传入第二个参数（转换函数）返回新的类型static &lt;T, A, R, RR&gt; Collector&lt;T, A, RR&gt; collectingAndThen(Collector&lt;T, A, R&gt; downstream, Function&lt;R, RR&gt; finisher) 工厂方法 返回类型 说明 collectingAndThen 转换函数返回的类型 包裹另一个收集器，对其结果应用转换函数 2 mapping1static &lt;T, U, A, R&gt; Collector&lt;T, ?, R&gt; mapping(Function&lt;? super T, ? extends U&gt; mapper, Collector&lt;? super U, A, R&gt; downstream) 工厂方法 返回类型 说明 mapping 转换函数返回的类型 原收集器中的每个元素映射为一个新值，并使用一个新收集器收集 4 分区1234// 一级分区static &lt;T&gt; Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate)// 多级分区static &lt;T, D, A&gt; Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate, Collector&lt;? super T, A, D&gt; downstream) 工厂方法 返回类型 说明 partitioningBy Map&lt;Boolean,List&lt;T&gt;&gt; 根据对流中每个元素应用谓词的结果来对元素进行分区 分区是分组的特殊情况：由一个谓词（返回一个布尔值的函数）作为分类函数，它称分区函数 分区函数返回一个布尔值，这意味着得到的分组 Map 的键类型是 Boolean ，即最多可以分为两组—— true 是一组， false 是一组 七 基本类型流7.1 概述 流操作基本类型时暗含装箱操作，Java8 提供了基本类型流来解决 IntStream：byte short char int boolean DoubleStream：float double LongStream：long IntStream DoubleStream LongStream 分别将流中的元素转为 int double long ，从而避免了暗含的装箱成本，且每个接口有新的常用数值归约方法以及转回对象流的方法 7.2 对象流与基本类型流的转换1 对象流 → 基本类型流123IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper)DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper)LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper) 2 基本类型流 → 对象流1234Stream&lt;Integer&gt; boxed()Stream&lt;Double&gt; boxed()Stream&lt;Long&gt; boxed()&lt;U&gt; Stream&lt;U&gt; mapToObj(IntFunction&lt;? extends U&gt; mapper) 7.3 IntStream 修饰 方法 说明 static IntStream range(int start, int end) [start, end) 范围内数值构成流 static IntStream rangeClosed(int start, int end) [start, end] 范围内数值构成流 int sum() 求和 OptionalInt max() 求最大值 OptionalInt min() 求最小值 long count() 统计个数 八 并行流8.1 概述 并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流 并行流背后使用的基础架构是 Java 7 中引入的分支/合并框架（Fork/Join） 8.2 转换 parallel()：顺序流 → 并行流 sequential()：并行流 → 顺序流 8.3 Spliterator&lt;T&gt; 1 概述 Spliterator 是 Java 8中加入的一个新接口；这个名字代表“可分迭代器”（splitable iterator） 和 Iterator 一样， Spliterator 也用于遍历数据源中的元素，但它是为了并行执行而设计的 Java 8 为集合框架中包含的所有数据结构提供了一个默认的 Spliterator 实现 2 API 修饰 方法 说明 boolean tryAdvance(Consumer&lt;? super T&gt; action) 按顺序一个一个使用 Spliterator 中的元素，并且如果还有元素要遍历就返回 true Spliterator&lt;T&gt; trySplit() 把一些元素划出去分给第二个 Spliterator （由该方法返回），让它们两个并行处理。当返回 null 时 ，表明它处理的数据结构不能再分割 long estimateSize() 估计还剩下多少元素要遍历 int characteristics() 返回一个 int ，代表 Spliterator 本身特性集的编码 3 特性 特性 int 说明 ORDERED 元素有既定的顺序（例如 List ），因此 Spliterator 在遍历和划分时也会遵循这一顺序 DISTINCT 对于任意一对遍历过的元素 x 和 y ， x.equals(y) 返回 false SORTED 遍历的元素按照一个预定义的顺序排序 SIZED 该 Spliterator 由一个已知大小的源建立（例如 Set ），因此 estimatedSize() 返回的是准确值 NONNULL 保证遍历的元素不会为 null IMMUTABLE Spliterator 的数据源不能修改。这意味着在遍历时不能添加、删除或修改任何元素 CONCURRENT 该 Spliterator 的数据源可以被其他线程同时修改而无需同步 SUBSIZED 该 Spliterator 和所有从它拆分出来的 Spliterator 都是 SIZED 九 java.util.Optional&lt;T&gt;9.1 概述 Optional&lt;T&gt; 是一种包装器对象，且只包装一个对象：T 或 null 对象存在时，则返回封装对象的 Optional 对象不存在时，由方法 Optional.empty() 返回一个空的 Optional 使用原则 不能为 null 的属性正常声明 T 可能为 null 的属性声明为 Optional&lt;T&gt; Optional&lt;T&gt; 也有三个基本类型版本：OptionalInt、OptionalDouble、OptionalLong 9.2 API1 创建 Optional 修饰 方法 说明 static &lt;T&gt; Optional&lt;T&gt; empty() 返回空的 Optional static &lt;T&gt; Optional&lt;T&gt; of​(T t) 将指定值用 Optional 封装之后返回，如果该值为 null ，则抛出一个 NullPointerException 异常 static &lt;T&gt; Optional&lt;T&gt; ofNullable​(T t) 将指定值用 Optional 封装之后返回，如果该值为 null ，则返回一个空的 Optional 对象 2 获取 Optional 容器中的值 修饰 方法 说明 T get() 如果值存在则返回，否则抛 NoSuchElementException 异常 T orElse​(T other) 如果值存在则返回，否则返回 other T orElseGet​(Supplier&lt;? extends T&gt; supplier) 如果值存在则返回，否则返回由 Supplier 提供的值 &lt;X extends Throwable&gt; T orElseThrow​(Supplier&lt;? extends X&gt; exceptionSupplier) 如果值存在则返回，否则抛出由 Supplier 提供的异常 3 操作 Optional 中的值 修饰 方法 说明 boolean isPresent() 如果值存在就返回 true ，否则返回 false void ifPresent​(Consumer&lt;? super T&gt; action) 如果值存在则传递给 action 执行；否则就不进行任何操作 void ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction) 如果值存在则传递给 action 执行；否则调用 emptyAction &lt;U&gt; Optional&lt;U&gt; map​(Function&lt;? super T,​? extends U&gt; mapper) 如果值存在则映射一个新值（如果映射值为 null 会空指针异常），然后返回存储新值的 Optional；否则返回空的 Optional &lt;U&gt; Optional&lt;U&gt; flatMap​(Function&lt;? super T,​? extends Optional&lt;? extends U&gt;&gt; mapper) map 方法的问题在于如果映射成的值还是一个 Optional，会形成多层 Optional&lt;Optional&lt;T&gt;&gt;，此方法能将多层的 Optional 合并为一个 Optional&lt;T&gt; filter​(Predicate&lt;? super T&gt; predicate) 如果值存在并且满足提供的谓词，就返回包含该值的 Optional 对象；否则返回空的 Optional 对象 Optional&lt;T&gt; or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier) 如果值存在，则返回存储此值的 Optional，否则返回由 Supplier 提供的 Optional 4 其它 修饰 方法 说明 Stream&lt;T&gt; stream() 如果值存在则获取只包含此元素的流，否则获取空流","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-Lambda","slug":"Java/Java-Lambda","date":"2020-09-29T08:01:27.000Z","updated":"2020-09-29T08:01:40.791Z","comments":true,"path":"2020/09/29/Java/Java-Lambda/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-Lambda/","excerpt":"","text":"一 Lambda 概述 Lambda 是一个匿名函数，但在 Java 中 Lambda 表达式的本质是函数式接口的一个实例，也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用 Lambda 表达式来表示 Lambda 需要函数式接口的支持 闭包 在 Lambda 表达式中引用了局部变量，会形成闭包，延长局部变量声明周期 此被引用的局部变量会变成 final 的 二 Lambda 语法2.1 基础语法123(形参列表) -&gt; &#123;方法体&#125;// 形参列表：对应函数式接口中抽象方法的形参列表// 方法体：即重写的函数式接口中抽象方法的方法体 参数类型可以省略（类型推断） 当且仅当参数只有一个时，可以省略小括号 如果方法体只有一句，可以省略大括号 如果方法体只有一句且是返回语句，大括号和 return 要一致 省略大括号的同时必须省略 return 关键字 不省略大括号那么也不能省略 return 关键字 2.2 方法引用1 概述 方法引用即将 Lambda 表达式的实现指向一个已经实现的方法，也就是说通过调用一个现有的方法来完成功能 方法引用其实返回的就是一个函数式接口的实例 1234// 只要符合条件就能当成对应函数式接口的实例// 所谓的符合条件：引用的方法与函数式接口的抽象方法有着相同形参和返回值，比如接收一个类型的参数，返回另一个类型...Consumer consumer = System.out::println;Runable runable = System.out::println; 条件 引用方法的形参列表（数量、顺序和类型）必须与接口中的方法一致 特殊情况：接口中方法的第一个形参是方法的调用者，剩余形参与引用方法一致（即指向类的实例方法的方法引用） 引用方法的返回值必须和接口中的方法一致 2 语法1234567// 语法方法隶属者::方法名// 有三种使用情况对象::实例方法名类::静态方法名类::实例方法名 指向对象的实例方法的方法引用 12(args) -&gt; expr.instanceMethod(args)expr::instanceMethod 指向类的静态方法的方法引用 12(args) -&gt; ClassName.staticMethod(args)CLassName::staticMethod 指向类的实例方法的方法引用 123(arg0, rest) -&gt; arg0.instanceMethod(rest)CLassName::instanceMethod// arg0 是 ClassName 类型的实例，即是实例方法的调用者又是方法的第一个参数 2.3 构造器引用1类::new 构造器形参列表要与函数式接口中抽象方法的形参列表一致 新创建的对象与函数式接口中抽象方法的返回值一致 2.4 数组引用1数组类型[]::new 可以把数组看作一个构造器 三 函数式接口3.1 概述 SAM：Simple Abstract Method 有且仅有一个抽象方法的接口就是函数式接口，可以有其它方法（静态，默认…） @FunctionalInterface：此注解用来标识函数式接口 java.lang.util.function 包下定义了许多函数式接口 3.2 常用函数式接口 函数式接口 参数类型 返回类型 接口方法 说明 原始类型特化 Predicate&lt;T&gt; T boolean boolean test(T t) 传入 T，返回布尔值 IntPredicateLongPredicateDoublePredicate BiPredicate&lt;T, U&gt; T, U boolean boolean test(T t, U u) 传入 T U，返回布尔值 Consumer&lt;T&gt; T void void accept(T t) 传入 T，无返回 IntConsumerLongConsumerDoubleConsumer BiConsumer&lt;T, U&gt; T, U void void accept(T t, U u) 传入 T U，无返回 ObjIntConsumer&lt;T&gt;ObjLongConsumer&lt;T&gt;ObjDoubleConsumer&lt;T&gt; Supplier&lt;T&gt; 无 T T get() 无传入，返回 T IntSupplierBooleanSupplierLongSupplierDoubleSupplier Function&lt;T, R&gt; T R R apply(T t) 传入 T，返回 R IntFunction&lt;R&gt;LongFunction&lt;R&gt;DoubleFunction&lt;R&gt;ToIntFunction&lt;T&gt;ToLongFunction&lt;T&gt;ToDoubleFunction&lt;T&gt;IntToLongFunctionIntToDoubleFunctionLongToIntFunctionLongToDoubleFunction UnaryOperator&lt;T&gt; T T T apply(T t) 传入 T，返回 T，继承 Function&lt;T, T&gt; 接口 IntUnaryOperatorLongUnaryOperatorDoubleUnaryOperator BiFunction&lt;T, U, R&gt; T, U R R apply(T t, U u) 传入 T U ，返回 R ToIntBiFunction&lt;T,U&gt;ToLongBiFunction&lt;T,U&gt;ToDoubleBiFunction&lt;T,U&gt; BinaryOperator&lt;T&gt; T, T T T apply(T t1, T t2) 传入 T T ，返回 T，继承 BiFunction&lt;T, T, T&gt; 接口 IntBinaryOperatorLongBinaryOperatorDoubleBinaryOperator Runnable 无 void void run() 无传入，无返回 Comparator&lt;T&gt; T, T int int compare(T t1, T t2) 传入 T T，返回 int 3.3 复合 Lambda 表达式的有用方法1 比较器复合12逆序：reversed比较器链：thenComparing 2 谓词复合123非：negate与：and或：or 3 函数复合1234andThen f.anThen(g)：先执行 f 后 执行 g，即 g(f(x))compose f.compose(g)：先执行 g 后 执行 f，即 f(g(x))","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-网络编程","slug":"Java/Java-网络编程","date":"2020-09-29T08:00:45.000Z","updated":"2020-09-29T08:01:02.601Z","comments":true,"path":"2020/09/29/Java/Java-网络编程/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"一 概述1.1 网络模型1 OSI（Open System Interconnection） 层 说明 相关协议 应用层 网络服务和最终用户的接口 HTTP HTTPS FTP SMTP POP3 DNS ... 表示层 数据的表示、安全、压缩 会话层 建立、管理和终止会话 传输层 定义传输数据的协议端口号，以及流量控制和差错校验 TCP UDP 网络层 进行逻辑地址寻找，实现不同网络间的路径选择 IP ARP RARP ICMP IGMP ... 数据链路层 建立逻辑连接、进行硬件地址寻址、差错校验等功能 MAC 地址 物理层 建立，维护，断开物理连接 2 TCP/IP 分层模型 层 相关协议 应用层 HTTP HTTPS FTP DNS ... 传输层 TCP UDP 网络层 IP ARP ICMP... 物理+数据链路层 硬件层面 1.2 网络编程 目的：直接或间接的通过网络协议与其它计算机通信，进行数据交换 两个问题： 如何准确定位网络上的一台或多台主机，以及如果定位主机上特定的应用 定位后，如何可靠高速的进行数据传输 1.3 网络通信三要素 IP 地址：确定设备 端口：确定设备上的程序 网络协议 1.4 常见端口 服务 端口 HTTP 80 HTTPS 443 SSH 22 Tomcat 8080 MySQL 3306 Oracle 1521 SMTP 25 POP3 110 二 java.net.InetAddress2.1 概述 用来包装 IP 地址对象 子类 Inet4Address Inet6Address 2.2 方法1 获取 IP 对象 修饰 方法 说明 static InetAddress getLocalHost() 获取本地主机 IP 对象，等价于 getByName(&quot;127.0.0.1&quot;) static InetAddress getByName​(String host) 根据主机名（ip 或 域名）获取 IP 对象 2 获取主机信息 修饰 方法 说明 String getHostName() 获取主机名（域名） String getHostAddress() 获取主机 IP 地址 三 Socket3.1 概述 IP 和端口组合得出一个网络套接字：Socket Socket 是网络通信的一种机制，是两台机器间通信的端点 分类 流套接字（TCP） 数据报套接字（UDP） 类 说明 java.net.Socket TCP 客户端 Socket java.net.ServerSocket TCP 服务端 Socket java.net.DatagramSocket UDP Socket java.net.DatagramPacket UDP 数据包 3.2 TCP1 java.net.Socket（客户端）1 构造 构造 说明 Socket​(String host, int port) 指定服务端主机地址，以及要连接的服务端口 Socket​(InetAddress address, int port) 指定服务端主机 IP 地址对象，以及要连接的服务端口 2 方法 修饰 方法 说明 InputStream getInputStream() 获取字节输入流 OutputStream getOutputStream() 获取字节输出流 InetAddress getLocalAddress() 获取 Socket 绑定的本地主机 IP 对象 InetAddress getInetAddress() 获取 Socket 连接的主机 IP 对象 void shutdownInput() 关闭 Socket 输入通道 void shutdownOutput() 关闭 Socket 输出通道 void close() 关闭 Socket，会自动关闭流 2 java.net.ServerSocket（服务端）1 构造 构造 说明 ServerSocket​(int port) 指定服务监听端口 2 方法 修饰 方法 说明 Socket accept() 等待并接收客户端连接，阻塞方法 void close() 关闭 Socket，会自动关闭流 3 应用1 客户端 创建 Socket 对象 使用 Socket 对象获取输入输出流来读写 关闭 Socket 2 服务端 创建 ServerSocket 对象，指定监听端口 使用 ServerSokcet 接收客户端 Socket 使用 Socket 对象获取输入输出流来读写 关闭 Socket 4 注意：如果服务端和客户端都等待 数据没有刷新，使用 BufferedReader 包装字节输入流时，readLIne() 结束标记是换行符 使用 PrintStream 包装字节输出流，可以自动刷新，如使用 println() 使用 PrintWrter 包装字节输出流，使用 println() 需要手动刷新或者构造函数中设置自动刷新 使用 BufferedWriter 包装字节输出流，输出后需要 newLine() 阻塞式方法没有结束标记 void shutdownInput() ``void shutdownOutput()` 5 服务端接收多个客户端连接 将每个客户端的业务封装为线程任务 使用多线程实现 12345ServerSocket ss=new ServerSocket(8866);while (true) &#123; Socket socket = ss.accept(); new ClientTask(socket).start();&#125; 3.3 UDP1 java.net.DatagramSocket1 构造 构造 说明 DatagramSocket() 发送端不用指定端口 DatagramSocket(int port) 接收端需要指定端口 2 方法 修饰 方法 说明 void send(DatagramPacket p) 发送数据包 void receive(DatagramPacket p) 接收数据包 void close() 关闭 Socket，会自动关闭流 2 java.net.DatagramPacket1 构造 构造 说明 DatagramPacket​(byte[] buf, int length) 接收端接收数据包 DatagramPacket​(byte[] buf, int length, InetAddress address, int port) 发送端打包需要指定接收端 IP 和 Port 2 方法 修饰 方法 说明 byte[] getData() 接收的数据 int getLength() 接收的数据实际长度 3 应用1 发送端 创建 DatagramSocket，不需端口 创建 DatagramPacket 数据包，指定数据存储数组，长度，接收端 IP 和 Port 发送数据包 关闭 DatagramSocket 2 接收端 创建 DatagramSocket，指定端口 创建 DatagramPacket，指定数据存储数组，长度 接收数据包 从数据包提取数据 关闭 DatagramSocket 四 java.net.URL4.1 构造 构造 说明 URL​(String spec) 根据 URL 地址字符串构造 URL 对象 URL​(String protocol, String host, int port, String file) 根据指定 protocol、host、port 号和 file 创建 URL 对象 4.2 方法 修饰 方法 说明 String getProtocol() 获取此 URL 的协议名称 String getHost() 获取此 URL 的主机地址 int getPort() 获取此 URL 的端口号 String getFile() 获取此 URL 的文件资源路径（完整 URI） String getPath() 获取此 URL 的路径部分（URI不带参数） String getQuery() 获取此 URL 的查询部分（参数） URLConnection openConnection() 返回一个 URLConnection 对象，它表示到 URL 所引用的远程对象的连接 InputStream openStream() 打开到此 URL 的连接并返回一个用于从该连接读入的 InputStream 五 java.net.URLConnection5.1 概述 URL 连接器对象 表示与 URL 建立的通信连接 5.2 方法 修饰 方法 说明 URL getURL() 获取此链接的 URL 对象 abstract void connect() 连接 InputStream getInputStream() 获取此链接的字节输入流 OutputStream getOutputStream() 获取此连接的字节输出流","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-反射","slug":"Java/Java-反射","date":"2020-09-29T07:59:44.000Z","updated":"2020-09-29T08:00:02.273Z","comments":true,"path":"2020/09/29/Java/Java-反射/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-%E5%8F%8D%E5%B0%84/","excerpt":"","text":"一 反射1.1 概述 反射 Reflection 允许程序在运行期间： 获取任意类型的详细信息 创建任意类型的对象 读写任意对象的任意属性 调用任意对象的任意方法 读取某个注解信息 读取某个类的泛型信息 生成动态代理 。。。 加载完类之后，在方法区中旧产生了一个 Class 对象（一个类对应一个），此对象包含了类的完整结构信息 1.2 动态语言 &amp; 静态语言 动态语言： 运行时可以根据某些条件改变自身结构 Object-C、C#、JavaScript、PHP、Python、Erlang 静态语言： 运行时结构不可变 Java、C、C++ Java 不是动态语言，但有一定的动态性（利用反射） 二 Java 类型2.1 概述 类型 说明 例 Type Java 中所有类型的公共高级接口 Class 普通类型（类，接口，数组，枚举，注解，基本数据类型，void），没有泛型信息 Person ParameterizedType 参数化类型（即泛型） Map&lt;String, Integer&gt;，List&lt;T&gt; GenericArrayType 泛型数组类型 T[]，List&lt;T&gt;[] TypeVariable&lt;D&gt; 类型变量（即泛型中的变量） T K V WildcardType 带通配符 ? 的类型 List&lt;?&gt;，List&lt;? extends Object&gt; 2.2 ParameterizedType 修饰 方法 说明 Type[] getActualTypeArguments() 获取泛型的实际类型，泛型可能有多个，所以返回数组（该方法只返回最外层的&lt;&gt;中的类型，无论该&lt;&gt;内有多少个&lt;&gt;） Type getRawType() 获取声明泛型的类或者接口，也就是泛型中&lt;&gt;前面的那个值 Type getOwnerType() 获取泛型的拥有者，例如： Map 就是 Map.Entry&lt;String,String&gt; 的拥有者 三 java.lang.ClassLoader3.1 获取 ClassLoader123456789// 1 获取当前类的 ClassLoaderclazz.getClassLoader()// 2 获取当前线程上下文的 ClassLoaderThread.currentThread().getContextClassLoader()// 3 获取系统的 ClassLoaderClassLoader.getSystemClassLoader()// 4 获取调用者的 ClassLoaderDriverManager.getCallClassLoader()Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len) 3.2 API 修饰 方法 说明 Class&lt;?&gt; loadClass​(String name) 加载指定全限定名的类，返回 Class 对象 protected Class&lt;?&gt; findClass(String name) 查找指定全限定名的类，返回 Class 对象 protected Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len) 将字节数组转为一个 Class 对象 InputStream getResourceAsStream​(String name) 获取指定资源文件的流 URL getResource​(String name) 获取指定资源文件的 URL 对象 ClassLoader getParent() 获取父加载器 3.3 Class 和 ClassLoader 获取资源1 说明123456789101112131415// 编译前App src a b Test.java hello.xml// 编译后App WEB-INF classes a b Test.class hello.xml Class 和 ClassLoader 资源路径都是相对于编译后的工程结构来说 getResource() 和 getResourceAsStream() 两个方法路径用法是一样的 2 Class 相对路径：相对于当前类的 .class 文件路径 1class.getResouce(\"hello.xml\") 绝对路径：/ 代表 classpath 根路径，即 classes 目录 1class.getResource(\"/a/b/hello.xml\") 3 ClassLoader 默认就是从 classpath 下寻找资源，所以不能写 / 1classLoader.getResource(\"a/b/hello.xml\") 4 文件流 文件流是相对于当前工程 四 java.lang.Class4.1 获取 Class 对象的方式 方式 说明 类.class 编译期这个类型就要存在 类对象.getClass() 需要先创建对象 Class.forName(&quot;全限定类名&quot;) 类型可以在编译期未知，类名可以在代码中或配置文件中等等 类加载器对象.loadClass(&quot;全限定类名&quot;) 一般用在自定义类加载器去加载指定路径的类 4.2 API1 获取 Class 和 ClassLoader 修饰 方法 说明 static Class&lt;?&gt; forName​(String className) 根据全限定类名获取 Class 对象 ClassLoader getClassLoader() 获取类加载器对象 2 获取类信息 修饰 方法 说明 Package getPackage() 获取包 String getPackageName() 获取包名 String getName() 获取类名 int getModifiers() 获取类修饰符编号 mod Class&lt;? super T&gt; getSuperclass() 获取父类（不带泛型） Type getGenericSuperclass() 获取带泛型的父类 Class&lt;?&gt;[] getInterfaces() 获取所有实现的接口（不带泛型） Type[] getGenericInterfaces() 获取所有实现接口（带泛型） 3 获取构造器 Constructor 修饰 方法 说明 Constructor&lt;?&gt;[] getConstructors() 获取本类所有 public 构造器 Constructor&lt;?&gt;[] getDeclaredConstructors() 获取本类所有构造器 Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 获取本类指定参数类型的 public 构造器 Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) 获取本类指定参数类型的构造器 4 获取属性 Field 修饰 方法 说明 Field[] getFields() 获取本类及父类的所有 public 属性 Field[] getDeclaredFields() 获取本类的所有属性 Field getField​(String name) 获取本类及父类中指定名称的 public 属性 Field getDeclaredField​(String name) 获取本类中指定名称的属性 5 获取方法 Method 修饰 方法 说明 Method[] getMethods() 获取本类及父类的所有 public 方法 Method[] getDeclaredMethods() 获取本类的所有方法 Method getMethod​(String name, Class&lt;?&gt;... parameterTypes) 获取本类及父类中指定方法名和参数类型的 public 方法 Method getDeclaredMethod​(String name, Class&lt;?&gt;... parameterTypes) 获取本类中指定方法名和参数类型的方法 6 获取注解 Annotation 修饰 方法 说明 Annotation[] getAnnotations() 获取类上的所有注解 &lt;A extends Annotation&gt; A getAnnotation​(Class&lt;A&gt; annotationClass) 获取类上指定注解类型的注解 五 java.lang.reflect 包5.1 概述 类 说明 AccessibleObject 访问修饰符控制 Modifier 修饰符 Constructor&lt;T&gt; 构造器 Field 属性 Method 方法 Proxy 代理 5.2 Modifier1 属性 修饰 属性 static int PUBLIC static int PRIVATE ... 此类为修饰符定义了常量值 123public static final int PUBLIC = 0x00000001;public static final int PRIVATE = 0x00000002;... 2 方法 修饰 方法 说明 static String toString(int mod) 获取编号对应的修饰符 5.3 AccessibleObject 修饰 方法 说明 Annotation[] getAnnotations() 获取当前元素（构造、属性、方法）上的所有注解 &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) 获取当前元素上的指定类型的注解 void setAccessible​(boolean flag) true 表示不启用 Java 访问修饰符的检查，可以访问非 public 修饰的成员 5.4 Constructor1 构造器信息 修饰 方法 说明 int getModifiers() 获取构造方法修饰符 String getName() 获取构造方法名 Class&lt;?&gt;[] getParameterTypes() 获取构造方法形参类型列表 2 构造器操作 修饰 方法 说明 T newInstance​(Object... initargs) 使用构造器创建对象 5.4 Field1 属性信息 修饰 方法 说明 int getModifiers() 获取属性修饰符 Class&lt;?&gt; getType() 获取属性类型 String getName() 获取属性名 2 属性操作 修饰 方法 说明 Object get​(Object obj) 获取指定对象此属性的值 void set​(Object obj, Object value) 为指定对象设置此属性的值 5.5 Method1 方法信息 修饰 方法 说明 int getModifiers() 获取方法修饰符 Class&lt;?&gt; getReturnType() 获取返回值类型 String getName() 获取方法名 Class&lt;?&gt;[] getParameterTypes() 获取方法形参类型列表 Class&lt;?&gt;[] getExceptionTypes() 获取抛出异常类型列表 2 方法操作 修饰 方法 说明 Object invoke​(Object obj, Object... args) 调用非静态方法传入指定对象，调用静态方法传入 null 或 类.class 5.6 Proxy 修饰 方法 说明 static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 创建代理对象 六 应用 List&lt;Integer&gt; 中添加字符串 123456// 泛型只在编译期，在运行期通过反射即可实现ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();Class&lt;?&gt; clazz = Class.forName(\"java.util.ArrayList\");Method method = clazz.getMethod(\"add\", Object.class);method.invoke(list, \"哈哈哈\");System.out.println(list);","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-多线程","slug":"Java/Java-多线程","date":"2020-09-29T07:57:44.000Z","updated":"2020-09-29T07:57:58.922Z","comments":true,"path":"2020/09/29/Java/Java-多线程/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"一 概念1.1 同步（Synchronous）&amp; 异步（Asynchronous） 同步和异步都用来形容一次方法调用 同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为 异步方法调用一旦开始，方法调用会立即返回，调用者可以继续后续操作，而异步方法通常会在另一个线程中 “真实” 的执行。异步调用的整个过程不会阻碍调用者的工作，如果异步调用需要返回结果，那么当此异步调用真正完成时，会通知调用者。 1.2 并发（Concurrency）&amp; 并行（Parallelism） 并发： 同一时间多个任务交替执行，只是切换速度较快，看起来是同时执行而并非真正同时执行 同一时间应对多件事情的能力 并行： 同一时间多个任务真正的同时执行 同一时间做多件事情的能力 1.3 进程（Process）&amp; 线程（Thread） 进程： 正在运行的程序的实例，是系统进行资源分配的基本单位 进程是容纳线程的容器 线程： 线程是调度 CPU 的基本单位 进程中的一条执行路径，一个进程至少有一个线程 线程是程序执行的最小单位 二 体系 Runnable 和 Callable 都可以作为线程的任务 Runnable 没有返回值，不能抛异常 Callable 有返回值，能抛异常，主要用于线程池 Future 用来存储将会产生的结果 FutureTask 技能存储结果也能作为任务，相当于 Future + Runnable 三 Thread3.1 创建线程12345678910// 1 使用 Thread 自身的任务Thread()Thread(String name)Thread(ThreadGroup group, String name)// 2 使用 Runnable 任务Thread(Runnable target)Thread(Runnable target, String name)Thread(ThreadGroup group, Runnable target)Thread(ThreadGroup group, Runnable target, String name) 若不指定线程名称，默认为 Thread-0,1,2... 若不指定线程组，默认为父线程（创建此线程的线程）的线程组 构造函数中的 statcksize 代表该线程占用的栈大小，如果未指定，默认为 0，0 代表忽略该参数，该参数会被 JNI 函数去使用。（该参数有些平台有效，有些则无效） 3.2 启动线程 修饰 方法 说明 void start() 启动线程 void run() 子类必须重写，任务方法 static void sleep(long millis)` 控制线程休眠若干毫秒 3.3 线程信息 修饰 方法 说明 String getName() 获取线程名称 void setName(String name) 设置线程名字 long getId() 获取线程 ID Thread.state getState() 获取线程状态 static Thread currentThread() 获取当前线程对象 3.4 加入线程 修饰 方法 说明 void join() 当前线程阻塞，等待插入线程执行完毕 void join(long millis) 当前线程阻塞，等待插入线程执行完毕，但最多只等待指定时间 void join(long millis, int nanos) 时间更精确一点 3.5 中断线程 修饰 方法 说明 void interrupt() 1 运行线程： 设置中断标志位，不代表会退出线程2 阻塞线程（ wait join sleep）：终止阻塞状态并抛出 InterruptedException 异常，且清除中断标志位 static boolean interrupted() 判断当前线程是否被中断，会清除中断标志位 boolean isInterrupted() 判断此线程是否中断，不会清除中断标志位 每个线程都有一个表示 中断状态 的 boolean 标记 每个线程都应该不时检查此标记，以判断线程是否被中断 3.6 守护线程 修饰 方法 说明 void setDaemon(boolean on) 是否将线程设置为守护线程，必须在线程启动前调用 boolean isDaemon 判断是否是守护线程 3.7 礼让线程 修饰 方法 说明 static void yield() 让出本次 CPU 执行权，加入下一次的抢夺中，效果不明显 3.8 线程组 修饰 方法 说明 ThreadGroup getThreadGroup() 获取线程所在线程组 1 概述 线程组可以对一批线程进行分类管理，Java 允许程序直接对线程组进行控制 创建线程对象时，如果未指定线程组，则默认为父线程的线程组 主线程的线程组为 main 2 ThreadGroup1 构造 构造 说明 ThreadGroup(String name) 创建线程组并指定名称 ThreadGroup(ThreadGroup parent, String name) 创建线程组并指定父线程组及名称 2 方法 修饰 方法 说明 String getName() 获取线程组名称 ThreadGroup getParent() 获取线程组的父线程组 int activeCount() 获取线程组中活动线程数 int enumerate(Thread[] list) 枚举线程组中的活动线程 3.9 线程优先级 修饰 方法 说明 int getPriority() 获取线程优先级 void setPriority(int newPriority) 设置线程优先级 1-10，仅仅是概率增加了，玄不改命 Thread.MIN_PRIORITY 最小优先级 1 Thread.NORM_PRIORITY 默认优先级 5 Thread.MAX_PRIORITY 最大优先级 10 四 线程状态 状态 说明 New 新建状态 Runnable 可运行状态：一个线程可能正在运行也可能没有运行 Blocked 阻塞状态 Waiting 无限等待 Timed waiting 限时等待 Terminated 终止状态：正常结束或异常意外终止 五 终止线程 stop() 已过时 stop() 方法过于暴力，会强行把执行到一半的线程终止，可能会引起一些数据不一致的问题 suspend() resume() 已过时 挂起和恢复线程这两个方法同样会破坏同步 定义标记，自行决定线程何时退出 Two Phase Termination：两阶段终止模式 通过中断标记实现 volatile 实现 六 JMM6.1 CPU 缓存1 概述 读写速度（离 CPU 越近，速度越快）：寄存器 &gt; cache L1 &gt; cache L2 &gt; cache L3 &gt; 内存 &gt; 硬盘 cache line 是 cache 的最小存储单元 在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，这就有了缓存一致性（CacheCoherence）问题 为了解决一致性的问题，有许多协议，如 MSI、MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol，等等 2 MESI 缓存一致性协议 状态 说明 M（Modified） 该 cache line 有效，数据被修改了，和内存中的数据不一致，数据只存在于本 Cache 中 E（Exclusive） 该 cache line 有效，数据和内存中的数据一致，数据只存在于本 Cache 中 S（Shared） 该 cache line 有效，数据和内存中的数据一致，数据存在于多个 Cache 中 I（Invalid） 该 cache line 无效 内存中数据，只有一个 cache 中有，则为独占状态 E 当不止一个 cache 中有时，则全为共享状态 S 当某个 cache 修改了数据，则其变为修改状态 M，且其它 cache 变为无效状态 I 多个 CPU 从主内存读取同一个数据到各自的高速缓存，当其中某个 CPU 修改了缓存里的数据，该数据会马上同步回主内存，其它 CPU 通过 总线嗅探机制 （类似于事件监听）可以感知到数据的变化从而将自己缓存里的数据失效 底层实现通过汇编 lock 指令 锁定这块内存区域的缓存（缓存行锁定），并立即将修改数据写回系统内存 这个写回内存的操作会引起在其它 CPU 里缓存了该内存地址的数据无效 6.2 JMM 概述 Java Memory Model Java内存模型是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式 实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享，受到内存模型控制 局部变量，方法参数，异常处理参数不会在线程之间共享，不受内存模型影响 相关概念 临界区 Critical Section 表示一种公共资源或共享数据，可以被多个线程使用，但每次只能有一个线程使用，一旦临界区资源被占用，其它线程就必须等待 一段代码内如果存在对共享数据的多线程读写操作，则这段代码称为临界区 竞态条件 Race Condition 多个线程在临界区内执行，由于代码执行序列不同而导致结果无法预测，称为发生了竞态条件 为避免临界区的竞态条件发生 阻塞式解决方案：synchronized, Lock 非阻塞式解决方案：原子变量 CAS 同步和互斥 同步：是由于线程执行的顺序不同，需要一个线程等待其它线程运行到某个点 互斥：保证同一时刻只有一个线程执行临界区代码 6.3 JMM 内存交互操作（原子操作） 操作 作用对象 说明 read 主内存 从主内存读取数据到工作内存中 load 工作内存 将 read 读取的数据载入工作内存变量副本中 use 工作内存 从工作内存读取数据传递给执行引擎计算 assign 工作内存 将执行引擎计算好的值重新赋值给工作内存 store 工作内存 将工作内存数据传送到主内存 write 工作内存 将 stroe 传送的数据赋值给主内存的变量 lock 主内存 将主内存变量加锁，标记为线程独占状态 unlock 主内存 将主内存变量解锁，解锁后才可以被其他线程锁定 6.4 JMM 特性1 原子性 Atomicity 原子性指一个操作是不可分割的单元，是不可中断的，要嘛都执行，要嘛都不执行 一个原子性操作一旦开始，就不会被其它线程干扰，而一个非原子性操作，在多线程环境下有可能被其它线程所干扰 从一个线程观察另外一个线程的时候，看到的都是一个个原子性的操作 例 1234567synchronized (this) &#123; a = 1; b = 2;&#125;从一个线程观察另一个线程执行上述代码，只有两种结果 1 a,b 都被赋值成功 2 a,b 都未被赋值 2 可见性 Visibility 可见性指当一个线程修改了某个共享变量后，其他线程是否能够立即知道这个修改 每个线程都有自己的工作内存，所以当线程修改完某个变量之后，在其他的线程中，未必能观察到该变量已经被修改 3 有序性 Ordering 指令重排序 JVM 在不影响正确性的前提下，可以调整指令的执行顺序，这种特性称之为『指令重排』，指令重排可以提高 CPU 的处理性能 as-if-serial 语义：不管如何重排序，必须保证串行语义一致，即单线程下，程序的执行结果不会改变 指令重排在多线程下有可能影响正确性 6.5 Happens-Before 规则1 概述 happens-before 规则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据 可以通过此规则分析一个并发程序是否安全 如果 A happens-bofore B，则 A 操作先于 B 操作发生，且 A 操作的结果对 B 可见 2 规则 规则 说明 程序顺序规则（Program Order Rule） 一个线程内保证语义的串行性，即按照代码顺序执行，前面的操作 happens-before 后续的任何操作 管程锁定规则（Monitor Lock Rule） 同一个锁的解锁操作 happens-before 后续对这个锁的加锁操作 volatile 变量规则（volatile Variable Rule） volatile 变量的写操作，happens-before 后续对这个变量的读操作 线程启动规则（Thread Start Rule） 线程 start() 方法 happens-before 线程中的每一个操作 线程终止规则（Thread Termination Rule） 线程的所有操作 happens-before 线程的终结 线程中断规则（Thread Interruption Rule） 线程 interrupt() 方法的调用 happens—before 被中断线程的代码检测到中断事件的发生 对象终结规则（Finalizer Rule） 一个对象的初始化完成（构造函数执行）happens—before 它的 finalize() 方法 传递性（Transitivity） 如果 A happens-before B，B happens-before C，那么 A happens-before C 6.6 volatile1 概述 volatile 是Java虚拟机提供的轻量级的同步机制 volatile 有两个作用： 保证可见性 禁止指令重排序 volatile 无法保证原子性 内存屏障 Memory Barrier 对 volatile 变量的写指令后会加入写屏障 storefence 对volatile 变量的读指令前会加入读屏障 loadfence 2 Volatile 可见性 硬件层面：MESI 当某个线程修改了被 volatile 修饰的共享变量的值，会马上同步到主内存，而开启了 CPU 总线嗅探机制的线程就会得知此修改，然后将自己工作内存中的共享变量副本失效，这样使用时就需要重新从主内存中读取 JVM 层面：Memory Barrier 写屏障保证在该屏障之前的，对共享变量的改动，都同步到主内存当中 读屏障保证在该屏障之后，对共享变量的读取，加载的是主内存中最新数据 3 Volatile 有序性 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前 6.7 synchronized1 概述 synchronized 内置锁是一种对象锁（锁的是对象而非引用），作用粒度是对象，可以用来实现对临界资源的同步互斥访问，是可重入的 synchronized 可以保证原子性和可见性，不能保证有序性，但如果共享变量完全被 synchronized 控制，则不会出现有序性问题 2 同步代码块1234synchronized(锁) &#123; 1. 同步代码块的锁可以是任意对象 2. 不要使用 String Integer Long 作为锁对象&#125; 3 同步函数1234修饰符 synchronized 返回值 方法名(形参列表)&#123; 1. 非静态同步函数的锁是 this 2. 静态同步函数的锁是当前类的字节码对象 类.class&#125; 4 synchronized 原理1 对象头 2 Monitor：监视器/管程 属性 说明 Owner 当一个线程获取锁，并正常执行，则将 Owner 指向此线程，Owner 只能有一个值 EntryList 尝试获取此锁的线程如果获取不到，会阻塞进入 EntryList WaitSet 已经获取锁但条件不满足，进入等待状态的线程会进入 WaitSet 3 原理 每个 Java 对象都有一个自己的 Monitor 对象，当给对象上锁（重量级锁）后，该对象头的 Mark Word 就会指向 Monitor Monitor 的实现依赖底层操作系统的 Mutex lock（互斥锁）实现，它是一个重量级锁性能较低 synchronized JVM内置锁通过内部对象 Monitor 实现，基于进入与退出 Monitor 对象实现方法与代码块同步 synchronized 关键字被编译成字节码后会被翻译成 monitorenter 和 monitorexit 两条指令分别在同步块逻辑代码的起始位置与结束位置 4 锁优化1 锁粗化1234567891011121314151617181920212223242526272829StringBuffer sb = new StringBuffer;public void test() &#123; sb.append(1); sb.append(2); sb.append(3); sb.append(4);&#125;/* StringBuffer是线程安全的，append方法有sychronized修饰，那么调用了4次append方法，就相当于有了四个同步块 sychronized()&#123; append(1); &#125; sychronized()&#123; append(2); &#125; sychronized()&#123; append(3); &#125; sychronized()&#123; append(4); &#125;而这是没有必要的，锁粗化相当于 sychronized()&#123; append(1); append(2); append(3); append(4); &#125;/* 2 锁消除 Java虚拟机在 JIT 编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间 3 锁膨胀升级1 概述 偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁 轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争 重量级锁：有实际竞争，且锁竞争时间长 2 偏向锁 在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁（会涉及到一些 CAS 操作）的代价而引入偏向锁 偏向锁核心思想：如果一个线程获得了锁，那么锁就进入偏向模式，此时 Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作（即获取锁的过程），这样就省去了大量有关锁申请的操作 偏向锁默认开启，但有延迟 调用了对象的 hashCode ，会导致偏向锁被撤销 如果发生了竞争，则偏向锁会失效，会膨胀为轻量级锁 3 轻量级锁 轻量级锁所适应的场景是线程交替执行同步块的场合 轻量级锁在没有竞争时，每次锁重入仍需要执行 CAS 操作 如果在尝试加轻量级锁的过程中，CAS 操作无法成功，一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），则轻量级锁会失败，轻量级锁失败后并不会立即膨胀为重量级锁，而是会先使用锁自旋的优化手段 自旋锁 在大多数情况下，线程持有锁的时间都不会太长，如果当前线程获取轻量级锁失败后直接挂起，可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高 自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，将轻量级锁膨胀为重量级锁 5 锁活跃性 死锁：一个线程需要同时获取多把锁，这时就容易发生死锁（例如锁嵌套） 活锁：两个线程互相改变对方的结束条件，导致谁也无法结束 饥饿：一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束 6.8 常见线程安全类1234567StringIntegerStringBufferRandomVectorHashtablejava.util.concurrent.* 线程安全指的是多个线程调用这些类的同一实例的同一方法是线程安全的 它们每个方法是原子的，但多个方法的组合不是原子的 七 等待唤醒机制7.1 wait/notify1 概述 只有重量级锁才有等待唤醒方法 wait()：相当于 wait(0)，无限等待直到被唤醒 wait(long timeout)：等待指定时间或被唤醒 notify() notifyAll() 获取锁之后才能调用等待唤醒方法，即等待唤醒的方法要在同步代码中执行，且需要同一个锁对象来调用 等待时释放锁，进入 Monitor 的 WaitSet，唤醒之后不会立即获取锁，而是进入 Monitor 的 EntrySet 重新竞争 2 wait &amp; sleep 方法 所属 参数 锁 使用 wait() Object 无参：无限等待有参：有限等待 释放锁 必须先获取锁，在同步代码中使用 sleep() Thread 有参：有限睡眠 不释放锁 可直接使用 3 模式 同步模式之保护性暂停 Guarded Suspension：用在一个线程等待另一个线程的执行结果 结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject 产生结果的线程与消费结果的线程需要一一对应 JDK 中，join 的实现、Future 的实现，采用的就是此模式 异步模式之生产者/消费者 产生结果的线程与消费结果的线程不需要一一对应 JDK 中各种阻塞队列，采用的就是这种模式 7.2 park/unpark1 与 wait &amp; notify 相比 wait &amp; notify 必须配合 Object Monitor 使用，park &amp; unpark 则不必 wait &amp; notify 只能随机唤醒等待线程，park &amp; unpark 是以线程为单位来等待唤醒的，所以精确 wait &amp; notify 不能先 notify，park &amp; unpark 可以先 unpark，即先 unpark 也能恢复 park 的线程 2 原理 每个线程都有自己的一个 Parker 对象，由三部分组成 _counter _cond _mutex park() 判断 _counter _counter == 0 则等待 _counter == 1 则继续运行 将 _counter 设置为 0 unpark() 将 _counter 设置为 1 判断线程状态 如果线程正在等待，则唤醒线程 如果线程正在运行，则继续运行，且由于 _counter 设置为了 1 ，线程下次调用 park() 时，会继续执行 八 CAS8.1 概述 Compare And Swap 或 Compare And Set CAS 是一种无锁算法，体现的是无锁并发、无阻塞并发 CAS 必须借助 volatile ，因为需要保证可见性来读取最新值 内部通过 Unsafe 实现，Unsafe 直接操作虚拟机内存，类似 C C++ 的指针 ABA 问题：version 8.2 原理 CAS 包含三个操作数： 内存值 V 预估值 A 更新值 B 第一次读取内存值记录为 A，之后进行一些操作 当真正写入数据时，再次读取内存值 V，当且仅当 V == A 时，才会更新 V = B 九 java.util.concurrent.atomic9.1 概述 类型 名称 基本类型原子类 AtomicIntegerAtomicBooleanAtomicLong 引用类型原子类 AtomicReference&lt;V&gt;AtomicStampedReference&lt;V&gt;AtomicMarkableReference&lt;V&gt; 数组类型原子类 AtomicIntegerArrayAtomicLongArrayAtomicReferenceArray&lt;E&gt; 原子字段更新器 AtomicIntegerFieldUpdater&lt;T&gt;AtomicLongFieldUpdater&lt;T&gt;AtomicReferenceFieldUpdater&lt;T, V&gt; 原子累加器 LongAdderDoubleAdderLongAccumulatorDoubleAccumulator AtomicReference&lt;V&gt; 只关心当前值和预期值是否相等，不知道值是否被修改过（ABA问题），如 A → B → C → A AtomicStampedReference&lt;V&gt; 增加一个版本号属性，每次修改都使版本号 + 1，可以知道值被修改过几次 AtomicMarkableReference&lt;V&gt; 增加要给布尔属性，判断值是否被修改过 9.2 AtomicInteger1 构造 构造 说明 AtomicInteger() 使用默认值 0 AtomicInteger(int initialValue) 使用指定值 2 方法 修饰 方法 说明 int get() 获取当前值 boolean compareAndSet(int expectedValue, int newValue) 如果当前值与预期值相等，则将当前值设置为新值并返回 true int getAndIncrement() i++ int incrementAndGet() ++i int getAndDecrement() i-- int decrementAndGet() --i int getAndAdd(int delta) 返回原值，之后将值加上指定值 int addAndGet(int delta) 将值加上指定值并返回 int getAndUpdate(IntUnaryOperator updateFunction) 获取原值并计算 int updateAndGet(IntUnaryOperator updateFunction) 计算并返回 十 java.util.concurrent.locks 10.1 Lock1 API 修饰 方法 说明 void lock() 获取锁 void unlock() 释放锁 boolean tryLock() 尝试获取锁 boolean tryLock(long time, TimeUnit unit) 尝试获取锁，会尝试指定时间 void lockInterruptibly() 功能同 locak，如果线程被中断会抛出异常 Condition newCondition() 创建一个该锁的 Condition 对象 2 典型使用1 lock()1234567Lock l = ...;l.lock(); // 获取锁后要紧跟 trytry &#123; // access the resource protected by this lock&#125; finally &#123; l.unlock(); // 释放锁要在 finally 的第一行&#125; 2 tryLock()12345678910Lock lock = ...;if (lock.tryLock()) &#123; try &#123; // manipulate protected state &#125; finally &#123; lock.unlock(); &#125;&#125; else &#123; // perform alternative actions&#125; 3 ReentrantLock1 构造 构造 说明 ReentrantLock() 默认为非公平锁 ReentrantLock(boolean fair) 可创建公平锁（但没有必要，会降低并发度） 2 与 synchronized 比较 在 synchronized 未优化之前，皆为重量级锁，所以才引入 ReentrantLock，ReentrantLock 提供了更丰富的 API synchronized 和 ReetrantLock 都是可重入锁 synchronized 获取不到锁会一直阻塞；ReentrantLock 获取不到锁可以被中断或超时 ReetrantLock 可设置公平锁 synchronized只有一个条件，不满足时进入 WaitSet 等待；ReetrantLock 一个锁可以对应多个 Condition 10.2 Condition 修饰 方法 说明 void await() 当前线程等待，直到被打断或被唤醒 boolean await(long time, TimeUnit unit) 当前线程等待，直到被打断或被唤醒或超时 long awaitNanos(long nanosTimeout) 当前线程等待，直到被打断或被唤醒或超时 void awaitUninterruptibly() 当前线程等待，直到被唤醒 void signal() 唤醒一个等待线程 void signalAll() 唤醒所有等待线程 10.3 ReadWriteLock1 概述 读写锁，将锁更细粒度的划分： 共享锁（读） 排他锁（写） 读锁可以被多个线程共享（当读操作多时，多个读线程可以并发执行，提高效率），写锁则只能一个线程独占 ReentrantReadWriteLock：唯一实现类 StampedLock：能力更强的读写锁 2 API 修饰 方法 说明 Lock readLock() 获取读锁 Lock writeLock() 获取写锁 10.4 LockSupport 修饰 方法 static Object getBlocker(Thread t) static void park() static void park(Object blocker) static void parkNanos(long nanos) static void parkNanos(Object blocker, long nanos) static void parkUntil(long deadline) static void parkUntil(Object blocker, long deadline) static void unpark(Thread thread) 十一 辅助工具类11.1 Semaphore1 概述 Semaphore 是一个计数信号量，必须由获取它的线程释放 用来控制同时访问资源的线程数量（限流） 2 构造 构造 说明 Semaphore(int permits) 创建具有给定许可数的计数信号量，默认为非公平信号量 Semaphore(int permits, boolean fair) 创建具有给定许可数的计数信号量，可设置为公平信号量 3 方法 修饰 方法 说明 void acquire() 从信号量中获取一个许可，在提供一个可用许可之前一直等待 void acquire(int permits) 从信号量中获取指定数量的许可 void release() 释放一个许可，将其返回给信号量 void release(int permits) 释放指定数量的许可，将其返回给信号量 int availablePermits() 获取当前可用的许可个数 boolean hasQueuedThreads() 是否有线程在等待获取许可 `int getQueueLength() 获取正在等待获取许可的线程数 protected Collection&lt;Thread&gt; getQueuedThreads() 获取所有等待获取许可的线程集合 int drainPermits() 获取可用许可个数，并将可用许可置为 0 11.2 CountDownLatch1 概述 用来进行线程同步写作，等待所有线程完成倒计时 允许一个或多个线程等待其他线程完成操作 2 构造 构造 说明 CountDownLatch(int count) 构造时传入一个计数 3 方法 修饰 方法 说明 void countDown() 计数减 1 void await() 当前线程等待，当计数归 0，当前线程继续执行 boolean await(long timeout, TimeUnit unit) 当前线程等待，当计数归 0 或者超时，当前线程继续执行 11.3 CyclicBarrier1 概述 循环栅栏，用来进行线程协作，等待线程满足某个计数 阻塞一组线程直到某个事件的发生 CountDownLatch 只能拦截一轮，CyclicBarrier 可以实现循环拦截 构造时设置计数，每个线程执行到某个需要同步的时刻则等待，当等待的线程数满足计数时，继续执行 2 构造 构造 说明 CyclicBarrier(int parties) 构造时传入一个计数，表示需要等待的线程数 CyclicBarrier(int parties, Runnable barrierAction) barrierAction：等待线程数达到时首先执行的任务 3 方法 修饰 方法 说明 void await() 当前线程等待，直到等待线程数达到初始计数 int await(long timeout, TimeUnit unit) 当前线程等待，直到等待线程数达到初始计数或超时 十二 线程池12.1 线程池体系 12.2 线程池执行过程 12.3 线程池状态 状态 高 3 位 说明 Running 111 接收新任务，能处理已添加任务 Shutdown 000 不接收新任务，能处理已添加任务 Stop 001 不接收新任务，不处理已添加任务，且中断正在处理的任务 Tidying 010 所有任务已终止，ctl 记录的活动线程为 0，即将进入终结 Terminated 011 线程池彻底终止 线程池的运行状态和活动线程数信息存储在一个原子变量 AtomicInteger ctl 中，目的是将线程池状态和线程个数合二为一，这样就可以用一次 CAS 原子操作进行赋值 ctl 高 3 位表示线程池状态，低 29 位表示线程池数量 12.4 线程池数量 Nthreds = NCPU * UCPU * (1 + W/C) NCPU ：CPU 的核数 UCPU ：CPU 期望利用率 (0, 1] W/C ：等待时间和计算时间比率 CPU 密集型运算：线程数 = CPU核数 + 1 I/O 密集型运算：线程数 = CPU核数 * 期望CPU利用率 *（CPU计算时间 + 等待时间）/ CPU计算时间 12.5 ThreadPoolExecutor1 构造1234567ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 参数 说明 int corePoolSize 核心线程数 int maximumPoolSize 最大线程数 long keepAliveTime 线程最大空闲时间，如果线程池中线程数量超过 corePoolSize，超出线程空闲时间超过 keepAliveTime 会被终止 TimeUnit unit 空闲时间单位 BlockingQueue&lt;Runnable&gt; workQueue 任务阻塞队列 ThreadFactory threadFactory 线程工厂 RejectedExecutionHandler handler 拒绝策略 1 Enum TimeUnit1 枚举项：时间粒度 粒度 名称 说明 NANOSECONDS 纳秒 ns 1 s = 109 ns MICROSECONDS 微秒 μs 1 s = 106 μs MILLISECONDS 毫秒 ms 1 s = 103 ms SECONDS 秒 s MINUTES 分 min HOURS 时 h DAYS 日 d 2 方法：线程 修饰 方法 说明 void sleep(long timeout) 当前线程睡眠当前粒度的 timout，替代 Thread.sleep(timeout) void timedJoin(Thread thread, long timeout) 指定线程 join 当前粒度的 timeout，替代 t.join(timout) void timedWait(Object obj, long timeout) 锁对象 obj 等待当前粒度的 timout，替代 obj.wait(timout) 3 方法：时间粒度转换 修饰 方法 说明 long convert(Duration duration) 将指定时间间隔 duration 转换为当前粒度 long convert(long sourceDuration, TimeUnit sourceUnit) 将指定数值 sourceDuration 的指定粒度 sourceUnit 转换为当前粒度 long toNanos(long duration) 将指定数值 duration 的当前粒度转换为纳秒 long toMicros(long duration) 将指定数值 duration 的当前粒度转换为微秒 long toMillis(long duration) 将指定数值 duration 的当前粒度转换为毫秒 long toSeconds(long duration) 将指定数值 duration 的当前粒度转换为秒 long toMinutes(long duration) 将指定数值 duration 的当前粒度转换为分 long toHours(long duration) 将指定数值 duration 的当前粒度转换为时 long toDays(long duration) 将指定数值 duration 的当前粒度转换为日 2 ThreadFactory 默认使用 Executors.defaultThreadFactory() 自定义线程工厂实现此接口 使用不同的工厂，可以更改线程名称，线程组，优先级，守护线程状态等等 3 RejectedExecutionHandler 内置拒绝策略 说明 AbortPolicy（默认） 放弃本次任务，抛 RejectedExecutionException 异常 DiscardPolicy 放弃本次任务 DiscardOldestPolicy 放弃队列中最早的任务，本次任务取而代之 CallerRunsPolicy 让调用者处理任务 自定义拒绝策略实现此接口 Dubbo 的实现：抛 异常之前会记录日志，并 dump 线程栈信息，方便定位 Netty 的实现：创建一个新线程来执行任务 ActiveMQ 的实现：带超时等待（60s）尝试放入队列 PinPoint 的实现：使用了一个拒绝策略链，会逐一尝试 2 方法1 提交任务 修饰 方法 说明 `void execute(Runnable command) 执行任务 Runnable 任务 &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) 提交 Callable 任务，使用 Future 获取任务执行结果 Future&lt;?&gt; submit(Runnable task) 提交 Runnbale 任务，使用 Future 获取任务执行结果 ` Future submit(Runnable task, T result) 提交带返回值的 Runnbale 任务，使用 Future 获取任务执行结果 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) 提交多个任务 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) 提交多个任务，带超时时间 &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) 提交多个任务，哪个任务先成功执行完毕则返回其结果，其它任务取消 &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) 提交多个任务，哪个任务先成功执行完毕则返回其结果，其它任务取消，带超时时间 2 关闭线程池 修饰 方法 说明 void shutdown() 线程池状态变为 Shutdown，不再接收新任务，已提交任务会被执行完，此方法不会阻塞调用线程的执行 List&lt;Runnable&gt; shutdownNow() 线程池状态变为 Stop，不再接收新任务，用 interrupt() 中断正在执行的任务，返回队列中等待执行的任务 boolean isShutdown() 测试线程池是否关闭，线程池状态不为 Running，都会返回 true boolean isTerminated() 测试是否所有任务都执行完毕了，线程池状态为 Terminated，返回 true boolean awaitTermination(long timeout, TimeUnit unit) 由于调用 shutdown 后，调用线程并不会等待所有任务执行完毕，可以使用此方法等待线程池状态变为 Terminated 12.6 Executors1 固定大小线程池12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 核心线程数 = 最大线程数，即不会有救急线程被创建，也就没有超时时间 阻塞队列 LinkedBlockingQueue 最大为 Integer.MAX_VALUE 适合任务量已知，相对耗时的任务 2 带缓冲线程池12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 核心线程数为 0，最大线程数为 Integer.MAX_VALUE，意味着全为救急线程，且超时时间为 60s 阻塞队列 SynchronousQueue 没有容量，读写操作一一对应，意味着提交一个任务就必须马上执行 适合任务数比较密集，但每个任务耗时较短的情况 3 单线程线程池123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService( new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 核心线程数 = 最大线程数 = 1，即线程数固定为 1 适合多个任务排队执行 单线程线程池 &amp; 自己创建一个线程的区别 自己创建一个线程，如果某个任务执行失败而终止，那么没有任何补救措施 单线程线程池会新创建一个线程，保证池中始终有一个工作线程，且线程池有任务阻塞队列 单线程线程池 &amp; 数量为 1 的固定大小线程池的区别 固定大小线程池对外暴漏的是 ThreadPoolExecutor 对象，所以可以使用其方法修改核心线程数 单线程线程池 FinalizableDelegatedExecutorService 使用的是装饰着模式，只对外暴漏了 ExecutorService 的方法，不能使用 ThreadPoolExecutor 的特有方法，无法修改 4 任务调度线程池123456789public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue());&#125; 没有任务调度线程池之前，java.util.Timer 可以用来实现定时功能，缺点： 所有任务由一个线程调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行 如果某一个任务出现异常，会影响到之后的任务 任务调度线程池可以由不同的线程来执行任务，且某个任务出现异常也不会影响其它任务 12.7 ScheduledThreadPoolExecutor 修饰 方法 说明 ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit) 指定延迟后，执行 Runnable 任务 &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit) 指定延迟后，执行 Callable 任务 ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) 初始延迟时间后开始执行任务，到达 period 间隔时间后，判断上一个任务是否执行完毕，若执行完毕则执行下一个任务，否则等待其执行完毕 ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) 初始延迟时间后开始执行任务，上一个任务执行完毕后延迟指定时间再开始执行下一个任务 12.8 Fork/Join1 概述 Fork/Join 是 JDK 7 加入的新的线程池实现，体现的是一种分治思想，适用于能够进行任务拆分的 CPU 密集型运算 分支/合并框架的目的是以递归方式将可以并行的任务拆分成更小的任务，然后将每个子任务的结果合并起来生成整体结果 Fork/Join 是 ExecutorService 接口的一个实现，它把子任务分配给线程池（称为 ForkJoinPool ）中的工作线程 2 任务1 概述 提交给 Fork/Join 线程池的任务需要继承 ForkJoinTask&lt;V&gt; RecursiveTask&lt;V&gt;：有返回值，V是并行化任务（以及所有子任务）产生的结果类型 RecursiveAction：无返回值 定义的任务， 只需实现它唯一的抽象方法 V compute()，此方法同时定义了： 将任务拆分成子任务的逻辑 无法再拆分或不方便再拆分时，生成单个子任务结果的逻辑 compute() 伪代码 1234567if (任务足够小或不可分) &#123; 顺序计算该任务&#125; else &#123; 将任务分成两个子任务 递归调用本方法，拆分每个子任务，等待所有子任务完成 合并每个子任务的结果&#125; 2 ForkJoinTask&lt;V&gt;12ForkJoinTask&lt;V&gt; fork()：使用 ForkJoinPool 中另一个线程异步执行子任务V join()：获取子任务结果，如果尚未完成就等待 3 工作窃取 理想情况下，划分并行任务时，应该让每个任务都用完全相同的时间完成，让所有的CPU内核都同样繁忙。不幸的是，实际中，每个子任务所花的时间可能天差地别 分支/合并框架工程用一种称为工作窃取（work stealing）的技术来解决这个问题 工作窃取算法用于在池中的工作线程之间重新分配和平衡任务 每个线程都为分配给它的任务保存一个双向链式队列，每完成一个任务，就会从队列头上取出下一个任务开始执行 某个线程可能早早完成了分配给它的所有任务，也就是它的队列已经空了，而其他的线程还很忙。这时，这个线程并没有闲下来，而是随机选了一个别的线程，从其队列的尾巴上“偷走”一个任务 这个过程一直继续下去，直到所有的任务都执行完毕，所有的队列都清空 4 ForkJoinPool1 构造 构造 说明 ForkJoinPool() 默认会创建和 CPU 核心数相同大小的线程池 ForkJoinPool(int parallelism) 指定线程数 2 方法123&lt;T&gt; T invoke(ForkJoinTask&lt;T&gt; task)void execute(ForkJoinTask&lt;?&gt; task)&lt;T&gt; ForkJoinTask&lt;T&gt; submit(ForkJoinTask&lt;T&gt; task) 十三 线程安全集合13.1 概述 遗留的线程安全集合如 Hashtable ， Vector 使用 Collections 装饰的线程安全集合 12345678Collections.synchronizedCollectionCollections.synchronizedListCollections.synchronizedMapCollections.synchronizedSetCollections.synchronizedNavigableMapCollections.synchronizedNavigableSetCollections.synchronizedSortedMapCollections.synchronizedSortedSet java.util.concurrent.* Blocking：大部分实现基于锁，并提供用来阻塞的方法 CopyOnWrite：写开销相对较重 Concurrent： 内部很多操作使用 CAS 优化，一般可以提供较高吞吐量 弱一致性 遍历时弱一致性：当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，但这时内容是旧的（非安全容器会抛异常） 求大小弱一致性：size 操作未必是 100% 准确 读取弱一致性 13.2 ConcurrentHashMap&lt;K,V&gt;1 概述 JDK 7 中非线程安全的 Map 集合当元素下标相同时，会添加到链表的头部，而 JDK 8 则是添加到链表的尾部 JDK 7 中在多线程环境使用非线程安全的 Map 集合，当扩容时可能出现并发死链，JDK 8 虽然将扩容算法做了调整，但还是会出现其他问题，如扩容丢数据 2 重要属性和内部类1234567891011121314151617181920212223242526// 默认为 0// 当初始化时, 为 -1// 当扩容时, 为 -(1 + 扩容线程数)// 当初始化或扩容完成后，为 下一次的扩容的阈值大小private transient volatile int sizeCtl;// 整个 ConcurrentHashMap 就是一个 Node[]static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;&#125;// hash 表transient volatile Node&lt;K,V&gt;[] table;// 扩容时的 新 hash 表private transient volatile Node&lt;K,V&gt;[] nextTable;// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Nodestatic final class ReservationNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;// 作为 treebin 的头节点, 存储 root 和 firststatic final class TreeBin&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;// 作为 treebin 的节点, 存储 parent, left, rightstatic final class TreeNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125; 3 重要方法12345678// 获取 Node[] 中第 i 个 Nodestatic final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i)// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) 13.3 CopyOnWriteArrayList ArrayList 每次写入时都会复制一个新的容器再写入 在迭代并添加时没有并发修改异常 每次写入都会复制，效率低，适合并发迭代 十四 java.lang.ThreadLocal&lt;T&gt;14.1 概述123456789101112131415161718192021// 1 ThreadLocalpublic class ThreadLocal&lt;T&gt; &#123; static class ThreadLocalMap &#123; private Entry[] table; static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; &#125;&#125;// 2 Threadpublic class Thread implements Runnable &#123; ThreadLocal.ThreadLocalMap threadLocals = null;&#125; ThreadLocal 中有一个静态内部类 ThreadLocalMap，ThreadLocalMap 中有一个静态内部类 Entry，且维护了一个 Entry 类型的数组，其实数据最终存储在了 Entry[] 中 TheadLocalMap 的键为 ThreaLoal 本身，值为自定义添加的值 一个 ThreadLocalMap 可以存储 n 个 ThreadLocal，所以存储时，会根据不同的 ThreadLocal 计算出不同的索引，此索引即存储到 ThreadLocalMap 中的 Entry[] 中的位置 每个线程对应一个 ThreadLoaclMap ，不同线程互不干扰 每个线程可以有多个不同的 ThreadLocal（如 ThreadLocal&lt;A&gt;, ThreadLoacl&lt;B&gt;...），所有 ThreadLocal 使用同一个 ThreadLocalMap Entry 是一个弱引用 如果是强引用，即使 ThreadLocal tl = null ，Entry 中的键依然指向 ThreadLocal ，会导致内存泄漏 弱引用还是有内存泄漏问题：当 ThreadLocal 为 null 被当成垃圾回收，但 ThreadLocalMap 生命周期和 Thread 一样，它不会回收，即 Entry 中的键为 null 了，而值还存在，但无法访问到了，所以使用完 ThreadLocal 后，执行 remove() 操作 14.2 API 修饰 方法 说明 void set(T value) 此 ThreadLocal 作为键，value 作为值，存储到当前线程的 ThreadLoaclMap 中 T get() 从当前线程的 ThreadLoaclMap 中，获取键 ThreadLocal 对应的值 void remove() 从当前线程的 ThreadLoaclMap 中，移除此 ThreadLocal 的键值对 1 set123456789101112131415161718public void set(T value) &#123; Thread t = Thread.currentThread(); // 获取当前线程的 ThreadLocalMap，如果已存在则直接使用，否则创建一个 ThreadLocalMap map = getMap(t); if (map != null) &#123; map.set(this, value); &#125; else &#123; createMap(t, value); &#125;&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 2 get12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125;","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-集合","slug":"Java/Java-集合","date":"2020-09-29T07:54:08.000Z","updated":"2020-09-29T07:54:24.623Z","comments":true,"path":"2020/09/29/Java/Java-集合/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-%E9%9B%86%E5%90%88/","excerpt":"","text":"一 java.util.Collection&lt;E&gt; 1.1 API1 增 修饰 方法 说明 boolean add(E e) 添加一个元素 boolean addAll(Collection&lt;? extends E&gt; c) 添加一个集合的元素 2 删 修饰 方法 说明 boolean remove(Object o) 删除一个元素 boolean removeAll(Collection&lt;?&gt; c) 删除交集 default boolean removeIf(Predicate&lt;? super E&gt; filter) 删除符合条件的元素 void clear() 清空集合 3 判断 修饰 方法 说明 boolean contains(Object o) 判断是否包含指定元素 boolean containsAll(Collection&lt;?&gt; c) 判断是否包含指定集合 boolean isEmpty() 判断是否为空 4 获取 修饰 方法 说明 int size() 获取元素个数 boolean retainAll(Collection&lt;?&gt; c) 取交集 5 转换 修饰 方法 说明 Object[] toArray() 集合 → 数组 &lt;T&gt; T[] toArray(T[] a) 集合 → 指定类型的数组（建议传入数组 length = size） default &lt;T&gt; T[] toArray(IntFunction&lt;T[]&gt; generator) 集合 → 指定类型的数组（由函数生成） 6 遍历 修饰 方法 说明 Iterator&lt;E&gt; iterator() 获取迭代器 default Spliterator&lt;E&gt; spliterator() 获取并行迭代器 7 流 修饰 方法 说明 default Stream&lt;E&gt; stream() 获取顺序流 default Stream&lt;E&gt; parallelStream() 获取并行流 1.2 java.util.List&lt;E&gt;1 概述 元素有序（存取顺序一致） 元素有索引 元素可以重复 2 API1 增 修饰 方法 说明 void add(int index, E element) 在指定位置插入元素 boolean addAll(int index, Collection&lt;? extends E&gt; c) 在指定位置插入一个集合的元素 2 删 修饰 方法 说明 E remove(int index) 删除指定位置的元素并返回 3 改 修饰 方法 说明 E set(int index, E element) 修改指定位置的元素 4 查 修饰 方法 说明 int indexOf(Object o) 从头开始查询元素第一次出现的索引 int lastIndexOf(Object o) 从尾开始查询元素第一次出现的索引 5 获取 修饰 方法 说明 E get(int index) 获取指定位置的元素 List&lt;E&gt; subList(int fromIndex, int toIndex) 截取集合 [from, to) static &lt;E&gt; List&lt;E&gt; of(E... elements) 获取包含指定元素的不可修改（只读）的 List 集合 static &lt;E&gt; List&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll) 如果传入的集合是不可变的则直接返回，否则通过 of 创建一个包含其元素的不可修改的 List 集合（顺序为指定集合元素的迭代顺序） 6 遍历 修饰 方法 说明 ListIterator&lt;E&gt; listIterator() 获取 ListIterator 迭代器 ListIterator&lt;E&gt; listIterator(int index) 获取 ListIterator 迭代器，从指定索引开始 3 ArrayList1 构造 构造 说明 ArrayList() 默认容量为 10，每次扩容为原容量的 1.5 倍（JDK8以后，创建时 {}，第一次添加时才创建容量 10 的数组） ArrayList(int initialCapacity) 指定容量 ArrayList(Collection&lt;? extends E&gt; c) 包含指定集合元素 2 ArrayList VS Vector ArrayList 非同步，Vector 同步 ArrayList 扩容是原来的 1.5 倍，Vector 扩容是原来的 2 倍 Vector 支持 Enumeration 4 Stack 修饰 方法 说明 boolean empty() 判断是否为空 E peek() 获取但不弹出栈顶元素 E pop() 弹栈（获取并弹出栈顶元素） E push(E item) 压栈（将元素添加到栈顶） int serach(Object o) 返回指定元素的位置编号（栈顶为 1） 1.3 java.util.Set&lt;E&gt;1 概述 元素唯一，不保证存取顺序 HashSet：元素存取无序 LinkedHashSet：元素存取有序 TreeSet：元素存取无序但会排序 Set 集合底层依赖于 Map 集合，添加到 Set 中的元素作为键，一个内部的共享对象作为值 2 API 修饰 方法 说明 static &lt;E&gt; Set&lt;E&gt; of(E... elements) 获取包含指定元素的不可修改的 Set 集合 static &lt;E&gt; Set&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll) 获取包含指定集合中所有元素的不可修改的 Set 集合 3 HashSet &amp; LinkedHashSet 添加元素时，首先 hashCode() 获取元素的哈希值，然后根据某种算法，算出底层数组中的存放位置 如果此位置上没有元素，则添加成功 如果此位置上有元素 首先比较哈希值，如果哈希值不同，则添加成功 如果哈希值相同，则比较 equals() 元素要存入 HashSet 需要重写 hashCode() 和 equals() 方法 一个位置多个元素以链表形式存储多个元素，七上八下： jdk7：新元素在上，指向旧元素 jdk8：新元素在下，旧元素指向新元素 4 TreeSet 元素具有比较性，元素实现 Comparable 接口 集合具有比较性，集合传入一个实现了 Comparator 接口的比较器 TreeSet 判断元素是否相同，就是看到比较结果 1.4 Queue&lt;E&gt;1 API 修饰 方法 说明 boolean add(E e) 向队列末尾添加元素，如果队列已满则抛异常 IllegalStateException boolean offer(E e) 向队列末尾添加元素，如果队列已满则返回 false E element() 获取但不移除队列第一个元素，如果队列为空则抛异常 NoSuchElementEsxception E peek() 获取但不移除队列第一个元素，如果队列为空则返回 null E remove() 获取并移除队列第一个元素，如果队列为空则则抛异常 NoSuchElementEsxception E poll() 获取并移除队列第一个元素，如果队列为空则返回 null 2 Deque&lt;E&gt; 修饰 方法 说明 void addFirst(E e) 向队列首部添加元素，如果队列已满则抛异常 IllegalStateException boolean offerFirst(E e) 向队列首部添加元素，如果队列已满则返回 false void addLast(E e) 向队列尾部添加元素，如果队列已满则抛异常 IllegalStateException boolean offerLast(E e) 向队列尾部添加元素，如果队列已满则返回 false E getFirst() 获取但不移除队列第一个元素，如果队列为空则抛异常 NoSuchElementEsxception E peekFirst() 获取但不移除队列第一个元素，如果队列为空则返回 null E getLast() 获取但不移除队列最后一个元素，如果队列为空则抛异常 NoSuchElementEsxception E peekLast() 获取但不移除队列最后一个元素，如果队列为空则返回 null E removeFirst() 获取并移除队列第一个元素，如果队列为空则则抛异常 NoSuchElementEsxception E pollFirst() 获取并移除队列第一个元素，如果队列为空则返回 null E removeLast() 获取并移除队列最后一个元素，如果队列为空则则抛异常 NoSuchElementEsxception E pollLast() 获取并移除队列最后一个元素，如果队列为空则返回 null 3 BlockingQueue&lt;E&gt;1 API 修饰 方法 说明 boolean add(E e) 向队列末尾添加元素，如果队列已满则抛异常 IllegalStateException boolean offer(E e) 向队列末尾添加元素，如果队列已满则返回 false boolean offer(E e, long timeout, TimeUnit unit) 向队列末尾添加元素，如果队列已满会尝试指定时间，超时则返回 false void put(E e) 向队列末尾添加元素，如果队列已满则阻塞等待 E remove() 获取并移除队列第一个元素，如果队列为空则则抛异常 NoSuchElementEsxception E poll() 获取并移除队列第一个元素，如果队列为空则返回 null E poll(long timeout, TimeUnit unit) 获取并移除队列第一个元素，如果队列为空会尝试指定时间，超时则返回 null E take() 获取并移除队列第一个元素，如果队列为空则阻塞等待 E element() 获取但不移除队列第一个元素，如果队列为空则抛异常 NoSuchElementEsxception E peek() 获取但不移除队列第一个元素，如果队列为空则返回 null Throws exception Special value Times out Blocks 增加 add(e) offer(e) offer(e, time, unit) put(e) 删除 remove() poll() poll(time, unit) take() 检测队首元素 element() peek() 2 实现类 类 说明 ArrayBlockingQueue 数组结构的有界阻塞队列 LinkedBlockingQueue 链表结构的有界阻塞队列（默认 Integer.MAX_VALUE，也可以看作是无界的） SynchronousQueue 容量为 0，是一个不存储元素的阻塞队列，读写操作配对出现，只有一个时会阻塞等待 DelayQueue 优先级堆支持的，基于时间的调度队列（元素按阻塞程度排序，会先获取阻塞低的元素） PriorityBlockingQueue 优先级堆支持的无界优先级队列（内部使用二叉树排好了序） 二 java.util.Map&lt;K,V&gt;2.1 概述 类 说明 HashMap 键唯一，存取无序，null 可以作为键和值，线程不安全（非同步） HashTable 键唯一，存取无序，null 不能作为键和值，线程安全（同步） LinkedHashMap 键唯一，存取有序 Properties 键唯一，存取无序，键值必须是字符串 TreeMap 键唯一，存取无序，元素根据键排序 2.2 键唯一性1 HashMap HashTable LinkedHashMap Properties hashCode() equals() 2 TreeMap 键具有比较性 集合传入比较器 2.3 API1 增 修饰 方法 说明 V put​(K key, V value) 添加键值对，若 key 已存在返回 value，否则返回 null void putAll(Map m) 添加一个集合的键值对 default V putIfAbsent(K key, V value) 如果指定的 key 没有值或值为 null，则将其值设置为指定 value，否则返回已有的值 2 删 修饰 方法 说明 V remove(Object key) 根据指定 key 删除并返回 value，若不存在则返回 null default boolean remove(Object key, Object value) 删除指定键值对 void clear() 清空集合 3 获取 修饰 方法 说明 V get(Object key) 根据指定 key 获取 value，若不存在则返回 null default V getOrDefault(Object key, V defaultValue) 根据指定 key 获取 value，若不存在则返回 defaultValue int size() 获取键值对个数 static &lt;K, V&gt; Map&lt;K, V&gt; copyOf(Map&lt;? extends K, ? extends V&gt; map) 获取包含指定集合键值对的不可修改的 Map 集合 4 判断 修饰 方法 说明 boolean isEmpty() 是否为空 boolean containsKey(Object key) 是否包含指定 key boolean containsValue(Object value) 是否包含指定 value 5 遍历 修饰 方法 说明 Set&lt;K&gt; keySet() 获取所有 key 的 Set 集合 Collection&lt;V&gt; values() 获取所有 value 的集合 Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() 获取所有键值对映射关系的 Set 集合 default void forEach(BiConsumer&lt;? super K, ? super V&gt; action) 遍历键值对并消费 2.4 HashMap1 JDK7：数组 + 链表1 相关概念 DEFAULT_INITIAL_CAPACITY = 16 默认初始容量 DEFAULT_LOAD_FACTOR = 0.75f 默认加载因子 threshold = capacity * loadFactor 阈值/临界值，到达此值数组需要扩容 2 过程 构造时，初始化一个长度为 16 的 Entry[] 数组，并算出 threshold 阈值 每次 put() 添加时，先获取 key 的哈希值，然后根据某种算法计算出在 Entry[] 数组中的存放位置 如果此位置没有数据，则将键值对构建为 Entry 对象添加成功 如果此位置有数据，则比较新加 key 与已存在 key 的哈希值 如果不同，则添加成功 如果相同，则继续比较 key 的 equals() 如果不同，则添加成功 如果相同，则覆盖 value key 不重复时，当大于等于阈值且要存储的位置没有数据时需要扩容（默认变为原容量 2 倍），且集合元素重新计算位置 同一位置的多个数据以链表形式存在，新元素在上边，旧元素会作为新元素的 next 2 JDK8：数组 + 链表/红黑树1 相关概念 DEFAULT_INITIAL_CAPACITY = 16 默认初始容量 DEFAULT_LOAD_FACTOR = 0.75f 默认加载因子 MAXIMUM_CAPACITY = 1 &lt;&lt; 30 最大容量 TREEIFY_THRESHOLD = 8 树化阈值，当链表长度达到此长度时，要考虑树化 UNTREEIFY_THRESHOLD = 6 反树化阈值，当树中的节点个数到达此值时，要考虑变为链表 MIN_TREEIFY_CAPACITY = 64 最小树化容量，当达到树化阈值且容量不小于次之时，才会树化 threshold = capacity * loadFactor 阈值/临界值，当已用容量到达此值数值时，要考虑扩容 2 过程 构造时，没有初始化数组 第一次 put() 添加时，将数组初始化为长度为 16 的 Node[] 数组，并算出 threshold 阈值 添加时过程相同，区别在于链表存储时七上八下，jdk8新的元素在下边，旧元素的 next 指向新元素 添加时还需要判断该索引下是否已经是树结构 如果不是，则判断是否需要树化，当达到树化阈值及树化容量时，会将链表变为红黑树 如果是，则添加 添加时还需要判断扩容问题 2.5 Properties 修饰 方法 说明 String getProperty(String key) 根据 key 获取 value，若不存在则返回 null String getProperty(String key, String defaultValue) 根据 key 获取 value，若不存在则返回 defaultValue Object setProperty(String key, String value) 添加键值对，调用的 HashTable 的 put 方法 Set&lt;String&gt; stringPropertyNames() 获取所有 key 的 Set 集合 Enumeration&lt;?&gt; propertyNames() 获取所有 key 的枚举 void load(InputStream inStream) 从字节输入流中读取键值对数据 void load(Reader reader) 从字符输入流中读取键值对数据 void store(OutputStream out, String comments) 将键值对数据写入字节输出流，comment 为描述信息 void store(Writer writer, String comments) 将键值对数据写入字符输出流 三 集合遍历3.1 java.lang.Iterable&lt;T&gt; 修饰 方法 说明 Iterator&lt;T&gt; iterator() 获取迭代器 default Spliterator&lt;T&gt; spliterator() 获取并行迭代器 default void forEach(Consumer&lt;? super T&gt; action) 增强 for 循环 3.2 java.util.Iterator&lt;E&gt; 修饰 方法 说明 boolean hasNext() 判断是否有下一个元素 E next() 获取下一个元素 default void remove() 删除 next() 获取的元素，即删除之前要先获取 default void forEachRemaining​(Consumer&lt;? super E&gt; action) 遍历并消费元素 3.3 java.util.ListIterator&lt;E&gt;1 说明 ListIterator 是 Iterator 的子接口 在迭代时可以添加修改元素，且可以往回迭代 2 API 修饰 方法 说明 boolean hasNext() 判断是否有下一个元素 E next() 获取下一个元素 int nextIndex() 获取下一个元素的索引 boolean hasPrevious() 判断是否有上一个元素 E previous() 获取上一个元素 int previousIndex() 获取上一个元素的索引 void add(E e) 添加元素 void remove() 删除 next() 或 previous() 获取的元素 void set(E e) 修改 next() 或 previous() 获取的元素 3.4 集合遍历的方式1 集合转为数组，使用普通 for 循环 遍历时可以增删，索引要相应变化 2 迭代器 遍历时如果增会发生并发修改异常 ConcurrentModifyException 遍历时可以使用迭代器的删除方法进行删除 3 增强 for 循环 Iterable 接口的子类或子接口都可以使用 foreach，如数组，集合 遍历时不能增删，因为增强 for 循环底层还是迭代器，增删会发生并发修改异常 3.5 modCount 在 ArrayList，LinkedList，HashMap... 等集合中有此属性，用来记录集合被修改的次数（添加 删除） 使用迭代器或 foreach 遍历集合时，会记录遍历开始时的 modCount 遍历时使用迭代器自身的增删方法修改集合，不会改变 modCount 遍历时使用集合的增删方法，会修改 modCount，前后 modCount 不一致，说明有两个线程在同时操作集合，这种操作有风险，为了保证安全性就会报异常 四 泛型（Generics）4.1 概述 如果没有泛型，就意味着你并不知道集合中存储的是什么类型的数据，那就只能认为都是 Object，所以在使用时，你想要把数据当作某种具体的类型来使用 需要强制类型转换 有可能 ClassCastException 异常 泛型就是一种可以在使用时明确数据类型的功能（类似形参实参） 定义时声明了泛型 使用时就可以使用泛型这种功能来明确数据类型 泛型的好处 明确了数据类型，使用时就不用再做类型转换 限定了数据类型，就意味着如果不合法，编译通不过，把运行期的错误提前到了编译期 泛型：参数化类型 Parameterized type &lt;引用数据类型&gt; 4.2 泛型定义1 定义语法 目标 语法 泛型类 修饰符 class 类名&lt;泛型形参列表&gt;{} 泛型接口 修饰符 interface 接口名&lt;泛型形参列表&gt;{} 泛型方法 修饰符 &lt;泛型形参列表&gt; 返回值类型 方法名(形参列表) {} 泛型形参可以为任意标识符，如 E T K V ... 泛型定义时可以限定使用时的类型上下限 T extends 上限 T super 下限 类/接口上定义的泛型，内部非静态成员可以直接使用 创建对象时指定具体类型 子类上指定具体类型 静态成员不能使用泛型，因为静态比泛型确定具体类型的时机要早 方法上定义的泛型，可以在方法形参和内部使用 调用方法时指定具体类型 泛型方法可以是静态的，因为是调用时确定的类型 方法上的泛型与类或接口没有关系 2 泛型类/接口的子类1 明确数据类型12修饰符 class 子类名 extends 父类&lt;具体类型&gt; &#123;&#125;修饰符 class 子类名 implements 接口&lt;具体类型&gt; &#123;&#125; 2 不明确数据类型12修饰符 class 子类名&lt;泛型形参列表&gt; extends 父类&lt;泛型形参列表&gt; &#123;&#125;修饰符 class 子类名&lt;泛型形参列表&gt; implements 接口&lt;泛型形参列表&gt; &#123;&#125; 4.3 泛型通配符 通配符 说明 &lt;?&gt; 写入时只能添加 null，读取时读取的类型为 Object ? extends E 设定上限，必须是 E 及其子类 ? super E 设定下限，必须是 E 及其父类 A 和 B 是子父类关系，G&lt;A&gt; 和 G&lt;B&gt; 没有关系，它们共同父类是 G&lt;?&gt; 为什么使用 ? 而不能用 Object 123456789101 public void show(Collection&lt;?&gt; c) &#123;&#125; // 正确 /* 因为使用时，ArrayList&lt;String&gt; 就意味着将通配符指定为 String 则 ArrayList&lt;String&gt; = new ArrayList&lt;String&gt;(); 没问题 */2 public void show(Collection&lt;Object&gt; c) &#123;&#125; // 错误 /* 因为使用时， ArrayList&lt;String&gt; = new ArrayList&lt;Number&gt;(); 由于接收的是 Object 所以理论上是没有问题的，但泛型前后必须一致，所以错误 */ 五 java.util.Collections1.1 增删改查 修饰 方法 说明 static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements) 添加多个元素到指定集合 static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) 将 List 集合 src 中的元素拷贝到 dest 中 static &lt;T&gt; boolean replaceAll(List&lt;T&gt; list, T oldVal, T newVal) 将 List 中所有的 oldVal 替换为 newVal static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) List 集合二分查找，要求 List 中的元素有比较性 static &lt;T&gt; int binarySearch(List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c) List 集合二分查找，使用指定比较器 static int frequency(Collection&lt;?&gt; c, Object o) 获取指定元素在集合中出现的次数 1.2 排序 修饰 方法 说明 static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) 按照元素自然顺序对 List 集合排序 static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) 使用指定比较器对 List 集合排序 static void reverse(List&lt;?&gt; list) 反转 LIst 集合 static void shuffle(List&lt;?&gt; list) 随机洗牌 static void swap(List&lt;?&gt; list, int i, int j) 交换 LIst 集合指定索引的元素 1.3 获取集合1 immutable 修饰 方法 说明 static &lt;T&gt; List&lt;T&gt; singletonList(T o) 返回不可变的只包含一个元素的 List 集合 static &lt;T&gt; Set&lt;T&gt; singleton(T o) 返回不可变的只包含一个元素的 Set 集合 static &lt;K, V&gt; Map&lt;K, V&gt; singletonMap(K key, V value) 返回不可变的只包含一对键值的 Map 集合 2 synchronized 修饰 方法 static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c) static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s) static &lt;T&gt; NavigableSet&lt;T&gt; synchronizedNavigableSet(NavigableSet&lt;T&gt; s) static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s) static &lt;K, V&gt; Map&lt;K, V&gt; synchronizedMap(Map&lt;K, V&gt; m) static &lt;K, V&gt; NavigableMap&lt;K, V&gt; synchronizedNavigableMap(NavigableMap&lt;K, V&gt; m) static &lt;K, V&gt; SortedMap&lt;K, V&gt; synchronizedSortedMap(SortedMap&lt;K, V&gt; m) 3 Unmodifiable（只读） 修饰 方法 static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c) static &lt;T&gt; List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list) static &lt;T&gt; Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; s) static &lt;T&gt; NavigableSet&lt;T&gt; unmodifiableNavigableSet(NavigableSet&lt;T&gt; s) static &lt;T&gt; SortedSet&lt;T&gt; unmodifiableSortedSet(SortedSet&lt;T&gt; s) static &lt;K, V&gt; Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m) static &lt;K, V&gt; NavigableMap&lt;K, V&gt; unmodifiableNavigableMap(NavigableMap&lt;K, ? extends V&gt; m) static &lt;K, V&gt; SortedMap&lt;K, V&gt; unmodifiableSortedMap(SortedMap&lt;K, ? extends V&gt; m)","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-IO","slug":"Java/Java-IO","date":"2020-09-29T07:52:03.000Z","updated":"2020-09-29T07:53:01.952Z","comments":true,"path":"2020/09/29/Java/Java-IO/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-IO/","excerpt":"","text":"一 File1.1 概述 File 类代表了一个文件或一个目录 File 类中涉及到的关于文件或目录的创建、删除、修改等方法，并未涉及到写入或读取文件内容的操作。如需读写文件内容，必须通过 IO 流来完成 1.2 属性 修饰 属性 说明 static char separatorChar 路径分隔符；unix &#39;/&#39;，windows &#39;\\\\&#39; static String separator &quot;&quot; + separatorChar static char pathSeparatorChar 多个路径之间的分隔符；unix : ，windows ; static String pathSeparator &quot;&quot; + pathSeparatorChar 1.3 构造 构造 说明 File​(String pathname) 根据路径字符串构造 File File​(String parent, String child) 根据父路径字符串和子路径字符串构造 File File​(File parent, String child) 根据父 File 和 子路径字符串构造 File File(URI uri) 根据 uri 构造 File 1.4 方法1 创建 修饰 方法 说明 boolean createNewFile() 创建文件，已存在则不创建 boolean mkdir() 创建目录，已存在则不创建 boolean mkdirs() 递归创建目录 2 删除 修饰 方法 说明 boolean delete() 删除文件或空目录（不走回收站） boolean renameTo(File dest) 路径相同则重命名，路径不同则剪切 3 判断 修饰 方法 说明 boolean exists() 是否存在 boolean isDirectory() 是否是目录 boolean isFile() 是否是文件 boolean canRead() 是否可读 boolean canWrite() 是否可写 boolean isHidden() 是否是隐藏 boolean isAbsolute() 是否是绝对路径 4 获取 修饰 方法 说明 String getName() 获取文件名 String getPath() 获取构造 File 对象时指定的路径 String getAbsolutePath() 获取绝对路径 String getCanonicalPath() 获取规范路径（自动解析 . ..） long length() 获取文件大小 long lastModified() 获取文件最后修改时间 String getParent() 获取父目录路径的字符串 File getParentFile() 获取父目录路径的 File 对象 5 遍历目录 修饰 方法 说明 static File[] listRoots() 获取系统可用盘符 String[] list() 获取目录下所有文件和目录的字符串名称的数组 String[] list(FilenameFilter filter) 文件名过滤器 File[] listFiles() 获取目录下所有文件和目录的 File 对象的数组 File[] listFiles(FileFilter filter) 文件过滤器 File[] listFiles(FilenameFilter filter) 文件名过滤器 二 IO 流的异常处理2.1 JDK 7123456789101112131415InputStream in = null;try&#123; in = new FileInputStream(\"test.txt\"); 业务代码;&#125; catch(IOException e) &#123; 异常处理;&#125; finally&#123; if(in!=null)&#123; try&#123; in.close(); &#125;catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 2.2 JDK 81234567try ( 需要关闭的资源;) &#123; 业务代码;&#125; catch (IOException e)&#123; 异常处理&#125; 实现了 java.lang.AutoCloseble 的资源可以使用此语法自动关闭（无论是否发生异常） IO 流体系实现了此接口 JDK9 以后要关闭的资源可以在 try 外边初始化 三 基础流3.1 字节输入流1 体系 2 InputStream 修饰 方法 说明 abstract int read() 读取单个字节，返回字节的 int 值，流末尾返回 -1 int read​(byte[] b) 读取字节并存储到数组中，返回读取的字节个数，流末尾返回 -1 int read​(byte[] b, int off, int len) 读取字节并存储到数组指定位置，返回读取的字节个数，流末尾返回 -1 byte[] readAllBytes() 读取流中所有字节 long transferTo(OutputStream out) 将当前输入流中所有数据传递给输出流，并返回传递字节数 void close() 关闭流 字节流读取中文 使用 read() 读取一个字节肯定乱码 使用 read(byte[] b) 缓存数组读取有可能乱码，因为数组长度与数据的字节个数未必恰好吻合，有可能会出现一个字符多个字节但只读取到部分的情况 3.2 字节输出流1 体系 2 OutputStream 修饰 方法 说明 abstract void write​(int b) 写单个字节 void write(byte[] b) 写字节数组 void write(byte[] b, int off, int len) 写字节数组的指定部分 void flush() 刷新，即将缓冲区数据写到目的地，刷新后还可以继续写 void close() 关闭前会自动刷新 3.3 字符输入流1 体系 2 Reader 修饰 方法 说明 int read() 读取单个字符，返回 Unicode 码元（0~65535），流末尾返回 -1 int read(char[] cbuf) 读取字符并存储到数组中，返回读取的字符个数，流末尾返回 -1 abstract int read​(char[] cbuf, int off, int len) 读取字符并存储到数组指定位置，返回读取的字符个数，流末尾返回 -1 abstract void close() 关闭流 字符流一次读取一个字符，字符流怎么知道几个字节是一个字符呢？ 跟字符集有关，如GBK中中文都是1开头的 字符流编码转换过程 read() 按照指定字符集读取 → 查询 unicode 中对应的码点（因为 java 为 unicode） 比如文件内容为一个字 “北”，假如使用的码表为GBK，字符流读取结果为 十进制：21271，转为十六进制为 \\u5317，先读取文件根据GBK转成了 “北”，然后查“北”在 Unicode 中的码点 3.4 字符输出流1 体系 2 Writer 修饰 方法 说明 void write(int c) 写单个字符 void write(String str) 写字符串 void write(String str, int off, int len) 写字符串的指定部分 void write(char[] cbuf) 写字符数组 abstract void write(char[] cbuf, int off, int len) 写字符数组的指定部分 abstract void flush() 刷新 abstract void close() 关闭前会自动刷新 四 文件流4.1 FileInputStream 构造方法 说明 FileInputStream(File file) 根据 File 对象创建，文件必须存在 FileInputStream(String name) 根据文件路径创建，文件必须存在 4.2 FileOutputStream 构造方法 说明 FileOutputStream(File file [, boolean append]) 文件不存在会创建，文件存在会清空 FileOutputStream(String name [, boolean append]) 文件不存在会创建，文件存在会清空 五 缓冲流5.1 概述 缓存流和定义数组哪个快？ 定义数组快，因为读写操作的都是同一个数组，而缓存流分输入和输出，操作的是两个数组 关闭流时，先关外层，再关内层，而关外层流时内层流会自动关闭 5.2 字节缓冲流1 BufferedInputStream 构造方法 说明 BufferedInputStream​(InputStream in [, int size]) 默认缓存区大小为 8192 字节 2 BufferedOutputStream 构造方法 说明 BufferedOutputStream(OutputStream out, int size) 默认缓存区大小为 8192 字节 5.3 字符缓冲流1 BufferedReader 构造方法 说明 BufferedReader​(Reader in [, int sz]) 默认缓存区大小 8192 字符 修饰 方法 说明 String readLine() 读取一行并返回（不包括换行符），流末尾返回 null 2 BufferedWriter 构造方法 说明 BufferedWriter​(Writer out [, int sz]) 默认缓存区大小 8192 字符 修饰 方法 说明 void newLine() 写出换行符（可跨平台） 六 转换流6.1 概述 转换流属于字符流，提供了字节流和字符流之间的转换 InputStreamReader：InputStream → Reader OutputStreamWriter：Writer → OutputStream 字符流原理就是转换流使用平台默认字符集将字节流转换成了字符流 12FileWriter fw = new FileWriter(\"test.txt\");OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"test.txt\"),\"utf-8\"); 字符流 = 转换流(字节流 + 默认字符集) 如果默认字符集是 utf-8 ，则上述两句是等价的 6.2 InputStreamReader 构造方法 说明 InputStreamReader​(InputStream in [, String charsetName)] 字节流到字符流的桥梁，使用指定字符集解码 使用字节流读取文本数据时，先读取字节数据，然后使用字符集解码 InputStreamReader：读取字节数据并使用字符集解码 6.3 OutputStreamWriter 构造方法 说明 OutputStreamWriter​(OutputStream out [, String charsetName]) 字符流到字节流的桥梁，使用指定字符集编码 使用字节流写出文本数据时，先使用字符集编码，然后写出字节数据 OutputStreamWriter：使用字符集编码并写出字节数据 6.4 两种方法实现键盘录入123456// 1BufferedReader br=new BufferedReader(new InputStreamReader(System.in))BUfferedWriter bw=new BufferedWriter(new OutputStreamWriter(System.out)) // 2Scanner sc=new Scanner(System.in); 七 打印流7.1 概述 可以对多种数据类型进行打印，并保持数据的表示形式 write(int) ：只会写出 1 个字节 print(int) ：可以写出 4 个字节 不抛出 IOException 打印原理 基本数据类型先变成字符串再打印 引用数据类型非 null 就调用对象的 toString()，null 就打印 null PrintWriter &amp; printStream PrintStream 能做的 PrintWriter 也都能实现且功能更强大，但 PrintStream 出现较早，System.out 使用的是 PrintStream 来实现的，所以为了兼容并没有废弃 PrintStream 二者都提供了一系列重载的 print println 方法 PringtStream 打印的所有字符都使用平台默认的字符集来编码为字节数据，打印字符时，建议使用 PrintWriter PrintWriter &amp; printStream 都可以设置自动刷新 printStream：写入字节数组、任何重载版本的 println() 被调用、一个换行符（char）被写入、一个换行符的字节存储（\\n）被写入 PrintWriter： 自动刷新只对 println() printf() format() 这些方法有效 7.2 PrintStream 构造 说明 PrintStream​(File file [, String charsetName]) 接收 File 对象 PrintStream​(String fileName [, String charsetName]) 接收字符串路径 PrintStream​(OutputStream out [, boolean autoFlush [, String encoding]]) 接收字节输出流 7.3 PrintWriter 构造 说明 PrintWriter​(File file [, String charsetName]) 接收 File 对象 PrintWriter​(String fileName [, String charsetName]) 接收字符串路径 PrintWriter​(OutputStream out [, boolean autoFlush [, Charset charset]]) 接收字节输出流 PrintWriter​(Writer out [, boolean autoFlush]) 接收字符输出流 7.4 标准输入输出流 流 类型 说明 设备 System.in InputStream 标准输入 键盘 System.out PrintStream 标准输出 显示器（控制台） System.err PrintStream 标准错误输出 显示器（控制台） 八 序列化流（对象流）8.1 概述 序列化 &amp; 反序列化 序列化：写出一个对象 反序列化：读取一个对象 对象序列化机制：好处在于将对象转化为字节数据，使其在保存和传输时可被还原 允许把内存中的 Java 对象转换成平台无关的二进制流，从而把这种二进制流持久的保存在磁盘上或通过网络进行传输 当其它程序获取这种二进制流，就可以恢复成原来的 Java 对象 对象序列化的条件： 对象必须实现序列化接口 Serializable ：序列化标记接口，对象序列化内容和顺序都是默认的 Externalizable ：Serializable 的子接口，可定制序列号内容和顺序 对象的所有属性也必须可序列化 引用类型的属性也必须实现序列化接口 基本类型属性默认可序列化 对象不会序列化的属性 transient 关键字修饰的属性 static 关键字修饰的属性 序列化ID ：serialVersionUID 用于判断类和对象是否是同一个版本 建议实现序列化接口时就指定，否则每次重新编译类，序列化ID都会变化 8.2 ObjectInputStream1 构造 构造 说明 ObjectInputStream​(InputStream in) 装饰字节输入流 2 方法 修饰 方法 说明 Object readObject() 读取对象 8.3 ObjectOutputStream1 构造 构造 说明 ObjectOutputStream(OutputStream out) 装饰字节输出流 2 方法 修饰 方法 说明 void writeObject(Object obj) 写出对象 九 数据流9.1 概述 数据流主要用来操作基本类型和 String 类型的数据，这些数据如果使用其它流读写，可能会出问题 以二进制形式读写数组，字符，字符串，布尔… 9.2 DataInputStream1 构造 构造 说明 DataInputStream​(InputStream in) 装饰字节输入流 2 方法 修饰 方法 说明 String readUTF() 读字符串 T readT() 读指定类型数据，readInt() readDouble() ... 9.3 DataOutputStream1 构造 构造 说明 DataOutputStream​(OutputStream out) 装饰字节输出流 修饰 方法 说明 void writeUTF​(String str) 写字符串 void writeT(T t) 写指定类型数据，writeInt(int i) writeDouble(double d) ... 十 内存流10.1 概述 操作字节数组 流关闭无效，不抛 IOException 向内存中读写数组 字节流读取中文时，可能会乱码，可以使用内存输出流先写到内存中，然后一次性获取所有数据 10.2 ByteArrayInputStream1 构造 构造 说明 ByteArrayInputStream(byte[] buf [, int offset, int length]) 把字节数组作为缓冲数组 2 方法 修饰 方法 说明 int read() 读取一个字节 int read(byte[] b, int off, int len) 读取字节并存储在数组中 10.3 ByteArrayOutputStream1 构造 构造 说明 ByteArrayOutputStream([int size]) 可以指定缓冲区大小 2 方法 修饰 方法 说明 void write(int b) 写出一个字节 void write(byte[] b, int off, int len) 写出数组指定数据 byte[] toByteArray() 将缓冲区的数据全部取出，获取一个字节数组 String toString() 将缓冲区的数据用平台默认编码转为字符串","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-异常","slug":"Java/Java-异常","date":"2020-09-29T07:50:06.000Z","updated":"2020-09-29T07:52:42.321Z","comments":true,"path":"2020/09/29/Java/Java-异常/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-%E5%BC%82%E5%B8%B8/","excerpt":"","text":"一 异常体系 非受检异常： Unchecked Exception Error 在你的控制范围之外 一般指 JVM 系统内部错误或资源耗尽等严重问题，一般不编写针对性的代码进行处理 RuntimeException 一般是程序员所犯的错误，由于代码不够健壮引起的异常，如果出现 RuntimeException 那么一定是你的问题 不应该处理，而是一开始就应该避免 受检异常：Checked Exception 非受检异常 Error 和 RuntimeException 外的所有异常都是受检异常，或叫编译时异常 编译时异常一般是由程序的运行环境导致的，程序可能被运行在各种未知的环境下，而程序员无法干预用户的使用环境 检查型异常需要处理：声明或捕获 二 异常处理（抛抓模型）2.1 “抛” 过程1. 概述 程序出现异常时，会在异常代码处创建一个异常对象（包含内容，原因，位置 …），并将此对象抛出 一旦抛出异常对象后，其后的代码就不再执行 抛出异常有两种方式 系统自动生成并抛出的异常 手动抛出异常 throw 2 throw1throw 异常对象实例; throw 用在在方法中，抛出异常 非受检异常 throw 后可以不用处理 受检异常 throw 后必须处理：try-catch 或 throws throw 会终止程序，代替 return 2.2 “抓” 过程1 概述 可以理解为异常的处理方式 共有两种： try-catch-finally throws 2 try-catch12345678910111213try( // 可能出现异常的代码) catch(异常类型1 变量名1) &#123; // 异常处理;&#125; catch(异常类型2 变量名2) &#123; // 异常处理;&#125; catch(异常类型3 变量名3) &#123; // 异常处理;&#125; ...finally &#123; // 可选&#125; try catch 处理异常后，程序可以继续运行 多 catch 时，大的异常要放在后边，因为会依次匹配，匹配到就停止 try 中的代码发生异常相当于创建了一个异常对象，然后赋值给 catch 后边括号中的变量 3 throws1void test() throws 异常1, 异常2, ... &#123;&#125; throws 用在方法上，声明此方法可能抛出的异常 可以声明多个，逗号分隔 一旦出现异常，把异常对象抛给此方法的调用者，若调用者也没有处理，则一直抛直到 main 函数，如果 main 函数也没有处理，则抛给 JVM 处理，JVM 默认异常处理机制：printStackTrace() 三 java.lang.Throwable3.1 构造 构造 Throwable() Throwable(String message) Throwable(Throwable cause) Throwable(String message, Throwable cause) 3.2 方法 修饰 方法 说明 String toString() 返回异常类名和异常信息的字符串 String getMessage() 获取异常信息 void printStackTrace() 打印异常类名和异常信息，以及异常出现在程序中的位置 Throwable getCause() 获取原因 Throwable initCause(Throwable cause) 为异常对象设置原因，如果已有原因则抛出一个异常 StackTraceElement[] getStackTrace() 获取构造异常对象时调用堆栈的轨迹 四 自定义异常1234567891011class MyException extends RuntimeException &#123; statci final long serialVersionUID = xxxxx; public MyException() &#123; super(); &#125; public MyException(String message) &#123; super(message); &#125;&#125; 继承现有异常结构： Exception 或 RuntimeException 提供重载构造器：建议保留无参构造和带 message 的有参构造 由于 Throwable 实现了 Serializable 接口，建议自定义异常时指定 serialVersionUID 五 思考 return 与 finally 混用 执行到了 return，已经把要返回的结果准备好了。这时先去执行 finally 中的代码，然后再 return 如果 finally 中改变了要 return 的值，最终返回结果也不会改变，因为 return 的值已经缓存好了，改变了也没用。 如果 finally 中也有 return，那么最后返回的是 finally中的返回值 六 断言6.1 语法 assert condition; 如果 condition 为 false 则抛出 AssertionError 异常 assert condition: expression; 如果 condition 为 false 则抛出 AssertionError 异常，且 expression 会传入 AssertionError 构造器，并转为一个消息字符串 6.2 启用/禁用断言 断言默认是禁用的 运行时使用 -enableassertions 或 -ea 启用 12java -ea Test 打开某个类的断言java -ea:xxx.xx.x Test 打开包下所有类的断言 -disableassertions 或 -da 禁用断言","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-面向对象","slug":"Java/Java-面向对象","date":"2020-09-29T07:45:40.000Z","updated":"2020-09-29T07:52:50.061Z","comments":true,"path":"2020/09/29/Java/Java-面向对象/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"一 概述1.1 编程范式 programming paradigm 术语 说明 Procedural programming 面向过程 Object-Oriented Programming 面向对象 Functional Programming 函数式 Event-driven Programming 事件驱动 Aspect-oriented Programming 面向切面 Logic Programming 逻辑 1.2 面向对象和面向过程 把大象装进冰箱 面向过程 POP（Process Oriented Programming） 打开冰箱门 把大象放进去 关上冰箱门 面向对象 OOP（Object Oriented Programming） 冰箱（开门，关门） 大象（进冰箱） 人（指挥冰箱开门，指挥大象进去，指挥冰箱关门） 区别 面向过程 强调的是功能行为，以函数为最小单位，考虑怎么做 性能相对较好，但耦合性搞，不易维护、复用和扩展 面向对象 强调具备了功能的对象，以类/对象为最小单位，考虑谁来做 耦合度低，易维护、易复用、易扩展 二 类2.1 概念 概念 说明 类 class 对一类事物的描述，模板 对象 object 某类事物的个体，也叫实例（instance） 属性 field 类的成员变量，也叫字段，域 方法 method 类的成员函数，也叫行为 2.2 类成员1234567修饰符 class 类名 &#123; 属性列表 代码块 构造器列表 方法列表 内部类&#125; 1 构造器 构造函数的名称必须与类名相同 一个类可以有多个构造器，彼此构成重载 若类中没有显式定义构造函数，则会有一个默认空参构造函数（修饰符与类一致 public 或 default） 构造函数第一行一定直接或间接调用父类构造函数，即如果在构造器首行没有显式的使用 this(形参列表) 或 super(形参列表) ，则默认调用了 super() 2 属性1 语法12修饰符 数据类型 属性名; // 默认初始值修饰符 数据类型 属性名 = 值; // 显式初始值 2 成员变量（实例变量/静态变量）和局部变量 变量 声明位置 初始值 存储位置 实例变量 类中 有 堆 静态变量 类中 有 方法区 局部变量 方法形参、方法内、代码块内、构造形参、构造内 无 栈 3 方法1 语法123修饰符 返回值 方法名(形参列表) &#123; 方法体;&#125; 2 形参列表 参数1, 参数2, ... 参数类型 ... 参数名 （可变参数） 可以传递 0 到 多个参数 可变参数必须在形参的最后声明 3 参数传递 Java 参数传递是值传递 基本数据类型实参赋值给形参的是实参真实存储的数据值 引用数据类型实参赋值给形参的是实参存储数据的地址值 java 在传递参数时，将实际参数的副本（拷贝一份）传入方法内，而参数本身不受影响 4 方法的重载（Overload） 同一个类中，方法名相同，形参列表不同（个数、顺序或类型）即为重载 4 代码块1 构造代码块12345&#123; 构造代码块： 1 每次创建类实例都会在构造器之前执行 2 如果有多个，按照声明顺序执行&#125; 2 静态代码块12345static &#123; 静态代码块： 1 随着类的加载而执行，且仅在加载类字节码文件时执行一次 2 如果有多个，按照声明顺序执行 &#125; 5 内部类1 分类 类型 分类 声明位置 成员内部类 非静态成员内部类（成员内部类）静态成员内部类（静态内部类） 类中 局部内部类 非匿名局部内部类（局部内部类）匿名局部内部类（匿名内部类） 方法中，代码块中，构造器中 2 成员内部类1 概述 当描述一个事物时，发现内部还有一个完整的结构需要一个类来描述，且此内部结构独立存在没有意义，必须依附外部类。就可以定义内部类。如身体和心脏。 内部类作为外部类的成员 访问外部类 内部类可以直接访问外部类的成员（包括私有），内部类持有一个外部类的引用 外部类名.this 外部类要访问内部类的成员，必须创建对象 可以被 4 种权限修饰符修饰 可以被 static 修饰：只要内部类不需要访问外部类对象，就应该使用静态内部类 内部类作为一个类 可以定义属性、方法、构造器等等 可以被 abstract final 修饰 2 非静态成员内部类（成员内部类） 成员内部类中不能有任何 static 的定义 成员内部类的访问 123456// 1 首先要创建外部类对象Outer out = new Outer();// 2 使用外部对象创建内部类对象Out.inner in = out.new Inner()// 简写Outer.Inner in=new Outer().new Inner(); 3 静态成员内部类（静态内部类） 静态内部类可以定义所有普通类可以定义的内容 静态内部类不会随着外部类的加载而加载，只有使用时才会加载 静态内部类的访问 12// 创建静态内部类对象Outer.Inner in=new Outer.Inner() 3 局部内部类1 概述 局部内部类修饰符只能有 final 和 abstract 局部内部类访问其所在方法的局部变量时，要求此局部变量必须是 final 因为当调用这个方法时，如果方法中的局部变量不是 final 的，那么方法弹栈此局部变量也就消失了，而此时局部内部类对象可能还存在，就会访问不到此局部变量 JDK 8 可以不加 final，但实际还是 final 的 2 非匿名局部内部类（局部内部类）12345public void method() &#123; class A&#123; &#125;&#125; 3 匿名局部内部类（匿名内部类）12345public void method() &#123; new 父类/父接口() &#123; 重写方法; &#125;&#125; 2.3 对象实例化过程 加载 class 文件（有父类先加载父类） 静态变量和静态代码块（谁在前谁先执行，只执行一次） 属性默认初始化 构造函数第一行（调用父类构造） 属性显式初始化和构造代码块（谁在前谁先执行，每次创建对象都会执行） 构造函数剩余行 三 面向对象特征3.1 权限修饰符 修饰符 本类 同一个包(子类+无关类) 不同包(子类) 不同包(无关类) private √ × × × default √ √ × × protected √ √ √ × public √ √ √ √ 权限修饰符是用来限定该类实例对象对该类成员的访问权限 在不同包的类中严格来说我认为只能访问 public 修饰的成员，特殊情况是不同包的子类中能使用子类实例访问到父类 protected 修饰的成员（使用父类实例是访问不到的），是因为继承的关系，在自己类中访问自己继承的东西当然可以访问到。 12345// 在子类 A 中this.clone() // 正确new A().clone() // 正确new Object().clone() // 错误new B().clone() // 错误 3.2 封装（Encapsulation） 封装即隐藏该隐藏的，暴露该暴露的 隐藏对象内部的复杂性，之对外公开简单接口，便于外界调用，提高维护性和扩展性 封装性的体现 private 私有化属性而提供公共的 getter/setter 方法 不对外暴漏的私有方法 单例… 3.3 继承（Inheritance）1 概述 好处 提高代码的复用性 便于功能的扩展 让类与类产生关系，是多态的前提 弊端 类的耦合性增强了 开发原则：高内聚，低耦合 耦合：类与类的关系 内聚：自己完成某件事的能力 2 特点 子类会继承父类所有的属性和方法，私有的也会继承，只是不能直接访问 Java 是单继承，一个类只能有一个父类 3 重写（Override） 方法名一致 形参列表一致 返回值 基本数据类型和 void，必须完全一致 引用数据类型，一致或者其子类 权限修饰符 子类重写方法访问权限不能小于父类方法 异常 子类重写方法抛出的异常只能是父类方法抛出的异常或者其子类 子类重写方法不能抛出父类方法没有抛出的异常 不能被重写的方法 final 修饰的方法 static 修饰的方法 子类不能访问的方法 private 修饰的方法 跨包时默认修饰权限的方法 4 类型转换 只能在继承层次内进行类型转换 向上转型（upcasting）：子类转父类，多态，自动转换 向下转型（downcasting）：父类转子类，强制类型转换 强制类型转换前，应使用 instanceof 检查 12x instanceof A// 判断 x 对象所属类是否是 A 类或 A 类的子类 3.4 多态（Polymorphism）1 概述 一个对象变量可以指向多种实际类型的现象称为多态 编译时类型和运行时类型不一致，就出现了多态 编译时类型由声明时的类型决定 运行时类型由实际对象类型决定 虚拟方法调用：子类中定义了与父类同名同参的方法（重写），多态情况下，将父类方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法，这样的方法调用编译器是无法确定的 在运行时能自动的选择适当的方法称为动态绑定 dynamic binding 如果是 private static final 方法或构造器，编译器可以准确的知道调用哪个方法，称为静态绑定 static binding 2 多态前提 继承或实现 重写 父类引用指向了子类对象 3 多态性 成员 多态性 说明 成员变量（属性） 无 编译运行都看左边 非静态成员方法 有 编译看左边，运行看右边（动态绑定） 静态成员方法 无 编译运行都看左边 对象的多态性只适用于方法，不适用于属性 非静态成员方法：虚拟方法调用 编译时：查看声明类型所属类（父类）是否有此方法，有则编译通过，没有则报错 运行时：查看对象实例所属类（子类）是否有父类中此方法对应的重写方法，有则执行，没有则向上查找 例 12345678910111213141516public class Cat &#123; private void eatFish() &#123; System.out.println(\"猫吃鱼\"); &#125; public static void main(String[] args) &#123; Cat cat = new SmallCat(); cat.eatFish(); // 结果是 \"猫吃鱼\" &#125;&#125;class SmallCat extends Cat &#123; public void eatFish() &#123; System.out.println(\"小猫吃奶\"); &#125;&#125;// 因为父类是private，子类访问不到，所以并非是重写// 成员方法运行时调用的是子类重写方法，没有则会调用父类方法，所以结果是调用的父类方法 四 关键字4.1 this 方法中：代表调用该方法的对象 构造器中：代表正在初始化的对象 构造器中：调用本类其它构造器 4.2 super 构造器或方法中：访问父类属性或方法 构造器中：调用父类构造 4.3 static 随着类的加载而加载 优先于对象存在 被类的所有实例共享 直接使用类名调用 静态上下文只能访问静态，不能访问非静态，静态上下文中没有 this super 非静态上下文可以访问静态和非静态 4.4 final 修饰对象 说明 类 类不能被继承，一个类被声明为 final 则其方法自动变为 final 变量 变量就变成了常量，必须初始化且只能被赋值一次，大写 方法 方法不能被重写 4.5 abstract1 只能修饰类和方法 抽象类有构造方法，但不能实例化 抽象类可以有抽象方法也可以有一般方法（包括静态和非静态方法） 有抽象方法的一定是抽象类，抽象类不一定有抽象方法 2 abstract 不共存的关键字（抽象是为了重写） static 类直接调用一个抽象方法没有意义 private private 修饰的方法子类无法访问，也就无法重写，一个不能被重写的抽象方法没有意义 final final 修饰的类无法继承，一个不能被继承的抽象类没有意义 final 修饰方法无法重写，一个不能被重写的方法没有意义 native 因为 native 本身就没有方法体，不明确是什么情况 4.6 native native 修饰的方法，看不到方法体，不是 Java 语言实现的，而是调用了底层 C/C++ 的实现，存储在本地方法栈 native 方法正常调用即可，且可以重写 4.7 包1 package1package x.x.x; 同一个包下类/接口不能重名 用于控制访问权限 用于划分项目的结构层次，通常将功能相近的类划分到同一个包中 2 import12import java.util.*import static java.util.Math.*; 如果在源文件中，使用了不同包下的同名的类，则只有一个可以导入，其它需要使用全类名的方式 xxx.* 表示可以使用 xxx 包下的所有结构，但其子包下还需要导入 3 JDK 主要包说明 包 说明 java.lang Java语言的核心类/接口 java.io IO 功能相关类/接口 java.net 网络相关类/接口 java.util 实用工具类 java.text 格式化相关的类 java.sql JDBC数据库编程的相关类/接口 java.awt GUI 相关 java.applet applet 运行所需的类 五 main() 方法说明 作为程序的入口 可以当作普通的静态方法 String[] args 可以用来接收控制台参数（以空格隔开） 六 接口 Interface6.1 语法1234修饰符 interface 接口名 &#123; 接口属性列表; 接口方法列表;&#125; 接口没有构造器，不能创建对象 类可以多实现，接口可以继承接口 接口实现类必须实现所有的接口方法，否则仍是抽象类 6.2 成员 接口成员 修饰符 说明 全局常量 public static final 修饰符可以省略 抽象方法 public abstract 修饰符可以省略 静态方法 public static public 可以省略 默认方法 public default public 可以省略 私有方法 private 修饰符不能省略 JDK 8 以后接口为何新增静态方法? 因为一般工具类中都是静态方法，而这些静态方法通常都是为某个接口服务的，如 Collection Collections 把静态方法直接定义在接口中，可以避免增加额外的工具类 JDK 8 以后接口为何新增默认方法? 因为有时候，一个接口的多数实现类对接口的抽象方法的实现是一样的 把这样的抽象方法定义为默认方法，可以减少实现类的重复工作 如果实现类实现多个接口，出现了默认方法冲突（会报错） 从其中选择一个，重写默认方法（去掉 default） 都不用，重写默认方法（去掉 default） 如果实现类继承父类实现接口，出现了默认方法冲突（不会报错） 默认使用父类 手动改选接口 完全重写 Java 9 中 接口中可以有 private 方法 七 枚举 Enum7.1 概述 类的对象只有确定的有限个 枚举即将其所有可用对象直接在内部列出来 枚举不需要创建对象，构造函数默认即为私有的 当需要定义一组常量时，强烈建议使用枚举类 枚举也可以实现接口 7.2 自定义枚举1 手动实现枚举（JDK5 之前） 私有化构造函数 在类中创建所有可用的实例对象，定义为公有静态常量 public static final 2 enum 关键字1234修饰符 enum 枚举类名 &#123; 枚举项列表; 其它成员列表;&#125; 默认继承 java.lang.Enum 枚举项必须定义在首行，以逗号分隔，最后一个以分号结束 枚举项即为枚举类的实例 构造函数有参数，枚举项也要有参数 123enum Week&#123; MON(\"星期一\"),TUS(\"星期二\"),SUN(\"星期日\");&#125; 枚举类有抽象方法，枚举项也要实现 1234567enum Week &#123; Mon(\"星期一\")&#123; @Override public void show() &#123; &#125; &#125;;&#125; 7.3 java.lang.Enum1 构造 构造 protected Enum(String name, int ordinal) 此构造方法不是程序员调用的，而是由编译器调用的 所以不能在枚举类中手动调用父类构造 2 方法 修饰 方法 说明 String toString() 返回此枚举项的名称 int ordinal() 返回枚举项的编号 String name() 返回此枚举项的名称 int compareTo(E o) 比较枚举项的编号 static &lt;T extends Enum&lt;T&gt;&gt; valueOf(Class&lt;T&gt; enumType, String name) 返回指定类型中指定名称的枚举项 static T[] values() Enum 没有，所有枚举类都有，获取所有枚举项 static T valueOf(String name) Enum 没有，所有枚举类都有，返回指定名称的枚举项 八 注解 Annotation8.1 概述 注解是针对程序的注释，是给程序看的，用于描述程序如何运行及在什么阶段来运行。 注解在实际开发中，最大的功能是用于替换配置文件 一个完整的注解由三部分组成 声明 使用 读取 Java 把枚举看作类，把注解看作接口 所有注解都继承了 java.lang.annotation.Annotation 8.2 JDK 中三个基本注解 注解 说明 @Override 检查重写方法是否合法 @Deprecated 表示已过时 @SuppressWarnings({警告类型列表/all}) 抑制警告 8.3 文档注释相关注解 注解 说明 格式 @author 作者 @author 作者名 @version 版本 @version 1.0 @see 另请参阅 @see 另请参阅信息 @since 从 xx 版本开始引入 @since xx @param 参数信息，一对一 @param 形参名 形参类型 注释 @return 返回值信息 @return 返回值类型 注释 @throws 抛出异常信息 @throws 异常类型 注释 8.4 自定义注解1 声明12345修饰符 @interface 注解名&#123; 数据类型 属性名(); // 注解的属性类似方法 int age(); String name() default \"haha\"; // 可以设置默认值&#125; 注解数据类型 八种基本数据类型 String 类型 enum 枚举类型 Annotation 注解类型 Class 类型 以上类型的一维数组类型 如果注解没有成员，通常是标识作用 如果注解只有一个成员，建议属性名 value 2 使用12@Xxx(name=\"\") //非数组类型注解赋值@Xxx(name=&#123;\"\", \"\", \"\"&#125;) // 数组类型注解赋值 使用注解时注解中的所有属性都要赋值，有默认值的可以省略使用默认值 如果使用注解时最终配置的属性只有一个 value，则可以省略属性名 3 读取 使用反射读取注解 8.5 元注解（用在注解上的注解） 元注解 格式 说明 @target @target(ElementType.xxx) 标记此注解的使用位置 @Retention @Retention(RetentionPolicy.xxx) 标记此注解的生命周期 @Documented @Documented 标记此注解可以被 javadoc.exe 读取到 API @Inherited @Inherited 标记此注解可以被子类继承 1 ElementType 是一个枚举类，用于枚举注解使用的位置 枚举项 使用位置 TYPE 类，接口（包括注解）或枚举 FIELD 属性 METHOD 方法 PARAMETER 形参 CONSTRUCTOR 构造函数 LOCAL_VARIABLE 局部变量 ANNOTATION_TYPE 注解 PACKAGE 包 TYPE_PARAMETER 类型变量的声明语句（如泛型声明） TYPE_USE 使用类型的任何语句 2 RetentionPolicy 是一个枚举类，用于枚举注解的存活阶段 枚举项 说明 SOURCE 源代码阶段有效（即.java源文件保留），会被编译器舍弃，即编译后的字节码文件不保留 CLASS（默认） 字节码阶段有效（即 .class 文件保留），运行时不会保留 RUNTIME 运行阶段有效（即运行时保留），可通过反射获取 8.6 JDK8 新特新 可重复注解 @Repeatable 类型注解","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]},{"title":"Java-语法","slug":"Java/Java-语法","date":"2020-09-29T06:29:26.000Z","updated":"2020-09-29T07:52:46.555Z","comments":true,"path":"2020/09/29/Java/Java-语法/","link":"","permalink":"https://anyeansan.github.io/2020/09/29/Java/Java-%E8%AF%AD%E6%B3%95/","excerpt":"","text":"一 前言1.1 概述 术语 缩写 说明 Java Development Kit JDK Java 开发工具包，编写 Java 程序的程序员使用的软件 Java Runtime Environment JRE Java 运行时环境，运行 Java 程序的用户使用的软件 Standard Edition SE 标准版，用于桌面或简单服务器应用的 Java 平台 Enterprise Edition EE 企业版，用于复杂服务器应用的 Java 平台 Micro Edition ME 微型版，用于小型设备的 Java 平台 Java Virtual Machine JVM Java 虚拟机，Java 程序运行在虚拟机上而非操作系统上 Oracle JDK - 官方 Java SE Open JDK - Java SE 的一个免费开源实现 Software Development Kit SDK 过时，用于描述 1998 ~ 2006 年之间的 JDK NetBeans - Oracle 公司的集成开发环境 path - 为了在任意地方使用所配置路径下的命令 classpath - 寻找 .class 文件的路径 1.2 编译 &amp; 运行1 编译1javac a/b/c/test.java 执行 javac.exe 命令所在的目录 + 输入的 .java 文件路径 = .java 文件绝对路径 .java 文件可以有多个类，但只能有零或一个 public 类且必须与文件名相同 2 运行1java 字节码文件名 必须在类的全限定名所在的路径下执行 java.exe 命令，因为 classpath 不设置时，默认在当前路径寻找 .class 文件 二 注释2.1 单行注释1// 单行注释 2.2 多行注释123/* 多行注释禁止嵌套*/ 2.3 文档注释1234567891011/*** @author 作者* @see 另请参阅* @since 从 xxx 版本开始引入* @param 参数* @return 返回值* @throws 异常*/// 生成文档javadoc -d 文件夹名称 -encoding UTF-8 -charset UTF-8 -author -version xxx.java 三 标识符3.1 定义规则 合法字符 A~Za~z 0~9 _ $ 不能以数字开头，不能使用空格 不能使用关键字和保留字，但可以包含 严格区分大小写，长度无限制 3.2 命名规范 对象 规范 包名 所有单词小写 类名, 接口名 所有单词的首字母大写 变量名, 方法名 第一个单词首字母小写，后边首字母大写 常量名 所有单词大写，单词之间使用 _ 连接 四 数据类型4.1 概述 4.2 基本数据类型1 整型 类型 大小 无符号范围 有符号范围 默认初始值 byte 1 字节 0 ~ 255 -128 ~ 127 0 short 2 字节 0 ~ 65535 -215 ~ 215-1 0 int（默认） 4 字节 0 ~ 232-1 -231 ~ 231-1 0 long 8 字节 0 ~ 264-1 -263 ~ 263-1 0L Java 都是有符号的，整形默认为 int，long 类型声明时需要加 l 或 L 长度计算公式（n 为字节数） 有符号：-28n-1~ 28n-1-1 无符号：0~28n-1 进制表示： 二进制：0b 开头 八进制：0 开头 十进制：0x 开头 数字字面量可添加下划线，为了可读性，编译器会自动去除 10_000_000 常量优化机制：Java 中整数默认为 int 型，当把整数值赋值给非 int 的整型时，JVM 会判断整数值是否超过此类型的范围 没有超过，则自动进行隐式转换，如 byte b = 127 超过，则报错，如 byte b = 128 2 浮点型 类型 大小 默认初始值 float 4 字节 0.0F double（默认） 8 字节 0.0D 浮点型默认为 double ，float 类型声明时需要加 f 或 F 浮点型常量有两种表示形式 十进制数形式，如 3.14 3.14F .314 科学计数法形式，如 3.14e2 314E2 100E-2 3 布尔型 类型 取值 默认初始值 boolean true false false 4 字符型 类型 大小 范围 默认初始值 char 2 字节 \\u0000 ~ \\uffff（ 0 ~ 65535 ） \\u0000（空） 字符型：由单引号包裹的单个字符（汉字、字母、数字、符号） &#39;&#39;：错误，不能是空单引号 &#39; &#39;：正确，空格字符 字符型三种表现形式 单引号包裹的单个字符 转义符转义的特殊字符，如 &#39;\\n&#39; Unicode 值 Java 中字符使用 Unicode 字符集，编码规则为 UTF-16 ，表示形式为 \\u0000： \\u：转义序列，表示是 Unicode 0000：字符在 Unicode 中的码点对应的十六进制数 4.3 基本数据类型转换 自动类型转换（隐式转换）：低容量类型 → 高容量类型 强制类型转换：高容量类型 → 低容量类型，可能损失精度 boolean 类型与其他基本类型不能进行类型转换 运算时，会先将两个操作数转为同一类型 byte short char 都会先转为 int int → long → float → double：碰到靠右的则先转为其类型 4.4 大数 如果基本整数和浮点数精度不满足需求，可以使用 java.math 包下的类 BigInteger：可以实现任意精度的整数运算 BigDecimal：可以实现任意精度的浮点数运算 将数值转为大数 12BigInteger.valueOf(100)new BigInteger(String num) 4.5 字符串1 概述 Java 字符串即 Unicode 字符序列，如 &quot;Java\\u5B89&quot; 由 5 个 Unicode 字符组成 J a v a 安 字符串：由双引号包裹的 0 到 多个字符 每个字符串都是 java.lang.String 的一个实例 2 字符串常量池1 概述 字符串常量池中不会存储相同内容的字符串 String pool 是一个固定大小的 Hashtable，可通过 -XX:StringTableSize 设置长度 JDK6 默认长度是 1009，设置无要求 JDK7 默认长度是 60013，设置无要求 JDK8 开始默认长度是 60013，1009 是可设置的最小长度 2 创建字符串 字面量 字符串存储在常量池中 new new String(&quot;a&quot;) 对象1：new String(&quot;a&quot;) 对象2：常量池中的 &quot;a&quot; new String(&quot;a&quot;) + new String(&quot;b&quot;) 对象1：new StringBuilder() 对象2：new String(&quot;a&quot;) 对象3：常量池中的 &quot;a&quot; 对象4：new String(&quot;b&quot;) 对象5：常量池中的 &quot;b&quot; 对象6：new String(&quot;ab&quot;) StringBuilder.toString() 的底层实际是 new 了一个字符串 注意：&quot;ab&quot; 并不会存入常量池中 String 类的 intern() 当调用的字符串在字符串常量池中已存在，则直接返回池中对象的地址引用 当调用的字符串在字符串常量池中不存在 JDK6 会复制一个新的字符串对象放入常量池中，并返回池中对象的地址引用 JDK7 及以后，会将此字符串的地址放入常量池中，并返回池中对象的地址引用 3 拼接字符串 常量和常量拼接结果在常量池，原理是编译器优化 如果拼接中出现了变量，则相当于在堆中 new String()，结果就在堆中，原理是 StringBuilder 3 java.lang.String 不可变（immutable）的字符序列 不可变性：指对字符串重新赋值，连接，替换等操作时，都不会改变原有字符串序列，就好比 3 永远是 3，”hello” 永远是 “hello” 对字符串的改变，其实是将变量指向了另一个字符串，而非改变原有字符串 123String s = &quot;hello&quot;;s = &quot;hehe&quot;;// 改变了 s 的指向，而非改变字符串 &quot;hello&quot; 不可变的优点：可以共享 String 类在JDK8 及之前内部定义了 char[] 用来存储数据，从 JDK9 开始： 字符串全为单字节字符则使用 byte[] 实现，否则使用 char[] 实现 因为字符串实际使用的大部分字符只占一个字节，使用字符数组就占用了两个字节，浪费空间 4.6 数组1 概述 数组是多个相同类型数据按一定顺序排列的集合 数组既可以存基本数据类型，也可以存引用数据类型 数组长度一旦确定，就不能修改 数组相关概念 数组名 元素 element：数组中的每个数据 索引（角标/下标）index：从 0 开始 长度 lenght：数组中元素个数称为数组的元素 数组的存储 数组会在内存中（堆）开辟一块连续的空间，数组名引用的是这块连续空间的首地址 下标表示此元素距离首地址的偏移量 2 声明数组1 一维数组123456789101112// 1 静态初始化：数组的初始化和元素赋值同时进行// 1.1int[] arr = new int[]&#123;1, 3, 5&#125;// 1.2int[] arr = &#123;1, 3, 5&#125;// 2 动态初始化：数组的初始化和元素赋值分别进行int[] arr = new int[3]arr[0] = 0;arr[1] = 0;arr[2] = 0; 2 多维数组12345678910111213141516// 1 静态初始化// 1.1int[][] arr = new int[][]&#123;&#123;2, 3, 4&#125;, &#123;3, 6&#125;, &#123;3, 4, 5, 6&#125;&#125;// 1.2int[][] arr = &#123;&#123;2, 3, 4&#125;, &#123;3, 6&#125;, &#123;3, 4, 5, 6&#125;&#125;// 2 动态初始化// 2.1 二维数组中有 3 个元素（每个元素都是一维数组），每个一维数组中有 4 个元素，这种方式一维数组元素个数都一样int[][] arr = new int[3][4]// 2.2 二维数组中有 3 个元素，没有指定一维数组中元素的个数，可以分别指定，这种方式一维数组元素个数可以不一样int[][] arr = new int[3][]arr[0] = new int[2]arr[1] = new int[3]arr[2] = new int[4] 3 数组默认值1 一维数组 元素类型 默认值 byte short int long 0 char 0 或 \\u0000，并非是 &#39;0&#39; float double 0.0 boolean false 引用类型 null 2 二维数组 int[][] arr = new int[3][4] 外层初始值为内层数组元素的地址值 内层初始值为对应类型的初始值 int[][] arr = new int[3][] 外层初始值为 null 内层还没有元素 五 运算5.1 运算符1 赋值运算符 运算符 名称 运算式 等价于 = 赋值 x = y x = y += 加赋值 x += y x = x + y -= 减赋值 x -= y x = x - y *= 乘赋值 x *= y x = x * y /= 除赋值 x /= y x = x / y %= 模赋值 x %= y x = x % y 支持连续赋值 在使用扩展赋值运算符（非 =）时，不会改变变量的数据类型，即会把结果强制转换为变量的类型 12345678910// 1 ----------------------------------short s = 3;s += 1; // 结果是 4// 等价于s = (short)(s + 1); // 2 ----------------------------------int i = 1;i *= 0.1; // 结果是 0// 等价于i = (int)(i * 0.1); 2 算术运算符 运算符 名称 运算式 + 加法 x + y - 减法 x - y * 乘法 x * y / 除法 x / y % 取模 x % y ++ 自增 x++ 或 ++x -- 自减 x-- 或 --x 自增和自减不会改变变量数据类型 负数的取模运算：只有被除数（左边的数）的负号才有影响 3 比较运算符 运算符 名称 运算式 == 等于 x == y != 不等于 x != y &gt; 大于 x &gt; y &lt; 小于 x &lt; y &gt;= 大于等于 x &gt;= y &lt;= 小于等于 x &lt;= y instanceof 是否是某类对象 obj instanceof Object 4 逻辑运算符 运算符 名称 运算式 说明 &amp; 逻辑与 expr1 &amp; expr2 有 false 则 false，且两个表达式都会计算 &amp;&amp; 短路与 expr1 &amp;&amp; expr2 有 false 则 false，且若前边表达式为 false，则不再计算后边表达式 &#124; 逻辑或 expr1 &#124; expr2 有 true 则 true，且两个表达式都会计算 &#124;&#124; 短路或 expr1 &#124;&#124; expr2 有 true 则 true，且若前边表达式为 true，则不再计算后边表达式 ! 逻辑非 !expr true 变 false，false 变 true ^ 逻辑异或 expr1 ^ expr2 相同则 false，不同则 true 5 位运算符 运算符 名称 运算式 说明 &amp; 按位与 x &amp; y 有 0 则 0 &#124; 按位或 x &#124; y 有 1 则 1 ~ 按位非 ~x 1 变 0，0 变 1 ^ 按位异或 x ^ y 相同则 0，不同则 1 &lt;&lt; 左移 x &lt;&lt; y 舍去高位，低位补0，相当于x * 2y &gt;&gt; 右移 x &gt;&gt; y 舍去低位，正数高位补 0，负数高位补 1，相当于x / 2y &gt;&gt;&gt; 无符号右移 x &gt;&gt;&gt; y 舍去低位，高位补 0，相当于x / 2y 6 三元运算符 语法 说明 条件表达式 ? exprIfTrue : exprIfFalse 最终执行的表达式必须有返回值 三元运算符编译时要求两个表达式是同一个类型 1234Object o = true ? new Integer(1) : new Double(2.0);System.out.println(o);// 结果是 1.0// 因为要求两个表达式类型一样，所以暗含一个类型提升 5.2 运算符优先级 优先级 运算符 结合性 1 () [] {} 左 → 右 2 ! +(正) -(负) ~ ++ -- 右 → 左 3 * / % 左 → 右 4 +(加) -(减) 左 → 右 5 &lt;&lt; &gt;&gt; &gt;&gt;&gt; 左 → 右 6 &lt; &lt;= &gt; &gt;= instanceof 左 → 右 7 == != 左 → 右 8 &amp; 左 → 右 9 ^ 左 → 右 10 &#124; 左 → 右 11 &amp;&amp; 左 → 右 12 &#124;&#124; 左 → 右 13 ?:(三元) 右 → 左 14 = += -= *= /= ... 右 → 左 结合性：在几个操作符具有相同的优先级时决定先执行哪一个 += 是右结合，从右到左运算，所以 a += b += c 等价于 a += (b += c) 六 语句6.1 条件语句1 if else1234567if (condition) &#123; statement;&#125; else if (condition) &#123; statement;&#125; else &#123; statement; &#125; 2 switch1234567891011switch(表达式) &#123; case 值1: code; break; case 值2: code; break; default: code; break;&#125; 表达式 基本类型（可以自动提升为 int 的） byte short char int 引用数据类型 枚举（jdk5） 字符串字面量（jdk7） case 后边必须是常量且不能相同，不能是变量 default 可以放到任意位置，但是总是最后当所有 case 都不匹配时才执行 break 如果省略，会出现 case 穿透现象，下一个 case 不再判断，直接执行 最后一个可以省略 6.2 循环语句1 for123for (初始化条件【可以有多个】; 循环条件【boolean类型】; 循环迭代条件) &#123; 循环体;&#125; 2 for each123for (variable: collection) &#123; statement;&#125; 3 while123while (condition) &#123; statement;&#125; 4 do while1234do &#123; statement;&#125;while (condition) 6.3 中断语句 语句 说明 continue 用于循环：跳出当次循环，继续下一次循环 break 用于 switch ... case：结束 switch用于循环：跳出当前循环，继续下边代码 return 任意位置：结束 cntinue 和 break 可以使用标签标记位置：label:","categories":[{"name":"CS","slug":"CS","permalink":"https://anyeansan.github.io/categories/CS/"},{"name":"Java","slug":"CS/Java","permalink":"https://anyeansan.github.io/categories/CS/Java/"}],"tags":[]}]}