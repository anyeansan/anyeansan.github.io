<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/anyeansan.github.io/images/an-apple-180.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/anyeansan.github.io/images/an-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/anyeansan.github.io/images/an-16.png">
  <link rel="mask-icon" href="/anyeansan.github.io/images/an.svg" color="#222">
  <link rel="alternate" href="/anyeansan.github.io/atom.xml" title="安₃" type="application/atom+xml">

<link rel="stylesheet" href="/anyeansan.github.io/css/main.css">


<link rel="stylesheet" href="/anyeansan.github.io/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/anyeansan.github.io/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"hide","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="一 概念1.1 同步（Synchronous）&amp;amp; 异步（Asynchronous） 同步和异步都用来形容一次方法调用 同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为 异步方法调用一旦开始，方法调用会立即返回，调用者可以继续后续操作，而异步方法通常会在另一个线程中 “真实” 的执行。异步调用的整个过程不会阻碍调用者的工作，如果异步调用需要返回结果，那么当此异步调用真正">
<meta property="og:type" content="article">
<meta property="og:title" content="Java-多线程">
<meta property="og:url" content="https:&#x2F;&#x2F;anyeansan.github.io&#x2F;2020&#x2F;09&#x2F;29&#x2F;Java&#x2F;Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B&#x2F;">
<meta property="og:site_name" content="安₃">
<meta property="og:description" content="一 概念1.1 同步（Synchronous）&amp;amp; 异步（Asynchronous） 同步和异步都用来形容一次方法调用 同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为 异步方法调用一旦开始，方法调用会立即返回，调用者可以继续后续操作，而异步方法通常会在另一个线程中 “真实” 的执行。异步调用的整个过程不会阻碍调用者的工作，如果异步调用需要返回结果，那么当此异步调用真正">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;anyeansan&#x2F;pics&#x2F;raw&#x2F;master&#x2F;CS&#x2F;Java&#x2F;%E7%BA%BF%E7%A8%8B%E4%BD%93%E7%B3%BB.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;anyeansan&#x2F;pics&#x2F;raw&#x2F;master&#x2F;CS&#x2F;Java&#x2F;%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png">
<meta property="og:image" content="https:&#x2F;&#x2F;gitee.com&#x2F;anis5&#x2F;pic&#x2F;raw&#x2F;master&#x2F;Java&#x2F;%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;anyeansan&#x2F;pics&#x2F;raw&#x2F;master&#x2F;CS&#x2F;Java&#x2F;CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;anyeansan&#x2F;pics&#x2F;raw&#x2F;master&#x2F;CS&#x2F;Java&#x2F;JMM.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;anyeansan&#x2F;pics&#x2F;raw&#x2F;master&#x2F;CS&#x2F;Java&#x2F;%E5%AF%B9%E8%B1%A1%E5%A4%B4.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;anyeansan&#x2F;pics&#x2F;raw&#x2F;master&#x2F;CS&#x2F;Java&#x2F;MarkWord32.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;anyeansan&#x2F;pics&#x2F;raw&#x2F;master&#x2F;CS&#x2F;Java&#x2F;MarkWord64.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;anyeansan&#x2F;pics&#x2F;raw&#x2F;master&#x2F;CS&#x2F;Java&#x2F;monitor.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;anyeansan&#x2F;pics&#x2F;raw&#x2F;master&#x2F;CS&#x2F;Java&#x2F;smonitor.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;anyeansan&#x2F;pics&#x2F;raw&#x2F;master&#x2F;CS&#x2F;Java&#x2F;synchronized%E9%94%81%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;anyeansan&#x2F;pics&#x2F;raw&#x2F;master&#x2F;CS&#x2F;Java&#x2F;%E9%94%81%E5%8D%87%E7%BA%A7.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;anyeansan&#x2F;pics&#x2F;raw&#x2F;master&#x2F;CS&#x2F;Java&#x2F;%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%811.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;anyeansan&#x2F;pics&#x2F;raw&#x2F;master&#x2F;CS&#x2F;Java&#x2F;%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%812.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;anyeansan&#x2F;pics&#x2F;raw&#x2F;master&#x2F;CS&#x2F;Java&#x2F;JUC-locks.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;anyeansan&#x2F;pics&#x2F;raw&#x2F;master&#x2F;CS&#x2F;Java&#x2F;CyclicBarrier.gif">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;anyeansan&#x2F;pics&#x2F;raw&#x2F;master&#x2F;CS&#x2F;Java&#x2F;JUC-executor.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;anyeansan&#x2F;pics&#x2F;raw&#x2F;master&#x2F;CS&#x2F;Java&#x2F;%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%87%E7%A8%8B01.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;anyeansan&#x2F;pics&#x2F;raw&#x2F;master&#x2F;CS&#x2F;Java&#x2F;%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%87%E7%A8%8B02.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;anyeansan&#x2F;pics&#x2F;raw&#x2F;master&#x2F;CS&#x2F;Java&#x2F;%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.png">
<meta property="og:image" content="https:&#x2F;&#x2F;github.com&#x2F;anyeansan&#x2F;pics&#x2F;raw&#x2F;master&#x2F;CS&#x2F;Java&#x2F;%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96.png">
<meta property="og:updated_time" content="2020-09-29T07:57:58.922Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;github.com&#x2F;anyeansan&#x2F;pics&#x2F;raw&#x2F;master&#x2F;CS&#x2F;Java&#x2F;%E7%BA%BF%E7%A8%8B%E4%BD%93%E7%B3%BB.png">

<link rel="canonical" href="https://anyeansan.github.io/2020/09/29/Java/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Java-多线程 | 安₃</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/anyeansan.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">安₃</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">我未成名君未嫁 可能俱是不如人</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/anyeansan.github.io/" rel="section"><i class="fa fa-fw fa-home"></i>安府</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/anyeansan.github.io/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>琅嬛福地</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/anyeansan.github.io/categories/" rel="section"><i class="fa fa-fw fa-th"></i>门派</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/anyeansan" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/09/29/Java/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java-多线程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-09-29 15:57:44 / 修改时间：15:57:58" itemprop="dateCreated datePublished" datetime="2020-09-29T15:57:44+08:00">2020-09-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="一-概念"><a href="#一-概念" class="headerlink" title="一 概念"></a>一 概念</h1><h2 id="1-1-同步（Synchronous）-amp-异步（Asynchronous）"><a href="#1-1-同步（Synchronous）-amp-异步（Asynchronous）" class="headerlink" title="1.1 同步（Synchronous）&amp; 异步（Asynchronous）"></a>1.1 同步（Synchronous）&amp; 异步（Asynchronous）</h2><ol>
<li>同步和异步都用来形容一次方法调用</li>
<li>同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为</li>
<li>异步方法调用一旦开始，方法调用会立即返回，调用者可以继续后续操作，而异步方法通常会在另一个线程中 “真实” 的执行。异步调用的整个过程不会阻碍调用者的工作，如果异步调用需要返回结果，那么当此异步调用真正完成时，会通知调用者。</li>
</ol>
<h2 id="1-2-并发（Concurrency）-amp-并行（Parallelism）"><a href="#1-2-并发（Concurrency）-amp-并行（Parallelism）" class="headerlink" title="1.2 并发（Concurrency）&amp; 并行（Parallelism）"></a>1.2 并发（Concurrency）&amp; 并行（Parallelism）</h2><ol>
<li>并发：<ul>
<li>同一时间多个任务交替执行，只是切换速度较快，看起来是同时执行而并非真正同时执行</li>
<li>同一时间应对多件事情的能力</li>
</ul>
</li>
<li>并行：<ul>
<li>同一时间多个任务真正的同时执行</li>
<li>同一时间做多件事情的能力</li>
</ul>
</li>
</ol>
<h2 id="1-3-进程（Process）-amp-线程（Thread）"><a href="#1-3-进程（Process）-amp-线程（Thread）" class="headerlink" title="1.3 进程（Process）&amp; 线程（Thread）"></a>1.3 进程（Process）&amp; 线程（Thread）</h2><ol>
<li><p>进程：</p>
<ul>
<li>正在运行的程序的实例，是系统进行资源分配的基本单位</li>
<li>进程是容纳线程的容器</li>
</ul>
</li>
<li><p>线程：</p>
<ul>
<li><p>线程是调度 CPU 的基本单位</p>
</li>
<li><p>进程中的一条执行路径，一个进程至少有一个线程</p>
</li>
<li><p>线程是程序执行的最小单位</p>
</li>
</ul>
</li>
</ol>
<h1 id="二-体系"><a href="#二-体系" class="headerlink" title="二 体系"></a>二 体系</h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E7%BA%BF%E7%A8%8B%E4%BD%93%E7%B3%BB.png" alt=""></p>
<ol>
<li><code>Runnable</code> 和 <code>Callable</code> 都可以作为线程的任务<ul>
<li><code>Runnable</code> 没有返回值，不能抛异常</li>
<li><code>Callable</code> 有返回值，能抛异常，主要用于线程池</li>
</ul>
</li>
<li><code>Future</code> 用来存储将会产生的结果</li>
<li><code>FutureTask</code> 技能存储结果也能作为任务，相当于 <code>Future + Runnable</code></li>
</ol>
<h1 id="三-Thread"><a href="#三-Thread" class="headerlink" title="三 Thread"></a>三 <code>Thread</code></h1><h2 id="3-1-创建线程"><a href="#3-1-创建线程" class="headerlink" title="3.1 创建线程"></a>3.1 创建线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 使用 Thread 自身的任务</span></span><br><span class="line">Thread()</span><br><span class="line">Thread(String name)</span><br><span class="line">Thread(ThreadGroup group, String name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 使用 Runnable 任务</span></span><br><span class="line">Thread(Runnable target)</span><br><span class="line">Thread(Runnable target, String name)</span><br><span class="line">Thread(ThreadGroup group, Runnable target)</span><br><span class="line">Thread(ThreadGroup group, Runnable target, String name)</span><br></pre></td></tr></table></figure>

<ol>
<li>若不指定线程名称，默认为  <code>Thread-0,1,2...</code></li>
<li>若不指定线程组，默认为父线程（创建此线程的线程）的线程组</li>
<li>构造函数中的 <code>statcksize</code> 代表该线程占用的栈大小，如果未指定，默认为 0，0 代表忽略该参数，该参数会被 JNI 函数去使用。（该参数有些平台有效，有些则无效）</li>
</ol>
<h2 id="3-2-启动线程"><a href="#3-2-启动线程" class="headerlink" title="3.2 启动线程"></a>3.2 启动线程</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>start()</code></td>
<td>启动线程</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>run()</code></td>
<td>子类必须重写，任务方法</td>
</tr>
<tr>
<td><code>static void</code></td>
<td>sleep(long millis)`</td>
<td>控制线程休眠若干毫秒</td>
</tr>
</tbody></table>
<h2 id="3-3-线程信息"><a href="#3-3-线程信息" class="headerlink" title="3.3 线程信息"></a>3.3 线程信息</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>getName()</code></td>
<td>获取线程名称</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setName(String name)</code></td>
<td>设置线程名字</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>getId()</code></td>
<td>获取线程 ID</td>
</tr>
<tr>
<td><code>Thread.state</code></td>
<td><code>getState()</code></td>
<td>获取线程状态</td>
</tr>
<tr>
<td><code>static Thread</code></td>
<td><code>currentThread()</code></td>
<td>获取当前线程对象</td>
</tr>
</tbody></table>
<h2 id="3-4-加入线程"><a href="#3-4-加入线程" class="headerlink" title="3.4 加入线程"></a>3.4 加入线程</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>join()</code></td>
<td>当前线程阻塞，等待插入线程执行完毕</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>join(long millis)</code></td>
<td>当前线程阻塞，等待插入线程执行完毕，但最多只等待指定时间</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>join(long millis, int nanos)</code></td>
<td>时间更精确一点</td>
</tr>
</tbody></table>
<h2 id="3-5-中断线程"><a href="#3-5-中断线程" class="headerlink" title="3.5 中断线程"></a>3.5 中断线程</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>interrupt()</code></td>
<td>1 运行线程： 设置中断标志位，不代表会退出线程<br/>2 阻塞线程（ <code>wait join sleep</code>）：终止阻塞状态并抛出 <code>InterruptedException</code> 异常，且清除中断标志位</td>
</tr>
<tr>
<td><code>static boolean</code></td>
<td><code>interrupted()</code></td>
<td>判断当前线程是否被中断，会清除中断标志位</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isInterrupted()</code></td>
<td>判断此线程是否中断，不会清除中断标志位</td>
</tr>
</tbody></table>
<ol>
<li>每个线程都有一个表示 <code>中断状态</code> 的 <code>boolean</code> 标记</li>
<li>每个线程都应该不时检查此标记，以判断线程是否被中断</li>
</ol>
<h2 id="3-6-守护线程"><a href="#3-6-守护线程" class="headerlink" title="3.6 守护线程"></a>3.6 守护线程</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>setDaemon(boolean on)</code></td>
<td>是否将线程设置为守护线程，必须在线程启动前调用</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isDaemon</code></td>
<td>判断是否是守护线程</td>
</tr>
</tbody></table>
<h2 id="3-7-礼让线程"><a href="#3-7-礼让线程" class="headerlink" title="3.7 礼让线程"></a>3.7 礼让线程</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static void</code></td>
<td><code>yield()</code></td>
<td>让出本次 CPU 执行权，加入下一次的抢夺中，效果不明显</td>
</tr>
</tbody></table>
<h2 id="3-8-线程组"><a href="#3-8-线程组" class="headerlink" title="3.8 线程组"></a>3.8 线程组</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ThreadGroup</code></td>
<td><code>getThreadGroup()</code></td>
<td>获取线程所在线程组</td>
</tr>
</tbody></table>
<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>线程组可以对一批线程进行分类管理，Java 允许程序直接对线程组进行控制</li>
<li>创建线程对象时，如果未指定线程组，则默认为父线程的线程组</li>
<li>主线程的线程组为 <code>main</code></li>
</ol>
<h3 id="2-ThreadGroup"><a href="#2-ThreadGroup" class="headerlink" title="2 ThreadGroup"></a>2 <code>ThreadGroup</code></h3><h4 id="1-构造"><a href="#1-构造" class="headerlink" title="1 构造"></a>1 构造</h4><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ThreadGroup(String name)</code></td>
<td>创建线程组并指定名称</td>
</tr>
<tr>
<td><code>ThreadGroup(ThreadGroup parent, String name)</code></td>
<td>创建线程组并指定父线程组及名称</td>
</tr>
</tbody></table>
<h4 id="2-方法"><a href="#2-方法" class="headerlink" title="2 方法"></a>2 方法</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>getName()</code></td>
<td>获取线程组名称</td>
</tr>
<tr>
<td><code>ThreadGroup</code></td>
<td><code>getParent()</code></td>
<td>获取线程组的父线程组</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>activeCount()</code></td>
<td>获取线程组中活动线程数</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>enumerate(Thread[] list)</code></td>
<td>枚举线程组中的活动线程</td>
</tr>
</tbody></table>
<h2 id="3-9-线程优先级"><a href="#3-9-线程优先级" class="headerlink" title="3.9 线程优先级"></a>3.9 线程优先级</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>getPriority()</code></td>
<td>获取线程优先级</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPriority(int newPriority)</code></td>
<td>设置线程优先级 <code>1-10</code>，仅仅是概率增加了，玄不改命</td>
</tr>
<tr>
<td></td>
<td><code>Thread.MIN_PRIORITY</code></td>
<td>最小优先级 <code>1</code></td>
</tr>
<tr>
<td></td>
<td><code>Thread.NORM_PRIORITY</code></td>
<td>默认优先级 <code>5</code></td>
</tr>
<tr>
<td></td>
<td><code>Thread.MAX_PRIORITY</code></td>
<td>最大优先级 <code>10</code></td>
</tr>
</tbody></table>
<h1 id="四-线程状态"><a href="#四-线程状态" class="headerlink" title="四 线程状态"></a>四 线程状态</h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt=""></p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>New</code></td>
<td>新建状态</td>
</tr>
<tr>
<td><code>Runnable</code></td>
<td>可运行状态：一个线程可能正在运行也可能没有运行</td>
</tr>
<tr>
<td><code>Blocked</code></td>
<td>阻塞状态</td>
</tr>
<tr>
<td><code>Waiting</code></td>
<td>无限等待</td>
</tr>
<tr>
<td><code>Timed waiting</code></td>
<td>限时等待</td>
</tr>
<tr>
<td><code>Terminated</code></td>
<td>终止状态：正常结束或异常意外终止</td>
</tr>
</tbody></table>
<h1 id="五-终止线程"><a href="#五-终止线程" class="headerlink" title="五 终止线程"></a>五 终止线程</h1><ol>
<li><p><code>stop()</code></p>
<ol>
<li>已过时</li>
<li><code>stop()</code> 方法过于暴力，会强行把执行到一半的线程终止，可能会引起一些数据不一致的问题</li>
</ol>
</li>
<li><p><code>suspend() resume()</code></p>
<ol>
<li>已过时</li>
<li>挂起和恢复线程这两个方法同样会破坏同步</li>
</ol>
</li>
<li><p>定义标记，自行决定线程何时退出</p>
</li>
<li><p><code>Two Phase Termination</code>：两阶段终止模式</p>
<p><img src="https://gitee.com/anis5/pic/raw/master/Java/%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B.png" alt=""></p>
<ol>
<li>通过中断标记实现</li>
<li><code>volatile</code> 实现</li>
</ol>
</li>
</ol>
<h1 id="六-JMM"><a href="#六-JMM" class="headerlink" title="六 JMM"></a>六 JMM</h1><h2 id="6-1-CPU-缓存"><a href="#6-1-CPU-缓存" class="headerlink" title="6.1 CPU 缓存"></a>6.1 CPU 缓存</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7.png" alt=""></p>
<ol>
<li>读写速度（离 CPU 越近，速度越快）：<code>寄存器 &gt; cache L1 &gt; cache L2 &gt; cache L3 &gt; 内存 &gt; 硬盘</code></li>
<li><code>cache line</code> 是 <code>cache</code> 的最小存储单元</li>
<li>在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，这就有了<strong>缓存一致性（CacheCoherence）</strong>问题</li>
<li>为了解决一致性的问题，有许多协议，如 MSI、<br>MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol，等等</li>
</ol>
<h3 id="2-MESI-缓存一致性协议"><a href="#2-MESI-缓存一致性协议" class="headerlink" title="2 MESI 缓存一致性协议"></a>2 <code>MESI</code> 缓存一致性协议</h3><table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>M（Modified）</code></td>
<td>该 <code>cache line</code> 有效，数据被修改了，和内存中的数据不一致，数据只存在于本 <code>Cache</code> 中</td>
</tr>
<tr>
<td><code>E（Exclusive）</code></td>
<td>该 <code>cache line</code> 有效，数据和内存中的数据一致，数据只存在于本 <code>Cache</code> 中</td>
</tr>
<tr>
<td><code>S（Shared）</code></td>
<td>该 <code>cache line</code> 有效，数据和内存中的数据一致，数据存在于多个 <code>Cache</code> 中</td>
</tr>
<tr>
<td><code>I（Invalid）</code></td>
<td>该 <code>cache line</code> 无效</td>
</tr>
</tbody></table>
<ol>
<li>内存中数据，只有一个  <code>cache</code> 中有，则为独占状态 <code>E</code></li>
<li>当不止一个 <code>cache</code> 中有时，则全为共享状态 <code>S</code></li>
<li>当某个 <code>cache</code> 修改了数据，则其变为修改状态 <code>M</code>，且其它 <code>cache</code> 变为无效状态 <code>I</code></li>
<li>多个 CPU 从主内存读取同一个数据到各自的高速缓存，当其中某个 CPU 修改了缓存里的数据，该数据会马上同步回主内存，其它 CPU 通过 <strong>总线嗅探机制</strong> （类似于事件监听）可以感知到数据的变化从而将自己缓存里的数据失效</li>
<li>底层实现通过汇编 <code>lock</code> 指令<ol>
<li>锁定这块内存区域的缓存（缓存行锁定），并立即将修改数据写回系统内存</li>
<li>这个写回内存的操作会引起在其它 CPU 里缓存了该内存地址的数据无效</li>
</ol>
</li>
</ol>
<h2 id="6-2-JMM-概述"><a href="#6-2-JMM-概述" class="headerlink" title="6.2 JMM 概述"></a>6.2 JMM 概述</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/JMM.png" alt=""></p>
<ol>
<li><p><code>Java Memory Model</code> </p>
</li>
<li><p>Java内存模型是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p>
<ul>
<li>实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享，受到内存模型控制</li>
<li>局部变量，方法参数，异常处理参数不会在线程之间共享，不受内存模型影响</li>
</ul>
</li>
<li><p>相关概念</p>
<ol>
<li><p><strong>临界区 <code>Critical Section</code></strong></p>
<ul>
<li><p>表示一种公共资源或共享数据，可以被多个线程使用，但每次只能有一个线程使用，一旦临界区资源被占用，其它线程就必须等待</p>
</li>
<li><p>一段代码内如果存在对共享数据的多线程读写操作，则这段代码称为临界区</p>
</li>
</ul>
</li>
<li><p><strong>竞态条件 <code>Race Condition</code></strong></p>
<ul>
<li>多个线程在临界区内执行，由于代码执行序列不同而导致结果无法预测，称为发生了竞态条件</li>
</ul>
</li>
<li><p>为避免临界区的竞态条件发生</p>
<ol>
<li>阻塞式解决方案：<code>synchronized, Lock</code> </li>
<li>非阻塞式解决方案：原子变量 CAS</li>
</ol>
</li>
<li><p>同步和互斥</p>
<ol>
<li>同步：是由于线程执行的顺序不同，需要一个线程等待其它线程运行到某个点</li>
<li>互斥：保证同一时刻只有一个线程执行临界区代码</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="6-3-JMM-内存交互操作（原子操作）"><a href="#6-3-JMM-内存交互操作（原子操作）" class="headerlink" title="6.3 JMM 内存交互操作（原子操作）"></a>6.3 JMM 内存交互操作（原子操作）</h2><table>
<thead>
<tr>
<th>操作</th>
<th>作用对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>read</code></td>
<td>主内存</td>
<td>从主内存读取数据到工作内存中</td>
</tr>
<tr>
<td><code>load</code></td>
<td>工作内存</td>
<td>将 <code>read</code> 读取的数据载入工作内存变量副本中</td>
</tr>
<tr>
<td><code>use</code></td>
<td>工作内存</td>
<td>从工作内存读取数据传递给执行引擎计算</td>
</tr>
<tr>
<td><code>assign</code></td>
<td>工作内存</td>
<td>将执行引擎计算好的值重新赋值给工作内存</td>
</tr>
<tr>
<td><code>store</code></td>
<td>工作内存</td>
<td>将工作内存数据传送到主内存</td>
</tr>
<tr>
<td><code>write</code></td>
<td>工作内存</td>
<td>将 <code>stroe</code> 传送的数据赋值给主内存的变量</td>
</tr>
<tr>
<td><code>lock</code></td>
<td>主内存</td>
<td>将主内存变量加锁，标记为线程独占状态</td>
</tr>
<tr>
<td><code>unlock</code></td>
<td>主内存</td>
<td>将主内存变量解锁，解锁后才可以被其他线程锁定</td>
</tr>
</tbody></table>
<h2 id="6-4-JMM-特性"><a href="#6-4-JMM-特性" class="headerlink" title="6.4 JMM 特性"></a>6.4 JMM 特性</h2><h3 id="1-原子性-Atomicity"><a href="#1-原子性-Atomicity" class="headerlink" title="1 原子性 Atomicity"></a>1 原子性 <code>Atomicity</code></h3><ol>
<li><p>原子性指一个操作是不可分割的单元，是不可中断的，要嘛都执行，要嘛都不执行</p>
</li>
<li><p>一个原子性操作一旦开始，就不会被其它线程干扰，而一个非原子性操作，在多线程环境下有可能被其它线程所干扰</p>
</li>
<li><p>从一个线程观察另外一个线程的时候，看到的都是一个个原子性的操作</p>
</li>
<li><p>例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">	a = <span class="number">1</span>;</span><br><span class="line">	b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">从一个线程观察另一个线程执行上述代码，只有两种结果</span><br><span class="line">	<span class="number">1</span> a,b 都被赋值成功</span><br><span class="line">	<span class="number">2</span> a,b 都未被赋值</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-可见性-Visibility"><a href="#2-可见性-Visibility" class="headerlink" title="2 可见性 Visibility"></a>2 可见性 <code>Visibility</code></h3><ol>
<li>可见性指当一个线程修改了某个共享变量后，其他线程是否能够立即知道这个修改</li>
<li>每个线程都有自己的工作内存，所以当线程修改完某个变量之后，在其他的线程中，未必能观察到该变量已经被修改</li>
</ol>
<h3 id="3-有序性-Ordering"><a href="#3-有序性-Ordering" class="headerlink" title="3 有序性 Ordering"></a>3 有序性 <code>Ordering</code></h3><ol>
<li>指令重排序<ol>
<li>JVM 在不影响正确性的前提下，可以调整指令的执行顺序，这种特性称之为『指令重排』，指令重排可以提高 CPU 的处理性能</li>
<li><code>as-if-serial</code> 语义：不管如何重排序，必须保证串行语义一致，即单线程下，程序的执行结果不会改变</li>
</ol>
</li>
<li>指令重排在多线程下有可能影响正确性</li>
</ol>
<h2 id="6-5-Happens-Before-规则"><a href="#6-5-Happens-Before-规则" class="headerlink" title="6.5 Happens-Before 规则"></a>6.5 <code>Happens-Before</code> 规则</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>happens-before</code> 规则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据</li>
<li>可以通过此规则分析一个并发程序是否安全</li>
<li>如果 <code>A happens-bofore B</code>，则 A 操作先于 B 操作发生，且 <code>A</code> 操作的结果对 B 可见</li>
</ol>
<h3 id="2-规则"><a href="#2-规则" class="headerlink" title="2 规则"></a>2 规则</h3><table>
<thead>
<tr>
<th>规则</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>程序顺序规则（<code>Program Order Rule</code>）</td>
<td>一个线程内保证语义的串行性，即按照代码顺序执行，前面的操作 <code>happens-before</code> 后续的任何操作</td>
</tr>
<tr>
<td>管程锁定规则（<code>Monitor Lock Rule</code>）</td>
<td>同一个锁的解锁操作 <code>happens-before</code> 后续对这个锁的加锁操作</td>
</tr>
<tr>
<td><code>volatile</code> 变量规则（<code>volatile Variable Rule</code>）</td>
<td><code>volatile</code> 变量的写操作，<code>happens-before</code> 后续对这个变量的读操作</td>
</tr>
<tr>
<td>线程启动规则（<code>Thread Start Rule</code>）</td>
<td>线程 <code>start()</code> 方法 <code>happens-before</code> 线程中的每一个操作</td>
</tr>
<tr>
<td>线程终止规则（<code>Thread Termination Rule</code>）</td>
<td>线程的所有操作 <code>happens-before</code> 线程的终结</td>
</tr>
<tr>
<td>线程中断规则（<code>Thread Interruption Rule</code>）</td>
<td>线程 <code>interrupt()</code> 方法的调用 <code>happens—before</code> 被中断线程的代码检测到中断事件的发生</td>
</tr>
<tr>
<td>对象终结规则（<code>Finalizer Rule</code>）</td>
<td>一个对象的初始化完成（构造函数执行）<code>happens—before</code> 它的 <code>finalize()</code> 方法</td>
</tr>
<tr>
<td>传递性（<code>Transitivity</code>）</td>
<td>如果 <code>A happens-before B，B happens-before C</code>，那么 <code>A happens-before C</code></td>
</tr>
</tbody></table>
<h2 id="6-6-volatile"><a href="#6-6-volatile" class="headerlink" title="6.6 volatile"></a>6.6 <code>volatile</code></h2><h3 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>volatile</code> 是Java虚拟机提供的轻量级的同步机制</li>
<li><code>volatile</code> 有两个作用：<ol>
<li>保证可见性</li>
<li>禁止指令重排序</li>
</ol>
</li>
<li><code>volatile</code> 无法保证原子性</li>
<li>内存屏障 <code>Memory Barrier</code><ol>
<li>对 <code>volatile</code> 变量的写指令后会加入写屏障 <code>storefence</code></li>
<li>对<code>volatile</code> 变量的读指令前会加入读屏障 <code>loadfence</code></li>
</ol>
</li>
</ol>
<h3 id="2-Volatile-可见性"><a href="#2-Volatile-可见性" class="headerlink" title="2 Volatile 可见性"></a>2 <code>Volatile</code> 可见性</h3><ol>
<li>硬件层面：<code>MESI</code><ul>
<li>当某个线程修改了被 <code>volatile</code> 修饰的共享变量的值，会马上同步到主内存，而开启了 CPU 总线嗅探机制的线程就会得知此修改，然后将自己工作内存中的共享变量副本失效，这样使用时就需要重新从主内存中读取</li>
</ul>
</li>
<li>JVM 层面：<code>Memory Barrier</code><ol>
<li>写屏障保证在该屏障之前的，对共享变量的改动，都同步到主内存当中</li>
<li>读屏障保证在该屏障之后，对共享变量的读取，加载的是主内存中最新数据</li>
</ol>
</li>
</ol>
<h3 id="3-Volatile-有序性"><a href="#3-Volatile-有序性" class="headerlink" title="3 Volatile 有序性"></a>3 <code>Volatile</code> 有序性</h3><ol>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li>
<li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li>
</ol>
<h2 id="6-7-synchronized"><a href="#6-7-synchronized" class="headerlink" title="6.7 synchronized"></a>6.7 <code>synchronized</code></h2><h3 id="1-概述-4"><a href="#1-概述-4" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>synchronized</code> 内置锁是一种对象锁（锁的是对象而非引用），作用粒度是对象，可以用来实现对临界资源的同步互斥访问，是可重入的</li>
<li><code>synchronized</code> 可以保证原子性和可见性，不能保证有序性，但如果共享变量完全被 <code>synchronized</code> 控制，则不会出现有序性问题</li>
</ol>
<h3 id="2-同步代码块"><a href="#2-同步代码块" class="headerlink" title="2 同步代码块"></a>2 同步代码块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(锁) &#123;</span><br><span class="line">	1. 同步代码块的锁可以是任意对象</span><br><span class="line">	2. 不要使用 String Integer Long 作为锁对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-同步函数"><a href="#3-同步函数" class="headerlink" title="3 同步函数"></a>3 同步函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 synchronized 返回值 方法名(形参列表)&#123;</span><br><span class="line">	1. 非静态同步函数的锁是 this</span><br><span class="line">	2. 静态同步函数的锁是当前类的字节码对象 类.class</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-synchronized-原理"><a href="#4-synchronized-原理" class="headerlink" title="4 synchronized 原理"></a>4 <code>synchronized</code> 原理</h3><h4 id="1-对象头"><a href="#1-对象头" class="headerlink" title="1 对象头"></a>1 对象头</h4><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" alt=""></p>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/MarkWord32.png" alt=""></p>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/MarkWord64.png" alt=""></p>
<h4 id="2-Monitor：监视器-管程"><a href="#2-Monitor：监视器-管程" class="headerlink" title="2 Monitor：监视器/管程"></a>2 <code>Monitor</code>：监视器/管程</h4><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/monitor.png" alt=""></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Owner</code></td>
<td>当一个线程获取锁，并正常执行，则将 <code>Owner</code> 指向此线程，<code>Owner</code> 只能有一个值</td>
</tr>
<tr>
<td><code>EntryList</code></td>
<td>尝试获取此锁的线程如果获取不到，会阻塞进入 <code>EntryList</code></td>
</tr>
<tr>
<td><code>WaitSet</code></td>
<td>已经获取锁但条件不满足，进入等待状态的线程会进入 <code>WaitSet</code></td>
</tr>
</tbody></table>
<h4 id="3-原理"><a href="#3-原理" class="headerlink" title="3 原理"></a>3 原理</h4><ol>
<li><p>每个 Java 对象都有一个自己的 <code>Monitor</code> 对象，当给对象上锁（重量级锁）后，该对象头的 <code>Mark Word</code> 就会指向 <code>Monitor</code></p>
</li>
<li><p><code>Monitor</code> 的实现依赖底层操作系统的 <code>Mutex lock</code>（互斥锁）实现，它是一个重量级锁性能较低</p>
</li>
<li><p><code>synchronized</code> JVM内置锁通过内部对象 <code>Monitor</code> 实现，基于进入与退出 <code>Monitor</code> 对象实现方法与代码块同步</p>
</li>
<li><p><code>synchronized</code> 关键字被编译成字节码后会被翻译成 <code>monitorenter</code> 和 <code>monitorexit</code> 两条指令分别在同步块逻辑代码的起始位置与结束位置</p>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/smonitor.png" alt=""></p>
</li>
</ol>
<h3 id="4-锁优化"><a href="#4-锁优化" class="headerlink" title="4 锁优化"></a>4 锁优化</h3><h4 id="1-锁粗化"><a href="#1-锁粗化" class="headerlink" title="1 锁粗化"></a>1 锁粗化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sb.append(<span class="number">1</span>);</span><br><span class="line">    sb.append(<span class="number">2</span>);</span><br><span class="line">    sb.append(<span class="number">3</span>);</span><br><span class="line">    sb.append(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">StringBuffer是线程安全的，append方法有sychronized修饰，那么调用了4次append方法，就相当于有了四个同步块</span></span><br><span class="line"><span class="comment">    sychronized()&#123;</span></span><br><span class="line"><span class="comment">        append(1);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    sychronized()&#123;</span></span><br><span class="line"><span class="comment">        append(2);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    sychronized()&#123;</span></span><br><span class="line"><span class="comment">        append(3);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    sychronized()&#123;</span></span><br><span class="line"><span class="comment">        append(4);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">而这是没有必要的，锁粗化相当于</span></span><br><span class="line"><span class="comment">    sychronized()&#123;</span></span><br><span class="line"><span class="comment">        append(1);</span></span><br><span class="line"><span class="comment">        append(2);</span></span><br><span class="line"><span class="comment">        append(3);</span></span><br><span class="line"><span class="comment">        append(4);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<h4 id="2-锁消除"><a href="#2-锁消除" class="headerlink" title="2 锁消除"></a>2 锁消除</h4><ul>
<li>Java虚拟机在 JIT 编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间</li>
</ul>
<h4 id="3-锁膨胀升级"><a href="#3-锁膨胀升级" class="headerlink" title="3 锁膨胀升级"></a>3 锁膨胀升级</h4><h5 id="1-概述-5"><a href="#1-概述-5" class="headerlink" title="1 概述"></a>1 概述</h5><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/synchronized%E9%94%81%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png" alt=""></p>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E9%94%81%E5%8D%87%E7%BA%A7.png" alt=""></p>
<ul>
<li>偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁</li>
<li>轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争</li>
<li>重量级锁：有实际竞争，且锁竞争时间长</li>
</ul>
<h5 id="2-偏向锁"><a href="#2-偏向锁" class="headerlink" title="2 偏向锁"></a>2 偏向锁</h5><ol>
<li>在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁（会涉及到一些 CAS 操作）的代价而引入偏向锁</li>
<li>偏向锁核心思想：如果一个线程获得了锁，那么锁就进入偏向模式，此时 <code>Mark Word</code> 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作（即获取锁的过程），这样就省去了大量有关锁申请的操作</li>
<li>偏向锁默认开启，但有延迟</li>
<li>调用了对象的 <code>hashCode</code> ，会导致偏向锁被撤销</li>
<li>如果发生了竞争，则偏向锁会失效，会膨胀为轻量级锁</li>
</ol>
<h5 id="3-轻量级锁"><a href="#3-轻量级锁" class="headerlink" title="3 轻量级锁"></a>3 轻量级锁</h5><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%811.png" alt=""></p>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%812.png" alt=""></p>
<ol>
<li>轻量级锁所适应的场景是线程交替执行同步块的场合</li>
<li>轻量级锁在没有竞争时，每次锁重入仍需要执行 <code>CAS</code> 操作</li>
<li>如果在尝试加轻量级锁的过程中，<code>CAS</code> 操作无法成功，一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），则轻量级锁会失败，轻量级锁失败后并不会立即膨胀为重量级锁，而是会先使用锁自旋的优化手段</li>
<li><strong>自旋锁</strong><ol>
<li>在大多数情况下，线程持有锁的时间都不会太长，如果当前线程获取轻量级锁失败后直接挂起，可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高</li>
<li>自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，将轻量级锁膨胀为重量级锁</li>
</ol>
</li>
</ol>
<h3 id="5-锁活跃性"><a href="#5-锁活跃性" class="headerlink" title="5 锁活跃性"></a>5 锁活跃性</h3><ol>
<li>死锁：一个线程需要同时获取多把锁，这时就容易发生死锁（例如锁嵌套）</li>
<li>活锁：两个线程互相改变对方的结束条件，导致谁也无法结束</li>
<li>饥饿：一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束</li>
</ol>
<h2 id="6-8-常见线程安全类"><a href="#6-8-常见线程安全类" class="headerlink" title="6.8 常见线程安全类"></a>6.8 常见线程安全类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String</span><br><span class="line">Integer</span><br><span class="line">StringBuffer</span><br><span class="line">Random</span><br><span class="line">Vector</span><br><span class="line">Hashtable</span><br><span class="line">java.util.concurrent.*</span><br></pre></td></tr></table></figure>

<ol>
<li>线程安全指的是多个线程调用这些类的同一实例的同一方法是线程安全的</li>
<li>它们每个方法是原子的，但多个方法的组合不是原子的</li>
</ol>
<h1 id="七-等待唤醒机制"><a href="#七-等待唤醒机制" class="headerlink" title="七 等待唤醒机制"></a>七 等待唤醒机制</h1><h2 id="7-1-wait-notify"><a href="#7-1-wait-notify" class="headerlink" title="7.1 wait/notify"></a>7.1 <code>wait/notify</code></h2><h3 id="1-概述-6"><a href="#1-概述-6" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>只有重量级锁才有等待唤醒方法<ol>
<li><code>wait()</code>：相当于 <code>wait(0)</code>，无限等待直到被唤醒</li>
<li><code>wait(long timeout)</code>：等待指定时间或被唤醒</li>
<li><code>notify()</code></li>
<li><code>notifyAll()</code></li>
</ol>
</li>
<li>获取锁之后才能调用等待唤醒方法，即等待唤醒的方法要在同步代码中执行，且需要同一个锁对象来调用</li>
<li>等待时释放锁，进入 <code>Monitor</code> 的 <code>WaitSet</code>，唤醒之后不会立即获取锁，而是进入 <code>Monitor</code> 的 <code>EntrySet</code> 重新竞争</li>
</ol>
<h3 id="2-wait-amp-sleep"><a href="#2-wait-amp-sleep" class="headerlink" title="2 wait &amp; sleep"></a>2 <code>wait</code> &amp; <code>sleep</code></h3><table>
<thead>
<tr>
<th>方法</th>
<th>所属</th>
<th>参数</th>
<th>锁</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td><code>wait()</code></td>
<td><code>Object</code></td>
<td>无参：无限等待<br/>有参：有限等待</td>
<td>释放锁</td>
<td>必须先获取锁，在同步代码中使用</td>
</tr>
<tr>
<td><code>sleep()</code></td>
<td><code>Thread</code></td>
<td>有参：有限睡眠</td>
<td>不释放锁</td>
<td>可直接使用</td>
</tr>
</tbody></table>
<h3 id="3-模式"><a href="#3-模式" class="headerlink" title="3 模式"></a>3 模式</h3><ol>
<li>同步模式之保护性暂停 <ol>
<li><code>Guarded Suspension</code>：用在一个线程等待另一个线程的执行结果</li>
<li>结果需要从一个线程传递到另一个线程，让他们关联同一个 <code>GuardedObject</code></li>
<li>产生结果的线程与消费结果的线程需要一一对应</li>
<li>JDK 中，<code>join</code> 的实现、<code>Future</code> 的实现，采用的就是此模式</li>
</ol>
</li>
<li>异步模式之生产者/消费者<ol>
<li>产生结果的线程与消费结果的线程不需要一一对应</li>
<li>JDK 中各种阻塞队列，采用的就是这种模式</li>
</ol>
</li>
</ol>
<h2 id="7-2-park-unpark"><a href="#7-2-park-unpark" class="headerlink" title="7.2 park/unpark"></a>7.2 <code>park/unpark</code></h2><h3 id="1-与-wait-amp-notify-相比"><a href="#1-与-wait-amp-notify-相比" class="headerlink" title="1 与 wait &amp; notify 相比"></a>1 与 <code>wait &amp; notify</code> 相比</h3><ol>
<li><code>wait &amp; notify</code> 必须配合 <code>Object Monitor</code> 使用，<code>park &amp; unpark</code> 则不必</li>
<li><code>wait &amp; notify</code> 只能随机唤醒等待线程，<code>park &amp; unpark</code> 是以线程为单位来等待唤醒的，所以精确</li>
<li><code>wait &amp; notify</code> 不能先 <code>notify</code>，<code>park &amp; unpark</code> 可以先 <code>unpark</code>，即先 <code>unpark</code> 也能恢复 <code>park</code> 的线程</li>
</ol>
<h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2 原理"></a>2 原理</h3><ol>
<li>每个线程都有自己的一个 <code>Parker</code> 对象，由三部分组成<ul>
<li><code>_counter</code></li>
<li><code>_cond</code></li>
<li><code>_mutex</code></li>
</ul>
</li>
<li><code>park()</code><ol>
<li>判断 <code>_counter</code><ul>
<li><code>_counter == 0</code> 则等待</li>
<li><code>_counter == 1</code> 则继续运行</li>
</ul>
</li>
<li>将 <code>_counter</code> 设置为 <code>0</code></li>
</ol>
</li>
<li><code>unpark()</code><ol>
<li>将 <code>_counter</code> 设置为 <code>1</code></li>
<li>判断线程状态<ol>
<li>如果线程正在等待，则唤醒线程</li>
<li>如果线程正在运行，则继续运行，且由于 <code>_counter</code> 设置为了 <code>1</code> ，线程下次调用 <code>park()</code> 时，会继续执行</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="八-CAS"><a href="#八-CAS" class="headerlink" title="八 CAS"></a>八 <code>CAS</code></h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><ol>
<li><code>Compare And Swap</code> 或 <code>Compare And Set</code></li>
<li>CAS 是一种无锁算法，体现的是无锁并发、无阻塞并发</li>
<li>CAS 必须借助 <code>volatile</code> ，因为需要保证可见性来读取最新值</li>
<li>内部通过 <code>Unsafe</code> 实现，<code>Unsafe</code> 直接操作虚拟机内存，类似 <code>C C++</code> 的指针</li>
<li><code>ABA</code> 问题：<code>version</code></li>
</ol>
<h2 id="8-2-原理"><a href="#8-2-原理" class="headerlink" title="8.2 原理"></a>8.2 原理</h2><ol>
<li>CAS 包含三个操作数：<ul>
<li>内存值 <code>V</code></li>
<li>预估值 <code>A</code></li>
<li>更新值 <code>B</code></li>
</ul>
</li>
<li>第一次读取内存值记录为 <code>A</code>，之后进行一些操作</li>
<li>当真正写入数据时，再次读取内存值 <code>V</code>，当且仅当 <code>V == A</code> 时，才会更新 <code>V = B</code></li>
</ol>
<h1 id="九-java-util-concurrent-atomic"><a href="#九-java-util-concurrent-atomic" class="headerlink" title="九 java.util.concurrent.atomic"></a>九 <code>java.util.concurrent.atomic</code></h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td>基本类型原子类</td>
<td><code>AtomicInteger</code><br><code>AtomicBoolean</code><br><code>AtomicLong</code></td>
</tr>
<tr>
<td>引用类型原子类</td>
<td><code>AtomicReference&lt;V&gt;</code><br><code>AtomicStampedReference&lt;V&gt;</code><br><code>AtomicMarkableReference&lt;V&gt;</code></td>
</tr>
<tr>
<td>数组类型原子类</td>
<td><code>AtomicIntegerArray</code><br/><code>AtomicLongArray</code><br/><code>AtomicReferenceArray&lt;E&gt;</code></td>
</tr>
<tr>
<td>原子字段更新器</td>
<td><code>AtomicIntegerFieldUpdater&lt;T&gt;</code><br/><code>AtomicLongFieldUpdater&lt;T&gt;</code><br/><code>AtomicReferenceFieldUpdater&lt;T, V&gt;</code></td>
</tr>
<tr>
<td>原子累加器</td>
<td><code>LongAdder</code><br/><code>DoubleAdder</code><br/><code>LongAccumulator</code><br><code>DoubleAccumulator</code></td>
</tr>
</tbody></table>
<ol>
<li><code>AtomicReference&lt;V&gt;</code><ul>
<li>只关心当前值和预期值是否相等，不知道值是否被修改过（ABA问题），如 <code>A → B → C → A</code></li>
</ul>
</li>
<li><code>AtomicStampedReference&lt;V&gt;</code><ul>
<li>增加一个版本号属性，每次修改都使版本号 + 1，可以知道值被修改过几次</li>
</ul>
</li>
<li><code>AtomicMarkableReference&lt;V&gt;</code><ul>
<li>增加要给布尔属性，判断值是否被修改过</li>
</ul>
</li>
</ol>
<h2 id="9-2-AtomicInteger"><a href="#9-2-AtomicInteger" class="headerlink" title="9.2 AtomicInteger"></a>9.2 <code>AtomicInteger</code></h2><h3 id="1-构造-1"><a href="#1-构造-1" class="headerlink" title="1 构造"></a>1 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>AtomicInteger()</code></td>
<td>使用默认值 <code>0</code></td>
</tr>
<tr>
<td><code>AtomicInteger(int initialValue)</code></td>
<td>使用指定值</td>
</tr>
</tbody></table>
<h3 id="2-方法-1"><a href="#2-方法-1" class="headerlink" title="2 方法"></a>2 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>get()</code></td>
<td>获取当前值</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>compareAndSet(int expectedValue, int newValue)</code></td>
<td>如果当前值与预期值相等，则将当前值设置为新值并返回 <code>true</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getAndIncrement()</code></td>
<td><code>i++</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>incrementAndGet()</code></td>
<td><code>++i</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getAndDecrement()</code></td>
<td><code>i--</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>decrementAndGet()</code></td>
<td><code>--i</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getAndAdd(int delta)</code></td>
<td>返回原值，之后将值加上指定值</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>addAndGet(int delta)</code></td>
<td>将值加上指定值并返回</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getAndUpdate(IntUnaryOperator updateFunction)</code></td>
<td>获取原值并计算</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>updateAndGet(IntUnaryOperator updateFunction)</code></td>
<td>计算并返回</td>
</tr>
</tbody></table>
<h1 id="十-java-util-concurrent-locks"><a href="#十-java-util-concurrent-locks" class="headerlink" title="十 java.util.concurrent.locks"></a>十 <code>java.util.concurrent.locks</code></h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/JUC-locks.png" alt=""></p>
<h2 id="10-1-Lock"><a href="#10-1-Lock" class="headerlink" title="10.1 Lock"></a>10.1 <code>Lock</code></h2><h3 id="1-API"><a href="#1-API" class="headerlink" title="1 API"></a>1 API</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>lock()</code></td>
<td>获取锁</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>unlock()</code></td>
<td>释放锁</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>tryLock()</code></td>
<td>尝试获取锁</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>tryLock(long time, TimeUnit unit)</code></td>
<td>尝试获取锁，会尝试指定时间</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>lockInterruptibly()</code></td>
<td>功能同 <code>locak</code>，如果线程被中断会抛出异常</td>
</tr>
<tr>
<td><code>Condition</code></td>
<td><code>newCondition()</code></td>
<td>创建一个该锁的 <code>Condition</code> 对象</td>
</tr>
</tbody></table>
<h3 id="2-典型使用"><a href="#2-典型使用" class="headerlink" title="2 典型使用"></a>2 典型使用</h3><h4 id="1-lock"><a href="#1-lock" class="headerlink" title="1 lock()"></a>1 <code>lock()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock l = ...;</span><br><span class="line">l.lock(); <span class="comment">// 获取锁后要紧跟 try</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// access the resource protected by this lock</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  l.unlock(); <span class="comment">// 释放锁要在 finally 的第一行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-tryLock"><a href="#2-tryLock" class="headerlink" title="2 tryLock()"></a>2 <code>tryLock()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line"><span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// manipulate protected state</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// perform alternative actions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-ReentrantLock"><a href="#3-ReentrantLock" class="headerlink" title="3 ReentrantLock"></a>3 <code>ReentrantLock</code></h3><h4 id="1-构造-2"><a href="#1-构造-2" class="headerlink" title="1 构造"></a>1 构造</h4><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ReentrantLock()</code></td>
<td>默认为非公平锁</td>
</tr>
<tr>
<td><code>ReentrantLock(boolean fair)</code></td>
<td>可创建公平锁（但没有必要，会降低并发度）</td>
</tr>
</tbody></table>
<h4 id="2-与-synchronized-比较"><a href="#2-与-synchronized-比较" class="headerlink" title="2 与 synchronized 比较"></a>2 与 <code>synchronized</code> 比较</h4><ol>
<li>在 <code>synchronized</code> 未优化之前，皆为重量级锁，所以才引入 <code>ReentrantLock</code>，<code>ReentrantLock</code> 提供了更丰富的 API</li>
<li><code>synchronized</code> 和 <code>ReetrantLock</code> 都是可重入锁</li>
<li><code>synchronized</code> 获取不到锁会一直阻塞；<code>ReentrantLock</code> 获取不到锁可以被中断或超时</li>
<li><code>ReetrantLock</code> 可设置公平锁</li>
<li><code>synchronized</code>只有一个条件，不满足时进入 <code>WaitSet</code> 等待；<code>ReetrantLock</code> 一个锁可以对应多个 <code>Condition</code></li>
</ol>
<h2 id="10-2-Condition"><a href="#10-2-Condition" class="headerlink" title="10.2 Condition"></a>10.2 <code>Condition</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>await()</code></td>
<td>当前线程等待，直到被打断或被唤醒</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>await(long time, TimeUnit unit)</code></td>
<td>当前线程等待，直到被打断或被唤醒或超时</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>awaitNanos(long nanosTimeout)</code></td>
<td>当前线程等待，直到被打断或被唤醒或超时</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>awaitUninterruptibly()</code></td>
<td>当前线程等待，直到被唤醒</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>signal()</code></td>
<td>唤醒一个等待线程</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>signalAll()</code></td>
<td>唤醒所有等待线程</td>
</tr>
</tbody></table>
<h2 id="10-3-ReadWriteLock"><a href="#10-3-ReadWriteLock" class="headerlink" title="10.3 ReadWriteLock"></a>10.3 <code>ReadWriteLock</code></h2><h3 id="1-概述-7"><a href="#1-概述-7" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>读写锁，将锁更细粒度的划分：<ul>
<li>共享锁（读）</li>
<li>排他锁（写）</li>
</ul>
</li>
<li>读锁可以被多个线程共享（当读操作多时，多个读线程可以并发执行，提高效率），写锁则只能一个线程独占</li>
<li><code>ReentrantReadWriteLock</code>：唯一实现类</li>
<li><code>StampedLock</code>：能力更强的读写锁</li>
</ol>
<h3 id="2-API"><a href="#2-API" class="headerlink" title="2 API"></a>2 API</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Lock</code></td>
<td><code>readLock()</code></td>
<td>获取读锁</td>
</tr>
<tr>
<td><code>Lock</code></td>
<td><code>writeLock()</code></td>
<td>获取写锁</td>
</tr>
</tbody></table>
<h2 id="10-4-LockSupport"><a href="#10-4-LockSupport" class="headerlink" title="10.4 LockSupport"></a>10.4 <code>LockSupport</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Object</code></td>
<td><code>getBlocker(Thread t)</code></td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>park()</code></td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>park(Object blocker)</code></td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>parkNanos(long nanos)</code></td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>parkNanos(Object blocker, long nanos)</code></td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>parkUntil(long deadline)</code></td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>parkUntil(Object blocker, long deadline)</code></td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>unpark(Thread thread)</code></td>
</tr>
</tbody></table>
<h1 id="十一-辅助工具类"><a href="#十一-辅助工具类" class="headerlink" title="十一 辅助工具类"></a>十一 辅助工具类</h1><h2 id="11-1-Semaphore"><a href="#11-1-Semaphore" class="headerlink" title="11.1 Semaphore"></a>11.1 <code>Semaphore</code></h2><h3 id="1-概述-8"><a href="#1-概述-8" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>Semaphore</code> 是一个计数信号量，必须由获取它的线程释放</li>
<li>用来控制同时访问资源的线程数量（限流）</li>
</ol>
<h3 id="2-构造"><a href="#2-构造" class="headerlink" title="2 构造"></a>2 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Semaphore(int permits)</code></td>
<td>创建具有给定许可数的计数信号量，默认为非公平信号量</td>
</tr>
<tr>
<td><code>Semaphore(int permits, boolean fair)</code></td>
<td>创建具有给定许可数的计数信号量，可设置为公平信号量</td>
</tr>
</tbody></table>
<h3 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>acquire()</code></td>
<td>从信号量中获取一个许可，在提供一个可用许可之前一直等待</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>acquire(int permits)</code></td>
<td>从信号量中获取指定数量的许可</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>release()</code></td>
<td>释放一个许可，将其返回给信号量</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>release(int permits)</code></td>
<td>释放指定数量的许可，将其返回给信号量</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>availablePermits()</code></td>
<td>获取当前可用的许可个数</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>hasQueuedThreads()</code></td>
<td>是否有线程在等待获取许可</td>
</tr>
<tr>
<td>`int</td>
<td><code>getQueueLength()</code></td>
<td>获取正在等待获取许可的线程数</td>
</tr>
<tr>
<td><code>protected Collection&lt;Thread&gt;</code></td>
<td><code>getQueuedThreads()</code></td>
<td>获取所有等待获取许可的线程集合</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>drainPermits()</code></td>
<td>获取可用许可个数，并将可用许可置为 0</td>
</tr>
</tbody></table>
<h2 id="11-2-CountDownLatch"><a href="#11-2-CountDownLatch" class="headerlink" title="11.2 CountDownLatch"></a>11.2 <code>CountDownLatch</code></h2><h3 id="1-概述-9"><a href="#1-概述-9" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>用来进行线程同步写作，等待所有线程完成倒计时</li>
<li>允许一个或多个线程等待其他线程完成操作</li>
</ol>
<h3 id="2-构造-1"><a href="#2-构造-1" class="headerlink" title="2 构造"></a>2 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>CountDownLatch(int count)</code></td>
<td>构造时传入一个计数</td>
</tr>
</tbody></table>
<h3 id="3-方法-1"><a href="#3-方法-1" class="headerlink" title="3 方法"></a>3 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>countDown()</code></td>
<td>计数减 <code>1</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>await()</code></td>
<td>当前线程等待，当计数归 <code>0</code>，当前线程继续执行</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>await(long timeout, TimeUnit unit)</code></td>
<td>当前线程等待，当计数归 <code>0</code> 或者超时，当前线程继续执行</td>
</tr>
</tbody></table>
<h2 id="11-3-CyclicBarrier"><a href="#11-3-CyclicBarrier" class="headerlink" title="11.3 CyclicBarrier"></a>11.3 <code>CyclicBarrier</code></h2><h3 id="1-概述-10"><a href="#1-概述-10" class="headerlink" title="1 概述"></a>1 概述</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/CyclicBarrier.gif" alt=""></p>
<ol>
<li>循环栅栏，用来进行线程协作，等待线程满足某个计数</li>
<li>阻塞一组线程直到某个事件的发生</li>
<li><code>CountDownLatch</code> 只能拦截一轮，<code>CyclicBarrier</code> 可以实现循环拦截</li>
<li>构造时设置计数，每个线程执行到某个需要同步的时刻则等待，当等待的线程数满足计数时，继续执行</li>
</ol>
<h3 id="2-构造-2"><a href="#2-构造-2" class="headerlink" title="2 构造"></a>2 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>CyclicBarrier(int parties)</code></td>
<td>构造时传入一个计数，表示需要等待的线程数</td>
</tr>
<tr>
<td><code>CyclicBarrier(int parties, Runnable barrierAction)</code></td>
<td><code>barrierAction</code>：等待线程数达到时首先执行的任务</td>
</tr>
</tbody></table>
<h3 id="3-方法-2"><a href="#3-方法-2" class="headerlink" title="3 方法"></a>3 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>await()</code></td>
<td>当前线程等待，直到等待线程数达到初始计数</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>await(long timeout, TimeUnit unit)</code></td>
<td>当前线程等待，直到等待线程数达到初始计数或超时</td>
</tr>
</tbody></table>
<h1 id="十二-线程池"><a href="#十二-线程池" class="headerlink" title="十二 线程池"></a>十二 线程池</h1><h2 id="12-1-线程池体系"><a href="#12-1-线程池体系" class="headerlink" title="12.1 线程池体系"></a>12.1 线程池体系</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/JUC-executor.png" alt=""></p>
<h2 id="12-2-线程池执行过程"><a href="#12-2-线程池执行过程" class="headerlink" title="12.2 线程池执行过程"></a>12.2 线程池执行过程</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%87%E7%A8%8B01.png" alt=""></p>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%87%E7%A8%8B02.png" alt=""></p>
<h2 id="12-3-线程池状态"><a href="#12-3-线程池状态" class="headerlink" title="12.3 线程池状态"></a>12.3 线程池状态</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.png" alt=""></p>
<table>
<thead>
<tr>
<th>状态</th>
<th>高 3 位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Running</code></td>
<td><code>111</code></td>
<td>接收新任务，能处理已添加任务</td>
</tr>
<tr>
<td><code>Shutdown</code></td>
<td><code>000</code></td>
<td>不接收新任务，能处理已添加任务</td>
</tr>
<tr>
<td><code>Stop</code></td>
<td><code>001</code></td>
<td>不接收新任务，不处理已添加任务，且中断正在处理的任务</td>
</tr>
<tr>
<td><code>Tidying</code></td>
<td><code>010</code></td>
<td>所有任务已终止，<code>ctl</code> 记录的活动线程为 0，即将进入终结</td>
</tr>
<tr>
<td><code>Terminated</code></td>
<td><code>011</code></td>
<td>线程池彻底终止</td>
</tr>
</tbody></table>
<ol start="2">
<li>线程池的运行状态和活动线程数信息存储在一个原子变量 <code>AtomicInteger ctl</code> 中，目的是将线程池状态和线程个数合二为一，这样就可以用一次 <code>CAS</code> 原子操作进行赋值</li>
<li><code>ctl</code> 高 3 位表示线程池状态，低 29 位表示线程池数量</li>
</ol>
<h2 id="12-4-线程池数量"><a href="#12-4-线程池数量" class="headerlink" title="12.4 线程池数量"></a>12.4 线程池数量</h2><ol>
<li><code>N<sub>threds</sub> = N<sub>CPU</sub> * U<sub>CPU</sub> * (1 + W/C)</code><ul>
<li><code>N<sub>CPU</sub></code> ：CPU 的核数</li>
<li><code>U<sub>CPU</sub></code> ：CPU 期望利用率 <code>(0, 1]</code></li>
<li><code>W/C</code> ：等待时间和计算时间比率</li>
</ul>
</li>
<li>CPU 密集型运算：<code>线程数 = CPU核数 + 1</code></li>
<li>I/O 密集型运算：<code>线程数 = CPU核数 * 期望CPU利用率 *（CPU计算时间 + 等待时间）/ CPU计算时间</code></li>
</ol>
<h2 id="12-5-ThreadPoolExecutor"><a href="#12-5-ThreadPoolExecutor" class="headerlink" title="12.5 ThreadPoolExecutor"></a>12.5 <code>ThreadPoolExecutor</code></h2><h3 id="1-构造-3"><a href="#1-构造-3" class="headerlink" title="1 构造"></a>1 构造</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, </span><br><span class="line">                    <span class="keyword">int</span> maximumPoolSize, </span><br><span class="line">                    <span class="keyword">long</span> keepAliveTime, </span><br><span class="line">                    TimeUnit unit, </span><br><span class="line">                    BlockingQueue&lt;Runnable&gt; workQueue, </span><br><span class="line">                    ThreadFactory threadFactory, </span><br><span class="line">                    RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int corePoolSize</code></td>
<td>核心线程数</td>
</tr>
<tr>
<td><code>int maximumPoolSize</code></td>
<td>最大线程数</td>
</tr>
<tr>
<td><code>long keepAliveTime</code></td>
<td>线程最大空闲时间，如果线程池中线程数量超过 <code>corePoolSize</code>，超出线程空闲时间超过 <code>keepAliveTime</code> 会被终止</td>
</tr>
<tr>
<td><code>TimeUnit unit</code></td>
<td>空闲时间单位</td>
</tr>
<tr>
<td><code>BlockingQueue&lt;Runnable&gt; workQueue</code></td>
<td>任务阻塞队列</td>
</tr>
<tr>
<td><code>ThreadFactory threadFactory</code></td>
<td>线程工厂</td>
</tr>
<tr>
<td><code>RejectedExecutionHandler handler</code></td>
<td>拒绝策略</td>
</tr>
</tbody></table>
<h4 id="1-Enum-TimeUnit"><a href="#1-Enum-TimeUnit" class="headerlink" title="1 Enum TimeUnit"></a>1 <code>Enum TimeUnit</code></h4><h5 id="1-枚举项：时间粒度"><a href="#1-枚举项：时间粒度" class="headerlink" title="1 枚举项：时间粒度"></a>1 枚举项：时间粒度</h5><table>
<thead>
<tr>
<th>粒度</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>NANOSECONDS</code></td>
<td>纳秒 <code>ns</code></td>
<td><code>1 s  = 10<sup>9</sup> ns</code></td>
</tr>
<tr>
<td><code>MICROSECONDS</code></td>
<td>微秒 <code>μs</code></td>
<td><code>1 s  = 10<sup>6</sup> μs</code></td>
</tr>
<tr>
<td><code>MILLISECONDS</code></td>
<td>毫秒 <code>ms</code></td>
<td><code>1 s  = 10<sup>3</sup> ms</code></td>
</tr>
<tr>
<td><code>SECONDS</code></td>
<td>秒 <code>s</code></td>
<td></td>
</tr>
<tr>
<td><code>MINUTES</code></td>
<td>分 <code>min</code></td>
<td></td>
</tr>
<tr>
<td><code>HOURS</code></td>
<td>时 <code>h</code></td>
<td></td>
</tr>
<tr>
<td><code>DAYS</code></td>
<td>日 <code>d</code></td>
<td></td>
</tr>
</tbody></table>
<h5 id="2-方法：线程"><a href="#2-方法：线程" class="headerlink" title="2 方法：线程"></a>2 方法：线程</h5><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>sleep(long timeout)</code></td>
<td>当前线程睡眠当前粒度的 <code>timout</code>，替代 <code>Thread.sleep(timeout)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>timedJoin(Thread thread, long timeout)</code></td>
<td>指定线程 <code>join</code> 当前粒度的 <code>timeout</code>，替代 <code>t.join(timout)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>timedWait(Object obj, long timeout)</code></td>
<td>锁对象 <code>obj</code> 等待当前粒度的 <code>timout</code>，替代 <code>obj.wait(timout)</code></td>
</tr>
</tbody></table>
<h5 id="3-方法：时间粒度转换"><a href="#3-方法：时间粒度转换" class="headerlink" title="3 方法：时间粒度转换"></a>3 方法：时间粒度转换</h5><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>long</code></td>
<td><code>convert(Duration duration)</code></td>
<td>将指定时间间隔 <code>duration</code> 转换为当前粒度</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>convert(long sourceDuration, TimeUnit sourceUnit)</code></td>
<td>将指定数值 <code>sourceDuration</code> 的指定粒度 <code>sourceUnit</code> 转换为当前粒度</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toNanos(long duration)</code></td>
<td>将指定数值 <code>duration</code> 的当前粒度转换为纳秒</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toMicros(long duration)</code></td>
<td>将指定数值 <code>duration</code> 的当前粒度转换为微秒</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toMillis(long duration)</code></td>
<td>将指定数值 <code>duration</code> 的当前粒度转换为毫秒</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toSeconds(long duration)</code></td>
<td>将指定数值 <code>duration</code> 的当前粒度转换为秒</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toMinutes(long duration)</code></td>
<td>将指定数值 <code>duration</code> 的当前粒度转换为分</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toHours(long duration)</code></td>
<td>将指定数值 <code>duration</code> 的当前粒度转换为时</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toDays(long duration)</code></td>
<td>将指定数值 <code>duration</code> 的当前粒度转换为日</td>
</tr>
</tbody></table>
<h4 id="2-ThreadFactory"><a href="#2-ThreadFactory" class="headerlink" title="2 ThreadFactory"></a>2 <code>ThreadFactory</code></h4><ol>
<li>默认使用 <code>Executors.defaultThreadFactory()</code></li>
<li>自定义线程工厂实现此接口</li>
<li>使用不同的工厂，可以更改线程名称，线程组，优先级，守护线程状态等等</li>
</ol>
<h4 id="3-RejectedExecutionHandler"><a href="#3-RejectedExecutionHandler" class="headerlink" title="3 RejectedExecutionHandler"></a>3 <code>RejectedExecutionHandler</code></h4><table>
<thead>
<tr>
<th>内置拒绝策略</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>AbortPolicy</code>（默认）</td>
<td>放弃本次任务，抛 <code>RejectedExecutionException</code> 异常</td>
</tr>
<tr>
<td><code>DiscardPolicy</code></td>
<td>放弃本次任务</td>
</tr>
<tr>
<td><code>DiscardOldestPolicy</code></td>
<td>放弃队列中最早的任务，本次任务取而代之</td>
</tr>
<tr>
<td><code>CallerRunsPolicy</code></td>
<td>让调用者处理任务</td>
</tr>
</tbody></table>
<ul>
<li>自定义拒绝策略实现此接口<ol>
<li><code>Dubbo</code> 的实现：抛 异常之前会记录日志，并 <code>dump</code> 线程栈信息，方便定位</li>
<li><code>Netty</code> 的实现：创建一个新线程来执行任务</li>
<li><code>ActiveMQ</code> 的实现：带超时等待（60s）尝试放入队列</li>
<li><code>PinPoint</code> 的实现：使用了一个拒绝策略链，会逐一尝试</li>
</ol>
</li>
</ul>
<h3 id="2-方法-2"><a href="#2-方法-2" class="headerlink" title="2 方法"></a>2 方法</h3><h4 id="1-提交任务"><a href="#1-提交任务" class="headerlink" title="1 提交任务"></a>1 提交任务</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>`void</td>
<td><code>execute(Runnable command)</code></td>
<td>执行任务 <code>Runnable</code> 任务</td>
</tr>
<tr>
<td><code>&lt;T&gt; Future&lt;T&gt;</code></td>
<td><code>submit(Callable&lt;T&gt; task)</code></td>
<td>提交 <code>Callable</code> 任务，使用 <code>Future</code> 获取任务执行结果</td>
</tr>
<tr>
<td><code>Future&lt;?&gt;</code></td>
<td><code>submit(Runnable task)</code></td>
<td>提交 <code>Runnbale</code> 任务，使用 <code>Future</code> 获取任务执行结果</td>
</tr>
<tr>
<td>`<T> Future<T></td>
<td><code>submit(Runnable task, T result)</code></td>
<td>提交带返回值的 <code>Runnbale</code> 任务，使用 <code>Future</code> 获取任务执行结果</td>
</tr>
<tr>
<td><code>&lt;T&gt; List&lt;Future&lt;T&gt;&gt;</code></td>
<td><code>invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</code></td>
<td>提交多个任务</td>
</tr>
<tr>
<td><code>&lt;T&gt; List&lt;Future&lt;T&gt;&gt;</code></td>
<td><code>invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)</code></td>
<td>提交多个任务，带超时时间</td>
</tr>
<tr>
<td><code>&lt;T&gt; T</code></td>
<td><code>invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</code></td>
<td>提交多个任务，哪个任务先成功执行完毕则返回其结果，其它任务取消</td>
</tr>
<tr>
<td><code>&lt;T&gt; T</code></td>
<td><code>invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)</code></td>
<td>提交多个任务，哪个任务先成功执行完毕则返回其结果，其它任务取消，带超时时间</td>
</tr>
</tbody></table>
<h4 id="2-关闭线程池"><a href="#2-关闭线程池" class="headerlink" title="2 关闭线程池"></a>2 关闭线程池</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>shutdown()</code></td>
<td>线程池状态变为 <code>Shutdown</code>，不再接收新任务，已提交任务会被执行完，此方法不会阻塞调用线程的执行</td>
</tr>
<tr>
<td><code>List&lt;Runnable&gt;</code></td>
<td><code>shutdownNow()</code></td>
<td>线程池状态变为 <code>Stop</code>，不再接收新任务，用 <code>interrupt()</code> 中断正在执行的任务，返回队列中等待执行的任务</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isShutdown()</code></td>
<td>测试线程池是否关闭，线程池状态不为 <code>Running</code>，都会返回 <code>true</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isTerminated()</code></td>
<td>测试是否所有任务都执行完毕了，线程池状态为 <code>Terminated</code>，返回 <code>true</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>awaitTermination(long timeout, TimeUnit unit)</code></td>
<td>由于调用 <code>shutdown</code> 后，调用线程并不会等待所有任务执行完毕，可以使用此方法等待线程池状态变为 <code>Terminated</code></td>
</tr>
</tbody></table>
<h2 id="12-6-Executors"><a href="#12-6-Executors" class="headerlink" title="12.6 Executors"></a>12.6 <code>Executors</code></h2><h3 id="1-固定大小线程池"><a href="#1-固定大小线程池" class="headerlink" title="1 固定大小线程池"></a>1 固定大小线程池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">	return new ThreadPoolExecutor(nThreads, nThreads, </span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS, </span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>核心线程数 = 最大线程数，即不会有救急线程被创建，也就没有超时时间</li>
<li>阻塞队列 <code>LinkedBlockingQueue</code> 最大为 <code>Integer.MAX_VALUE</code></li>
<li>适合任务量已知，相对耗时的任务</li>
</ol>
<h3 id="2-带缓冲线程池"><a href="#2-带缓冲线程池" class="headerlink" title="2 带缓冲线程池"></a>2 带缓冲线程池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">	return new ThreadPoolExecutor(0, Integer.MAX_VALUE, </span><br><span class="line">                                    60L, TimeUnit.SECONDS, </span><br><span class="line">                                    new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>核心线程数为 <code>0</code>，最大线程数为 <code>Integer.MAX_VALUE</code>，意味着全为救急线程，且超时时间为 <code>60s</code></li>
<li>阻塞队列 <code>SynchronousQueue</code> 没有容量，读写操作一一对应，意味着提交一个任务就必须马上执行</li>
<li>适合任务数比较密集，但每个任务耗时较短的情况</li>
</ol>
<h3 id="3-单线程线程池"><a href="#3-单线程线程池" class="headerlink" title="3 单线程线程池"></a>3 单线程线程池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService(</span><br><span class="line">    		new ThreadPoolExecutor(1, 1, </span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS, </span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>核心线程数 = 最大线程数 = 1，即线程数固定为 1</li>
<li>适合多个任务排队执行</li>
<li>单线程线程池 &amp; 自己创建一个线程的区别<ol>
<li>自己创建一个线程，如果某个任务执行失败而终止，那么没有任何补救措施</li>
<li>单线程线程池会新创建一个线程，保证池中始终有一个工作线程，且线程池有任务阻塞队列</li>
</ol>
</li>
<li>单线程线程池 &amp; 数量为 1 的固定大小线程池的区别<ol>
<li>固定大小线程池对外暴漏的是 <code>ThreadPoolExecutor</code> 对象，所以可以使用其方法修改核心线程数</li>
<li>单线程线程池 <code>FinalizableDelegatedExecutorService</code> 使用的是装饰着模式，只对外暴漏了 <code>ExecutorService</code> 的方法，不能使用  <code>ThreadPoolExecutor</code> 的特有方法，无法修改</li>
</ol>
</li>
</ol>
<h3 id="4-任务调度线程池"><a href="#4-任务调度线程池" class="headerlink" title="4 任务调度线程池"></a>4 任务调度线程池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">	return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">	super(corePoolSize, Integer.MAX_VALUE, </span><br><span class="line">		DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">		new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>没有任务调度线程池之前，<code>java.util.Timer</code> 可以用来实现定时功能，缺点：<ol>
<li>所有任务由一个线程调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行</li>
<li>如果某一个任务出现异常，会影响到之后的任务</li>
</ol>
</li>
<li>任务调度线程池可以由不同的线程来执行任务，且某个任务出现异常也不会影响其它任务</li>
</ol>
<h2 id="12-7-ScheduledThreadPoolExecutor"><a href="#12-7-ScheduledThreadPoolExecutor" class="headerlink" title="12.7 ScheduledThreadPoolExecutor"></a>12.7 <code>ScheduledThreadPoolExecutor</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ScheduledFuture&lt;?&gt;</code></td>
<td><code>schedule(Runnable command, long delay, TimeUnit unit)</code></td>
<td>指定延迟后，执行 <code>Runnable</code> 任务</td>
</tr>
<tr>
<td><code>&lt;V&gt; ScheduledFuture&lt;V&gt;</code></td>
<td><code>schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code></td>
<td>指定延迟后，执行 <code>Callable</code> 任务</td>
</tr>
<tr>
<td><code>ScheduledFuture&lt;?&gt;</code></td>
<td><code>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code></td>
<td>初始延迟时间后开始执行任务，到达 <code>period</code> 间隔时间后，判断上一个任务是否执行完毕，若执行完毕则执行下一个任务，否则等待其执行完毕</td>
</tr>
<tr>
<td><code>ScheduledFuture&lt;?&gt;</code></td>
<td><code>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code></td>
<td>初始延迟时间后开始执行任务，上一个任务执行完毕后延迟指定时间再开始执行下一个任务</td>
</tr>
</tbody></table>
<h2 id="12-8-Fork-Join"><a href="#12-8-Fork-Join" class="headerlink" title="12.8 Fork/Join"></a>12.8 <code>Fork/Join</code></h2><h3 id="1-概述-11"><a href="#1-概述-11" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>Fork/Join</code> 是 JDK 7 加入的新的线程池实现，体现的是一种分治思想，适用于能够进行任务拆分的 CPU 密集型运算</li>
<li>分支/合并框架的目的是以递归方式将可以并行的任务拆分成更小的任务，然后将每个子任务的结果合并起来生成整体结果</li>
<li><code>Fork/Join</code> 是 <code>ExecutorService</code> 接口的一个实现，它把子任务分配给线程池（称为 <code>ForkJoinPool</code> ）中的工作线程</li>
</ol>
<h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2 任务"></a>2 任务</h3><h4 id="1-概述-12"><a href="#1-概述-12" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li><p>提交给 <code>Fork/Join</code> 线程池的任务需要继承 <code>ForkJoinTask&lt;V&gt;</code></p>
<ol>
<li><code>RecursiveTask&lt;V&gt;</code>：有返回值，<code>V</code>是并行化任务（以及所有子任务）产生的结果类型</li>
<li><code>RecursiveAction</code>：无返回值</li>
</ol>
</li>
<li><p>定义的任务， 只需实现它唯一的抽象方法 <code>V compute()</code>，此方法同时定义了：</p>
<ol>
<li>将任务拆分成子任务的逻辑</li>
<li>无法再拆分或不方便再拆分时，生成单个子任务结果的逻辑</li>
</ol>
</li>
<li><p><code>compute()</code> 伪代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (任务足够小或不可分) &#123;</span><br><span class="line">	顺序计算该任务</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    将任务分成两个子任务</span><br><span class="line">    递归调用本方法，拆分每个子任务，等待所有子任务完成</span><br><span class="line">    合并每个子任务的结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2-ForkJoinTask-lt-V-gt"><a href="#2-ForkJoinTask-lt-V-gt" class="headerlink" title="2 ForkJoinTask&lt;V&gt;"></a>2 <code>ForkJoinTask&lt;V&gt;</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinTask&lt;V&gt; fork()：使用 ForkJoinPool 中另一个线程异步执行子任务</span><br><span class="line">V join()：获取子任务结果，如果尚未完成就等待</span><br></pre></td></tr></table></figure>

<h3 id="3-工作窃取"><a href="#3-工作窃取" class="headerlink" title="3 工作窃取"></a>3 工作窃取</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96.png" alt=""></p>
<ol>
<li>理想情况下，划分并行任务时，应该让每个任务都用完全相同的时间完成，让所有的CPU内核都同样繁忙。不幸的是，实际中，每个子任务所花的时间可能天差地别</li>
<li>分支/合并框架工程用一种称为工作窃取（<code>work stealing</code>）的技术来解决这个问题</li>
<li>工作窃取算法用于在池中的工作线程之间重新分配和平衡任务<ol>
<li>每个线程都为分配给它的任务保存一个双向链式队列，每完成一个任务，就会从队列头上取出下一个任务开始执<br>行</li>
<li>某个线程可能早早完成了分配给它的所有任务，也就是它的队列已经空了，而其他的线程还很忙。这时，这个线程并没有闲下来，而是随机选了一个别的线程，从其队列的尾巴上“偷走”一个任务</li>
<li>这个过程一直继续下去，直到所有的任务都执行完毕，所有的队列都清空</li>
</ol>
</li>
</ol>
<h3 id="4-ForkJoinPool"><a href="#4-ForkJoinPool" class="headerlink" title="4 ForkJoinPool"></a>4 <code>ForkJoinPool</code></h3><h4 id="1-构造-4"><a href="#1-构造-4" class="headerlink" title="1 构造"></a>1 构造</h4><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ForkJoinPool()</code></td>
<td>默认会创建和 CPU 核心数相同大小的线程池</td>
</tr>
<tr>
<td><code>ForkJoinPool(int parallelism)</code></td>
<td>指定线程数</td>
</tr>
</tbody></table>
<h4 id="2-方法-3"><a href="#2-方法-3" class="headerlink" title="2 方法"></a>2 方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; T invoke(ForkJoinTask&lt;T&gt; task)</span><br><span class="line">void execute(ForkJoinTask&lt;?&gt; task)</span><br><span class="line">&lt;T&gt; ForkJoinTask&lt;T&gt; submit(ForkJoinTask&lt;T&gt; task)</span><br></pre></td></tr></table></figure>

<h1 id="十三-线程安全集合"><a href="#十三-线程安全集合" class="headerlink" title="十三 线程安全集合"></a>十三 线程安全集合</h1><h2 id="13-1-概述"><a href="#13-1-概述" class="headerlink" title="13.1 概述"></a>13.1 概述</h2><ol>
<li><p>遗留的线程安全集合如  <code>Hashtable</code> ， <code>Vector</code></p>
</li>
<li><p>使用 <code>Collections</code> 装饰的线程安全集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collections.synchronizedCollection</span><br><span class="line">Collections.synchronizedList</span><br><span class="line">Collections.synchronizedMap</span><br><span class="line">Collections.synchronizedSet</span><br><span class="line">Collections.synchronizedNavigableMap</span><br><span class="line">Collections.synchronizedNavigableSet</span><br><span class="line">Collections.synchronizedSortedMap</span><br><span class="line">Collections.synchronizedSortedSet</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>java.util.concurrent.*</code></p>
<ol>
<li><code>Blocking</code>：大部分实现基于锁，并提供用来阻塞的方法</li>
<li><code>CopyOnWrite</code>：写开销相对较重</li>
<li><code>Concurrent</code>：<ol>
<li>内部很多操作使用 <code>CAS</code> 优化，一般可以提供较高吞吐量</li>
<li>弱一致性<ul>
<li>遍历时弱一致性：当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍<br>历，但这时内容是旧的（非安全容器会抛异常）</li>
<li>求大小弱一致性：size 操作未必是 100% 准确</li>
<li>读取弱一致性</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="13-2-ConcurrentHashMap-lt-K-V-gt"><a href="#13-2-ConcurrentHashMap-lt-K-V-gt" class="headerlink" title="13.2 ConcurrentHashMap&lt;K,V&gt;"></a>13.2 <code>ConcurrentHashMap&lt;K,V&gt;</code></h2><h3 id="1-概述-13"><a href="#1-概述-13" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>JDK 7 中非线程安全的 Map 集合当元素下标相同时，会添加到链表的头部，而 JDK 8 则是添加到链表的尾部</li>
<li>JDK 7 中在多线程环境使用非线程安全的 Map 集合，当扩容时可能出现并发死链，JDK 8 虽然将扩容算法做了调整，但还是会出现其他问题，如扩容丢数据</li>
</ol>
<h3 id="2-重要属性和内部类"><a href="#2-重要属性和内部类" class="headerlink" title="2 重要属性和内部类"></a>2 重要属性和内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 默认为 0</span><br><span class="line">// 当初始化时, 为 -1</span><br><span class="line">// 当扩容时, 为 -(1 + 扩容线程数)</span><br><span class="line">// 当初始化或扩容完成后，为 下一次的扩容的阈值大小</span><br><span class="line">private transient volatile int sizeCtl;</span><br><span class="line"></span><br><span class="line">// 整个 ConcurrentHashMap 就是一个 Node[]</span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">// hash 表</span><br><span class="line">transient volatile Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">// 扩容时的 新 hash 表</span><br><span class="line">private transient volatile Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点</span><br><span class="line">static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node</span><br><span class="line">static final class ReservationNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 作为 treebin 的头节点, 存储 root 和 first</span><br><span class="line">static final class TreeBin&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 作为 treebin 的节点, 存储 parent, left, right</span><br><span class="line">static final class TreeNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-重要方法"><a href="#3-重要方法" class="headerlink" title="3 重要方法"></a>3 重要方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取 Node[] 中第 i 个 Node</span><br><span class="line">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i)</span><br><span class="line"></span><br><span class="line">// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值</span><br><span class="line">static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span><br><span class="line"></span><br><span class="line">// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值</span><br><span class="line">static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v)</span><br></pre></td></tr></table></figure>

<h2 id="13-3-CopyOnWriteArrayList"><a href="#13-3-CopyOnWriteArrayList" class="headerlink" title="13.3 CopyOnWriteArrayList"></a>13.3 <code>CopyOnWriteArrayList</code></h2><ol>
<li><code>ArrayList</code></li>
<li>每次写入时都会复制一个新的容器再写入</li>
<li>在迭代并添加时没有并发修改异常</li>
<li>每次写入都会复制，效率低，适合并发迭代</li>
</ol>
<h1 id="十四-java-lang-ThreadLocal-lt-T-gt"><a href="#十四-java-lang-ThreadLocal-lt-T-gt" class="headerlink" title="十四 java.lang.ThreadLocal&lt;T&gt;"></a>十四 <code>java.lang.ThreadLocal&lt;T&gt;</code></h1><h2 id="14-1-概述"><a href="#14-1-概述" class="headerlink" title="14.1 概述"></a>14.1 概述</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 ThreadLocal</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 Thread</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>ThreadLocal</code> 中有一个静态内部类 <code>ThreadLocalMap</code>，<code>ThreadLocalMap</code> 中有一个静态内部类 <code>Entry</code>，且维护了一个 <code>Entry</code> 类型的数组，其实数据最终存储在了 <code>Entry[]</code> 中</li>
<li><code>TheadLocalMap</code> 的键为 <code>ThreaLoal</code> 本身，值为自定义添加的值</li>
<li>一个 <code>ThreadLocalMap</code> 可以存储 <code>n</code> 个 <code>ThreadLocal</code>，所以存储时，会根据不同的  <code>ThreadLocal</code> 计算出不同的索引，此索引即存储到 <code>ThreadLocalMap</code> 中的 <code>Entry[]</code> 中的位置</li>
<li>每个线程对应一个 <code>ThreadLoaclMap</code> ，不同线程互不干扰</li>
<li>每个线程可以有多个不同的 <code>ThreadLocal</code>（如 <code>ThreadLocal&lt;A&gt;, ThreadLoacl&lt;B&gt;...</code>），所有 <code>ThreadLocal</code> 使用同一个 <code>ThreadLocalMap</code></li>
<li><code>Entry</code> 是一个弱引用<ol>
<li>如果是强引用，即使 <code>ThreadLocal tl = null</code> ，<code>Entry</code> 中的键依然指向 <code>ThreadLocal</code> ，会导致内存泄漏</li>
<li>弱引用还是有内存泄漏问题：当 <code>ThreadLocal</code> 为 <code>null</code> 被当成垃圾回收，但 <code>ThreadLocalMap</code> 生命周期和 <code>Thread</code> 一样，它不会回收，即 <code>Entry</code> 中的键为 <code>null</code> 了，而值还存在，但无法访问到了，所以使用完 <code>ThreadLocal</code> 后，执行 <code>remove()</code> 操作</li>
</ol>
</li>
</ol>
<h2 id="14-2-API"><a href="#14-2-API" class="headerlink" title="14.2 API"></a>14.2 API</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>set(T value)</code></td>
<td>此 <code>ThreadLocal</code> 作为键，<code>value</code> 作为值，存储到当前线程的 <code>ThreadLoaclMap</code> 中</td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>get()</code></td>
<td>从当前线程的 <code>ThreadLoaclMap</code> 中，获取键 <code>ThreadLocal</code> 对应的值</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>remove()</code></td>
<td>从当前线程的 <code>ThreadLoaclMap</code> 中，移除此 <code>ThreadLocal</code> 的键值对</td>
</tr>
</tbody></table>
<h3 id="1-set"><a href="#1-set" class="headerlink" title="1 set"></a>1 <code>set</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的 ThreadLocalMap，如果已存在则直接使用，否则创建一个</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-get"><a href="#2-get" class="headerlink" title="2 get"></a>2 <code>get</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <div>
      
	<div>
    
        <div style="text-align:center;color: #66ccff;font-size:14px;">-------------The End&nbsp;&nbsp;<i class="fa fa-paw"></i>&nbsp;&nbsp;客官请自便-------------</div>
    
</div
      
    </div>

      <footer class="post-footer">


        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/anyeansan.github.io/2020/09/29/Java/Java-%E9%9B%86%E5%90%88/" rel="next" title="Java-集合">
                  <i class="fa fa-chevron-left"></i> Java-集合
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/anyeansan.github.io/2020/09/29/Java/Java-%E5%8F%8D%E5%B0%84/" rel="prev" title="Java-反射">
                  Java-反射 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          秘笈
        </li>
        <li class="sidebar-nav-overview">
          安₃
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一-概念"><span class="nav-text">一 概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-同步（Synchronous）-amp-异步（Asynchronous）"><span class="nav-text">1.1 同步（Synchronous）&amp; 异步（Asynchronous）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-并发（Concurrency）-amp-并行（Parallelism）"><span class="nav-text">1.2 并发（Concurrency）&amp; 并行（Parallelism）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-进程（Process）-amp-线程（Thread）"><span class="nav-text">1.3 进程（Process）&amp; 线程（Thread）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二-体系"><span class="nav-text">二 体系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三-Thread"><span class="nav-text">三 Thread</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-创建线程"><span class="nav-text">3.1 创建线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-启动线程"><span class="nav-text">3.2 启动线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-线程信息"><span class="nav-text">3.3 线程信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-加入线程"><span class="nav-text">3.4 加入线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-中断线程"><span class="nav-text">3.5 中断线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-守护线程"><span class="nav-text">3.6 守护线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-礼让线程"><span class="nav-text">3.7 礼让线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-线程组"><span class="nav-text">3.8 线程组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-概述"><span class="nav-text">1 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-ThreadGroup"><span class="nav-text">2 ThreadGroup</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-构造"><span class="nav-text">1 构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-方法"><span class="nav-text">2 方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-9-线程优先级"><span class="nav-text">3.9 线程优先级</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四-线程状态"><span class="nav-text">四 线程状态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五-终止线程"><span class="nav-text">五 终止线程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#六-JMM"><span class="nav-text">六 JMM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-CPU-缓存"><span class="nav-text">6.1 CPU 缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-概述-1"><span class="nav-text">1 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-MESI-缓存一致性协议"><span class="nav-text">2 MESI 缓存一致性协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-JMM-概述"><span class="nav-text">6.2 JMM 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-JMM-内存交互操作（原子操作）"><span class="nav-text">6.3 JMM 内存交互操作（原子操作）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-JMM-特性"><span class="nav-text">6.4 JMM 特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-原子性-Atomicity"><span class="nav-text">1 原子性 Atomicity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-可见性-Visibility"><span class="nav-text">2 可见性 Visibility</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-有序性-Ordering"><span class="nav-text">3 有序性 Ordering</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-Happens-Before-规则"><span class="nav-text">6.5 Happens-Before 规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-概述-2"><span class="nav-text">1 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-规则"><span class="nav-text">2 规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-volatile"><span class="nav-text">6.6 volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-概述-3"><span class="nav-text">1 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Volatile-可见性"><span class="nav-text">2 Volatile 可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Volatile-有序性"><span class="nav-text">3 Volatile 有序性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-7-synchronized"><span class="nav-text">6.7 synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-概述-4"><span class="nav-text">1 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-同步代码块"><span class="nav-text">2 同步代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-同步函数"><span class="nav-text">3 同步函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-synchronized-原理"><span class="nav-text">4 synchronized 原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-对象头"><span class="nav-text">1 对象头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Monitor：监视器-管程"><span class="nav-text">2 Monitor：监视器/管程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-原理"><span class="nav-text">3 原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-锁优化"><span class="nav-text">4 锁优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-锁粗化"><span class="nav-text">1 锁粗化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-锁消除"><span class="nav-text">2 锁消除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-锁膨胀升级"><span class="nav-text">3 锁膨胀升级</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述-5"><span class="nav-text">1 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-偏向锁"><span class="nav-text">2 偏向锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-轻量级锁"><span class="nav-text">3 轻量级锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-锁活跃性"><span class="nav-text">5 锁活跃性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-8-常见线程安全类"><span class="nav-text">6.8 常见线程安全类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#七-等待唤醒机制"><span class="nav-text">七 等待唤醒机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-wait-notify"><span class="nav-text">7.1 wait/notify</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-概述-6"><span class="nav-text">1 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-wait-amp-sleep"><span class="nav-text">2 wait &amp; sleep</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-模式"><span class="nav-text">3 模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-park-unpark"><span class="nav-text">7.2 park/unpark</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-与-wait-amp-notify-相比"><span class="nav-text">1 与 wait &amp; notify 相比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-原理"><span class="nav-text">2 原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#八-CAS"><span class="nav-text">八 CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-概述"><span class="nav-text">8.1 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-原理"><span class="nav-text">8.2 原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#九-java-util-concurrent-atomic"><span class="nav-text">九 java.util.concurrent.atomic</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-概述"><span class="nav-text">9.1 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-AtomicInteger"><span class="nav-text">9.2 AtomicInteger</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-构造-1"><span class="nav-text">1 构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-方法-1"><span class="nav-text">2 方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十-java-util-concurrent-locks"><span class="nav-text">十 java.util.concurrent.locks</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-Lock"><span class="nav-text">10.1 Lock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-API"><span class="nav-text">1 API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-典型使用"><span class="nav-text">2 典型使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-lock"><span class="nav-text">1 lock()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-tryLock"><span class="nav-text">2 tryLock()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-ReentrantLock"><span class="nav-text">3 ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-构造-2"><span class="nav-text">1 构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-与-synchronized-比较"><span class="nav-text">2 与 synchronized 比较</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-Condition"><span class="nav-text">10.2 Condition</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-3-ReadWriteLock"><span class="nav-text">10.3 ReadWriteLock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-概述-7"><span class="nav-text">1 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-API"><span class="nav-text">2 API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-4-LockSupport"><span class="nav-text">10.4 LockSupport</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十一-辅助工具类"><span class="nav-text">十一 辅助工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1-Semaphore"><span class="nav-text">11.1 Semaphore</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-概述-8"><span class="nav-text">1 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-构造"><span class="nav-text">2 构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-方法"><span class="nav-text">3 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2-CountDownLatch"><span class="nav-text">11.2 CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-概述-9"><span class="nav-text">1 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-构造-1"><span class="nav-text">2 构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-方法-1"><span class="nav-text">3 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-3-CyclicBarrier"><span class="nav-text">11.3 CyclicBarrier</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-概述-10"><span class="nav-text">1 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-构造-2"><span class="nav-text">2 构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-方法-2"><span class="nav-text">3 方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十二-线程池"><span class="nav-text">十二 线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-线程池体系"><span class="nav-text">12.1 线程池体系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-2-线程池执行过程"><span class="nav-text">12.2 线程池执行过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-3-线程池状态"><span class="nav-text">12.3 线程池状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-4-线程池数量"><span class="nav-text">12.4 线程池数量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-5-ThreadPoolExecutor"><span class="nav-text">12.5 ThreadPoolExecutor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-构造-3"><span class="nav-text">1 构造</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Enum-TimeUnit"><span class="nav-text">1 Enum TimeUnit</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-枚举项：时间粒度"><span class="nav-text">1 枚举项：时间粒度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-方法：线程"><span class="nav-text">2 方法：线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-方法：时间粒度转换"><span class="nav-text">3 方法：时间粒度转换</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-ThreadFactory"><span class="nav-text">2 ThreadFactory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-RejectedExecutionHandler"><span class="nav-text">3 RejectedExecutionHandler</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-方法-2"><span class="nav-text">2 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-提交任务"><span class="nav-text">1 提交任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-关闭线程池"><span class="nav-text">2 关闭线程池</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-6-Executors"><span class="nav-text">12.6 Executors</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-固定大小线程池"><span class="nav-text">1 固定大小线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-带缓冲线程池"><span class="nav-text">2 带缓冲线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-单线程线程池"><span class="nav-text">3 单线程线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-任务调度线程池"><span class="nav-text">4 任务调度线程池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-7-ScheduledThreadPoolExecutor"><span class="nav-text">12.7 ScheduledThreadPoolExecutor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-8-Fork-Join"><span class="nav-text">12.8 Fork/Join</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-概述-11"><span class="nav-text">1 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-任务"><span class="nav-text">2 任务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-概述-12"><span class="nav-text">1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-ForkJoinTask-lt-V-gt"><span class="nav-text">2 ForkJoinTask&lt;V&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-工作窃取"><span class="nav-text">3 工作窃取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-ForkJoinPool"><span class="nav-text">4 ForkJoinPool</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-构造-4"><span class="nav-text">1 构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-方法-3"><span class="nav-text">2 方法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十三-线程安全集合"><span class="nav-text">十三 线程安全集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#13-1-概述"><span class="nav-text">13.1 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-2-ConcurrentHashMap-lt-K-V-gt"><span class="nav-text">13.2 ConcurrentHashMap&lt;K,V&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-概述-13"><span class="nav-text">1 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-重要属性和内部类"><span class="nav-text">2 重要属性和内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-重要方法"><span class="nav-text">3 重要方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-3-CopyOnWriteArrayList"><span class="nav-text">13.3 CopyOnWriteArrayList</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十四-java-lang-ThreadLocal-lt-T-gt"><span class="nav-text">十四 java.lang.ThreadLocal&lt;T&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#14-1-概述"><span class="nav-text">14.1 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-2-API"><span class="nav-text">14.2 API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-set"><span class="nav-text">1 set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-get"><span class="nav-text">2 get</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="安₃"
      src="/anyeansan.github.io/images/an3.png">
  <p class="site-author-name" itemprop="name">安₃</p>
  <div class="site-description" itemprop="description">一蓑烟雨任平生</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/anyeansan.github.io/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">琅嬛福地</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/anyeansan.github.io/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">门派</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/anyeansan.github.io/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-star-half-full"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">安₃</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/anyeansan.github.io/lib/anime.min.js"></script>
  <script src="/anyeansan.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/anyeansan.github.io/lib/velocity/velocity.ui.min.js"></script>
<script src="/anyeansan.github.io/js/utils.js"></script><script src="/anyeansan.github.io/js/motion.js"></script>
<script src="/anyeansan.github.io/js/schemes/pisces.js"></script>
<script src="/anyeansan.github.io/js/next-boot.js"></script>



  




  <script src="/anyeansan.github.io/js/local-search.js"></script>













  

  

</body>
</html>
