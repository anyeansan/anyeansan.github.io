<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/anyeansan.github.io/images/an-apple-180.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/anyeansan.github.io/images/an-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/anyeansan.github.io/images/an-16.png">
  <link rel="mask-icon" href="/anyeansan.github.io/images/an.svg" color="#222">
  <link rel="alternate" href="/anyeansan.github.io/atom.xml" title="安₃" type="application/atom+xml">

<link rel="stylesheet" href="/anyeansan.github.io/css/main.css">


<link rel="stylesheet" href="/anyeansan.github.io/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/anyeansan.github.io/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"hide","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="一蓑烟雨任平生">
<meta property="og:type" content="website">
<meta property="og:title" content="安₃">
<meta property="og:url" content="https:&#x2F;&#x2F;anyeansan.github.io&#x2F;page&#x2F;3&#x2F;">
<meta property="og:site_name" content="安₃">
<meta property="og:description" content="一蓑烟雨任平生">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://anyeansan.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>安₃</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/anyeansan.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">安₃</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">我未成名君未嫁 可能俱是不如人</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/anyeansan.github.io/" rel="section"><i class="fa fa-fw fa-home"></i>安府</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/anyeansan.github.io/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>琅嬛福地</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/anyeansan.github.io/categories/" rel="section"><i class="fa fa-fw fa-th"></i>门派</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/anyeansan" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/11/08/UI/JS%E9%97%AD%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/11/08/UI/JS%E9%97%AD%E5%8C%85/" class="post-title-link" itemprop="url">JS闭包</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-11-08 21:08:50 / 修改时间：21:10:52" itemprop="dateCreated datePublished" datetime="2020-11-08T21:08:50+08:00">2020-11-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-作用域"><a href="#1-1-作用域" class="headerlink" title="1.1 作用域"></a>1.1 作用域</h2><ol>
<li>函数作用域内可以访问全局变量，函数作用域外不能访问函数作用域中的局部变量</li>
<li>函数执行完毕（弹栈），函数作用域中的变量也随之销毁</li>
<li>作用域是临时的，而闭包是永久的</li>
</ol>
<h2 id="1-2-闭包-closure"><a href="#1-2-闭包-closure" class="headerlink" title="1.2 闭包 closure"></a>1.2 闭包 closure</h2><ol>
<li>有一个单独的作用域，此作用域中定义一个函数，则这个函数与它能在此作用域中所有能访问的变量构成了闭包。在此作用域外调用函数时，函数能够使用此作用域中的变量</li>
<li>闭包可以在外部作用域中访问到函数作用域中的局部变量，延长了变量的生命周期和作用范围</li>
</ol>
<h1 id="二-如何形成闭包"><a href="#二-如何形成闭包" class="headerlink" title="二 如何形成闭包"></a>二 如何形成闭包</h1><h2 id="2-1-条件"><a href="#2-1-条件" class="headerlink" title="2.1 条件"></a>2.1 条件</h2><ol>
<li>单独的作用域：为了创建局部变量</li>
<li>内部定义一个函数：形成闭包</li>
<li>在外部访问函数</li>
</ol>
<h2 id="2-2-例"><a href="#2-2-例" class="headerlink" title="2.2 例"></a>2.2 例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i++);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> inner = outer(); <span class="comment">// 执行外部函数，返回内部函数</span></span><br><span class="line">inner(); <span class="comment">// 外部函数执行完毕后，依然可以访问到外部函数中的变量</span></span><br></pre></td></tr></table></figure>

<h1 id="三-应用"><a href="#三-应用" class="headerlink" title="三 应用"></a>三 应用</h1><h2 id="3-1-事件"><a href="#3-1-事件" class="headerlink" title="3.1 事件"></a>3.1 事件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有 5 个 li ，添加点击事件，打印索引</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">	lis[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i); <span class="comment">// 最终结果每个 li 都打印 4，因为循环是同步的，而点击事件是异步的</span></span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用闭包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">		lis[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(index);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 立即执行函数是一个单独作用域</span></span><br><span class="line"><span class="comment">// 2. 事件处理函数和立即执行函数中的局部变量 index 形成了闭包</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-定时任务"><a href="#3-2-定时任务" class="headerlink" title="3.2 定时任务"></a>3.2 定时任务</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i);<span class="comment">// 最终结果都打印 4，因为循环是同步的，而定时任务是异步的</span></span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用闭包------</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(index);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/11/08/UI/JS%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/11/08/UI/JS%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">JS内置对象</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-11-08 21:08:44 / 修改时间：21:11:14" itemprop="dateCreated datePublished" datetime="2020-11-08T21:08:44+08:00">2020-11-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-Math"><a href="#一-Math" class="headerlink" title="一 Math"></a>一 Math</h1><h2 id="1-1-静态属性"><a href="#1-1-静态属性" class="headerlink" title="1.1 静态属性"></a>1.1 静态属性</h2><table>
<thead>
<tr>
<th>静态属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Math.E</code></td>
<td>欧拉常数 <code>e</code></td>
</tr>
<tr>
<td><code>Math.PI</code></td>
<td><code>π</code></td>
</tr>
</tbody></table>
<h2 id="1-2-静态方法"><a href="#1-2-静态方法" class="headerlink" title="1.2 静态方法"></a>1.2 静态方法</h2><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Math.abs(x)</code></td>
<td>绝对值</td>
</tr>
<tr>
<td><code>Math.ceil(x)</code></td>
<td>向上取整</td>
</tr>
<tr>
<td><code>Math.floor(x)</code></td>
<td>向下取整</td>
</tr>
<tr>
<td><code>Math.pow(x, y)</code></td>
<td>返回 x 的 y 次幂</td>
</tr>
<tr>
<td><code>Math.random()</code></td>
<td>返回 <code>[0-1)</code>之间的伪随机数</td>
</tr>
<tr>
<td><code>Math.round(x)</code></td>
<td>四舍五入</td>
</tr>
<tr>
<td><code>Math.sqrt(x)</code></td>
<td>平方</td>
</tr>
<tr>
<td><code>Math.log(x)</code></td>
<td>对数</td>
</tr>
<tr>
<td><code>Math.exp(x)</code></td>
<td><code>e</code> 的指数，即 e<sup>x</sup></td>
</tr>
<tr>
<td><code>Math.min([value1[,value2, ...]])</code></td>
<td>返回一组数字中的最小值。如果有任一参数不能转换为数值，则返回 <code>NaN</code></td>
</tr>
<tr>
<td><code>Math.max(value1[,value2, ...])</code></td>
<td>返回一组数字中的最大值。如果有任一参数不能转换为数值，则返回 <code>NaN</code></td>
</tr>
<tr>
<td><code>Math.sin(x)</code></td>
<td>正弦</td>
</tr>
<tr>
<td><code>Math.cos(x)</code></td>
<td>余弦</td>
</tr>
<tr>
<td><code>Math.tan(x)</code></td>
<td>正切</td>
</tr>
</tbody></table>
<h1 id="二-Date"><a href="#二-Date" class="headerlink" title="二 Date"></a>二 Date</h1><h2 id="2-1-构造函数"><a href="#2-1-构造函数" class="headerlink" title="2.1 构造函数"></a>2.1 构造函数</h2><table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Date([value])</code></td>
<td>普通函数</td>
<td>无论有没有参数，都返回当前日期和时间的字符串</td>
</tr>
<tr>
<td><code>new Date()</code></td>
<td>构造函数</td>
<td>创建一个当前日期和时间的 <code>Date</code> 对象</td>
</tr>
<tr>
<td><code>new Date(stamp)</code></td>
<td>构造函数</td>
<td>创建一个指定时间戳的 <code>Date</code> 对象</td>
</tr>
<tr>
<td><code>new Date(dateString)</code></td>
<td>构造函数</td>
<td>创建一个 <code>Date</code> 对象，时间由 <code>dateString</code> 决定，该字符串能被 <code>Date.parse()</code>正确识别</td>
</tr>
</tbody></table>
<h2 id="2-2-静态方法"><a href="#2-2-静态方法" class="headerlink" title="2.2 静态方法"></a>2.2 静态方法</h2><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Date.now()</code></td>
<td>返回当前时间距离时间零点的毫秒数</td>
</tr>
<tr>
<td><code>Date.parse(dateString)</code></td>
<td>解析日期字符串，返回该时间距离时间零点的毫秒数</td>
</tr>
</tbody></table>
<h2 id="2-3-原型方法-Date-prototype"><a href="#2-3-原型方法-Date-prototype" class="headerlink" title="2.3 原型方法 Date.prototype."></a>2.3 原型方法 <code>Date.prototype.</code></h2><h3 id="1-to"><a href="#1-to" class="headerlink" title="1 to"></a>1 to</h3><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>toString()</code></td>
<td>返回日期时间字符串字符串</td>
</tr>
<tr>
<td><code>toLocaleString()</code></td>
<td>返回本地日期时间字符串</td>
</tr>
<tr>
<td><code>toUTCString()</code></td>
<td>返回 UTC 日期时间字符串</td>
</tr>
<tr>
<td><code>toISOString()</code></td>
<td>返回 ISO8601 写法的日期时间字符串，通常用于网络服务</td>
</tr>
<tr>
<td><code>toJSON()</code></td>
<td>与<code>toISOString()</code>方法的返回结果完全相同</td>
</tr>
</tbody></table>
<h3 id="2-get"><a href="#2-get" class="headerlink" title="2 get"></a>2 get</h3><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>getTime</code></td>
<td>返回距离事件元点的毫秒数</td>
</tr>
<tr>
<td><code>getFullYear</code></td>
<td>年（四位数）</td>
</tr>
<tr>
<td><code>getMonth()</code></td>
<td>月 <code>0-11</code></td>
</tr>
<tr>
<td><code>getDate()</code></td>
<td>日 <code>1-31</code></td>
</tr>
<tr>
<td><code>getDay()</code></td>
<td>星期 <code>0-6</code></td>
</tr>
<tr>
<td><code>getHours()</code></td>
<td>时 <code>0-23</code></td>
</tr>
<tr>
<td><code>getMinutes()</code></td>
<td>分 <code>0-59</code></td>
</tr>
<tr>
<td><code>getSeconds()</code></td>
<td>秒 <code>0-59</code></td>
</tr>
<tr>
<td><code>getMilliseconds()</code></td>
<td>毫秒 <code>0-999</code></td>
</tr>
</tbody></table>
<h3 id="3-set"><a href="#3-set" class="headerlink" title="3 set"></a>3 set</h3><ul>
<li>set 与 get 一一相对应，除了没有 <code>setDay()</code>，因为星期是算的</li>
</ul>
<h1 id="三-RegExp"><a href="#三-RegExp" class="headerlink" title="三 RegExp"></a>三 RegExp</h1><h2 id="3-1-构造函数"><a href="#3-1-构造函数" class="headerlink" title="3.1 构造函数"></a>3.1 构造函数</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>new RegExp(pattern [, flags])</code></td>
<td>创建 <code>RegExp</code> 对象，<code>flags</code>：可以是<code>g i m u y s</code>的任意组合</td>
</tr>
<tr>
<td><code>RegExp()</code></td>
<td>同 <code>new RegExp()</code></td>
</tr>
</tbody></table>
<h2 id="3-2-字面量"><a href="#3-2-字面量" class="headerlink" title="3.2 字面量"></a>3.2 字面量</h2><ul>
<li><code>/pattern/flags</code><ul>
<li><code>/</code> 斜杠表示开始和结束</li>
</ul>
</li>
</ul>
<h2 id="3-3-原型属性-RegExp-prototype"><a href="#3-3-原型属性-RegExp-prototype" class="headerlink" title="3.3 原型属性 RegExp.prototype."></a>3.3 原型属性 <code>RegExp.prototype.</code></h2><table>
<thead>
<tr>
<th>原型属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>global</code></td>
<td>只读</td>
<td>返回一个布尔值，判断是否设置了修饰符<code>g</code></td>
</tr>
<tr>
<td><code>ignoreCase</code></td>
<td>只读</td>
<td>返回一个布尔值，判断是否设置了修饰符<code>i</code></td>
</tr>
<tr>
<td><code>multiline</code></td>
<td>只读</td>
<td>返回一个布尔值，判断是否设置了修饰符<code>m</code></td>
</tr>
<tr>
<td><code>unicode</code></td>
<td>只读</td>
<td>返回一个布尔值，判断是否设置了修饰符<code>y</code></td>
</tr>
<tr>
<td><code>sticky</code></td>
<td>只读</td>
<td>返回一个布尔值，判断是否设置了修饰符<code>y</code></td>
</tr>
<tr>
<td><code>dotAll</code></td>
<td>只读</td>
<td>返回一个布尔值，判断是否设置了修饰符<code>s</code></td>
</tr>
<tr>
<td><code>flags</code></td>
<td>只读</td>
<td>返回一个字符串，包含已经设置的所有修饰符，按字母排序</td>
</tr>
<tr>
<td><code>source</code></td>
<td>只读</td>
<td>返回正则表达式文本字符串，该字符串不包含正则字面量两边的斜杠以及任何的标志字符</td>
</tr>
<tr>
<td><code>lastIndex</code></td>
<td>读写</td>
<td>指定下一次匹配的起始索引。正则表达式必须有 <code>g</code></td>
</tr>
</tbody></table>
<h2 id="3-4-原型方法-RegExp-prototype"><a href="#3-4-原型方法-RegExp-prototype" class="headerlink" title="3.4 原型方法 RegExp.prototype."></a>3.4 原型方法 <code>RegExp.prototype.</code></h2><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>test(str)</code></td>
<td>判断是否匹配，会更新正则对象的 <code>lastIndex</code> 属性</td>
</tr>
<tr>
<td><code>exec(str)</code></td>
<td>返回一个包含匹配项的数组（包含附加属性），若匹配失败返回 <code>null</code>，并将 <code>lastIndex</code> 重置为 0</td>
</tr>
</tbody></table>
<h1 id="四-JSON"><a href="#四-JSON" class="headerlink" title="四 JSON"></a>四 JSON</h1><h2 id="4-1-语法"><a href="#4-1-语法" class="headerlink" title="4.1 语法"></a>4.1 语法</h2><ol>
<li>属性：必须是双引号括起来的字符串；最后一个属性后不能有逗号</li>
<li>基本类型的值<ol>
<li>字符串</li>
<li>数值（必须十进制，<code>NaN</code> 不行）</li>
<li>布尔值</li>
<li>null（ <code>undefined</code> 不行）</li>
</ol>
</li>
<li>引用类型的值<ol>
<li>数组</li>
<li>对象</li>
</ol>
</li>
</ol>
<h2 id="4-2-静态方法"><a href="#4-2-静态方法" class="headerlink" title="4.2 静态方法"></a>4.2 静态方法</h2><ol>
<li><code>JSON.stringify(value[, replacer [, space]])</code><ul>
<li>将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被<code>parse()</code>方法还原。</li>
<li><code>value</code><ul>
<li>要被序列化的对象</li>
<li>如果对象有自定义的<code>toJSON()</code>方法，那么<code>JSON.stringify()</code>会使用<code>toJSON()</code>方法的返回值作为参数</li>
</ul>
</li>
<li><code>replacer</code><ol>
<li>如果是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的处理</li>
<li>如果是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中</li>
</ol>
</li>
<li><code>space</code>：<ul>
<li>指定缩进用的空白字符串，用于美化输出（pretty-print）增加可读性。<ol>
<li>如果是数字，表示每个属性前面添加的空格（不超过10个）</li>
<li>如果是字符串（不超过10个字符），则该字符串会添加在每行前面</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><code>JSON.parse(text[, reviver])</code><ul>
<li>将 JSON 字符串转换成对应的对象</li>
<li><code>reviver(currentKey, currentValue)</code><ul>
<li>转换器，此函数调用时机在 parse 函数返回之前，用于在返回之前对所得到的对象执行操作  </li>
<li>转成的对象的所有属性都会调用 reviver 函数，并且会将 reviver 返回值作为新的属性值，如果 reviver 返回 <code>undefined</code>，会删除当前属性</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="五-Error"><a href="#五-Error" class="headerlink" title="五 Error"></a>五 Error</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ul>
<li>当代码运行时的发生错误，会创建新的Error 对象，并将其抛出</li>
</ul>
<h2 id="5-2-构造函数"><a href="#5-2-构造函数" class="headerlink" title="5.2 构造函数"></a>5.2 构造函数</h2><ul>
<li><code>new Error([message])</code></li>
</ul>
<h2 id="5-3-原型属性"><a href="#5-3-原型属性" class="headerlink" title="5.3 原型属性"></a>5.3 原型属性</h2><ol>
<li><code>message</code><ul>
<li>错误信息</li>
</ul>
</li>
<li><code>name</code><ul>
<li>error 类型的名称.初始值为 <code>Error</code></li>
</ul>
</li>
</ol>
<h2 id="5-4-其它类型的错误构造函数"><a href="#5-4-其它类型的错误构造函数" class="headerlink" title="5.4 其它类型的错误构造函数"></a>5.4 其它类型的错误构造函数</h2><table>
<thead>
<tr>
<th>类型</th>
<th>错误原因</th>
</tr>
</thead>
<tbody><tr>
<td><code>EvalError</code></td>
<td>与 <code>eval()</code> 有关</td>
</tr>
<tr>
<td><code>RangeError</code></td>
<td>数值变量或参数超出其有效范围</td>
</tr>
<tr>
<td><code>ReferenceError</code></td>
<td>无效引用</td>
</tr>
<tr>
<td><code>SyntaxError</code></td>
<td>语法错误</td>
</tr>
<tr>
<td><code>TypeError</code></td>
<td>变量或参数不属于有效类型</td>
</tr>
<tr>
<td><code>URIError</code></td>
<td>给 <code>encodeURI()</code> 或  <code>decodeURl()</code> 传递的参数无效</td>
</tr>
</tbody></table>
<h1 id="六-集合"><a href="#六-集合" class="headerlink" title="六 集合"></a>六 集合</h1><h2 id="6-1-Set"><a href="#6-1-Set" class="headerlink" title="6.1 Set"></a>6.1 Set</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>Set 中的元素有序（存取顺序一致） 唯一</li>
<li>可以存储基本数据类型和引用数据类型（包括 <code>NaN undefined null</code>）</li>
<li>判断元素相等： 基于 <code>sameValueZero</code> 算法<ul>
<li>类似 <code>===</code>，除了 NaN，<code>NaN === NaN</code> 返回 <code>false</code>，但是在 Set 中看作相等</li>
</ul>
</li>
</ol>
<h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2 构造函数"></a>2 构造函数</h3><ul>
<li><code>new Set([iterable])</code><ul>
<li><code>iterable</code><ul>
<li>可迭代对象，它的所有元素将不重复地被添加到 Set 中。</li>
<li>如果省略或其值为 <code>null</code>，则新的 Set 为空</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-原型属性-Set-prototype"><a href="#3-原型属性-Set-prototype" class="headerlink" title="3 原型属性 Set.prototype."></a>3 原型属性 <code>Set.prototype.</code></h3><table>
<thead>
<tr>
<th>原型属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>size</code></td>
<td>Set 集合的元素个数</td>
</tr>
</tbody></table>
<h3 id="4-原型方法-Set-prototype"><a href="#4-原型方法-Set-prototype" class="headerlink" title="4 原型方法 Set.prototype."></a>4 原型方法 <code>Set.prototype.</code></h3><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>add(value)</code></td>
<td>向 Set 末尾添加元素，返回 Set</td>
</tr>
<tr>
<td><code>delete(value)</code></td>
<td>从 Set 中删除指定元素，成功删除返回 true，否则返回 false</td>
</tr>
<tr>
<td><code>has(value)</code></td>
<td>判断 Set 中是否有指定的元素</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清空 Set</td>
</tr>
<tr>
<td><code>keys()</code></td>
<td>由于 Set 结构没有键只有值，<code>keys()</code> 与 <code>values()</code> 完全一样</td>
</tr>
<tr>
<td><code>values()</code></td>
<td>返回值的迭代器对象，值就是 Set 元素</td>
</tr>
<tr>
<td><code>entries()</code></td>
<td>返回键值对的迭代器对象，键值对形式为<code>[value, value]</code>，Set 中的元素即是键也是值</td>
</tr>
<tr>
<td><code>forEach(callback[, thisArg])</code></td>
<td>遍历 Set，按插入顺序依次执行回调函数</td>
</tr>
</tbody></table>
<ul>
<li><code>callback([currentValue[, currentKey[, set]]])</code><ul>
<li><code>currentValue</code><ul>
<li>当前元素</li>
</ul>
</li>
<li><code>currentKey</code><ul>
<li>由于 Set 没有键，<code>currentKey</code> 与 <code>currentValue</code> 永远都一样，也是当前元素</li>
</ul>
</li>
<li><code>set</code><ul>
<li>当前Set</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-Set-↔-数组"><a href="#5-Set-↔-数组" class="headerlink" title="5 Set ↔ 数组"></a>5 Set ↔ 数组</h3><table>
<thead>
<tr>
<th>方式</th>
<th>转换</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>[...set]</code></td>
<td>Set → 数组</td>
<td>展开语法，可以展开可迭代对象</td>
</tr>
<tr>
<td><code>Array.from(set)</code></td>
<td>Set → 数组</td>
<td>数组静态方法，将可迭代对象转为数组</td>
</tr>
<tr>
<td><code>new Set(arr)</code></td>
<td>数组 → Set</td>
<td>Set 构造方法，将数组转为 Set</td>
</tr>
</tbody></table>
<h2 id="6-2-WeakSet"><a href="#6-2-WeakSet" class="headerlink" title="6.2 WeakSet"></a>6.2 WeakSet</h2><ol>
<li>用法同 Set 大致相同</li>
<li>与 Set 的区别<ol>
<li>WeakSet 只能存引用数据类型</li>
<li>WeakSet 是弱引用<ul>
<li>当对象引用数量为 0 时，会被垃圾回收掉，弱引用的意思就是不会增加对象的引用数量。</li>
</ul>
</li>
<li>WeakSet 不可遍历<ul>
<li>因为WeakSet 是弱引用，其中的对象随时有可能别垃圾回收掉</li>
</ul>
</li>
<li>没有<code>size</code> 属性</li>
<li>原型方法只有 <code>add() delete() has()</code></li>
</ol>
</li>
</ol>
<h2 id="6-3-Map"><a href="#6-3-Map" class="headerlink" title="6.3 Map"></a>6.3 Map</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>Map 是键值对的集合，且键有序（存取一致）</li>
<li>对象的键只能是字符串，Map 的键可以是任何值</li>
<li>如果键相等，后边的值回覆盖前边</li>
<li>判断键相等 基于 <code>sameValueZero</code> 算法<ul>
<li>类似 <code>===</code>，除了NaN，<code>NaN === NaN</code>返回 <code>false</code>，但是在 Map 中看作相等</li>
</ul>
</li>
</ol>
<h3 id="2-构造函数-1"><a href="#2-构造函数-1" class="headerlink" title="2 构造函数"></a>2 构造函数</h3><ul>
<li><code>new Map([iterable])</code><ul>
<li><code>iterable</code><ul>
<li>可迭代对象，其元素为键值对。</li>
<li>如数组为 <code>[[&#39;name&#39;,&#39;xiaoming&#39;],[&#39;age&#39;,18]]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-原型属性-Map-prototype"><a href="#3-原型属性-Map-prototype" class="headerlink" title="3 原型属性 Map.prototype."></a>3 原型属性 <code>Map.prototype.</code></h3><table>
<thead>
<tr>
<th>原型属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>size</code></td>
<td>Map 集合中键值对的个数</td>
</tr>
</tbody></table>
<h3 id="4-原型方法-Map-prototype"><a href="#4-原型方法-Map-prototype" class="headerlink" title="4 原型方法 Map.prototype."></a>4 原型方法 <code>Map.prototype.</code></h3><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>set(key, value)</code></td>
<td>向 Map 添加键值对，返回 Map</td>
</tr>
<tr>
<td><code>get(key)</code></td>
<td>根据 <code>key</code> 获取 <code>value</code>，没有返回 <code>undefined</code></td>
</tr>
<tr>
<td><code>delete(key)</code></td>
<td>根据 <code>key</code> 删除键值对，删除成功返回 <code>true</code>，否则返回 <code>false</code></td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清空 Map</td>
</tr>
<tr>
<td><code>has(key)</code></td>
<td>判断指定 <code>key</code> 的元素是否存在</td>
</tr>
<tr>
<td><code>keys()</code></td>
<td>返回键的迭代器对象</td>
</tr>
<tr>
<td><code>values()</code></td>
<td>返回值的迭代器对象</td>
</tr>
<tr>
<td><code>entries()</code></td>
<td>返回键值对的迭代器对象，键值对形式为<code>[key, value]</code></td>
</tr>
<tr>
<td><code>forEach(callback[, thisArg])</code></td>
<td>遍历 Map，按键插入顺序依次执行回调函数</td>
</tr>
</tbody></table>
<h3 id="5-Map-↔-数组"><a href="#5-Map-↔-数组" class="headerlink" title="5 Map ↔ 数组"></a>5 Map ↔ 数组</h3><table>
<thead>
<tr>
<th>方式</th>
<th>转换</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>[...map]</code></td>
<td>Map → 数组</td>
<td>展开语法，可以展开可迭代对象</td>
</tr>
<tr>
<td><code>Array.from(map)</code></td>
<td>Map → 数组</td>
<td>数组静态方法，将可迭代对象转为数组</td>
</tr>
<tr>
<td><code>new Map([[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]])</code></td>
<td>数组 → Map</td>
<td>将一个二维键值对数组转换成一个 Map 对象</td>
</tr>
</tbody></table>
<h2 id="6-4-WeakMap"><a href="#6-4-WeakMap" class="headerlink" title="6.4 WeakMap"></a>6.4 WeakMap</h2><ol>
<li>用法同Map大致相同</li>
<li>与Map的区别<ol>
<li>WeakMap 的键只能是引用数据类型（不能为 <code>null</code> ）</li>
<li>WeakMap 的键是弱引用</li>
<li>WeakMap 不能遍历</li>
<li>WeakMap 没有<code>size</code>属性</li>
<li>WeakMap 原型方法只有 <code>set() get() delete() has()</code></li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/11/08/UI/JS%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/11/08/UI/JS%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">JS引用类型-函数</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-11-08 21:08:36 / 修改时间：21:11:33" itemprop="dateCreated datePublished" datetime="2020-11-08T21:08:36+08:00">2020-11-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>每个 JavaScript 函数都是一个 <code>Function</code> 实例</li>
<li>函数作为对象中的属性通常称为方法</li>
</ol>
<h1 id="二-定义函数"><a href="#二-定义函数" class="headerlink" title="二 定义函数"></a>二 定义函数</h1><h2 id="2-1-方式"><a href="#2-1-方式" class="headerlink" title="2.1 方式"></a>2.1 方式</h2><h3 id="1-函数声明"><a href="#1-函数声明" class="headerlink" title="1 函数声明"></a>1 函数声明</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">参数列表</span>) </span>&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>函数提升（提升优先级高于 <code>var</code> 变量提升），所以可以在定义函数之前的位置调用函数</li>
<li>声明的函数会添加到 <code>window</code> 对象中</li>
<li>优先级高于函数表达式</li>
</ol>
<h3 id="2-函数表达式"><a href="#2-函数表达式" class="headerlink" title="2 函数表达式"></a>2 函数表达式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>/<span class="keyword">let</span>/<span class="keyword">const</span> 函数名 = <span class="function"><span class="keyword">function</span> (<span class="params">参数列表</span>) </span>&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>var</code> 会有变量提升，但不会赋值，即相当于函数没有提升，所以不可以在定义函数之前的位置调用函数</li>
<li><code>var</code> 声明的函数会添加到 <code>window</code> 对象中，但 <code>let/const</code> 则不会</li>
</ol>
<h3 id="3-Function-构造函数"><a href="#3-Function-构造函数" class="headerlink" title="3 Function 构造函数"></a>3 Function 构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var/let/const 函数名 = new Function(&quot;参数列表&quot;,&quot;函数体&quot;);</span><br></pre></td></tr></table></figure>

<ol>
<li><code>var</code> 会有变量提升，但不会赋值，即相当于函数没有提升</li>
<li><code>var</code> 声明的函数会添加到 <code>window</code> 对象中，但 <code>let/const</code> 则不会</li>
</ol>
<h2 id="2-2-参数"><a href="#2-2-参数" class="headerlink" title="2.2 参数"></a>2.2 参数</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><p>形参 <code>parameter</code> ；实参 <code>argument</code></p>
<ul>
<li>形参是默认声明的，不需用 <code>var/let/const</code> 修饰</li>
<li>实参数量小于形参时，没有传递的形参值为 <code>undefined</code></li>
<li>实参数量大于形参时，多余的实参将忽略并不会报错</li>
</ul>
</li>
<li><p>在形参上可以直接定义参数默认值，当对应实参没有值或值为 undefined 时，使用默认值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b = <span class="number">2</span></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-arguments"><a href="#2-arguments" class="headerlink" title="2 arguments"></a>2 arguments</h3><ul>
<li><code>arguments</code> 对象是一个类数组对象，存储了传递的所有实参</li>
<li><code>arguments</code> 是所有函数中都可用的局部变量，箭头函数除外</li>
</ul>
<h3 id="3-剩余参数"><a href="#3-剩余参数" class="headerlink" title="3 剩余参数"></a>3 剩余参数</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>剩余参数是一个数组，用于接收形参外的所有参数（类似于 java 可变参数）</li>
<li>剩余参数必须是最后一个参数</li>
</ol>
<h4 id="2-语法"><a href="#2-语法" class="headerlink" title="2 语法"></a>2 语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">a, b, ...theArgs</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-剩余参数和-arguments-对象的区别"><a href="#4-剩余参数和-arguments-对象的区别" class="headerlink" title="4 剩余参数和 arguments 对象的区别"></a>4 剩余参数和 arguments 对象的区别</h4><ol>
<li>剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。</li>
<li>arguments 对象不是一个真正的数组，而剩余参数是真正的 Array 实例，即剩余参数可以使用所有的数组方法</li>
</ol>
<h1 id="三-立即执行函数-IIFE"><a href="#三-立即执行函数-IIFE" class="headerlink" title="三 立即执行函数 IIFE"></a>三 立即执行函数 IIFE</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol>
<li><code>Imdiately Invoked Function Expression</code></li>
<li>不必为函数命名</li>
<li>形成单独的作用域，封装遍历，避免重名…</li>
</ol>
<h2 id="3-2-语法"><a href="#3-2-语法" class="headerlink" title="3.2 语法"></a>3.2 语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">形参列表</span>)</span>&#123;&#125;(实参列表)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">形参列表</span>)</span>&#123;&#125;</span><br><span class="line">)(实参列表)</span><br></pre></td></tr></table></figure>

<h1 id="四-箭头函数（lambda）"><a href="#四-箭头函数（lambda）" class="headerlink" title="四 箭头函数（lambda）"></a>四 箭头函数（lambda）</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ol>
<li>箭头函数内部的<code>this</code> 是固定的，指向定义时所在的环境的 <code>this</code></li>
<li>箭头函数不可以当作构造函数，也就是说，不可以使用 <code>new</code> 命令</li>
<li>箭头函数内部不存在 <code>arguments</code> 对象</li>
<li>箭头函数不可以使用<code>yield</code>命令，因此箭头函数不能用作 <code>Generator</code> 函数</li>
</ol>
<h2 id="4-2-语法"><a href="#4-2-语法" class="headerlink" title="4.2 语法"></a>4.2 语法</h2><ol>
<li><p>基础语法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(param1, param2, …, paramN) =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>没有参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当且仅当只有一个参数时，小括号可以省略</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">singleParam =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数体只有一句且是返回语句时，<code>return</code>、分号和大括号都可以省略</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(param1, param2, …, paramN) =&gt;&#123; <span class="keyword">return</span> expression; &#125;</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line">(param1, param2, …, paramN) =&gt; expression</span><br><span class="line"></span><br><span class="line"><span class="comment">//  注意：如果返回的是一个对象，要用()包括，因为&#123;&#125;会被认为是一个代码块</span></span><br><span class="line">(param1, param2, …, paramN) =&gt; (&#123;<span class="attr">name</span>: <span class="string">'xiaoming'</span>&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="五-Function"><a href="#五-Function" class="headerlink" title="五 Function"></a>五 Function</h1><h2 id="5-1-构造函数"><a href="#5-1-构造函数" class="headerlink" title="5.1 构造函数"></a>5.1 构造函数</h2><ul>
<li><code>new Function (variableStr, functionBodyStr)</code><ul>
<li><code>variableStr</code><ul>
<li>形参字符串，字符串中多个参数用逗号分隔</li>
</ul>
</li>
<li><code>functionBodyStr</code><ul>
<li>函数体的字符串</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-2-实例属性"><a href="#5-2-实例属性" class="headerlink" title="5.2 实例属性"></a>5.2 实例属性</h2><table>
<thead>
<tr>
<th>实例属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>length</code></td>
<td>函数的形参个数</td>
</tr>
<tr>
<td><code>name</code></td>
<td>函数的名称</td>
</tr>
</tbody></table>
<h2 id="5-3-原型方法-Function-prototype"><a href="#5-3-原型方法-Function-prototype" class="headerlink" title="5.3 原型方法 Function.prototype."></a>5.3 原型方法 <code>Function.prototype.</code></h2><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>call(thisArg, arg1, arg2, ...)</code></td>
<td>使用指定的 <code>this</code> 值和实参列表来调用此函数</td>
<td>执行函数</td>
</tr>
<tr>
<td><code>apply(thisArg, [argsArray])</code></td>
<td>同<code>call()</code>，不同的是接受的是一个实参数组</td>
<td>执行函数</td>
</tr>
<tr>
<td><code>bind(thisArg[, arg1[, arg2[, ...]]])</code></td>
<td>使用指定的 <code>this</code> 和实参列表创建一个原函数的拷贝并返回，<code>bind</code> 实参优先级高于调用实参</td>
<td>创建函数</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/11/08/UI/JS%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/11/08/UI/JS%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">JS引用类型-数组</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-11-08 21:08:32 / 修改时间：21:11:38" itemprop="dateCreated datePublished" datetime="2020-11-08T21:08:32+08:00">2020-11-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>数组都是 <code>Array</code> 的实例</li>
<li>数组可以存任意类型的数据</li>
<li>数组长度可变</li>
<li>ES6 明确数组中空位值为 <code>undefined</code></li>
</ol>
<h1 id="二-数组管理"><a href="#二-数组管理" class="headerlink" title="二 数组管理"></a>二 数组管理</h1><h2 id="2-1-创建数组"><a href="#2-1-创建数组" class="headerlink" title="2.1 创建数组"></a>2.1 创建数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 数组字面量</span></span><br><span class="line"><span class="keyword">let</span> arr = [ele0, ele1, ..., eleN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 Array 构造函数</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-清空数组"><a href="#2-2-清空数组" class="headerlink" title="2.2 清空数组"></a>2.2 清空数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 将原数组指向一个空数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 将数组长度置为 0</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 使用 splice() 方法</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.splice(<span class="number">0</span>, arr.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 循环一个个删</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">while</span> (arr.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	arr.pop();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三-Array"><a href="#三-Array" class="headerlink" title="三 Array"></a>三 Array</h1><h2 id="3-1-构造函数"><a href="#3-1-构造函数" class="headerlink" title="3.1 构造函数"></a>3.1 构造函数</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>new Array(arrayLength)</code></td>
<td>创建一个指定长度的数组，<code>arrayLength</code> ：0-2<sup>32</sup>-1 之间的整数</td>
</tr>
<tr>
<td><code>new Array(ele0, ele1[, ...[, eleN]])</code></td>
<td>创建一个包含指定元素的数组</td>
</tr>
<tr>
<td><code>Array(...)</code></td>
<td>和 <code>new Array(...)</code> 是等同的</td>
</tr>
</tbody></table>
<h2 id="3-2-实例属性"><a href="#3-2-实例属性" class="headerlink" title="3.2 实例属性"></a>3.2 实例属性</h2><table>
<thead>
<tr>
<th>实例属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>length</code></td>
<td>读写</td>
<td>数组元素个数</td>
</tr>
</tbody></table>
<h2 id="3-3-静态方法"><a href="#3-3-静态方法" class="headerlink" title="3.3  静态方法"></a>3.3  静态方法</h2><ol>
<li><code>Array.isArray(obj)</code><ul>
<li>如果值是 Array，则返回true，否则返回false</li>
<li>用来弥补<code>typeof</code>，因为<code>typeof 数组</code> 返回的是<code>object</code></li>
</ul>
</li>
<li><code>Array.of(element0[, element1[, ...[, elementN]]])</code><ul>
<li>将一组值转换为数组</li>
<li>用来弥补构造函数，构造函数参数个数不同会导致结果不同。</li>
</ul>
</li>
<li><code>Array.from(arrayLike[, mapFn[, thisArg]])</code><ul>
<li>从一个类数组对象或可迭代对象创建一个新的浅拷贝的数组实例并返回</li>
<li><code>mapFn</code><ul>
<li>如果指定了该参数，新数组中的每个元素都会执行该回调函数</li>
</ul>
</li>
<li><code>thisArg</code><ul>
<li>执行回调函数 mapFn 时的 this 对象</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="3-4-原型方法"><a href="#3-4-原型方法" class="headerlink" title="3.4 原型方法"></a>3.4 原型方法</h2><h3 id="1-获取"><a href="#1-获取" class="headerlink" title="1 获取"></a>1 获取</h3><ol>
<li><code>valueOf()</code><ul>
<li>返回数组本身</li>
</ul>
</li>
<li><code>toString()</code><ul>
<li>返回数组的字符串形式</li>
</ul>
</li>
<li><code>join([separator])</code><ul>
<li>以指定分隔符（默认为逗号）将所有数组成员连接为一个字符串返回</li>
</ul>
</li>
</ol>
<h3 id="2-增删改"><a href="#2-增删改" class="headerlink" title="2 增删改"></a>2 增删改</h3><ol>
<li><code>push(element1, ..., elementN)</code><ul>
<li>将一个或多个元素添加到数组的末尾，并返回该数组的新长度，改变原数组</li>
<li>如果参数为数组，把数组作为元素添加到数组中。(二维数组)</li>
</ul>
</li>
<li><code>pop()</code><ul>
<li>删除并返回最后一个元素，改变原数组</li>
</ul>
</li>
<li><code>unshift(element1, ..., elementN)</code><ul>
<li>将一个或多个元素添加到数组的开头，并返回该数组的新长度，改变原数组</li>
<li>参数可以是数组（二维数组）</li>
</ul>
</li>
<li><code>shift()</code><ul>
<li>删除并返回第一个元素，改变原数组</li>
</ul>
</li>
<li><code>fill(value[, start[, end]])</code><ul>
<li>使用指定值填充数组，可指定开始结束索引，返回修改后的数组</li>
</ul>
</li>
<li><code>splice(start[, deleteCount[, item1[, item2[, ...]]]])</code><ul>
<li>删除目标数组的一部分成员，并可以在删除的位置添加新的数组成员，返回被删除的元素组成的数组，改变原数组</li>
</ul>
</li>
<li><code>slice([begin[, end]])</code><ul>
<li>提取目标数组的一部分，返回一个浅拷贝新数组，原数组不变</li>
</ul>
</li>
<li><code>concat(value1, value2, ..., valueN)</code><ul>
<li>将一个或多个值合并到数组中，返回新数组，不改变原数组</li>
</ul>
</li>
<li><code>copyWithin(target[, start[, end]])</code><ul>
<li>复制数组的一部分到数组指定位置（覆盖原有成员），并返回数组，改变原数组但不改变数组长度（因为会覆盖原有成员）</li>
<li><code>target</code><ul>
<li>目标位置</li>
</ul>
</li>
<li><code>start</code><ul>
<li>复制的起始索引，默认为0</li>
</ul>
</li>
<li><code>end</code><ul>
<li>复制的终止索引（不含），默认为尾部</li>
</ul>
</li>
</ul>
</li>
<li><code>flat([depth])</code><ul>
<li>将数组降维，返回新数组，不改变原数组</li>
<li><code>depth</code><ul>
<li>指定结构深度，默认值为 1，即只可以将二维数组合并成一维数组</li>
</ul>
</li>
</ul>
</li>
<li><code>flatMap(callback[, thisArg])</code><ul>
<li>对数组中每一个元素执行回调函数，然后对返回值组成的数组执行flat()方法，结构深度 depth 值为1，返回新数组</li>
<li><code>callback(currentValue[, index[, array]])</code><ul>
<li><code>currentValue</code>：当前遍历的元素</li>
<li><code>index</code>：当前遍历到的索引</li>
<li><code>array</code>：当前数组</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-查"><a href="#3-查" class="headerlink" title="3 查"></a>3 查</h3><ol>
<li><code>indexOf(searchElement[, fromIndex])</code><ul>
<li>返回第一个匹配索引，如果不存在，则返回 <code>-1</code></li>
</ul>
</li>
<li><code>lastIndexOf(searchElement[, fromIndex])</code><ul>
<li>返回从后往前的第一个匹配索引，如果不存在，则返回 <code>-1</code></li>
</ul>
</li>
<li><code>includes(valueToFind[, fromIndex])</code><ul>
<li>判断数组是否包含指定元素</li>
</ul>
</li>
<li><code>find(callback[, thisArg])</code><ul>
<li>返回数组中第一个满足所提供测试函数（返回true）的元素的值，否则返回 undefined</li>
<li><code>callback(element[, index[, array]])</code><ul>
<li><code>element</code>：当前遍历的元素</li>
<li><code>index</code>：当前遍历到的索引</li>
<li><code>array</code>：当前数组</li>
</ul>
</li>
<li><code>thisArg</code><ul>
<li>执行回调时函数时this 指向的对象。</li>
</ul>
</li>
</ul>
</li>
<li><code>findIndex(callback[, thisArg])</code><ul>
<li>返回数组中第一个满足所提供测试函数（返回true）的元素的索引，否则返回 -1</li>
</ul>
</li>
</ol>
<h3 id="4-排序"><a href="#4-排序" class="headerlink" title="4 排序"></a>4 排序</h3><ol>
<li><code>reverse()</code><ul>
<li>反转数组并返回，改变原数组</li>
</ul>
</li>
<li><code>sort([compareFunction])</code><ul>
<li>默认是按照字典顺序排序，返回排序后的数组，改变原数组</li>
<li><code>compareFunction(value1, value2)</code><ul>
<li>返回一个数字，如果小于0则value1排在value2之前</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="5-循环遍历"><a href="#5-循环遍历" class="headerlink" title="5 循环遍历"></a>5 循环遍历</h3><ol>
<li><code>forEach(callback[, thisArg])</code><ul>
<li><code>callback(currentValue[, index[, array]])</code><ul>
<li><code>currentValue</code>：当前遍历的元素</li>
<li><code>index</code>：当前遍历到的索引</li>
<li><code>array</code>：当前数组</li>
</ul>
</li>
</ul>
</li>
<li><code>keys()</code><ul>
<li>返回数组元素键的迭代器对象</li>
</ul>
</li>
<li><code>values()</code><ul>
<li>返回数组元素值的迭代器对象</li>
</ul>
</li>
<li><code>entries()</code><ul>
<li>返回数组元素键值对的迭代器对象</li>
</ul>
</li>
</ol>
<h3 id="6-扩展方法"><a href="#6-扩展方法" class="headerlink" title="6 扩展方法"></a>6 扩展方法</h3><ol>
<li><code>every(callback[, thisArg])</code><ul>
<li>判断数组元素是否全部能通过指定测试函数，返回布尔值，一个元素返回 <code>false</code>，则 <code>every()</code>立即返回 <code>false</code></li>
<li><code>callback(currentValue[, index[, array]])</code><ul>
<li><code>currentValue</code>：当前遍历的元素</li>
<li><code>index</code>：当前遍历到的索引</li>
<li><code>array</code>：当前数组</li>
</ul>
</li>
</ul>
</li>
<li><code>some(callback[, thisArg])</code><ul>
<li>数组中有至少一个元素通过回调函数的测试就会返回 <code>true</code>；</li>
</ul>
</li>
<li><code>filter(callback[, thisArg])</code><ul>
<li>返回一个新的由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组</li>
</ul>
</li>
<li><code>map(callback[, thisArg])</code><ul>
<li>对数组中每一个元素执行回调函数，返回每一个回调函数结果组成的新数组</li>
</ul>
</li>
<li><code>reduce(callback[, initialValue])</code><ul>
<li>返回回调函数累计处理的结果</li>
<li><code>callback(accumulator, currentValue[, index[, array]])</code><ul>
<li><code>accumulator</code><ul>
<li>第一次循环<ol>
<li>有<code>initialValue</code>，则为<code>initialValue</code></li>
<li>无<code>initialValue</code>，则为数组第一个元素</li>
</ol>
</li>
<li>从第二次循环往后为回调函数返回值</li>
</ul>
</li>
<li><code>currentValue</code><ul>
<li>数组中当前循环的元素</li>
<li>第一次循环时，如果没有<code>initialValue</code>，由于<code>accumulator</code>是数组第一个元素，则<code>currentValue</code>会从第二个元素开始循环</li>
</ul>
</li>
<li><code>index</code><ul>
<li>数组中当前循环的元素的索引</li>
</ul>
</li>
<li><code>array</code><ul>
<li>当前数组</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>reduceRight(callback[, initialValue])</code><ul>
<li>与<code>reduce()</code>相似，只是从右向左遍历数组</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/11/08/UI/JS%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/11/08/UI/JS%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">JS引用类型-对象</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-11-08 21:08:26 / 修改时间：21:11:27" itemprop="dateCreated datePublished" datetime="2020-11-08T21:08:26+08:00">2020-11-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-创建对象"><a href="#一-创建对象" class="headerlink" title="一 创建对象"></a>一 创建对象</h1><h2 id="1-1-Object-构造函数"><a href="#1-1-Object-构造函数" class="headerlink" title="1.1 Object 构造函数"></a>1.1 Object 构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Object([value])</span><br></pre></td></tr></table></figure>

<h2 id="1-2-对象字面量"><a href="#1-2-对象字面量" class="headerlink" title="1.2  对象字面量"></a>1.2  对象字面量</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>对象字面量内部调用了 <code>Object</code> 的构造函数</li>
<li>对象字面量与 <code>json</code> 的区别<ol>
<li><code>json</code> 属性只能是字符串</li>
<li><code>json</code> 值不能是函数和 <code>undefined</code></li>
</ol>
</li>
</ol>
<h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2 语法"></a>2 语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 标准形式</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	key: value,</span><br><span class="line">	key: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 方法定义可以简化</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	key: value,</span><br><span class="line">	key()&#123;&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 如果属性名是一个表达式，则使用[]包裹，意思是取表达式的值</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	[expr]: value,</span><br><span class="line">	key()&#123;&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 如果属性名和属性值与外部变量名和值都相同，可以简写</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"mm"</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    <span class="comment">// 可以简写</span></span><br><span class="line">	name,</span><br><span class="line">	key()&#123;&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-Object-的-create-方法"><a href="#1-3-Object-的-create-方法" class="headerlink" title="1.3 Object 的 create 方法"></a>1.3 Object 的 <code>create</code> 方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种方式可以指定原型</span></span><br><span class="line"><span class="built_in">Object</span>.create(proto[, propertiesObject])</span><br></pre></td></tr></table></figure>

<h2 id="1-4-构造函数"><a href="#1-4-构造函数" class="headerlink" title="1.4 构造函数"></a>1.4 构造函数</h2><h3 id="1-内置构造函数"><a href="#1-内置构造函数" class="headerlink" title="1 内置构造函数"></a>1 内置构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Array()</span><br><span class="line">new Function()</span><br><span class="line">new String()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="2-自定义构造函数"><a href="#2-自定义构造函数" class="headerlink" title="2 自定义构造函数"></a>2 自定义构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 定义构造函数，构造函数名首字母大写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 构造函数名(<span class="params">形参列表</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.属性 = 值;</span><br><span class="line">	<span class="keyword">this</span>.方法 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 使用自定义构造创建对象</span></span><br><span class="line"><span class="keyword">new</span> 构造函数名(实参列表);</span><br></pre></td></tr></table></figure>

<h2 id="1-5-工厂函数"><a href="#1-5-工厂函数" class="headerlink" title="1.5 工厂函数"></a>1.5 工厂函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">userFactory</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">	<span class="comment">// 1</span></span><br><span class="line">	obj.name = name;</span><br><span class="line">	obj.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">	<span class="comment">// 2 简写</span></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		name,</span><br><span class="line">		show()&#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>与自定义构造函数方式的区别<ol>
<li>工厂函数是函数调用，自定义构造是 <code>new</code></li>
<li>工厂函数是函数名称小写，自定义构造名称大写</li>
<li>工厂函数内部需要显式创建一个对象，然后根据参数赋值后再显式返</li>
<li>自定义构造根据参数自动创建一个对象并返回</li>
</ol>
</li>
</ul>
<h1 id="二-对象属性"><a href="#二-对象属性" class="headerlink" title="二 对象属性"></a>二 对象属性</h1><h2 id="2-1-属性描述符"><a href="#2-1-属性描述符" class="headerlink" title="2.1 属性描述符"></a>2.1 属性描述符</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>property descriptor</code></li>
<li>JS 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为属性描述符，或者叫属性描述对象</li>
<li>元属性：属性描述符中的属性，用来描述对象属性的元信息，即描述对象属性的属性</li>
</ol>
<h3 id="2-分类（只能取其一）"><a href="#2-分类（只能取其一）" class="headerlink" title="2 分类（只能取其一）"></a>2 分类（只能取其一）</h3><table>
<thead>
<tr>
<th>分类</th>
<th>可以具有的元属性</th>
</tr>
</thead>
<tbody><tr>
<td>数据描述符</td>
<td><code>configurable enumerable value writable</code></td>
</tr>
<tr>
<td>存取描述符</td>
<td><code>configurable enumerable get set</code></td>
</tr>
</tbody></table>
<h3 id="3-元属性"><a href="#3-元属性" class="headerlink" title="3 元属性"></a>3 元属性</h3><table>
<thead>
<tr>
<th>元属性</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>value</code></td>
<td>表示该属性的值</td>
<td><code>undefined</code></td>
</tr>
<tr>
<td><code>writable</code></td>
<td>表示该属性是否可写</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>enumerable</code></td>
<td>表示该属性是否可遍历</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>configurable</code></td>
<td>1 该属性是否可删除<br>2 该属性的属性描述符是否可修改</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>get</code></td>
<td>表示该属性的取值函数 <code>getter</code></td>
<td><code>undefined</code></td>
</tr>
<tr>
<td><code>set</code></td>
<td>表示该属性的存值函数 <code>setter</code></td>
<td><code>undefined</code></td>
</tr>
</tbody></table>
<h2 id="2-2-属性管理"><a href="#2-2-属性管理" class="headerlink" title="2.2 属性管理"></a>2.2 属性管理</h2><h3 id="1-读写"><a href="#1-读写" class="headerlink" title="1 读写"></a>1 读写</h3><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>obj.property</code></td>
<td>必须是确定的属性名，且名称不特殊（数字、空格…）</td>
</tr>
<tr>
<td><code>obj[&#39;property&#39;]</code></td>
<td>属性名可以是表达式和变量，或者名称比较特殊</td>
</tr>
</tbody></table>
<h3 id="2-判断"><a href="#2-判断" class="headerlink" title="2 判断"></a>2 判断</h3><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>prop in obj</code></td>
<td>对象中是否有指定属性</td>
</tr>
</tbody></table>
<h3 id="3-删除"><a href="#3-删除" class="headerlink" title="3 删除"></a>3 删除</h3><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>delete object.property</code></td>
<td>删除属性，所有情况都返回 <code>true</code></td>
</tr>
<tr>
<td><code>delete object[&#39;property&#39;]</code></td>
<td>删除属性，所有情况都返回 <code>true</code></td>
</tr>
</tbody></table>
<h3 id="4-访问器（getter-setter）"><a href="#4-访问器（getter-setter）" class="headerlink" title="4 访问器（getter/setter）"></a>4 访问器（getter/setter）</h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>JS 中 <code>getter/setter</code> 的调用是当成属性来访问，自动调用方法</li>
<li>调用方式与属性访问方式一样<ol>
<li><code>obj.访问器名</code></li>
<li><code>obj[&#39;访问器名&#39;]</code></li>
</ol>
</li>
</ol>
<h4 id="2-语法-1"><a href="#2-语法-1" class="headerlink" title="2 语法"></a>2 语法</h4><table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>get prop() { ... }</code></td>
<td>访问器名称是一个有效标识符</td>
</tr>
<tr>
<td><code>get [expression]() { ... }</code></td>
<td>访问器名称可以是一个表达式</td>
</tr>
<tr>
<td><code>set prop(val) { . . . }</code></td>
<td>访问器名称是一个有效标识符</td>
</tr>
<tr>
<td><code>set [expression](val) { . . . }</code></td>
<td>访问器名称可以是一个表达式</td>
</tr>
</tbody></table>
<h4 id="3-定义方式"><a href="#3-定义方式" class="headerlink" title="3 定义方式"></a>3 定义方式</h4><ol>
<li><p>通过配置属性描述符的元属性定义访问器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	name : <span class="string">'小明'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">	<span class="keyword">get</span>() &#123;</span><br><span class="line">		<span class="keyword">return</span> obj.name; <span class="comment">// 注意：此处跟取值方式一样，也会调用get，会无限循环</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="keyword">set</span>(value) &#123;</span><br><span class="line">		obj.name = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.name; <span class="comment">// 调用get取值</span></span><br><span class="line">obj.name = <span class="string">'旺财'</span>; <span class="comment">// 调用set设置值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象字面量中直接定义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	_name: <span class="string">'小明'</span>,</span><br><span class="line">	<span class="keyword">get</span> name() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="keyword">set</span> name(value) &#123;</span><br><span class="line">		<span class="keyword">this</span>._name = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="三-对象拷贝"><a href="#三-对象拷贝" class="headerlink" title="三 对象拷贝"></a>三 对象拷贝</h1><h2 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h2><ol>
<li><p>浅拷贝</p>
<ul>
<li>如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 </li>
<li>一个对象修改可能会影响到另一个对象</li>
</ul>
</li>
<li><p>深拷贝</p>
<ul>
<li>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象</li>
<li>一个对象修改不会影响到另一个对象</li>
</ul>
</li>
</ol>
<h2 id="3-2-浅拷贝方式"><a href="#3-2-浅拷贝方式" class="headerlink" title="3.2 浅拷贝方式"></a>3.2 浅拷贝方式</h2><h3 id="1-for-in"><a href="#1-for-in" class="headerlink" title="1 for... in"></a>1 <code>for... in</code></h3><ul>
<li><p>创建新对象，然后使用<code>for...in</code>遍历原对象属性并连同值一起添加到新对象上</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> source = &#123;<span class="attr">name</span>:<span class="string">'an3'</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> cp = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> source)&#123;</span><br><span class="line">	<span class="keyword">if</span>(source.hasOwnProperty(key)&#123;</span><br><span class="line">		cp[key] = source[key];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-Object-assign-target-sources"><a href="#2-Object-assign-target-sources" class="headerlink" title="2 Object.assign(target, ...sources)"></a>2 <code>Object.assign(target, ...sources)</code></h3><ul>
<li><p>将目标对象设为空对象，就相当于返回了原对象的浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> source = &#123;<span class="attr">name</span>:<span class="string">'an3'</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> cp = <span class="built_in">Object</span>.assign(&#123;&#125;, source);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-展开语法"><a href="#3-展开语法" class="headerlink" title="3 展开语法"></a>3 展开语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> source = &#123;<span class="attr">name</span>:<span class="string">'an3'</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> cp = &#123;...source&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-深拷贝方式"><a href="#3-3-深拷贝方式" class="headerlink" title="3.3 深拷贝方式"></a>3.3 深拷贝方式</h2><h3 id="1-JSON"><a href="#1-JSON" class="headerlink" title="1 JSON"></a>1 <code>JSON</code></h3><ol>
<li>步骤<ol>
<li><code>JSON.stringify()</code>：将一个对象序列成一个字符串</li>
<li><code>JSON.parse()</code>：将字符串反序列化生成深拷贝对象</li>
</ol>
</li>
<li>注意<ol>
<li>拷贝的对象的值中如果有 <code>函数、undefined、symbol</code> 则经过 <code>JSON.stringify()</code> 序列化后的 <code>JSON</code> 字符串中这个键值对会消失</li>
<li>无法拷贝不可枚举的属性，无法拷贝对象的原型链</li>
<li>拷贝 <code>Date</code> 引用类型会变成字符串</li>
<li>拷贝 <code>RegExp</code> 引用类型会变成空对象</li>
<li>对象中含有 <code>NaN、Infinity、-Infinity</code> ，则序列化的结果会变成 <code>null</code></li>
<li>无法拷贝对象的循环应用，即 <code>obj[key] = obj</code></li>
</ol>
</li>
</ol>
<h3 id="2-递归"><a href="#2-递归" class="headerlink" title="2 递归"></a>2 递归</h3><ul>
<li><p>原理就是浅拷贝只拷贝一层，利用递归，如果这一层属性的值是引用类型，就再拷贝一层 …</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 对象的属性值有可能是数组，判断一下防止递归时把数组变成了对象</span></span><br><span class="line">	<span class="keyword">let</span> cpObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">	<span class="comment">// Object.entries()方法对于对象和数组返回结果形式是一样的</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">const</span> [k, v] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj)) &#123;</span><br><span class="line">		<span class="comment">// 判断对象属性如果是引用类型就递归拷贝</span></span><br><span class="line">		cpObj[k] = <span class="keyword">typeof</span> v == <span class="string">'object'</span> ? deepCopy(v) : v;</span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> cpObj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="四-Object"><a href="#四-Object" class="headerlink" title="四 Object"></a>四 Object</h1><h2 id="4-1-构造函数"><a href="#4-1-构造函数" class="headerlink" title="4.1 构造函数"></a>4.1 构造函数</h2><table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>new Object([value])</code></td>
<td>构造函数</td>
<td>创建一个对象</td>
</tr>
<tr>
<td><code>Object([value])</code></td>
<td>类型转换函数</td>
<td>将 <code>value</code> 转成一个对象</td>
</tr>
</tbody></table>
<ul>
<li><code>value</code> ：<ol>
<li>为空或者是 <code>undefined null</code>，返回一个空对象</li>
<li>是基本类型的值则返回其包装对象</li>
<li>是引用类型则直接返回</li>
</ol>
</li>
</ul>
<h2 id="4-2-静态方法"><a href="#4-2-静态方法" class="headerlink" title="4.2 静态方法"></a>4.2 静态方法</h2><h3 id="1-属性"><a href="#1-属性" class="headerlink" title="1 属性"></a>1 属性</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object.keys(obj)</code></td>
<td>返回对象自身可枚举属性键的数组</td>
</tr>
<tr>
<td><code>Object.values(obj)</code></td>
<td>返回对象自身可枚举属性值的数组</td>
</tr>
<tr>
<td><code>Object.entries(obj)</code></td>
<td>返回对象自身可枚举属性键值对的数组</td>
</tr>
<tr>
<td><code>Object.getOwnPropertyNames(obj)</code></td>
<td>返回对象自身的所有属性（包含可枚举和不可枚举属性，不包含 <code>Symbol</code> 属性）键的数组</td>
</tr>
<tr>
<td><code>Object.getOwnPropertySymbols(obj)</code></td>
<td>返回对象自身的所有 <code>Symbol</code> 属性的数组</td>
</tr>
</tbody></table>
<h3 id="2-属性描述符"><a href="#2-属性描述符" class="headerlink" title="2 属性描述符"></a>2 属性描述符</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object.getOwnPropertyDescriptor(obj, prop)</code></td>
<td>获取对象自身某个属性的属性描述符</td>
</tr>
<tr>
<td><code>Object.getOwnPropertyDescriptors(obj)</code></td>
<td>获取对象自身所有属性的属性描述符</td>
</tr>
<tr>
<td><code>Object.defineProperty(obj, prop, descriptor)</code></td>
<td>如果对象自身存在指定属性，则修改它的属性描述符，否则为对象添加指定属性并定义属性描述符，返回该对象</td>
</tr>
<tr>
<td><code>Object.defineProperties(obj, props)</code></td>
<td>修改或添加对象多个属性的属性描述对象，返回该对象</td>
</tr>
</tbody></table>
<h3 id="3-创建对象"><a href="#3-创建对象" class="headerlink" title="3 创建对象"></a>3 创建对象</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object.create(proto[, propertiesObject])</code></td>
<td>根据原型对象和属性（使用属性描述符定义），创建一个新的对象</td>
</tr>
<tr>
<td><code>Object.fromEntries(iterable)</code></td>
<td>把键值对列表转换为一个对象，是 <code>Object.entries()</code> 的反转</td>
</tr>
<tr>
<td><code>Object.assign(target, ...sources)</code></td>
<td>将 n 个源对象的所有可枚举属性复制到目标对象，并返回目标对象</td>
</tr>
</tbody></table>
<ul>
<li><code>Object.assign(target, ...sources)</code><ol>
<li>如果目标对象与源对象有同名属性，或多个源对象有同名属性，后边覆盖前边</li>
<li><code>Object.assign</code> 方法实行的是浅拷贝</li>
<li>数组会被当作对象，即相同索引会覆盖</li>
<li>如果属性值是取值函数，会计算后再复制</li>
</ol>
</li>
</ul>
<h3 id="4-原型对象"><a href="#4-原型对象" class="headerlink" title="4 原型对象"></a>4 原型对象</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object.getPrototypeOf(obj)</code></td>
<td>获取对象的原型对象，即<code>obj.__proto__</code></td>
</tr>
<tr>
<td><code>Object.setPrototypeOf(obj, prototype)</code></td>
<td>获取对象的原型对象</td>
</tr>
</tbody></table>
<h3 id="5-比较"><a href="#5-比较" class="headerlink" title="5 比较"></a>5 比较</h3><ul>
<li><code>Object.is(value1, value2)</code><ul>
<li>判断两个值是否相等，不会作类型转换</li>
<li>与<code>===</code>的区别<ol>
<li><code>===</code> 认为<code>-0</code>和<code>+0</code>相等，此方法认为不相等</li>
<li><code>===</code> 认为<code>NaN</code>和<code>NaN</code>不相等，此方法认为相等</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="6-状态"><a href="#6-状态" class="headerlink" title="6 状态"></a>6 状态</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object.preventExtensions(obj)</code></td>
<td>让一个对象变的不可扩展，即永远不能添加新的属性</td>
</tr>
<tr>
<td><code>Object.isExtensible(obj)</code></td>
<td>判断一个对象是否可扩展</td>
</tr>
<tr>
<td><code>Object.seal(obj)</code></td>
<td>封闭一个对象，此对象不可扩展且对象所有自身属性的<code>configurable</code>标记为 <code>false</code>，即不能添加、删除属性，属性修饰符不可配置</td>
</tr>
<tr>
<td><code>Object.isSealed(obj)</code></td>
<td>判断一个对象是否被封闭</td>
</tr>
<tr>
<td><code>Object.freeze(obj)</code></td>
<td>冻结一个对象，此对象不可扩展且对象所有自身属性 <code>writable configurable</code> 标记为 <code>false</code>，即不能添加、修改和删除属性，属性修饰符不可配置</td>
</tr>
<tr>
<td><code>Object.isFrozen(obj)</code></td>
<td>判断一个对象是否被冻结</td>
</tr>
</tbody></table>
<h2 id="4-3-原型方法-Object-prototype"><a href="#4-3-原型方法-Object-prototype" class="headerlink" title="4.3 原型方法 Object.prototype."></a>4.3 原型方法 <code>Object.prototype.</code></h2><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>toString()</code></td>
<td>默认返回 <code>[object type]</code>，通常会覆盖</td>
</tr>
<tr>
<td><code>toLocaleString()</code></td>
<td>默认返回 <code>toString()</code> 的结果，可以覆盖</td>
</tr>
<tr>
<td><code>hasOwnProperty(prop)</code></td>
<td>判断对象自身是否含有某个属性</td>
</tr>
<tr>
<td><code>propertyIsEnumerable(prop)</code></td>
<td>判断某个属性是否可枚举</td>
</tr>
<tr>
<td><code>isPrototypeOf(object)</code></td>
<td>判断调用对象是否在另一个对象的原型链上</td>
</tr>
<tr>
<td><code>valueOf()</code></td>
<td>返回对象原始值，若没有原始值，返回对象本身，通常会覆盖</td>
</tr>
</tbody></table>
<ol>
<li><p><code>isPrototypeOf(object)</code> 和 <code>instanceof</code> 的区别</p>
<ol>
<li><code>A instanceof B</code> ：判断 <code>B.prototype</code>是否在 <code>A</code> 的原型链上</li>
<li><code>B.isPrototypeOf(A)</code>：判断 <code>B</code> 是否在 <code>A</code> 的原型链上</li>
</ol>
</li>
<li><p><code>valueOf()</code> 返回值</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>对象</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td><code>Number</code></td>
<td>数值</td>
</tr>
<tr>
<td><code>Boolean</code></td>
<td>布尔值</td>
</tr>
<tr>
<td><code>String</code></td>
<td>字符串值</td>
</tr>
<tr>
<td><code>Object</code></td>
<td>对象本身</td>
</tr>
<tr>
<td><code>Array</code></td>
<td>数组本身</td>
</tr>
<tr>
<td><code>Function</code></td>
<td>函数本身</td>
</tr>
<tr>
<td><code>Date</code></td>
<td>距离1970-01-01 00:00:00 的毫秒数</td>
</tr>
</tbody></table>
<h1 id="五-代理"><a href="#五-代理" class="headerlink" title="五 代理"></a>五 代理</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol>
<li>代理（拦截器）是对象的访问控制</li>
<li><code>setter/getter</code> 访问器是对对象属性的访问控制</li>
</ol>
<h2 id="5-2-Proxy（代理对象）"><a href="#5-2-Proxy（代理对象）" class="headerlink" title="5.2 Proxy（代理对象）"></a>5.2 Proxy（代理对象）</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><ul>
<li><code>new Proxy(target, handler)</code><ul>
<li>返回一个代理对象</li>
<li><code>target</code><ul>
<li>用 <code>Proxy</code> 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）</li>
</ul>
</li>
<li><code>handler</code><ul>
<li>处理器对象，有许多拦截相应操作的函数，如果没有配置，则执行默认操作</li>
<li>注意：处理操作都是针对代理对象的，目标对象无效。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-handler（处理器对象）"><a href="#2-handler（处理器对象）" class="headerlink" title="2 handler（处理器对象）"></a>2 handler（处理器对象）</h3><ol>
<li><code>get(target, property, receiver)</code><ul>
<li>参数<ul>
<li><code>target</code><ul>
<li>目标对象</li>
</ul>
</li>
<li><code>property</code><ul>
<li>获取的属性名</li>
</ul>
</li>
<li><code>reveiver</code><ul>
<li>Proxy或者继承Proxy的对象</li>
</ul>
</li>
</ul>
</li>
<li>说明<ul>
<li>get 方法拦截属性的获取，可以返回任何值</li>
</ul>
</li>
</ul>
</li>
<li><code>set(target, property, value, receiver)</code><ul>
<li>参数<ul>
<li><code>value</code><ul>
<li>被设置的新值</li>
</ul>
</li>
</ul>
</li>
<li>说明<ul>
<li>set 方法拦截属性的设置</li>
<li>严格模式下 set 必须返回布尔值，且如果返回false会报错</li>
</ul>
</li>
</ul>
</li>
<li><code>apply(target, thisArg, argumentsList)</code><ul>
<li>参数<ul>
<li><code>target</code><ul>
<li>目标函数</li>
</ul>
</li>
<li><code>thisArg</code><ul>
<li>被调用时的上下文对象</li>
</ul>
</li>
<li><code>argumentsList</code><ul>
<li>被调用时的参数数组</li>
</ul>
</li>
</ul>
</li>
<li>说明<ul>
<li>apply 方法拦截函数调用，可以返回任何值<ol>
<li>直接调用</li>
<li><code>Function.prototype.call()</code> 方式调用</li>
<li><code>Function.prototype.apply()</code> 方式调用</li>
<li><code>Reflet.apply()</code> 方式调用</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><code>has(target, prop)</code><ul>
<li>参数<ul>
<li><code>target</code><ul>
<li>目标对象</li>
</ul>
</li>
<li><code>prop</code><ul>
<li>需要检查是否存在的属性.</li>
</ul>
</li>
</ul>
</li>
<li>说明<ul>
<li>拦截 <code>prop in object</code> 语句，返回布尔值</li>
</ul>
</li>
</ul>
</li>
<li><code>construct(target, argumentsList, newTarget)</code><ul>
<li>参数<ul>
<li><code>target</code><ul>
<li>目标构造函数</li>
</ul>
</li>
<li><code>argumentsList</code><ul>
<li>constructor的参数列表</li>
</ul>
</li>
<li><code>newTarget</code><ul>
<li>生成的代理对象（即代理构造函数）</li>
</ul>
</li>
</ul>
</li>
<li>说明<ul>
<li>拦截new操作，必须返回一个对象</li>
</ul>
</li>
</ul>
</li>
<li><code>deleteProperty(target, prop)</code><ul>
<li>拦截<code>delete</code> 操作，必须返回布尔值</li>
</ul>
</li>
<li><code>defineProperty(target, property, descriptor)</code><ul>
<li>拦截<code>Object.defineProperty()</code>，必须返回布尔值</li>
</ul>
</li>
<li><code>getOwnPropertyDescriptor(target, prop)</code><ul>
<li>拦截 <code>Object.getOwnPropertyDescriptor()</code>，必须返回一个对象或undefined</li>
</ul>
</li>
<li><code>getPrototypeOf(target)</code><ul>
<li>拦截获取原型操作</li>
</ul>
</li>
<li><code>setPrototypeOf(target, prototype)</code><ul>
<li>拦截设置原型操作，返回布尔值</li>
</ul>
</li>
<li><code>preventExtensions(target)</code><ul>
<li>拦截<code>Object.preventExtensions()</code>，返回一个布尔值</li>
</ul>
</li>
<li><code>isExtensible(target)</code><ul>
<li>拦截<code>Object.isExtensible()</code>，必须返回布尔值</li>
</ul>
</li>
<li><code>ownKeys(target)</code><ul>
<li>拦截对象获取自身属性的操作</li>
</ul>
</li>
</ol>
<h1 id="六-Reflect"><a href="#六-Reflect" class="headerlink" title="六 Reflect"></a>六 Reflect</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><ol>
<li><code>Reflect</code> 不是一个构造函数，不能 <code>new</code>，<code>Reflect</code> 的所有属性和方法都是静态的</li>
<li>将 <code>Object</code> 对象的一些明显属于语言内部的方法（如<code>Object.defineProperty()</code>），放到 <code>Reflect</code> 对象上</li>
<li>修改某些 <code>Object</code> 方法的返回结果，让其变得更合理<ul>
<li>如 <code>Object.defineProperty()</code>无法定义属性时，会抛出错误，而<code>Reflect.defineProperty()</code>会返回false</li>
</ul>
</li>
<li>让 <code>Object</code> 操作都变成函数行为<ul>
<li>如 <code>prop in object</code> ，对应<code>Reflect.has(obj, prop)</code></li>
<li><code>delete obj.prop</code>，对应<code>Reflect.deleteProperty(obj, prop)</code></li>
</ul>
</li>
<li><code>Reflect</code> 对象与 <code>Proxy</code> 的 <code>handler</code> 方法完全一致，在使用代理拦截某些操作时，使用 <code>Reflect</code> 的方法可以保证原生行为能正常执行。</li>
</ol>
<h2 id="6-2-静态方法"><a href="#6-2-静态方法" class="headerlink" title="6.2 静态方法"></a>6.2 静态方法</h2><ul>
<li>见 <code>Proxy handler</code></li>
</ul>
<h1 id="七-this"><a href="#七-this" class="headerlink" title="七 this"></a>七 this</h1><table>
<thead>
<tr>
<th>场景</th>
<th><code>this</code> 指向</th>
</tr>
</thead>
<tbody><tr>
<td>全局作用域，普通函数</td>
<td>非严格模式 <code>window</code><br>严格模式 <code>undefined</code></td>
</tr>
<tr>
<td>对象中</td>
<td>当前对象</td>
</tr>
<tr>
<td>对象方法中</td>
<td>调用该方法的对象</td>
</tr>
<tr>
<td>原型对象方法中</td>
<td>调用该方法的对象</td>
</tr>
<tr>
<td>构造函数中</td>
<td>正在构造的新对象</td>
</tr>
<tr>
<td>箭头函数中</td>
<td>与箭头函数所在作用域的 <code>this</code> 指向一致</td>
</tr>
<tr>
<td>DOM 事件处理函数中</td>
<td>绑定事件的元素</td>
</tr>
<tr>
<td>回调函数</td>
<td><code>window</code></td>
</tr>
<tr>
<td>内联事件处理函数中</td>
<td><code>window</code></td>
</tr>
<tr>
<td>立即执行函数</td>
<td><code>window</code></td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/11/08/UI/JS%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%8C%85%E8%A3%85%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/11/08/UI/JS%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%8C%85%E8%A3%85%E7%B1%BB/" class="post-title-link" itemprop="url">JS基本类型及包装类</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-11-08 21:08:14 / 修改时间：21:10:57" itemprop="dateCreated datePublished" datetime="2020-11-08T21:08:14+08:00">2020-11-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-number"><a href="#一-number" class="headerlink" title="一 number"></a>一 number</h1><h2 id="1-1-说明"><a href="#1-1-说明" class="headerlink" title="1.1 说明"></a>1.1 说明</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>任意数字</code></td>
<td>整数或者浮点数</td>
</tr>
<tr>
<td><code>+Infinity</code></td>
<td>正无穷</td>
</tr>
<tr>
<td><code>-Infinity</code></td>
<td>负无穷</td>
</tr>
<tr>
<td><code>NaN</code></td>
<td><code>not a number</code> 一个不是数字的数字类型</td>
</tr>
</tbody></table>
<ol>
<li>JavaScript 的 number 类型为双精度IEEE 754 64位浮点类型。范围（-2<sup>53</sup>- 2<sup>53</sup>） </li>
<li>JavaScript 内部，整数和浮点数采用的是同样的储存方法。所以<code>1===1.0</code> 为true</li>
<li>进制<ul>
<li>十进制</li>
<li>二进制：以 <code>0b</code> 开头</li>
<li>八进制：以 <code>0o</code>开头</li>
<li>十六进制：以 <code>0x</code> 开头</li>
</ul>
</li>
</ol>
<h2 id="1-2-Number（包装类）"><a href="#1-2-Number（包装类）" class="headerlink" title="1.2 Number（包装类）"></a>1.2 Number（包装类）</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>new Number([value])</code></td>
<td>构造函数</td>
<td>创建一个 <code>Number</code> 对象</td>
</tr>
<tr>
<td><code>Number([value])</code></td>
<td>类型转换函数</td>
<td>将 <code>value</code> 转成一个 <code>number</code></td>
</tr>
</tbody></table>
<h3 id="2-静态属性"><a href="#2-静态属性" class="headerlink" title="2 静态属性"></a>2 静态属性</h3><table>
<thead>
<tr>
<th>静态属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Number.POSITIVE_INFINITY</code></td>
<td>正无穷，指向 <code>+Infinity</code></td>
</tr>
<tr>
<td><code>Number.NEGATIVE_INFINITY</code></td>
<td>负无穷，指向 <code>-Infinity</code></td>
</tr>
<tr>
<td><code>Number.NaN</code></td>
<td><code>NaN</code></td>
</tr>
<tr>
<td><code>Number.MIN_VALUE</code></td>
<td>最小正值</td>
</tr>
<tr>
<td><code>Number.MAX_VALUE</code></td>
<td>最大数值</td>
</tr>
<tr>
<td><code>Number.MIN_SAFE_INTEGER</code></td>
<td>JS 中能够准确表示的整数范围下限</td>
</tr>
<tr>
<td><code>Number.MAX_SAFE_INTEGER</code></td>
<td>JS 中能够准确表示的整数范围上限</td>
</tr>
<tr>
<td><code>Number.EPSILON</code></td>
<td>表示 1 与大于 1 的最小的浮点数之间的差值，即 JS 的精度</td>
</tr>
</tbody></table>
<h3 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="3 静态方法"></a>3 静态方法</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Number.isNaN(value)</code></td>
<td>判断是否是 <code>NaN</code></td>
</tr>
<tr>
<td><code>Number.isFinite(value)</code></td>
<td>判断否是有穷数</td>
</tr>
<tr>
<td><code>Number.isInteger(value)</code></td>
<td>判断是否是整数</td>
</tr>
<tr>
<td><code>Number.parseInt(string[, radix])</code></td>
<td>将一个字符串转换成指定进制的整数，<code>radix</code> ：进制 <code>2-36</code>，默认 <code>10</code></td>
</tr>
<tr>
<td><code>Number.parseFloat(string)</code></td>
<td>将一个字符串转换成浮点数</td>
</tr>
</tbody></table>
<ol>
<li><code>Number.isNaN(value)</code> &amp; <code>window.isNaN()</code><ul>
<li>全局函数 <code>isNaN()</code> 会先将非数值转换为数值，再进行判断</li>
<li><code>Number.isNaN()</code> 只对数值有效，非数值直接返回 <code>false</code></li>
</ul>
</li>
<li><code>Number.isFinite(value)</code> &amp; <code>window.isFinite()</code><ul>
<li>全局函数 <code>isFinite()</code> 会先将非数值转换为数值，再进行判断</li>
<li><code>Number.isFinite()</code> 只对数值有效，非数值直接返回 <code>false</code></li>
</ul>
</li>
</ol>
<h3 id="4-原型方法-Number-prototype"><a href="#4-原型方法-Number-prototype" class="headerlink" title="4 原型方法 Number.prototype."></a>4 原型方法 <code>Number.prototype.</code></h3><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>valueOf()</code></td>
<td>返回 <code>number</code> 值</td>
</tr>
<tr>
<td><code>toString([radix])</code></td>
<td>返回字符串形式</td>
</tr>
<tr>
<td><code>toFixed([digits])</code></td>
<td>返回保留指定位数浮点数的字符串</td>
</tr>
</tbody></table>
<h1 id="二-boolean"><a href="#二-boolean" class="headerlink" title="二 boolean"></a>二 boolean</h1><h2 id="2-1-说明"><a href="#2-1-说明" class="headerlink" title="2.1 说明"></a>2.1 说明</h2><table>
<thead>
<tr>
<th>项</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code>（布尔值）</td>
<td><code>false, true</code></td>
</tr>
<tr>
<td><code>Falsy</code>（类假值）</td>
<td><code>false, 0, &#39;&#39;, undefined, null, NaN</code></td>
</tr>
<tr>
<td><code>Truthy</code>（类真值）</td>
<td>非 <code>Falsy</code> 的值</td>
</tr>
</tbody></table>
<ol>
<li>隐式转换<ul>
<li><code>Falsy</code> 可以隐式转换为 <code>false</code>；<code>Truthy</code> 可以隐式转换为 <code>true</code></li>
<li>注意：值和布尔值是不同的概念</li>
</ul>
</li>
<li>显式转换<ol>
<li><code>Boolean()</code></li>
<li><code>!!</code></li>
<li><code>new Boolean()</code><ul>
<li>不推荐，因为返回一个对象，而对象是 <code>Truthy</code> 转为布尔值必为 <code>true</code></li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="2-2-Boolean（包装类）"><a href="#2-2-Boolean（包装类）" class="headerlink" title="2.2 Boolean（包装类）"></a>2.2 Boolean（包装类）</h2><h3 id="1-构造函数-1"><a href="#1-构造函数-1" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>new Boolean([value])</code></td>
<td>构造函数</td>
<td>创建一个 <code>Boolean</code> 对象</td>
</tr>
<tr>
<td><code>Boolean([value])</code></td>
<td>类型转换函数</td>
<td>将 <code>value</code> 转成一个布尔值</td>
</tr>
</tbody></table>
<h3 id="2-原型方法-Boolean-prototype"><a href="#2-原型方法-Boolean-prototype" class="headerlink" title="2 原型方法 Boolean.prototype."></a>2 原型方法 <code>Boolean.prototype.</code></h3><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>toString()</code></td>
<td>返回布尔值的字符串形式</td>
</tr>
<tr>
<td><code>valueOf()</code></td>
<td>返回布尔值</td>
</tr>
</tbody></table>
<h1 id="三-string"><a href="#三-string" class="headerlink" title="三 string"></a>三 string</h1><h2 id="3-1-说明"><a href="#3-1-说明" class="headerlink" title="3.1 说明"></a>3.1 说明</h2><h3 id="1-字符串字面量"><a href="#1-字符串字面量" class="headerlink" title="1 字符串字面量"></a>1 字符串字面量</h3><table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&quot;&quot;</code> <code>&#39;&#39;</code></td>
<td>单/双引号，特殊字符使用 <code>\</code> 转义</td>
</tr>
<tr>
<td><code>&#96;&#96;</code></td>
<td>反引号，模板字面量，特殊字符（反引号自身需要<code>\</code>转义）可以直接使用</td>
</tr>
<tr>
<td><code>\uxxxx</code></td>
<td>只限 Unicode 编码在 <code>\u0000~\uFFFF</code>（0-65535）之间的字符</td>
</tr>
<tr>
<td><code>\u{xxxx}</code></td>
<td>大于<code>\uFFFF</code>的字符也能正确表示</td>
</tr>
</tbody></table>
<h3 id="2-模板字面量"><a href="#2-模板字面量" class="headerlink" title="2 模板字面量"></a>2 模板字面量</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>模板字面量是增强版的字符串，它用反引号标识</li>
<li>空格换行等都会原样输出</li>
<li><code>${表达式}</code> <ul>
<li>占位符就如同一个普通字符串一样，可以插入到字符串中的任意位置</li>
<li>作用是取表达式的值</li>
</ul>
</li>
<li>反引号可以嵌套</li>
</ol>
<h4 id="2-模板字面量标签"><a href="#2-模板字面量标签" class="headerlink" title="2 模板字面量标签"></a>2 模板字面量标签</h4><ol>
<li><p>模板字面量标签通常是一个函数</p>
</li>
<li><p>调用标签函数，将它放在模板字面量前面即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 内置函数</span><br><span class="line">alert`hello`;</span><br><span class="line">2 自定义函数</span><br><span class="line">function myTag (strings, ...values)&#123;&#125;</span><br><span class="line">myTag`hello`</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用标签函数时，会将模板字面量处理成参数，传递给函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let name = &apos;xiaoming&apos;, age = 18;</span><br><span class="line">alert`hello$&#123;name&#125;,ni$&#123;18&#125;了吗`; </span><br><span class="line">// 相当于</span><br><span class="line">alert ([&apos;hello&apos;, &apos;,ni&apos;, &apos;了吗&apos;], &apos;xiaoming&apos;, 18);</span><br></pre></td></tr></table></figure>

<ol>
<li>第一个参数是数组，存储模板字面量中占位符<code>${}</code>两侧的字符串</li>
<li>第二个参数是可变参数，存储占位符<code>${}</code>的返回值</li>
</ol>
</li>
</ol>
<h3 id="3-字符串换行"><a href="#3-字符串换行" class="headerlink" title="3 字符串换行"></a>3 字符串换行</h3><ol>
<li>末尾加<code>\</code></li>
<li>加号连接</li>
<li>反引号</li>
</ol>
<h2 id="3-2-String（包装类）"><a href="#3-2-String（包装类）" class="headerlink" title="3.2 String（包装类）"></a>3.2 String（包装类）</h2><h3 id="1-构造函数-2"><a href="#1-构造函数-2" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>new String([value])</code></td>
<td>构造函数</td>
<td>创建一个 <code>String</code> 对象</td>
</tr>
<tr>
<td><code>String([value])</code></td>
<td>类型转换函数</td>
<td>将 <code>value</code> 转成一个字符串</td>
</tr>
</tbody></table>
<ul>
<li>由于字符串的不可变性，字符串中的所有方法都不改变原字符串</li>
</ul>
<h3 id="2-实例属性"><a href="#2-实例属性" class="headerlink" title="2 实例属性"></a>2 实例属性</h3><table>
<thead>
<tr>
<th>实例属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>length</code></td>
<td>字符数</td>
</tr>
</tbody></table>
<h3 id="3-静态方法-1"><a href="#3-静态方法-1" class="headerlink" title="3 静态方法"></a>3 静态方法</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String.fromCharCode(charCode1, ..., charCodeN)</code></td>
<td>返回使用指定的 Unicode 编码创建的字符串，不能识别大于<code>0xFFFF</code>的字符</td>
</tr>
<tr>
<td><code>String.fromCodePoint(num1[, ...[, numN]])</code></td>
<td>返回使用指定的 Unicode 编码创建的字符串，识别大于<code>0xFFFF</code>的字符</td>
</tr>
<tr>
<td><code>String.raw&#96;templateString&#96;</code></td>
<td>返回模板字符串的原始字符串</td>
</tr>
</tbody></table>
<h3 id="4-原型方法-String-prototype"><a href="#4-原型方法-String-prototype" class="headerlink" title="4 原型方法 String.prototype."></a>4 原型方法 <code>String.prototype.</code></h3><h4 id="1-查"><a href="#1-查" class="headerlink" title="1 查"></a>1 查</h4><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>charAt(index)</code></td>
<td>返回指定索引的字符</td>
</tr>
<tr>
<td><code>str[index]</code></td>
<td>等效于 <code>charAt(index)</code></td>
</tr>
<tr>
<td><code>charCodeAt(index)</code></td>
<td>返回指定索引字符的 Unicode 码，只能获取两个字节的字符</td>
</tr>
<tr>
<td><code>codePointAt(index)</code></td>
<td>返回指定索引字符的 Unicode 码</td>
</tr>
<tr>
<td><code>indexOf(searchValue[, fromIndex])</code></td>
<td>返回第一次出现的索引，未找到返回 <code>-1</code></td>
</tr>
<tr>
<td><code>lastIndexOf(searchValue[, fromIndex])</code></td>
<td>返回从后往前第一次出现的索引，未找到返回 <code>-1</code></td>
</tr>
</tbody></table>
<h4 id="2-获取"><a href="#2-获取" class="headerlink" title="2 获取"></a>2 获取</h4><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>valueOf()</code></td>
<td>返回字符串对象的原始字符串</td>
</tr>
<tr>
<td><code>repeat(count)</code></td>
<td>返回当前字符串重复 <code>count</code> 次组成的新字符串</td>
</tr>
<tr>
<td><code>concat(str1, str2[, ..., strN])</code></td>
<td>连接字符串并返回</td>
</tr>
<tr>
<td><code>slice(beginIndex[, endIndex])</code></td>
<td>提取 <code>[begin,end)</code> 索引之间的字符串并返回，索引可以为负</td>
</tr>
<tr>
<td><code>substring(beginIndex[, endIndex])</code></td>
<td>提取 <code>[begin,end)</code> 索引之间的字符串并返回，</td>
</tr>
</tbody></table>
<h4 id="3-改"><a href="#3-改" class="headerlink" title="3 改"></a>3 改</h4><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>toLowerCase()</code></td>
<td>转小写</td>
</tr>
<tr>
<td><code>toUpperCase()</code></td>
<td>转大写</td>
</tr>
<tr>
<td><code>trim()</code></td>
<td>去除字符串两端的空格</td>
</tr>
<tr>
<td><code>padStart(targetLength [, padString])</code></td>
<td>以指定字符串 <code>padString</code> 在原字符串开头补充，以达到目标长度 <code>targetLength</code></td>
</tr>
<tr>
<td><code>padEnd(targetLength [, padString])</code></td>
<td>以指定字符串 <code>padString</code> 在原字符串末尾补充，以达到目标长度 <code>targetLength</code></td>
</tr>
</tbody></table>
<h4 id="4-判断"><a href="#4-判断" class="headerlink" title="4 判断"></a>4 判断</h4><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>includes(searchString[, fromIndex])</code></td>
<td>判断是否包含指定字符串</td>
</tr>
<tr>
<td><code>startsWith(searchString[, fromIndex])</code></td>
<td>判断是否以指定字符串开头</td>
</tr>
<tr>
<td><code>endsWith(searchString[, length])</code></td>
<td>判断是否以指定字符串结尾，<code>length</code> 表示只判断原字符串指定长度</td>
</tr>
</tbody></table>
<h4 id="5-正则"><a href="#5-正则" class="headerlink" title="5 正则"></a>5 正则</h4><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>split([separator[, limit]])</code></td>
<td>按照给定规则分割字符串，返回一个由分割出来的子字符串以指定分隔符组成的数组</td>
</tr>
<tr>
<td><code>search(regexp)</code></td>
<td>返回首次匹配项的索引，无匹配返回 <code>-1</code></td>
</tr>
<tr>
<td><code>match(regexp)</code></td>
<td>正则有 <code>g</code>，则返回所有匹配结果的数组（无附加属性），正则无 <code>g</code>，则返回只有第一个匹配结果的数组（有附加属性），无匹配返回 <code>null</code></td>
</tr>
<tr>
<td><code>matchAll(regexp)</code></td>
<td>返回所有匹配结果的迭代器（包含附加属性）</td>
</tr>
</tbody></table>
<h4 id="6-替换"><a href="#6-替换" class="headerlink" title="6 替换"></a>6 替换</h4><ul>
<li><code>replace(regexp|substr, newSubStr|function)</code><ul>
<li><code>regexp|substr</code><ul>
<li>正则匹配的内容或者指定的内容</li>
</ul>
</li>
<li><code>newSubStr</code><ul>
<li>使用新的字符串替换，替换时可以插入特殊变量</li>
</ul>
</li>
<li><code>function</code><ul>
<li>使用函数返回的字符串替换</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">特殊变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>$$</code></td>
<td>插入一个 “$”</td>
</tr>
<tr>
<td align="center"><code>$&amp;</code></td>
<td>插入匹配的子串</td>
</tr>
<tr>
<td align="center">$`</td>
<td>插入当前匹配的子串左边的内容</td>
</tr>
<tr>
<td align="center"><code>$&#39;</code></td>
<td>插入当前匹配的子串右边的内容</td>
</tr>
<tr>
<td align="center"><code>$n</code></td>
<td>如果第一个参数是RegExp对象，表示插入第n组的内容</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">函数参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>match</code></td>
<td>匹配的子串。（对应<code>$&amp;</code>。）</td>
</tr>
<tr>
<td align="center"><code>p1,p2,...</code></td>
<td>如果第一个参数是RegExp对象，表示第n组的内容（对应<code>$n</code>）</td>
</tr>
<tr>
<td align="center"><code>offset</code></td>
<td>匹配到的子字符串在原字符串中起始索引</td>
</tr>
<tr>
<td align="center"><code>string</code></td>
<td>被匹配的原字符串</td>
</tr>
<tr>
<td align="center"><code>NamedCaptureGroup</code></td>
<td>命名捕获组匹配的对象</td>
</tr>
</tbody></table>
<h1 id="四-undefined"><a href="#四-undefined" class="headerlink" title="四 undefined"></a>四 undefined</h1><ol>
<li><code>undefined</code> 是一种类型，且只有一个值 <code>undefined</code></li>
<li>一个变量没有指定类型（没有赋值则不能确定类型），则默认为 <code>undefined</code> 类型，其值也是 <code>undefined</code><ul>
<li>变量或者对象属性没有赋值，默认值为 <code>undefined</code></li>
<li>调用函数时，没有传值的参数默认值为 <code>undefined</code></li>
<li>函数没有返回值时，默认返回 <code>undefined</code></li>
</ul>
</li>
</ol>
<h1 id="五-symbol"><a href="#五-symbol" class="headerlink" title="五 symbol"></a>五 symbol</h1><h2 id="5-1-说明"><a href="#5-1-说明" class="headerlink" title="5.1 说明"></a>5.1 说明</h2><ol>
<li>symbol 的值是唯一的，独一无二的，不会重复的</li>
<li>symbol 值作为对象属性名时，不能用点运算符，只能使用<code>[]</code><ol>
<li>不会被<code>for...in for... of</code>遍历到</li>
<li>不会被 <code>Object.keys() Object.getOwnPropertyNames() JSON.stringify()</code> 返回</li>
<li>使用<code>Object.getOwnPropertySymbols()</code>可以获取</li>
</ol>
</li>
<li>symbol 值不能与其他类型的值进行运算，可以转为字符串和布尔值</li>
</ol>
<h2 id="5-2-Symbol（包装类）"><a href="#5-2-Symbol（包装类）" class="headerlink" title="5.2 Symbol（包装类）"></a>5.2 Symbol（包装类）</h2><h3 id="1-构造函数-3"><a href="#1-构造函数-3" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Symbol([description])</code></td>
<td>返回一个唯一的 <code>symbol</code> 值，不会放入全局 <code>symbol</code> 注册表，<code>description</code>：只是描述，不影响 <code>symbol</code> 值</td>
</tr>
<tr>
<td><code>new Symbol()</code></td>
<td>不支持此语法</td>
</tr>
</tbody></table>
<h3 id="2-静态属性-1"><a href="#2-静态属性-1" class="headerlink" title="2 静态属性"></a>2 静态属性</h3><ul>
<li>ES6 提供了 11 个内置的 <code>symbol</code> 值，指向语言内部使用的方法</li>
</ul>
<table>
<thead>
<tr>
<th>静态属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Symbol.hasInstance</code></td>
<td><code>A instanceof B</code> 实际调用的是 <code>B[Symbol.hasInstance](A)</code></td>
</tr>
<tr>
<td><code>Symbol.iterator</code></td>
<td>指向一个返回对象迭代器的方法, <code>Obj[Symbol.iterator]()</code> 获取此方法并执行，返回对象的迭代器，被 <code>for... of</code> 使用</td>
</tr>
</tbody></table>
<h3 id="3-实例属性"><a href="#3-实例属性" class="headerlink" title="3 实例属性"></a>3 实例属性</h3><table>
<thead>
<tr>
<th>实例属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>description</code></td>
<td>只读属性，返回 Symbol 对象的可选的描述字符串</td>
</tr>
</tbody></table>
<h3 id="4-静态方法"><a href="#4-静态方法" class="headerlink" title="4 静态方法"></a>4 静态方法</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Symbol.for(key)</code></td>
<td>根据 <code>key</code> 从全局 <code>symbol</code> 注册表查询，找到则返回，否则创建一个与 <code>key</code> 关联的 <code>symbol</code> 值并放入全局 <code>symbol</code>注册表</td>
</tr>
<tr>
<td><code>Symbol.keyFor(sym)</code></td>
<td>获取全局 <code>symbol</code> 注册表中与指定 <code>symbole</code> 值关联的 <code>key</code></td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/11/08/UI/JS%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/11/08/UI/JS%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">JS语法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-11-08 21:08:04 / 修改时间：21:11:48" itemprop="dateCreated datePublished" datetime="2020-11-08T21:08:04+08:00">2020-11-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-注释"><a href="#一-注释" class="headerlink" title="一 注释"></a>一 注释</h1><ol>
<li><code>/ 单行注释 /</code></li>
<li><code>/* 多行注释，不能嵌套 */</code></li>
</ol>
<h1 id="二-作用域"><a href="#二-作用域" class="headerlink" title="二 作用域"></a>二 作用域</h1><ol>
<li>全局作用域：<code>&lt;script&gt;</code> 标签中或外部 <code>.js</code> 文件中</li>
<li>函数作用域：函数内部</li>
<li>块作用域：<code>ES 6</code> 之后才有，<code>{}</code> 内部，如 <code>{}, if, for, while, ...</code></li>
</ol>
<h1 id="三-声明关键字"><a href="#三-声明关键字" class="headerlink" title="三 声明关键字"></a>三 声明关键字</h1><table>
<thead>
<tr>
<th align="center">关键字</th>
<th>初始化</th>
<th>变量提升</th>
<th>作用域</th>
<th>window</th>
<th>同一作用域重复声明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>var</code></td>
<td>可选</td>
<td>有</td>
<td><code>全局，函数</code></td>
<td>全局声明会添加到 <code>window</code> 对象</td>
<td>可以，后者覆盖前者</td>
</tr>
<tr>
<td align="center"><code>let</code></td>
<td>可选</td>
<td>无</td>
<td><code>全局，函数，块</code></td>
<td>全局声明不会添加到 <code>window</code> 对象</td>
<td>不能</td>
</tr>
<tr>
<td align="center"><code>const</code></td>
<td>必须</td>
<td>无</td>
<td><code>全局，函数，块</code></td>
<td>全局声明不会添加到 <code>window</code> 对象</td>
<td>不能</td>
</tr>
</tbody></table>
<ol>
<li><p>JS 引擎运行分为两步：预解析和代码执行</p>
</li>
<li><p>预解析：将脚本中所有 <code>var</code> 和 <code>function</code> 语句提升到其作用域的最前面（hoisting）</p>
<ul>
<li>变量提升 <code>var</code>：将变量的声明提升到其作用域最前面，赋值操作不会提升</li>
<li>函数提升 <code>function</code>：将函数的声明提升到其作用域最前面</li>
</ul>
</li>
<li><p><code>var</code> 的问题：</p>
<ol>
<li>在函数及其子作用域声明的变量作用域都是函数</li>
<li>全局声明会添加到 <code>windows</code> 中</li>
</ol>
</li>
<li><p>暂时性死区  TDZ <code>temporal dead zone</code></p>
<ul>
<li><p>从作用域开始到声明语句之间区域，如果使用声明的变量就会会导致 <code>ReferenceError</code>，这块区域称为暂时性死区。</p>
</li>
<li><p>说白了就是要先声明后使用</p>
</li>
<li><p>暂时性死区不会查找全局变量（我觉得应该是特殊情况下）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let num = 10;</span><br><span class="line">if (true) &#123;</span><br><span class="line">	console.log(num); // 报错</span><br><span class="line">	let num = 20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ol>
<h1 id="四-变量"><a href="#四-变量" class="headerlink" title="四 变量"></a>四 变量</h1><ol>
<li><p>变量的声明和赋值，是分开的两个步骤</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;  </span><br><span class="line"><span class="comment">// 其实是下边两步</span></span><br><span class="line"><span class="keyword">let</span> a;</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同一条声明语句中可以声明多个变量</p>
</li>
<li><p>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</p>
</li>
<li><p>变量标识符命名规则</p>
<ol>
<li><code>A-Za-z</code> <code>0-9</code> <code>_</code> <code>$</code></li>
<li>不能用数字开头</li>
<li>不能使用 js 关键字和保留字</li>
</ol>
</li>
</ol>
<h1 id="五-数据类型"><a href="#五-数据类型" class="headerlink" title="五 数据类型"></a>五 数据类型</h1><h2 id="5-1-数据类型分类"><a href="#5-1-数据类型分类" class="headerlink" title="5.1 数据类型分类"></a>5.1 数据类型分类</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/JS/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt=""></p>
<table>
<thead>
<tr>
<th>内置对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object</code></td>
<td>对象都是 <code>Object</code> 的实例</td>
</tr>
<tr>
<td><code>Array</code></td>
<td>数组都是 <code>Array</code> 的实例</td>
</tr>
<tr>
<td><code>Function</code></td>
<td>函数都是 <code>Function</code> 的实例</td>
</tr>
<tr>
<td><code>Map Set WeakMap WeakSet</code></td>
<td>集合</td>
</tr>
<tr>
<td><code>Number Boolean String Symbol BigInt</code></td>
<td>基本类型包装类</td>
</tr>
<tr>
<td><code>Math</code></td>
<td>数学运算</td>
</tr>
<tr>
<td><code>Date</code></td>
<td>日期</td>
</tr>
<tr>
<td><code>JSON</code></td>
<td>Json</td>
</tr>
<tr>
<td><code>RegExp</code></td>
<td>正则表达式都是 <code>RegExp</code> 的实例</td>
</tr>
<tr>
<td><code>Error</code></td>
<td>错误</td>
</tr>
</tbody></table>
<h2 id="5-2-数据类型判断"><a href="#5-2-数据类型判断" class="headerlink" title="5.2 数据类型判断"></a>5.2 数据类型判断</h2><h3 id="1-方式"><a href="#1-方式" class="headerlink" title="1 方式"></a>1 方式</h3><table>
<thead>
<tr>
<th>方式</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>typeof</code></td>
<td><code>typeof operand</code></td>
<td>返回数据类型的字符串形式</td>
</tr>
<tr>
<td><code>instanceof</code></td>
<td><code>obj instanceof constructor</code></td>
<td>检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上</td>
</tr>
</tbody></table>
<h3 id="2-typeof-返回值"><a href="#2-typeof-返回值" class="headerlink" title="2 typeof 返回值"></a>2 typeof 返回值</h3><table>
<thead>
<tr>
<th>type</th>
<th>typeof Result</th>
</tr>
</thead>
<tbody><tr>
<td><code>number</code></td>
<td><code>&quot;number&quot;</code></td>
</tr>
<tr>
<td><code>bigint</code></td>
<td><code>&quot;bigint&quot;</code></td>
</tr>
<tr>
<td><code>string</code></td>
<td><code>&quot;string&quot;</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>&quot;boolean&quot;</code></td>
</tr>
<tr>
<td><code>undefined</code></td>
<td><code>&quot;undefined&quot;</code></td>
</tr>
<tr>
<td><code>null</code></td>
<td><code>&quot;object&quot;</code></td>
</tr>
<tr>
<td><code>symbol</code></td>
<td><code>&quot;symbol&quot;</code></td>
</tr>
<tr>
<td><code>function object (implements [[Call]])</code></td>
<td><code>&quot;function&quot;</code></td>
</tr>
<tr>
<td><code>any other object</code></td>
<td><code>&quot;object&quot;</code></td>
</tr>
</tbody></table>
<ul>
<li><code>typeof null</code>返回<code>object</code>是历史原因</li>
</ul>
<h1 id="六-运算符"><a href="#六-运算符" class="headerlink" title="六 运算符"></a>六 运算符</h1><h2 id="6-1-赋值运算符"><a href="#6-1-赋值运算符" class="headerlink" title="6.1 赋值运算符"></a>6.1 赋值运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
<th>等价于</th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td>赋值</td>
<td><code>x = y</code></td>
<td><code>x = y</code></td>
</tr>
<tr>
<td><code>+=</code></td>
<td>加赋值</td>
<td><code>x += y</code></td>
<td><code>x = x + y</code></td>
</tr>
<tr>
<td><code>-=</code></td>
<td>减赋值</td>
<td><code>x -= y</code></td>
<td><code>x = x - y</code></td>
</tr>
<tr>
<td><code>*=</code></td>
<td>乘赋值</td>
<td><code>x *= y</code></td>
<td><code>x = x * y</code></td>
</tr>
<tr>
<td><code>/=</code></td>
<td>除赋值</td>
<td><code>x /= y</code></td>
<td><code>x = x / y</code></td>
</tr>
<tr>
<td><code>%=</code></td>
<td>模赋值</td>
<td><code>x %= y</code></td>
<td><code>x = x % y</code></td>
</tr>
<tr>
<td><code>**=</code></td>
<td>指数赋值</td>
<td><code>x **= y</code></td>
<td><code>x = x ** y</code></td>
</tr>
<tr>
<td><code>&lt;&lt;=</code></td>
<td>左移赋值</td>
<td><code>x &lt;&lt;= y</code></td>
<td><code>x = x &lt;&lt; y</code></td>
</tr>
<tr>
<td><code>&gt;&gt;=</code></td>
<td>右移赋值</td>
<td><code>x &gt;&gt;= y</code></td>
<td><code>x = x &gt;&gt; y</code></td>
</tr>
<tr>
<td><code>&gt;&gt;&gt;=</code></td>
<td>无符号右移赋值</td>
<td><code>x &gt;&gt;&gt;= y</code></td>
<td><code>x = x &gt;&gt;&gt; y</code></td>
</tr>
<tr>
<td><code>&amp;=</code></td>
<td>按位与赋值</td>
<td><code>x &amp;= y</code></td>
<td><code>x = x &amp; y</code></td>
</tr>
<tr>
<td><code>&#124;=</code></td>
<td>按位或赋值</td>
<td><code>x &#124;= y</code></td>
<td><code>x = x &#124; y</code></td>
</tr>
<tr>
<td><code>^=</code></td>
<td>按位异或赋值</td>
<td><code>x ^= y</code></td>
<td><code>x = x ^ y</code></td>
</tr>
</tbody></table>
<h2 id="6-2-算术运算符"><a href="#6-2-算术运算符" class="headerlink" title="6.2 算术运算符"></a>6.2 算术运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>加法</td>
<td><code>x + y</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td>减法</td>
<td><code>x - y</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘法</td>
<td><code>x * y</code></td>
</tr>
<tr>
<td><code>/</code></td>
<td>除法</td>
<td><code>x / y</code></td>
</tr>
<tr>
<td><code>%</code></td>
<td>求余</td>
<td><code>x % y</code></td>
</tr>
<tr>
<td><code>**</code></td>
<td>幂</td>
<td><code>x ** y</code></td>
</tr>
<tr>
<td><code>++</code></td>
<td>自增</td>
<td><code>x++</code> 或 <code>++x</code></td>
</tr>
<tr>
<td><code>--</code></td>
<td>自减</td>
<td><code>x--</code> 或 <code>--x</code></td>
</tr>
<tr>
<td><code>+</code></td>
<td>一元正号</td>
<td><code>+x</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td>一元负号</td>
<td><code>-x</code></td>
</tr>
</tbody></table>
<h3 id="1-加法"><a href="#1-加法" class="headerlink" title="1 加法"></a>1 加法</h3><ol>
<li><p>遇到字符串会变成连接</p>
</li>
<li><p>对象相加，会先转成原始类型的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line">obj + <span class="number">2</span> <span class="comment">// "[object Object]2"</span></span><br><span class="line"><span class="comment">// obj.valueOf() 结果为&#123;p:1&#125;</span></span><br><span class="line"><span class="comment">// obj.valueOf().toString() 结果为"[object object]"</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-一元加号-减号"><a href="#2-一元加号-减号" class="headerlink" title="2 一元加号/减号"></a>2 一元加号/减号</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一元加号/减号运算符的作用在于可以将任何值转为数值</span></span><br><span class="line">+<span class="literal">true</span> <span class="comment">// 1</span></span><br><span class="line">+[] <span class="comment">// 0</span></span><br><span class="line">+&#123;&#125; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h3 id="3-幂运算符"><a href="#3-幂运算符" class="headerlink" title="3 幂运算符"></a>3 幂运算符</h3><ol>
<li><p>前一个运算子是底数，后一个运算子是指数</p>
</li>
<li><p>幂运算符是右结合：即多个指数运算符连用时，先进行最右边的计算。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">3</span> ** <span class="number">2</span></span><br><span class="line"><span class="comment">// 512 相当于 2 ** (3 ** 2) 即先求3的2次方=9 再求2的9次方</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="6-3-比较运算符"><a href="#6-3-比较运算符" class="headerlink" title="6.3 比较运算符"></a>6.3 比较运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
</tr>
</thead>
<tbody><tr>
<td><code>&gt;</code></td>
<td>大于</td>
<td><code>x &gt; y</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
<td><code>x &lt; y</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
<td><code>x &gt;= y</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
<td><code>x &lt;= y</code></td>
</tr>
<tr>
<td><code>==</code></td>
<td>相等</td>
<td><code>x == y</code></td>
</tr>
<tr>
<td><code>===</code></td>
<td>严格相等</td>
<td><code>x === y</code></td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不相等</td>
<td><code>x != y</code></td>
</tr>
<tr>
<td><code>!==</code></td>
<td>严格不相等</td>
<td><code>x !== y</code></td>
</tr>
</tbody></table>
<h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h3><ol>
<li>基本类型<ol>
<li>非字符串：先转成数值再比较</li>
<li>字符串：按照字典顺序比较（实际上是比较 Unicode 码点）</li>
</ol>
</li>
<li>引用类型<ul>
<li>先转为基本类型的值，再进行比较</li>
</ul>
</li>
<li>严格相等（全等）：符号两边的值类型和值都相等</li>
</ol>
<h3 id="2-总结"><a href="#2-总结" class="headerlink" title="2 总结"></a>2 总结</h3><table>
<thead>
<tr>
<th>方式</th>
<th><code>NaN</code></th>
<th><code>undefined</code></th>
<th><code>null</code></th>
<th><code>+0</code> 和 <code>-0</code></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>==</code></td>
<td>不等于任何值</td>
<td>等于 <code>undefined</code> 和 <code>null</code></td>
<td>等于 <code>undefined</code> 和 <code>null</code></td>
<td>相等</td>
<td>先进行类型转换，之后使用 <code>===</code> 比较</td>
</tr>
<tr>
<td><code>===</code></td>
<td>不等于任何值</td>
<td>等于 <code>undefined</code></td>
<td>等于 <code>null</code></td>
<td>相等</td>
<td>类型不同即为 <code>false</code></td>
</tr>
<tr>
<td><code>Object.is(value1, value2)</code></td>
<td>等于 <code>NaN</code></td>
<td>等于 <code>undefined</code></td>
<td>等于 <code>null</code></td>
<td>不相等</td>
<td>类型不同即为 <code>false</code></td>
</tr>
</tbody></table>
<h2 id="6-4-逻辑运算符"><a href="#6-4-逻辑运算符" class="headerlink" title="6.4 逻辑运算符"></a>6.4 逻辑运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑与</td>
<td><code>expr1 &amp;&amp; expr2</code></td>
<td>若<code>expr1</code>为 <code>true</code>，则返回<code>expr2</code>的值，否则，返回<code>expr1</code>的值，且不再计算<code>expr2</code> （短路）</td>
</tr>
<tr>
<td><code>&#124;&#124;</code></td>
<td>逻辑或</td>
<td><code>expr1 &#124;&#124; expr2</code></td>
<td>若<code>expr1</code>为 <code>false</code>，则返回<code>expr2</code>的值，否则，返回<code>expr1</code>的值，且不再计算<code>expr2</code> （短路）</td>
</tr>
<tr>
<td><code>!</code></td>
<td>逻辑非</td>
<td><code>!expr</code></td>
<td>若<code>expr</code> 为 <code>true</code>，则返回 <code>false</code>，否则，返回<code>true</code></td>
</tr>
<tr>
<td><code>!!</code></td>
<td>双重非</td>
<td><code>!!expr</code></td>
<td>显式地将任意值强制转换为其对应的布尔值</td>
</tr>
</tbody></table>
<ul>
<li>JS 中逻辑运算符返回的不一定是布尔值，而是表达式的值</li>
</ul>
<h2 id="6-5-按位运算符"><a href="#6-5-按位运算符" class="headerlink" title="6.5 按位运算符"></a>6.5 按位运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td>按位与</td>
<td><code>x &amp; y</code></td>
<td>有0则0</td>
</tr>
<tr>
<td><code>&#124;</code></td>
<td>按位或</td>
<td><code>x &#124; y</code></td>
<td>有1则1</td>
</tr>
<tr>
<td><code>~</code></td>
<td>按位非</td>
<td><code>~x</code></td>
<td>1变0，0变1</td>
</tr>
<tr>
<td><code>^</code></td>
<td>按位异或</td>
<td><code>x ^ y</code></td>
<td>相同则0，不同则1</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移</td>
<td><code>x &lt;&lt; y</code></td>
<td>低位补0，相当于<code>x * 2<sup>y</sup></code></td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移</td>
<td><code>x &gt;&gt; y</code></td>
<td>舍去低位，正数高位补 0，负数高位补 1，相当于<code>x / 2<sup>y</sup></code></td>
</tr>
<tr>
<td><code>&gt;&gt;&gt;</code></td>
<td>无符号右移</td>
<td><code>x &gt;&gt;&gt; y</code></td>
<td>舍去低位，高位补 0，相当于<code>x / 2<sup>y</sup></code></td>
</tr>
</tbody></table>
<h2 id="6-6-三元运算符"><a href="#6-6-三元运算符" class="headerlink" title="6.6 三元运算符"></a>6.6 三元运算符</h2><ul>
<li><code>condition ? exprIfTrue : exprIfFalse</code><ol>
<li>若<code>condition</code> 为true，返回<code>exprIfTrue</code>的值，否则，返回<code>exprIfFalse</code>的值</li>
<li>和 <code>if else</code> 的区别：if…else是语句，没有返回值；三元运算符是表达式，具有返回值。</li>
</ol>
</li>
</ul>
<h2 id="6-7-void运算符"><a href="#6-7-void运算符" class="headerlink" title="6.7 void运算符"></a>6.7 void运算符</h2><ul>
<li><code>void expression</code><ol>
<li>对给定的表达式进行求值，然后返回 <code>undefined</code></li>
<li>void 运算符通常只用于获取 <code>undefined</code> 的原始值，一般使用 <code>void(0)</code>（等同于<code>void 0</code>）</li>
<li>应用<ol>
<li><code>javascript: void(0);</code></li>
<li><code>() =&gt; void doSomething();</code></li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="6-8-逗号运算符"><a href="#6-8-逗号运算符" class="headerlink" title="6.8 逗号运算符"></a>6.8 逗号运算符</h2><ul>
<li><p><code>expr1, expr2, expr3...</code></p>
<ul>
<li><p>从左到右依次计算每个表达式，并返回最后一个表达式的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a'</span>, <span class="string">'b'</span> <span class="comment">// "b"</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> y = (x++, <span class="number">10</span>);  <span class="comment">// x=1 y=10</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="七-语句"><a href="#七-语句" class="headerlink" title="七 语句"></a>七 语句</h1><h2 id="7-1-条件"><a href="#7-1-条件" class="headerlink" title="7.1 条件"></a>7.1 条件</h2><h3 id="1-if-…-else"><a href="#1-if-…-else" class="headerlink" title="1 if … else"></a>1 if … else</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-switch-…-case"><a href="#2-switch-…-case" class="headerlink" title="2 switch … case"></a>2 switch … case</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switch 内部采用严格相等</span></span><br><span class="line"><span class="keyword">switch</span> (variable) &#123;</span><br><span class="line">    <span class="keyword">case</span> value1:</span><br><span class="line">        statement</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2:</span><br><span class="line">        statement</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-循环"><a href="#7-2-循环" class="headerlink" title="7.2 循环"></a>7.2 循环</h2><h3 id="1-for"><a href="#1-for" class="headerlink" title="1 for"></a>1 for</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化条件【可以有多个】; 循环条件【boolean类型】; 循环迭代条件) &#123;</span><br><span class="line">	循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-while"><a href="#2-while" class="headerlink" title="2 while"></a>2 while</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">	statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-do-…-while"><a href="#3-do-…-while" class="headerlink" title="3 do … while"></a>3 do … while</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (condition)</span><br></pre></td></tr></table></figure>

<h3 id="4-for-…-in"><a href="#4-for-…-in" class="headerlink" title="4 for … in"></a>4 for … in</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object)&#123;</span><br><span class="line">	statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>遍历对象（推荐）<ol>
<li>遍历对象的所有可枚举属性（包括它的原型链上的可枚举属性），属性是否可枚举由属性描述符的<code>enumerable</code>决定</li>
<li>每次循环获取的是属性名</li>
</ol>
</li>
<li>遍历数组（不推荐）<ol>
<li>数组键名是数字，但每次循环获取的是索引的字符串</li>
<li>除了遍历数组元素外，数组本身以及原型链上的可枚举属性也会被遍历到</li>
<li>某些情况下，不能保证按顺序返回索引</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>语句</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>{}</code></td>
<td>声明块作用域</td>
</tr>
<tr>
<td><code>prop in obj</code></td>
<td>判断对象或其原型链上是否包含某个属性</td>
</tr>
</tbody></table>
<h3 id="5-for-…-of"><a href="#5-for-…-of" class="headerlink" title="5 for … of"></a>5 for … of</h3><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>用来遍历可迭代对象，每次循环取出的是值</li>
<li>for… of 内部就是调用了可迭代对象的 <code>Symbol.iterator</code> 生成了迭代器</li>
</ol>
<h4 id="2-迭代器"><a href="#2-迭代器" class="headerlink" title="2 迭代器"></a>2 迭代器</h4><ol>
<li><p>迭代器就是具有指定<code>next()</code>方法的对象</p>
</li>
<li><p>此指定 <code>next()</code> ：返回一个对象，返回对象拥有两个属性</p>
<ol>
<li><p><code>value</code>：当前迭代的值</p>
</li>
<li><p><code>done</code>：布尔值，迭代是否结束。</p>
<ul>
<li><code>false</code> 表示没结束，可以省略    </li>
<li><code>true</code> 表示结束，此时 <code>value</code>为 <code>undefined</code>，<code>value</code> 可以省略</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="3-可迭代对象"><a href="#3-可迭代对象" class="headerlink" title="3 可迭代对象"></a>3 可迭代对象</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h5><ol>
<li>一个可迭代对象必须实现 <code>@@iterator</code> 方法，这意味着对象（或其原型链上的某个对象）必须有一个键为 <code>@@iterator</code> 的属性</li>
<li><code>@@iterator</code> 属性可以通过 <code>Symbol.iterator</code> 访问</li>
<li>对象（或者其原型链）上拥有 <code>Symbol.iterator</code> 属性，就是可迭代对象</li>
</ol>
<h5 id="2-Symbol-iterator"><a href="#2-Symbol-iterator" class="headerlink" title="2 Symbol.iterator"></a>2 <code>Symbol.iterator</code></h5><ol>
<li><code>Symbol.iterator</code> 属性指向一个函数，此函数返回对象的迭代器</li>
<li><code>obj[Symbol.iterator]</code> 返回对象用于获取迭代器的函数</li>
</ol>
<h5 id="3-JS-内置可迭代对象"><a href="#3-JS-内置可迭代对象" class="headerlink" title="3 JS 内置可迭代对象"></a>3 JS 内置可迭代对象</h5><table>
<thead>
<tr>
<th>内置可迭代对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td>字符串</td>
</tr>
<tr>
<td><code>Array</code></td>
<td>数组</td>
</tr>
<tr>
<td><code>Set / Map</code></td>
<td>集合</td>
</tr>
<tr>
<td><code>arguments</code></td>
<td>类数组对象</td>
</tr>
<tr>
<td><code>DOM NodeList</code></td>
<td>类数组对象</td>
</tr>
<tr>
<td><code>Generator</code></td>
<td>生成器对象</td>
</tr>
<tr>
<td><code>TypedArray</code></td>
<td>类型化数组</td>
</tr>
</tbody></table>
<ol>
<li>可枚举属性：属性描述符 <code>enumerable: true</code> 的属性</li>
<li>普通对象：没有数字键和 <code>length</code> 属性的对象</li>
<li>类数组对象：存在数值键名和 <code>length</code> 属性的对象</li>
</ol>
<h4 id="4-自定义-for-…-of"><a href="#4-自定义-for-…-of" class="headerlink" title="4 自定义 for … of"></a>4 自定义 for … of</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myForOf</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 1 获取迭代器</span></span><br><span class="line">	<span class="keyword">let</span> it = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">    <span class="comment">// 2 判断迭代是否结束</span></span><br><span class="line">	<span class="keyword">let</span> res = it.next();</span><br><span class="line">	<span class="keyword">while</span>(!res.done) &#123;</span><br><span class="line">		<span class="comment">// 3 获取值</span></span><br><span class="line">	    <span class="built_in">console</span>.log(res.value);</span><br><span class="line">	    res = it.next();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-3-label"><a href="#7-3-label" class="headerlink" title="7.3 label"></a>7.3 label</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">label（label可自定义名称）:</span><br><span class="line">	statement</span><br></pre></td></tr></table></figure>

<ul>
<li>相当于定位符，用于跳转到程序的任意位置，通常配合 <code>break</code>  和 <code>continue</code> 使用<ul>
<li><code>break [label]</code> </li>
<li><code>continue [label]</code></li>
</ul>
</li>
</ul>
<h1 id="八-展开语法（Spread-syntax）"><a href="#八-展开语法（Spread-syntax）" class="headerlink" title="八 展开语法（Spread syntax）"></a>八 展开语法（Spread syntax）</h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><ol>
<li>展开语法用  <code>...</code> 表示    </li>
<li>展开语法在函数调用或构造字面量数组时, 将<strong>可迭代对象</strong>在语法层面展开</li>
<li>展开语法在构造字面量对象时, 将对象按 <code>key:value</code> 的方式展开</li>
</ol>
<h2 id="8-2-应用"><a href="#8-2-应用" class="headerlink" title="8.2 应用"></a>8.2 应用</h2><h3 id="1-函数调用"><a href="#1-函数调用" class="headerlink" title="1 函数调用"></a>1 函数调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function show(x, y, z) &#123; &#125;</span><br><span class="line">let args = [0, 1, 2];</span><br><span class="line">show(...args); // 等价于 show(0, 1, 2)</span><br></pre></td></tr></table></figure>

<h3 id="2-构造字面量数组"><a href="#2-构造字面量数组" class="headerlink" title="2 构造字面量数组"></a>2 构造字面量数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [0, 1, 2];</span><br><span class="line">let arr2 = [3, 4, 5];</span><br><span class="line">let arr3 = [...arr1, ...arr2]; // [0,1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<h3 id="3-构造字面量对象"><a href="#3-构造字面量对象" class="headerlink" title="3 构造字面量对象"></a>3 构造字面量对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123; foo: &apos;bar&apos;, x: 42 &#125;;</span><br><span class="line">let obj2 = &#123; foo: &apos;baz&apos;, y: 13 &#125;;</span><br><span class="line">let clonedObj = &#123; ...obj1 &#125;; // 克隆后的对象: &#123; foo: &quot;bar&quot;, x: 42 &#125;</span><br><span class="line">let mergedObj = &#123; ...obj1, ...obj2 &#125;; // 合并后的对象: &#123; foo: &quot;baz&quot;, x: 42, y: 13 &#125;</span><br></pre></td></tr></table></figure>

<h1 id="九-解构赋值"><a href="#九-解构赋值" class="headerlink" title="九 解构赋值"></a>九 解构赋值</h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><ol>
<li>解构赋值：从数组和对象中提取值，对变量进行赋值</li>
<li>解构对象时会查找原型链（如果属性不在对象自身，将从原型链中查找）</li>
</ol>
<h2 id="9-2-解构数组"><a href="#9-2-解构数组" class="headerlink" title="9.2 解构数组"></a>9.2 解构数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 先声明后赋值的解构</span></span><br><span class="line"><span class="keyword">let</span> a, b;</span><br><span class="line">[a, b] = [<span class="number">10</span>, <span class="number">20</span>]; <span class="comment">// a=10 b=20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 声明并赋值的解构</span></span><br><span class="line"><span class="keyword">let</span> [a,b] = [<span class="number">10</span>, <span class="number">20</span>]; <span class="comment">// a=10 b=20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 有默认值的解构</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = <span class="number">4</span>] = [<span class="number">1</span>]; <span class="comment">// a=1 b=4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 变量数量小于数组值数量时，忽略多余值</span></span><br><span class="line"><span class="keyword">let</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; <span class="comment">// a =1 b = 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 可用于交换变量</span></span><br><span class="line"><span class="keyword">let</span> a =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">[a, b] = [b, a]; <span class="comment">// a=2 b=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6 剩余参数</span></span><br><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// a=1 b=[2,3]</span></span><br></pre></td></tr></table></figure>

<h2 id="9-3-解构对象"><a href="#9-3-解构对象" class="headerlink" title="9.3 解构对象"></a>9.3 解构对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 基本语法</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">key</span>:变量&#125; = &#123;<span class="attr">key</span>:value&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 变量名与属性名相同可以简写</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">key</span>:key&#125; = &#123;<span class="attr">key</span>:value&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;key&#125; = &#123;<span class="attr">key</span>:value&#125;; <span class="comment">// 简写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 先声明后赋值的解构</span></span><br><span class="line"><span class="keyword">let</span> name, age;</span><br><span class="line"><span class="comment">// 错误： 赋值时必须使用 `()` 包括，因为左边`&#123;name, age&#125;`会被认为是块而不是对象字面量</span></span><br><span class="line">&#123;name,age&#125; =  &#123;<span class="attr">name</span>:<span class="string">'an3'</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;); </span><br><span class="line"><span class="comment">// 正确：name='an3' age=18</span></span><br><span class="line">(&#123;name, age&#125; = &#123;<span class="attr">name</span>:<span class="string">'an3'</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 有默认值的解构</span></span><br><span class="line"><span class="keyword">let</span> &#123;name=<span class="string">'haha'</span>, age=<span class="number">10</span>&#125; = &#123;<span class="attr">name</span>:<span class="string">'an3'</span>&#125;; <span class="comment">// name='an3' age=10</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:n=<span class="string">'haha'</span> age:a=<span class="number">10</span>&#125; = &#123;<span class="attr">name</span>:<span class="string">'an3'</span>&#125;; <span class="comment">// n='an3' a=10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 变量数量小于对象键值对数量时，忽略多余值</span></span><br><span class="line"><span class="keyword">let</span> &#123;name=<span class="string">'haha'</span>, age=<span class="number">10</span>&#125; = &#123;<span class="attr">name</span>:<span class="string">'an3'</span>,<span class="attr">age</span>:<span class="number">10</span>,<span class="attr">sex</span>:<span class="number">1</span>&#125;; <span class="comment">// name='an3' age=18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6 解构嵌套</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">	name:<span class="string">'xiaoming'</span>,</span><br><span class="line">	lesson:&#123;</span><br><span class="line">		title:<span class="string">'js'</span>,</span><br><span class="line">		score:<span class="number">90</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;name,<span class="attr">lesson</span>:&#123;title,score&#125;&#125; = user;</span><br></pre></td></tr></table></figure>

<h1 id="十-全局函数"><a href="#十-全局函数" class="headerlink" title="十 全局函数"></a>十 全局函数</h1><table>
<thead>
<tr>
<th>全局函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>encodeURI(URI)</code></td>
<td>使用 UTF-8 编码，编码后的格式为UTF-8编码的每个字节前加 <code>%</code>，如 <code>安</code> 编码后 <code>%E5%AE%89</code></td>
</tr>
<tr>
<td><code>decodeURI(encodedURI)</code></td>
<td><code>encodeURI(URI)</code> 对应的解码函数</td>
</tr>
<tr>
<td><code>encodeURIComponent(str)</code></td>
<td>类似<code>encodeURI()</code>，区别在于不会编码的字符</td>
</tr>
<tr>
<td><code>decodeURIComponent(encodedURI)</code></td>
<td><code>encodeURIComponent()</code>对应的解码函数</td>
</tr>
<tr>
<td><code>isFinite(value)</code></td>
<td>同 <code>Number.isFinite(value)</code></td>
</tr>
<tr>
<td><code>isNaN(value)</code></td>
<td>同 <code>Number.isNaN(value)</code></td>
</tr>
<tr>
<td><code>parseInt(string[, radix])</code></td>
<td>同 <code>Number.parseInt(string[, radix])</code></td>
</tr>
<tr>
<td><code>parseFloat(string)</code></td>
<td>同 <code>Number.parseFloat(string)</code></td>
</tr>
<tr>
<td><code>eval(string)</code>（不要使用）</td>
<td>将传入的字符串当做 JavaScript 代码进行执行</td>
</tr>
</tbody></table>
<ul>
<li><code>encodeURI(URI)</code> 和 <code>encodeURIComponent(str)</code> 区别<ol>
<li><code>encodeURI(URI)</code> 不会编码的字符    <ol>
<li><code>; , / ? : @ &amp; = + $</code>        </li>
<li><code>字母 数字 - _ . ! ~ * &#39; ( )</code></li>
<li><code>#</code></li>
</ol>
</li>
<li><code>encodeURIComponent(str)</code> 不会编码的字符<ol>
<li><code>字母 数字 - _ . ! ~ * &#39; ( )</code></li>
</ol>
</li>
<li>使用场景<ol>
<li>对整个 URI 编码，使用 <code>encodeURI(URI)</code></li>
<li>对 URI 中的参数编码，使用 <code>encodeURIComponent(str)</code></li>
</ol>
</li>
</ol>
</li>
</ul>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/11/08/UI/JS%E5%89%8D%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/11/08/UI/JS%E5%89%8D%E8%A8%80/" class="post-title-link" itemprop="url">JS前言</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-11-08 21:07:58 / 修改时间：21:11:21" itemprop="dateCreated datePublished" datetime="2020-11-08T21:07:58+08:00">2020-11-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/JS/JS%E7%BB%84%E6%88%90.png" alt=""></p>
<ol>
<li>JavaScript 是运行在客户端的解释性脚本语言，不需要编译，由 JS 引擎逐行解释并执行</li>
<li>浏览器分成两个部分：<ul>
<li>渲染引擎：用来解析 HTML 和 CSS，俗称内核</li>
<li>JS 引擎：专门处理 JavaScript 脚本的虚拟机，也称 JS 解释器<ul>
<li><code>chrome v8</code></li>
<li><code>firefox SpiderMonkey</code></li>
<li><code>edge chakra</code></li>
<li><code>Opera Carakan</code></li>
<li>……</li>
</ul>
</li>
</ul>
</li>
<li>原本 JS 只运行在浏览器上，后来出现了 Node（包含了<code>chrome v8</code> 的 C++ 程序），JS 可以使用 Node 运行在浏览器之外</li>
<li>ECMAScript 是规范，JavaScript 是实现</li>
</ol>
<h1 id="二-引入-JavaScript-脚本"><a href="#二-引入-JavaScript-脚本" class="headerlink" title="二  引入 JavaScript 脚本"></a>二  引入 JavaScript 脚本</h1><h2 id="2-1-网页加载流程-前端"><a href="#2-1-网页加载流程-前端" class="headerlink" title="2.1  网页加载流程 - 前端"></a>2.1  网页加载流程 - 前端</h2><ol>
<li>浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。</li>
<li>css 和 html 是并行加载的，过程中如果遇到css 或者 img，则会向浏览器返回一个请求，待资源返回后，将其添加到dom的相应位置中</li>
<li>解析过程中，浏览器发现<code>&lt;script&gt;</code>元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎（原因是 JavaScript 代码可以修改 DOM，所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题。）</li>
<li>如果<code>&lt;script&gt;</code>元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</li>
<li>JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页</li>
</ol>
<h2 id="2-2-JavaScript-脚本位置"><a href="#2-2-JavaScript-脚本位置" class="headerlink" title="2.2 JavaScript 脚本位置"></a>2.2 JavaScript 脚本位置</h2><ul>
<li>浏览器加载 JavaScript 脚本，主要通过<code>&lt;script&gt;</code>元素完成，<code>&lt;script&gt;</code> 最好放在页面底部（<code>&lt;body&gt;</code> 标签后）<ol>
<li>如果外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。脚本放在页面底部，即使遇到脚本失去响应，网页主体的渲染也已经完成了，用户至少可以看到内容</li>
<li>JS 通常要操作页面中的元素，如果在 DOM 结构生成之前就调用 DOM 节点，JavaScript 会报错，脚本放在页面底部，就不存在这个问题，因为这时 DOM 肯定已经生成了。</li>
</ol>
</li>
</ul>
<h2 id="2-3-JavaScript-脚本引入方式"><a href="#2-3-JavaScript-脚本引入方式" class="headerlink" title="2.3 JavaScript 脚本引入方式"></a>2.3 JavaScript 脚本引入方式</h2><h3 id="1-内联脚本"><a href="#1-内联脚本" class="headerlink" title="1 内联脚本"></a>1 内联脚本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 第一种：直接写脚本</span></span><br><span class="line">&lt;button onclick=<span class="string">"alert('xxx')"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 2 第二种：传递脚本</span></span><br><span class="line">&lt;button onclick=<span class="string">"fn()"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert(<span class="string">'xxx'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-内部脚本"><a href="#2-内部脚本" class="headerlink" title="2 内部脚本"></a>2 内部脚本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">	<span class="comment">// 1 type 可以省略，默认 text/javascript</span></span><br><span class="line">	<span class="comment">// 2 新的浏览器可以写 application/javascript</span></span><br><span class="line">&lt;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-外部脚本"><a href="#3-外部脚本" class="headerlink" title="3 外部脚本"></a>3 外部脚本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"xxx.js&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>标签体不能有内容，<code>&lt;/script&gt;</code>不能省略</li>
<li><code>src</code> 默认是http协议</li>
<li>外部的 <code>.js</code> 脚本文件中不能包含 <code>&lt;script&gt;</code> 标签。</li>
</ol>
<h1 id="三-顶层对象"><a href="#三-顶层对象" class="headerlink" title="三 顶层对象"></a>三 顶层对象</h1><table>
<thead>
<tr>
<th>环境</th>
<th>顶层对象</th>
<th>ES2020</th>
</tr>
</thead>
<tbody><tr>
<td><code>浏览器</code></td>
<td><code>window，self</code></td>
<td><code>globalThis</code></td>
</tr>
<tr>
<td><code>Web Worker</code></td>
<td><code>self</code></td>
<td><code>globalThis</code></td>
</tr>
<tr>
<td><code>Node</code></td>
<td><code>global</code></td>
<td><code>globalThis</code></td>
</tr>
</tbody></table>
<ol>
<li>JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。</li>
<li>顶层对象在各种实现里面是不统一的</li>
<li>ES2020 标准中，引入<code>globalThis</code>作为顶层对象。也就是说，任何环境下，<code>globalThis</code>都是存在的</li>
</ol>
<h1 id="四-严格模式"><a href="#四-严格模式" class="headerlink" title="四 严格模式"></a>四 严格模式</h1><h2 id="4-1-启用"><a href="#4-1-启用" class="headerlink" title="4.1 启用"></a>4.1 启用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"use strict;"</span></span><br><span class="line"><span class="comment">// 1 放在脚本文件的第一行，整个脚本都将以严格模式运行</span></span><br><span class="line"><span class="comment">// 2 放在函数体的第一行，则整个函数以严格模式运行</span></span><br></pre></td></tr></table></figure>

<h2 id="4-2-严格模式中的变化"><a href="#4-2-严格模式中的变化" class="headerlink" title="4.2 严格模式中的变化"></a>4.2 严格模式中的变化</h2><h3 id="1-显式报错"><a href="#1-显式报错" class="headerlink" title="1 显式报错"></a>1 显式报错</h3><ol>
<li>严格模式会使引起静默失败(silently fail，不报错也没有任何效果)的赋值操作抛出异常，如只读属性的写操作，不可扩展对象扩展操作</li>
<li>严格模式下，试图删除不可删除的属性时会抛出异常</li>
<li>严格模式下禁止对象属性重名</li>
<li>严格模式下禁止函数参数重名</li>
<li>严格模式禁止八进制数字语法</li>
</ol>
<h3 id="2-安全措施"><a href="#2-安全措施" class="headerlink" title="2 安全措施"></a>2 安全措施</h3><ol>
<li>严格模式下，变量必须先声明，然后再使用</li>
<li>禁止 this 关键字指向全局对象 <code>window</code></li>
<li>严格模式禁止删除声明变量</li>
</ol>
<h3 id="3-静态绑定"><a href="#3-静态绑定" class="headerlink" title="3 静态绑定"></a>3 静态绑定</h3><ul>
<li>js允许动态绑定，即属性或方法属于哪个对象不是编译时确定的，而是在运行时确定</li>
<li>严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定，即编译时就确定属性或方法属于哪个对象。</li>
</ul>
<h3 id="4-其它"><a href="#4-其它" class="headerlink" title="4 其它"></a>4 其它</h3><ol>
<li>严格模式禁用 <code>with</code>语句</li>
<li>创设 eval 作用域<ul>
<li>正常模式下，eval语句的作用域，取决于它处于全局作用域，还是函数作用域。</li>
<li>严格模式下，eval语句本身就是一个作用域，即eval所生成的变量只能用于eval内部</li>
</ul>
</li>
<li>arguments 不再追踪参数的变化<ul>
<li>变量arguments代表函数的参数。</li>
<li>严格模式下，函数内部改变参数与arguments的联系被切断了，两者不再存在联动关系</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/11/08/UI/Less/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/11/08/UI/Less/" class="post-title-link" itemprop="url">Less</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-11-08 21:03:13 / 修改时间：21:07:15" itemprop="dateCreated datePublished" datetime="2020-11-08T21:03:13+08:00">2020-11-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-Less-概述"><a href="#一-Less-概述" class="headerlink" title="一 Less 概述"></a>一 Less 概述</h2><ol>
<li><code>Leaner Style Sheets</code></li>
<li>Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。</li>
<li>Less 可以运行在 Node 或浏览器端</li>
</ol>
<h1 id="二-变量"><a href="#二-变量" class="headerlink" title="二 变量"></a>二 变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@变量名: 值;</span><br></pre></td></tr></table></figure>

<h1 id="三-嵌套"><a href="#三-嵌套" class="headerlink" title="三 嵌套"></a>三 嵌套</h1><ol>
<li><p>使用选择器嵌套结构即可实现选择器层次关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.fu &#123;</span><br><span class="line">	div &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// .fu div &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&amp;</code> 代表当前选择器，类似于 <code>this</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	&amp;::after&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// div::after &#123;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="四-运算"><a href="#四-运算" class="headerlink" title="四 运算"></a>四 运算</h1><ol>
<li>算术运算符 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 可以对任何数字、颜色或变量进行运算</li>
<li>计算的结果以最左侧操作数的单位类型为准</li>
<li>运算符两侧必须加空格</li>
</ol>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/11/08/UI/CSS%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/11/08/UI/CSS%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/" class="post-title-link" itemprop="url">CSS媒体查询</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-11-08 21:03:06 / 修改时间：21:05:16" itemprop="dateCreated datePublished" datetime="2020-11-08T21:03:06+08:00">2020-11-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-媒体查询概述"><a href="#一-媒体查询概述" class="headerlink" title="一 媒体查询概述"></a>一 媒体查询概述</h1><ol>
<li><p><code>Media Querie</code></p>
</li>
<li><p>可以针对不同的媒体类型定义不同的样式</p>
</li>
</ol>
<h1 id="二-媒体查询语法-media"><a href="#二-媒体查询语法-media" class="headerlink" title="二 媒体查询语法 @media"></a>二 媒体查询语法 <code>@media</code></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">	@media meidatype and|not|only (media feature) &#123;</span><br><span class="line">		css code;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>语法</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td><code>meidatype</code></td>
<td>媒体类型</td>
</tr>
<tr>
<td><code>and</code></td>
<td>逻辑与</td>
</tr>
<tr>
<td><code>not</code></td>
<td>逻辑非，必须写在查询的最前面，表示对整个条件取反</td>
</tr>
<tr>
<td><code>only</code></td>
<td>必须写在查询的最前面，指定某个特定媒体类型</td>
</tr>
<tr>
<td><code>media feature</code></td>
<td>媒体特性</td>
</tr>
</tbody></table>
<h1 id="三-媒体类型"><a href="#三-媒体类型" class="headerlink" title="三 媒体类型"></a>三 媒体类型</h1><table>
<thead>
<tr>
<th><code>mediatype</code></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>all（默认）</td>
<td>所有媒体类型</td>
</tr>
<tr>
<td>screen</td>
<td>用于电脑屏幕，平板电脑，智能手机等</td>
</tr>
<tr>
<td>print</td>
<td>打印设备</td>
</tr>
<tr>
<td>speech</td>
<td>应用于屏幕阅读器等发声设备</td>
</tr>
</tbody></table>
<ul>
<li>多媒体支持<ul>
<li>可以用逗号分隔同时支持多个媒体设备 如 <code>screen, print</code></li>
</ul>
</li>
</ul>
<h1 id="四-媒体特性"><a href="#四-媒体特性" class="headerlink" title="四 媒体特性"></a>四 媒体特性</h1><table>
<thead>
<tr>
<th>媒体特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>orientation: landscape/portrait</td>
<td>横屏/竖屏</td>
</tr>
<tr>
<td>width</td>
<td>设备宽度</td>
</tr>
<tr>
<td>height</td>
<td>设备高度</td>
</tr>
<tr>
<td>min-width</td>
<td>最小宽度</td>
</tr>
<tr>
<td>max-width</td>
<td>最大宽度</td>
</tr>
<tr>
<td>min-height</td>
<td>最小高度</td>
</tr>
<tr>
<td>max-height</td>
<td>最大高度</td>
</tr>
</tbody></table>
<h1 id="五-引入资源"><a href="#五-引入资源" class="headerlink" title="五 引入资源"></a>五 引入资源</h1><h3 id="1-lt-style-gt"><a href="#1-lt-style-gt" class="headerlink" title="1  &lt;style&gt;"></a>1  <code>&lt;style&gt;</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style media=&quot;meidatype and|not|only (media feature)&gt;</span><br><span class="line">	// 满足条件则使用此内部样式</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-lt-link-gt"><a href="#2-lt-link-gt" class="headerlink" title="2 &lt;link&gt;"></a>2 <code>&lt;link&gt;</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;&quot; href=&quot;&quot; media=&quot;meidatype and|not|only (media feature)&quot;&gt;</span><br><span class="line">// 满足条件则使用导入的外部样式</span><br></pre></td></tr></table></figure>

<h3 id="3-lt-link-gt-import"><a href="#3-lt-link-gt-import" class="headerlink" title="3 &lt;link&gt; + @import"></a>3 <code>&lt;link&gt; + @import</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// test.html</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;</span><br><span class="line">// style.css</span><br><span class="line">@import url(1.css) all;</span><br><span class="line">@import url(2.css) screen;</span><br><span class="line">@import url(3.css) print;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>&lt;link&gt;</code>指定媒体类型需要导入不同的css文件，导致<code>&lt;link&gt;</code>语句过多，可以使用外部 css 文件一起导入</li>
</ul>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/anyeansan.github.io/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/anyeansan.github.io/">1</a><a class="page-number" href="/anyeansan.github.io/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/anyeansan.github.io/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/anyeansan.github.io/page/8/">8</a><a class="extend next" rel="next" href="/anyeansan.github.io/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          秘笈
        </li>
        <li class="sidebar-nav-overview">
          安₃
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="安₃"
      src="/anyeansan.github.io/images/an3.png">
  <p class="site-author-name" itemprop="name">安₃</p>
  <div class="site-description" itemprop="description">一蓑烟雨任平生</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/anyeansan.github.io/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">琅嬛福地</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/anyeansan.github.io/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">门派</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/anyeansan.github.io/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-star-half-full"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">安₃</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/anyeansan.github.io/lib/anime.min.js"></script>
  <script src="/anyeansan.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/anyeansan.github.io/lib/velocity/velocity.ui.min.js"></script>
<script src="/anyeansan.github.io/js/utils.js"></script><script src="/anyeansan.github.io/js/motion.js"></script>
<script src="/anyeansan.github.io/js/schemes/pisces.js"></script>
<script src="/anyeansan.github.io/js/next-boot.js"></script>



  




  <script src="/anyeansan.github.io/js/local-search.js"></script>













  

  

</body>
</html>
