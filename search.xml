<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mysql备份</title>
    <url>/anyeansan.github.io/2020/11/08/SQL/Mysql%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<h1 id="一-备份策略"><a href="#一-备份策略" class="headerlink" title="一 备份策略"></a>一 备份策略</h1><h2 id="1-1备份策略"><a href="#1-1备份策略" class="headerlink" title="1.1备份策略"></a>1.1备份策略</h2><ol>
<li>全量备份<ul>
<li>完整备份所有数据</li>
</ul>
</li>
<li>增量备份<ul>
<li>做一次完全备份，以后每次只备份新增的数据</li>
</ul>
</li>
<li>差异备份<ul>
<li>做一次完全备份，以后每次只备份和第一次完全备份不同的数据</li>
</ul>
</li>
</ol>
<h2 id="1-2-备份周期"><a href="#1-2-备份周期" class="headerlink" title="1.2 备份周期"></a>1.2 备份周期</h2><ol>
<li>根据数据量</li>
<li>自动</li>
</ol>
<h2 id="1-3-备份类型"><a href="#1-3-备份类型" class="headerlink" title="1.3 备份类型"></a>1.3 备份类型</h2><ol>
<li>热备<ul>
<li>在数据库正常业务时,备份数据,并且能够一致性恢复（只能是innodb）</li>
</ul>
</li>
<li>温备<ul>
<li>锁表备份,只能查询不能修改（myisam）</li>
</ul>
</li>
<li>冷备<ul>
<li>关闭数据库业务,数据库没有任何变更的情况下,进行备份数据.</li>
</ul>
</li>
</ol>
<h2 id="1-4-备份工具"><a href="#1-4-备份工具" class="headerlink" title="1.4 备份工具"></a>1.4 备份工具</h2><ol>
<li><code>mysqldump</code></li>
<li><code>Xtrabackup</code><ul>
<li>percona 数据库默认</li>
</ul>
</li>
<li><code>mysqlbinlog</code></li>
</ol>
<h2 id="1-5-备份方式"><a href="#1-5-备份方式" class="headerlink" title="1.5 备份方式"></a>1.5 备份方式</h2><ol>
<li>逻辑（基于 SQL 语句备份）<ol>
<li>全备：<code>mysqldump</code></li>
<li>增量：<code>mysqlbinlog</code></li>
</ol>
</li>
<li>物理（基于磁盘数据文件备份）<ol>
<li>全备：<code>Xtrabackup</code></li>
<li>增量：<code>Xtrabackup</code></li>
</ol>
</li>
</ol>
<h1 id="二-mysqldump"><a href="#二-mysqldump" class="headerlink" title="二 mysqldump"></a>二 mysqldump</h1><h2 id="2-1-连接数据库"><a href="#2-1-连接数据库" class="headerlink" title="2.1 连接数据库"></a>2.1 连接数据库</h2><ul>
<li><code>mysqldupm OPTION</code><ul>
<li><code>OPTION</code><ul>
<li><code>-u</code></li>
<li><code>-p</code></li>
<li><code>-S</code></li>
<li><code>-h</code></li>
<li><code>-P</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-2-基础参数"><a href="#2-2-基础参数" class="headerlink" title="2.2 基础参数"></a>2.2 基础参数</h2><ol>
<li><code>-A</code><ul>
<li>全备</li>
</ul>
</li>
<li><code>-B db1 db2 ...</code><ul>
<li>备份多个数据库</li>
</ul>
</li>
<li><code>db t1 t2 ...</code><ul>
<li>备份指定数据的表</li>
</ul>
</li>
</ol>
<h2 id="2-3-特殊参数"><a href="#2-3-特殊参数" class="headerlink" title="2.3 特殊参数"></a>2.3 特殊参数</h2><ol>
<li><code>-R</code><ul>
<li>备份备份存储过程及函数</li>
</ul>
</li>
<li><code>-E</code><ul>
<li>备份事件</li>
</ul>
</li>
<li><code>--triggers</code><ul>
<li>备份触发器</li>
</ul>
</li>
<li><code>-F</code><ul>
<li>在备份开始时,刷新一个新 binlog 日志</li>
</ul>
</li>
<li><code>--master-data=2</code><ul>
<li>以注释的形式，保存备份开始时间点的 binlog 的状态信息</li>
</ul>
</li>
<li><code>--single-transaction</code><ol>
<li>不加 ，温备份，所有表都锁定</li>
<li>加上，对 innodb 表进行快照备份（不锁表），对非 innodb 表可以实现自动锁表功能</li>
</ol>
</li>
<li><code>--set-gtid-purged=auto/on/off</code></li>
<li><code>--max-allowed-packet=#</code></li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql日志</title>
    <url>/anyeansan.github.io/2020/11/08/SQL/Mysql%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="一-日志分类"><a href="#一-日志分类" class="headerlink" title="一 日志分类"></a>一 日志分类</h1><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Error log</code></td>
<td>错误日志</td>
</tr>
<tr>
<td><code>Binary log</code></td>
<td>二进制日志</td>
</tr>
<tr>
<td><code>Slow query log</code></td>
<td>慢查询日志</td>
</tr>
<tr>
<td><code>General query log</code></td>
<td>常规日志</td>
</tr>
</tbody></table>
<h1 id="二-错误日志"><a href="#二-错误日志" class="headerlink" title="二 错误日志"></a>二 错误日志</h1><ol>
<li>默认开启</li>
<li>默认存储位置 <code>datadir/hostname.err</code></li>
<li><code>select @@log_error</code><ul>
<li>查看错误日志位置</li>
</ul>
</li>
<li>手动配置 <code>/etc/my.cnf</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log_error=路径</span><br></pre></td></tr></table></figure>

<h1 id="三-二进制日志"><a href="#三-二进制日志" class="headerlink" title="三 二进制日志"></a>三 二进制日志</h1><h2 id="3-1-作用"><a href="#3-1-作用" class="headerlink" title="3.1 作用"></a>3.1 作用</h2><ol>
<li>主从环境必须依赖二进制日志</li>
<li>备份恢复必须依赖二进制日志</li>
</ol>
<h2 id="3-2-配置"><a href="#3-2-配置" class="headerlink" title="3.2 配置"></a>3.2 配置</h2><ol>
<li>默认没有开启</li>
<li>手动配置 <code>/etc/my.cnf</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">1 server_id= </span><br><span class="line">	# 服务ID号 0 ~ 65535</span><br><span class="line">2 log_bin=1</span><br><span class="line">	# 开启二进制日志</span><br><span class="line">3 log_bin_basename=/目录/二进制日志文件名前缀</span><br><span class="line">	# 设置存储目录及文件前缀</span><br><span class="line">4 log_bin=/目录/二进制日志文件名前缀</span><br><span class="line">	# 等同于 2,3两步</span><br><span class="line">5 binlog_format=row</span><br><span class="line">	# 二进制日志格式，5.7 默认配置，可以省略</span><br><span class="line">6 sync_binlog=1</span><br><span class="line">	# 每次提交都立即刷写binlog到磁盘</span><br></pre></td></tr></table></figure>

<h2 id="3-3-二进制日志记录内容"><a href="#3-3-二进制日志记录内容" class="headerlink" title="3.3 二进制日志记录内容"></a>3.3 二进制日志记录内容</h2><h3 id="1-内容"><a href="#1-内容" class="headerlink" title="1 内容"></a>1 内容</h3><ul>
<li>记录了数据库所有变更类的操作日志<ol>
<li>DDL：原封不动的记录当前 DDL（statement 语句方式），即原样记录语句</li>
<li>DCL：原封不动的记录当前 DCL（statement 语句方式）</li>
<li>DML：只记录已经提交的事务 DML</li>
</ol>
</li>
</ul>
<h3 id="2-DML-记录模式"><a href="#2-DML-记录模式" class="headerlink" title="2 DML 记录模式"></a>2 DML 记录模式</h3><ol>
<li><code>statment</code><ul>
<li>SBR（statement based replication）模式</li>
<li>语句模式，原封不动的记录当前DML</li>
<li>可读性较高，日志量少，但是不够严谨</li>
</ul>
</li>
<li><code>row</code><ul>
<li>RBR（ROW based replication）模式</li>
<li>记录数据行的变化（用户看不懂，需要工具分析）</li>
<li>可读性很低，日志量大，足够严谨</li>
</ul>
</li>
<li><code>mixed</code><ul>
<li>MBR（mixed based replication）模式 </li>
<li>以上两种模式的混合</li>
</ul>
</li>
</ol>
<h2 id="3-4-二进制日记记录单元-event"><a href="#3-4-二进制日记记录单元-event" class="headerlink" title="3.4 二进制日记记录单元 event"></a>3.4 二进制日记记录单元 event</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>event 是二进制日志的最小记录单元</li>
<li>DDL DCL<ul>
<li>一个语句就是一个 event</li>
</ul>
</li>
<li>DML ：只记录已提交的事务<ol>
<li>begin 是一个 event</li>
<li>DML 语句的 event</li>
<li>commit 是一个 event</li>
</ol>
</li>
</ol>
<h3 id="2-event-组成"><a href="#2-event-组成" class="headerlink" title="2 event 组成"></a>2 event 组成</h3><ol>
<li>事件的开始标识：<code>position</code> 号</li>
<li>事件内容</li>
<li>事件的结束标识：<code>end_log_position</code> 号</li>
</ol>
<h2 id="3-5-二进制日志-操作"><a href="#3-5-二进制日志-操作" class="headerlink" title="3.5 二进制日志 操作"></a>3.5 二进制日志 操作</h2><h3 id="1-查看信息"><a href="#1-查看信息" class="headerlink" title="1 查看信息"></a>1 查看信息</h3><ol>
<li><code>show variables like &#39;%log_bin%&#39;</code><ul>
<li>查看二进制日志路径</li>
</ul>
</li>
<li><code>show binary logs</code><ul>
<li>查看所有二进制日志</li>
</ul>
</li>
<li><code>show master status</code><ul>
<li>查看当前使用的二进制日志</li>
</ul>
</li>
<li><code>show binlog events in &#39;log_name&#39; [from pos] [limit]</code><ul>
<li>查看二进制日志 event 信息</li>
</ul>
</li>
</ol>
<h3 id="2-查看内容-mysqlbinlog"><a href="#2-查看内容-mysqlbinlog" class="headerlink" title="2 查看内容 mysqlbinlog"></a>2 查看内容 mysqlbinlog</h3><ul>
<li><code>mysqlbinlog [OPTION] 日志路径</code><ul>
<li><code>--base64-output=decode-rows</code><ul>
<li>以指定格式输出</li>
</ul>
</li>
<li><code>-vvv</code><ul>
<li>更详细</li>
</ul>
</li>
<li><code>--start-position</code><ul>
<li>开始位置</li>
</ul>
</li>
<li><code>--stop-position</code><ul>
<li>结束位置</li>
</ul>
</li>
<li><code>-d db_name</code><ul>
<li>只查看指定库的日志</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-恢复"><a href="#3-恢复" class="headerlink" title="3 恢复"></a>3 恢复</h3><ol>
<li><code>mysqlbinlog --start-position= --stop--position= &gt;/tmp/log.sql</code><ul>
<li>将指定位置的二进制日志内容截取出来输出到一个文件，其实就是sql脚本，执行即可</li>
</ul>
</li>
<li><code>set sql_log_bin=0</code><ul>
<li>临时关闭二进制日志，因为恢复时也会产生二进制日志，没有必要</li>
</ul>
</li>
<li><code>source /tmp/log.sql</code></li>
<li><code>set sql_log_bin=1</code></li>
</ol>
<h2 id="3-6-GTID-模式管理二进制日志"><a href="#3-6-GTID-模式管理二进制日志" class="headerlink" title="3.6 GTID 模式管理二进制日志"></a>3.6 GTID 模式管理二进制日志</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>GTID <code>Global Transaction ID</code></li>
<li>对二进制日志中每一个事务，自动生成一个 GTID 号<ol>
<li>DDL DCL<ul>
<li>一个 event 就是一个事务，就有一个 GTID</li>
</ul>
</li>
<li>DML<ul>
<li>一个事务（从 begin 到 commit）一个 GTID</li>
</ul>
</li>
</ol>
</li>
<li>GTID 幂等性<ul>
<li>使用有 GTID 的二进制日志做恢复时，会检查当前系统是否有相同的 GTID，若有则跳过不再执行。</li>
<li>会影响恢复和主从复制</li>
</ul>
</li>
</ol>
<h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2 配置"></a>2 配置</h3><ol>
<li>默认未开启</li>
<li><code>/etc/my.cnf</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">gtid-mode=on</span><br><span class="line">enforce-gtid-consistency=true</span><br></pre></td></tr></table></figure>

<h3 id="3-GTID-组成"><a href="#3-GTID-组成" class="headerlink" title="3 GTID 组成"></a>3 GTID 组成</h3><ul>
<li><code>server_uuid:transaction_id</code><ul>
<li><code>server_uuid</code><ul>
<li>启动 mysql 自动生成，存储在 <code>datadir/auto.cnf</code></li>
</ul>
</li>
<li><code>transaction_id</code><ul>
<li>从 1 开始，自增长</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-查看有-GTID-的日志内容"><a href="#4-查看有-GTID-的日志内容" class="headerlink" title="4 查看有 GTID 的日志内容"></a>4 查看有 GTID 的日志内容</h3><ul>
<li><code>mysqlbinlog [OPTION] 日志路径</code><ul>
<li><code>OPTION</code><ul>
<li><code>--incude-gtids</code><ul>
<li>包含指定 gtid，多个逗号隔开，连续可以 <code>server_uuid:1-8</code></li>
</ul>
</li>
<li><code>--exclude-gtids</code><ul>
<li>排除指定 gtid</li>
</ul>
</li>
<li><code>--skip-gtids</code><ul>
<li>由于 gtid 的幂等性，导出的 sql 执行时会报错，因为已经存在相同 gtid</li>
<li>此选项表示：导出时，忽略原有的 GTID 信息，恢复时当作新事务对待</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-基于-GTID-的恢复"><a href="#5-基于-GTID-的恢复" class="headerlink" title="5  基于 GTID 的恢复"></a>5  基于 GTID 的恢复</h3><ol>
<li><code>mysqlbinlog --skip-gtids --include-gtids= 日志路径&gt;/tmp/log.sql</code></li>
<li><code>set sql_log_bin=0</code></li>
<li><code>source /tmp/log.sql</code></li>
<li><code>set sql_log_bin=1</code></li>
</ol>
<h2 id="3-7-二进制日志清理"><a href="#3-7-二进制日志清理" class="headerlink" title="3.7 二进制日志清理"></a>3.7 二进制日志清理</h2><h3 id="1-自动清理"><a href="#1-自动清理" class="headerlink" title="1 自动清理"></a>1 自动清理</h3><ul>
<li><code>expire_logs_days</code><ul>
<li>二进制日志过期天数，<code>0</code> 表示永不过期</li>
<li>建议至少保留两个全备周期 +1</li>
</ul>
</li>
</ul>
<h3 id="2-手动清理"><a href="#2-手动清理" class="headerlink" title="2 手动清理"></a>2 手动清理</h3><ol>
<li><code>purge binary logs to &#39;log_name&#39;</code><ul>
<li>删除指定日志之前的日志</li>
</ul>
</li>
<li><code>purge binary logs before &#39;time&#39;</code><ul>
<li>删除指定日期之前的日志</li>
</ul>
</li>
</ol>
<h2 id="3-8-日志滚动"><a href="#3-8-日志滚动" class="headerlink" title="3.8 日志滚动"></a>3.8 日志滚动</h2><ol>
<li><code>flush logs</code></li>
<li>重启 mysql 会自动滚动一个新的</li>
<li>日志文件达到 <code>max_binlog_size</code></li>
</ol>
<h1 id="四-慢查询日志"><a href="#四-慢查询日志" class="headerlink" title="四 慢查询日志"></a>四 慢查询日志</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ul>
<li>记录运行较慢的 SQL语句，优化常用</li>
</ul>
<h2 id="4-2-配置"><a href="#4-2-配置" class="headerlink" title="4.2 配置"></a>4.2 配置</h2><ol>
<li>默认未开启</li>
<li><code>/etc/my.cnf</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">1 slow_query_log=1 </span><br><span class="line">	# 开启 </span><br><span class="line">2 slow_query_log_file=/目录/文件</span><br><span class="line">	# 日志文件路径</span><br><span class="line">3 long_query_time=0.1</span><br><span class="line">	# 设置慢查询时间，超过此时间就算慢，默认 10.000000 10秒，小数位表示粒度</span><br><span class="line">4 log_queries_not_using_indexes</span><br><span class="line">	# 没走索引的语句也记录</span><br></pre></td></tr></table></figure>

<h2 id="4-3-分析"><a href="#4-3-分析" class="headerlink" title="4.3 分析"></a>4.3 分析</h2><ul>
<li><code>mysqldumpslow -s c -t N 日志路径</code><ul>
<li><code>-s c</code><ul>
<li>sort，按次数排序</li>
</ul>
</li>
<li><code>-t N</code><ul>
<li>top，取前多少个</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-4-相关参数"><a href="#4-4-相关参数" class="headerlink" title="4.4 相关参数"></a>4.4 相关参数</h2><ol>
<li><code>slow_query_log</code></li>
<li><code>long_query_time</code></li>
<li><code>log_throttle_queries_not_using_indexes</code></li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql触发器</title>
    <url>/anyeansan.github.io/2020/11/08/SQL/Mysql%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>事先为某张表绑定好一段代码 ,当表中的某些内容发生改变的时候（增删改）系统会自动触发代码执行</li>
<li>事件类型<ul>
<li>增 <code>insert</code></li>
<li>删 <code>delete</code></li>
<li>改 <code>update</code></li>
</ul>
</li>
<li>触发时间<ul>
<li>前 <code>before</code></li>
<li>后 <code>after</code></li>
</ul>
</li>
<li>一张表最多能有 6 种触发器（事件类型 + 触发事件）<ol>
<li><code>增 前/后</code></li>
<li><code>删 前/后</code></li>
<li><code>改 前/后</code></li>
</ol>
</li>
<li>触发对象<ul>
<li>表中的每一条记录（行）</li>
</ul>
</li>
<li><code>new/old</code><ul>
<li>可以用来获取新添加的或者删除的记录</li>
</ul>
</li>
</ol>
<h1 id="二-创建触发器"><a href="#二-创建触发器" class="headerlink" title="二 创建触发器"></a>二 创建触发器</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 1 临时修改语句结束符</span><br><span class="line">Delimiter 自定义符号</span><br><span class="line">-- 2 </span><br><span class="line">Create trigger 触发器名字 触发时间 事件类型 on 表名 for each row</span><br><span class="line">-- 3 </span><br><span class="line">Begin		</span><br><span class="line">	触发器的内容</span><br><span class="line">End	</span><br><span class="line">-- 4 语句结束符</span><br><span class="line">自定义符号</span><br><span class="line">-- 5 将临时修改修正过来</span><br><span class="line">Delimiter ;</span><br></pre></td></tr></table></figure>

<h1 id="三-触发器管理"><a href="#三-触发器管理" class="headerlink" title="三 触发器管理"></a>三 触发器管理</h1><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>show triggers</code></td>
<td>查看所有触发器</td>
</tr>
<tr>
<td><code>show create trigger 触发器名</code></td>
<td>查看触发器创建语句</td>
</tr>
<tr>
<td><code>drop trigger 触发器名</code></td>
<td>删除触发器</td>
</tr>
</tbody></table>
<ul>
<li><code>Information_schema.triggers</code><ul>
<li>所有的触发器信息都保存此表中</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql存储过程</title>
    <url>/anyeansan.github.io/2020/11/08/SQL/Mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一-Procedure概述"><a href="#一-Procedure概述" class="headerlink" title="一 Procedure概述"></a>一 Procedure概述</h1><ol>
<li>存储过程是一组为了完成特定功能的 sql 语句和流程控制语句的预编译集合，存储在数据库内，可以由应用程序调用。</li>
<li>存储过程的好处<ol>
<li>可复用</li>
<li>预编译：只在创建时编译一次，以后调用时不再编译，速度快</li>
<li>减少网络流量：存储过程存储在数据库服务器上，都在数据库服务器上运行，调用存储过程时只需要传递名称和参数即可。</li>
<li>安全：可防止sql注入</li>
</ol>
</li>
</ol>
<h1 id="二-存储过程和自定义函数的区别"><a href="#二-存储过程和自定义函数的区别" class="headerlink" title="二 存储过程和自定义函数的区别"></a>二 存储过程和自定义函数的区别</h1><ol>
<li>存储过程实现的功能更复杂，函数的针对性更强</li>
<li>存储过程可以返回多个值，函数只能返回一个值</li>
<li>存储过程一般单独执行，函数可以作为其它sql语句的组成部分。</li>
</ol>
<h1 id="三-语法"><a href="#三-语法" class="headerlink" title="三 语法"></a>三 语法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE</span><br><span class="line">	[DEFINER = user]</span><br><span class="line">	PROCEDURE sp_name ([proc_parameter[,...]])</span><br><span class="line">	[characteristic ...]</span><br><span class="line">	routine_body</span><br><span class="line"></span><br><span class="line">proc_parameter:</span><br><span class="line">    [ IN | OUT | INOUT ] param_name type</span><br></pre></td></tr></table></figure>

<h1 id="四-创建"><a href="#四-创建" class="headerlink" title="四 创建"></a>四 创建</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE IF EXISTS 存储过程名;</span><br><span class="line">-- 1 修改结束符，自定义，如$$</span><br><span class="line">DELIMITER [结束标记]</span><br><span class="line">CREATE PROCEDURE 存储过程名([参数列表])</span><br><span class="line">BEGIN</span><br><span class="line">        [存储过程体(一组合法的SQL语句)]</span><br><span class="line">END [结束标记]</span><br><span class="line">-- 2 将结束符改回分号</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<ul>
<li>形参：参数名 参数类型<ul>
<li><code>in</code><ul>
<li>输入参数，调用存储过程时传入的值</li>
<li>可以省略</li>
</ul>
</li>
<li><code>out</code><ul>
<li>输出参数，可在存储过程内部被改变并返回。</li>
<li><code>into</code>：使用 <code>into</code> 为out参数赋值</li>
</ul>
</li>
<li><code>inout</code><ul>
<li>输入输出参数，调用存储过程时传入值，在存储过程内部可以改变并返回。</li>
</ul>
</li>
</ul>
</li>
<li>返回值<ul>
<li>存储过程可以有返回值也可以没有返回值。</li>
</ul>
</li>
</ul>
<h1 id="五-管理"><a href="#五-管理" class="headerlink" title="五 管理"></a>五 管理</h1><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>show procedure status</code></td>
<td>查看所有存储过程</td>
</tr>
<tr>
<td><code>show create procedure 存储过程名</code></td>
<td>查看存储过程创建语句</td>
</tr>
<tr>
<td><code>drop procedoure [if exists] 存储过程名</code></td>
<td>删除存储过程</td>
</tr>
</tbody></table>
<h1 id="六-调用"><a href="#六-调用" class="headerlink" title="六 调用"></a>六 调用</h1><ul>
<li><code>call 存储过程名(in参数, @out参数, @inout参数)</code><ol>
<li>存储过程没有返回值（通过out返回），不能用select调用。</li>
<li>实参<ol>
<li>in参数：直接传递即可</li>
<li>out参数：定义一个变量接收返回值<code>@变量名</code></li>
<li>inout参数：在外部定义一个变量，并设置值</li>
</ol>
</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// in</span><br><span class="line">call inpr(3);</span><br><span class="line">// out</span><br><span class="line">call outpr(@name);</span><br><span class="line">select @name;</span><br><span class="line">// inout</span><br><span class="line">set @age = 10;</span><br><span class="line">call inoutpr(@age);</span><br><span class="line">select @age;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>CS</category>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql视图</title>
    <url>/anyeansan.github.io/2020/11/08/SQL/Mysql%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="一-View-概述"><a href="#一-View-概述" class="headerlink" title="一 View 概述"></a>一 View 概述</h1><ol>
<li>view可以看作是一张虚拟表，是表通过某种运算得到的一个投影。</li>
<li>视图中并没有真正存储数据。</li>
<li>表的改变会影响视图(视图就好像表的影子一样)</li>
<li>视图的改变也能影响表。(如果可以改变的话)</li>
<li>可以跟基本表一样，进行增删改查操作</li>
</ol>
<h1 id="二-数据操作"><a href="#二-数据操作" class="headerlink" title="二 数据操作"></a>二 数据操作</h1><ol>
<li>主要是用来查询</li>
<li>增删改操作有条件限制<ul>
<li>如果视图的数据与表的数据是一一对应出来的，改变不会影响其它数据，就可以增删改。</li>
<li>如果视图的数据是通过计算得来的，改变则会影响表中的其它数据，不可以增删改。</li>
</ul>
</li>
<li>可更新视图：没有以下语句<ul>
<li><code>distinct</code></li>
<li>聚合函数</li>
<li><code>group by / having</code></li>
<li><code>union</code></li>
</ul>
</li>
<li><code>with check option</code><ul>
<li>在视图的 <code>select</code> 语句后添加可以防止更新或删除已有的视图数据</li>
</ul>
</li>
</ol>
<h1 id="三-视图作用"><a href="#三-视图作用" class="headerlink" title="三 视图作用"></a>三 视图作用</h1><ol>
<li>方便操作，特别是查询操作，减少复杂的SQL语句<ul>
<li>将一条复杂的查询语句使用视图进行保存: 以后可以直接对视图进行操作</li>
</ul>
</li>
<li>数据安全<ul>
<li>视图操作是主要针对查询的, 如果对视图结构进行处理(删除), 不会影响基表数据(相对安全).</li>
<li>可以对外提供有用的数据, 但是隐藏关键(无用)的数据</li>
<li>数据库授权命令不能限定到特定行和特定列，但是通过合理创建视图，可以把权限限定到行列级别</li>
</ul>
</li>
<li>权限控制<ul>
<li>不希望用户访问表中某些含敏感信息的列,可以通过view开放某几个列</li>
</ul>
</li>
<li>数据过多时，分表用</li>
</ol>
<h1 id="四-视图管理"><a href="#四-视图管理" class="headerlink" title="四 视图管理"></a>四 视图管理</h1><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>create [or replace] view 视图名 as select语句</code></td>
<td>创建视图</td>
</tr>
<tr>
<td><code>show create view 视图名</code></td>
<td>查看视图</td>
</tr>
<tr>
<td><code>desc 视图名</code></td>
<td></td>
</tr>
<tr>
<td><code>drop view 视图名</code></td>
<td>删除视图</td>
</tr>
<tr>
<td><code>alter view 视图名 as 新的select语句</code></td>
<td>视图本身不可修改，但视图来源可以修改</td>
</tr>
</tbody></table>
<ul>
<li>视图是一张虚拟表，表的所有查看方式，视图都能用，且视图比表多一个关键字 <code>view</code> </li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql索引</title>
    <url>/anyeansan.github.io/2020/11/08/SQL/Mysql%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>系统根据某种算法，将已有的数据（或未来可能新增的数据）单独建立一个文件，此文件能够实现快速的匹配数据，并且能够快速的找到对应表中的记录</li>
<li>几乎所有的索引都是建立在字段之上</li>
<li>索引本身会产生索引文件(有时候有可能比数据文件还大)，会占用磁盘空间.</li>
<li>索引类似书或字典前边的目录，提升查询速度，但是增删改时，索引也要动态的维护，降低了效率。</li>
<li>索引是在存储引擎中实现的，也就是说不同的存储引擎，会使用不同算法的索引<ol>
<li><code>B-tree</code></li>
<li><code>FullText</code></li>
<li><code>Hash</code></li>
<li><code>GIS</code></li>
<li><code>R-tree</code></li>
</ol>
</li>
</ol>
<h1 id="二-作用"><a href="#二-作用" class="headerlink" title="二 作用"></a>二 作用</h1><ol>
<li>优化查询<ul>
<li>如果某个字段需要作为查询的条件经常使用，那么可以使用索引</li>
</ul>
</li>
<li>约束数据的有效性<ul>
<li>如果某个字段需要进行数据的有效性约束, 也可能使用索引（主键,唯一键 …）</li>
</ul>
</li>
</ol>
<h1 id="三-索引分类"><a href="#三-索引分类" class="headerlink" title="三 索引分类"></a>三 索引分类</h1><ol>
<li>普通索引 <code>MUL</code><ol>
<li>单列索引</li>
<li>多列索引（联合索引）</li>
<li>前缀索引（建索引时，可以只索引列的一部分内容）</li>
</ol>
</li>
<li>唯一索引 <code>UNI</code></li>
<li>主键索引 <code>PRI</code>（也叫聚合索引，MySql 会自动将主键索引添加到所有从属索引中）</li>
<li>全文索引</li>
</ol>
<h1 id="四-索引管理"><a href="#四-索引管理" class="headerlink" title="四 索引管理"></a>四 索引管理</h1><h2 id="4-1-查"><a href="#4-1-查" class="headerlink" title="4.1 查"></a>4.1 查</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>desc 表名</code></td>
<td>通过表结构可以查看索引</td>
</tr>
<tr>
<td><code>show index in/from 表名</code></td>
<td>查看索引详细信息</td>
</tr>
</tbody></table>
<h2 id="4-2-增"><a href="#4-2-增" class="headerlink" title="4.2 增"></a>4.2 增</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>alter table 表名 add index 索引名(字段列表)</code></td>
<td>添加普通索引</td>
</tr>
<tr>
<td><code>create index 索引名 on 表名(字段列表)</code></td>
<td>添加普通索引</td>
</tr>
<tr>
<td><code>alter table 表名 add unique index 索引名(字段列表)</code></td>
<td>添加唯一索引</td>
</tr>
<tr>
<td><code>create unique index 索引名 on 表名(字段列表)</code></td>
<td>添加唯一索引</td>
</tr>
<tr>
<td><code>alter table 表名 add primary key(字段列表)</code></td>
<td>添加主键索引</td>
</tr>
</tbody></table>
<h2 id="4-3-删"><a href="#4-3-删" class="headerlink" title="4.3 删"></a>4.3 删</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>alter table 表名 drop index 索引名</code></td>
<td>删除索引</td>
</tr>
<tr>
<td><code>drop index 索引名 on 表名</code></td>
<td>删除索引</td>
</tr>
</tbody></table>
<h1 id="五-执行计划"><a href="#五-执行计划" class="headerlink" title="五 执行计划"></a>五 执行计划</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol>
<li>SQL 层解析器会生成多个执行计划，优化器会选择最优的执行计划</li>
<li>执行计划分析<ul>
<li>就是在执行前获取这个最优执行计划，查看其计划信息，可以有效的防止性能较差的语句带来的性能问题</li>
</ul>
</li>
</ol>
<h2 id="5-2-获取执行计划"><a href="#5-2-获取执行计划" class="headerlink" title="5.2 获取执行计划"></a>5.2 获取执行计划</h2><ol>
<li><code>desc sql语句</code></li>
<li><code>explain sql语句</code></li>
</ol>
<h2 id="5-3-执行计划分析"><a href="#5-3-执行计划分析" class="headerlink" title="5.3 执行计划分析"></a>5.3 执行计划分析</h2><ol>
<li><code>table</code><ul>
<li>查询所操作的表</li>
</ul>
</li>
<li><code>type</code><ol>
<li>全表扫描：<code>all</code><ul>
<li>不走索引<ol>
<li>没有查询条件，或者查询条件列无索引</li>
<li>查询结构集是原表中的大部分数据，一般25%以上</li>
<li><code>! not</code><ul>
<li>普通索引列</li>
</ul>
</li>
<li><code>like %xxx</code></li>
<li>联合索引有时只走部分索引</li>
</ol>
</li>
</ul>
</li>
<li>索引扫描（性能依次变好）<ol>
<li><code>index</code><ul>
<li>全索引扫描<ul>
<li>无条件查询索引列 <code>select id from t</code></li>
</ul>
</li>
</ul>
</li>
<li><code>range</code><ul>
<li>索引范围扫描<ol>
<li><code>&gt; &gt;= &lt; &lt;= between and or in()</code></li>
<li><code>like xxx%</code></li>
<li><code>! not</code><ul>
<li>主键索引或唯一索引列</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><code>ref</code><ul>
<li>普通索引列的等值查询</li>
</ul>
</li>
<li><code>eq_ref</code><ul>
<li>在多表连接时，子表（被连接表）使用主键列或者唯一列作为连接条件</li>
</ul>
</li>
<li><code>consist(system)</code><ul>
<li>主键索引或唯一索引列的等值查询</li>
</ul>
</li>
<li><code>null</code></li>
</ol>
</li>
</ol>
</li>
<li><code>possible_key</code><ul>
<li>可能会用到的索引</li>
</ul>
</li>
<li><code>key</code><ul>
<li>真正使用的索引</li>
</ul>
</li>
<li><code>key_len</code><ul>
<li>索引最大预留长度</li>
</ul>
</li>
<li><code>extra</code><ul>
<li><code>using filesort</code><ul>
<li>说明查询中有关排序的条件列没有合理的应用索引，因为索引本身已经是有序的</li>
</ul>
</li>
</ul>
</li>
<li><code>rows</code><ul>
<li>扫描行数</li>
</ul>
</li>
</ol>
<h1 id="六-联合索引"><a href="#六-联合索引" class="headerlink" title="六 联合索引"></a>六 联合索引</h1><h2 id="6-1-联合索引说明"><a href="#6-1-联合索引说明" class="headerlink" title="6.1 联合索引说明"></a>6.1 联合索引说明</h2><ul>
<li>优化器会自动对查询条件按照索引创建时的顺序排序<ol>
<li>最终使用的索引列是排序后连续的等值比较查询</li>
<li>也就是说碰到不连续的或者非等值比较查询（&gt; &gt;= &lt; &lt;= like …）就会停止</li>
</ol>
</li>
<li>例：创建联合索引 <code>inx_haha(a,b,c,d)</code><ol>
<li>查询条件是 <code>b= c= a= d=</code>，排序后 <code>a= b= c= d=</code>，最终使用的索引列 <code>abcd</code></li>
<li>查询条件是 <code>b= a= d=</code>，排序后 <code>a= b= d=</code>，最终使用的索引列 <code>ab</code></li>
<li>查询条件是 <code>c= a= d=</code>，排序后 <code>a= c= d=</code>，最终使用的索引列 <code>a</code></li>
<li>查询条件是 <code>b&gt; a= c= d=</code>，排序后 <code>a= b&gt; c= d=</code>，最终使用的索引列 <code>ab</code></li>
</ol>
</li>
</ul>
<h2 id="6-2-联合索引优化"><a href="#6-2-联合索引优化" class="headerlink" title="6.2 联合索引优化"></a>6.2 联合索引优化</h2><ol>
<li>创建联合索引时唯一键多的列放在最左侧</li>
<li>创建联合索引时等值比较的列放在最左侧</li>
<li>如果查询中出现多种子句（where group by …），要按照子句的执行顺序建立索引</li>
</ol>
<h1 id="七-索引应用规范"><a href="#七-索引应用规范" class="headerlink" title="七 索引应用规范"></a>七 索引应用规范</h1><ol>
<li>建表必须有主键，一般是个无关列，自增值</li>
<li>经常需要where 、ORDER BY、GROUP BY,join on等操作的列建立索引，</li>
<li>值长度较长的列，建议使用前缀索引</li>
<li>索引不是越多越好，不要创建无用索引，不常使用的索引要清理</li>
<li>索引维护避开业务繁忙期</li>
<li>小表不建索引</li>
<li>联合索引优化</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql事务</title>
    <url>/anyeansan.github.io/2020/11/08/SQL/Mysql%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="一-ACID-特性"><a href="#一-ACID-特性" class="headerlink" title="一 ACID 特性"></a>一 ACID 特性</h1><table>
<thead>
<tr>
<th>特性</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Atomicity</code></td>
<td>原子性</td>
<td>一个事务是一个不可分割的单元，事务中的操作要么都成功，要么都取消</td>
</tr>
<tr>
<td><code>Consistency</code></td>
<td>一致性</td>
<td>事务的执行不能破坏数据库数据的完整性和一致性</td>
</tr>
<tr>
<td><code>Isolation</code></td>
<td>隔离性</td>
<td>事务之间是互不干扰的</td>
</tr>
<tr>
<td><code>Durability</code></td>
<td>持久性</td>
<td>一个事务一旦被提交，它对数据库中数据的改变就是永久性的</td>
</tr>
</tbody></table>
<h1 id="二-事务的生命周期"><a href="#二-事务的生命周期" class="headerlink" title="二 事务的生命周期"></a>二 事务的生命周期</h1><h2 id="2-1-标准生命周期"><a href="#2-1-标准生命周期" class="headerlink" title="2.1 标准生命周期"></a>2.1 标准生命周期</h2><table>
<thead>
<tr>
<th>阶段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>begin &#124; start transction &#124; set autocommit=0</code></td>
<td>开启事务</td>
</tr>
<tr>
<td><code>DML（insert update delete）</code></td>
<td>数据操作</td>
</tr>
<tr>
<td><code>commit &#124; rollback</code></td>
<td>结束事务</td>
</tr>
</tbody></table>
<ul>
<li>注意：开启事务后，在事务中执行一些语句会触发隐式提交（应避免）<ol>
<li>DDL（<code>alte</code> <code>create</code> <code>drop</code> <code>truncate</code>）</li>
<li>DCL（<code>grant</code> <code>revoke</code> <code>set password</code>）</li>
<li>锁（<code>lock tables</code> <code>unlock tables</code>）</li>
<li>…</li>
</ol>
</li>
</ul>
<h2 id="2-2-自动提交（atutocommit）"><a href="#2-2-自动提交（atutocommit）" class="headerlink" title="2.2 自动提交（atutocommit）"></a>2.2 自动提交（atutocommit）</h2><ol>
<li>默认 <code>atutocommit = 1</code> 即开启自动提交，执行 <code>DML</code> 时会自动开启事务并提交</li>
<li>关闭自动提交<ol>
<li><code>set autocommit = 0</code><ul>
<li>会话级别</li>
</ul>
</li>
<li><code>set global autocommit = 0</code><ul>
<li>全局级别，影响所有会话，重启失效</li>
</ul>
</li>
<li><code>vim /etc/my.cnf</code> 中添加 <code>autocommit=0</code><ul>
<li>永久生效</li>
</ul>
</li>
</ol>
</li>
</ol>
<h1 id="三-隔离级别"><a href="#三-隔离级别" class="headerlink" title="三 隔离级别"></a>三 隔离级别</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol>
<li>对于同时运行的多个事务（多线程并发）, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题</li>
<li>问题的本质就是线程安全问题，共享数据的问题</li>
</ol>
<h2 id="3-2-问题"><a href="#3-2-问题" class="headerlink" title="3.2 问题"></a>3.2 问题</h2><table>
<thead>
<tr>
<th>问题</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>脏读</td>
<td>事务 T1 读取到了事务 T2 未提交的数据，如果 T2 回滚，那么 T1 读取到的数据是临时且无效的</td>
</tr>
<tr>
<td>不可重复读</td>
<td>事务 T1 读取到了事务 T2 已提交的数据（update），导致 T1 多次读取同一个字段但是结果不同</td>
</tr>
<tr>
<td>幻读</td>
<td>事务 T1 读取到了事务 T2 已提交的数据（insert / delete），导致 T1 多次读取同一张表，但记录数不同</td>
</tr>
</tbody></table>
<h2 id="3-3-隔离级别分类"><a href="#3-3-隔离级别分类" class="headerlink" title="3.3 隔离级别分类"></a>3.3 隔离级别分类</h2><table>
<thead>
<tr>
<th>隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td><code>read uncommitted</code></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td><code>read committed</code></td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td><code>repeatable read</code></td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td><code>serializable</code></td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<ul>
<li><code>repeatable read</code><ul>
<li>是 MySQl 默认 隔离级别，Mysql 5.0 之后此级别也可以避免幻读?</li>
</ul>
</li>
</ul>
<h2 id="3-4-隔离级别管理"><a href="#3-4-隔离级别管理" class="headerlink" title="3.4 隔离级别管理"></a>3.4 隔离级别管理</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>select @@tx_isolation</code></td>
<td>查看会话隔离级别</td>
</tr>
<tr>
<td><code>set tx_isolation=隔离级别</code></td>
<td>设置会话隔离级别，必须在开启事务之前</td>
</tr>
<tr>
<td><code>set [global/session] transaction isolation level 隔离级别</code></td>
<td>设置下次事务的隔离级别</td>
</tr>
<tr>
<td><code>tx_isolation=隔离级别</code></td>
<td>在 <code>/etc/my.cnf</code> 中添加，永久设置</td>
</tr>
</tbody></table>
<h1 id="四-锁"><a href="#四-锁" class="headerlink" title="四 锁"></a>四 锁</h1><h2 id="4-1-悲观锁"><a href="#4-1-悲观锁" class="headerlink" title="4.1 悲观锁"></a>4.1 悲观锁</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>数据库提供实现</li>
<li>悲观的认为别人一定会修改我使用的数据，我就未为我使用的数据加锁，防止别人修改</li>
</ol>
<h3 id="2-锁粒度划分"><a href="#2-锁粒度划分" class="headerlink" title="2 锁粒度划分"></a>2 锁粒度划分</h3><ol>
<li>表锁<ul>
<li>开销小，加锁快；不会出现死锁；但锁粒度大，锁冲突概率高，并发度低</li>
</ul>
</li>
<li>行锁<ul>
<li>开销大，加锁慢；会出现死锁；锁定粒度小，锁冲突概率低，并发度高。</li>
</ul>
</li>
</ol>
<h3 id="3-锁机制划分"><a href="#3-锁机制划分" class="headerlink" title="3 锁机制划分"></a>3 锁机制划分</h3><ol>
<li>读锁/共享锁<ul>
<li>其他事务可以读，但不能写</li>
</ul>
</li>
<li>写锁/排他锁<ul>
<li>其他事务不能读取，也不能写</li>
</ul>
</li>
</ol>
<h2 id="4-2-乐观锁"><a href="#4-2-乐观锁" class="headerlink" title="4.2 乐观锁"></a>4.2 乐观锁</h2><ol>
<li>需要自己实现</li>
<li>乐观的认为数据一般是不会造成冲突的。只有在提交数据的时候，才会对数据的冲突进行检测</li>
<li>类似与 版本控制（git / svn），会有一个版本号，在提交时会对比版本号，如果冲突则不能提交。</li>
<li>例：<ul>
<li><code>id=1 money=100 version=1</code>甲乙同时操作money-10</li>
<li>甲先提交<code>id=1 money=90 version=2</code>提交成功。</li>
<li>乙后提交<code>id=1 money=90 version=2</code>提交失败</li>
<li>乙需要从新查询，然后修改提交<code>id=1 money=80 version=3</code></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql语句</title>
    <url>/anyeansan.github.io/2020/11/08/SQL/Mysql%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-SQL（Structure-Query-Language）"><a href="#1-1-SQL（Structure-Query-Language）" class="headerlink" title="1.1 SQL（Structure Query Language）"></a>1.1 SQL（Structure Query Language）</h2><ol>
<li>结构化查询语言，关系型数据库通用命令</li>
<li>遵循SQL92标准</li>
<li>注释<ol>
<li><code>-- 单行注释</code></li>
<li><code>#单行注释</code>（mysql 特有）</li>
<li><code>/* 多行注释 */</code></li>
</ol>
</li>
</ol>
<h2 id="1-2-严格模式（SQL-MODE）"><a href="#1-2-严格模式（SQL-MODE）" class="headerlink" title="1.2 严格模式（SQL_MODE）"></a>1.2 严格模式（SQL_MODE）</h2><ol>
<li><code>set sql_mode = &#39;traditional&#39;</code><ul>
<li>设置严格模式（默认）</li>
</ul>
</li>
<li><code>set sql_mode = &#39;&#39;</code><ul>
<li>关闭严格模式</li>
</ul>
</li>
</ol>
<h2 id="1-3-规范"><a href="#1-3-规范" class="headerlink" title="1.3 规范"></a>1.3 规范</h2><h3 id="1-SQL-规范"><a href="#1-SQL-规范" class="headerlink" title="1 SQL 规范"></a>1 SQL 规范</h3><ol>
<li>SQL 语句不区分大小写，关键字和函数名建议大写</li>
<li>值：除了数值类型外都使用单引号 <code>&#39;&#39;</code></li>
<li>别名建议使用双引号 <code>&quot;&quot;</code>，且不省略 <code>as</code> 关键字</li>
<li>数据库必须设置字符集，表必须设置字符集和存储引擎</li>
<li>列选择合适的数据类型及长度，且要有注释</li>
<li>每列设置 <code>NOT NULL + DEFAULT</code><ol>
<li>数值默认为 <code>0</code> 或其它有效数字</li>
<li>字符串默认为空格字符串 <code>&#39; &#39;</code> 或其它有效字符串</li>
</ol>
</li>
<li>enum 类型不要用于数值，只能用于字符串</li>
<li>主键列最好是无关数值列，且自增长</li>
</ol>
<h3 id="2-命名规范"><a href="#2-命名规范" class="headerlink" title="2 命名规范"></a>2 命名规范</h3><ol>
<li>库名和表名小写，只能使用 <code>A-Z a-z 0-9</code>，不能以数字开头</li>
<li>不能使用关键字和保留字</li>
</ol>
<h2 id="1-4-SQL-常用分类"><a href="#1-4-SQL-常用分类" class="headerlink" title="1.4 SQL 常用分类"></a>1.4 SQL 常用分类</h2><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>DDL（Data Definition Language）</code></td>
<td>数据定义语言，如 <code>create alter drop truncate</code></td>
</tr>
<tr>
<td><code>DML（Data Manipulation Language）</code></td>
<td>数据操作语言，如 <code>insert delete update</code></td>
</tr>
<tr>
<td><code>DQL（Data Query Language）</code></td>
<td>数据查询语言，如 <code>select show</code></td>
</tr>
<tr>
<td><code>DCL（Data Control Language）</code></td>
<td>数据控制语言，如 <code>grant revoke</code></td>
</tr>
</tbody></table>
<h1 id="二-库"><a href="#二-库" class="headerlink" title="二 库"></a>二 库</h1><h2 id="2-1-查"><a href="#2-1-查" class="headerlink" title="2.1 查"></a>2.1 查</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>show databases</code></td>
<td>查看所有库</td>
</tr>
<tr>
<td><code>use 库名</code></td>
<td>使用指定数据库</td>
</tr>
<tr>
<td><code>select database()</code></td>
<td>查看正在使用的数据库</td>
</tr>
<tr>
<td><code>show create database db_name</code></td>
<td>查看建库语句</td>
</tr>
<tr>
<td><code>show variables like &#39;character_set_database&#39;</code></td>
<td>查看当前数据库字符集</td>
</tr>
<tr>
<td><code>show variables like &#39;collation_database&#39;</code></td>
<td>查看当前数据库校对集</td>
</tr>
</tbody></table>
<h2 id="2-2-增"><a href="#2-2-增" class="headerlink" title="2.2 增"></a>2.2 增</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database [if not exists] 库名 [default character set 字符集 collate 校对集]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>character set</code> 都可以简写为 <code>charset</code></li>
</ul>
<h2 id="2-3-删"><a href="#2-3-删" class="headerlink" title="2.3 删"></a>2.3 删</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop database [if exists] 库名</span><br></pre></td></tr></table></figure>

<h2 id="2-4-改"><a href="#2-4-改" class="headerlink" title="2.4 改"></a>2.4 改</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter database 库名 [charset 字符集 collate 校对集]</span><br></pre></td></tr></table></figure>

<ol>
<li>库名不可修改</li>
<li>只能修改库属性（字符集和校对集）</li>
</ol>
<h1 id="三-表"><a href="#三-表" class="headerlink" title="三 表"></a>三 表</h1><h2 id="3-1-查"><a href="#3-1-查" class="headerlink" title="3.1 查"></a>3.1 查</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>show tables [from 库名]</code></td>
<td>查看库（默认为当前库）中的所有表</td>
</tr>
<tr>
<td><code>show create table 表名</code></td>
<td>查看建表语句</td>
</tr>
<tr>
<td><code>desc 表名</code></td>
<td>查看表结构</td>
</tr>
</tbody></table>
<h2 id="3-2-增"><a href="#3-2-增" class="headerlink" title="3.2 增"></a>3.2 增</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1 </span><br><span class="line">create table [if not exists] 表名(</span><br><span class="line">	列名 列属性,</span><br><span class="line">	......</span><br><span class="line">	列名 列属性</span><br><span class="line">)[engine=INNODB character set 字符集 collate 校对集]</span><br><span class="line"></span><br><span class="line">// 2 根据已有表结构创建新表</span><br><span class="line">create table 新表名 like 旧表名</span><br><span class="line"></span><br><span class="line">// 3 根据已有表创建新表并添加数据</span><br><span class="line">create table 新表名 AS 子查询</span><br></pre></td></tr></table></figure>

<h2 id="3-3-删"><a href="#3-3-删" class="headerlink" title="3.3 删"></a>3.3 删</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop table [if exists] 表名</span><br></pre></td></tr></table></figure>

<h2 id="3-4-改"><a href="#3-4-改" class="headerlink" title="3.4 改"></a>3.4 改</h2><h3 id="1-表信息（表名-表属性）"><a href="#1-表信息（表名-表属性）" class="headerlink" title="1 表信息（表名 表属性）"></a>1 表信息（表名 表属性）</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>rename table 表名 to 新表名</code></td>
<td>修改表名</td>
</tr>
<tr>
<td><code>alter table 表名 rename 新表名</code></td>
<td>修改表名</td>
</tr>
<tr>
<td><code>alter table 表名 表属性</code></td>
<td>修改表属性</td>
</tr>
</tbody></table>
<h3 id="2-表结构（列信息）"><a href="#2-表结构（列信息）" class="headerlink" title="2 表结构（列信息）"></a>2 表结构（列信息）</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>alter table 表名 add [column] 列名 列属性 [位置]</code></td>
<td>默认在最后添加一列，可指定位置：<code>first</code> 或 <code>after 某列</code></td>
</tr>
<tr>
<td><code>alter table 表名 add [column] (列名 列属性, ...)</code></td>
<td>在最后添加多列</td>
</tr>
<tr>
<td><code>alter table 表名 drop [column] 列名</code></td>
<td>删除列</td>
</tr>
<tr>
<td><code>alter table 表名 modify 列名 列属性</code></td>
<td>修改列属性</td>
</tr>
<tr>
<td><code>alter table 表名 change 列名 新列名 列属性</code></td>
<td>修改列名和列属性</td>
</tr>
</tbody></table>
<h1 id="四-数据"><a href="#四-数据" class="headerlink" title="四 数据"></a>四 数据</h1><h2 id="4-1-增删改"><a href="#4-1-增删改" class="headerlink" title="4.1 增删改"></a>4.1 增删改</h2><h3 id="1-insert"><a href="#1-insert" class="headerlink" title="1 insert"></a>1 insert</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>insert [into] 表名 values(值列表)[, (值列表)]</code></td>
<td>向表所有列插入 1 或多条记录，列与值一一对应</td>
</tr>
<tr>
<td><code>insert [into] 表名(字段列表) values(值列表)[, (值列表)]</code></td>
<td>向表指定列插入 1 或多条记录，列与值一一对应</td>
</tr>
<tr>
<td><code>insert [into] 表名 set 列=值, ...</code></td>
<td>向表指定列插入 1 条记录，值可以使用子查询</td>
</tr>
</tbody></table>
<h3 id="2-update"><a href="#2-update" class="headerlink" title="2 update"></a>2 update</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>update 表名 set 列=值 [where 子句]</code></td>
<td>不加条件会更新所有行</td>
</tr>
</tbody></table>
<h3 id="3-delete"><a href="#3-delete" class="headerlink" title="3 delete"></a>3 delete</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>delete from 表名 [where 子句]</code></td>
<td>不加条件会删除所有行</td>
</tr>
<tr>
<td><code>truncate [table] 表名</code></td>
<td>清空表</td>
</tr>
</tbody></table>
<ul>
<li>truncate 和 delete 区别<ul>
<li>DELETE <ol>
<li>DML 操作，是逻辑性质删除，逐行删除速度慢</li>
<li>删除表中的数据，表结构还在，删除后的数据可以找回</li>
<li>自增长不会重置</li>
</ol>
</li>
<li>TRUNCATE <ol>
<li>DDL 操作，对表段中的数据页进行清空，速度快</li>
<li>相当于把表扔了又创建一个同样表结构的新表</li>
<li>自增长会重置</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="4-2-查"><a href="#4-2-查" class="headerlink" title="4.2 查"></a>4.2 查</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select [选项] 表达式 [as 列别名] [, [选项] 表达式 [as 列别名], ...]</span><br><span class="line">[</span><br><span class="line">	from 数据源 [as 表别名]</span><br><span class="line">	[where 子句]</span><br><span class="line">	[group by 子句]</span><br><span class="line">	[having 子句]</span><br><span class="line">	[order by 子句]</span><br><span class="line">	[limit 子句]</span><br><span class="line">]</span><br><span class="line">[union | union all]</span><br><span class="line">select ...</span><br><span class="line"></span><br><span class="line">// 查询过程</span><br><span class="line">1. from</span><br><span class="line">   - 确定数据源</span><br><span class="line">2. where</span><br><span class="line">   - 从原表中筛选出符合条件的数据形成一个概念中的临时结果集，存入内存</span><br><span class="line">3. group by</span><br><span class="line">   - 按照指定列进行分组</span><br><span class="line">4. select</span><br><span class="line">   - 处理表达式（函数, 别名, 运算 ...），形成结果集</span><br><span class="line">5. having</span><br><span class="line">   - 对结果集进行过滤</span><br><span class="line">6. order by</span><br><span class="line">   - 对过滤后的结果集进行排序</span><br><span class="line">7. limit</span><br><span class="line">   - 对排序后的结果集进行条目限制，形成最终结果集</span><br></pre></td></tr></table></figure>

<h3 id="1-select-子句"><a href="#1-select-子句" class="headerlink" title="1 select 子句"></a>1 select 子句</h3><ol>
<li>选项<ul>
<li><code>all</code>：保留所有结果（默认）</li>
<li><code>distinct</code>：去除重复</li>
<li><code>distinct row</code></li>
<li><code>top</code></li>
</ul>
</li>
<li>表达式<ul>
<li>每一个表达式代表一列，可以是列名，*，变量，函数，…</li>
</ul>
</li>
<li>别名<ul>
<li>表别名可用于全局</li>
<li>列别名可用于 <code>having</code> 和 <code>order by</code> </li>
</ul>
</li>
</ol>
<h3 id="2-from-子句"><a href="#2-from-子句" class="headerlink" title="2 from 子句"></a>2 from 子句</h3><ul>
<li>本质上只要数据类似二维表，都可以作为数据源<ol>
<li>单表数据源</li>
<li>多表数据源</li>
<li>查询语句</li>
</ol>
</li>
</ul>
<h3 id="3-where-子句"><a href="#3-where-子句" class="headerlink" title="3 where 子句"></a>3 where 子句</h3><ol>
<li>从原表中的记录中进行筛选</li>
<li>where 是直接对表中数据进行判断，所以只能使用表中的列，且不能使用别名</li>
</ol>
<h3 id="4-group-by-子句"><a href="#4-group-by-子句" class="headerlink" title="4 group by 子句"></a>4 group by 子句</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>通常配合聚合函数使用</li>
<li>可以有多个分组列，以逗号分隔</li>
<li>select 中可以查询的列：<ol>
<li>分组的列</li>
<li>聚合函数的列</li>
<li>与分组列一对一的列（不报错，但不推荐）</li>
</ol>
</li>
</ol>
<h4 id="2-group-by-原理"><a href="#2-group-by-原理" class="headerlink" title="2 group by 原理"></a>2 group by 原理</h4><ol>
<li>先按照分组列排序、去重，形成一张虚拟表</li>
<li>虚拟表的结构：分组列与其它列的对应关系<ol>
<li>分组列一对一的列可以直接查询（即与分组列对应的列只有一行记录）</li>
<li>分组列一对多的列不能直接查询（即与分组列对应的列有多行记录）<ol>
<li>使用聚合函数将多行记录统计为一行记录</li>
<li>使用 <code>group_concat()</code> 将多行记录合并连接为一行记录</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="3-聚合函数"><a href="#3-聚合函数" class="headerlink" title="3 聚合函数"></a>3 聚合函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>max([distinct] expr)</code></td>
<td>返回 expr 最大值</td>
</tr>
<tr>
<td><code>min([distinct] expr)</code></td>
<td>返回 expr 最小值</td>
</tr>
<tr>
<td><code>count([distinct] expr)</code></td>
<td>返回 expr 记录总数</td>
</tr>
<tr>
<td><code>sum([distinct] expr)</code></td>
<td>返回 expr 总和</td>
</tr>
<tr>
<td><code>avg([distinct] expr)</code></td>
<td>返回 expr 平均值</td>
</tr>
<tr>
<td><code>group_concat()</code></td>
<td>将group by产生的同一个分组中的其它列的所有值连接成一个字符串（多行记录变一行）</td>
</tr>
</tbody></table>
<ul>
<li><code>count()</code><ol>
<li><code>count(*)</code> 和 <code>count(常量)</code><ul>
<li>记录总数（包含空行）</li>
<li>此类参数表示数数，有一行记录总数就+1，也就是说总数与记录内容无关</li>
<li><code>count(*)</code> 效率底不建议</li>
</ul>
</li>
<li><code>count(列名)</code><ul>
<li>记录总数（不包含空行）</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="4-with-rollup"><a href="#4-with-rollup" class="headerlink" title="4 with rollup"></a>4 with rollup</h4><ul>
<li>分组后跟 <code>with rollup</code> 会对分组进行统计</li>
<li>只有 mysql 支持</li>
</ul>
<h3 id="5-having-子句"><a href="#5-having-子句" class="headerlink" title="5 having 子句"></a>5 having 子句</h3><ul>
<li>having 是对其之前子句筛选出的数据进行条件过滤</li>
</ul>
<h3 id="6-order-by子句"><a href="#6-order-by子句" class="headerlink" title="6 order by子句"></a>6 order by子句</h3><table>
<thead>
<tr>
<th>语句</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>asc</code></td>
<td>升序（默认）</td>
</tr>
<tr>
<td><code>desc</code></td>
<td>降序</td>
</tr>
</tbody></table>
<ol>
<li>排序依赖校对集</li>
<li>可以有多个排序条件，前一个条件结果相同则比较下一个条件</li>
</ol>
<h3 id="7-limit-子句"><a href="#7-limit-子句" class="headerlink" title="7 limit 子句"></a>7 limit 子句</h3><table>
<thead>
<tr>
<th>语句</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>limit [startIndex, ]length</code></td>
<td>从指定索引（若省略，默认为 0）开始，取 <code>length</code> 条数据</td>
</tr>
<tr>
<td><code>limit length offset startIndex</code></td>
<td>同上，也可以把索引理解为偏移量（即跳过 <code>startIndex</code> 个）</td>
</tr>
</tbody></table>
<h3 id="8-union-amp-union-all"><a href="#8-union-amp-union-all" class="headerlink" title="8 union &amp; union all"></a>8 union &amp; union all</h3><table>
<thead>
<tr>
<th>语句</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>union all</code></td>
<td>合并多个查询结果集，保留所有</td>
</tr>
<tr>
<td><code>union</code></td>
<td>合并多个查询结果集，去除重复</td>
</tr>
</tbody></table>
<ul>
<li>要合并的查询结果列数必须相同，合并后结果集的列名取决于第一个要合并的查询</li>
<li>一般情况下,会将 <code>in()</code> 或者 <code>OR</code> 语句 改写成 <code>UNION ALL</code> ，来提高性能</li>
</ul>
<h1 id="五-关联查询（SQL-JOIN）"><a href="#五-关联查询（SQL-JOIN）" class="headerlink" title="五 关联查询（SQL JOIN）"></a>五 关联查询（SQL JOIN）</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><h3 id="1-关联查询结果"><a href="#1-关联查询结果" class="headerlink" title="1 关联查询结果"></a>1 关联查询结果</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/SQL/sql-join.png" alt=""></p>
<ol>
<li>关联查询有七种结果（行/记录）</li>
<li>关联查询的列都是两表组合在一起，即 A 表的列 + B 表的列</li>
</ol>
<h3 id="2-关联查询分类"><a href="#2-关联查询分类" class="headerlink" title="2 关联查询分类"></a>2 关联查询分类</h3><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>查询结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>inner/cross join</code></td>
<td>内连接</td>
<td><code>A ∩ B</code></td>
</tr>
<tr>
<td><code>left [outer] join</code></td>
<td>左外连接</td>
<td><code>A</code>，<code>A - A ∩ B</code></td>
</tr>
<tr>
<td><code>right [outer] join</code></td>
<td>右外连接</td>
<td><code>B</code>，<code>B - A ∩ B</code></td>
</tr>
<tr>
<td><code>full [outer] join</code></td>
<td>全外连接</td>
<td><code>A ∪ B</code>，<code>A ∪ B - A ∩ B</code></td>
</tr>
</tbody></table>
<ol>
<li>如果连接的表是同一张表，又称为<strong>自连接</strong></li>
<li>mysql 不支持全外连接，可通过 <code>union</code> 实现</li>
</ol>
<h2 id="5-2-语法"><a href="#5-2-语法" class="headerlink" title="5.2 语法"></a>5.2 语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表1 </span><br><span class="line">&#123;[inner | cross] | &#123;left | right&#125; [outer]&#125;  join</span><br><span class="line">表2</span><br><span class="line">on 条件表达式</span><br><span class="line">[</span><br><span class="line">	&#123;[inner | cross] | &#123;left | right&#125; [outer]&#125;  join</span><br><span class="line">	表3</span><br><span class="line">	on 条件表达式</span><br><span class="line">	......</span><br><span class="line">]</span><br><span class="line">[</span><br><span class="line">	[where 子句]</span><br><span class="line">	[group by 子句]</span><br><span class="line">	[having 子句]</span><br><span class="line">	[order by 子句]</span><br><span class="line">	[limit 子句]</span><br><span class="line">]</span><br><span class="line">[union | union all]</span><br><span class="line">select ...</span><br></pre></td></tr></table></figure>

<h2 id="5-3-关联条件"><a href="#5-3-关联条件" class="headerlink" title="5.3 关联条件"></a>5.3 关联条件</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>内连接如果没有关联条件，会形成笛卡尔积</li>
<li>外连接如果没有关联条件，会报错</li>
</ol>
<h3 id="2-笛卡尔积"><a href="#2-笛卡尔积" class="headerlink" title="2 笛卡尔积"></a>2 笛卡尔积</h3><ol>
<li>笛卡儿积是元素相组合，不是数学相乘</li>
<li>数学中的笛卡儿积<ul>
<li>集合 A 有 <code>m</code> 个元素，集合 B 有 <code>n</code> 个元素，则笛卡尔积共 <code>m * n</code>个元素</li>
<li>集合 <code>A = {a, b}</code>，集合 <code>B = {0, 1, 2}</code>，笛卡尔积 = <code>{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}</code></li>
</ul>
</li>
<li>数据库中的笛卡儿积<ul>
<li>表 A 有 <code>m</code> 条记录，表 B 中有 n 条记录，则笛卡尔积共有 <code>m*n</code> 条记录</li>
</ul>
</li>
</ol>
<h3 id="3-关联条件的方式"><a href="#3-关联条件的方式" class="headerlink" title="3 关联条件的方式"></a>3 关联条件的方式</h3><ol>
<li><code>where</code><ul>
<li>用于所有关联查询</li>
</ul>
</li>
<li><code>join on</code><ul>
<li>只能写关联条件，虽然关联条件可以并到 <code>where</code> 中，但单独写可读性更好</li>
</ul>
</li>
<li><code>join using(列名列表)</code><ul>
<li>表示两个关联字段值相同，要求两个关联字段列名必须一致</li>
</ul>
</li>
</ol>
<h2 id="5-4-内连接"><a href="#5-4-内连接" class="headerlink" title="5.4 内连接"></a>5.4 内连接</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1 隐式</span><br><span class="line">from 表1, 表2 where 条件</span><br><span class="line"></span><br><span class="line">// 2 显式</span><br><span class="line">from 表1 [inner | cross] join 表2 on 关联条件</span><br></pre></td></tr></table></figure>

<h3 id="2-结果"><a href="#2-结果" class="headerlink" title="2 结果"></a>2 结果</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/SQL/INNER_JOIN.png" alt=""></p>
<h2 id="5-5-外连接"><a href="#5-5-外连接" class="headerlink" title="5.5 外连接"></a>5.5 外连接</h2><h3 id="1-左外连接"><a href="#1-左外连接" class="headerlink" title="1 左外连接"></a>1 左外连接</h3><h4 id="1-语法-1"><a href="#1-语法-1" class="headerlink" title="1 语法"></a>1 语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表1 left [outer] join 表2 on 条件</span><br></pre></td></tr></table></figure>

<h4 id="2-结果-1"><a href="#2-结果-1" class="headerlink" title="2 结果"></a>2 结果</h4><p><img src="https://github.com/anyeansan/pics/raw/master/CS/SQL/LEFT_JOIN.png" alt=""></p>
<ul>
<li>查出左表所有行，左表中的行在右表没有匹配则右表对应行返回空</li>
</ul>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/SQL/LEFT_EXCLUDING_JOIN.png" alt=""></p>
<ul>
<li>查出左表在右表中没有匹配的行，右表肯定都返回空</li>
</ul>
<h3 id="2-右外连接"><a href="#2-右外连接" class="headerlink" title="2 右外连接"></a>2 右外连接</h3><h4 id="1-语法-2"><a href="#1-语法-2" class="headerlink" title="1 语法"></a>1 语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表1 right [outer] join 表2 on 条件</span><br></pre></td></tr></table></figure>

<h4 id="2-结果-2"><a href="#2-结果-2" class="headerlink" title="2 结果"></a>2 结果</h4><p><img src="https://github.com/anyeansan/pics/raw/master/CS/SQL/RIGHT_JOIN.png" alt=""></p>
<ul>
<li>查出右表所有行，右表中的行在左表没有匹配则左表对应行返回空</li>
</ul>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/SQL/RIGHT_EXCLUDING_JOIN.png" alt=""></p>
<ul>
<li>查出右表在左表中没有匹配的行，左表肯定都返回空</li>
</ul>
<h3 id="3-全外连接"><a href="#3-全外连接" class="headerlink" title="3 全外连接"></a>3 全外连接</h3><h4 id="1-语法-3"><a href="#1-语法-3" class="headerlink" title="1 语法"></a>1 语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表1 full [outer] join 表2 on 条件</span><br></pre></td></tr></table></figure>

<h4 id="2-结果-3"><a href="#2-结果-3" class="headerlink" title="2 结果"></a>2 结果</h4><p><img src="https://github.com/anyeansan/pics/raw/master/CS/SQL/FULL_OUTER_JOIN.png" alt=""></p>
<ul>
<li>查出左表和右表的所有行，在彼此表中没有匹配的行则返回空</li>
</ul>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/SQL/OUTER_EXCLUDING_JOIN.png" alt=""></p>
<ul>
<li>查出在左表和右表中彼此没有匹配的行</li>
</ul>
<h2 id="5-6-例"><a href="#5-6-例" class="headerlink" title="5.6 例"></a>5.6 例</h2><h3 id="1-原始表-t1-和-t2"><a href="#1-原始表-t1-和-t2" class="headerlink" title="1 原始表 t1 和 t2"></a>1 原始表 t1 和 t2</h3><table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>D</td>
</tr>
<tr>
<td>3</td>
<td>E</td>
</tr>
<tr>
<td>4</td>
<td>F</td>
</tr>
</tbody></table>
<h3 id="2-内连接"><a href="#2-内连接" class="headerlink" title="2 内连接"></a>2 内连接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t1 inner join t2 on t1.id=t2.id;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>a</td>
<td>2</td>
<td>D</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
<td>3</td>
<td>E</td>
</tr>
</tbody></table>
<h3 id="3-左外连接"><a href="#3-左外连接" class="headerlink" title="3 左外连接"></a>3 左外连接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t1 left join t2 on t1.id=t2.id;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>a</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
<td>2</td>
<td>D</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
<td>3</td>
<td>E</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t1 left join t2 on t1.id!=t2.id;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>a</td>
<td>null</td>
<td>null</td>
</tr>
</tbody></table>
<h3 id="4-右外连接"><a href="#4-右外连接" class="headerlink" title="4 右外连接"></a>4 右外连接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t1 right join t2 on t1.id=t2.id;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>b</td>
<td>2</td>
<td>D</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
<td>3</td>
<td>E</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>4</td>
<td>F</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t1 right join t2 on t1.id!=t2.id;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>null</td>
<td>null</td>
<td>4</td>
<td>F</td>
</tr>
</tbody></table>
<h3 id="5-全外连接"><a href="#5-全外连接" class="headerlink" title="5 全外连接"></a>5 全外连接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t1 full join t2 on t1.id=t2.id;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>a</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
<td>2</td>
<td>D</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
<td>3</td>
<td>E</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>4</td>
<td>F</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t1 full join t2 on t1.id!=t2.id;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>a</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>4</td>
<td>F</td>
</tr>
</tbody></table>
<h1 id="六-子查询"><a href="#六-子查询" class="headerlink" title="六 子查询"></a>六 子查询</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><ul>
<li>一个查询需要的条件或数据是另一个查询的结果，即一个查询中嵌套了另一个查询，嵌套在里面的查询就是子查询</li>
</ul>
<h2 id="6-2-子查询根据位置分类"><a href="#6-2-子查询根据位置分类" class="headerlink" title="6.2 子查询根据位置分类"></a>6.2 子查询根据位置分类</h2><ol>
<li><p>from 型子查询：子查询必须有别名</p>
<ul>
<li><code>from (子查询) 别名</code></li>
</ul>
</li>
<li><p>where 型子查询</p>
<ul>
<li><code>where 字段 = (子查询)</code></li>
<li><code>where 字段 in (子查询)</code></li>
<li><code>...</code></li>
</ul>
</li>
<li><p>exists 型子查询</p>
<ul>
<li><code>where exists(子查询)</code><ol>
<li>子查询返回记录，则 <code>exists</code> 为 <code>true</code>，添加记录</li>
<li>子查询没有记录，则 <code>exists</code> 为 <code>false</code>，不添加记录</li>
</ol>
</li>
</ul>
</li>
<li><p>相关子查询：子查询和外部查询有关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM invoices i</span><br><span class="line">WHERE invoice_total &gt; (</span><br><span class="line">	SELECT AVG(invoice_total)</span><br><span class="line">	FROM invoices</span><br><span class="line">	WHERE client_id = i.client_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>select 子查询</p>
</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql语法</title>
    <url>/anyeansan.github.io/2020/11/08/SQL/Mysql%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一-元数据"><a href="#一-元数据" class="headerlink" title="一 元数据"></a>一 元数据</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ol>
<li>元数据可以简单理解为描述数据的数据，除了存储在数据库中的数据外，其它大多可以理解为元数据</li>
<li>元数据存储在“基表”中，不能直接访问<ol>
<li><code>infomation_schema</code> 数据库中保存了大量元数据查询的视图</li>
<li><code>show</code> 命令是封装好的，提供元数据查询的基础功能</li>
</ol>
</li>
</ol>
<h2 id="1-2-information-schema"><a href="#1-2-information-schema" class="headerlink" title="1.2 information_schema"></a>1.2 information_schema</h2><table>
<thead>
<tr>
<th>表</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>schemata</code></td>
<td>存储当前 mysql 实例中所有数据库的信息，<code>show databases</code> 命令从这个表获取数据</td>
</tr>
<tr>
<td><code>tables</code></td>
<td>存储数据库中的表信息（包括视图），<code>show tables [from db_name]</code> 命令从这个表获取结果</td>
</tr>
<tr>
<td><code>columns</code></td>
<td>存储数据库中每张表的列信息（如属于哪张表哪个库，属性信息…)</td>
</tr>
<tr>
<td><code>table_constraints</code></td>
<td>存储表约束信息</td>
</tr>
<tr>
<td><code>statistics</code></td>
<td>存储表索引信息</td>
</tr>
<tr>
<td><code>collations</code></td>
<td>存储了字符集和校对集对照信息</td>
</tr>
</tbody></table>
<h3 id="tables-表"><a href="#tables-表" class="headerlink" title="tables 表"></a>tables 表</h3><table>
<thead>
<tr>
<th>列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>table_schema</code></td>
<td>表所在库名</td>
</tr>
<tr>
<td><code>table_name</code></td>
<td>表名</td>
</tr>
<tr>
<td><code>engine</code></td>
<td>存储引擎</td>
</tr>
<tr>
<td><code>table_rows</code></td>
<td>总行数</td>
</tr>
<tr>
<td><code>avg_row_length</code></td>
<td>行平均长度</td>
</tr>
<tr>
<td><code>index_length</code></td>
<td>索引长度</td>
</tr>
</tbody></table>
<ul>
<li><code>表大小 = avg_row_length * table_rows + index_length</code></li>
</ul>
<h2 id="1-3-show"><a href="#1-3-show" class="headerlink" title="1.3 show"></a>1.3 show</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>show databases</code></td>
<td>查看所有库名</td>
</tr>
<tr>
<td><code>show tables [from db_name]</code></td>
<td>查看库中所有表名</td>
</tr>
<tr>
<td><code>show create database db_name</code></td>
<td>查看建库语句</td>
</tr>
<tr>
<td><code>show create table t_name</code></td>
<td>查看建表语句</td>
</tr>
<tr>
<td><code>show processlist</code></td>
<td>查看数据库连接情况</td>
</tr>
<tr>
<td><code>show charset</code></td>
<td>查看支持的字符集</td>
</tr>
<tr>
<td><code>show collation</code></td>
<td>查看支持的校对集</td>
</tr>
<tr>
<td><code>show engines</code></td>
<td>查看支持的存储引擎</td>
</tr>
<tr>
<td><code>show grants for user_name</code></td>
<td>查看用户权限</td>
</tr>
<tr>
<td><code>shwo variables [like pattern]</code></td>
<td>查看变量信息</td>
</tr>
<tr>
<td><code>show index from t_name</code></td>
<td>查看表的索引信息</td>
</tr>
<tr>
<td><code>show engine innodb statsu\G</code></td>
<td>查看 innodb 引擎详细状态信息（横向）</td>
</tr>
<tr>
<td><code>show status [like pattern]</code></td>
<td>查看数据库状态信息</td>
</tr>
<tr>
<td><code>show binary logs</code></td>
<td>查看二进制日志的列表信息</td>
</tr>
<tr>
<td><code>show binlog events in log_name</code></td>
<td>查看二进制日志的事件信息</td>
</tr>
<tr>
<td><code>show master status</code></td>
<td>查看 mysql 当前使用的二进制日志信息</td>
</tr>
<tr>
<td><code>show relaylog events in log_name</code></td>
<td>查看中继日志的事件信息</td>
</tr>
</tbody></table>
<h1 id="二-运算符-和-语句"><a href="#二-运算符-和-语句" class="headerlink" title="二 运算符 和 语句"></a>二 运算符 和 语句</h1><h2 id="2-1-算术运算符"><a href="#2-1-算术运算符" class="headerlink" title="2.1 算术运算符"></a>2.1 算术运算符</h2><table>
<thead>
<tr>
<th align="left">运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>+</code></td>
<td>加</td>
</tr>
<tr>
<td align="left"><code>-</code></td>
<td>减</td>
</tr>
<tr>
<td align="left"><code>*</code></td>
<td>乘</td>
</tr>
<tr>
<td align="left"><code>/</code></td>
<td>除</td>
</tr>
<tr>
<td align="left"><code>DIV</code></td>
<td>整除</td>
</tr>
<tr>
<td align="left"><code>%, MOD</code></td>
<td>模</td>
</tr>
</tbody></table>
<h2 id="2-2-比较运算符"><a href="#2-2-比较运算符" class="headerlink" title="2.2 比较运算符"></a>2.2 比较运算符</h2><table>
<thead>
<tr>
<th align="left">运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td align="left"><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td align="left"><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td align="left"><code>&lt;=</code></td>
<td>小于等于</td>
</tr>
<tr>
<td align="left"><code>=</code></td>
<td>等于，<code>null = null</code> 返回 null</td>
</tr>
<tr>
<td align="left"><code>&lt;=&gt;</code></td>
<td>等于，<code>null = null</code> 返回 1</td>
</tr>
<tr>
<td align="left"><code>&lt;&gt;, !=</code></td>
<td>不等于</td>
</tr>
</tbody></table>
<h2 id="2-3-逻辑运算符"><a href="#2-3-逻辑运算符" class="headerlink" title="2.3 逻辑运算符"></a>2.3 逻辑运算符</h2><table>
<thead>
<tr>
<th align="left">运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>and, &amp;&amp;</code></td>
<td>逻辑与</td>
</tr>
<tr>
<td align="left"><code>or, &#124;&#124;</code></td>
<td>逻辑或</td>
</tr>
<tr>
<td align="left"><code>not, !</code></td>
<td>逻辑非</td>
</tr>
<tr>
<td align="left"><code>xor</code></td>
<td>逻辑异或</td>
</tr>
</tbody></table>
<ul>
<li><code>and</code> 优先级高于 <code>or</code></li>
</ul>
<h2 id="2-4-正则"><a href="#2-4-正则" class="headerlink" title="2.4 正则"></a>2.4 正则</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">regexp pattern</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>^</code></td>
<td>开头</td>
</tr>
<tr>
<td><code>$</code></td>
<td>结尾</td>
</tr>
<tr>
<td>`</td>
<td>`</td>
</tr>
<tr>
<td><code>[abc] [a-z]</code></td>
<td>范围</td>
</tr>
<tr>
<td><code>{n} {m,} {m,n} * + ?</code></td>
<td>数量</td>
</tr>
</tbody></table>
<h2 id="2-5-语句"><a href="#2-5-语句" class="headerlink" title="2.5 语句"></a>2.5 语句</h2><table>
<thead>
<tr>
<th>语句</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>like pattern</code></td>
<td>模糊查询，<code>pattern</code> 中：<code>%</code> 匹配任意个任意字符，<code>_</code> 匹配一个任意字符</td>
</tr>
<tr>
<td><code>between ... and ...</code></td>
<td>在某个范围之间</td>
</tr>
<tr>
<td><code>is null</code></td>
<td>是否为空</td>
</tr>
<tr>
<td><code>is not null</code></td>
<td>是否不为空</td>
</tr>
<tr>
<td><code>in()</code></td>
<td>匹配其中任意一个值，则为 true，类似逻辑或</td>
</tr>
<tr>
<td><code>any()</code></td>
<td>必须配合比较运算符使用，代表（大于, 小于, …）其中任意一个值则为 true</td>
</tr>
<tr>
<td><code>some()</code></td>
<td>是 <code>any()</code> 的别名</td>
</tr>
<tr>
<td><code>all()</code></td>
<td>必须配合比较运算符使用，代表（大于, 小于, …）其中所有值则为 true</td>
</tr>
</tbody></table>
<h1 id="三-变量"><a href="#三-变量" class="headerlink" title="三 变量"></a>三 变量</h1><h2 id="3-1-分类"><a href="#3-1-分类" class="headerlink" title="3.1 分类"></a>3.1 分类</h2><table>
<thead>
<tr>
<th>类型</th>
<th>级别</th>
</tr>
</thead>
<tbody><tr>
<td>系统变量</td>
<td>全局级别，会话级别</td>
</tr>
<tr>
<td>自定义变量</td>
<td>会话级别</td>
</tr>
</tbody></table>
<h2 id="3-2-系统变量"><a href="#3-2-系统变量" class="headerlink" title="3.2 系统变量"></a>3.2 系统变量</h2><h3 id="1-查看系统变量"><a href="#1-查看系统变量" class="headerlink" title="1 查看系统变量"></a>1 查看系统变量</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>show global variables</code></td>
<td>查看全局级别所有系统变量的信息</td>
</tr>
<tr>
<td><code>show session variables</code></td>
<td>查看会话级别所有系统变量的信息</td>
</tr>
<tr>
<td><code>select @@global.变量名</code></td>
<td>查看全局级别的指定系统变量的信息</td>
</tr>
<tr>
<td><code>select @@session.变量名</code></td>
<td>查看会话级别的指定系统变量的信息</td>
</tr>
<tr>
<td><code>select @@变量名</code></td>
<td>查看会话级别的指定系统变量的信息</td>
</tr>
</tbody></table>
<h3 id="2-修改系统变量"><a href="#2-修改系统变量" class="headerlink" title="2 修改系统变量"></a>2 修改系统变量</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>set global 变量名=值</code></td>
<td>修改全局级别的系统变量，影响新会话，重启失效</td>
</tr>
<tr>
<td><code>set @@global.变量名=值</code></td>
<td>修改全局级别的系统变量，影响新会话，重启失效</td>
</tr>
<tr>
<td><code>set session 变量名=值</code></td>
<td>修改会话级别的系统变量</td>
</tr>
<tr>
<td><code>set @@session.变量名=值</code></td>
<td>修改会话级别的系统变量</td>
</tr>
</tbody></table>
<h2 id="3-3-自定义变量"><a href="#3-3-自定义变量" class="headerlink" title="3.3 自定义变量"></a>3.3 自定义变量</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>为了区分系统变量, 规定用户自定义变量必须使用一个 <code>@</code> 符号</li>
<li>所有自定义变量不区分数据库</li>
<li>所有自定义的变量都是会话级别，但根据作用域可以分为<ol>
<li>全局变量（user/session variable）: 作用域为当前会话</li>
<li>局部变量（local variable） ：作用域为所在的 <code>begin end</code></li>
</ol>
</li>
</ol>
<h3 id="2-全局变量"><a href="#2-全局变量" class="headerlink" title="2 全局变量"></a>2 全局变量</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>set @变量名=值</code></td>
<td>声明并赋值</td>
</tr>
<tr>
<td><code>set @变量名 := 值</code></td>
<td>声明并赋值</td>
</tr>
<tr>
<td><code>select @变量名 := 值</code></td>
<td>声明并赋值</td>
</tr>
<tr>
<td><code>select 字段 into @变量名 from t_name</code></td>
<td>声明并从表中查询数据赋值</td>
</tr>
<tr>
<td><code>select @变量名</code></td>
<td>查看变量值</td>
</tr>
</tbody></table>
<ul>
<li>全局变量可以不声明直接使用，默认值为 <code>null</code></li>
</ul>
<h3 id="3-局部变量"><a href="#3-局部变量" class="headerlink" title="3 局部变量"></a>3 局部变量</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>declare 变量名 类型</code></td>
<td>声明局部变量</td>
</tr>
<tr>
<td><code>declare 变量名 类型 default 默认值</code></td>
<td>声明局部变量并设置默认值</td>
</tr>
</tbody></table>
<ol>
<li>局部变量需要先声明后使用</li>
<li>局部变量的赋值与查看命令与全局变量完全一致</li>
</ol>
<h1 id="四-函数"><a href="#四-函数" class="headerlink" title="四 函数"></a>四 函数</h1><h2 id="4-1-信息函数"><a href="#4-1-信息函数" class="headerlink" title="4.1 信息函数"></a>4.1 信息函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>user()</code></td>
<td>返回当前用户及所在主机</td>
</tr>
<tr>
<td><code>database()</code></td>
<td>返回当前数据库名</td>
</tr>
<tr>
<td><code>version()</code></td>
<td>返回数据库的版本号</td>
</tr>
<tr>
<td><code>connection_id()</code></td>
<td>返回连接id</td>
</tr>
<tr>
<td><code>last_insert_id()</code></td>
<td>最后插入记录的id</td>
</tr>
</tbody></table>
<h2 id="4-2-数学函数"><a href="#4-2-数学函数" class="headerlink" title="4.2 数学函数"></a>4.2 数学函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>abs(X)</code></td>
<td>绝对值</td>
</tr>
<tr>
<td><code>ceil(X)</code></td>
<td>向上取整</td>
</tr>
<tr>
<td><code>floor(X)</code></td>
<td>向下取整</td>
</tr>
<tr>
<td><code>round(X, D)</code></td>
<td>四舍五入，保留D位小数</td>
</tr>
<tr>
<td><code>truncate(X, D)</code></td>
<td>数字截断，保留D位小数</td>
</tr>
<tr>
<td><code>rand(X)</code></td>
<td><code>0~1</code> 的随机数</td>
</tr>
<tr>
<td><code>mod(N, M)</code></td>
<td>等价于 <code>N % M</code> 或者 <code>N MOD M</code></td>
</tr>
<tr>
<td><code>sort(X)</code></td>
<td>平方</td>
</tr>
<tr>
<td><code>pow(X,Y)</code></td>
<td>Y次方</td>
</tr>
<tr>
<td><code>conv(X, from_base, to_base)</code></td>
<td>将X从进制 <code>from_base</code> 转为进制 <code>to_base</code> 的字符串</td>
</tr>
</tbody></table>
<h2 id="4-3-字符串函数"><a href="#4-3-字符串函数" class="headerlink" title="4.3 字符串函数"></a>4.3 字符串函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>md5(str)</code></td>
<td>返回字符串的 md5 加密版本</td>
</tr>
<tr>
<td><code>password(str)</code></td>
<td>返回字符串的加密版本，41位的字符串</td>
</tr>
<tr>
<td><code>concat(str1, str2, ...)</code></td>
<td>连接字符串，有一个参数为 <code>null</code>，则返回 <code>null</code></td>
</tr>
<tr>
<td><code>concat_ws(separator, str1, str2, ...)</code></td>
<td>使用指定分隔符连接字符串</td>
</tr>
<tr>
<td><code>length(str)</code></td>
<td>字节数</td>
</tr>
<tr>
<td><code>char_length(str)</code></td>
<td>字符数</td>
</tr>
<tr>
<td><code>lower(str)</code></td>
<td>转小写</td>
</tr>
<tr>
<td><code>upper(str)</code></td>
<td>转大写</td>
</tr>
<tr>
<td><code>format(X, D)</code></td>
<td>将数字 X 转为 <code>#,###,###.##</code> 形式的字符串，D为小数位数</td>
</tr>
<tr>
<td><code>trim([{both &#124; leading &#124; trailing}] [remstr from] str)</code></td>
<td>去除两端空格，<code>remstr</code> 默认空格可指定字符</td>
</tr>
<tr>
<td><code>ltrim(str)</code></td>
<td>去除左端空格</td>
</tr>
<tr>
<td><code>rtrim(str)</code></td>
<td>去除右端空格</td>
</tr>
<tr>
<td><code>reverse(str)</code></td>
<td>反转</td>
</tr>
<tr>
<td><code>left(str, len)</code></td>
<td>返回 str 从左开始 <code>len</code> 个字符的字符串</td>
</tr>
<tr>
<td><code>right(str, len)</code></td>
<td>返回 str 从右开始 <code>len</code> 个字符的字符串</td>
</tr>
<tr>
<td><code>substring(str, [from] pos, [[for] len])</code></td>
<td>返回 str 从 <code>pos</code> 开始的len个字符的字符串</td>
</tr>
<tr>
<td><code>substr()</code></td>
<td>等价于  <code>substring()</code></td>
</tr>
<tr>
<td><code>locate(substr, str[, pos])</code></td>
<td>返回子串在 str 中第一次出现的位置，默认从 1 开始，没有则返回 0</td>
</tr>
<tr>
<td><code>instr(str, substr)</code></td>
<td>等价于 <code>locate(substr, str)</code></td>
</tr>
<tr>
<td><code>insert(str, pos, len, newstr)</code></td>
<td>将 str 从 <code>pos</code> 开始的 <code>len</code> 个字符替换为 <code>newstr</code></td>
</tr>
<tr>
<td><code>replace(str, from_str, to_str)</code></td>
<td>替换 str 的子串</td>
</tr>
<tr>
<td><code>strcmp(expr1,expr2)</code></td>
<td>比较两个字符串</td>
</tr>
<tr>
<td><code>repeat(str, count)</code></td>
<td>返回 str 重复 count 次组成的字符串</td>
</tr>
<tr>
<td><code>isnull(expr)</code></td>
<td>判断表达式是否为空</td>
</tr>
</tbody></table>
<h2 id="4-4-日期函数"><a href="#4-4-日期函数" class="headerlink" title="4.4 日期函数"></a>4.4 日期函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>now()</code></td>
<td>返回当前日期和时间 <code>yyyy-MM--dd HH:mm:ss</code></td>
</tr>
<tr>
<td><code>curdate()</code></td>
<td>返回当前日期 <code>yyyy-MM-dd</code></td>
</tr>
<tr>
<td><code>curtime()</code></td>
<td>返回当前时间 <code>HH:mm:ss</code></td>
</tr>
<tr>
<td><code>date_format(date, format)</code></td>
<td>日期格式化</td>
</tr>
<tr>
<td><code>year(date)/month(date)/day(date)/hour(time)</code></td>
<td>返回指定项</td>
</tr>
<tr>
<td><code>extract(year/month/day from now())</code></td>
<td>提取日期中的年月日…</td>
</tr>
<tr>
<td><code>datediff(expr1, expr2)</code></td>
<td>返回 <code>expr1 - expr2</code> 的日期差值</td>
</tr>
<tr>
<td><code>dayofyear(date)</code></td>
<td>返回指定日期是当年的第几天</td>
</tr>
<tr>
<td><code>dayofmonth(date)</code></td>
<td>返回指定日期是当月的第几天</td>
</tr>
<tr>
<td><code>dayofweek(date)</code></td>
<td>返回指定日期是当周的第几天（周日是第一天）</td>
</tr>
<tr>
<td><code>date_add(date, INTERVAL expr unit)</code></td>
<td>给日期加上指定值，unit 用来指定日期项，expr 为值</td>
</tr>
<tr>
<td><code>date_sub(date, INTERVAL expr unit)</code></td>
<td>给日期减去指定值</td>
</tr>
</tbody></table>
<h2 id="4-4-JSON-函数"><a href="#4-4-JSON-函数" class="headerlink" title="4.4 JSON 函数"></a>4.4 JSON 函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>json_array([val[, val ...]])</code></td>
<td>返回由参数组成json数组</td>
</tr>
<tr>
<td><code>json_object([key, val[, key, val ...]])</code></td>
<td>返回由参数组成的 json 对象，奇数参数是 key，偶数参数是 value</td>
</tr>
<tr>
<td><code>json_pretty(json_val)</code></td>
<td>漂亮的打印 json</td>
</tr>
<tr>
<td><code>json_array_append(json_doc, path, val[, path, val ...])</code></td>
<td>在 <code>json_doc</code> 指定位置上的值后追加值</td>
</tr>
<tr>
<td><code>json_array_insert(json_doc, path, val[, path, val ...])</code></td>
<td>向 json 数组指定位置插入值，返回新数组，不改变原有数组</td>
</tr>
<tr>
<td><code>json_insert(json_doc, path, val[, path, val ...])</code></td>
<td>向 json 对象添加新的键值对，返回新对象，不改变原对象</td>
</tr>
<tr>
<td><code>json_set(json_doc, path, val[, path, val ...])</code></td>
<td>替换 <code>json_doc</code> 指定位置现有的值，如果不存在则添加</td>
</tr>
<tr>
<td><code>json_replace(json_doc, path, val[, path, val ...])</code></td>
<td>仅替换现有的值</td>
</tr>
<tr>
<td><code>json_remove(json_doc, path[, path...])</code></td>
<td>删除 <code>json_doc</code> 指定位置的值</td>
</tr>
<tr>
<td><code>json_extract(json_doc, path[, path...])</code></td>
<td>获取 <code>json_doc</code> 指定位置的值</td>
</tr>
<tr>
<td><code>json_contains_path(json_doc, one_or_all, path[, path...])</code></td>
<td>判断是否包含指定路径（索引或者key）</td>
</tr>
<tr>
<td><code>json_contains(target, candidate[, path])</code></td>
<td>判断是否包含指定值</td>
</tr>
<tr>
<td><code>json_length(json_doc[, path])</code></td>
<td>返回 <code>json_doc</code> 的长度</td>
</tr>
</tbody></table>
<h2 id="4-5-自定义函数"><a href="#4-5-自定义函数" class="headerlink" title="4.5 自定义函数"></a>4.5 自定义函数</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE</span><br><span class="line">	[DEFINER = user]</span><br><span class="line">	FUNCTION sp_name ([func_parameter[,...]])</span><br><span class="line">	RETURNS type</span><br><span class="line">	[characteristic ...] </span><br><span class="line">	routine_body</span><br><span class="line"></span><br><span class="line">func_parameter: </span><br><span class="line">	param_name type</span><br><span class="line">type:</span><br><span class="line">	Any valid MySQL data type</span><br><span class="line">characteristic:</span><br><span class="line">	  COMMENT &apos;string&apos;</span><br><span class="line">	| LANGUAGE SQL</span><br><span class="line">	| [NOT] DETERMINISTIC</span><br><span class="line">	| &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;</span><br><span class="line">	| SQL SECURITY &#123; DEFINER | INVOKER &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-创建"><a href="#2-创建" class="headerlink" title="2 创建"></a>2 创建</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP FUNCTION IF EXISTS 函数名;</span><br><span class="line">DELIMITER 结束标记</span><br><span class="line">CREATE FUNCTION 函数名 ([参数列表]) RETURNS 返回值类型</span><br><span class="line">BEGIN </span><br><span class="line">    函数体</span><br><span class="line">    RETURN 返回值;</span><br><span class="line">END 结束标记</span><br><span class="line">DELIMITER ; -- 将结束标记改回默认分号</span><br></pre></td></tr></table></figure>

<ul>
<li>形参<ul>
<li><code>形参名 形参类型</code></li>
</ul>
</li>
<li>返回值<ul>
<li><code>{STRING | INTEGER | REAL | DECIMAL}</code></li>
<li>必须有返回值且只有一个</li>
</ul>
</li>
</ul>
<h3 id="3-查看"><a href="#3-查看" class="headerlink" title="3 查看"></a>3 查看</h3><ol>
<li><code>show function status [like pattern]</code><ul>
<li>查看所有函数</li>
</ul>
</li>
<li><code>show create function 函数名</code><ul>
<li>查看函数的创建语句</li>
</ul>
</li>
</ol>
<h3 id="4-修改-删除-函数"><a href="#4-修改-删除-函数" class="headerlink" title="4 修改/删除 函数"></a>4 修改/删除 函数</h3><ol>
<li>函数不能修改</li>
<li>删除<ul>
<li><code>drop function [if exists] 函数名</code></li>
</ul>
</li>
</ol>
<h1 id="五-流程控制语句"><a href="#五-流程控制语句" class="headerlink" title="五 流程控制语句"></a>五 流程控制语句</h1><h2 id="5-1-if"><a href="#5-1-if" class="headerlink" title="5.1 if"></a>5.1 if</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If  条件判断  then</span><br><span class="line">	-- 满足条件要执行的代码;</span><br><span class="line">Else</span><br><span class="line">	-- 不满足条件要执行的代码;</span><br><span class="line">End if;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-while"><a href="#5-2-while" class="headerlink" title="5.2 while"></a>5.2 while</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">While 条件判断 do</span><br><span class="line">	-- 循环体</span><br><span class="line">End while;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-Iterate-amp-Leave"><a href="#5-3-Iterate-amp-Leave" class="headerlink" title="5.3 Iterate &amp; Leave"></a>5.3 Iterate &amp; Leave</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">循环名:While 条件判断 do</span><br><span class="line">	-- 循环体</span><br><span class="line">	itrate/leave 循环名;</span><br><span class="line">End while;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>Iterate</code> 类似 <code>continue</code></li>
<li><code>Leave</code> 类似 <code>break</code></li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql库表列属性</title>
    <url>/anyeansan.github.io/2020/11/08/SQL/Mysql%E5%BA%93%E8%A1%A8%E5%88%97%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h1 id="一-库表属性"><a href="#一-库表属性" class="headerlink" title="一 库表属性"></a>一 库表属性</h1><h2 id="1-1-字符集（charset）"><a href="#1-1-字符集（charset）" class="headerlink" title="1.1 字符集（charset）"></a>1.1 字符集（charset）</h2><h3 id="1-MySQL-的-UTF-8"><a href="#1-MySQL-的-UTF-8" class="headerlink" title="1 MySQL 的 UTF-8"></a>1 MySQL 的 UTF-8</h3><ol>
<li>MySQL 中的 <code>utf8mb4</code> 才是真正的 <code>UTF-8</code>，而 <code>utf8</code> 是 <code>utf8mb3</code> 的别名，是 MySQL 脑残的产物</li>
<li>MySQL 表示未来会删除 <code>utf8mb3</code>，然后 <code>utf8</code> 指代 <code>utf8mb4</code>（真是个小机灵鬼）</li>
</ol>
<h3 id="2-字符集说明"><a href="#2-字符集说明" class="headerlink" title="2 字符集说明"></a>2 字符集说明</h3><ol>
<li><code>show charset</code><ul>
<li>查看数据库支持的字符集</li>
</ul>
</li>
<li><code>show variables like &#39;character%&#39;</code><ul>
<li>查看数据库默认字符集设置</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>配置</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>character_set_database</code></td>
<td>数据库默认字符集，若没设置则使用 <code>character_set_server</code></td>
</tr>
<tr>
<td><code>character_set_client</code></td>
<td>客户端字符集</td>
</tr>
<tr>
<td><code>character_set_connection</code></td>
<td>客户端连接数据库使用的字符集</td>
</tr>
<tr>
<td><code>character_set_results</code></td>
<td>数据库给客户端返回数据使用的字符集</td>
</tr>
<tr>
<td><code>character_set_server</code></td>
<td>服务器字符集，建议由系统自己管理，不要人为定义</td>
</tr>
<tr>
<td><code>character_set_filesystem</code></td>
<td>用于将系统文件名转化成此字符集，默认 <code>binary</code> 不做转换（建议不改动）</td>
</tr>
<tr>
<td><code>character_set_system</code></td>
<td>数据库系统用来存储元数据的编码，通常是 <code>utf8</code>（不要改动）</td>
</tr>
<tr>
<td><code>character_sets_dir</code></td>
<td>字符集安装目录</td>
</tr>
</tbody></table>
<h3 id="3-乱码问题"><a href="#3-乱码问题" class="headerlink" title="3 乱码问题"></a>3 乱码问题</h3><h4 id="1-存"><a href="#1-存" class="headerlink" title="1 存"></a>1 存</h4><ul>
<li><code>数据本身字符集</code> → <code>客户端字符集</code> → <code>连接字符集</code> → <code>数据库字符集</code><ol>
<li><code>数据本身字符集 = 客户端字符集</code>，若不一致则会乱码</li>
<li>将数据从 <code>客户端字符集</code> 转为 <code>连接字符集</code>，若一致则不转换</li>
<li>将数据从 <code>连接字符集</code> 转为 <code>数据库字符集</code>，若一致则不转换</li>
<li>存数据最终是按照 <code>数据库字符集</code> 存储</li>
</ol>
</li>
<li>结论<ol>
<li>保证 <code>数据本身字符集 = 客户端字符集</code></li>
<li>连接字符集不要太小导致转换损失数据</li>
</ol>
</li>
</ul>
<h4 id="2-取"><a href="#2-取" class="headerlink" title="2 取"></a>2 取</h4><ul>
<li><code>数据库字符集</code> → <code>连接字符集</code> → <code>结果字符集</code> → <code>客户端字符集</code><ol>
<li>将数据从 <code>数据库字符集</code> 转为 <code>连接字符集</code> ，若一致则不转换</li>
<li>将数据从 <code>连接字符集</code> 转为 <code>结果字符集</code>，若一致则不转换</li>
<li>取数据最终是按照结果字符集返回给客户端</li>
<li>比较 <code>结果字符集</code> 与 <code>客户端字符集</code> 是否一致</li>
</ol>
</li>
<li>结论<ol>
<li>保证 <code>结果字符集 = 客户端字符集</code></li>
<li>连接字符集不要太小导致转换损失数据</li>
</ol>
</li>
</ul>
<h2 id="1-2-校对集（collation）"><a href="#1-2-校对集（collation）" class="headerlink" title="1.2 校对集（collation）"></a>1.2 校对集（collation）</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>校对集，就是数据的比较方式，或者排序规则</li>
<li>只有当数据产生比较的时候，校对集才会生效</li>
<li>必须在没有数据之前声明好校对集，如果有了数据再进行校对集修改，修改无效</li>
<li>校对集依赖字符集，每个字符集都对应 1 或 多个校对集，如 <code>utf8mb4</code> 默认校对集 <code>utf8mb4_general_ci</code></li>
</ol>
<h3 id="2-校对集格式"><a href="#2-校对集格式" class="headerlink" title="2 校对集格式"></a>2 校对集格式</h3><ul>
<li><code>show collation</code><ul>
<li>查看数据库支持的校对集</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>_bin</code></td>
<td><code>binary</code>，二进制比较, 大小写敏感（适用比较特殊的数据，如拼音，日文…）</td>
</tr>
<tr>
<td><code>_ci</code></td>
<td><code>case insensitive</code>，大小写不敏感</td>
</tr>
<tr>
<td><code>_cs</code></td>
<td><code>case sensitive</code>，大小写敏感</td>
</tr>
</tbody></table>
<h2 id="1-3-存储引擎（engine）"><a href="#1-3-存储引擎（engine）" class="headerlink" title="1.3 存储引擎（engine）"></a>1.3 存储引擎（engine）</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>MySQL进行存储数据的方式。</li>
<li>每一种存储引擎使用不同的存储机制，索引技巧，锁定水平，最终提供广泛且不同的功能。</li>
</ol>
<h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2 分类"></a>2 分类</h3><ol>
<li><code>show engines</code><ul>
<li>查看支持的存储引擎</li>
</ul>
</li>
<li><code>select @@default_storage_engine</code><ul>
<li>查看默认的存储引擎</li>
</ul>
</li>
<li><code>alter table 表名 engine=存储引擎</code><ul>
<li>除了修改存储引擎外，还会做碎片整理</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>存储引擎</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>InnoDB</code></td>
<td>新版 MySQL 默认存储引擎</td>
</tr>
<tr>
<td><code>Myisam</code></td>
<td>速度快，不支持事务，安全性不够</td>
</tr>
<tr>
<td><code>Memory</code></td>
<td>数据存在内存中，不存在磁盘，一关闭服务器就消失。适合临时数据</td>
</tr>
<tr>
<td><code>XtraDB</code></td>
<td><code>PerconaDB</code> 默认存储引擎</td>
</tr>
<tr>
<td><code>TokuDB RocksDB MyRocks</code></td>
<td>第三方存储引擎：共同点是压缩比较高,数据插入性能极高</td>
</tr>
</tbody></table>
<h3 id="3-InnoDB"><a href="#3-InnoDB" class="headerlink" title="3 InnoDB"></a>3 InnoDB</h3><h4 id="1-特性"><a href="#1-特性" class="headerlink" title="1 特性"></a>1 特性</h4><ol>
<li>事务（Transaction）</li>
<li>行级锁（Row-level Lock）</li>
<li>多版本并发控制 MVCC（Multi-Version Concurrency Control）</li>
<li>自动故障安全恢复 ACSR（Auto Crash Safey Recovery）</li>
<li>热备份（Hot Backup）</li>
<li>外键</li>
<li>复制 Replication<ol>
<li>Group Commit</li>
<li>GTID (Global Transaction ID)</li>
<li>多线程（Multi-Threads-SQL）</li>
</ol>
</li>
</ol>
<h4 id="2-物理存储结构"><a href="#2-物理存储结构" class="headerlink" title="2 物理存储结构"></a>2 物理存储结构</h4><h5 id="1-共享表空间"><a href="#1-共享表空间" class="headerlink" title="1 共享表空间"></a>1 共享表空间</h5><table>
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>idbdata1</code></td>
<td>系统数据字典信息（统计信息），Undo 回滚日志等数据</td>
</tr>
<tr>
<td><code>ib_logfile0~ib_logfile1</code></td>
<td>Redo 重做日志文件，事务日志文件</td>
</tr>
<tr>
<td><code>ibtmp1</code></td>
<td>临时表空间，存储临时表（如 join union 等操作）</td>
</tr>
</tbody></table>
<h5 id="2-独立表空间"><a href="#2-独立表空间" class="headerlink" title="2 独立表空间"></a>2 独立表空间</h5><table>
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>.frm</code></td>
<td>存储表列信息（列名，列属性）</td>
</tr>
<tr>
<td><code>.ibd</code></td>
<td>存储表数据行和索引</td>
</tr>
<tr>
<td><code>opt</code></td>
<td>存储库属性</td>
</tr>
</tbody></table>
<ul>
<li>一张 InnoDB 表 = <code>ibdata1 + frm + ibd（段、区、页）</code></li>
</ul>
<h5 id="3-表空间（Tablespace）说明"><a href="#3-表空间（Tablespace）说明" class="headerlink" title="3 表空间（Tablespace）说明"></a>3 表空间（Tablespace）说明</h5><ol>
<li>共享表空间：将所有数据存储到同一个表空间中 ，管理比较混乱</li>
<li>独立表空间：一张表一个 <code>frm</code> 存储列信息，一个 <code>ibd</code> 存储数据行和索引</li>
<li>说明<ol>
<li>共享表空间是 5.5 版本出现的管理模式</li>
<li>5.6 版本开始默认使用独立表空间，保留共享表空间，只用来存储：数据字典信息，undo，临时表</li>
<li>5.7 版本临时表被独立出去，共享表空间只存储：数据字典信息，undo</li>
<li>8.0 版本undo也被独立出去，共享表空间只存储：数据字典信息</li>
</ol>
</li>
</ol>
<h3 id="4-核心参数"><a href="#4-核心参数" class="headerlink" title="4 核心参数"></a>4 核心参数</h3><h4 id="1-存储引擎"><a href="#1-存储引擎" class="headerlink" title="1 存储引擎"></a>1 存储引擎</h4><ol>
<li><code>default_storage_engine=innodb</code><ul>
<li>默认存储引擎</li>
</ul>
</li>
</ol>
<h4 id="2-表空间"><a href="#2-表空间" class="headerlink" title="2 表空间"></a>2 表空间</h4><ol>
<li><code>innobd_file_pre_table=1</code><ul>
<li>表空间模式，1 独立表空间</li>
</ul>
</li>
<li><code>innodb_data_file_path=ibdata1:512M:ibdata2:512M:autoextend</code><ul>
<li>共享表空间文件个数和大小</li>
</ul>
</li>
</ol>
<h4 id="3-缓冲区"><a href="#3-缓冲区" class="headerlink" title="3 缓冲区"></a>3 缓冲区</h4><ol>
<li><code>innodb_flush_log_at_trx_commit=1</code><ul>
<li>双一标准之一</li>
<li>控制了 innodb 将 <code>log buffer</code> 中的数据写入日志文件并 flush 磁盘的时间点，取值分别为 0、1、2 三个</li>
</ul>
</li>
<li><code>Innodb_flush_method=(O_DIRECT, fdatasync)</code><ul>
<li>双一标准之一</li>
<li>控制 <code>log buffer</code> 和 <code>data buffer</code> 刷写磁盘的时候是否经过文件系统缓存 <code>OS buffer</code></li>
</ul>
</li>
<li><code>innodb_max_dirty_pages_pct=75</code><ul>
<li>脏页刷写策略</li>
</ul>
</li>
</ol>
<h4 id="4-redo-日志"><a href="#4-redo-日志" class="headerlink" title="4 redo 日志"></a>4 redo 日志</h4><ol>
<li><code>innodb_log_buffer_size</code></li>
<li><code>innodb_log_file_size</code></li>
<li><code>innodb_log_files_in_group</code></li>
</ol>
<h1 id="二-列属性"><a href="#二-列属性" class="headerlink" title="二 列属性"></a>二 列属性</h1><h2 id="2-1-数据类型"><a href="#2-1-数据类型" class="headerlink" title="2.1 数据类型"></a>2.1 数据类型</h2><h3 id="1-数值类型"><a href="#1-数值类型" class="headerlink" title="1 数值类型"></a>1 数值类型</h3><h4 id="1-整型"><a href="#1-整型" class="headerlink" title="1 整型"></a>1 整型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>无符号范围</th>
<th>有符号范围</th>
</tr>
</thead>
<tbody><tr>
<td><strong>tinyint</strong></td>
<td>1 Byte</td>
<td><code>0 ~ 255</code></td>
<td><code>-128 ~ 127</code></td>
</tr>
<tr>
<td><code>smallint</code></td>
<td>2 Byte</td>
<td><code>0 ~ 65535</code></td>
<td><code>-2<sup>15</sup> ~ 2<sup>15</sup>-1</code></td>
</tr>
<tr>
<td><code>mediumint</code></td>
<td>3 Byte</td>
<td><code>0 ~ 2<sup>24</sup>-1</code>`</td>
<td><code>-2<sup>23</sup> ~ 2<sup>23</sup>-1</code></td>
</tr>
<tr>
<td><strong>int</strong></td>
<td>4 Byte</td>
<td><code>0 ~ 2<sup>32</sup>-1</code>`</td>
<td><code>-2<sup>31</sup> ~ 2<sup>31</sup>-1</code></td>
</tr>
<tr>
<td><code>bigint</code></td>
<td>8 Byte</td>
<td><code>0 ~ 2<sup>64</sup>-1</code>`</td>
<td><code>-2<sup>63</sup> ~ 2<sup>63</sup>-1</code></td>
</tr>
</tbody></table>
<ul>
<li><code>int(M)</code><ul>
<li><code>M</code> 与存储无关，只是标识显示长度，且要配合 <code>zerofill</code> 才有意义</li>
</ul>
</li>
</ul>
<h4 id="2-浮点型-amp-定点型"><a href="#2-浮点型-amp-定点型" class="headerlink" title="2 浮点型 &amp; 定点型"></a>2 浮点型 &amp; 定点型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>语法</th>
<th><code>M</code></th>
<th><code>D</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>float</code></td>
<td>单精度浮点型 4 Byte</td>
<td><code>float(M,D)</code></td>
<td>总位数</td>
<td>小数点后的位数（不足用0补，超过则四舍五入）</td>
</tr>
<tr>
<td><code>double</code></td>
<td>双精度浮点型 8 Byte</td>
<td><code>double(M,D)</code></td>
<td>总位数</td>
<td>小数点后的位数（不足用0补，超过则四舍五入）</td>
</tr>
<tr>
<td><code>decimal</code></td>
<td>定点型，底层使用字符串存储</td>
<td><code>decimal(M,D)</code></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="2-字符串类型"><a href="#2-字符串类型" class="headerlink" title="2 字符串类型"></a>2 字符串类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>语法</th>
<th><code>M</code></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>char</strong></td>
<td>定长字符串</td>
<td><code>char(M)</code></td>
<td>字符数 <code>[1,255]</code></td>
<td>char 会立即分配 M 个字符长度的存储空间，未占满用空格填充</td>
</tr>
<tr>
<td><strong>varchar</strong></td>
<td>变长字符串</td>
<td><code>varchar(M)</code></td>
<td>最大字符数 <code>[1,65535]</code></td>
<td>varchar 存储前会先判断长度，按需分配空间</td>
</tr>
<tr>
<td><code>tinytext</code></td>
<td>短文本</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>text</code></td>
<td>文本</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>mediumtext</code></td>
<td>中长文本</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>longtext</code></td>
<td>长文本</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="1-char"><a href="#1-char" class="headerlink" title="1 char"></a>1 char</h4><ol>
<li>非空 char 的最大长度是 255【字节】</li>
<li>可空 char 的最大长度是 254【字节】，因为允许为空时，系统会自动从整个记录中保留一个字节来存储 NULL</li>
</ol>
<h4 id="2-varchar"><a href="#2-varchar" class="headerlink" title="2 varchar"></a>2 varchar</h4><ol>
<li>非空 varchar 的最大长度是 65532【字节】<ol>
<li>如果存储值小于 255 字节，则使用 1 个字节标记长度</li>
<li>如果存储值超过 255 字节，则使用 2 个字节标记长度</li>
<li>varchar是从第二个字节开始存储的</li>
</ol>
</li>
<li>可空 varchar 的最大长度是 65531【字节】</li>
</ol>
<h4 id="3-以-utf8-为例比较"><a href="#3-以-utf8-为例比较" class="headerlink" title="3 以 utf8 为例比较"></a>3 以 utf8 为例比较</h4><table>
<thead>
<tr>
<th>类型</th>
<th>可存字符</th>
<th>实存字符</th>
<th>实占字节</th>
<th>利用率</th>
</tr>
</thead>
<tbody><tr>
<td><code>char(M)</code></td>
<td>M</td>
<td>n</td>
<td><code>M * 3</code></td>
<td><code>n / M</code></td>
</tr>
<tr>
<td><code>varchar(M)</code></td>
<td>M</td>
<td>n</td>
<td><code>n * 3 + (1~2)</code></td>
<td><code>n * 3 / （n * 3 + (1~2)）</code></td>
</tr>
</tbody></table>
<h3 id="3-枚举-enum"><a href="#3-枚举-enum" class="headerlink" title="3 枚举 enum"></a>3 枚举 enum</h3><ul>
<li><code>enum(value1, value2, value3, ...)</code><ol>
<li>建表时在字段上定义枚举列表，按照定义顺序索引值从 1 开始编号<ul>
<li>空字符串 <code>&quot;&quot;</code> 索引为 0</li>
<li><code>null</code> 索引为 <code>null</code></li>
</ul>
</li>
<li>插入数据时（单选），可以使用索引值或者枚举值</li>
<li>数据库存储时存储索引，读取时再根据枚举列表将索引转为枚举值</li>
</ol>
</li>
</ul>
<h3 id="4-集合-set"><a href="#4-集合-set" class="headerlink" title="4 集合 set"></a>4 集合 set</h3><ul>
<li><code>set(value1, value2, value3, ...)</code><ol>
<li>建表时在字段上定义集合列表，集合中每个值对应一个二进制位<ul>
<li>第一个值对应 <code>1 = 1</code></li>
<li>第二个值对应 <code>10 = 2</code></li>
<li>第三个值对应 <code>100 = 4</code></li>
<li>第四个值对应 <code>1000 = 8</code></li>
<li>…</li>
<li>也就是说一个二进制数，从低位向高位依次对应集合从 1 开始的值</li>
</ul>
</li>
<li>插入数据时（多选），可以使用二进制对应的十进制数字，插入数字对应的二进制，相应位置为 1 代表插入该值，例如<ul>
<li>插入 <code>6</code>，转为二进制 <code>110</code>，即插入第二和第三个值</li>
<li>插入 <code>7</code>，转为二进制 <code>111</code>，即插入前三个值</li>
<li>插入 <code>8</code>，转为二进制 <code>1000</code>，即插入第四个值</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="5-日期类型"><a href="#5-日期类型" class="headerlink" title="5 日期类型"></a>5 日期类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>格式</th>
<th>大小</th>
<th>最小值</th>
<th>最大值</th>
<th>零值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>datetime</strong></td>
<td><code>yyyy-mm-dd hh:mm:ss</code></td>
<td>8 Byte</td>
<td><code>1000-01-01 00:00:00</code></td>
<td><code>9999-12-31 23:59:59</code></td>
<td><code>0000-00-00 00:00:00</code></td>
<td>表示日期时间</td>
</tr>
<tr>
<td><strong>timestamp</strong></td>
<td><code>yyyy-mm-dd hh:mm:ss</code></td>
<td>4 Byte</td>
<td><code>1970-01-01 00:00:00</code></td>
<td><code>2038-01-19 03:14:07</code></td>
<td><code>0000-00-00 00:00:00</code></td>
<td></td>
</tr>
<tr>
<td><code>date</code></td>
<td><code>yyyy-mm-dd</code></td>
<td>3 Byte</td>
<td><code>1000-01-01</code></td>
<td><code>9999-12-31</code></td>
<td><code>0000-00-00</code></td>
<td>表示日期</td>
</tr>
<tr>
<td><code>time</code></td>
<td><code>hh:mm:ss</code></td>
<td>3 Byte</td>
<td><code>-838:59:59</code></td>
<td><code>838:59:59</code></td>
<td><code>00:00:00</code></td>
<td>表示时间</td>
</tr>
</tbody></table>
<ol>
<li><code>datatime</code><ul>
<li>存储日期时间</li>
</ul>
</li>
<li><code>timestamp</code><ol>
<li>时间戳（从 <code>1970-01-01 00:00:00</code> 到指定时间的毫秒值）</li>
<li>存储毫秒值，显示时，根据毫秒值计算出一个本地化的日期时间（即可以自动根据时区显示）</li>
<li><code>timestamp</code> 因为存储的毫秒值，比较或计算时效率更高</li>
<li>插入时未指定值或插入 <code>null</code>，则会插入系统当前时间</li>
</ol>
</li>
<li>插入 Mysql 的日期时间格式为  <code>yyyy-MM-dd HH:mm:ss</code></li>
</ol>
<h3 id="6-二进制类型"><a href="#6-二进制类型" class="headerlink" title="6 二进制类型"></a>6 二进制类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>tinyblob</code></td>
<td>最大长度为255B</td>
</tr>
<tr>
<td><code>blob</code></td>
<td>最大长度为64KB</td>
</tr>
<tr>
<td><code>mediumblob</code></td>
<td>最大长度为16MB</td>
</tr>
<tr>
<td><code>longblob</code></td>
<td>最大长度为4GB</td>
</tr>
</tbody></table>
<ul>
<li>二进制数据类型可存储任何数据（甚至包括二进制信息），如图像、多媒体、字处理文档等</li>
</ul>
<h2 id="2-2-注释"><a href="#2-2-注释" class="headerlink" title="2.2 注释"></a>2.2 注释</h2><ul>
<li><code>comment &#39;注释&#39;</code><ul>
<li>用于描述字段信息</li>
</ul>
</li>
</ul>
<h2 id="2-3-unsigned"><a href="#2-3-unsigned" class="headerlink" title="2.3 unsigned"></a>2.3 unsigned</h2><ul>
<li><code>unsigned</code><ol>
<li>将数值类型声明为无符号</li>
<li>MySQL 中的数值默认都是有符号的。</li>
</ol>
</li>
</ul>
<h2 id="2-4-zerofill"><a href="#2-4-zerofill" class="headerlink" title="2.4 zerofill"></a>2.4 zerofill</h2><ul>
<li><code>zerofill</code><ol>
<li>数值类型的列位数不足时用 0 补填充</li>
<li>如果声明 <code>zerofill</code>，则会自动声明为 <code>unsigned</code></li>
</ol>
</li>
</ul>
<h2 id="2-5-自增长"><a href="#2-5-自增长" class="headerlink" title="2.5 自增长"></a>2.5 自增长</h2><h3 id="1-添加自增长"><a href="#1-添加自增长" class="headerlink" title="1 添加自增长"></a>1 添加自增长</h3><ul>
<li><code>字段 auto_increment</code><ol>
<li>一张表只能有一个自增长，因为一张表只有一个维护自增长的变量</li>
<li>自增的列必须是整数列</li>
<li>自增的列必须是键列（主键，唯一键，外键）</li>
<li>建表后，增删自增长通过修改列属性来实现</li>
</ol>
</li>
</ul>
<h3 id="2-使用自增长"><a href="#2-使用自增长" class="headerlink" title="2 使用自增长"></a>2 使用自增长</h3><ol>
<li>自增列指定了值且非 <code>0 null</code>，则使用指定值<ol>
<li>如果指定值 &lt; 自增值，则表的自增值不变</li>
<li>如果指定值 &gt; 自增值，则表的自增值会变成指定值</li>
</ol>
</li>
<li>使用自增值<ol>
<li>自增列没有指定值</li>
<li>自增列指定值为 <code>0 null default</code></li>
</ol>
</li>
</ol>
<h3 id="3-自增长管理"><a href="#3-自增长管理" class="headerlink" title="3 自增长管理"></a>3 自增长管理</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>show variables like &#39;auto_increment%&#39;</code></td>
<td>查看自增长初始值和种子</td>
</tr>
<tr>
<td><code>select last_insert_id()</code></td>
<td>获取自增的最后一个值</td>
</tr>
<tr>
<td><code>show create database 库名</code></td>
<td>通过查看表创建语句查看下一次自增长的值</td>
</tr>
<tr>
<td><code>alter table 表名 auto_increment = 值</code></td>
<td>修改自增长的值，只能比当前自增长的最大值大，不能小（小则不生效）</td>
</tr>
</tbody></table>
<h2 id="2-6-约束（Constraint）"><a href="#2-6-约束（Constraint）" class="headerlink" title="2.6 约束（Constraint）"></a>2.6 约束（Constraint）</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h3><table>
<thead>
<tr>
<th>约束</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Primary key</code></td>
<td>主键约束</td>
<td>唯一，非空，一张表只能有一个</td>
</tr>
<tr>
<td><code>Foreign key</code></td>
<td>外键约束</td>
<td>用于在两表之间建立关系，需指定引用主表的哪一列</td>
</tr>
<tr>
<td><code>Unique key</code></td>
<td>唯一键约束</td>
<td>唯一，非空，一张表可有多个唯一键</td>
</tr>
<tr>
<td><code>Not Null</code></td>
<td>非空约束</td>
<td>要求该列值不能为空</td>
</tr>
<tr>
<td><code>Default</code></td>
<td>默认约束</td>
<td>设置该列默认值</td>
</tr>
<tr>
<td><code>Check</code></td>
<td>检查约束（Mysql 不支持）</td>
<td>限制该列取值范围是否合适</td>
</tr>
</tbody></table>
<ul>
<li><code>select * from information_schema.table_constraints where table_name = &#39;表名&#39;</code><ul>
<li>查看某表的约束信息</li>
<li>表的约束信息存储在 <code>information_shcema</code> 数据库的 <code>table_constraints</code> 表中</li>
</ul>
</li>
</ul>
<h3 id="2-主键约束"><a href="#2-主键约束" class="headerlink" title="2 主键约束"></a>2 主键约束</h3><h4 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>主键列唯一，非空，一张表只能有一个主键</li>
<li>主键分为：<ol>
<li>单列主键（单列） </li>
<li>复合主键（多列）</li>
</ol>
</li>
<li>创建主键会自动创建对应的索引，删除主键会自动删除对应的索引</li>
<li>主键无法修改</li>
<li>主键约束名称为 <code>PRIMARY</code></li>
</ol>
<h4 id="2-添加主键约束"><a href="#2-添加主键约束" class="headerlink" title="2 添加主键约束"></a>2 添加主键约束</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>字段 primaray key</code></td>
<td>建表时，为当前列添加单列主键</td>
</tr>
<tr>
<td><code>primary key(字段列表)</code></td>
<td>建表时，单独一行，添加单列主键或复合主键</td>
</tr>
<tr>
<td><code>alter table 表名 add primary key(字段列表)</code></td>
<td>建表后，添加单列主键或复合主键</td>
</tr>
</tbody></table>
<h4 id="3-删除主键约束"><a href="#3-删除主键约束" class="headerlink" title="3 删除主键约束"></a>3 删除主键约束</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>alter table 表名 drop primary key</code></td>
<td>有自增长先要删除自增长，因为自增长的列必须有索引</td>
</tr>
</tbody></table>
<h3 id="3-唯一键约束"><a href="#3-唯一键约束" class="headerlink" title="3 唯一键约束"></a>3 唯一键约束</h3><h4 id="1-概述-4"><a href="#1-概述-4" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>唯一约束列唯一，可以为 <code>null</code>，且可以有多个 <code>null</code>，因为 <code>null = null -&gt; false</code></li>
<li>一张表可以有多个唯一约束 </li>
<li>唯一键分为：<ol>
<li>单列唯一键（约束名：列名）</li>
<li>复合唯一键（约束名：该多列组合的第一列的列名）</li>
</ol>
</li>
<li>创建唯一键约束会自动创建对应的索引，删除唯一键约束是通过删除对应索引来删除</li>
</ol>
<h4 id="2-添加唯一键约束"><a href="#2-添加唯一键约束" class="headerlink" title="2 添加唯一键约束"></a>2 添加唯一键约束</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>字段 unique key</code></td>
<td>建表时，为当前列添加单列唯一键</td>
</tr>
<tr>
<td><code>unique key(字段列表)</code></td>
<td>建表时，单独一行，添加单列唯一键或复合唯一键</td>
</tr>
<tr>
<td><code>alter table 表名 add unique key(字段列表)</code></td>
<td>建表后，添加单列唯一键或复合唯一键</td>
</tr>
</tbody></table>
<h4 id="3-删除唯一键约束"><a href="#3-删除唯一键约束" class="headerlink" title="3 删除唯一键约束"></a>3 删除唯一键约束</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>alter table 表名 drop [index/key] 唯一键约束名</code></td>
<td>通过删除索引删除唯一键约束</td>
</tr>
</tbody></table>
<h3 id="4-外键约束"><a href="#4-外键约束" class="headerlink" title="4 外键约束"></a>4 外键约束</h3><h4 id="1-概述-5"><a href="#1-概述-5" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>外键约束建立在从表之上，一个表可以有多个外键约束</li>
<li>主表和从表必须使用相同的存储引擎 <code>InnoDB</code>，且禁止使用临时表</li>
<li>从表的外键列和主表的被引用列的名称可以不同，列属性必须一致</li>
<li>主表被引用列必须是键列</li>
<li>从表添加外键约束时会自动创建索引，删除外键约束不会删除索引</li>
</ol>
<h4 id="2-外键约束模式"><a href="#2-外键约束模式" class="headerlink" title="2 外键约束模式"></a>2 外键约束模式</h4><h5 id="1-概述-6"><a href="#1-概述-6" class="headerlink" title="1 概述"></a>1 概述</h5><ol>
<li>外键约束同时约束双方行为<ul>
<li>主表：<code>update delete</code><ul>
<li>因为从表有可能引用了主表要更新或删除的数据</li>
</ul>
</li>
<li>从表：<code>insert update</code><ul>
<li>从表的数据必须存在于主表之中</li>
</ul>
</li>
</ul>
</li>
<li>建表时：先建主表再建从表，删表时：先删从表再删主表</li>
<li>删除和修改可以分别指定外键约束模式<ol>
<li><code>on update 模式</code></li>
<li><code>on delete 模式</code></li>
</ol>
</li>
</ol>
<h5 id="2-模式"><a href="#2-模式" class="headerlink" title="2 模式"></a>2 模式</h5><table>
<thead>
<tr>
<th>模式</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>restrict（默认）</code></td>
<td>严格模式</td>
<td>如果从表外键列有引用，则主表不能 <code>update/delete</code> 被引用列的值</td>
</tr>
<tr>
<td><code>no action</code></td>
<td>严格模式</td>
<td>标准 SQL 的关键字，在 MySQL 中同 <code>restrict</code></td>
</tr>
<tr>
<td><code>cascade</code></td>
<td>级联模式</td>
<td>主表被引用列的值<br>1. <code>update</code>，则从表外键列对应值 <code>update</code><br>2. <code>delete</code> ，则从表删除对应的整行记录</td>
</tr>
<tr>
<td><code>set null</code></td>
<td>置空模式</td>
<td>主表被引用列的值 <code>update/delete</code> 时， 从表外键列对应值设为 <code>null</code>（外键列要可以为空）</td>
</tr>
<tr>
<td><code>set default</code></td>
<td>默认值模式</td>
<td>Mysql Innodb不支持</td>
</tr>
</tbody></table>
<h4 id="3-添加外键约束"><a href="#3-添加外键约束" class="headerlink" title="3 添加外键约束"></a>3 添加外键约束</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>foreign key(从表外键列) references 主表名(被引用列) [on delete 模式 on update 模式]</code></td>
<td>建表时，单独一行，添加外键约束</td>
</tr>
<tr>
<td><code>alter table 从表名 add foreign key(从表外键列) references 主表名(被引用列) [on delete 模式 on update 模式]</code></td>
<td>建表后，添加外键约束</td>
</tr>
</tbody></table>
<h4 id="4-删除外键约束"><a href="#4-删除外键约束" class="headerlink" title="4 删除外键约束"></a>4 删除外键约束</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>alter table 表名 drop foreign key 外键约束名</code></td>
<td>外键约束名通过系统库 <code>information_schema</code> 的 <code>table_constraints</code> 获取</td>
</tr>
</tbody></table>
<h3 id="5-非空约束"><a href="#5-非空约束" class="headerlink" title="5 非空约束"></a>5 非空约束</h3><ul>
<li><code>not null</code><ol>
<li>列不能为 <code>null</code>，必须插入值，通常配合 <code>default</code> 使用</li>
<li>建表后，增删非空约束通过修改列属性来实现</li>
</ol>
</li>
</ul>
<h3 id="6-默认约束"><a href="#6-默认约束" class="headerlink" title="6 默认约束"></a>6 默认约束</h3><ul>
<li><code>字段 default 默认值</code><ol>
<li>使用默认值<ol>
<li>对应字段没有插入值</li>
<li>对应字段插入值为 <code>default</code></li>
</ol>
</li>
<li>建表后，增删默认约束通过修改列属性来实现</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql前言</title>
    <url>/anyeansan.github.io/2020/11/08/SQL/Mysql%E5%89%8D%E8%A8%80/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><ol>
<li><code>DBMS（Database Management System）</code>：数据库管理系统<ol>
<li>RDBMS（Relational DBMS）<ul>
<li><code>Oracle DB2</code></li>
<li><code>Sql-Server Mysql</code></li>
<li><code>access</code></li>
<li><code>PG MSSQL</code></li>
</ul>
</li>
<li>NoSQL（Not Only SQL）<ul>
<li><code>MongoDB</code></li>
<li><code>Redis</code></li>
<li><code>ES（Elasticsearch）</code></li>
<li><code>memcached</code></li>
</ul>
</li>
<li>NewSQL（分布式）<ul>
<li><code>TiDB Spanner AliSQL OB PolarDB</code></li>
</ul>
</li>
</ol>
</li>
<li><code>DBA（Database Administrator）</code>：数据库管理员</li>
</ol>
<h2 id="1-2-Mysql-GA版本"><a href="#1-2-Mysql-GA版本" class="headerlink" title="1.2 Mysql GA版本"></a>1.2 Mysql GA版本</h2><ol>
<li><code>5.6</code><ul>
<li><code>5.6.38</code>（2017-09-13）</li>
</ul>
</li>
<li><code>5.7</code><ul>
<li><code>5.7.20</code>（2017-09-13）</li>
</ul>
</li>
</ol>
<h2 id="1-3-数据库设计三大范式"><a href="#1-3-数据库设计三大范式" class="headerlink" title="1.3 数据库设计三大范式"></a>1.3 数据库设计三大范式</h2><ol>
<li>每个单元格都应该是单一值，并且列不重复</li>
<li>每个表都应该是单一功能的，即一个表能且仅能表示一个实体类型，表中所有字段都是用来描述此实体的</li>
<li>一个表中的字段不该由表中其它字段推导而来</li>
</ol>
<h1 id="二-Mysql-安装与配置"><a href="#二-Mysql-安装与配置" class="headerlink" title="二 Mysql 安装与配置"></a>二 Mysql 安装与配置</h1><h2 id="2-1-Linux"><a href="#2-1-Linux" class="headerlink" title="2.1 Linux"></a>2.1 Linux</h2><h3 id="1-下载解压"><a href="#1-下载解压" class="headerlink" title="1 下载解压"></a>1 下载解压</h3><ol>
<li>下载 <code>linux-generic</code> 通用二进制包（类似绿色版）</li>
<li>上传到 linux 并解压</li>
</ol>
<h3 id="2-卸载-mariadb"><a href="#2-卸载-mariadb" class="headerlink" title="2 卸载 mariadb"></a>2 卸载 <code>mariadb</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 rpm -qa | grep mariadb</span><br><span class="line">2 yum remove -y xxx</span><br></pre></td></tr></table></figure>

<h3 id="3-创建用户并授权，用于管理mysql"><a href="#3-创建用户并授权，用于管理mysql" class="headerlink" title="3 创建用户并授权，用于管理mysql"></a>3 创建用户并授权，用于管理mysql</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 useradd -s /sbin/nologin mysql</span><br><span class="line">2 chown -R mysql.mysql basedir</span><br><span class="line">3 chown -R mysql.mysql datadir</span><br></pre></td></tr></table></figure>

<h3 id="4-设置环境变量"><a href="#4-设置环境变量" class="headerlink" title="4 设置环境变量"></a>4 设置环境变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 vim /etc/profile</span><br><span class="line">2 export PATH=basedir/bin:$PATH</span><br><span class="line">3 source /etc/profile</span><br><span class="line">4 mysql -V</span><br></pre></td></tr></table></figure>

<h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5 初始化"></a>5 初始化</h3><h4 id="1-无密码"><a href="#1-无密码" class="headerlink" title="1 无密码"></a>1 无密码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqld --initialize-insecure --user=mysql --basedir=xxx --datadir=xxx</span><br></pre></td></tr></table></figure>

<h4 id="2-有密码"><a href="#2-有密码" class="headerlink" title="2 有密码"></a>2 有密码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqld --initialize --user=mysql --basedir=xxx --datadir=xxx</span><br></pre></td></tr></table></figure>

<ol>
<li>可能会因为缺少 <code>libaio-devel</code> 依赖而报错</li>
<li><code>--initialize</code><ol>
<li>对密码复杂度进行定制：12位，4种</li>
<li>密码过期时间：180天</li>
<li>给 <code>root@localhost</code> 用户设置临时密码</li>
</ol>
</li>
</ol>
<h3 id="6-配置文件-etc-my-cnf"><a href="#6-配置文件-etc-my-cnf" class="headerlink" title="6 配置文件 /etc/my.cnf"></a>6 配置文件 <code>/etc/my.cnf</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld] </span><br><span class="line">user=mysql</span><br><span class="line">basedir=</span><br><span class="line">datadir=</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">port=3306</span><br><span class="line">server_id=6</span><br><span class="line">[mysql]</span><br><span class="line">socket=/tmp/mysql.sock</span><br></pre></td></tr></table></figure>

<h3 id="7-MySQL-服务"><a href="#7-MySQL-服务" class="headerlink" title="7 MySQL 服务"></a>7 MySQL 服务</h3><h4 id="1-服务启动配置"><a href="#1-服务启动配置" class="headerlink" title="1 服务启动配置"></a>1 服务启动配置</h4><h5 id="1-作用"><a href="#1-作用" class="headerlink" title="1 作用"></a>1 作用</h5><ol>
<li>影响数据库的启动</li>
<li>影响客户端的功能</li>
</ol>
<h5 id="2-配置方式"><a href="#2-配置方式" class="headerlink" title="2 配置方式"></a>2 配置方式</h5><ol>
<li>配置文件</li>
<li>命令行启动参数：如果参数冲突，命令行参数会优先级高于配置文件</li>
<li>编译安装时配置</li>
</ol>
<h5 id="3-配置文件"><a href="#3-配置文件" class="headerlink" title="3 配置文件"></a>3 配置文件</h5><h6 id="1-加载顺序"><a href="#1-加载顺序" class="headerlink" title="1 加载顺序"></a>1 加载顺序</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 默认情况下，MySQL启动时，会依序读取配置文件，如果有重复选项，会以最后一个文件设置的为准</span><br><span class="line">// 查看配置文件加载顺序</span><br><span class="line">mysqld --help --verbose | grep my.cnf</span><br><span class="line"></span><br><span class="line">// 如果启动时手动配置了配置文件，则默认配置文件都不再读取</span><br><span class="line">--defaults-file=</span><br></pre></td></tr></table></figure>

<h6 id="2-格式"><a href="#2-格式" class="headerlink" title="2 格式"></a>2 格式</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[module]</span><br><span class="line">key=value</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">module</span><br><span class="line">	1. 服务端</span><br><span class="line">		1. [mysqld]</span><br><span class="line">		2. [mysqld_safe]</span><br><span class="line">		3. [server]</span><br><span class="line">			* 包括服务端所有</span><br><span class="line">	2. 客户端</span><br><span class="line">		1. [mysql]</span><br><span class="line">		2. [mysqladmin]</span><br><span class="line">		3. [mysqldump]</span><br><span class="line">		4. [client]</span><br><span class="line">			* 包括客户端所有</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h6 id="3-样板"><a href="#3-样板" class="headerlink" title="3 样板"></a>3 样板</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -----------------服务端配置-------------------------</span><br><span class="line">[mysqld]</span><br><span class="line"># 管理用户</span><br><span class="line">user=mysql</span><br><span class="line"># 软件安装目录</span><br><span class="line">basedir=/app/mysql</span><br><span class="line"># 数据目录</span><br><span class="line">datadir=/data/mysql/data</span><br><span class="line"># 服务端保存 socket 文件路径</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line"># 端口号</span><br><span class="line">port=3306</span><br><span class="line"># 服务器id号 1~65535</span><br><span class="line">server_id=6</span><br><span class="line"># -----------------客户端配置-------------------------</span><br><span class="line">[mysql]</span><br><span class="line"># 客户端登录时寻找 socket 文件路径 </span><br><span class="line">socket=/tmp/mysql.sock</span><br></pre></td></tr></table></figure>

<h4 id="2-服务启动方式"><a href="#2-服务启动方式" class="headerlink" title="2 服务启动方式"></a>2 服务启动方式</h4><h5 id="1-init"><a href="#1-init" class="headerlink" title="1 init"></a>1 <code>init</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1 配置</span><br><span class="line">cp basedir/support-files/mysql.server /etc/init.d/mysqld</span><br><span class="line"></span><br><span class="line">// 2 启动</span><br><span class="line">service mysqld start 或者 /etc/init.d/mysqld start</span><br></pre></td></tr></table></figure>

<ul>
<li>其实是调用了 <code>basedir/support-files/mysql.server</code> 脚本<ol>
<li>读取 <code>/etc/my.cnf</code> 配置文件<ol start="2">
<li>调用 <code>basedir/bin/mysqld_safe</code> 来启动 <code>mysqld</code></li>
</ol>
</li>
</ol>
</li>
</ul>
<h5 id="2-systemd"><a href="#2-systemd" class="headerlink" title="2 systemd"></a>2 <code>systemd</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1 配置 /etc/systemd/system/mysqld.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=MySQL Server</span><br><span class="line">Documentation=man:mysqld(8)</span><br><span class="line">Documentation=http://dev.mysql.com/doc/refman/en/using-systemd.html</span><br><span class="line">After=network.target</span><br><span class="line">After=syslog.target</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">[Service]</span><br><span class="line">User=mysql</span><br><span class="line">Group=mysql</span><br><span class="line">ExecStart=basedir/bin/mysqld --defaults-file=/etc/my.cnf</span><br><span class="line">LimitNOFILE = 5000</span><br><span class="line"></span><br><span class="line">// 2 启动</span><br><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure>

<ul>
<li>其实是加载了 <code>/etc/systemd/system/mysqld.service</code><ol>
<li>读取 <code>/etc/my.cnf</code> 配置文件</li>
<li>启动 <code>mysqld</code></li>
</ol>
</li>
</ul>
<h5 id="3-手动"><a href="#3-手动" class="headerlink" title="3 手动"></a>3 手动</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 维护模式启动</span><br><span class="line">mysqld_safe --skip-grant-tables --skip-networking &amp;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Windows"><a href="#2-2-Windows" class="headerlink" title="2.2 Windows"></a>2.2 Windows</h2><h3 id="1-配置环境变量"><a href="#1-配置环境变量" class="headerlink" title="1 配置环境变量"></a>1 配置环境变量</h3><h3 id="2-在MySql目录下创建-ini-配置文件"><a href="#2-在MySql目录下创建-ini-配置文件" class="headerlink" title="2 在MySql目录下创建 .ini 配置文件"></a>2 在MySql目录下创建 <code>.ini</code> 配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 服务端配置</span><br><span class="line">[mysqld] </span><br><span class="line">basedir =</span><br><span class="line">datadir =</span><br><span class="line">port = 3306</span><br><span class="line">character-set-server=utf8mb4 // 1</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8mb4 // 2</span><br></pre></td></tr></table></figure>

<ul>
<li>配置结果：12皆不配置/配置1/配置2<br><img src="https://github.com/anyeansan/pics/raw/master/CS/SQL/%E4%B8%8D%E9%85%8D%E7%BD%AE12%E7%BB%93%E6%9E%9C.png" alt=""><br><img src="https://github.com/anyeansan/pics/raw/master/CS/SQL/%E9%85%8D%E7%BD%AE1%E7%BB%93%E6%9E%9C.png" alt=""><br><img src="https://github.com/anyeansan/pics/raw/master/CS/SQL/%E9%85%8D%E7%BD%AE2%E7%BB%93%E6%9E%9C.png" alt=""></li>
</ul>
<h3 id="3-初始化：在-basedir-bin-下执行命令"><a href="#3-初始化：在-basedir-bin-下执行命令" class="headerlink" title="3 初始化：在 basedir/bin 下执行命令"></a>3 初始化：在 <code>basedir/bin</code> 下执行命令</h3><ol>
<li><code>mysqld --initialize --console</code><ul>
<li>随机密码，并在控制台显示密码</li>
</ul>
</li>
<li><code>mysqld --initialize-insecure</code><ul>
<li>无密码</li>
</ul>
</li>
</ol>
<h3 id="4-服务"><a href="#4-服务" class="headerlink" title="4 服务"></a>4 服务</h3><ol>
<li><code>mysqld --install</code><ul>
<li>安装服务</li>
</ul>
</li>
<li><code>net start mysql</code><ul>
<li>启动服务</li>
</ul>
</li>
<li><code>net stop mysql</code><ul>
<li>停止服务</li>
</ul>
</li>
<li><code>mysqld remove</code> / <code>sc delete mysql</code><ul>
<li>删除服务</li>
</ul>
</li>
</ol>
<h1 id="三-MySQL-的连接"><a href="#三-MySQL-的连接" class="headerlink" title="三 MySQL 的连接"></a>三 MySQL 的连接</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol>
<li>Mysql 是 C/S 模型</li>
<li>使用 Mysql 需要安装服务端，连接服务端需要通过客户端</li>
</ol>
<h2 id="3-2-客户端"><a href="#3-2-客户端" class="headerlink" title="3.2 客户端"></a>3.2 客户端</h2><h3 id="1-MySQL自带的命令行工具-mysql-exe"><a href="#1-MySQL自带的命令行工具-mysql-exe" class="headerlink" title="1 MySQL自带的命令行工具 mysql.exe"></a>1 MySQL自带的命令行工具 <code>mysql.exe</code></h3><h4 id="1-连接方式"><a href="#1-连接方式" class="headerlink" title="1 连接方式"></a>1 连接方式</h4><table>
<thead>
<tr>
<th>命令</th>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>mysql [-h Host] [-Pport] -uuser -p[password]</code></td>
<td>TCP/IP 方式</td>
<td>本地、远程</td>
</tr>
<tr>
<td><code>mysql -uuser -p[password] [-S /tmp/mysql.sock]</code></td>
<td>Socket 方式</td>
<td>本地</td>
</tr>
</tbody></table>
<h4 id="2-mysql-OPTION-（mysql-命令）"><a href="#2-mysql-OPTION-（mysql-命令）" class="headerlink" title="2 mysql [OPTION] （mysql 命令）"></a>2 <code>mysql [OPTION]</code> （mysql 命令）</h4><table>
<thead>
<tr>
<th>OPTION</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-u user</code></td>
<td>用户名</td>
</tr>
<tr>
<td><code>-ppassword</code></td>
<td>密码和 <code>p</code> 之间不能有空格</td>
</tr>
<tr>
<td><code>-h host</code></td>
<td>主机地址</td>
</tr>
<tr>
<td><code>-P port</code></td>
<td>端口</td>
</tr>
<tr>
<td><code>-S Socket</code></td>
<td>Socket 文件路径</td>
</tr>
<tr>
<td><code>-e &quot;sql&quot;</code></td>
<td>免交互执行命令（即不连接数据库）</td>
</tr>
<tr>
<td><code>&lt; 脚本路径</code></td>
<td>导入 sql 脚本</td>
</tr>
<tr>
<td><code>-prompt 提示符</code></td>
<td>定义 mysql 提示符，默认为 <code>mysql&gt;</code></td>
</tr>
</tbody></table>
<h4 id="3-mysqldump-命令"><a href="#3-mysqldump-命令" class="headerlink" title="3 mysqldump 命令"></a>3 mysqldump 命令</h4><ul>
<li><code>mysqldump -hhost -Pport -uuser -ppassword --databse 库名 &gt; .sql路径</code><ul>
<li>不登录，导出某个数据库的备份（导出 sql 脚本）</li>
</ul>
</li>
</ul>
<h3 id="2-图形化工具（GUI）"><a href="#2-图形化工具（GUI）" class="headerlink" title="2 图形化工具（GUI）"></a>2 图形化工具（GUI）</h3><table>
<thead>
<tr>
<th align="center">软件</th>
<th align="center">windows</th>
<th align="center">mac</th>
<th align="center">linux</th>
<th align="center">功能</th>
<th align="center">免费版</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>sequelpro</code></td>
<td align="center">&nbsp;</td>
<td align="center">√</td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center"><code>dbeaver</code></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">&nbsp;</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center"><code>navicat</code></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">强</td>
<td align="center">&nbsp;</td>
</tr>
<tr>
<td align="center"><code>SQLyog</code></td>
<td align="center">√</td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center">强</td>
<td align="center">&nbsp;</td>
</tr>
<tr>
<td align="center"><code>dbForge</code></td>
<td align="center">√</td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center">强</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center"><code>heidisql</code></td>
<td align="center">√</td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center"><code>TablePlus</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h1 id="四-MySQL-体系结构"><a href="#四-MySQL-体系结构" class="headerlink" title="四 MySQL 体系结构"></a>四 MySQL 体系结构</h1><h2 id="4-1-mysql-实例"><a href="#4-1-mysql-实例" class="headerlink" title="4.1 mysql 实例"></a>4.1 mysql 实例</h2><ol>
<li><code>mysqld</code>（老板）</li>
<li><code>master thread</code>（经理）</li>
<li><code>other thread</code>（员工）</li>
<li><code>预分配内存</code>（办公区）</li>
</ol>
<h2 id="4-2-MySQL-逻辑架构"><a href="#4-2-MySQL-逻辑架构" class="headerlink" title="4.2 MySQL 逻辑架构"></a>4.2 MySQL 逻辑架构</h2><h3 id="1-连接层"><a href="#1-连接层" class="headerlink" title="1 连接层"></a>1 连接层</h3><ol>
<li>提供连接协议：TCP/IP 、SOCKET</li>
<li>提供验证：用户、密码、IP、Port、SOCKET …</li>
<li>提供专用连接线程：接收用户SQL，返回结果<ul>
<li><code>show processlist</code><ul>
<li>查看连接线程</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="2-SQL-层（服务层）"><a href="#2-SQL-层（服务层）" class="headerlink" title="2 SQL 层（服务层）"></a>2 SQL 层（服务层）</h3><ol>
<li>接收上层传送的SQL语句</li>
<li>语法验证模块：验证语句语法,是否满足SQL_MODE</li>
<li>语义检查：判断SQL语句的类型（DQL、DML …）</li>
<li>权限检查：用户对库表有没有权限</li>
<li>解析器：语句执行前进行预处理，生成解析树(执行计划)，说白了就是生成多种执行方案</li>
<li>优化器：根据解析器得出的多种执行计划，进行判断，选择最优的执行计划<ul>
<li>代价模型：资源（CPU IO MEM）的耗损评估性能好坏</li>
</ul>
</li>
<li>执行器：根据最优执行计划，执行SQL语句，产生执行结果（在磁盘上）</li>
<li>提供查询缓存（默认没开启）：会使用redis tair替代查询缓存功能</li>
<li>提供日志记录（默认没开启）：二进制日志 <code>binlog</code> 、审计日志、通用日志 …</li>
</ol>
<h3 id="3-存储引擎层"><a href="#3-存储引擎层" class="headerlink" title="3 存储引擎层"></a>3 存储引擎层</h3><ol>
<li>根据SQL层执行的结果，从磁盘上拿数据</li>
<li>将16进制的磁盘数据，返回给 SQL 层结构化成表</li>
<li>由连接层的专用线程返回给用户</li>
</ol>
<h2 id="4-3-MySQL-逻辑存储结构"><a href="#4-3-MySQL-逻辑存储结构" class="headerlink" title="4.3 MySQL 逻辑存储结构"></a>4.3 MySQL 逻辑存储结构</h2><ol>
<li>库（database）<ol>
<li>库名</li>
<li>库属性（字符集，校对集(排序规则)）</li>
</ol>
</li>
<li>表（table）<ol>
<li>表名</li>
<li>表属性（存储引擎，字符集，校对集(排序规则)）</li>
</ol>
</li>
<li>列（column）/ 字段（field） <ol>
<li>列名</li>
<li>列属性（数据类型，约束，…）</li>
</ol>
</li>
<li>行（row）/ 记录（record）</li>
</ol>
<h2 id="4-4-MySQL-物理存储结构"><a href="#4-4-MySQL-物理存储结构" class="headerlink" title="4.4 MySQL 物理存储结构"></a>4.4 MySQL 物理存储结构</h2><ol>
<li>库（目录）</li>
<li>表<ol>
<li><code>MyISAM</code><ul>
<li><code>.frm</code> ：存储表结构（列名，列属性）</li>
<li><code>.MYD</code> ：存储数据记录</li>
<li><code>.MYI</code> ：存储索引</li>
</ul>
</li>
<li><code>InnoDB</code><ul>
<li><code>.frm</code> ：存储表结构（列名，列属性）</li>
<li><code>.ibd</code> ：存储数据记录和索引</li>
<li><code>.opt</code> ：存储库属性</li>
<li><code>ibdata1</code> ：数据字段信息</li>
</ul>
</li>
</ol>
</li>
<li>InnoDB，一般情况下（非分区表）<ol>
<li>段：一个表就是一个段，一个段由多个区构成</li>
<li>区：一个区由64个连续的页构造，1M 大小（ <code>64*16=1024</code> ）</li>
<li>页：一个页大小为 16 kb</li>
</ol>
</li>
</ol>
<h1 id="五-用户-amp-权限"><a href="#五-用户-amp-权限" class="headerlink" title="五 用户 &amp; 权限"></a>五 用户 &amp; 权限</h1><h2 id="5-1-用户"><a href="#5-1-用户" class="headerlink" title="5.1 用户"></a>5.1 用户</h2><h3 id="1-用户定义"><a href="#1-用户定义" class="headerlink" title="1 用户定义"></a>1 用户定义</h3><ul>
<li><code>user@&#39;Host&#39;</code><ul>
<li><code>Host</code>：白名单，即此用户可以在哪个主机连接数据库</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Host（例）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>localhost</code></td>
<td>本地</td>
</tr>
<tr>
<td><code>127.0.0.1</code></td>
<td>本地</td>
</tr>
<tr>
<td><code>%</code></td>
<td>任意网段</td>
</tr>
<tr>
<td><code>10.0.0.%</code></td>
<td><code>10.0.0.0~10.0.0.255</code></td>
</tr>
<tr>
<td><code>10.0.0.5%</code></td>
<td><code>10.0.0.50~10.0.0.59</code></td>
</tr>
<tr>
<td><code>10.0.0.0/255.255.255.0</code></td>
<td><code>10.0.0.0~10.0.0.255</code></td>
</tr>
</tbody></table>
<h3 id="2-用户管理"><a href="#2-用户管理" class="headerlink" title="2 用户管理"></a>2 用户管理</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>select user,host,authentication_string from mysql.user</code></td>
<td>查询用户名，主机，密码（用户信息存储在数据库 <code>mysql</code> 中 的 <code>user</code> 表）</td>
</tr>
<tr>
<td><code>create user user@&#39;Host&#39; [identified by &#39;password&#39;]</code></td>
<td>创建用户</td>
</tr>
<tr>
<td><code>drop user user@&#39;Host&#39;</code></td>
<td>删除用户</td>
</tr>
</tbody></table>
<h3 id="3-修改用户密码"><a href="#3-修改用户密码" class="headerlink" title="3 修改用户密码"></a>3 修改用户密码</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>mysqladmin -u用户名 -p[旧密码] password 新密码</code></td>
<td>不需登录</td>
</tr>
<tr>
<td><code>alter user &#39;用户名&#39; @&#39;localhost&#39; identified by &#39;新密码&#39;</code></td>
<td>需要登录</td>
</tr>
<tr>
<td><code>set password for 用户名 = &#39;新密码&#39;</code></td>
<td>修改指定用户密码</td>
</tr>
<tr>
<td><code>set password = &#39;新密码&#39;</code></td>
<td>修改自己密码</td>
</tr>
</tbody></table>
<ul>
<li>忘记 root 密码<ol>
<li>关闭数据库</li>
<li>维护模式启动数据库<ul>
<li><code>mysqld_safe --skip-grant-tables --skip-networking &amp;</code></li>
</ul>
</li>
<li>登录并修改密码（如果修改密码报错，则刷新权限）<ul>
<li><code>flush privileges</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="5-2-权限"><a href="#5-2-权限" class="headerlink" title="5.2 权限"></a>5.2 权限</h2><h3 id="1-权限列表"><a href="#1-权限列表" class="headerlink" title="1 权限列表"></a>1 权限列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1 基本权限</span><br><span class="line">SELECT，INSERT，UPDATE，DELETE，CREATE，DROP，ALTER，SHOW DATABASES，CREATE USER，CREATE TEMPORARY TABLES，RELOAD，SHUTDOWN，PROCESS，FILE，REFERENCE，INDEX，SUPER，EXECUTE，REPLICATION，SLAVE，REPLICATION，CLIENT，EVENT，TRIGGER，LOCK TABLES，CREATE VIEW，SHOW VIEW，CREATE ROUTINE，ALTER ROUTINE，CREATE TABLESPACE，</span><br><span class="line"></span><br><span class="line">// 2 特殊权限</span><br><span class="line">// 2.1 所有权限</span><br><span class="line">ALL privileges</span><br><span class="line"></span><br><span class="line">// 2.2 可以给别的用户授权的权限，超级管理员才具备</span><br><span class="line">with grant option</span><br></pre></td></tr></table></figure>

<h3 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2 权限管理"></a>2 权限管理</h3><h4 id="1-查看权限"><a href="#1-查看权限" class="headerlink" title="1 查看权限"></a>1 查看权限</h4><ul>
<li><code>show grants [for user@&#39;Host&#39;]</code><ul>
<li>查看自己（或指定用户）的权限</li>
</ul>
</li>
</ul>
<h4 id="2-授权"><a href="#2-授权" class="headerlink" title="2 授权"></a>2 授权</h4><ul>
<li><code>grant 权限 on 目标 to 用户 [identified by &#39;password&#39;] [with grant option]</code><ul>
<li>权限<ol>
<li><code>ALL privileges</code></li>
<li>权限列表，以逗号分隔</li>
</ol>
</li>
<li>目标<ol>
<li><code>*.*</code><ul>
<li>所有数据库的所有表</li>
</ul>
</li>
<li><code>database.*</code><ul>
<li>指定数据库的所有表</li>
</ul>
</li>
<li><code>database.table</code><ul>
<li>指定数据库的指定表</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="3-回收权限"><a href="#3-回收权限" class="headerlink" title="3 回收权限"></a>3 回收权限</h4><ul>
<li><code>revoke 权限 on 目标 from user@&#39;Host&#39;</code></li>
</ul>
<h1 id="六-MySQL-内置命令"><a href="#六-MySQL-内置命令" class="headerlink" title="六 MySQL 内置命令"></a>六 MySQL 内置命令</h1><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>help</code></td>
<td>打印帮助</td>
</tr>
<tr>
<td><code>\c</code></td>
<td>放弃本条语句，类似 <code>ctrl + c</code></td>
</tr>
<tr>
<td><code>quit</code> <code>exit</code> <code>ctrl+d</code> <code>\q</code></td>
<td>退出</td>
</tr>
<tr>
<td><code>\G</code></td>
<td>竖形显示数据</td>
</tr>
<tr>
<td><code>source 脚本路径</code></td>
<td>导入SQL脚本</td>
</tr>
<tr>
<td><code>tee 路径</code></td>
<td>将输入的sql语句存储到本地</td>
</tr>
<tr>
<td><code>prompt 提示符</code></td>
<td>定义 mysql 提示符，默认为 <code>mysql&gt;</code></td>
</tr>
<tr>
<td><code>delimiter 符号</code></td>
<td>定义结束符，默认为<code>;</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CS</category>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title>jQuery</title>
    <url>/anyeansan.github.io/2020/11/08/UI/jQuery/</url>
    <content><![CDATA[<h1 id="一-jQuery-概述"><a href="#一-jQuery-概述" class="headerlink" title="一 jQuery 概述"></a>一 jQuery 概述</h1><h2 id="1-1-jQuery-中的顶级对象"><a href="#1-1-jQuery-中的顶级对象" class="headerlink" title="1.1  jQuery 中的顶级对象 $"></a>1.1  jQuery 中的顶级对象 <code>$</code></h2><ol>
<li><code>$</code> 是 <code>jQuery</code> 的别称，在代码中可以使用 <code>jQuery</code> 代替</li>
<li><code>$</code> 是 jQuery 的顶级对象，相当于原生 JavaScript 中的 <code>window</code></li>
</ol>
<h2 id="1-2-jQuery-对象和-DOM-对象"><a href="#1-2-jQuery-对象和-DOM-对象" class="headerlink" title="1.2 jQuery 对象和 DOM 对象"></a>1.2 jQuery 对象和 DOM 对象</h2><ol>
<li>用原生 JS 获取的是 DOM 对象</li>
<li>jQuery 方法获取的是 jQuery 对象，本质是利用 <code>$</code> 对 DOM 对象包装后产生的对象，是一个类数组</li>
<li>隐式迭代：对 jQuery 对象执行操作时，会给内部所有 DOM 元素进行操作</li>
</ol>
<table>
<thead>
<tr>
<th>转换</th>
<th>方式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DOM → jQuery</strong></td>
<td><code>jQuery = $(DOM)</code></td>
</tr>
<tr>
<td><strong>jQuery → DOM</strong></td>
<td><code>DOM = jQuery[0]</code><br><code>DOM = jQuery.get(0)</code></td>
</tr>
</tbody></table>
<h2 id="1-3"><a href="#1-3" class="headerlink" title="1.3 $()"></a>1.3 <code>$()</code></h2><table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>$()</code></td>
<td>页面 DOM 加载事件，相当于原生 js 中的 <code>DOMContentLoaded</code> 事件</td>
</tr>
<tr>
<td><code>$(DOM)</code></td>
<td>将 DOM 对象转为 jQuery 对象</td>
</tr>
<tr>
<td><code>$(selector)</code></td>
<td>使用选择器获取 jQeury 对象</td>
</tr>
<tr>
<td><code>$(Html)</code></td>
<td>新建一个指定 Html 标签的 jQury 对象</td>
</tr>
</tbody></table>
<h1 id="二-选择器"><a href="#二-选择器" class="headerlink" title="二 选择器"></a>二 选择器</h1><h2 id="2-1-基础选择器"><a href="#2-1-基础选择器" class="headerlink" title="2.1 基础选择器"></a>2.1 基础选择器</h2><table>
<thead>
<tr>
<th>选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>通配选择器</td>
</tr>
<tr>
<td><code>#id</code></td>
<td>ID 选择器</td>
</tr>
<tr>
<td><code>.class</code></td>
<td>类选择器</td>
</tr>
<tr>
<td><code>html</code></td>
<td>标签选择器</td>
</tr>
<tr>
<td><code>s1,s2,...</code></td>
<td>并集</td>
</tr>
<tr>
<td><code>s1.s2</code></td>
<td>交集</td>
</tr>
</tbody></table>
<h2 id="2-2-层级选择器"><a href="#2-2-层级选择器" class="headerlink" title="2.2 层级选择器"></a>2.2 层级选择器</h2><table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>A E</code></td>
<td>后代元素</td>
</tr>
<tr>
<td><code>A &gt; E</code></td>
<td>子元素</td>
</tr>
<tr>
<td><code>A ~ E</code></td>
<td>兄弟元素</td>
</tr>
<tr>
<td><code>A + E</code></td>
<td>下一个兄弟元素</td>
</tr>
</tbody></table>
<h2 id="2-3-属性选择器"><a href="#2-3-属性选择器" class="headerlink" title="2.3 属性选择器"></a>2.3 属性选择器</h2><table>
<thead>
<tr>
<th>属性选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>[attr]</code></td>
<td>带有 <code>attr</code> 属性的元素</td>
</tr>
<tr>
<td><code>[attr=value]</code></td>
<td><code>attr</code> 属性值为 <code>value</code> 的元素</td>
</tr>
<tr>
<td><code>[attr!=value]</code></td>
<td><code>attr</code> 属性值不为 <code>value</code> 的元素</td>
</tr>
<tr>
<td><code>[attr^=value]</code></td>
<td><code>attr</code> 属性值以 <code>value</code> 开头的元素</td>
</tr>
<tr>
<td><code>[attr$=value]</code></td>
<td><code>attr</code> 属性值以 <code>value</code> 结尾的元素</td>
</tr>
<tr>
<td><code>[attr*=value]</code></td>
<td><code>attr</code> 属性值包含 <code>value</code> 的元素</td>
</tr>
<tr>
<td><code>[s1][s2][sN]</code></td>
<td>相当于 <code>&amp;&amp;</code></td>
</tr>
</tbody></table>
<h2 id="2-4-过滤选择器"><a href="#2-4-过滤选择器" class="headerlink" title="2.4 过滤选择器"></a>2.4 过滤选择器</h2><table>
<thead>
<tr>
<th>过滤选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>:first</code></td>
<td>第一个</td>
</tr>
<tr>
<td><code>:last</code></td>
<td>最后一个</td>
</tr>
<tr>
<td><code>:not(s)</code></td>
<td>非</td>
</tr>
<tr>
<td><code>:odd</code></td>
<td>奇数索引</td>
</tr>
<tr>
<td><code>:even</code></td>
<td>偶数索引</td>
</tr>
<tr>
<td><code>:eq(index)</code></td>
<td>等于索引</td>
</tr>
<tr>
<td><code>:gt(index)</code></td>
<td>大于索引</td>
</tr>
<tr>
<td><code>:lt(index)</code></td>
<td>小于索引</td>
</tr>
</tbody></table>
<h2 id="2-5-子元素选择器"><a href="#2-5-子元素选择器" class="headerlink" title="2.5 子元素选择器"></a>2.5 子元素选择器</h2><table>
<thead>
<tr>
<th>子元素选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>:first-child</code></td>
<td>第一个子元素</td>
</tr>
<tr>
<td><code>:last-child</code></td>
<td>最后一个子元素</td>
</tr>
<tr>
<td><code>:only-child</code></td>
<td>唯一的子元素</td>
</tr>
<tr>
<td><code>:nth-child(expr)</code></td>
<td><code>expr</code> 可以是 <code>an+b, odd, even</code></td>
</tr>
</tbody></table>
<h2 id="2-6-内容选择器"><a href="#2-6-内容选择器" class="headerlink" title="2.6 内容选择器"></a>2.6 内容选择器</h2><table>
<thead>
<tr>
<th>内容选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>:empty</code></td>
<td>不包含子元素或者文本的元素</td>
</tr>
<tr>
<td><code>:contains(text)</code></td>
<td>包含指定文本的元素</td>
</tr>
<tr>
<td><code>:has(selector)</code></td>
<td>包含选择器所匹配元素的元素</td>
</tr>
<tr>
<td><code>:parent</code></td>
<td>含有子元素或者文本的元素</td>
</tr>
</tbody></table>
<h2 id="2-7-可见性选择器"><a href="#2-7-可见性选择器" class="headerlink" title="2.7 可见性选择器"></a>2.7 可见性选择器</h2><table>
<thead>
<tr>
<th>可见性选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>:hidden</code></td>
<td>所有不可见元素，<code>display:none, type=hidden ...</code></td>
</tr>
<tr>
<td><code>:visible</code></td>
<td>所有可见元素</td>
</tr>
</tbody></table>
<h2 id="2-8-表单选择器"><a href="#2-8-表单选择器" class="headerlink" title="2.8 表单选择器"></a>2.8 表单选择器</h2><table>
<thead>
<tr>
<th>表单选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>:input</code></td>
<td>匹配所有 <code>input textarea select button</code> 元素</td>
</tr>
<tr>
<td><code>:Type</code></td>
<td>匹配 <code>input</code> 指定类型的元素，如 <code>:text :radio ...</code></td>
</tr>
</tbody></table>
<h2 id="2-9-表单属性选择器"><a href="#2-9-表单属性选择器" class="headerlink" title="2.9 表单属性选择器"></a>2.9 表单属性选择器</h2><table>
<thead>
<tr>
<th>表单属性选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>:enabled</code></td>
<td>所有可用元素</td>
</tr>
<tr>
<td><code>:disabled</code></td>
<td>所有不可用元素</td>
</tr>
<tr>
<td><code>:checked</code></td>
<td>单/复选框的所有选中元素</td>
</tr>
<tr>
<td><code>:selected</code></td>
<td>下拉框所有选中的 <code>option</code> 元素</td>
</tr>
</tbody></table>
<h2 id="2-10-筛选方法"><a href="#2-10-筛选方法" class="headerlink" title="2.10 筛选方法"></a>2.10 筛选方法</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>选择器能完成的，筛选提供相同方法也能完成</li>
<li>区别在于选择器直接获取筛选后的结果，方法先获取原结果，然后再筛选<ol>
<li><code>$(&quot;div:first&quot;)</code>：直接获取第一个 <code>div</code></li>
<li><code>$(&quot;div&quot;).first()</code>：先获取所有 <code>div</code>，之后筛选出第一个</li>
</ol>
</li>
</ol>
<h3 id="2-查找"><a href="#2-查找" class="headerlink" title="2 查找"></a>2 查找</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>parent()</code></td>
<td>父元素</td>
</tr>
<tr>
<td>childre([selector])</td>
<td>所有匹配子元素</td>
</tr>
<tr>
<td><code>find(selector)</code></td>
<td>查找匹配的元素</td>
</tr>
<tr>
<td><code>siblings([selector])</code></td>
<td>所有兄弟元素</td>
</tr>
<tr>
<td><code>next([selector])</code></td>
<td>下一个兄弟元素</td>
</tr>
<tr>
<td><code>nextAll([selector])</code></td>
<td>之后的所有兄弟元素</td>
</tr>
<tr>
<td><code>prev([selector])</code></td>
<td>上一个兄弟元素</td>
</tr>
<tr>
<td><code>prevAll([selector])</code></td>
<td>之前的所有兄弟元素</td>
</tr>
</tbody></table>
<h3 id="3-过滤"><a href="#3-过滤" class="headerlink" title="3 过滤"></a>3 过滤</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>eq(index)</code></td>
<td>获取指定索引元素</td>
</tr>
<tr>
<td><code>first()</code></td>
<td>第一个</td>
</tr>
<tr>
<td><code>last()</code></td>
<td>最后一个</td>
</tr>
<tr>
<td><code>filter(expr)</code></td>
<td>获取匹配的元素</td>
</tr>
</tbody></table>
<h1 id="三-文档处理"><a href="#三-文档处理" class="headerlink" title="三 文档处理"></a>三 文档处理</h1><h2 id="3-1-元素遍历"><a href="#3-1-元素遍历" class="headerlink" title="3,1 元素遍历"></a>3,1 元素遍历</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>$(Selector).each(callback)</code></td>
<td>遍历 jQuery 对象</td>
</tr>
<tr>
<td><code>$.each(obj, callback)</code></td>
<td>遍历任意对象</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">callback:</span><br><span class="line">function(index, domEle) &#123;</span><br><span class="line">	index：元素的索引</span><br><span class="line">	domEle：遍历的元素，相当于 this，是 DOM 对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-添删改"><a href="#3-2-添删改" class="headerlink" title="3.2 添删改"></a>3.2 添删改</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>append(ele)</code></td>
<td>追加到元素内尾部，父子关系</td>
</tr>
<tr>
<td><code>prepend(ele)</code></td>
<td>追加到元素内首部，父子关系</td>
</tr>
<tr>
<td><code>after(ele)</code></td>
<td>添加到元素后面，兄弟关系</td>
</tr>
<tr>
<td><code>before(ele)</code></td>
<td>添加到元素前面，兄弟关系</td>
</tr>
<tr>
<td><code>remove()</code></td>
<td>删除自已及后代节点，移除绑定事件和绑定数据</td>
</tr>
<tr>
<td><code>detach()</code></td>
<td>删除自已及后代节点，保留绑定事件和绑定数据</td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>删除所有后代节点</td>
</tr>
<tr>
<td><code>replaceWith(content)</code></td>
<td>将所有匹配的元素替换成指定的 HTML 或 DOM 元素</td>
</tr>
<tr>
<td><code>replaceAll(selector)</code></td>
<td>替换所有匹配的元素</td>
</tr>
</tbody></table>
<h2 id="3-3-复制"><a href="#3-3-复制" class="headerlink" title="3.3 复制"></a>3.3 复制</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>clone()</code></td>
<td>只复制样式，不复制行为</td>
</tr>
<tr>
<td><code>clone(true)</code></td>
<td>既复制样式，又复制行为</td>
</tr>
</tbody></table>
<h1 id="四-文本"><a href="#四-文本" class="headerlink" title="四 文本"></a>四 文本</h1><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>html([value])</code></td>
<td>获取或设置元素内容，对应 <code>innerHTML</code></td>
</tr>
<tr>
<td><code>text([value])</code></td>
<td>获取或设置元素内容，对应 <code>innerText</code></td>
</tr>
<tr>
<td><code>val([value])</code></td>
<td>获取或设置元素 <code>value</code> 属性的值</td>
</tr>
</tbody></table>
<h1 id="五-数据缓存"><a href="#五-数据缓存" class="headerlink" title="五 数据缓存"></a>五 数据缓存</h1><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>data(key)</code></td>
<td>获取绑定数据</td>
</tr>
<tr>
<td><code>data(key,value)</code></td>
<td>绑定数据，页面刷新移除</td>
</tr>
<tr>
<td><code>removeData(key)</code></td>
<td>移除绑定数据</td>
</tr>
</tbody></table>
<h1 id="六-属性"><a href="#六-属性" class="headerlink" title="六 属性"></a>六 属性</h1><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>attr(key)</code></td>
<td>获取属性的值（自定义属性和标准属性）</td>
</tr>
<tr>
<td><code>attr(key,value)</code></td>
<td>设置属性的值</td>
</tr>
<tr>
<td><code>removeAttr(key)</code></td>
<td>删除属性</td>
</tr>
<tr>
<td><code>prop(key)</code></td>
<td>获取属性的值（Html 标准属性）</td>
</tr>
<tr>
<td><code>prop(key,value)</code></td>
<td>设置属性的值</td>
</tr>
<tr>
<td><code>removeProp(key)</code></td>
<td>删除属性</td>
</tr>
</tbody></table>
<h1 id="七-CSS"><a href="#七-CSS" class="headerlink" title="七 CSS"></a>七 CSS</h1><h2 id="7-1-样式"><a href="#7-1-样式" class="headerlink" title="7.1 样式"></a>7.1 样式</h2><table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>css(key, value)</code></td>
<td>添加属性和值</td>
</tr>
<tr>
<td>css({key:value, key:value, …})</td>
<td>以对象形式添加多组属性和值</td>
</tr>
<tr>
<td><code>addClass(class)</code></td>
<td>添加类</td>
</tr>
<tr>
<td><code>removeClass(class)</code></td>
<td>删除类</td>
</tr>
<tr>
<td><code>toggleClass(class)</code></td>
<td>切换，有类则删除，无类则添加</td>
</tr>
<tr>
<td><code>hasClass(class)</code></td>
<td>判断是否有指定类</td>
</tr>
</tbody></table>
<h2 id="7-2-位置"><a href="#7-2-位置" class="headerlink" title="7.2 位置"></a>7.2 位置</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>offset()</code></td>
<td>获取元素相对于文档的偏移，返回 JSON 对象，有两个属性 <code>top left</code></td>
</tr>
<tr>
<td><code>offset({top:value, left:value})</code></td>
<td>设置元素相对于文档的偏移</td>
</tr>
<tr>
<td><code>position()</code></td>
<td>获取元素相对于有定位祖先元素的偏移，没有则相对于文档偏移，返回 JSON 对象：<code>top left</code></td>
</tr>
<tr>
<td><code>scrollTop([value])</code></td>
<td>获取或设置元素上边被卷去的距离</td>
</tr>
<tr>
<td><code>scrollLeft([value])</code></td>
<td>获取或设置元素左边被卷去的距离</td>
</tr>
</tbody></table>
<h2 id="7-3-尺寸"><a href="#7-3-尺寸" class="headerlink" title="7.3 尺寸"></a>7.3 尺寸</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>width([value])</code></td>
<td>获取或设置元素宽度，<code>content-box</code></td>
</tr>
<tr>
<td><code>height([value])</code></td>
<td>获取或设置元素高度，<code>content-box</code></td>
</tr>
<tr>
<td><code>innerWidth()</code></td>
<td>获取 <code>padding-box</code> 宽度</td>
</tr>
<tr>
<td><code>innerHeight()</code></td>
<td>获取 <code>padding-box</code> 高度</td>
</tr>
<tr>
<td><code>outerWidth()</code></td>
<td>获取 <code>border-box</code> 宽度</td>
</tr>
<tr>
<td><code>outerHeight()</code></td>
<td>获取 <code>border-box</code> 高度</td>
</tr>
<tr>
<td><code>outerWidth(true)</code></td>
<td>获取 <code>margin-box</code> 宽度</td>
</tr>
<tr>
<td><code>outerHeight(true)</code></td>
<td>获取 <code>margin-box</code> 高度</td>
</tr>
</tbody></table>
<h1 id="八-效果"><a href="#八-效果" class="headerlink" title="八 效果"></a>八 效果</h1><h2 id="8-1-显示隐藏"><a href="#8-1-显示隐藏" class="headerlink" title="8.1 显示隐藏"></a>8.1 显示隐藏</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>show([speed], [easing], [callback])</code></td>
<td>显示元素</td>
</tr>
<tr>
<td><code>hide([speed], [easing], [callback])</code></td>
<td>隐藏元素</td>
</tr>
</tbody></table>
<ol>
<li><code>speed</code><ol>
<li><code>slow normal fast</code></li>
<li>毫秒值</li>
</ol>
</li>
<li><code>easing</code><ol>
<li><code>swing</code> ：默认，慢 → 快 → 慢</li>
<li><code>linear</code>：匀速</li>
</ol>
</li>
</ol>
<h2 id="8-2-滑动"><a href="#8-2-滑动" class="headerlink" title="8.2 滑动"></a>8.2 滑动</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>slideDown([speed], [easing], [callback])</code></td>
<td>向下滑动</td>
</tr>
<tr>
<td><code>slideUp([speed], [easing], [callback])</code></td>
<td>向上滑动</td>
</tr>
<tr>
<td><code>slideToggle([speed], [easing], [callback])</code></td>
<td>滑动切换</td>
</tr>
</tbody></table>
<h2 id="8-3-淡入淡出"><a href="#8-3-淡入淡出" class="headerlink" title="8.3 淡入淡出"></a>8.3 淡入淡出</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>fadeIn([speed], [easing], [callback])</code></td>
<td>淡入显示</td>
</tr>
<tr>
<td><code>fadeOut([speed], [easing], [callback])</code></td>
<td>淡出隐藏</td>
</tr>
<tr>
<td><code>fadeToggle([speed], [easing], [callback])</code></td>
<td>淡入淡出切换</td>
</tr>
<tr>
<td><code>fadeTo([speed], opacity, [easing], [callback])</code></td>
<td>调整到指定透明度，<code>opacity</code>：0~1，必须</td>
</tr>
</tbody></table>
<h2 id="8-4-自定义动画"><a href="#8-4-自定义动画" class="headerlink" title="8.4 自定义动画"></a>8.4 自定义动画</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>animate(params, [speed], [easing], [callback])</code></td>
<td>创建动画，<code>params</code>：对象形式的样式属性和值</td>
</tr>
<tr>
<td><code>stop([clearQueue], [gotoEnd])</code></td>
<td>停止所有在指定元素上正在运行的动画</td>
</tr>
<tr>
<td><code>delay(duration, [queueName])</code></td>
<td>动画延迟时间</td>
</tr>
</tbody></table>
<h1 id="九-事件"><a href="#九-事件" class="headerlink" title="九 事件"></a>九 事件</h1><h2 id="9-1-页面加载"><a href="#9-1-页面加载" class="headerlink" title="9.1 页面加载"></a>9.1 页面加载</h2><table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>$(document).ready(fn)</code></td>
<td>标准 API，相当于原生 js 中的 <code>DOMContentLoaded</code> 事件</td>
</tr>
<tr>
<td><code>$(fn)</code></td>
<td>简化版</td>
</tr>
</tbody></table>
<h2 id="9-2-事件绑定"><a href="#9-2-事件绑定" class="headerlink" title="9.2 事件绑定"></a>9.2 事件绑定</h2><h3 id="1-普通方式"><a href="#1-普通方式" class="headerlink" title="1 普通方式"></a>1 普通方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(selector).type(fn);</span><br></pre></td></tr></table></figure>

<h3 id="2-on"><a href="#2-on" class="headerlink" title="2 on"></a>2 on</h3><ol>
<li><p>一个事件对应一个处理函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(selector).on(</span><br><span class="line">    &#123;</span><br><span class="line">		type: fn,</span><br><span class="line">		type: fn,</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>多个事件对应一个处理函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(selector).on(&quot;type type type ...&quot;, fn);</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件委托</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(selector).on(types, childSelector, fn);</span><br><span class="line">// 事件绑定在父元素上，但由子元素触发</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="3-off"><a href="#3-off" class="headerlink" title="3 off"></a>3 off</h3><ol>
<li><p>解绑元素所有事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(selector).off()</span><br></pre></td></tr></table></figure>
</li>
<li><p>解绑元素指定事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(selector).off(type)</span><br></pre></td></tr></table></figure>
</li>
<li><p>解绑委托事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(selector).off(type, childSelector)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="9-3-事件处理"><a href="#9-3-事件处理" class="headerlink" title="9.3 事件处理"></a>9.3 事件处理</h2><table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>$(selector).hover(over, [out])</code></td>
<td><code>mouseenter</code> 触发第一个函数，<code>mouseleave</code> 触发第二个函数，如果只有一个函数，则都触发它</td>
</tr>
<tr>
<td><code>$(selector).trigger(type)</code></td>
<td>自动触发指定事件</td>
</tr>
<tr>
<td><code>$(selector).triggerHandler(type)</code></td>
<td>自动触发指定事件，不会触发元素默认行为</td>
</tr>
</tbody></table>
<h1 id="十-工具"><a href="#十-工具" class="headerlink" title="十 工具"></a>十 工具</h1><h2 id="10-1-拷贝对象"><a href="#10-1-拷贝对象" class="headerlink" title="10.1 拷贝对象"></a>10.1 拷贝对象</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$.extend([deep], target, srcObj1, srcOjb2, ...)</span><br></pre></td></tr></table></figure>

<h2 id="10-2-字符串去空格"><a href="#10-2-字符串去空格" class="headerlink" title="10.2 字符串去空格"></a>10.2 字符串去空格</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$.trim(str)</span><br></pre></td></tr></table></figure>

<h2 id="10-3-多库共存"><a href="#10-3-多库共存" class="headerlink" title="10.3 多库共存"></a>10.3 多库共存</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 修改 $ 为自定义变量</span><br><span class="line">let newSymbol = $.noConflict()</span><br></pre></td></tr></table></figure>

<h1 id="十一-AJAX"><a href="#十一-AJAX" class="headerlink" title="十一 AJAX"></a>十一 AJAX</h1><h2 id="11-1-Ajax-请求"><a href="#11-1-Ajax-请求" class="headerlink" title="11.1 Ajax 请求"></a>11.1 Ajax 请求</h2><h3 id="1-ajax"><a href="#1-ajax" class="headerlink" title="1 $.ajax()"></a>1 <code>$.ajax()</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">	url: &quot;&quot;,</span><br><span class="line">	type: &quot;&quot;,</span><br><span class="line">	data: &quot;&quot;,</span><br><span class="line">	async: true,</span><br><span class="line">	dataType: &quot;&quot;,</span><br><span class="line">	contentType: &quot;&quot;,</span><br><span class="line">	beforeSend: function(XHR) &#123;</span><br><span class="line">		XHR：XMLHttpRequest 对象</span><br><span class="line">	&#125;,</span><br><span class="line">	success: function(data,textStatus,XHR)&#123;</span><br><span class="line">		data：响应数据</span><br><span class="line">		textStatus：描述状态的字符串</span><br><span class="line">	&#125;,</span><br><span class="line">	error: function(XHR,textStatus,errorThrown)&#123;</span><br><span class="line">		textStatus：错误信息</span><br><span class="line">		errorThrown：异常对象</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>type</code></td>
<td>请求方式，默认 <code>GET</code></td>
</tr>
<tr>
<td><code>url</code></td>
<td>请求地址</td>
</tr>
<tr>
<td><code>data</code></td>
<td>请求参数，<code>key=value&amp;key=value</code> 字符串或者 JSON</td>
</tr>
<tr>
<td><code>dataType</code></td>
<td>响应数据类型，<code>xml html json text script jsonp ...</code></td>
</tr>
<tr>
<td><code>async</code></td>
<td>是否异步，默认 <code>true</code></td>
</tr>
<tr>
<td><code>contentType</code></td>
<td>请求参数编码类型，默认 <code>application/x-www-form-urlencoded</code></td>
</tr>
<tr>
<td><code>beforeSend</code></td>
<td>发送请求前修改 <code>XMLHttpRequest</code> 对象的函数</td>
</tr>
<tr>
<td><code>success</code></td>
<td>请求成功后的回调函数</td>
</tr>
<tr>
<td><code>error</code></td>
<td>请求失败时调用此函数</td>
</tr>
</tbody></table>
<h3 id="2-get"><a href="#2-get" class="headerlink" title="2 $.get()"></a>2 <code>$.get()</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$.get(url, [data], [callback], [dataType])</span><br></pre></td></tr></table></figure>

<h3 id="3-post"><a href="#3-post" class="headerlink" title="3 $.post()"></a>3 <code>$.post()</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$.get(post, [data], [callback], [dataType])</span><br></pre></td></tr></table></figure>

<h2 id="11-2-表单序列化"><a href="#11-2-表单序列化" class="headerlink" title="11.2 表单序列化"></a>11.2 表单序列化</h2><h3 id="1-serialize"><a href="#1-serialize" class="headerlink" title="1 serialize()"></a>1 <code>serialize()</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;form&quot;).serialize()</span><br></pre></td></tr></table></figure>

<ol>
<li>必须使用 <code>&lt;form&gt;</code> 元素</li>
<li>表单项必须有 <code>name</code> 属性</li>
<li>将表单中所有项拼凑成一个字符串，格式为 <code>key=value&amp;key=value</code></li>
</ol>
<h3 id="2-serializeArray"><a href="#2-serializeArray" class="headerlink" title="2 serializeArray()"></a>2 <code>serializeArray()</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;form&quot;).serializeArray()</span><br></pre></td></tr></table></figure>

<ol>
<li>必须使用 <code>&lt;form&gt;</code> 元素</li>
<li>表单项必须有 <code>name</code> 属性</li>
<li>将表单中所有项拼凑成一个 <code>json</code> 数组，格式 <code>[{key:value}, {key:value}]</code></li>
</ol>
<h2 id="11-3-Ajax-事件"><a href="#11-3-Ajax-事件" class="headerlink" title="11.3 Ajax 事件"></a>11.3 Ajax 事件</h2><table>
<thead>
<tr>
<th>事件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ajaxStart</code></td>
<td>AJAX 请求开始时触发</td>
</tr>
<tr>
<td><code>ajaxComplete</code></td>
<td>AJAX 请求完成时触发</td>
</tr>
<tr>
<td><code>ajaxSuccess</code></td>
<td>AJAX 请求成功时触发</td>
</tr>
<tr>
<td><code>ajaxError</code></td>
<td>AJAX 请求失败时触发</td>
</tr>
</tbody></table>
<h2 id="11-4-跨域"><a href="#11-4-跨域" class="headerlink" title="11.4 跨域"></a>11.4 跨域</h2><ol>
<li><code>$.getJSON()</code></li>
<li><code>$.getScript()</code></li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>AJAX</title>
    <url>/anyeansan.github.io/2020/11/08/UI/AJAX/</url>
    <content><![CDATA[<h1 id="一-AJAX-概述"><a href="#一-AJAX-概述" class="headerlink" title="一 AJAX 概述"></a>一 AJAX 概述</h1><ol>
<li><code>Asynchronous JavaScript And XML</code><ul>
<li>AJAX 不是一个技术，是多个技术联合实现的产物，且无论服务端编程语言是哪一种都可以，AJAX 只负责发送请求和接收响应</li>
<li>异步提交下 <code>form</code> 标签的 <code>action</code> 和 <code>method</code> 没有意义</li>
<li>服务端不能使用转发或重定向，因为会让浏览器全面刷新，只能以流的方式响应给浏览器</li>
</ul>
</li>
<li>一个页面可以同时发送多个 AJAX 请求</li>
<li>传统的网页（不使用 AJAX）都是同步的，如果需要更新内容，必需重载整个网页面<ul>
<li><code>客户端 → 请求 → 服务端</code></li>
<li><code>服务端 → 响应 → 客户端</code></li>
</ul>
</li>
<li>Ajax：可以使网页实现异步更新，即在不重新加载整个网页的情况下，对网页的某部分进行更新<ul>
<li><code>客户端 → 请求 → ajax engine → 服务端</code></li>
<li><code>服务端 → 响应 → ajax engine → 客户端</code></li>
</ul>
</li>
<li>Ajax 应用场景<ol>
<li>页面向下加载更多数据</li>
<li>列表数据无刷新分页</li>
<li>表单项失去焦点验证</li>
<li>输入框的自动补全（下拉提示）</li>
<li>地图</li>
<li>…</li>
</ol>
</li>
</ol>
<h1 id="二-XMLHttpRequest"><a href="#二-XMLHttpRequest" class="headerlink" title="二 XMLHttpRequest"></a>二 <code>XMLHttpRequest</code></h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol>
<li>异步通讯对象</li>
<li>老版本的 IE 中是 <code>ActiveXObject</code></li>
</ol>
<h2 id="2-2-构造"><a href="#2-2-构造" class="headerlink" title="2.2 构造"></a>2.2 构造</h2><table>
<thead>
<tr>
<th>构造函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>XMLHttpRequest()</code></td>
<td>创建 <code>XMLHttpRequest</code> 对象</td>
</tr>
</tbody></table>
<h2 id="2-3-属性"><a href="#2-3-属性" class="headerlink" title="2.3 属性"></a>2.3 属性</h2><table>
<thead>
<tr>
<th>属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>readyState</code></td>
<td>只读</td>
<td><code>XMLHttpRequest</code> 状态码（<code>0-4</code>）</td>
</tr>
<tr>
<td><code>status</code></td>
<td>只读</td>
<td>响应状态码（<code>200 302 404 500 ...</code>）</td>
</tr>
<tr>
<td><code>responseType</code></td>
<td>读写</td>
<td>在<code>open()</code>之后<code>send()</code>之前设置，告诉服务器返回指定类型的数据，默认 <code>text</code></td>
</tr>
<tr>
<td><code>responseText</code></td>
<td>只读</td>
<td>字符串形式的响应数据</td>
</tr>
<tr>
<td><code>responseXML</code></td>
<td>只读</td>
<td>XML 形式的响应数据</td>
</tr>
<tr>
<td><code>withCredentials</code></td>
<td>读写</td>
<td>跨域请求是否携带 <code>cookie</code>，默认 <code>false</code></td>
</tr>
</tbody></table>
<h3 id="1-readyState"><a href="#1-readyState" class="headerlink" title="1 readyState"></a>1 readyState</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>0</code></td>
<td><code>unsent</code></td>
<td>请求未初始化</td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>opened</code></td>
<td>服务器连接已建立</td>
</tr>
<tr>
<td><code>2</code></td>
<td><code>headers_received</code></td>
<td>请求已接收</td>
</tr>
<tr>
<td><code>3</code></td>
<td><code>loading</code></td>
<td>请求处理中</td>
</tr>
<tr>
<td><code>4</code></td>
<td><code>done</code></td>
<td>请求已完成，且响应已就绪</td>
</tr>
</tbody></table>
<h3 id="2-responseType"><a href="#2-responseType" class="headerlink" title="2 responseType"></a>2 responseType</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&quot;&quot;</code></td>
<td>同 <code>text</code></td>
</tr>
<tr>
<td><code>&quot;text&quot;</code>（默认）</td>
<td>表示服务器返回文本数据</td>
</tr>
<tr>
<td><code>&quot;json&quot;</code></td>
<td>表示服务器返回 JSON 数据</td>
</tr>
<tr>
<td><code>&quot;blob&quot;</code></td>
<td>表示服务器返回二进制对象</td>
</tr>
<tr>
<td><code>&quot;document&quot;</code></td>
<td>表示服务器返回一个文档对象，HTML 或 XML</td>
</tr>
<tr>
<td><code>&quot;arraybuffer&quot;</code></td>
<td>表示服务器返回二进制数组</td>
</tr>
</tbody></table>
<h2 id="2-4-方法"><a href="#2-4-方法" class="headerlink" title="2.4 方法"></a>2.4 方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>open(method, url, [async], [user], [password])</code></td>
<td>初始化一个请求</td>
</tr>
<tr>
<td><code>send([data])</code></td>
<td>发送请求</td>
</tr>
<tr>
<td><code>setRequestHeader(key, value)</code></td>
<td>设置请求头</td>
</tr>
<tr>
<td><code>getResponseHeader(key)</code></td>
<td>获取响应头信息</td>
</tr>
<tr>
<td><code>getAllResponseHeaders()</code></td>
<td>获取一个包含所有响应头信息的字符串</td>
</tr>
<tr>
<td><code>overrideMimeType(mimeType)</code></td>
<td>指定一个MIME类型用于替代服务器指定的类型，必须在 <code>send()</code> 之前调用</td>
</tr>
</tbody></table>
<h3 id="1-open"><a href="#1-open" class="headerlink" title="1 open()"></a>1 <code>open()</code></h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>method</code></td>
<td>请求方法，<code>GET POST PUT DELETE...</code></td>
</tr>
<tr>
<td><code>url</code></td>
<td>请求地址</td>
</tr>
<tr>
<td><code>async</code></td>
<td>是否异步，默认 <code>true</code></td>
</tr>
<tr>
<td><code>user</code></td>
<td>用于认证的用户名，默认为 <code>null</code></td>
</tr>
<tr>
<td><code>password</code></td>
<td>用于认证的密码，默认为 <code>null</code></td>
</tr>
</tbody></table>
<h2 id="2-5-事件及对应属性"><a href="#2-5-事件及对应属性" class="headerlink" title="2.5 事件及对应属性"></a>2.5 事件及对应属性</h2><table>
<thead>
<tr>
<th>事件</th>
<th>说明</th>
<th>对应属性</th>
</tr>
</thead>
<tbody><tr>
<td><code>readyStateChange</code></td>
<td>当 <code>readyState</code> 属性改变时，就会触发此事件</td>
<td><code>onreadystatechange</code></td>
</tr>
<tr>
<td><code>load</code></td>
<td>请求成功完成时触发</td>
<td><code>onload</code></td>
</tr>
<tr>
<td><code>error</code></td>
<td>请求出错时触发</td>
<td><code>onerror</code></td>
</tr>
<tr>
<td><code>abort</code></td>
<td>请求中止时触发</td>
<td><code>onabort</code></td>
</tr>
<tr>
<td><code>loadend</code></td>
<td>请求结束时触发，无论成功失败或中止</td>
<td><code>onloadend</code></td>
</tr>
<tr>
<td><code>timeout</code></td>
<td>请求超时时触发</td>
<td><code>ontimeout</code></td>
</tr>
<tr>
<td><code>loadstart</code></td>
<td>接收到响应数据时触发</td>
<td><code>onloadstart</code></td>
</tr>
<tr>
<td><code>progress</code></td>
<td>接收数据开始周期触发，进度条</td>
<td><code>onprogress</code></td>
</tr>
</tbody></table>
<ul>
<li>事件对应属性指向一个函数，是对应事件触发时的处理函数</li>
</ul>
<h1 id="三-AJAX-使用步骤"><a href="#三-AJAX-使用步骤" class="headerlink" title="三 AJAX 使用步骤"></a>三 AJAX 使用步骤</h1><h2 id="3-1-创建-XMLHttpRequest-对象"><a href="#3-1-创建-XMLHttpRequest-对象" class="headerlink" title="3.1 创建 XMLHttpRequest 对象"></a>3.1 创建 XMLHttpRequest 对象</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ajax;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">	ajax=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	ajax=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ajax;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-初始化请求并发送"><a href="#3-2-初始化请求并发送" class="headerlink" title="3.2 初始化请求并发送"></a>3.2 初始化请求并发送</h2><h3 id="1-GET"><a href="#1-GET" class="headerlink" title="1 GET"></a>1 GET</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 初始化请求</span></span><br><span class="line">ajax.open(<span class="string">"GET"</span>,<span class="string">"url?name=xxx&amp;age=18"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 发送请求</span></span><br><span class="line">ajax.send();</span><br></pre></td></tr></table></figure>

<h3 id="2-POST"><a href="#2-POST" class="headerlink" title="2 POST"></a>2 POST</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 初始化请求</span></span><br><span class="line">ajax.open(<span class="string">"POST"</span>,<span class="string">"url"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 设置请求头并发送请求（POST 请求需要使用表单）</span></span><br><span class="line"><span class="comment">// 2.1 请求参数格式为 application/x-www-form-urlencoded</span></span><br><span class="line">ajax.setRequestHeader(<span class="string">"content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">ajax.send(<span class="string">"name=xxx&amp;age=18"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.2 请求参数格式为  application/json</span></span><br><span class="line">ajax.setRequestHeader(<span class="string">"content-type"</span>,<span class="string">"application/json"</span>);</span><br><span class="line"><span class="comment">// 请求参数必须是字符串，所以需要把 JSON 对象转为字符串</span></span><br><span class="line">ajax.send(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">name</span>:<span class="string">"xxx"</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;));</span><br></pre></td></tr></table></figure>

<h2 id="3-3-注册回调函数接收服务器响应数据"><a href="#3-3-注册回调函数接收服务器响应数据" class="headerlink" title="3.3 注册回调函数接收服务器响应数据"></a>3.3 注册回调函数接收服务器响应数据</h2><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>onload</code>（推荐）</td>
<td>不兼容旧 IE，不需要判断状态码，被调用一次</td>
</tr>
<tr>
<td><code>onreadystatechange</code></td>
<td>兼容旧 IE，需要判断状态码，被调用多次</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 onreadystatechange</span></span><br><span class="line">ajax.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> res=ajax.responseText;</span><br><span class="line">	<span class="keyword">let</span> res=ajax.responseXml;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 onload</span></span><br><span class="line">ajax.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ajax.readyState==<span class="number">4</span> &amp;&amp; ajax.status==<span class="number">200</span>)&#123;</span><br><span class="line">		<span class="keyword">let</span> res=ajax.responseText;</span><br><span class="line">		<span class="keyword">let</span> res=ajax.responseXml;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-低版本-IE-浏览器缓存问题"><a href="#3-4-低版本-IE-浏览器缓存问题" class="headerlink" title="3.4 低版本 IE 浏览器缓存问题"></a>3.4 低版本 IE 浏览器缓存问题</h2><ol>
<li>问题：在请求地址不变的情况下，只有第一次请求真正发送到服务器，后续请求都从浏览器缓存中获取结果，导致拿到的都是旧数据</li>
<li>解决：发送请求时，添加一个每次都不同的请求参数，如时间戳，随机数</li>
</ol>
<h1 id="四-FormData"><a href="#四-FormData" class="headerlink" title="四 FormData"></a>四 FormData</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ol>
<li>将表单数据的键值对组合，实现表单数据的序列化，减少表单元素拼接</li>
<li>可以通过 <code>send(formData)</code> 发送</li>
</ol>
<h2 id="4-2-构造"><a href="#4-2-构造" class="headerlink" title="4.2 构造"></a>4.2 构造</h2><table>
<thead>
<tr>
<th>构造函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>FormData(form)</code></td>
<td>将表单元素构造为 <code>FormData</code> 对象</td>
</tr>
</tbody></table>
<h2 id="4-3-方法"><a href="#4-3-方法" class="headerlink" title="4.3 方法"></a>4.3 方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>get(key)</code></td>
<td>返回 <code>FormData</code> 对象中与给定键关联的第一个值</td>
</tr>
<tr>
<td><code>getAll(key)</code></td>
<td>返回 <code>FormData</code> 对象中与给定键关联的所有值的数组</td>
</tr>
<tr>
<td><code>set(key, value)</code></td>
<td>给 <code>FormData</code> 设置键值对，键不存在则添加，存在则覆盖</td>
</tr>
<tr>
<td><code>append(key, value,[fileName])</code></td>
<td>给 <code>formData</code> 追加键值对，键存在也不会覆盖，如果是文件，可以添加文件名</td>
</tr>
<tr>
<td><code>delete(key)</code></td>
<td>从 <code>FormData</code> 对象里面删除一个键值对</td>
</tr>
<tr>
<td><code>has(key)</code></td>
<td>判断 <code>FormData</code> 对象是否包含指定键</td>
</tr>
<tr>
<td><code>kes()</code></td>
<td>返回一个包含所有键的迭代器对象</td>
</tr>
<tr>
<td><code>values()</code></td>
<td>返回一个包含所有值的迭代器对象</td>
</tr>
<tr>
<td><code>entries()</code></td>
<td>返回一个包含所有键值对的迭代器对象</td>
</tr>
</tbody></table>
<h1 id="五-跨域"><a href="#五-跨域" class="headerlink" title="五 跨域"></a>五 跨域</h1><h2 id="5-1-同源政策"><a href="#5-1-同源政策" class="headerlink" title="5.1 同源政策"></a>5.1 同源政策</h2><ol>
<li>同源：协议、域名和端口都相同</li>
<li>Ajax 只能向同源服务器发送HTTP 请求，如果发出跨域请求，就会报错</li>
<li>同源政策是为了用户信息安全，防止恶意窃取数据</li>
<li>解决同源的方式有许多，如 <code>JSONP</code></li>
</ol>
<h2 id="5-2-JSONP"><a href="#5-2-JSONP" class="headerlink" title="5.2 JSONP"></a>5.2 JSONP</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>json with padding</code></li>
<li>JSONP 不属于 Ajax 请求，但可以模拟 Ajax 请求</li>
<li>是 <code>json</code> 的一种 “使用模式”，可以从别的域请求资源</li>
</ol>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h3><ol>
<li>在客户端全局作用域定义一个函数</li>
<li>客户端 <code>&lt;script src=&quot;&quot;&gt;</code> 是不受同源限制的，非同源请求地址写在<code>src</code> 中</li>
<li>在请求地址中将函数名发送给服务器</li>
<li>服务器响应数据必须是客户端所定义函数的调用，真正发给客户端的数据作为函数调用的参数</li>
<li>客户端接收到实参，执行函数</li>
</ol>
<h3 id="3-动态请求"><a href="#3-动态请求" class="headerlink" title="3 动态请求"></a>3 动态请求</h3><ol>
<li><code>&lt;script&gt;</code> 标签可以不写死，而是用 JS 动态生成</li>
<li>添加监听事件 <code>onload</code>，在请求完成后，删除 <code>&lt;script src=&quot;&quot;&gt;</code> ，避免多次请求产生多个 <code>&lt;script src=&quot;&quot;&gt;</code></li>
</ol>
<h3 id="4-跨域-Cookie"><a href="#4-跨域-Cookie" class="headerlink" title="4 跨域 Cookie"></a>4 跨域 Cookie</h3><ol>
<li><code>withCredentials</code> 设置为 <code>true</code></li>
<li><code>Access-Control-Allow-Credentials</code> 设置为 <code>true</code></li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>DOM</title>
    <url>/anyeansan.github.io/2020/11/08/UI/DOM/</url>
    <content><![CDATA[<h1 id="一-DOM-概述"><a href="#一-DOM-概述" class="headerlink" title="一 DOM 概述"></a>一 DOM 概述</h1><ol>
<li><code>Document Object Model</code> 文档对象模型</li>
<li>DOM 是 HTML 和 XML 文档的编程接口，用于改变文档的结构，样式和内容</li>
<li>DOM 的最小组成单位叫做节点（node），DOM 树由各种不同类型的节点组成</li>
<li>页面中所有内容都是节点（标签，属性，文本，注释等）</li>
</ol>
<h1 id="二-NodeList-amp-HTMLCollection"><a href="#二-NodeList-amp-HTMLCollection" class="headerlink" title="二 NodeList &amp; HTMLCollection"></a>二 NodeList &amp; HTMLCollection</h1><h2 id="2-1-NodeList"><a href="#2-1-NodeList" class="headerlink" title="2.1 NodeList"></a>2.1 NodeList</h2><ol>
<li><code>NodeList</code> 是节点的集合，是类数组对象</li>
<li><code>Node.childNodes</code> 返回的是一个动态集合，即文档中的节点树发生变化，<code>NodeList</code> 也会随之变化</li>
<li>其他的 <code>NodeList</code> 都是静态集合</li>
<li><code>NodeList</code> 的 <code>length</code> 属性表示其包含的节点数量</li>
<li><code>NodeList</code> 的遍历<ol>
<li><code>item(index)</code><ul>
<li>获取指定索引的值，可以用 <code>nodeList[index]</code> 代替</li>
</ul>
</li>
<li><code>for</code> 循环<ul>
<li>因为是类数组对象，有索引</li>
</ul>
</li>
<li><code>forEach()</code></li>
<li><code>keys()</code></li>
<li><code>values()</code></li>
<li><code>entries()</code></li>
</ol>
</li>
</ol>
<h2 id="2-2-HTMLCollection"><a href="#2-2-HTMLCollection" class="headerlink" title="2.2 HTMLCollection"></a>2.2 HTMLCollection</h2><ol>
<li><code>HTMLCollection</code> 元素节点的集合，是类数组对象</li>
<li><code>HTMLCollection</code> 都是动态集合</li>
<li><code>HTMLCollection</code> 的 <code>length</code> 属性表示其包含的节点数量</li>
<li><code>HTMLCollection</code> 不能使用 <code>foreach</code> 遍历</li>
</ol>
<h1 id="三-Node"><a href="#三-Node" class="headerlink" title="三 Node"></a>三 Node</h1><h2 id="3-1-分类"><a href="#3-1-分类" class="headerlink" title="3.1 分类"></a>3.1 分类</h2><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
<th align="center"><code>nodeType</code></th>
<th><code>nodeName</code></th>
<th><code>nodeValue</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>Document</code></td>
<td>文档节点</td>
<td>整个页面</td>
<td align="center"><code>9</code></td>
<td><code>#document</code></td>
<td><code>null</code></td>
</tr>
<tr>
<td><code>Element</code></td>
<td>元素节点</td>
<td>页面 HTML 标签</td>
<td align="center"><code>1</code></td>
<td>大写的标签名</td>
<td><code>null</code></td>
</tr>
<tr>
<td><code>Attr</code></td>
<td>属性节点</td>
<td>页面标签的属性</td>
<td align="center"><code>2</code></td>
<td>属性名</td>
<td>属性值</td>
</tr>
<tr>
<td><code>Text</code></td>
<td>文本节点</td>
<td>页面中的文本</td>
<td align="center"><code>3</code></td>
<td><code>#text</code></td>
<td>文本内容</td>
</tr>
<tr>
<td><code>Comment</code></td>
<td>注释节点</td>
<td>注释</td>
<td align="center"><code>8</code></td>
<td><code>#comment</code></td>
<td>注释内容</td>
</tr>
<tr>
<td><code>DocumentType</code></td>
<td>文档类型节点</td>
<td><code>&lt;!DOCTYPE html&gt;</code></td>
<td align="center"><code>10</code></td>
<td>文档的类型</td>
<td><code>null</code></td>
</tr>
<tr>
<td><code>DocumentFragment</code></td>
<td>文档片段节点</td>
<td>一个没有父级文件的最小文档对象</td>
<td align="center"><code>11</code></td>
<td><code>#document-fragment</code></td>
<td><code>null</code></td>
</tr>
</tbody></table>
<h2 id="3-2-属性"><a href="#3-2-属性" class="headerlink" title="3.2 属性"></a>3.2 属性</h2><h3 id="1-节点信息"><a href="#1-节点信息" class="headerlink" title="1 节点信息"></a>1 节点信息</h3><table>
<thead>
<tr>
<th>属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>nodeType</code></td>
<td>只读</td>
<td>节点类型（整数值）</td>
</tr>
<tr>
<td><code>nodeName</code></td>
<td>只读</td>
<td>节点名</td>
</tr>
<tr>
<td><code>nodeValue</code></td>
<td>读写</td>
<td>获取或设置当前节点的值</td>
</tr>
<tr>
<td><code>baseURI</code></td>
<td>只读</td>
<td>当前网页的绝对路径 URI</td>
</tr>
</tbody></table>
<h3 id="2-节点结构"><a href="#2-节点结构" class="headerlink" title="2 节点结构"></a>2 节点结构</h3><table>
<thead>
<tr>
<th>属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>parentNode</code></td>
<td>只读</td>
<td>父节点</td>
</tr>
<tr>
<td><code>childNodes</code></td>
<td>只读</td>
<td>所有子节点的 <code>NodeList</code> 集合</td>
</tr>
<tr>
<td><code>firstChild</code></td>
<td>只读</td>
<td>第一个子节点</td>
</tr>
<tr>
<td><code>lastChild</code></td>
<td>只读</td>
<td>最后一个子节点</td>
</tr>
<tr>
<td><code>nextSibling</code></td>
<td>只读</td>
<td>弟节点</td>
</tr>
<tr>
<td><code>previousSibling</code></td>
<td>只读</td>
<td>兄节点</td>
</tr>
</tbody></table>
<h3 id="3-元素节点结构"><a href="#3-元素节点结构" class="headerlink" title="3 元素节点结构"></a>3 元素节点结构</h3><table>
<thead>
<tr>
<th>属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>parentElement</code></td>
<td>只读</td>
<td>父元素节点，若没有父节点或父节点不是元素节点则返回 <code>null</code></td>
</tr>
<tr>
<td><code>children</code></td>
<td>只读</td>
<td>所有子元素节点，非标准，但推荐使用</td>
</tr>
<tr>
<td><code>firstElementChild</code></td>
<td>只读</td>
<td>第一个子元素节点，有兼容问题，推荐 <code>children[0]</code></td>
</tr>
<tr>
<td><code>lastElementChild</code></td>
<td>只读</td>
<td>最后一个子元素节点，有兼容问题，推荐 <code>children[children.length-1]</code></td>
</tr>
<tr>
<td><code>nextElementSibling</code></td>
<td>只读</td>
<td>弟元素节点，有兼容问题</td>
</tr>
<tr>
<td><code>previousElementSibling</code></td>
<td>只读</td>
<td>兄元素节点，有兼容问题</td>
</tr>
</tbody></table>
<h2 id="3-3-方法"><a href="#3-3-方法" class="headerlink" title="3.3 方法"></a>3.3 方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>parentNode.appendChild(childNode)</code></td>
<td>追加子节点</td>
</tr>
<tr>
<td><code>parentNode.removeChild(childNode)</code></td>
<td>删除子节点</td>
</tr>
<tr>
<td><code>parentNode.replaceChild(newNode, oldNode)</code></td>
<td>替换子节点</td>
</tr>
<tr>
<td><code>parentNode.insertBefore(childNode, targetNode)</code></td>
<td>将子节点插入到目标节点之前</td>
</tr>
<tr>
<td><code>node.cloneNode([flag])</code></td>
<td>克隆节点，无参或 <code>false</code> 为浅拷贝，<code>true</code> 为深拷贝</td>
</tr>
<tr>
<td><code>node.hasChildNodes()</code></td>
<td>判断是否有子节点</td>
</tr>
<tr>
<td><code>node.contains(node)</code></td>
<td>判断是否是其自己或后代节点</td>
</tr>
</tbody></table>
<h1 id="四-Document"><a href="#四-Document" class="headerlink" title="四 Document"></a>四 Document</h1><h2 id="4-1-属性"><a href="#4-1-属性" class="headerlink" title="4.1 属性"></a>4.1 属性</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>forms</code></td>
<td>返回所有 <code>&lt;form&gt;</code> 表单节点的  <code>HTMLCollection</code> 集合</td>
</tr>
<tr>
<td><code>documentURI</code></td>
<td>文档的 URI</td>
</tr>
<tr>
<td><code>location</code></td>
<td>浏览器地址栏对象</td>
</tr>
<tr>
<td><code>body</code></td>
<td>获取 <code>&lt;body&gt;</code> 元素节点</td>
</tr>
<tr>
<td><code>documentElement</code></td>
<td>获取 <code>&lt;html&gt;</code> 元素节点</td>
</tr>
</tbody></table>
<h2 id="4-2-方法"><a href="#4-2-方法" class="headerlink" title="4.2 方法"></a>4.2 方法</h2><h3 id="1-获取"><a href="#1-获取" class="headerlink" title="1 获取"></a>1 获取</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>getElementById(id)</code></td>
<td>根据元素 ID 获取 <code>Element</code> 对象</td>
</tr>
<tr>
<td><code>getElementsByTagName(tagName)</code></td>
<td>根据标签名获取元素节点的 <code>HTMLCollection</code> 集合</td>
</tr>
<tr>
<td><code>getElementsByClassName(class)</code></td>
<td>根据 <code>class</code> 属性值获取元素节点的 <code>HTMLCollection</code> 集合</td>
</tr>
<tr>
<td><code>getElementsByName(name)</code></td>
<td>根据元素 <code>name</code> 属性的值获取节点的 <code>NodeList</code> 集合</td>
</tr>
<tr>
<td><code>querySelector(selector)</code></td>
<td>返回第一个匹配的节点</td>
</tr>
<tr>
<td><code>querySelectorAll(selector)</code></td>
<td>返回所有匹配节点的 <code>NodeList</code> 集合</td>
</tr>
</tbody></table>
<h3 id="2-创建"><a href="#2-创建" class="headerlink" title="2 创建"></a>2 创建</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>createElement(tageName)</code></td>
<td>创建元素节点</td>
</tr>
<tr>
<td><code>createAttribute(attrName)</code></td>
<td>创建属性节点</td>
</tr>
<tr>
<td><code>createTextNode(text)</code></td>
<td>创建文本节点</td>
</tr>
<tr>
<td><code>createComment(comment)</code></td>
<td>创建注释节点</td>
</tr>
</tbody></table>
<ul>
<li>另外两种创建节点的方式<ol>
<li><code>document.write()</code><ul>
<li>是直接将内容写入页面，如果文档流加载完毕才执行，会导致页面重绘（仍掉原页面，创建新页面且只有写出的内容）</li>
</ul>
</li>
<li><code>innerHTML</code><ul>
<li>创建多个元素通过拼接字符串创建，效率底</li>
<li>创建多个元素通过数组形式拼接，效率高，但复杂</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="五-Element"><a href="#五-Element" class="headerlink" title="五 Element"></a>五 Element</h1><h2 id="5-1-属性"><a href="#5-1-属性" class="headerlink" title="5.1 属性"></a>5.1 属性</h2><h3 id="1-信息属性"><a href="#1-信息属性" class="headerlink" title="1 信息属性"></a>1 信息属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>id</code></td>
<td>读写</td>
<td>元素 id</td>
</tr>
<tr>
<td><code>tagName</code></td>
<td>只读</td>
<td>元素标签名</td>
</tr>
<tr>
<td><code>className</code></td>
<td>读写</td>
<td>返回 class 属性的字符串，多个用空格分隔</td>
</tr>
<tr>
<td><code>classList</code></td>
<td>只读</td>
<td>返回 class 属性的类数组对象</td>
</tr>
<tr>
<td><code>innerHTML</code></td>
<td>读写</td>
<td>识别 Html 标签，保留Html 标签、空格和换行，w3c 标准</td>
</tr>
<tr>
<td><code>innerText</code></td>
<td>读写</td>
<td>不识别 Html 标签，会去除 Html标签以及空格和换行，非标准</td>
</tr>
<tr>
<td><code>dataset</code></td>
<td>只读</td>
<td>存放了所有以 <code>data-</code> 开头的自定义属性的集合</td>
</tr>
<tr>
<td><code>hiddent</code></td>
<td>读写</td>
<td>元素是否隐藏</td>
</tr>
<tr>
<td><code>style</code></td>
<td>读写</td>
<td>元素的行内样式信息，带单位</td>
</tr>
</tbody></table>
<h3 id="2-offset-系列属性"><a href="#2-offset-系列属性" class="headerlink" title="2 offset 系列属性"></a>2 offset 系列属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>offsetParent</code></td>
<td>只读</td>
<td>返回该元素带有定位的祖先元素，如果没有则返回 <code>body</code></td>
</tr>
<tr>
<td><code>offsetTop</code></td>
<td>只读</td>
<td>返回元素相对定位祖先元素上方的偏移量，不带单位</td>
</tr>
<tr>
<td><code>offsetLeft</code></td>
<td>只读</td>
<td>返回元素相对定位祖先元素左方的偏移量，不带单位</td>
</tr>
<tr>
<td><code>offsetWidth</code></td>
<td>只读</td>
<td>返回 <code>boder-box</code> 的宽度，不带单位</td>
</tr>
<tr>
<td><code>offsetHeight</code></td>
<td>只读</td>
<td>返回 <code>boder-box</code> 的高度，不带单位</td>
</tr>
</tbody></table>
<h4 id="offset-amp-style-的区别"><a href="#offset-amp-style-的区别" class="headerlink" title="offset &amp; style 的区别"></a>offset &amp; style 的区别</h4><table>
<thead>
<tr>
<th><code>offset</code></th>
<th><code>style</code></th>
</tr>
</thead>
<tbody><tr>
<td>获取任意样式表的值</td>
<td>获取行内样式表的值</td>
</tr>
<tr>
<td>获取的值没有单位</td>
<td>获取的值有单位</td>
</tr>
<tr>
<td><code>offsetWidth = width + padding + border</code></td>
<td><code>style.width = width</code></td>
</tr>
<tr>
<td>只读</td>
<td>读写</td>
</tr>
</tbody></table>
<h3 id="3-client-系列属性"><a href="#3-client-系列属性" class="headerlink" title="3 client 系列属性"></a>3 client 系列属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>clientTop</code></td>
<td>只读</td>
<td>元素上边框大小</td>
</tr>
<tr>
<td><code>clientLeft</code></td>
<td>只读</td>
<td>元素左边框大小</td>
</tr>
<tr>
<td><code>clientWidth</code></td>
<td>只读</td>
<td><code>padding-box</code> 的可视宽度，不带单位</td>
</tr>
<tr>
<td><code>clientHeight</code></td>
<td>只读</td>
<td><code>padding-box</code> 的可视高度，不带单位</td>
</tr>
</tbody></table>
<h3 id="4-scroll-系列属性"><a href="#4-scroll-系列属性" class="headerlink" title="4 scroll 系列属性"></a>4 scroll 系列属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>scrollLeft</code></td>
<td>被卷去的上侧距离，不带单位</td>
<td></td>
</tr>
<tr>
<td><code>scrollTop</code></td>
<td>被卷去的左侧距离，不带单位</td>
<td></td>
</tr>
<tr>
<td><code>scrollWidth</code></td>
<td><code>padding-box</code> 的实际宽度，不带单位</td>
<td></td>
</tr>
<tr>
<td><code>scrollHeight</code></td>
<td><code>padding-box</code> 的实际高度，不带单位</td>
<td></td>
</tr>
</tbody></table>
<h2 id="5-2-方法"><a href="#5-2-方法" class="headerlink" title="5.2 方法"></a>5.2 方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>getAttribute(key)</code></td>
<td>获取属性的值</td>
</tr>
<tr>
<td><code>setAttribute(key, value)</code></td>
<td>设置属性的值</td>
</tr>
<tr>
<td><code>removeAttribute(key)</code></td>
<td>删除属性</td>
</tr>
<tr>
<td><code>getAttributeNames()</code></td>
<td>返回当前元素所有属性名</td>
</tr>
<tr>
<td><code>hasAttribute(key)</code></td>
<td>某个属性是否存在</td>
</tr>
<tr>
<td><code>hasAttributes()</code></td>
<td>当前元素是否有属性</td>
</tr>
<tr>
<td><code>click()</code></td>
<td>模拟鼠标左键单击一个元素</td>
</tr>
</tbody></table>
<ul>
<li><code>Document</code> 中用来获取元素节点的方法，<code>Element</code> 也能用，只是匹配范围是当前元素而非整个文档</li>
</ul>
<h1 id="六-事件"><a href="#六-事件" class="headerlink" title="六 事件"></a>六 事件</h1><h2 id="6-1-EventTarget"><a href="#6-1-EventTarget" class="headerlink" title="6.1 EventTarget"></a>6.1 EventTarget</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ul>
<li>DOM 的事件操作（监听和触发），都定义在 <code>EventTarget</code> 接口</li>
</ul>
<h3 id="2-API"><a href="#2-API" class="headerlink" title="2 API"></a>2 API</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>addEventListener(type, listener [,useCapture])</code></td>
<td>添加事件监听</td>
</tr>
<tr>
<td><code>removeEventListener(type, listener [,useCapture])</code></td>
<td>移除事件监听</td>
</tr>
<tr>
<td><code>dispatchEvent(event)</code></td>
<td>触发指定事件</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>type</code></td>
<td>事件类型字符串，大小写敏感，如 click focus …</td>
</tr>
<tr>
<td><code>listener</code></td>
<td>监听函数</td>
</tr>
<tr>
<td><code>useCapture</code></td>
<td>默认 <code>false</code>：冒泡阶段触发，<code>true</code>：捕获阶段触发</td>
</tr>
</tbody></table>
<h2 id="6-2-事件绑定和解绑"><a href="#6-2-事件绑定和解绑" class="headerlink" title="6.2 事件绑定和解绑"></a>6.2 事件绑定和解绑</h2><h3 id="1-传统注册方式"><a href="#1-传统注册方式" class="headerlink" title="1 传统注册方式"></a>1 传统注册方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 绑定事件</span><br><span class="line">element.onEventType = function()&#123;&#125; </span><br><span class="line"># 解绑事件</span><br><span class="line">element.onclick=null;</span><br></pre></td></tr></table></figure>

<ol>
<li>利用 <code>on</code> 开头的事件</li>
<li>只在冒泡阶段触发</li>
<li>注册事件的唯一性：同一个元素同一个事件只能定义一个监听函数，多次定义会覆盖</li>
</ol>
<h3 id="2-方法监听注册方式"><a href="#2-方法监听注册方式" class="headerlink" title="2 方法监听注册方式"></a>2 方法监听注册方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 绑定事件</span><br><span class="line">element.addEventListener(type, listener [,useCapture]) </span><br><span class="line"># 解绑事件</span><br><span class="line">element.removeEventListener(type, listener [,useCapture])</span><br></pre></td></tr></table></figure>

<ol>
<li>同一个元素同一个事件可以添加多个监听函数</li>
<li>能够指定在哪个阶段（捕获阶段 or 冒泡阶段）触发监听函数</li>
<li>是整个 JavaScript 统一的监听函数接口</li>
</ol>
<h2 id="6-3-DOM-事件流"><a href="#6-3-DOM-事件流" class="headerlink" title="6.3 DOM 事件流"></a>6.3 DOM 事件流</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>事件流描述的是从页面中接收事件的顺序</li>
<li>事件发生时会在元素节点之间按照特定的顺序传播，此传播过程即 DOM 事件流</li>
<li>JS 代码中只能执行捕获或者冒泡中的一个阶段</li>
<li>冒泡阶段更常用，但某些事件没有冒泡阶段，如 <code>focus blur mouseenter mouseleave</code></li>
</ol>
<h3 id="2-事件流三个阶段"><a href="#2-事件流三个阶段" class="headerlink" title="2 事件流三个阶段"></a>2 事件流三个阶段</h3><p><img src="https://gitee.com/anis5/pic/raw/master/UI/JS/%E4%BA%8B%E4%BB%B6%E6%B5%81.png" alt=""></p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>capture phase</code></td>
<td>捕获阶段</td>
<td>从 window 对象传导到目标节点（上层传到底层）</td>
</tr>
<tr>
<td><code>target phase</code></td>
<td>目标阶段</td>
<td>在目标节点上触发</td>
</tr>
<tr>
<td><code>bubbling phase</code></td>
<td>冒泡阶段</td>
<td>从目标节点传导回 window 对象（从底层传回上层）</td>
</tr>
</tbody></table>
<h3 id="3-事件委托（代理-委派）"><a href="#3-事件委托（代理-委派）" class="headerlink" title="3 事件委托（代理/委派）"></a>3 事件委托（代理/委派）</h3><ol>
<li>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件</li>
<li>优点：只操作一次DOM，性能更高</li>
<li>如果希望事件到某个节点为止，不再传播，<code>event.stopPropagation()</code> 阻止冒泡</li>
<li>获取触发事件的对象 <code>event.target</code></li>
<li>获取绑定事件的对象 <code>this</code> </li>
</ol>
<h2 id="6-4-Event"><a href="#6-4-Event" class="headerlink" title="6.4 Event"></a>6.4 Event</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>事件发生以后，系统会自动创建一个事件对象 <code>Event</code>，作为参数传给监听函数</li>
<li>事件对象是一系列与事件相关的数据的集合</li>
<li><code>Event</code> 有许多字类，如 <code>MouseEvent, KeyboardEvent, TouchEvent...</code> </li>
</ol>
<h3 id="2-属性"><a href="#2-属性" class="headerlink" title="2 属性"></a>2 属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>target</code></td>
<td>触发事件的对象，<code>this</code> ：绑定事件的对象</td>
</tr>
<tr>
<td><code>type</code></td>
<td>事件类型（名称）</td>
</tr>
<tr>
<td><code>returnValue</code></td>
<td>阻止事件的默认行为，低版本浏览器使用</td>
</tr>
</tbody></table>
<h3 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>preventDefault()</code></td>
<td>阻止事件的默认行为（如跳转，提交…）</td>
</tr>
<tr>
<td><code>stopPropagation()</code></td>
<td>阻止事件传播（捕获和冒泡）</td>
</tr>
</tbody></table>
<h3 id="4-阻止事件的默认行为方式"><a href="#4-阻止事件的默认行为方式" class="headerlink" title="4 阻止事件的默认行为方式"></a>4 阻止事件的默认行为方式</h3><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>returnValue</code></td>
<td>低版本浏览器 IE678 使用</td>
</tr>
<tr>
<td><code>return false</code></td>
<td>没有兼容性问题，但是会结束代码，且只限于传统事件注册方式</td>
</tr>
<tr>
<td><code>preventDefault()</code></td>
<td>W3C 标准，低版本可能不支持</td>
</tr>
</tbody></table>
<h2 id="6-5-鼠标事件"><a href="#6-5-鼠标事件" class="headerlink" title="6.5 鼠标事件"></a>6.5 鼠标事件</h2><h3 id="1-事件"><a href="#1-事件" class="headerlink" title="1 事件"></a>1 事件</h3><table>
<thead>
<tr>
<th>事件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>click</code></td>
<td>单击</td>
</tr>
<tr>
<td><code>dblclick</code></td>
<td>双击</td>
</tr>
<tr>
<td><code>focus</code></td>
<td>获取焦点，该事件不会冒泡</td>
</tr>
<tr>
<td><code>blur</code></td>
<td>失去焦点，该事件不会冒泡</td>
</tr>
<tr>
<td><code>mousedown</code></td>
<td>鼠标键按下</td>
</tr>
<tr>
<td><code>mouseup</code></td>
<td>鼠标键弹起</td>
</tr>
<tr>
<td><code>mousemove</code></td>
<td>鼠标移动</td>
</tr>
<tr>
<td><code>mouseenter</code></td>
<td>鼠标经过，该事件不会冒泡</td>
</tr>
<tr>
<td><code>mouseleave</code></td>
<td>鼠标离开，该事件不会冒泡</td>
</tr>
<tr>
<td><code>mouseover</code></td>
<td>鼠标经过</td>
</tr>
<tr>
<td><code>mouseout</code></td>
<td>鼠标离开</td>
</tr>
<tr>
<td><code>contextmenu</code></td>
<td>右键菜单，常使用 <code>event.preventDefault()</code> 来禁止右键菜单</td>
</tr>
<tr>
<td><code>selectstart</code></td>
<td>选中文字，常使用 <code>event.preventDefault()</code> 来禁止选中文字</td>
</tr>
</tbody></table>
<h3 id="2-MouseEvent"><a href="#2-MouseEvent" class="headerlink" title="2 MouseEvent"></a>2 MouseEvent</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>clientX</code></td>
<td>鼠标相对于浏览器窗口可视区的 X 坐标</td>
</tr>
<tr>
<td><code>clientY</code></td>
<td>鼠标相对于浏览器窗口可视区的 Y 坐标</td>
</tr>
<tr>
<td><code>pageX</code></td>
<td>鼠标相对于文档页面的 X 坐标</td>
</tr>
<tr>
<td><code>pageY</code></td>
<td>鼠标相对于文档页面的 Y 坐标</td>
</tr>
<tr>
<td><code>screenX</code></td>
<td>鼠标相对于电脑屏幕的 X 坐标</td>
</tr>
<tr>
<td><code>screenY</code></td>
<td>鼠标相对于电脑屏幕的 Y 坐标</td>
</tr>
</tbody></table>
<h2 id="6-6-键盘事件"><a href="#6-6-键盘事件" class="headerlink" title="6.6 键盘事件"></a>6.6 键盘事件</h2><h3 id="1-事件-1"><a href="#1-事件-1" class="headerlink" title="1 事件"></a>1 事件</h3><table>
<thead>
<tr>
<th>事件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>keydown</code></td>
<td>按下键盘按键之后文字未输入之前触发，顺序在 <code>keypress</code> 之前，不区分大小写</td>
</tr>
<tr>
<td><code>keypress</code></td>
<td>按下有值的键之后文字未输入之前触发触发，区分大小写，不识别功能键如 <code>→ ← ctrl alt shift...</code></td>
</tr>
<tr>
<td><code>keyup</code></td>
<td>弹起键盘按键触发，不区分大小写</td>
</tr>
</tbody></table>
<h3 id="2-KeyboardEvent"><a href="#2-KeyboardEvent" class="headerlink" title="2 KeyboardEvent"></a>2 KeyboardEvent</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>keyCode</code></td>
<td>按键对应的 ASCII 码值</td>
</tr>
</tbody></table>
<h2 id="6-7-触屏事件"><a href="#6-7-触屏事件" class="headerlink" title="6.7 触屏事件"></a>6.7 触屏事件</h2><h3 id="1-事件-2"><a href="#1-事件-2" class="headerlink" title="1 事件"></a>1 事件</h3><table>
<thead>
<tr>
<th>事件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>touchstart</code></td>
<td>触摸到一个 DOM 元素时触发</td>
</tr>
<tr>
<td><code>touchmove</code></td>
<td>在一个 DOM 元素上滑动时触发</td>
</tr>
<tr>
<td><code>touchend</code></td>
<td>从一个 DOM 元素上移开时触发</td>
</tr>
</tbody></table>
<h3 id="2-概念"><a href="#2-概念" class="headerlink" title="2 概念"></a>2 概念</h3><table>
<thead>
<tr>
<th>对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Touch</code></td>
<td>单个触摸点。触摸点可能是一根手指，也可能是一根触摸笔</td>
</tr>
<tr>
<td><code>TouchList</code></td>
<td>多个触摸点的集合</td>
</tr>
<tr>
<td><code>TouchEvent</code></td>
<td>触摸引发的事件实例</td>
</tr>
</tbody></table>
<h3 id="3-TouchEvent"><a href="#3-TouchEvent" class="headerlink" title="3 TouchEvent"></a>3 TouchEvent</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>touches</code></td>
<td><code>TouchList</code>，正在触摸屏幕的触点的列表</td>
</tr>
<tr>
<td><code>targetTouches</code></td>
<td><code>TouchList</code>，正在触摸当前 DOM 元素的触点的列表</td>
</tr>
<tr>
<td><code>changedTouches</code></td>
<td><code>TouchList</code>，状态发生改变的触点的列表</td>
</tr>
</tbody></table>
<h3 id="4-TouchList"><a href="#4-TouchList" class="headerlink" title="4 TouchList"></a>4 TouchList</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>length</code></td>
<td>节点数量</td>
</tr>
<tr>
<td><code>item(index)</code></td>
<td>获取指定索引的节点，可以用 <code>list[index]</code> 代替</td>
</tr>
</tbody></table>
<h3 id="5-Touch"><a href="#5-Touch" class="headerlink" title="5 Touch"></a>5 Touch</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>identifier</code></td>
<td>返回一个整数，表示触摸点的唯一 ID</td>
</tr>
<tr>
<td><code>target</code></td>
<td>触摸的节点</td>
</tr>
<tr>
<td><code>clientX</code></td>
<td>触点相对于可见视区左边沿的的 X 坐标</td>
</tr>
<tr>
<td><code>clientY</code></td>
<td>触点相对于可见视区上边沿的的 Y 坐标.</td>
</tr>
<tr>
<td><code>pageX</code></td>
<td>触点相对于 HTML 文档左边沿的的 X 坐标</td>
</tr>
<tr>
<td><code>pageY</code></td>
<td>触点相对于 HTML 文档上边沿的的 Y 坐标</td>
</tr>
<tr>
<td><code>screenX</code></td>
<td>触点相对于屏幕左边沿的的 X 坐标</td>
</tr>
<tr>
<td><code>screenY</code></td>
<td>触点相对于屏幕上边沿的的 Y 坐标</td>
</tr>
</tbody></table>
<h2 id="6-8-表单事件"><a href="#6-8-表单事件" class="headerlink" title="6.8 表单事件"></a>6.8 表单事件</h2><table>
<thead>
<tr>
<th>事件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>input</code></td>
<td>当 <code>&lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;</code> 的值发生变化时触发</td>
</tr>
<tr>
<td><code>change</code></td>
<td>同 <code>input</code> 区别是如果有连续变化，<code>input</code> 事件会触发多次，而 <code>change</code> 事件只在失去焦点时触发一次</td>
</tr>
<tr>
<td><code>select</code></td>
<td>在<code>&lt;input&gt;、&lt;textarea&gt;</code> 里面选中文本时触发</td>
</tr>
<tr>
<td><code>invalid</code></td>
<td>提交表单时，如果表单元素的值不满足校验条件时触发</td>
</tr>
<tr>
<td><code>reset</code></td>
<td>重置表单时触发</td>
</tr>
<tr>
<td><code>submit</code></td>
<td>提交表单时触发</td>
</tr>
</tbody></table>
<h1 id="七-元素的属性操作"><a href="#七-元素的属性操作" class="headerlink" title="七 元素的属性操作"></a>七 元素的属性操作</h1><h2 id="7-1-attribute-amp-property"><a href="#7-1-attribute-amp-property" class="headerlink" title="7.1 attribute &amp; property"></a>7.1 attribute &amp; property</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>attribute</code></td>
<td>HTML 标准属性和自定义属性</td>
</tr>
<tr>
<td><code>property</code></td>
<td>DOM 属性（HTML 元素的标准属性会自动成为元素节点对象的属性）</td>
</tr>
</tbody></table>
<h2 id="7-2-操作方式"><a href="#7-2-操作方式" class="headerlink" title="7.2 操作方式"></a>7.2 操作方式</h2><h3 id="1-attribute"><a href="#1-attribute" class="headerlink" title="1 attribute"></a>1 attribute</h3><table>
<thead>
<tr>
<th>操作</th>
<th>原生 DOM</th>
<th>jQuery</th>
</tr>
</thead>
<tbody><tr>
<td>读</td>
<td><code>element.getAttribute(name)</code></td>
<td><code>$element.attr(name)</code></td>
</tr>
<tr>
<td>写</td>
<td><code>element.setAttribute(name, value)</code></td>
<td><code>$element.attr(name, value)</code></td>
</tr>
<tr>
<td>删</td>
<td><code>element.removeAttribute(name)</code></td>
<td><code>$element.removeAttr(name)</code></td>
</tr>
</tbody></table>
<h3 id="2-property"><a href="#2-property" class="headerlink" title="2 property"></a>2 property</h3><table>
<thead>
<tr>
<th>操作</th>
<th>原生 DOM</th>
<th>jQuery</th>
</tr>
</thead>
<tbody><tr>
<td>读</td>
<td><code>element.name</code></td>
<td><code>$element.prop(name)</code></td>
</tr>
<tr>
<td>写</td>
<td><code>element.name=value</code></td>
<td><code>$element.prop(name, value)</code></td>
</tr>
<tr>
<td>删</td>
<td><code>delete element.name</code></td>
<td><code>$element.removeProp(name)</code></td>
</tr>
</tbody></table>
<h2 id="7-3-总结"><a href="#7-3-总结" class="headerlink" title="7.3 总结"></a>7.3 总结</h2><h3 id="1-HTML-标准属性"><a href="#1-HTML-标准属性" class="headerlink" title="1 HTML 标准属性"></a>1 HTML 标准属性</h3><ol>
<li><code>attribute</code></li>
<li><code>property</code></li>
</ol>
<h3 id="2-自定义属性"><a href="#2-自定义属性" class="headerlink" title="2 自定义属性"></a>2 自定义属性</h3><ol>
<li><code>attribute</code><ul>
<li>能够操作，但是不符合标准，导致网页代码通不过校验</li>
</ul>
</li>
</ol>
<h3 id="3-HTML5-自定义属性规范"><a href="#3-HTML5-自定义属性规范" class="headerlink" title="3 HTML5 自定义属性规范"></a>3 HTML5 自定义属性规范</h3><ol>
<li>自定义属性名以 <code>data-</code> 开头，如 <code>data-test</code></li>
<li>获取标准自定义属性有两种方式<ol>
<li>如：<code>data-test</code><ol>
<li><code>getAttribute(&#39;data-test&#39;)</code></li>
<li><code>element.dataset.test</code></li>
</ol>
</li>
<li>如：<code>data-test-name</code><ol>
<li><code>getAttribute(&#39;data-test-name&#39;)</code> </li>
<li><code>element.dataset.testName</code><ul>
<li>如果名称有多个以 <code>-</code> 连接的单词，使用驼峰</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>BOM</title>
    <url>/anyeansan.github.io/2020/11/08/UI/BOM/</url>
    <content><![CDATA[<h1 id="一-BOM-概述"><a href="#一-BOM-概述" class="headerlink" title="一 BOM 概述"></a>一 BOM 概述</h1><ol>
<li><code>Browser Object Model</code> 浏览器对象模型，提供了独立于内容而与浏览器窗口进行交互的对象</li>
<li>BOM 由浏览器厂商各自定义，兼容性较差</li>
<li>BOM 包含 DOM</li>
<li>BOM 都有一个顶级对象，不同的环境顶级对象也不同，浏览器环境是 <code>window</code></li>
</ol>
<h1 id="二-window"><a href="#二-window" class="headerlink" title="二 window"></a>二 window</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol>
<li><code>window</code> 是浏览器的顶级对象，是 JS 访问浏览器窗口的一个接口</li>
<li><code>window</code> 是一个全局对象，定义在全局作用域的变量、函数都会变成 <code>window</code> 对象的属性和方法</li>
</ol>
<h2 id="2-2-属性"><a href="#2-2-属性" class="headerlink" title="2.2 属性"></a>2.2 属性</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>name</code></td>
<td>窗口名</td>
</tr>
<tr>
<td><code>innerWidth</code></td>
<td>窗口可视宽度</td>
</tr>
<tr>
<td><code>innerHeight</code></td>
<td>窗口可视高度</td>
</tr>
<tr>
<td><code>pageXOffset</code></td>
<td>页面的水平滚动距离</td>
</tr>
<tr>
<td><code>pageYOffset</code></td>
<td>页面的垂直滚动距离</td>
</tr>
<tr>
<td><code>document</code></td>
<td>返回 Document 对象</td>
</tr>
<tr>
<td><code>location</code></td>
<td>返回 Location 对象</td>
</tr>
<tr>
<td><code>navigator</code></td>
<td>返回 Navigator 对象</td>
</tr>
<tr>
<td><code>history</code></td>
<td>返回 History 对象</td>
</tr>
<tr>
<td><code>console</code></td>
<td>返回 Console 对象</td>
</tr>
<tr>
<td><code>screen</code></td>
<td>返回 Screen 对象</td>
</tr>
<tr>
<td><code>localStorage</code></td>
<td>本地储存的 <code>localStorage</code> 数据</td>
</tr>
<tr>
<td><code>sessionStorage</code></td>
<td>本地储存的 <code>sessionStorage</code> 数据</td>
</tr>
</tbody></table>
<h2 id="2-3-方法"><a href="#2-3-方法" class="headerlink" title="2.3 方法"></a>2.3 方法</h2><h3 id="1-弹窗"><a href="#1-弹窗" class="headerlink" title="1 弹窗"></a>1 弹窗</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>alert(message)</code></td>
<td>提示框</td>
</tr>
<tr>
<td><code>confirm(message)</code></td>
<td>确认框</td>
</tr>
<tr>
<td><code>prompt([message,] value)</code></td>
<td>输入框</td>
</tr>
</tbody></table>
<h3 id="2-定时器"><a href="#2-定时器" class="headerlink" title="2 定时器"></a>2 定时器</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>setTimeout(function [, time])</code></td>
<td>指定时间后调用一次函数，<code>time</code>：毫秒值，默认为 <code>0</code> 即立即执行；通常会给定时器一个标识符，用于清除</td>
</tr>
<tr>
<td><code>clearTimeout(定时器标识符)</code></td>
<td>清除定时器</td>
</tr>
<tr>
<td><code>setInterval(function [, time])</code></td>
<td>每隔指定时间调用一此函数</td>
</tr>
<tr>
<td><code>clearInterval(定时器标识符)</code></td>
<td>清除定时器</td>
</tr>
</tbody></table>
<h3 id="3-滚动"><a href="#3-滚动" class="headerlink" title="3 滚动"></a>3 滚动</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>scrollTo(x-coord, y-coord )</code></td>
<td>滚动到指定位置</td>
</tr>
<tr>
<td><code>scrollBy(x-coord, y-coord)</code></td>
<td>滚动指定距离</td>
</tr>
</tbody></table>
<h2 id="2-4-窗口-window-事件"><a href="#2-4-窗口-window-事件" class="headerlink" title="2.4 窗口 window 事件"></a>2.4 窗口 window 事件</h2><table>
<thead>
<tr>
<th>事件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>beforeunload</code></td>
<td>窗口关闭前</td>
</tr>
<tr>
<td><code>unload</code></td>
<td>窗口关闭</td>
</tr>
<tr>
<td><code>load</code></td>
<td>窗口加载完毕，包含 dom 元素，图片，flash，css …</td>
</tr>
<tr>
<td><code>DOMContentLoaded</code></td>
<td>DOM 加载完毕，不包含其它，事件源为 <code>document</code></td>
</tr>
<tr>
<td><code>error</code></td>
<td>窗口加载失败</td>
</tr>
<tr>
<td><code>resize</code></td>
<td>窗口大小改变</td>
</tr>
<tr>
<td><code>scroll</code></td>
<td>滚动条滚动</td>
</tr>
</tbody></table>
<h1 id="三-Location"><a href="#三-Location" class="headerlink" title="三 Location"></a>三 Location</h1><h2 id="3-1-属性"><a href="#3-1-属性" class="headerlink" title="3.1 属性"></a>3.1 属性</h2><table>
<thead>
<tr>
<th>属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>href</code></td>
<td>读写</td>
<td>URL，格式 <code>protocal://host[:port]/path/[?query] # fragment</code></td>
</tr>
<tr>
<td><code>protocal</code></td>
<td>读写</td>
<td>协议</td>
</tr>
<tr>
<td><code>host</code></td>
<td>读写</td>
<td>主机，如果端口不是默认 <code>80 433</code>，则包含端口</td>
</tr>
<tr>
<td><code>hostname</code></td>
<td>读写</td>
<td>主机，不含端口</td>
</tr>
<tr>
<td><code>port</code></td>
<td>读写</td>
<td>端口</td>
</tr>
<tr>
<td><code>pathname</code></td>
<td>读写</td>
<td>资源路径</td>
</tr>
<tr>
<td><code>search</code></td>
<td>读写</td>
<td>参数，<code>?key=value&amp;key=value</code></td>
</tr>
<tr>
<td><code>hash</code></td>
<td>读写</td>
<td>片段，<code>#</code> 后面的内容，如链接 锚点</td>
</tr>
</tbody></table>
<h2 id="3-2-方法"><a href="#3-2-方法" class="headerlink" title="3.2 方法"></a>3.2 方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>assign(url)</code></td>
<td>重定向，记录浏览历史，可以回退，效果同 <code>href</code> 属性</td>
</tr>
<tr>
<td><code>replace(url)</code></td>
<td>重定向，不记录浏览历史，不能回退</td>
</tr>
<tr>
<td><code>reload([flag])</code></td>
<td>无参或 <code>false</code> 表示刷新 <code>F5</code>，<code>true</code> 表示强制刷新 <code>ctrl + F5</code></td>
</tr>
</tbody></table>
<h1 id="四-Navigator"><a href="#四-Navigator" class="headerlink" title="四 Navigator"></a>四 Navigator</h1><table>
<thead>
<tr>
<th>属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>userAgent</code></td>
<td>只读</td>
<td>客户端发送给服务器的 <code>user-agent</code> 头部的值</td>
</tr>
</tbody></table>
<h1 id="五-History"><a href="#五-History" class="headerlink" title="五 History"></a>五 History</h1><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>back()</code></td>
<td>后退</td>
</tr>
<tr>
<td><code>forward()</code></td>
<td>前进</td>
</tr>
<tr>
<td><code>go(n)</code></td>
<td><code>0</code> 表示刷新，正数表示前进 n 个页面，负数表示后退 n 个页面</td>
</tr>
</tbody></table>
<h1 id="六-本地存储（Storage）"><a href="#六-本地存储（Storage）" class="headerlink" title="六 本地存储（Storage）"></a>六 本地存储（Storage）</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><ol>
<li>数据存储在用户浏览器中，只能存字符串，以键值对的形式存储</li>
<li><code>Storage</code> 下有两个子接口 <code>localStorage</code> 和 <code>sessionStorage</code></li>
</ol>
<h2 id="6-2-属性"><a href="#6-2-属性" class="headerlink" title="6.2 属性"></a>6.2 属性</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>length</code></td>
<td>保存的数据项个数</td>
</tr>
</tbody></table>
<h2 id="6-3-方法"><a href="#6-3-方法" class="headerlink" title="6.3 方法"></a>6.3 方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>setItem(key, value)</code></td>
<td>存储数据</td>
</tr>
<tr>
<td><code>getItem(key)</code></td>
<td>获取数据</td>
</tr>
<tr>
<td><code>removeItem(key)</code></td>
<td>移除数据</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清空</td>
</tr>
<tr>
<td><code>key(index)</code></td>
<td>返回指定索引的键，从 0 开始</td>
</tr>
</tbody></table>
<h2 id="6-4-sessionStorage-amp-localStorage"><a href="#6-4-sessionStorage-amp-localStorage" class="headerlink" title="6.4 sessionStorage &amp; localStorage"></a>6.4 sessionStorage &amp; localStorage</h2><table>
<thead>
<tr>
<th>对象</th>
<th>生命周期</th>
<th>数据共享</th>
<th>容量</th>
</tr>
</thead>
<tbody><tr>
<td><code>sessionStorage</code></td>
<td>一次会话（窗口关闭结束）</td>
<td>本页面</td>
<td><code>≈ 5M</code></td>
</tr>
<tr>
<td><code>localStorage</code></td>
<td>长期</td>
<td>本页面和其它页面</td>
<td><code>≈ 20M</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/anyeansan.github.io/2020/11/08/UI/Promise/</url>
    <content><![CDATA[<h1 id="二-promise"><a href="#二-promise" class="headerlink" title="二 promise"></a>二 promise</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol>
<li>Promise 对象本质上表示的是一系列操作的中间状态，或者说是未来某时刻一个操作完成或失败后返回的结果。</li>
<li>Promise 的回调函数不是正常的异步任务（宏任务），而是微任务（microtask）<ul>
<li>正常异步任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常异步任务</li>
</ul>
</li>
</ol>
<h2 id="2-2-promise-状态"><a href="#2-2-promise-状态" class="headerlink" title="2.2 promise 状态"></a>2.2 promise 状态</h2><h3 id="1-三种状态"><a href="#1-三种状态" class="headerlink" title="1 三种状态"></a>1 三种状态</h3><ol>
<li><code>pending</code> ：初始状态，初始化 promise 时的状态</li>
<li><code>fulfilled</code>：异步操作成功</li>
<li><code>rejected</code>：异步操作失败</li>
</ol>
<h3 id="2-说明"><a href="#2-说明" class="headerlink" title="2 说明"></a>2 说明</h3><ol>
<li><code>fulfilled</code> 和 <code>rejected</code> 统称 <code>settled</code> </li>
<li><code>resolved</code><ol>
<li>promise 已经 <code>settled</code></li>
<li>promise 已经使用另一个promise（B）来resolve <ul>
<li>此时promise的状态由B来决定，可能是<code>pending fulfilled rejected</code> 的任何一种</li>
</ul>
</li>
</ol>
</li>
<li><code>unresolved</code> &amp; <code>resolved</code><ul>
<li><code>unresolved</code> ：promise的状态只能是pending</li>
<li><code>resolved</code>：promise的状态可能是pending、fulfilled、rejected 的任何一种</li>
</ul>
</li>
</ol>
<h2 id="2-3-Promise-API"><a href="#2-3-Promise-API" class="headerlink" title="2.3 Promise API"></a>2.3 Promise API</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise(executor)</span><br><span class="line">// executor</span><br><span class="line">function(resolve, reject) &#123;&#125;</span><br><span class="line">// 或</span><br><span class="line">(resolve, reject) =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>executor</code><ol>
<li>指带有 resolve 和 reject 两个参数的函数</li>
<li>Promise构造函数执行时立即调用executor 函数</li>
<li>resolve 和 reject 是JavaScript 提供提供的两个函数<ol>
<li>resolve被调用时，将promise的状态改为<code>fulfilled</code></li>
<li>reject被调用时，将promise的状态改为<code>rejected</code></li>
</ol>
</li>
<li>如果executor内部出错，将promise的状态改为<code>rejected</code>，且忽略executor返回值</li>
</ol>
</li>
</ul>
<h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2 静态方法"></a>2 静态方法</h3><ol>
<li><p><code>Promise.resolve(value)</code></p>
<ul>
<li>返回一个以给定值解析后的Promise 对象。</li>
<li>value<ol>
<li>如果该value值为promise，返回这个promise；</li>
<li>如果该value值是thenable（即带有”then” 方法），会将thenable对象包装为promise并返回;</li>
<li>否则，返回的promise将以此value值完成，即此promise的成功值是value，也就是then方法中第一个函数的参数。</li>
</ol>
</li>
</ul>
</li>
<li><p><code>Promise.reject(reason)</code></p>
<ul>
<li>返回一个带有拒绝原因的Promise对象</li>
<li>reason<ul>
<li>拒绝的原因，通常是一个Error对象，也就是then方法中第二个函数的参数</li>
</ul>
</li>
</ul>
</li>
<li><p><code>Promise.all(iterable)</code><br>// TODO</p>
<ul>
<li>注：iterable中非promise元素会被转为promise</li>
</ul>
<ol>
<li>如果参数是一个空的可迭代对象<ol>
<li>返回一个已完成（already resolved）的 Promise。</li>
<li>此promise会调用成功回调函数，成功值是空数组</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promis.all([]).then(</span><br><span class="line">	value =&gt; console.log(value), // []</span><br><span class="line">	reason =&gt; console.log(reason)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<pre><code>2. 如果iterable参数不包含任何 promise
    1. 返回一个异步完成（asynchronously resolved） Promise
    2. 此promise会调用成功回调函数，成功值是由参数的元素构成的数组</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promis.all(&quot;abc&quot;).then(</span><br><span class="line">	value =&gt; console.log(value), // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class="line">	reason =&gt; console.log(reason)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<pre><code>3. 其它情况下返回一个处理中（pending）的Promise
    1. 如果iterable参数中包含的所有promise都成功，则此返回的promise调用成功函数，成功值为一个数组，数组元素为所有promise的成功值和非promise的值</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">	resolve(&apos;p1-success&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">Promis.all([p1, 3, 4, &apos;abc&apos;]).then(</span><br><span class="line">	value =&gt; console.log(value), // [&apos;p1-success&apos;,3,4,&apos;abc&apos;]</span><br><span class="line">	reason =&gt; console.log(reason)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<pre><code>2. 如果iterable参数中 包含的promise 有一个失败，则此返回的promise调用失败函数，失败原因是第一个失败的promise的原因</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">	reject(&apos;p1-fail&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">Promis.all([p1, 3, 4, &apos;abc&apos;]).then(</span><br><span class="line">	value =&gt; console.log(value), </span><br><span class="line">	reason =&gt; console.log(reason) // p1-fail</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>Promise.allSettled(iterable)</code><ul>
<li>返回一个fulfilled状态的promise，成功值为一个对象数组，每个对象包含两个属性，表示对应的iterable元素的结果</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;status: &quot;fulfilled&quot;, value: ...&#125;</span><br><span class="line">&#123;status: &quot;rejected&quot;, reason: ...&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>Promise.race(iterable)</code><ul>
<li>返回一个promise，此返回promise的状态取决于iterable参数中promise 成功/失败的最快的那个。 </li>
</ul>
</li>
</ol>
<h3 id="3-原型方法"><a href="#3-原型方法" class="headerlink" title="3 原型方法"></a>3 原型方法</h3><h4 id="1-then"><a href="#1-then" class="headerlink" title="1 then"></a>1 then</h4><h5 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">then(onFulfilled[, onRejected])</span><br><span class="line"></span><br><span class="line">then(value =&gt; &#123;</span><br><span class="line">	// fulfillment</span><br><span class="line">&#125;, reason =&gt; &#123;</span><br><span class="line">	// rejection</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="2-参数"><a href="#2-参数" class="headerlink" title="2 参数"></a>2 参数</h5><ul>
<li>onFulfilled    ，可选<ul>
<li>当 Promise 变成fulfilled状态时调用的函数，参数为 <code>fulfillment  value</code>，表示成功的值</li>
<li>如果onFulfilled不是一个函数，会被忽略，内部变成<code>(value) =&gt; value</code>，即将<code>fulfillment  value</code>原样返回</li>
</ul>
</li>
<li>onRejected，可选<ul>
<li>当 Promise 变成rejected状态时调用的函数，参数为<code>rejection reason</code>，表示失败原因</li>
<li>如果onRejected不是函数，则会在内部被替换为一个 “Thrower” 函数，抛出失败原因</li>
</ul>
</li>
</ul>
<h5 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3 返回值"></a>3 返回值</h5><ol>
<li>如果then没有参数，或者要执行的回调函数对应的参数不是一个函数，则返回的promise与原promise状态相同，且成功值和失败原因也相同。</li>
<li>如果then没有返回值，则返回的promise，状态为fulfilled，成功值为undefined</li>
<li>如果then返回一个值，则返回的promise，状态为fulfilled，成功值为返回的值</li>
<li>如果then抛出错误，则返回的promise，状态为rejected，失败原因为抛出的错误</li>
<li>如果then返回一个promise（三种状态都有可能），则可以当作是最终返回的promise，即状态，成功值或者失败原因都是一样的</li>
</ol>
<table>
<thead>
<tr>
<th>内部返回值</th>
<th>最终返回promise状态</th>
<th>成功的值</th>
<th>失败原因</th>
</tr>
</thead>
<tbody><tr>
<td>错误</td>
<td>rejected</td>
<td>-</td>
<td>错误</td>
</tr>
<tr>
<td>无</td>
<td>fulfilled</td>
<td>undefined</td>
<td>-</td>
</tr>
<tr>
<td>非promise的值</td>
<td>fulfilled</td>
<td>非promise的值</td>
<td>-</td>
</tr>
<tr>
<td>promise值</td>
<td>同promise值</td>
<td>同promise值</td>
<td>同promise值</td>
</tr>
</tbody></table>
<h4 id="2-catch"><a href="#2-catch" class="headerlink" title="2 catch"></a>2 catch</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">catch(onRejected)</span><br><span class="line"></span><br><span class="line">catch(reason =&gt; &#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li>等同于 <code>then(undefined, onRejected)</code></li>
<li>catch之前任一promise状态变为rejected，如果此promise自己没有处理，则会被catch捕获 </li>
<li>catch返回一个promise，其状态取决于catch内部onRejected函数<ol>
<li>如果onRejected返回一个rejected状态的Promise或着抛出一个错误，则catch返回的promise状态为rejected</li>
<li>否则，catch返回的promise状态为fulfilled</li>
</ol>
</li>
</ol>
<h4 id="3-finally"><a href="#3-finally" class="headerlink" title="3 finally"></a>3 finally</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">finally(onFinally)</span><br><span class="line"></span><br><span class="line">finally(() =&gt; &#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>onFinally<ul>
<li>Promise 结束后，无论结果是fulfilled或者是rejected，都会执行onFinally回调函数</li>
</ul>
</li>
<li>返回一个设置了 finally 回调函数的Promise对象</li>
</ul>
<h1 id="三-async-await"><a href="#三-async-await" class="headerlink" title="三 async / await"></a>三 async / await</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol>
<li>async/await 是promise 的语法糖</li>
<li>async用来声明一个异步函数（async function），await操作符只能用在异步函数中</li>
</ol>
<h2 id="3-2-async"><a href="#3-2-async" class="headerlink" title="3.2 async"></a>3.2 async</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function show()&#123;&#125;</span><br><span class="line"></span><br><span class="line">let show = async function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">	async show()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class xxx&#123;</span><br><span class="line">	async show() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>异步函数返回一个promise<ol>
<li>如果异步函数正常执行，则返回的promise会调用成功函数，成功值为异步函数内部返回值。</li>
<li>如果异步函数抛出异常，则返回的promise会调用失败函数，失败原因是抛出异常</li>
</ol>
</li>
<li>错误处理<ul>
<li>async返回一个promise，可以调用catch来处理错误</li>
</ul>
</li>
</ol>
<h2 id="3-3-await"><a href="#3-3-await" class="headerlink" title="3.3 await"></a>3.3 await</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[return_value] = await expression;</span><br></pre></td></tr></table></figure>

<ol>
<li>await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成<ol>
<li>如果表达式是一个promise，则返回值为promise的处理结果</li>
<li>如果表达式不是一个promise，则返回该值本身</li>
</ol>
</li>
<li>错误处理<ol>
<li>await后边的promise出错，相当于async函数返回的promise为reject，所以可以在外部调用catch方法处理</li>
<li>可以在内部用try…catch…处理</li>
</ol>
</li>
<li>await的并行<ol>
<li>让promise先执行后再使用await处理结果</li>
<li>使用 Promise.all() 处理多个promise并行执行</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>JS执行机制</title>
    <url>/anyeansan.github.io/2020/11/08/UI/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>JavaScript 是单线程语言</li>
<li>单线程意味着，所有任务都需要排队，前一个任务结束，才会执行后一个任务</li>
<li>HTML 5 提出 Web Worker 标准，允许 JavaScript 创建多线程，于是 JS 中出现了同步和异步</li>
</ol>
<h1 id="二-JS-任务"><a href="#二-JS-任务" class="headerlink" title="二 JS 任务"></a>二 JS 任务</h1><h2 id="2-1-任务分类（类型）"><a href="#2-1-任务分类（类型）" class="headerlink" title="2.1 任务分类（类型）"></a>2.1 任务分类（类型）</h2><h3 id="1-同步任务"><a href="#1-同步任务" class="headerlink" title="1 同步任务"></a>1 同步任务</h3><ol>
<li>在主线程上排队执行的任务，形成一个执行栈</li>
<li>前一个任务执行完毕，才能执行后一个任务</li>
</ol>
<h3 id="2-异步任务"><a href="#2-异步任务" class="headerlink" title="2 异步任务"></a>2 异步任务</h3><ol>
<li>JS 的异步是通过回调函数实现的</li>
<li>异步任务相关回调函数会进入任务队列（消息队列）</li>
<li>异步任务不具有“堵塞”效应</li>
<li>异步任务通常有三种<ol>
<li>普通事件，如 <code>click resize ...</code></li>
<li>资源加载，如 <code>load, error ...</code></li>
<li>定时器</li>
</ol>
</li>
</ol>
<h2 id="2-2-任务分类（机制）"><a href="#2-2-任务分类（机制）" class="headerlink" title="2.2 任务分类（机制）"></a>2.2 任务分类（机制）</h2><h3 id="1-宏任务（macrotask）"><a href="#1-宏任务（macrotask）" class="headerlink" title="1 宏任务（macrotask）"></a>1 宏任务（macrotask）</h3><ol>
<li>整个脚本代码（第一个宏任务）</li>
<li>定时器（setTimeout setInterval ..）</li>
<li>事件 I/O</li>
<li>UI 渲染</li>
<li>…</li>
</ol>
<h3 id="2-微任务（microtask）"><a href="#2-微任务（microtask）" class="headerlink" title="2 微任务（microtask）"></a>2 微任务（microtask）</h3><ol>
<li><code>promise.then</code></li>
<li>…</li>
</ol>
<h1 id="三-JS-执行机制"><a href="#三-JS-执行机制" class="headerlink" title="三 JS 执行机制"></a>三 JS 执行机制</h1><h2 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h2><ol>
<li>任务队列（task queue）<ul>
<li>用于存放异步任务</li>
<li>根据异步任务的类型，可以存在多个任务队列</li>
</ul>
</li>
<li>事件循环（Event Loop）<ul>
<li>同步任务执行完毕后，引擎会在任务队列循环检查，如果有可以执行的异步任务，则结束等待状态，进入主线程开始执行</li>
</ul>
</li>
</ol>
<h2 id="3-2-步骤"><a href="#3-2-步骤" class="headerlink" title="3.2 步骤"></a>3.2 步骤</h2><p><img src="https://gitee.com/anis5/pic/raw/master/UI/JS/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.png" alt=""></p>
<ol>
<li>脚本代码作为第一个宏任务开始执行，同步任务进入主线程执行栈</li>
<li>异步任务（宏任务和微任务）交给各自异步处理进程，当满足条件时（如 事件触发，定时器到时…）<ol>
<li>宏任务进入宏任务队列 <code>macrotask queue</code></li>
<li>微任务进入微任务队列 <code>microtask queue</code></li>
</ol>
</li>
<li>同步任务执行完毕后，事件循环微任务队列，依次读入主线程执行栈并执行</li>
<li>微任务队列完毕后，事件循环宏任务队列，每个宏任务与第一个宏任务一样重复以上步骤</li>
</ol>
<h2 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 有点类似递归的感觉</span><br><span class="line">* 宏任务</span><br><span class="line">	* 同步任务</span><br><span class="line">	* 异步任务</span><br><span class="line">		* 微任务</span><br><span class="line">		* 宏任务</span><br><span class="line">			* 同步任务</span><br><span class="line">			* 异步任务</span><br><span class="line">				* 微任务</span><br><span class="line">				* 宏任务</span><br><span class="line">					* ...</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>JS模块</title>
    <url>/anyeansan.github.io/2020/11/08/UI/JS%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li><a href="https://segmentfault.com/a/1190000015302578" target="_blank" rel="noopener">网上概述</a></li>
<li>ES6 之前有许多方式来实现模块<ul>
<li><code>AMD</code>：用于浏览器</li>
<li><code>CommonJS</code>：用于 Node.js</li>
<li><code>UMD</code>：浏览器/Node.js</li>
</ul>
</li>
<li>ES6 JS有了模块</li>
<li>模块就是一个独立的文件，文件内部的变量，函数，类…外部无法获取</li>
<li>使用模块可以解决全局变量冲突</li>
<li>模块需要隐藏内部实现，只对外开发接口</li>
<li>模块可以避免滥用全局变量，造成代码不可控</li>
<li>模块可以被不同的应用使用，提高编码效率</li>
<li>模块默认运行在严格模式</li>
<li>模块都有独立的顶级作用域，不同模块间不能相互访问，类似函数作用域</li>
<li>模块在导入时只执行一次解析，之后的导入不会再执行模块代码，而使用第一次解析结果，并共享数据</li>
</ol>
<h1 id="三-加载"><a href="#三-加载" class="headerlink" title="三 加载"></a>三 加载</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>异步加载，即模块总是会在所有html解析后才执行</li>
</ul>
<h1 id="四-export"><a href="#四-export" class="headerlink" title="四 export"></a>四 export</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ul>
<li>模块中的功能默认外部无法使用，使用<code>export</code>命令规定模块的对面接口，即将指定功能导出供外部使用。</li>
</ul>
<h2 id="4-2-导出单个"><a href="#4-2-导出单个" class="headerlink" title="4.2 导出单个"></a>4.2 导出单个</h2><ul>
<li><code>export 声明语句</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export let name = &apos;xiaoqiang&apos;;</span><br><span class="line">export let obj = &#123;&#125;;</span><br><span class="line">export function show() &#123;&#125;;</span><br><span class="line">export class User &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-导出列表"><a href="#4-3-导出列表" class="headerlink" title="4.3 导出列表"></a>4.3 导出列表</h2><ul>
<li><code>export { name1, name2, …, nameN };</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export let name = &apos;xiaoqiang&apos;;</span><br><span class="line">export let obj = &#123;&#125;;</span><br><span class="line">export function show() &#123;&#125;;</span><br><span class="line">export class User &#123;&#125;</span><br><span class="line">export &#123;name, obj, show, User&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-别名"><a href="#4-4-别名" class="headerlink" title="4.4 别名"></a>4.4 别名</h2><ul>
<li><code>export { variable1 as name1, variable2 as name2, …, nameN };</code></li>
</ul>
<h2 id="4-5-默认导出"><a href="#4-5-默认导出" class="headerlink" title="4.5 默认导出"></a>4.5 默认导出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default expression;</span><br><span class="line">export default function (…) &#123; … &#125; // also class, function*</span><br><span class="line">export default function name1(…) &#123; … &#125; // also class, function*</span><br><span class="line">export &#123; name1 as default, … &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>默认导出接口只能有一个，但默认导出可以与普通导出共存</li>
<li>本质上，<code>export default</code>就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字</li>
<li>默认导出时，函数和类可以具名也可以匿名，变量不能具名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default let a = 1; // 错误</span><br><span class="line">let a = 1;</span><br><span class="line">export default a; // 正确，相当于把a的值赋予default</span><br><span class="line">export default 1; // 正确，相当于直接把值赋予default</span><br></pre></td></tr></table></figure>

<h1 id="五-import（静态导入）"><a href="#五-import（静态导入）" class="headerlink" title="五 import（静态导入）"></a>五 import（静态导入）</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol>
<li>import用于导入其它模块提供的功能。</li>
<li>import导入的变量名要与export导出的一致</li>
<li>import导入的变量是只读的</li>
<li>import命令具有提升效果，会提升到整个模块的头部，首先执行 </li>
<li>import是静态导入，不能使用表达式和变量</li>
<li>在浏览器中引用模块必须添加路径，但在打包工具如webpack中则不需要，因为他们有自己的存放方式。</li>
</ol>
<h2 id="5-2-导入所有导出接口"><a href="#5-2-导入所有导出接口" class="headerlink" title="5.2 导入所有导出接口"></a>5.2 导入所有导出接口</h2><ul>
<li><code>import * as name from &quot;module-name&quot;;</code><ul>
<li><code>name</code><ul>
<li>导入模块的命名空间</li>
</ul>
</li>
<li><code>module-name</code><ul>
<li>要导入的模块。通常是包含目标模块的.js文件的相对或绝对路径名，可以不包括.js扩展名。</li>
</ul>
</li>
<li>使用<code>default</code>获取默认导出</li>
</ul>
</li>
</ul>
<h2 id="5-3-导入指定导出接口"><a href="#5-3-导入指定导出接口" class="headerlink" title="5.3 导入指定导出接口"></a>5.3 导入指定导出接口</h2><ul>
<li><code>import { export1, export2, ..., exportN } from &quot;module-name&quot;;</code></li>
</ul>
<h2 id="5-4-别名"><a href="#5-4-别名" class="headerlink" title="5.4 别名"></a>5.4 别名</h2><ul>
<li><code>import { export1 as alias1, export2, ..., exportN } from &quot;module-name&quot;;</code></li>
</ul>
<h2 id="5-5-导入默认导出"><a href="#5-5-导入默认导出" class="headerlink" title="5.5 导入默认导出"></a>5.5 导入默认导出</h2><ul>
<li><code>import defaultExport from &quot;module-name&quot;;</code><ol>
<li>导入默认导出时名称任意</li>
<li>由于默认导出只有一个，所以不需要<code>{}</code></li>
</ol>
</li>
</ul>
<h2 id="5-6-混合导入"><a href="#5-6-混合导入" class="headerlink" title="5.6 混合导入"></a>5.6 混合导入</h2><ul>
<li><code>import defaultExport, { export1, export2, ..., exportN} from &quot;module-name&quot;;</code></li>
</ul>
<h1 id="六-export-default"><a href="#六-export-default" class="headerlink" title="六 export default"></a>六 export default</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><ol>
<li>使用<code>import</code>命令时，需要知道<code>export</code>导出的变量名。</li>
<li><code>export default</code> 本质是导出一个名为<code>defualt</code>的变量，使用<code>import</code>导入时可以以任意名称导入。</li>
<li>一个模块只能有一个默认输出，可以与普通导出共存</li>
</ol>
<h2 id="6-2-语法"><a href="#6-2-语法" class="headerlink" title="6.2 语法"></a>6.2 语法</h2><ol>
<li><code>export default expression</code><ul>
<li>将<code>expression</code>表达式的值赋给<code>default</code>导出</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a = 1;</span><br><span class="line">export default a; // 将a的值1赋给default</span><br><span class="line">export default 1; // 将1赋给default</span><br><span class="line">export default let a = 1; // 错误 因为let a = 1不能计算出一个值</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>export default function(){}  // also class, function*</code><ul>
<li>导出匿名函数/类，名称为<code>default</code></li>
</ul>
</li>
<li><code>export default function name(…) { … } // also class, function*</code><ul>
<li>导出具名函数/类，名称为<code>default</code>，原有名称会被忽略</li>
</ul>
</li>
<li><code>export { name1 as default, … };</code><ul>
<li>由于 <code>export default</code> 本质是导出一个名为<code>default</code>的变量</li>
<li>可以使用<code>export</code>导出一个别名为<code>default</code>的变量</li>
</ul>
</li>
</ol>
<h1 id="七-export-import"><a href="#七-export-import" class="headerlink" title="七 export + import"></a>七 export + import</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ol>
<li>可以将导入的模块再次导出</li>
<li>如果<code>export</code>和<code>import</code>结合在一起，其实就相当于一个转发，并没有导入到当前模块，即当前模块不能使用导入导出的功能。</li>
</ol>
<h2 id="7-2-语法"><a href="#7-2-语法" class="headerlink" title="7.2 语法"></a>7.2 语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export * from …;</span><br><span class="line">export &#123; name1, name2, …, nameN &#125; from …;</span><br><span class="line">export &#123; import1 as name1, import2 as name2, …, nameN &#125; from …;</span><br><span class="line">export &#123; default &#125; from …;</span><br></pre></td></tr></table></figure>

<h1 id="八-import-（动态导入）"><a href="#八-import-（动态导入）" class="headerlink" title="八 import()（动态导入）"></a>八 import()（动态导入）</h1><ol>
<li>接收参数与静态导入一致 </li>
<li>使用<code>import()</code> 函数可以动态导入模块，它返回一个 promise 对象，可以按需加载</li>
<li><code>import()</code> 函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块</li>
</ol>
<h1 id="九-工具"><a href="#九-工具" class="headerlink" title="九 工具"></a>九 工具</h1><ol>
<li>转译器 Transpiler：将现代 JS 代码翻译成所有浏览器都能看懂的代码<ul>
<li>Babel</li>
</ul>
</li>
<li>打包器 Bundler<ul>
<li>WebPack</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>JS类</title>
    <url>/anyeansan.github.io/2020/11/08/UI/JS%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>class 只是语法糖，为了让类的声明与继承更加简洁清晰，底层实现机制依然是原型继承，与其它语言的 class 不一样</li>
<li>class 其实就是函数，<code>typeof 类 -&gt; function</code></li>
<li>class 内部代码始终以严格模式执行</li>
<li>class 不存在变量提升</li>
<li>class 中的属性名可以采用表达式<code>[]</code></li>
<li>class 中定义的属性都是实例属性，定义的方法都是原型方法且不可枚举</li>
</ol>
<h1 id="二-语法"><a href="#二-语法" class="headerlink" title="二 语法"></a>二 语法</h1><h2 id="2-1-类"><a href="#2-1-类" class="headerlink" title="2.1 类"></a>2.1 类</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 类声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名 </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 类表达式</span></span><br><span class="line"><span class="keyword">let</span> 类名= <span class="class"><span class="keyword">class</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种方式都不会提升</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-构造函数"><a href="#2-2-构造函数" class="headerlink" title="2.2 构造函数"></a>2.2 构造函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数语法</span></span><br><span class="line"><span class="keyword">constructor</span>(参数列表) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类默认构造函数</span></span><br><span class="line"><span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类默认构造函数</span></span><br><span class="line"><span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">	<span class="keyword">super</span>(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用类 <code>new</code> 一个对象时会自动调用构造函数</li>
<li>如果省略，则会有默认构造函数</li>
<li><code>constructor</code> 默认返回实例对象（即 <code>this</code>），可以改为返回另一个对象</li>
<li>类的原型的 <code>constructor</code> 属性指向类本身：<code>类.prototype.constructor = 类</code></li>
</ol>
<h2 id="2-3-属性-amp-方法"><a href="#2-3-属性-amp-方法" class="headerlink" title="2.3 属性 &amp; 方法"></a>2.3 属性 &amp; 方法</h2><h3 id="1-实例属性"><a href="#1-实例属性" class="headerlink" title="1 实例属性"></a>1 实例属性</h3><ol>
<li><p>使用<code>this.</code> 定义在<code>constructor</code>中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(age) &#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在类中直接定义的属性就是实例属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	age = <span class="number">18</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-原型方法"><a href="#2-原型方法" class="headerlink" title="2 原型方法"></a>2 原型方法</h3><ol>
<li><p>在类的原型上定义方法，是可枚举的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">User.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在类中直接定义的方法就是原型方法，且不可枚举（non-enumerable）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	show()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="3-静态属性-方法"><a href="#3-静态属性-方法" class="headerlink" title="3 静态属性/方法"></a>3 静态属性/方法</h3><ol>
<li><p>定义在类上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">User.age = <span class="number">10</span>;</span><br><span class="line">User.show() = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在类中定义的属性/方法前加<code>static</code>关键字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> age = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">// 静态方法可以包含 this 关键字，this 指的是类本身，而不是实例对象 </span></span><br><span class="line">	<span class="keyword">static</span> show() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="4-私有属性-方法"><a href="#4-私有属性-方法" class="headerlink" title="4 私有属性 / 方法"></a>4 私有属性 / 方法</h3><h4 id="1-利用-Symbol"><a href="#1-利用-Symbol" class="headerlink" title="1 利用 Symbol"></a>1 利用 Symbol</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _name = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> _show = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>[_name] = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [_show]()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-利用集合"><a href="#2-利用集合" class="headerlink" title="2 利用集合"></a>2 利用集合</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _name = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> _show = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        _name.set(<span class="keyword">this</span>, name);</span><br><span class="line">        _show.set(<span class="keyword">this</span>, () =&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-约定"><a href="#3-约定" class="headerlink" title="3 约定"></a>3 约定</h4><ol>
<li><p>私有属性：在属性名前加 <code>#</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	#phone = '13800000000';   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>私有方法：以表达式形式定义方法并在方法前加<code>#</code> ，可以理解为就是定义私有属性，不过属性的值是一个函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">	#say = function() &#123;&#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="5-受保护属性-方法"><a href="#5-受保护属性-方法" class="headerlink" title="5 受保护属性 / 方法"></a>5 受保护属性 / 方法</h3><ul>
<li>在属性/方法名前加 <code>_</code>，这只是约定不是语法也不是规范</li>
<li>可以通过 <code>symbol weakmap ...</code> 人为实现保护</li>
</ul>
<h2 id="2-4-访问器-getter-setter"><a href="#2-4-访问器-getter-setter" class="headerlink" title="2.4 访问器 getter/setter"></a>2.4 访问器 getter/setter</h2><ul>
<li>类中同样可以使用访问器，且访问器也是定义在属性的属性描述符上</li>
</ul>
<h1 id="三-class-的继承"><a href="#三-class-的继承" class="headerlink" title="三 class 的继承"></a>三 class 的继承</h1><h2 id="3-1-extends"><a href="#3-1-extends" class="headerlink" title="3.1 extends"></a>3.1 extends</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>() &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 子类构造函数第一行必须先调用父类构造函数</span></span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-super"><a href="#3-2-super" class="headerlink" title="3.2 super"></a>3.2 super</h2><h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1 问题"></a>1 问题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 子 父：在子类中调用父类方法</span></span><br><span class="line">子：<span class="keyword">this</span>.__proto__.__proto__</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 子 父 爷：在子类中调用父类方法，父类方法中又调用了父类的父类的方法</span></span><br><span class="line">子：<span class="keyword">this</span>.__proto__.__proto__</span><br><span class="line">父：<span class="keyword">this</span>.__proto__</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 父 爷：直接在父类中调用父类的父类的方法</span></span><br><span class="line">父：<span class="keyword">this</span>.__proto__.__proto__</span><br></pre></td></tr></table></figure>

<ul>
<li>如果只有双层继承，使用 <code>this</code>是可以的，如果有多重继承，同一个类中的代码不同情况是不一样的</li>
</ul>
<h3 id="2-用法"><a href="#2-用法" class="headerlink" title="2 用法"></a>2 用法</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li><p>super 只能在类或对象的方法中使用，而不能在函数中使用</p>
</li>
<li><p>使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误，无法看出是函数还是对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">super</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2-调用父类构造"><a href="#2-调用父类构造" class="headerlink" title="2 调用父类构造"></a>2 调用父类构造</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此时 super 代表父类的构造函数</span></span><br><span class="line"><span class="keyword">super</span>([<span class="built_in">arguments</span>]);</span><br></pre></td></tr></table></figure>

<h4 id="3-调用父类方法"><a href="#3-调用父类方法" class="headerlink" title="3 调用父类方法"></a>3 调用父类方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此时 super 代表父类原型对象，如果是静态方法则 super 代表父类本身</span></span><br><span class="line"><span class="keyword">super</span>.functionOnParent([<span class="built_in">arguments</span>]);</span><br></pre></td></tr></table></figure>

<h2 id="3-3-原生构造函数的继承"><a href="#3-3-原生构造函数的继承" class="headerlink" title="3.3 原生构造函数的继承"></a>3.3 原生构造函数的继承</h2><ol>
<li>之前，这些内置的构造函数如<code>Object() Array() ...</code> 是无法继承的</li>
<li>ES6 允许继承</li>
</ol>
<h2 id="3-4-mixin"><a href="#3-4-mixin" class="headerlink" title="3.4 mixin"></a>3.4 mixin</h2><ol>
<li>创建一个 mixin 类，包含许多供其它类使用的方法</li>
<li>将 mixin 类合并到要使用功能的类的原型上</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>JS原型</title>
    <url>/anyeansan.github.io/2020/11/08/UI/JS%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-原型"><a href="#1-1-原型" class="headerlink" title="1.1 原型"></a>1.1 原型</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/JS/%E5%8E%9F%E5%9E%8B.png" alt=""></p>
<h3 id="1-proto"><a href="#1-proto" class="headerlink" title="1 __proto__"></a>1 <code>__proto__</code></h3><ol>
<li><p><code>__proto__</code> 是浏览器实现的非 JavaScript 标准的属性，在ES6写入了附录，用于获取或设置对象的原型，由于非标准，浏览器有这个属性，其它环境未必有。建议使用 Object中 的方法 替代<code>__proto__</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">- <span class="built_in">Object</span>.getPrototypeOf(obj)</span><br><span class="line">- <span class="built_in">Object</span>.setPrototypeOf(obj, prototype)</span><br><span class="line">- <span class="built_in">Object</span>.create(proto[, propertiesObject])</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>obj.__proto__</code> 并非是普通的属性访问方式，而是通过 <code>getter/setter</code> 访问器，可以理解为 <code>prototype</code> 属性的 <code>getter/setter</code> 实现</p>
</li>
<li><p>每个对象都有 <code>__proto__</code> 属性，指向它的构造函数的原型对象，即如果A对象是由B函数构造的，则 <code>A.__proto__ === B.prototype</code></p>
<ol>
<li>普通对象的构造函数是其对应的构造函数，原型对象也是普通对象，其默认构造函数是 Object，则<ul>
<li><code>对象.__proto__ === 构造函数.prototype</code></li>
<li><code>原型对象.__proto__ === Object.prototype</code></li>
</ul>
</li>
<li>原型对象中有两个特殊<ol>
<li><code>Object.prototype</code>：它是原型链的顶端，<code>Object.prototype.__proto__ === null</code></li>
<li><code>Function.prototype</code><ul>
<li>它是原型对象，但不属于普通对象而属于函数对象</li>
<li>它是函数对象，但它没有 <code>prototype</code> 属性</li>
</ul>
</li>
</ol>
</li>
<li>函数对象（包括 Function 自身）的构造函数是 Function，则 <ul>
<li><code>函数.__proto__ === Function.prototype</code></li>
<li><code>Function.__proto__ === Function.prototype</code></li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="2-prototype"><a href="#2-prototype" class="headerlink" title="2 prototype"></a>2 <code>prototype</code></h3><ol>
<li>每个构造函数都有 <code>prototype</code> 属性，指向其原型对象，原型对象用于所有实例共享属性和方法</li>
<li>函数作为对象有 <code>__proto__</code> 属性，又可以作为构造函数有<code>prototype</code> 属性</li>
<li>原型的作用是让该构造函数所实例化的对象们都可以找到公用的属性和方法，所以 JS 的继承是通过 <code>prototype</code> 实现的</li>
</ol>
<h3 id="3-constructor"><a href="#3-constructor" class="headerlink" title="3 constructor"></a>3 <code>constructor</code></h3><ul>
<li>只有原型对象才有 <code>constructor</code> 属性，指向对应构造函数<ul>
<li><code>实例对象.__proto__ === 原型对象</code></li>
<li><code>构造函数.prototype === 原型对象</code></li>
<li><code>原型对象.constructor === 构造函数</code></li>
</ul>
</li>
</ul>
<h2 id="1-2-原型链"><a href="#1-2-原型链" class="headerlink" title="1.2 原型链"></a>1.2 原型链</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/JS/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt=""></p>
<ul>
<li>对象有自己的原型对象，而对象又可以充当其他对象的原型，就会形成一个“原型链”（prototype chain）</li>
</ul>
<h2 id="1-3-new"><a href="#1-3-new" class="headerlink" title="1.3 new"></a>1.3 new</h2><h3 id="1-new的执行过程"><a href="#1-new的执行过程" class="headerlink" title="1 new的执行过程"></a>1 new的执行过程</h3><ol>
<li>创建一个空对象 <code>let obj = {};</code></li>
<li>将新建对象的 <code>__proto__</code> 指向构造函数的原型对象，<code>obj.__proto__ = 构造函数.prototype</code></li>
<li>将新建对象作为构造函数执行的上下文，即将构造函数内部的 <code>this</code> 指向新建对象</li>
<li>执行构造函数，如果构造函数没有返回引用类型的值，则返回新建对象</li>
</ol>
<h3 id="2-自定义-new"><a href="#2-自定义-new" class="headerlink" title="2 自定义 new"></a>2 自定义 new</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myNew = <span class="function"><span class="keyword">function</span>(<span class="params">cons, args</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> obj = &#123;&#125;; <span class="comment">// 步骤1</span></span><br><span class="line">	obj.__proto__ = cons.prototype; <span class="comment">// 步骤2</span></span><br><span class="line">	<span class="comment">// let obj = Object.create(cons.prototype); 步骤1，2合在一起</span></span><br><span class="line">	<span class="keyword">let</span> result = cons.apply(obj, args); <span class="comment">// 步骤3</span></span><br><span class="line">	<span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj; <span class="comment">// 步骤4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-new-target-属性"><a href="#3-new-target-属性" class="headerlink" title="3 new.target 属性"></a>3 <code>new.target</code> 属性</h3><ul>
<li>用来检测函数是否通过<code>new</code>或者<code>Reflect.construct()</code>调用的<ol>
<li>如果在普通函数中使用，返回 <code>undefined</code></li>
<li>在构造函数中使用指向被 new 调用的构造函数</li>
<li>在 <code>class</code> 的 <code>constructor</code> 函数中使用指向被 new 调用的 <code>class</code></li>
</ol>
</li>
</ul>
<h1 id="二-构造函数中的属性和方法"><a href="#二-构造函数中的属性和方法" class="headerlink" title="二 构造函数中的属性和方法"></a>二 构造函数中的属性和方法</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> age = <span class="number">18</span>; <span class="comment">// 私有属性</span></span><br><span class="line">	<span class="keyword">let</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// 私有方法</span></span><br><span class="line">	<span class="keyword">this</span>.name = name; <span class="comment">// 实例属性</span></span><br><span class="line">	<span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;<span class="comment">// 实例方法</span></span><br><span class="line">&#125;</span><br><span class="line">User.country = <span class="string">'中国'</span>; <span class="comment">// 静态属性</span></span><br><span class="line">User.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// 静态方法</span></span><br><span class="line">User.prototype.gender = <span class="string">'男'</span>; <span class="comment">// 原型属性</span></span><br><span class="line">User.prototype.change = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// 原型方法</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>私有属性 / 方法</td>
<td>在对象内部使用 <code>var/let/const</code>声明的属性/方法（严格来说只是内部的局部变量不属于对象）</td>
</tr>
<tr>
<td>实例属性 / 方法</td>
<td>在对象内部使用<code>this.</code>声明的属性/方法</td>
</tr>
<tr>
<td>静态属性 / 方法</td>
<td>定义在构造函数上的属性/方法</td>
</tr>
<tr>
<td>原型属性 / 方法</td>
<td>定义在构造函数原型上的属性/方法 ，<strong>原型方法默认可枚举</strong></td>
</tr>
</tbody></table>
<h1 id="三-继承"><a href="#三-继承" class="headerlink" title="三 继承"></a>三 继承</h1><h2 id="3-1-继承原理"><a href="#3-1-继承原理" class="headerlink" title="3.1 继承原理"></a>3.1 继承原理</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/JS/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF.png" alt=""></p>
<ul>
<li><code>1 -&gt; 2</code>：将子类构造函数的原型对象的原型指向父类构造函数的原型对象</li>
</ul>
<h2 id="3-2-设置原型方式"><a href="#3-2-设置原型方式" class="headerlink" title="3.2 设置原型方式"></a>3.2 设置原型方式</h2><ol>
<li><p>设置构造函数原型，使用函数的 <code>prototype</code> 属性</p>
</li>
<li><p>设置对象的原型</p>
<ol>
<li><p>Object 的方法，创建对象时指定原型（只是定义无法获取）：<code>Object.create(proto[, propertiesObject])</code> </p>
</li>
<li><p>使用对象的属性<code>__proto__</code> 获取或设置原型，在浏览器之外的环境可能不行。</p>
</li>
<li><p>Object 的方法，与<code>__proto__</code>效果一样，但是是 JS 标准</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj)</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, prototype)</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h2 id="3-3-实现继承的方式"><a href="#3-3-实现继承的方式" class="headerlink" title="3.3 实现继承的方式"></a>3.3 实现继承的方式</h2><h3 id="1-原型链-1"><a href="#1-原型链-1" class="headerlink" title="1 原型链-1"></a>1 原型链-1</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/JS/%E7%BB%A7%E6%89%BF1.png" alt=""></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">A.prototype.__proto__ = B.prototype;</span><br></pre></td></tr></table></figure>

<ul>
<li>将子类构造函数的原型对象的原型直接指向父类构造函数的原型</li>
<li>好处<ul>
<li>父类原型在子类原型链上，则子类可以继承父类的原型属性/方法</li>
</ul>
</li>
<li>弊端<ul>
<li>创建子类时不会调用父类构造函数，无法继承父类的实例属性/方法</li>
</ul>
</li>
</ul>
<h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2 构造函数"></a>2 构造函数</h3><ul>
<li><p>在子类构造函数中通过<code>call/apply</code>调用父类构造函数，并指定this为子类对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fu</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Zi</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">	Fu(name,age); <span class="comment">// 不行，因为直接调用时，父类构造函数this是指向window的</span></span><br><span class="line">	Fu.call(<span class="keyword">this</span>, name, age); </span><br><span class="line">	Fu.apply(<span class="keyword">this</span>, [name, age])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>好处</p>
<ul>
<li>创建的子类实例具备父类实例属性/方法</li>
</ul>
</li>
<li><p>弊端</p>
<ol>
<li>只是子类的实例，不是父类的实例（只是通过调用父类构造函数模拟继承）</li>
<li>无法继承父类原型属性/方法</li>
</ol>
</li>
</ul>
<h3 id="3-原型链-2"><a href="#3-原型链-2" class="headerlink" title="3 原型链-2"></a>3 原型链-2</h3><h4 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h4><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/JS/%E7%BB%A7%E6%89%BF2.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A.prototype = new B();</span><br></pre></td></tr></table></figure>

<ul>
<li>将子类构造函数的原型对象修改为一个父类实例（舍弃原有原型对象）</li>
<li>好处<ul>
<li>父类实例对象具有父类的实例属性/方法，父类实例对象的原型又指向父类构造函数原型，所以父类的实例属性/方法 和 原型属性/方法，子类都可以继承</li>
</ul>
</li>
<li>弊端<ol>
<li>父类的实例属性/方法是在子类原型对象上，这就导致父类的实例属性/方法实际上变成了子类的原型属性/方法。</li>
<li>需要手动为新的子类原型对象添加 <code>constructor</code>属性</li>
</ol>
</li>
</ul>
<h4 id="2-对新增对象的影响"><a href="#2-对新增对象的影响" class="headerlink" title="2 对新增对象的影响"></a>2 对新增对象的影响</h4><ul>
<li>如果新增对象在修改原型操作之前，那就意味着，新增对象指向的原型还是原来被舍弃的原型，所以这种方式只对修改原型操作之后新增的对象有效 </li>
</ul>
<h4 id="3-对constructor的影响"><a href="#3-对constructor的影响" class="headerlink" title="3 对constructor的影响"></a>3 对constructor的影响</h4><ul>
<li><p>由于这种方式是将子类原型修改成了一个新的对象，而这个新对象中是没有<code>constructor</code>属性的，所以需要手动为新对象添加<code>constructor</code>属性，并指向子类构造函数</p>
<ol>
<li><p>直接添加（有一个弊端，就是<code>constructor</code>属性默认可遍历）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">A.prototype.constructor = A;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Object的 <code>defineProperty()</code> 添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(A.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">	value: A,</span><br><span class="line">	enumerable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h3 id="4-组合继承1（构造函数-原型链2）"><a href="#4-组合继承1（构造函数-原型链2）" class="headerlink" title="4 组合继承1（构造函数+原型链2）"></a>4 组合继承1（构造函数+原型链2）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.gender = <span class="string">'nan'</span>;</span><br><span class="line">B.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">	B.call(<span class="keyword">this</span>, <span class="string">'小猫'</span>); <span class="comment">// 第一次调用</span></span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype = <span class="keyword">new</span> B(<span class="string">'小狗'</span>); <span class="comment">// 第二次调用</span></span><br><span class="line">A.prototype.constructor = A;</span><br></pre></td></tr></table></figure>

<ul>
<li>好处<ul>
<li>通过构造函数方式可以继承到父类的实例属性/方法</li>
<li>通过原型链方式可以继承到父类的原型属性/方法</li>
</ul>
</li>
<li>弊端<ol>
<li>父类的实例属性会在子类实例和子类原型上都定义一份，不过不影响，因为会先使用实例自己的属性</li>
<li>会调用两次父类构造函数</li>
<li>需要手动为新的子类原型对象添加 <code>constructor</code>属性</li>
<li>子类原有的原型对象上的属性和方法没有了</li>
</ol>
</li>
</ul>
<h3 id="5-组合继承2（构造函数-原型链1）"><a href="#5-组合继承2（构造函数-原型链1）" class="headerlink" title="5 组合继承2（构造函数+原型链1）"></a>5 组合继承2（构造函数+原型链1）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.gender = <span class="string">'nan'</span>;</span><br><span class="line">B.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">	B.call(<span class="keyword">this</span>, <span class="string">'小猫'</span>); </span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.__proto__ = B.prototype</span><br></pre></td></tr></table></figure>

<ul>
<li>好处<ul>
<li>通过构造函数方式可以继承到父类的实例属性/方法</li>
<li>通过原型链方式可以继承到父类的原型属性/方法</li>
</ul>
</li>
<li>弊端<ul>
<li><code>__proto__</code> 在浏览器之外的环境可能不行。</li>
<li><code>B.prototype</code> 中的 <code>constructor</code> 指向的是父类构造函数</li>
</ul>
</li>
</ul>
<h3 id="6-最终方式"><a href="#6-最终方式" class="headerlink" title="6 最终方式"></a>6 最终方式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.gender = <span class="string">'nan'</span>;</span><br><span class="line">B.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1 继承父类实例属性/方法</span></span><br><span class="line">	B.call(<span class="keyword">this</span>, <span class="string">'小猫'</span>); </span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 设置子类原型对象</span></span><br><span class="line">A.prototype = <span class="built_in">Object</span>.create(B.prototype);</span><br><span class="line"><span class="comment">// 3 为子类原型对象添加 constructor</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(A.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">	value: A,</span><br><span class="line">	enumerable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="3-4-对象工厂"><a href="#3-4-对象工厂" class="headerlink" title="3.4 对象工厂"></a>3.4 对象工厂</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fu</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(Fu.prototype);</span><br><span class="line">	Fu.call(obj, ...args); <span class="comment">//通过调用父类</span></span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>与继承方式类似，只是通过对象工厂创建子类对象，不需要子类构造函数<ol>
<li>创建一个以父类原型为原型的对象，相当于继承了父类原型属性/方法</li>
<li>调用父类构造函数，并设置this为新建对象，即相当于继承了父类实例属性</li>
<li>返回新建对象</li>
</ol>
</li>
</ul>
<h2 id="3-5-静态属性-方法的继承"><a href="#3-5-静态属性-方法的继承" class="headerlink" title="3.5 静态属性/方法的继承"></a>3.5 静态属性/方法的继承</h2><ul>
<li><p>静态属性/方法即在构造函数上定义的属性/方法，继承原理都是一样的，函数也是对象，把子类构造函数看作对象，设置其原型为父类构造函数，即可继承静态属性/方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fu</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Fu.haha = <span class="string">"wangcai"</span>;</span><br><span class="line">Fu.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'fu static show'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Zi</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Zi.__proto__ = Fu;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-6-Mixin-模式"><a href="#3-6-Mixin-模式" class="headerlink" title="3.6 Mixin 模式"></a>3.6 Mixin 模式</h2><ol>
<li><p>JS 不支持多继承，也没有接口实现，如果要使用多个类的方法时可以使用 mixin 混合模式来完成</p>
</li>
<li><p>Mixin模式 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口</p>
</li>
<li><p>Mixin 可以看作是一个包含许多功能的对象，使用时将这些功能合并到要使用功能的对象原型上即可</p>
</li>
<li><p>例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myMix = &#123;</span><br><span class="line">	sayHi() &#123;&#125;,</span><br><span class="line">	sayBye() &#123;&#125;,</span><br><span class="line">	eat()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 合并之后，User的实例就有了myMix的所有功能了</span></span><br><span class="line"><span class="built_in">Object</span>.assign(User.prototype, myMix);</span><br><span class="line"><span class="comment">// 手动添加某个功能</span></span><br><span class="line">User.prototype.eat = myHix.eat;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>JS闭包</title>
    <url>/anyeansan.github.io/2020/11/08/UI/JS%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-作用域"><a href="#1-1-作用域" class="headerlink" title="1.1 作用域"></a>1.1 作用域</h2><ol>
<li>函数作用域内可以访问全局变量，函数作用域外不能访问函数作用域中的局部变量</li>
<li>函数执行完毕（弹栈），函数作用域中的变量也随之销毁</li>
<li>作用域是临时的，而闭包是永久的</li>
</ol>
<h2 id="1-2-闭包-closure"><a href="#1-2-闭包-closure" class="headerlink" title="1.2 闭包 closure"></a>1.2 闭包 closure</h2><ol>
<li>有一个单独的作用域，此作用域中定义一个函数，则这个函数与它能在此作用域中所有能访问的变量构成了闭包。在此作用域外调用函数时，函数能够使用此作用域中的变量</li>
<li>闭包可以在外部作用域中访问到函数作用域中的局部变量，延长了变量的生命周期和作用范围</li>
</ol>
<h1 id="二-如何形成闭包"><a href="#二-如何形成闭包" class="headerlink" title="二 如何形成闭包"></a>二 如何形成闭包</h1><h2 id="2-1-条件"><a href="#2-1-条件" class="headerlink" title="2.1 条件"></a>2.1 条件</h2><ol>
<li>单独的作用域：为了创建局部变量</li>
<li>内部定义一个函数：形成闭包</li>
<li>在外部访问函数</li>
</ol>
<h2 id="2-2-例"><a href="#2-2-例" class="headerlink" title="2.2 例"></a>2.2 例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i++);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> inner = outer(); <span class="comment">// 执行外部函数，返回内部函数</span></span><br><span class="line">inner(); <span class="comment">// 外部函数执行完毕后，依然可以访问到外部函数中的变量</span></span><br></pre></td></tr></table></figure>

<h1 id="三-应用"><a href="#三-应用" class="headerlink" title="三 应用"></a>三 应用</h1><h2 id="3-1-事件"><a href="#3-1-事件" class="headerlink" title="3.1 事件"></a>3.1 事件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有 5 个 li ，添加点击事件，打印索引</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">	lis[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i); <span class="comment">// 最终结果每个 li 都打印 4，因为循环是同步的，而点击事件是异步的</span></span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用闭包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">		lis[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(index);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 立即执行函数是一个单独作用域</span></span><br><span class="line"><span class="comment">// 2. 事件处理函数和立即执行函数中的局部变量 index 形成了闭包</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-定时任务"><a href="#3-2-定时任务" class="headerlink" title="3.2 定时任务"></a>3.2 定时任务</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i);<span class="comment">// 最终结果都打印 4，因为循环是同步的，而定时任务是异步的</span></span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用闭包------</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(index);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>JS内置对象</title>
    <url>/anyeansan.github.io/2020/11/08/UI/JS%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="一-Math"><a href="#一-Math" class="headerlink" title="一 Math"></a>一 Math</h1><h2 id="1-1-静态属性"><a href="#1-1-静态属性" class="headerlink" title="1.1 静态属性"></a>1.1 静态属性</h2><table>
<thead>
<tr>
<th>静态属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Math.E</code></td>
<td>欧拉常数 <code>e</code></td>
</tr>
<tr>
<td><code>Math.PI</code></td>
<td><code>π</code></td>
</tr>
</tbody></table>
<h2 id="1-2-静态方法"><a href="#1-2-静态方法" class="headerlink" title="1.2 静态方法"></a>1.2 静态方法</h2><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Math.abs(x)</code></td>
<td>绝对值</td>
</tr>
<tr>
<td><code>Math.ceil(x)</code></td>
<td>向上取整</td>
</tr>
<tr>
<td><code>Math.floor(x)</code></td>
<td>向下取整</td>
</tr>
<tr>
<td><code>Math.pow(x, y)</code></td>
<td>返回 x 的 y 次幂</td>
</tr>
<tr>
<td><code>Math.random()</code></td>
<td>返回 <code>[0-1)</code>之间的伪随机数</td>
</tr>
<tr>
<td><code>Math.round(x)</code></td>
<td>四舍五入</td>
</tr>
<tr>
<td><code>Math.sqrt(x)</code></td>
<td>平方</td>
</tr>
<tr>
<td><code>Math.log(x)</code></td>
<td>对数</td>
</tr>
<tr>
<td><code>Math.exp(x)</code></td>
<td><code>e</code> 的指数，即 e<sup>x</sup></td>
</tr>
<tr>
<td><code>Math.min([value1[,value2, ...]])</code></td>
<td>返回一组数字中的最小值。如果有任一参数不能转换为数值，则返回 <code>NaN</code></td>
</tr>
<tr>
<td><code>Math.max(value1[,value2, ...])</code></td>
<td>返回一组数字中的最大值。如果有任一参数不能转换为数值，则返回 <code>NaN</code></td>
</tr>
<tr>
<td><code>Math.sin(x)</code></td>
<td>正弦</td>
</tr>
<tr>
<td><code>Math.cos(x)</code></td>
<td>余弦</td>
</tr>
<tr>
<td><code>Math.tan(x)</code></td>
<td>正切</td>
</tr>
</tbody></table>
<h1 id="二-Date"><a href="#二-Date" class="headerlink" title="二 Date"></a>二 Date</h1><h2 id="2-1-构造函数"><a href="#2-1-构造函数" class="headerlink" title="2.1 构造函数"></a>2.1 构造函数</h2><table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Date([value])</code></td>
<td>普通函数</td>
<td>无论有没有参数，都返回当前日期和时间的字符串</td>
</tr>
<tr>
<td><code>new Date()</code></td>
<td>构造函数</td>
<td>创建一个当前日期和时间的 <code>Date</code> 对象</td>
</tr>
<tr>
<td><code>new Date(stamp)</code></td>
<td>构造函数</td>
<td>创建一个指定时间戳的 <code>Date</code> 对象</td>
</tr>
<tr>
<td><code>new Date(dateString)</code></td>
<td>构造函数</td>
<td>创建一个 <code>Date</code> 对象，时间由 <code>dateString</code> 决定，该字符串能被 <code>Date.parse()</code>正确识别</td>
</tr>
</tbody></table>
<h2 id="2-2-静态方法"><a href="#2-2-静态方法" class="headerlink" title="2.2 静态方法"></a>2.2 静态方法</h2><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Date.now()</code></td>
<td>返回当前时间距离时间零点的毫秒数</td>
</tr>
<tr>
<td><code>Date.parse(dateString)</code></td>
<td>解析日期字符串，返回该时间距离时间零点的毫秒数</td>
</tr>
</tbody></table>
<h2 id="2-3-原型方法-Date-prototype"><a href="#2-3-原型方法-Date-prototype" class="headerlink" title="2.3 原型方法 Date.prototype."></a>2.3 原型方法 <code>Date.prototype.</code></h2><h3 id="1-to"><a href="#1-to" class="headerlink" title="1 to"></a>1 to</h3><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>toString()</code></td>
<td>返回日期时间字符串字符串</td>
</tr>
<tr>
<td><code>toLocaleString()</code></td>
<td>返回本地日期时间字符串</td>
</tr>
<tr>
<td><code>toUTCString()</code></td>
<td>返回 UTC 日期时间字符串</td>
</tr>
<tr>
<td><code>toISOString()</code></td>
<td>返回 ISO8601 写法的日期时间字符串，通常用于网络服务</td>
</tr>
<tr>
<td><code>toJSON()</code></td>
<td>与<code>toISOString()</code>方法的返回结果完全相同</td>
</tr>
</tbody></table>
<h3 id="2-get"><a href="#2-get" class="headerlink" title="2 get"></a>2 get</h3><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>getTime</code></td>
<td>返回距离事件元点的毫秒数</td>
</tr>
<tr>
<td><code>getFullYear</code></td>
<td>年（四位数）</td>
</tr>
<tr>
<td><code>getMonth()</code></td>
<td>月 <code>0-11</code></td>
</tr>
<tr>
<td><code>getDate()</code></td>
<td>日 <code>1-31</code></td>
</tr>
<tr>
<td><code>getDay()</code></td>
<td>星期 <code>0-6</code></td>
</tr>
<tr>
<td><code>getHours()</code></td>
<td>时 <code>0-23</code></td>
</tr>
<tr>
<td><code>getMinutes()</code></td>
<td>分 <code>0-59</code></td>
</tr>
<tr>
<td><code>getSeconds()</code></td>
<td>秒 <code>0-59</code></td>
</tr>
<tr>
<td><code>getMilliseconds()</code></td>
<td>毫秒 <code>0-999</code></td>
</tr>
</tbody></table>
<h3 id="3-set"><a href="#3-set" class="headerlink" title="3 set"></a>3 set</h3><ul>
<li>set 与 get 一一相对应，除了没有 <code>setDay()</code>，因为星期是算的</li>
</ul>
<h1 id="三-RegExp"><a href="#三-RegExp" class="headerlink" title="三 RegExp"></a>三 RegExp</h1><h2 id="3-1-构造函数"><a href="#3-1-构造函数" class="headerlink" title="3.1 构造函数"></a>3.1 构造函数</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>new RegExp(pattern [, flags])</code></td>
<td>创建 <code>RegExp</code> 对象，<code>flags</code>：可以是<code>g i m u y s</code>的任意组合</td>
</tr>
<tr>
<td><code>RegExp()</code></td>
<td>同 <code>new RegExp()</code></td>
</tr>
</tbody></table>
<h2 id="3-2-字面量"><a href="#3-2-字面量" class="headerlink" title="3.2 字面量"></a>3.2 字面量</h2><ul>
<li><code>/pattern/flags</code><ul>
<li><code>/</code> 斜杠表示开始和结束</li>
</ul>
</li>
</ul>
<h2 id="3-3-原型属性-RegExp-prototype"><a href="#3-3-原型属性-RegExp-prototype" class="headerlink" title="3.3 原型属性 RegExp.prototype."></a>3.3 原型属性 <code>RegExp.prototype.</code></h2><table>
<thead>
<tr>
<th>原型属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>global</code></td>
<td>只读</td>
<td>返回一个布尔值，判断是否设置了修饰符<code>g</code></td>
</tr>
<tr>
<td><code>ignoreCase</code></td>
<td>只读</td>
<td>返回一个布尔值，判断是否设置了修饰符<code>i</code></td>
</tr>
<tr>
<td><code>multiline</code></td>
<td>只读</td>
<td>返回一个布尔值，判断是否设置了修饰符<code>m</code></td>
</tr>
<tr>
<td><code>unicode</code></td>
<td>只读</td>
<td>返回一个布尔值，判断是否设置了修饰符<code>y</code></td>
</tr>
<tr>
<td><code>sticky</code></td>
<td>只读</td>
<td>返回一个布尔值，判断是否设置了修饰符<code>y</code></td>
</tr>
<tr>
<td><code>dotAll</code></td>
<td>只读</td>
<td>返回一个布尔值，判断是否设置了修饰符<code>s</code></td>
</tr>
<tr>
<td><code>flags</code></td>
<td>只读</td>
<td>返回一个字符串，包含已经设置的所有修饰符，按字母排序</td>
</tr>
<tr>
<td><code>source</code></td>
<td>只读</td>
<td>返回正则表达式文本字符串，该字符串不包含正则字面量两边的斜杠以及任何的标志字符</td>
</tr>
<tr>
<td><code>lastIndex</code></td>
<td>读写</td>
<td>指定下一次匹配的起始索引。正则表达式必须有 <code>g</code></td>
</tr>
</tbody></table>
<h2 id="3-4-原型方法-RegExp-prototype"><a href="#3-4-原型方法-RegExp-prototype" class="headerlink" title="3.4 原型方法 RegExp.prototype."></a>3.4 原型方法 <code>RegExp.prototype.</code></h2><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>test(str)</code></td>
<td>判断是否匹配，会更新正则对象的 <code>lastIndex</code> 属性</td>
</tr>
<tr>
<td><code>exec(str)</code></td>
<td>返回一个包含匹配项的数组（包含附加属性），若匹配失败返回 <code>null</code>，并将 <code>lastIndex</code> 重置为 0</td>
</tr>
</tbody></table>
<h1 id="四-JSON"><a href="#四-JSON" class="headerlink" title="四 JSON"></a>四 JSON</h1><h2 id="4-1-语法"><a href="#4-1-语法" class="headerlink" title="4.1 语法"></a>4.1 语法</h2><ol>
<li>属性：必须是双引号括起来的字符串；最后一个属性后不能有逗号</li>
<li>基本类型的值<ol>
<li>字符串</li>
<li>数值（必须十进制，<code>NaN</code> 不行）</li>
<li>布尔值</li>
<li>null（ <code>undefined</code> 不行）</li>
</ol>
</li>
<li>引用类型的值<ol>
<li>数组</li>
<li>对象</li>
</ol>
</li>
</ol>
<h2 id="4-2-静态方法"><a href="#4-2-静态方法" class="headerlink" title="4.2 静态方法"></a>4.2 静态方法</h2><ol>
<li><code>JSON.stringify(value[, replacer [, space]])</code><ul>
<li>将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被<code>parse()</code>方法还原。</li>
<li><code>value</code><ul>
<li>要被序列化的对象</li>
<li>如果对象有自定义的<code>toJSON()</code>方法，那么<code>JSON.stringify()</code>会使用<code>toJSON()</code>方法的返回值作为参数</li>
</ul>
</li>
<li><code>replacer</code><ol>
<li>如果是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的处理</li>
<li>如果是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中</li>
</ol>
</li>
<li><code>space</code>：<ul>
<li>指定缩进用的空白字符串，用于美化输出（pretty-print）增加可读性。<ol>
<li>如果是数字，表示每个属性前面添加的空格（不超过10个）</li>
<li>如果是字符串（不超过10个字符），则该字符串会添加在每行前面</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><code>JSON.parse(text[, reviver])</code><ul>
<li>将 JSON 字符串转换成对应的对象</li>
<li><code>reviver(currentKey, currentValue)</code><ul>
<li>转换器，此函数调用时机在 parse 函数返回之前，用于在返回之前对所得到的对象执行操作  </li>
<li>转成的对象的所有属性都会调用 reviver 函数，并且会将 reviver 返回值作为新的属性值，如果 reviver 返回 <code>undefined</code>，会删除当前属性</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="五-Error"><a href="#五-Error" class="headerlink" title="五 Error"></a>五 Error</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ul>
<li>当代码运行时的发生错误，会创建新的Error 对象，并将其抛出</li>
</ul>
<h2 id="5-2-构造函数"><a href="#5-2-构造函数" class="headerlink" title="5.2 构造函数"></a>5.2 构造函数</h2><ul>
<li><code>new Error([message])</code></li>
</ul>
<h2 id="5-3-原型属性"><a href="#5-3-原型属性" class="headerlink" title="5.3 原型属性"></a>5.3 原型属性</h2><ol>
<li><code>message</code><ul>
<li>错误信息</li>
</ul>
</li>
<li><code>name</code><ul>
<li>error 类型的名称.初始值为 <code>Error</code></li>
</ul>
</li>
</ol>
<h2 id="5-4-其它类型的错误构造函数"><a href="#5-4-其它类型的错误构造函数" class="headerlink" title="5.4 其它类型的错误构造函数"></a>5.4 其它类型的错误构造函数</h2><table>
<thead>
<tr>
<th>类型</th>
<th>错误原因</th>
</tr>
</thead>
<tbody><tr>
<td><code>EvalError</code></td>
<td>与 <code>eval()</code> 有关</td>
</tr>
<tr>
<td><code>RangeError</code></td>
<td>数值变量或参数超出其有效范围</td>
</tr>
<tr>
<td><code>ReferenceError</code></td>
<td>无效引用</td>
</tr>
<tr>
<td><code>SyntaxError</code></td>
<td>语法错误</td>
</tr>
<tr>
<td><code>TypeError</code></td>
<td>变量或参数不属于有效类型</td>
</tr>
<tr>
<td><code>URIError</code></td>
<td>给 <code>encodeURI()</code> 或  <code>decodeURl()</code> 传递的参数无效</td>
</tr>
</tbody></table>
<h1 id="六-集合"><a href="#六-集合" class="headerlink" title="六 集合"></a>六 集合</h1><h2 id="6-1-Set"><a href="#6-1-Set" class="headerlink" title="6.1 Set"></a>6.1 Set</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>Set 中的元素有序（存取顺序一致） 唯一</li>
<li>可以存储基本数据类型和引用数据类型（包括 <code>NaN undefined null</code>）</li>
<li>判断元素相等： 基于 <code>sameValueZero</code> 算法<ul>
<li>类似 <code>===</code>，除了 NaN，<code>NaN === NaN</code> 返回 <code>false</code>，但是在 Set 中看作相等</li>
</ul>
</li>
</ol>
<h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2 构造函数"></a>2 构造函数</h3><ul>
<li><code>new Set([iterable])</code><ul>
<li><code>iterable</code><ul>
<li>可迭代对象，它的所有元素将不重复地被添加到 Set 中。</li>
<li>如果省略或其值为 <code>null</code>，则新的 Set 为空</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-原型属性-Set-prototype"><a href="#3-原型属性-Set-prototype" class="headerlink" title="3 原型属性 Set.prototype."></a>3 原型属性 <code>Set.prototype.</code></h3><table>
<thead>
<tr>
<th>原型属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>size</code></td>
<td>Set 集合的元素个数</td>
</tr>
</tbody></table>
<h3 id="4-原型方法-Set-prototype"><a href="#4-原型方法-Set-prototype" class="headerlink" title="4 原型方法 Set.prototype."></a>4 原型方法 <code>Set.prototype.</code></h3><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>add(value)</code></td>
<td>向 Set 末尾添加元素，返回 Set</td>
</tr>
<tr>
<td><code>delete(value)</code></td>
<td>从 Set 中删除指定元素，成功删除返回 true，否则返回 false</td>
</tr>
<tr>
<td><code>has(value)</code></td>
<td>判断 Set 中是否有指定的元素</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清空 Set</td>
</tr>
<tr>
<td><code>keys()</code></td>
<td>由于 Set 结构没有键只有值，<code>keys()</code> 与 <code>values()</code> 完全一样</td>
</tr>
<tr>
<td><code>values()</code></td>
<td>返回值的迭代器对象，值就是 Set 元素</td>
</tr>
<tr>
<td><code>entries()</code></td>
<td>返回键值对的迭代器对象，键值对形式为<code>[value, value]</code>，Set 中的元素即是键也是值</td>
</tr>
<tr>
<td><code>forEach(callback[, thisArg])</code></td>
<td>遍历 Set，按插入顺序依次执行回调函数</td>
</tr>
</tbody></table>
<ul>
<li><code>callback([currentValue[, currentKey[, set]]])</code><ul>
<li><code>currentValue</code><ul>
<li>当前元素</li>
</ul>
</li>
<li><code>currentKey</code><ul>
<li>由于 Set 没有键，<code>currentKey</code> 与 <code>currentValue</code> 永远都一样，也是当前元素</li>
</ul>
</li>
<li><code>set</code><ul>
<li>当前Set</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-Set-↔-数组"><a href="#5-Set-↔-数组" class="headerlink" title="5 Set ↔ 数组"></a>5 Set ↔ 数组</h3><table>
<thead>
<tr>
<th>方式</th>
<th>转换</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>[...set]</code></td>
<td>Set → 数组</td>
<td>展开语法，可以展开可迭代对象</td>
</tr>
<tr>
<td><code>Array.from(set)</code></td>
<td>Set → 数组</td>
<td>数组静态方法，将可迭代对象转为数组</td>
</tr>
<tr>
<td><code>new Set(arr)</code></td>
<td>数组 → Set</td>
<td>Set 构造方法，将数组转为 Set</td>
</tr>
</tbody></table>
<h2 id="6-2-WeakSet"><a href="#6-2-WeakSet" class="headerlink" title="6.2 WeakSet"></a>6.2 WeakSet</h2><ol>
<li>用法同 Set 大致相同</li>
<li>与 Set 的区别<ol>
<li>WeakSet 只能存引用数据类型</li>
<li>WeakSet 是弱引用<ul>
<li>当对象引用数量为 0 时，会被垃圾回收掉，弱引用的意思就是不会增加对象的引用数量。</li>
</ul>
</li>
<li>WeakSet 不可遍历<ul>
<li>因为WeakSet 是弱引用，其中的对象随时有可能别垃圾回收掉</li>
</ul>
</li>
<li>没有<code>size</code> 属性</li>
<li>原型方法只有 <code>add() delete() has()</code></li>
</ol>
</li>
</ol>
<h2 id="6-3-Map"><a href="#6-3-Map" class="headerlink" title="6.3 Map"></a>6.3 Map</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>Map 是键值对的集合，且键有序（存取一致）</li>
<li>对象的键只能是字符串，Map 的键可以是任何值</li>
<li>如果键相等，后边的值回覆盖前边</li>
<li>判断键相等 基于 <code>sameValueZero</code> 算法<ul>
<li>类似 <code>===</code>，除了NaN，<code>NaN === NaN</code>返回 <code>false</code>，但是在 Map 中看作相等</li>
</ul>
</li>
</ol>
<h3 id="2-构造函数-1"><a href="#2-构造函数-1" class="headerlink" title="2 构造函数"></a>2 构造函数</h3><ul>
<li><code>new Map([iterable])</code><ul>
<li><code>iterable</code><ul>
<li>可迭代对象，其元素为键值对。</li>
<li>如数组为 <code>[[&#39;name&#39;,&#39;xiaoming&#39;],[&#39;age&#39;,18]]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-原型属性-Map-prototype"><a href="#3-原型属性-Map-prototype" class="headerlink" title="3 原型属性 Map.prototype."></a>3 原型属性 <code>Map.prototype.</code></h3><table>
<thead>
<tr>
<th>原型属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>size</code></td>
<td>Map 集合中键值对的个数</td>
</tr>
</tbody></table>
<h3 id="4-原型方法-Map-prototype"><a href="#4-原型方法-Map-prototype" class="headerlink" title="4 原型方法 Map.prototype."></a>4 原型方法 <code>Map.prototype.</code></h3><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>set(key, value)</code></td>
<td>向 Map 添加键值对，返回 Map</td>
</tr>
<tr>
<td><code>get(key)</code></td>
<td>根据 <code>key</code> 获取 <code>value</code>，没有返回 <code>undefined</code></td>
</tr>
<tr>
<td><code>delete(key)</code></td>
<td>根据 <code>key</code> 删除键值对，删除成功返回 <code>true</code>，否则返回 <code>false</code></td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清空 Map</td>
</tr>
<tr>
<td><code>has(key)</code></td>
<td>判断指定 <code>key</code> 的元素是否存在</td>
</tr>
<tr>
<td><code>keys()</code></td>
<td>返回键的迭代器对象</td>
</tr>
<tr>
<td><code>values()</code></td>
<td>返回值的迭代器对象</td>
</tr>
<tr>
<td><code>entries()</code></td>
<td>返回键值对的迭代器对象，键值对形式为<code>[key, value]</code></td>
</tr>
<tr>
<td><code>forEach(callback[, thisArg])</code></td>
<td>遍历 Map，按键插入顺序依次执行回调函数</td>
</tr>
</tbody></table>
<h3 id="5-Map-↔-数组"><a href="#5-Map-↔-数组" class="headerlink" title="5 Map ↔ 数组"></a>5 Map ↔ 数组</h3><table>
<thead>
<tr>
<th>方式</th>
<th>转换</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>[...map]</code></td>
<td>Map → 数组</td>
<td>展开语法，可以展开可迭代对象</td>
</tr>
<tr>
<td><code>Array.from(map)</code></td>
<td>Map → 数组</td>
<td>数组静态方法，将可迭代对象转为数组</td>
</tr>
<tr>
<td><code>new Map([[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]])</code></td>
<td>数组 → Map</td>
<td>将一个二维键值对数组转换成一个 Map 对象</td>
</tr>
</tbody></table>
<h2 id="6-4-WeakMap"><a href="#6-4-WeakMap" class="headerlink" title="6.4 WeakMap"></a>6.4 WeakMap</h2><ol>
<li>用法同Map大致相同</li>
<li>与Map的区别<ol>
<li>WeakMap 的键只能是引用数据类型（不能为 <code>null</code> ）</li>
<li>WeakMap 的键是弱引用</li>
<li>WeakMap 不能遍历</li>
<li>WeakMap 没有<code>size</code>属性</li>
<li>WeakMap 原型方法只有 <code>set() get() delete() has()</code></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>JS引用类型-函数</title>
    <url>/anyeansan.github.io/2020/11/08/UI/JS%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>每个 JavaScript 函数都是一个 <code>Function</code> 实例</li>
<li>函数作为对象中的属性通常称为方法</li>
</ol>
<h1 id="二-定义函数"><a href="#二-定义函数" class="headerlink" title="二 定义函数"></a>二 定义函数</h1><h2 id="2-1-方式"><a href="#2-1-方式" class="headerlink" title="2.1 方式"></a>2.1 方式</h2><h3 id="1-函数声明"><a href="#1-函数声明" class="headerlink" title="1 函数声明"></a>1 函数声明</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">参数列表</span>) </span>&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>函数提升（提升优先级高于 <code>var</code> 变量提升），所以可以在定义函数之前的位置调用函数</li>
<li>声明的函数会添加到 <code>window</code> 对象中</li>
<li>优先级高于函数表达式</li>
</ol>
<h3 id="2-函数表达式"><a href="#2-函数表达式" class="headerlink" title="2 函数表达式"></a>2 函数表达式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>/<span class="keyword">let</span>/<span class="keyword">const</span> 函数名 = <span class="function"><span class="keyword">function</span> (<span class="params">参数列表</span>) </span>&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>var</code> 会有变量提升，但不会赋值，即相当于函数没有提升，所以不可以在定义函数之前的位置调用函数</li>
<li><code>var</code> 声明的函数会添加到 <code>window</code> 对象中，但 <code>let/const</code> 则不会</li>
</ol>
<h3 id="3-Function-构造函数"><a href="#3-Function-构造函数" class="headerlink" title="3 Function 构造函数"></a>3 Function 构造函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var/let/const 函数名 = new Function(&quot;参数列表&quot;,&quot;函数体&quot;);</span><br></pre></td></tr></table></figure>

<ol>
<li><code>var</code> 会有变量提升，但不会赋值，即相当于函数没有提升</li>
<li><code>var</code> 声明的函数会添加到 <code>window</code> 对象中，但 <code>let/const</code> 则不会</li>
</ol>
<h2 id="2-2-参数"><a href="#2-2-参数" class="headerlink" title="2.2 参数"></a>2.2 参数</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><p>形参 <code>parameter</code> ；实参 <code>argument</code></p>
<ul>
<li>形参是默认声明的，不需用 <code>var/let/const</code> 修饰</li>
<li>实参数量小于形参时，没有传递的形参值为 <code>undefined</code></li>
<li>实参数量大于形参时，多余的实参将忽略并不会报错</li>
</ul>
</li>
<li><p>在形参上可以直接定义参数默认值，当对应实参没有值或值为 undefined 时，使用默认值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b = <span class="number">2</span></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-arguments"><a href="#2-arguments" class="headerlink" title="2 arguments"></a>2 arguments</h3><ul>
<li><code>arguments</code> 对象是一个类数组对象，存储了传递的所有实参</li>
<li><code>arguments</code> 是所有函数中都可用的局部变量，箭头函数除外</li>
</ul>
<h3 id="3-剩余参数"><a href="#3-剩余参数" class="headerlink" title="3 剩余参数"></a>3 剩余参数</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>剩余参数是一个数组，用于接收形参外的所有参数（类似于 java 可变参数）</li>
<li>剩余参数必须是最后一个参数</li>
</ol>
<h4 id="2-语法"><a href="#2-语法" class="headerlink" title="2 语法"></a>2 语法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">a, b, ...theArgs</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-剩余参数和-arguments-对象的区别"><a href="#4-剩余参数和-arguments-对象的区别" class="headerlink" title="4 剩余参数和 arguments 对象的区别"></a>4 剩余参数和 arguments 对象的区别</h4><ol>
<li>剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。</li>
<li>arguments 对象不是一个真正的数组，而剩余参数是真正的 Array 实例，即剩余参数可以使用所有的数组方法</li>
</ol>
<h1 id="三-立即执行函数-IIFE"><a href="#三-立即执行函数-IIFE" class="headerlink" title="三 立即执行函数 IIFE"></a>三 立即执行函数 IIFE</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol>
<li><code>Imdiately Invoked Function Expression</code></li>
<li>不必为函数命名</li>
<li>形成单独的作用域，封装遍历，避免重名…</li>
</ol>
<h2 id="3-2-语法"><a href="#3-2-语法" class="headerlink" title="3.2 语法"></a>3.2 语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">形参列表</span>)</span>&#123;&#125;(实参列表)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">形参列表</span>)</span>&#123;&#125;</span><br><span class="line">)(实参列表)</span><br></pre></td></tr></table></figure>

<h1 id="四-箭头函数（lambda）"><a href="#四-箭头函数（lambda）" class="headerlink" title="四 箭头函数（lambda）"></a>四 箭头函数（lambda）</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ol>
<li>箭头函数内部的<code>this</code> 是固定的，指向定义时所在的环境的 <code>this</code></li>
<li>箭头函数不可以当作构造函数，也就是说，不可以使用 <code>new</code> 命令</li>
<li>箭头函数内部不存在 <code>arguments</code> 对象</li>
<li>箭头函数不可以使用<code>yield</code>命令，因此箭头函数不能用作 <code>Generator</code> 函数</li>
</ol>
<h2 id="4-2-语法"><a href="#4-2-语法" class="headerlink" title="4.2 语法"></a>4.2 语法</h2><ol>
<li><p>基础语法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(param1, param2, …, paramN) =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>没有参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">() =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当且仅当只有一个参数时，小括号可以省略</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">singleParam =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数体只有一句且是返回语句时，<code>return</code>、分号和大括号都可以省略</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(param1, param2, …, paramN) =&gt;&#123; <span class="keyword">return</span> expression; &#125;</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line">(param1, param2, …, paramN) =&gt; expression</span><br><span class="line"></span><br><span class="line"><span class="comment">//  注意：如果返回的是一个对象，要用()包括，因为&#123;&#125;会被认为是一个代码块</span></span><br><span class="line">(param1, param2, …, paramN) =&gt; (&#123;<span class="attr">name</span>: <span class="string">'xiaoming'</span>&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="五-Function"><a href="#五-Function" class="headerlink" title="五 Function"></a>五 Function</h1><h2 id="5-1-构造函数"><a href="#5-1-构造函数" class="headerlink" title="5.1 构造函数"></a>5.1 构造函数</h2><ul>
<li><code>new Function (variableStr, functionBodyStr)</code><ul>
<li><code>variableStr</code><ul>
<li>形参字符串，字符串中多个参数用逗号分隔</li>
</ul>
</li>
<li><code>functionBodyStr</code><ul>
<li>函数体的字符串</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-2-实例属性"><a href="#5-2-实例属性" class="headerlink" title="5.2 实例属性"></a>5.2 实例属性</h2><table>
<thead>
<tr>
<th>实例属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>length</code></td>
<td>函数的形参个数</td>
</tr>
<tr>
<td><code>name</code></td>
<td>函数的名称</td>
</tr>
</tbody></table>
<h2 id="5-3-原型方法-Function-prototype"><a href="#5-3-原型方法-Function-prototype" class="headerlink" title="5.3 原型方法 Function.prototype."></a>5.3 原型方法 <code>Function.prototype.</code></h2><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>call(thisArg, arg1, arg2, ...)</code></td>
<td>使用指定的 <code>this</code> 值和实参列表来调用此函数</td>
<td>执行函数</td>
</tr>
<tr>
<td><code>apply(thisArg, [argsArray])</code></td>
<td>同<code>call()</code>，不同的是接受的是一个实参数组</td>
<td>执行函数</td>
</tr>
<tr>
<td><code>bind(thisArg[, arg1[, arg2[, ...]]])</code></td>
<td>使用指定的 <code>this</code> 和实参列表创建一个原函数的拷贝并返回，<code>bind</code> 实参优先级高于调用实参</td>
<td>创建函数</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>JS引用类型-数组</title>
    <url>/anyeansan.github.io/2020/11/08/UI/JS%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>数组都是 <code>Array</code> 的实例</li>
<li>数组可以存任意类型的数据</li>
<li>数组长度可变</li>
<li>ES6 明确数组中空位值为 <code>undefined</code></li>
</ol>
<h1 id="二-数组管理"><a href="#二-数组管理" class="headerlink" title="二 数组管理"></a>二 数组管理</h1><h2 id="2-1-创建数组"><a href="#2-1-创建数组" class="headerlink" title="2.1 创建数组"></a>2.1 创建数组</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 数组字面量</span></span><br><span class="line"><span class="keyword">let</span> arr = [ele0, ele1, ..., eleN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 Array 构造函数</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-清空数组"><a href="#2-2-清空数组" class="headerlink" title="2.2 清空数组"></a>2.2 清空数组</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 将原数组指向一个空数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 将数组长度置为 0</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 使用 splice() 方法</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.splice(<span class="number">0</span>, arr.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 循环一个个删</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">while</span> (arr.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	arr.pop();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三-Array"><a href="#三-Array" class="headerlink" title="三 Array"></a>三 Array</h1><h2 id="3-1-构造函数"><a href="#3-1-构造函数" class="headerlink" title="3.1 构造函数"></a>3.1 构造函数</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>new Array(arrayLength)</code></td>
<td>创建一个指定长度的数组，<code>arrayLength</code> ：0-2<sup>32</sup>-1 之间的整数</td>
</tr>
<tr>
<td><code>new Array(ele0, ele1[, ...[, eleN]])</code></td>
<td>创建一个包含指定元素的数组</td>
</tr>
<tr>
<td><code>Array(...)</code></td>
<td>和 <code>new Array(...)</code> 是等同的</td>
</tr>
</tbody></table>
<h2 id="3-2-实例属性"><a href="#3-2-实例属性" class="headerlink" title="3.2 实例属性"></a>3.2 实例属性</h2><table>
<thead>
<tr>
<th>实例属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>length</code></td>
<td>读写</td>
<td>数组元素个数</td>
</tr>
</tbody></table>
<h2 id="3-3-静态方法"><a href="#3-3-静态方法" class="headerlink" title="3.3  静态方法"></a>3.3  静态方法</h2><ol>
<li><code>Array.isArray(obj)</code><ul>
<li>如果值是 Array，则返回true，否则返回false</li>
<li>用来弥补<code>typeof</code>，因为<code>typeof 数组</code> 返回的是<code>object</code></li>
</ul>
</li>
<li><code>Array.of(element0[, element1[, ...[, elementN]]])</code><ul>
<li>将一组值转换为数组</li>
<li>用来弥补构造函数，构造函数参数个数不同会导致结果不同。</li>
</ul>
</li>
<li><code>Array.from(arrayLike[, mapFn[, thisArg]])</code><ul>
<li>从一个类数组对象或可迭代对象创建一个新的浅拷贝的数组实例并返回</li>
<li><code>mapFn</code><ul>
<li>如果指定了该参数，新数组中的每个元素都会执行该回调函数</li>
</ul>
</li>
<li><code>thisArg</code><ul>
<li>执行回调函数 mapFn 时的 this 对象</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="3-4-原型方法"><a href="#3-4-原型方法" class="headerlink" title="3.4 原型方法"></a>3.4 原型方法</h2><h3 id="1-获取"><a href="#1-获取" class="headerlink" title="1 获取"></a>1 获取</h3><ol>
<li><code>valueOf()</code><ul>
<li>返回数组本身</li>
</ul>
</li>
<li><code>toString()</code><ul>
<li>返回数组的字符串形式</li>
</ul>
</li>
<li><code>join([separator])</code><ul>
<li>以指定分隔符（默认为逗号）将所有数组成员连接为一个字符串返回</li>
</ul>
</li>
</ol>
<h3 id="2-增删改"><a href="#2-增删改" class="headerlink" title="2 增删改"></a>2 增删改</h3><ol>
<li><code>push(element1, ..., elementN)</code><ul>
<li>将一个或多个元素添加到数组的末尾，并返回该数组的新长度，改变原数组</li>
<li>如果参数为数组，把数组作为元素添加到数组中。(二维数组)</li>
</ul>
</li>
<li><code>pop()</code><ul>
<li>删除并返回最后一个元素，改变原数组</li>
</ul>
</li>
<li><code>unshift(element1, ..., elementN)</code><ul>
<li>将一个或多个元素添加到数组的开头，并返回该数组的新长度，改变原数组</li>
<li>参数可以是数组（二维数组）</li>
</ul>
</li>
<li><code>shift()</code><ul>
<li>删除并返回第一个元素，改变原数组</li>
</ul>
</li>
<li><code>fill(value[, start[, end]])</code><ul>
<li>使用指定值填充数组，可指定开始结束索引，返回修改后的数组</li>
</ul>
</li>
<li><code>splice(start[, deleteCount[, item1[, item2[, ...]]]])</code><ul>
<li>删除目标数组的一部分成员，并可以在删除的位置添加新的数组成员，返回被删除的元素组成的数组，改变原数组</li>
</ul>
</li>
<li><code>slice([begin[, end]])</code><ul>
<li>提取目标数组的一部分，返回一个浅拷贝新数组，原数组不变</li>
</ul>
</li>
<li><code>concat(value1, value2, ..., valueN)</code><ul>
<li>将一个或多个值合并到数组中，返回新数组，不改变原数组</li>
</ul>
</li>
<li><code>copyWithin(target[, start[, end]])</code><ul>
<li>复制数组的一部分到数组指定位置（覆盖原有成员），并返回数组，改变原数组但不改变数组长度（因为会覆盖原有成员）</li>
<li><code>target</code><ul>
<li>目标位置</li>
</ul>
</li>
<li><code>start</code><ul>
<li>复制的起始索引，默认为0</li>
</ul>
</li>
<li><code>end</code><ul>
<li>复制的终止索引（不含），默认为尾部</li>
</ul>
</li>
</ul>
</li>
<li><code>flat([depth])</code><ul>
<li>将数组降维，返回新数组，不改变原数组</li>
<li><code>depth</code><ul>
<li>指定结构深度，默认值为 1，即只可以将二维数组合并成一维数组</li>
</ul>
</li>
</ul>
</li>
<li><code>flatMap(callback[, thisArg])</code><ul>
<li>对数组中每一个元素执行回调函数，然后对返回值组成的数组执行flat()方法，结构深度 depth 值为1，返回新数组</li>
<li><code>callback(currentValue[, index[, array]])</code><ul>
<li><code>currentValue</code>：当前遍历的元素</li>
<li><code>index</code>：当前遍历到的索引</li>
<li><code>array</code>：当前数组</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-查"><a href="#3-查" class="headerlink" title="3 查"></a>3 查</h3><ol>
<li><code>indexOf(searchElement[, fromIndex])</code><ul>
<li>返回第一个匹配索引，如果不存在，则返回 <code>-1</code></li>
</ul>
</li>
<li><code>lastIndexOf(searchElement[, fromIndex])</code><ul>
<li>返回从后往前的第一个匹配索引，如果不存在，则返回 <code>-1</code></li>
</ul>
</li>
<li><code>includes(valueToFind[, fromIndex])</code><ul>
<li>判断数组是否包含指定元素</li>
</ul>
</li>
<li><code>find(callback[, thisArg])</code><ul>
<li>返回数组中第一个满足所提供测试函数（返回true）的元素的值，否则返回 undefined</li>
<li><code>callback(element[, index[, array]])</code><ul>
<li><code>element</code>：当前遍历的元素</li>
<li><code>index</code>：当前遍历到的索引</li>
<li><code>array</code>：当前数组</li>
</ul>
</li>
<li><code>thisArg</code><ul>
<li>执行回调时函数时this 指向的对象。</li>
</ul>
</li>
</ul>
</li>
<li><code>findIndex(callback[, thisArg])</code><ul>
<li>返回数组中第一个满足所提供测试函数（返回true）的元素的索引，否则返回 -1</li>
</ul>
</li>
</ol>
<h3 id="4-排序"><a href="#4-排序" class="headerlink" title="4 排序"></a>4 排序</h3><ol>
<li><code>reverse()</code><ul>
<li>反转数组并返回，改变原数组</li>
</ul>
</li>
<li><code>sort([compareFunction])</code><ul>
<li>默认是按照字典顺序排序，返回排序后的数组，改变原数组</li>
<li><code>compareFunction(value1, value2)</code><ul>
<li>返回一个数字，如果小于0则value1排在value2之前</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="5-循环遍历"><a href="#5-循环遍历" class="headerlink" title="5 循环遍历"></a>5 循环遍历</h3><ol>
<li><code>forEach(callback[, thisArg])</code><ul>
<li><code>callback(currentValue[, index[, array]])</code><ul>
<li><code>currentValue</code>：当前遍历的元素</li>
<li><code>index</code>：当前遍历到的索引</li>
<li><code>array</code>：当前数组</li>
</ul>
</li>
</ul>
</li>
<li><code>keys()</code><ul>
<li>返回数组元素键的迭代器对象</li>
</ul>
</li>
<li><code>values()</code><ul>
<li>返回数组元素值的迭代器对象</li>
</ul>
</li>
<li><code>entries()</code><ul>
<li>返回数组元素键值对的迭代器对象</li>
</ul>
</li>
</ol>
<h3 id="6-扩展方法"><a href="#6-扩展方法" class="headerlink" title="6 扩展方法"></a>6 扩展方法</h3><ol>
<li><code>every(callback[, thisArg])</code><ul>
<li>判断数组元素是否全部能通过指定测试函数，返回布尔值，一个元素返回 <code>false</code>，则 <code>every()</code>立即返回 <code>false</code></li>
<li><code>callback(currentValue[, index[, array]])</code><ul>
<li><code>currentValue</code>：当前遍历的元素</li>
<li><code>index</code>：当前遍历到的索引</li>
<li><code>array</code>：当前数组</li>
</ul>
</li>
</ul>
</li>
<li><code>some(callback[, thisArg])</code><ul>
<li>数组中有至少一个元素通过回调函数的测试就会返回 <code>true</code>；</li>
</ul>
</li>
<li><code>filter(callback[, thisArg])</code><ul>
<li>返回一个新的由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组</li>
</ul>
</li>
<li><code>map(callback[, thisArg])</code><ul>
<li>对数组中每一个元素执行回调函数，返回每一个回调函数结果组成的新数组</li>
</ul>
</li>
<li><code>reduce(callback[, initialValue])</code><ul>
<li>返回回调函数累计处理的结果</li>
<li><code>callback(accumulator, currentValue[, index[, array]])</code><ul>
<li><code>accumulator</code><ul>
<li>第一次循环<ol>
<li>有<code>initialValue</code>，则为<code>initialValue</code></li>
<li>无<code>initialValue</code>，则为数组第一个元素</li>
</ol>
</li>
<li>从第二次循环往后为回调函数返回值</li>
</ul>
</li>
<li><code>currentValue</code><ul>
<li>数组中当前循环的元素</li>
<li>第一次循环时，如果没有<code>initialValue</code>，由于<code>accumulator</code>是数组第一个元素，则<code>currentValue</code>会从第二个元素开始循环</li>
</ul>
</li>
<li><code>index</code><ul>
<li>数组中当前循环的元素的索引</li>
</ul>
</li>
<li><code>array</code><ul>
<li>当前数组</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>reduceRight(callback[, initialValue])</code><ul>
<li>与<code>reduce()</code>相似，只是从右向左遍历数组</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>JS引用类型-对象</title>
    <url>/anyeansan.github.io/2020/11/08/UI/JS%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="一-创建对象"><a href="#一-创建对象" class="headerlink" title="一 创建对象"></a>一 创建对象</h1><h2 id="1-1-Object-构造函数"><a href="#1-1-Object-构造函数" class="headerlink" title="1.1 Object 构造函数"></a>1.1 Object 构造函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Object([value])</span><br></pre></td></tr></table></figure>

<h2 id="1-2-对象字面量"><a href="#1-2-对象字面量" class="headerlink" title="1.2  对象字面量"></a>1.2  对象字面量</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>对象字面量内部调用了 <code>Object</code> 的构造函数</li>
<li>对象字面量与 <code>json</code> 的区别<ol>
<li><code>json</code> 属性只能是字符串</li>
<li><code>json</code> 值不能是函数和 <code>undefined</code></li>
</ol>
</li>
</ol>
<h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2 语法"></a>2 语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 标准形式</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	key: value,</span><br><span class="line">	key: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 方法定义可以简化</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	key: value,</span><br><span class="line">	key()&#123;&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 如果属性名是一个表达式，则使用[]包裹，意思是取表达式的值</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	[expr]: value,</span><br><span class="line">	key()&#123;&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 如果属性名和属性值与外部变量名和值都相同，可以简写</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"mm"</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    <span class="comment">// 可以简写</span></span><br><span class="line">	name,</span><br><span class="line">	key()&#123;&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-Object-的-create-方法"><a href="#1-3-Object-的-create-方法" class="headerlink" title="1.3 Object 的 create 方法"></a>1.3 Object 的 <code>create</code> 方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这种方式可以指定原型</span></span><br><span class="line"><span class="built_in">Object</span>.create(proto[, propertiesObject])</span><br></pre></td></tr></table></figure>

<h2 id="1-4-构造函数"><a href="#1-4-构造函数" class="headerlink" title="1.4 构造函数"></a>1.4 构造函数</h2><h3 id="1-内置构造函数"><a href="#1-内置构造函数" class="headerlink" title="1 内置构造函数"></a>1 内置构造函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Array()</span><br><span class="line">new Function()</span><br><span class="line">new String()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="2-自定义构造函数"><a href="#2-自定义构造函数" class="headerlink" title="2 自定义构造函数"></a>2 自定义构造函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 定义构造函数，构造函数名首字母大写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 构造函数名(<span class="params">形参列表</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.属性 = 值;</span><br><span class="line">	<span class="keyword">this</span>.方法 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 使用自定义构造创建对象</span></span><br><span class="line"><span class="keyword">new</span> 构造函数名(实参列表);</span><br></pre></td></tr></table></figure>

<h2 id="1-5-工厂函数"><a href="#1-5-工厂函数" class="headerlink" title="1.5 工厂函数"></a>1.5 工厂函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">userFactory</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">	<span class="comment">// 1</span></span><br><span class="line">	obj.name = name;</span><br><span class="line">	obj.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">	<span class="comment">// 2 简写</span></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		name,</span><br><span class="line">		show()&#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>与自定义构造函数方式的区别<ol>
<li>工厂函数是函数调用，自定义构造是 <code>new</code></li>
<li>工厂函数是函数名称小写，自定义构造名称大写</li>
<li>工厂函数内部需要显式创建一个对象，然后根据参数赋值后再显式返</li>
<li>自定义构造根据参数自动创建一个对象并返回</li>
</ol>
</li>
</ul>
<h1 id="二-对象属性"><a href="#二-对象属性" class="headerlink" title="二 对象属性"></a>二 对象属性</h1><h2 id="2-1-属性描述符"><a href="#2-1-属性描述符" class="headerlink" title="2.1 属性描述符"></a>2.1 属性描述符</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>property descriptor</code></li>
<li>JS 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为属性描述符，或者叫属性描述对象</li>
<li>元属性：属性描述符中的属性，用来描述对象属性的元信息，即描述对象属性的属性</li>
</ol>
<h3 id="2-分类（只能取其一）"><a href="#2-分类（只能取其一）" class="headerlink" title="2 分类（只能取其一）"></a>2 分类（只能取其一）</h3><table>
<thead>
<tr>
<th>分类</th>
<th>可以具有的元属性</th>
</tr>
</thead>
<tbody><tr>
<td>数据描述符</td>
<td><code>configurable enumerable value writable</code></td>
</tr>
<tr>
<td>存取描述符</td>
<td><code>configurable enumerable get set</code></td>
</tr>
</tbody></table>
<h3 id="3-元属性"><a href="#3-元属性" class="headerlink" title="3 元属性"></a>3 元属性</h3><table>
<thead>
<tr>
<th>元属性</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>value</code></td>
<td>表示该属性的值</td>
<td><code>undefined</code></td>
</tr>
<tr>
<td><code>writable</code></td>
<td>表示该属性是否可写</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>enumerable</code></td>
<td>表示该属性是否可遍历</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>configurable</code></td>
<td>1 该属性是否可删除<br>2 该属性的属性描述符是否可修改</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>get</code></td>
<td>表示该属性的取值函数 <code>getter</code></td>
<td><code>undefined</code></td>
</tr>
<tr>
<td><code>set</code></td>
<td>表示该属性的存值函数 <code>setter</code></td>
<td><code>undefined</code></td>
</tr>
</tbody></table>
<h2 id="2-2-属性管理"><a href="#2-2-属性管理" class="headerlink" title="2.2 属性管理"></a>2.2 属性管理</h2><h3 id="1-读写"><a href="#1-读写" class="headerlink" title="1 读写"></a>1 读写</h3><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>obj.property</code></td>
<td>必须是确定的属性名，且名称不特殊（数字、空格…）</td>
</tr>
<tr>
<td><code>obj[&#39;property&#39;]</code></td>
<td>属性名可以是表达式和变量，或者名称比较特殊</td>
</tr>
</tbody></table>
<h3 id="2-判断"><a href="#2-判断" class="headerlink" title="2 判断"></a>2 判断</h3><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>prop in obj</code></td>
<td>对象中是否有指定属性</td>
</tr>
</tbody></table>
<h3 id="3-删除"><a href="#3-删除" class="headerlink" title="3 删除"></a>3 删除</h3><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>delete object.property</code></td>
<td>删除属性，所有情况都返回 <code>true</code></td>
</tr>
<tr>
<td><code>delete object[&#39;property&#39;]</code></td>
<td>删除属性，所有情况都返回 <code>true</code></td>
</tr>
</tbody></table>
<h3 id="4-访问器（getter-setter）"><a href="#4-访问器（getter-setter）" class="headerlink" title="4 访问器（getter/setter）"></a>4 访问器（getter/setter）</h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>JS 中 <code>getter/setter</code> 的调用是当成属性来访问，自动调用方法</li>
<li>调用方式与属性访问方式一样<ol>
<li><code>obj.访问器名</code></li>
<li><code>obj[&#39;访问器名&#39;]</code></li>
</ol>
</li>
</ol>
<h4 id="2-语法-1"><a href="#2-语法-1" class="headerlink" title="2 语法"></a>2 语法</h4><table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>get prop() { ... }</code></td>
<td>访问器名称是一个有效标识符</td>
</tr>
<tr>
<td><code>get [expression]() { ... }</code></td>
<td>访问器名称可以是一个表达式</td>
</tr>
<tr>
<td><code>set prop(val) { . . . }</code></td>
<td>访问器名称是一个有效标识符</td>
</tr>
<tr>
<td><code>set [expression](val) { . . . }</code></td>
<td>访问器名称可以是一个表达式</td>
</tr>
</tbody></table>
<h4 id="3-定义方式"><a href="#3-定义方式" class="headerlink" title="3 定义方式"></a>3 定义方式</h4><ol>
<li><p>通过配置属性描述符的元属性定义访问器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	name : <span class="string">'小明'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">	<span class="keyword">get</span>() &#123;</span><br><span class="line">		<span class="keyword">return</span> obj.name; <span class="comment">// 注意：此处跟取值方式一样，也会调用get，会无限循环</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="keyword">set</span>(value) &#123;</span><br><span class="line">		obj.name = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.name; <span class="comment">// 调用get取值</span></span><br><span class="line">obj.name = <span class="string">'旺财'</span>; <span class="comment">// 调用set设置值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象字面量中直接定义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	_name: <span class="string">'小明'</span>,</span><br><span class="line">	<span class="keyword">get</span> name() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="keyword">set</span> name(value) &#123;</span><br><span class="line">		<span class="keyword">this</span>._name = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="三-对象拷贝"><a href="#三-对象拷贝" class="headerlink" title="三 对象拷贝"></a>三 对象拷贝</h1><h2 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h2><ol>
<li><p>浅拷贝</p>
<ul>
<li>如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 </li>
<li>一个对象修改可能会影响到另一个对象</li>
</ul>
</li>
<li><p>深拷贝</p>
<ul>
<li>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象</li>
<li>一个对象修改不会影响到另一个对象</li>
</ul>
</li>
</ol>
<h2 id="3-2-浅拷贝方式"><a href="#3-2-浅拷贝方式" class="headerlink" title="3.2 浅拷贝方式"></a>3.2 浅拷贝方式</h2><h3 id="1-for-in"><a href="#1-for-in" class="headerlink" title="1 for... in"></a>1 <code>for... in</code></h3><ul>
<li><p>创建新对象，然后使用<code>for...in</code>遍历原对象属性并连同值一起添加到新对象上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> source = &#123;<span class="attr">name</span>:<span class="string">'an3'</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> cp = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> source)&#123;</span><br><span class="line">	<span class="keyword">if</span>(source.hasOwnProperty(key)&#123;</span><br><span class="line">		cp[key] = source[key];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-Object-assign-target-sources"><a href="#2-Object-assign-target-sources" class="headerlink" title="2 Object.assign(target, ...sources)"></a>2 <code>Object.assign(target, ...sources)</code></h3><ul>
<li><p>将目标对象设为空对象，就相当于返回了原对象的浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> source = &#123;<span class="attr">name</span>:<span class="string">'an3'</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> cp = <span class="built_in">Object</span>.assign(&#123;&#125;, source);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-展开语法"><a href="#3-展开语法" class="headerlink" title="3 展开语法"></a>3 展开语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> source = &#123;<span class="attr">name</span>:<span class="string">'an3'</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> cp = &#123;...source&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-深拷贝方式"><a href="#3-3-深拷贝方式" class="headerlink" title="3.3 深拷贝方式"></a>3.3 深拷贝方式</h2><h3 id="1-JSON"><a href="#1-JSON" class="headerlink" title="1 JSON"></a>1 <code>JSON</code></h3><ol>
<li>步骤<ol>
<li><code>JSON.stringify()</code>：将一个对象序列成一个字符串</li>
<li><code>JSON.parse()</code>：将字符串反序列化生成深拷贝对象</li>
</ol>
</li>
<li>注意<ol>
<li>拷贝的对象的值中如果有 <code>函数、undefined、symbol</code> 则经过 <code>JSON.stringify()</code> 序列化后的 <code>JSON</code> 字符串中这个键值对会消失</li>
<li>无法拷贝不可枚举的属性，无法拷贝对象的原型链</li>
<li>拷贝 <code>Date</code> 引用类型会变成字符串</li>
<li>拷贝 <code>RegExp</code> 引用类型会变成空对象</li>
<li>对象中含有 <code>NaN、Infinity、-Infinity</code> ，则序列化的结果会变成 <code>null</code></li>
<li>无法拷贝对象的循环应用，即 <code>obj[key] = obj</code></li>
</ol>
</li>
</ol>
<h3 id="2-递归"><a href="#2-递归" class="headerlink" title="2 递归"></a>2 递归</h3><ul>
<li><p>原理就是浅拷贝只拷贝一层，利用递归，如果这一层属性的值是引用类型，就再拷贝一层 …</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 对象的属性值有可能是数组，判断一下防止递归时把数组变成了对象</span></span><br><span class="line">	<span class="keyword">let</span> cpObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">	<span class="comment">// Object.entries()方法对于对象和数组返回结果形式是一样的</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">const</span> [k, v] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj)) &#123;</span><br><span class="line">		<span class="comment">// 判断对象属性如果是引用类型就递归拷贝</span></span><br><span class="line">		cpObj[k] = <span class="keyword">typeof</span> v == <span class="string">'object'</span> ? deepCopy(v) : v;</span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> cpObj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="四-Object"><a href="#四-Object" class="headerlink" title="四 Object"></a>四 Object</h1><h2 id="4-1-构造函数"><a href="#4-1-构造函数" class="headerlink" title="4.1 构造函数"></a>4.1 构造函数</h2><table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>new Object([value])</code></td>
<td>构造函数</td>
<td>创建一个对象</td>
</tr>
<tr>
<td><code>Object([value])</code></td>
<td>类型转换函数</td>
<td>将 <code>value</code> 转成一个对象</td>
</tr>
</tbody></table>
<ul>
<li><code>value</code> ：<ol>
<li>为空或者是 <code>undefined null</code>，返回一个空对象</li>
<li>是基本类型的值则返回其包装对象</li>
<li>是引用类型则直接返回</li>
</ol>
</li>
</ul>
<h2 id="4-2-静态方法"><a href="#4-2-静态方法" class="headerlink" title="4.2 静态方法"></a>4.2 静态方法</h2><h3 id="1-属性"><a href="#1-属性" class="headerlink" title="1 属性"></a>1 属性</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object.keys(obj)</code></td>
<td>返回对象自身可枚举属性键的数组</td>
</tr>
<tr>
<td><code>Object.values(obj)</code></td>
<td>返回对象自身可枚举属性值的数组</td>
</tr>
<tr>
<td><code>Object.entries(obj)</code></td>
<td>返回对象自身可枚举属性键值对的数组</td>
</tr>
<tr>
<td><code>Object.getOwnPropertyNames(obj)</code></td>
<td>返回对象自身的所有属性（包含可枚举和不可枚举属性，不包含 <code>Symbol</code> 属性）键的数组</td>
</tr>
<tr>
<td><code>Object.getOwnPropertySymbols(obj)</code></td>
<td>返回对象自身的所有 <code>Symbol</code> 属性的数组</td>
</tr>
</tbody></table>
<h3 id="2-属性描述符"><a href="#2-属性描述符" class="headerlink" title="2 属性描述符"></a>2 属性描述符</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object.getOwnPropertyDescriptor(obj, prop)</code></td>
<td>获取对象自身某个属性的属性描述符</td>
</tr>
<tr>
<td><code>Object.getOwnPropertyDescriptors(obj)</code></td>
<td>获取对象自身所有属性的属性描述符</td>
</tr>
<tr>
<td><code>Object.defineProperty(obj, prop, descriptor)</code></td>
<td>如果对象自身存在指定属性，则修改它的属性描述符，否则为对象添加指定属性并定义属性描述符，返回该对象</td>
</tr>
<tr>
<td><code>Object.defineProperties(obj, props)</code></td>
<td>修改或添加对象多个属性的属性描述对象，返回该对象</td>
</tr>
</tbody></table>
<h3 id="3-创建对象"><a href="#3-创建对象" class="headerlink" title="3 创建对象"></a>3 创建对象</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object.create(proto[, propertiesObject])</code></td>
<td>根据原型对象和属性（使用属性描述符定义），创建一个新的对象</td>
</tr>
<tr>
<td><code>Object.fromEntries(iterable)</code></td>
<td>把键值对列表转换为一个对象，是 <code>Object.entries()</code> 的反转</td>
</tr>
<tr>
<td><code>Object.assign(target, ...sources)</code></td>
<td>将 n 个源对象的所有可枚举属性复制到目标对象，并返回目标对象</td>
</tr>
</tbody></table>
<ul>
<li><code>Object.assign(target, ...sources)</code><ol>
<li>如果目标对象与源对象有同名属性，或多个源对象有同名属性，后边覆盖前边</li>
<li><code>Object.assign</code> 方法实行的是浅拷贝</li>
<li>数组会被当作对象，即相同索引会覆盖</li>
<li>如果属性值是取值函数，会计算后再复制</li>
</ol>
</li>
</ul>
<h3 id="4-原型对象"><a href="#4-原型对象" class="headerlink" title="4 原型对象"></a>4 原型对象</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object.getPrototypeOf(obj)</code></td>
<td>获取对象的原型对象，即<code>obj.__proto__</code></td>
</tr>
<tr>
<td><code>Object.setPrototypeOf(obj, prototype)</code></td>
<td>获取对象的原型对象</td>
</tr>
</tbody></table>
<h3 id="5-比较"><a href="#5-比较" class="headerlink" title="5 比较"></a>5 比较</h3><ul>
<li><code>Object.is(value1, value2)</code><ul>
<li>判断两个值是否相等，不会作类型转换</li>
<li>与<code>===</code>的区别<ol>
<li><code>===</code> 认为<code>-0</code>和<code>+0</code>相等，此方法认为不相等</li>
<li><code>===</code> 认为<code>NaN</code>和<code>NaN</code>不相等，此方法认为相等</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="6-状态"><a href="#6-状态" class="headerlink" title="6 状态"></a>6 状态</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object.preventExtensions(obj)</code></td>
<td>让一个对象变的不可扩展，即永远不能添加新的属性</td>
</tr>
<tr>
<td><code>Object.isExtensible(obj)</code></td>
<td>判断一个对象是否可扩展</td>
</tr>
<tr>
<td><code>Object.seal(obj)</code></td>
<td>封闭一个对象，此对象不可扩展且对象所有自身属性的<code>configurable</code>标记为 <code>false</code>，即不能添加、删除属性，属性修饰符不可配置</td>
</tr>
<tr>
<td><code>Object.isSealed(obj)</code></td>
<td>判断一个对象是否被封闭</td>
</tr>
<tr>
<td><code>Object.freeze(obj)</code></td>
<td>冻结一个对象，此对象不可扩展且对象所有自身属性 <code>writable configurable</code> 标记为 <code>false</code>，即不能添加、修改和删除属性，属性修饰符不可配置</td>
</tr>
<tr>
<td><code>Object.isFrozen(obj)</code></td>
<td>判断一个对象是否被冻结</td>
</tr>
</tbody></table>
<h2 id="4-3-原型方法-Object-prototype"><a href="#4-3-原型方法-Object-prototype" class="headerlink" title="4.3 原型方法 Object.prototype."></a>4.3 原型方法 <code>Object.prototype.</code></h2><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>toString()</code></td>
<td>默认返回 <code>[object type]</code>，通常会覆盖</td>
</tr>
<tr>
<td><code>toLocaleString()</code></td>
<td>默认返回 <code>toString()</code> 的结果，可以覆盖</td>
</tr>
<tr>
<td><code>hasOwnProperty(prop)</code></td>
<td>判断对象自身是否含有某个属性</td>
</tr>
<tr>
<td><code>propertyIsEnumerable(prop)</code></td>
<td>判断某个属性是否可枚举</td>
</tr>
<tr>
<td><code>isPrototypeOf(object)</code></td>
<td>判断调用对象是否在另一个对象的原型链上</td>
</tr>
<tr>
<td><code>valueOf()</code></td>
<td>返回对象原始值，若没有原始值，返回对象本身，通常会覆盖</td>
</tr>
</tbody></table>
<ol>
<li><p><code>isPrototypeOf(object)</code> 和 <code>instanceof</code> 的区别</p>
<ol>
<li><code>A instanceof B</code> ：判断 <code>B.prototype</code>是否在 <code>A</code> 的原型链上</li>
<li><code>B.isPrototypeOf(A)</code>：判断 <code>B</code> 是否在 <code>A</code> 的原型链上</li>
</ol>
</li>
<li><p><code>valueOf()</code> 返回值</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>对象</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td><code>Number</code></td>
<td>数值</td>
</tr>
<tr>
<td><code>Boolean</code></td>
<td>布尔值</td>
</tr>
<tr>
<td><code>String</code></td>
<td>字符串值</td>
</tr>
<tr>
<td><code>Object</code></td>
<td>对象本身</td>
</tr>
<tr>
<td><code>Array</code></td>
<td>数组本身</td>
</tr>
<tr>
<td><code>Function</code></td>
<td>函数本身</td>
</tr>
<tr>
<td><code>Date</code></td>
<td>距离1970-01-01 00:00:00 的毫秒数</td>
</tr>
</tbody></table>
<h1 id="五-代理"><a href="#五-代理" class="headerlink" title="五 代理"></a>五 代理</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol>
<li>代理（拦截器）是对象的访问控制</li>
<li><code>setter/getter</code> 访问器是对对象属性的访问控制</li>
</ol>
<h2 id="5-2-Proxy（代理对象）"><a href="#5-2-Proxy（代理对象）" class="headerlink" title="5.2 Proxy（代理对象）"></a>5.2 Proxy（代理对象）</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><ul>
<li><code>new Proxy(target, handler)</code><ul>
<li>返回一个代理对象</li>
<li><code>target</code><ul>
<li>用 <code>Proxy</code> 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）</li>
</ul>
</li>
<li><code>handler</code><ul>
<li>处理器对象，有许多拦截相应操作的函数，如果没有配置，则执行默认操作</li>
<li>注意：处理操作都是针对代理对象的，目标对象无效。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-handler（处理器对象）"><a href="#2-handler（处理器对象）" class="headerlink" title="2 handler（处理器对象）"></a>2 handler（处理器对象）</h3><ol>
<li><code>get(target, property, receiver)</code><ul>
<li>参数<ul>
<li><code>target</code><ul>
<li>目标对象</li>
</ul>
</li>
<li><code>property</code><ul>
<li>获取的属性名</li>
</ul>
</li>
<li><code>reveiver</code><ul>
<li>Proxy或者继承Proxy的对象</li>
</ul>
</li>
</ul>
</li>
<li>说明<ul>
<li>get 方法拦截属性的获取，可以返回任何值</li>
</ul>
</li>
</ul>
</li>
<li><code>set(target, property, value, receiver)</code><ul>
<li>参数<ul>
<li><code>value</code><ul>
<li>被设置的新值</li>
</ul>
</li>
</ul>
</li>
<li>说明<ul>
<li>set 方法拦截属性的设置</li>
<li>严格模式下 set 必须返回布尔值，且如果返回false会报错</li>
</ul>
</li>
</ul>
</li>
<li><code>apply(target, thisArg, argumentsList)</code><ul>
<li>参数<ul>
<li><code>target</code><ul>
<li>目标函数</li>
</ul>
</li>
<li><code>thisArg</code><ul>
<li>被调用时的上下文对象</li>
</ul>
</li>
<li><code>argumentsList</code><ul>
<li>被调用时的参数数组</li>
</ul>
</li>
</ul>
</li>
<li>说明<ul>
<li>apply 方法拦截函数调用，可以返回任何值<ol>
<li>直接调用</li>
<li><code>Function.prototype.call()</code> 方式调用</li>
<li><code>Function.prototype.apply()</code> 方式调用</li>
<li><code>Reflet.apply()</code> 方式调用</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><code>has(target, prop)</code><ul>
<li>参数<ul>
<li><code>target</code><ul>
<li>目标对象</li>
</ul>
</li>
<li><code>prop</code><ul>
<li>需要检查是否存在的属性.</li>
</ul>
</li>
</ul>
</li>
<li>说明<ul>
<li>拦截 <code>prop in object</code> 语句，返回布尔值</li>
</ul>
</li>
</ul>
</li>
<li><code>construct(target, argumentsList, newTarget)</code><ul>
<li>参数<ul>
<li><code>target</code><ul>
<li>目标构造函数</li>
</ul>
</li>
<li><code>argumentsList</code><ul>
<li>constructor的参数列表</li>
</ul>
</li>
<li><code>newTarget</code><ul>
<li>生成的代理对象（即代理构造函数）</li>
</ul>
</li>
</ul>
</li>
<li>说明<ul>
<li>拦截new操作，必须返回一个对象</li>
</ul>
</li>
</ul>
</li>
<li><code>deleteProperty(target, prop)</code><ul>
<li>拦截<code>delete</code> 操作，必须返回布尔值</li>
</ul>
</li>
<li><code>defineProperty(target, property, descriptor)</code><ul>
<li>拦截<code>Object.defineProperty()</code>，必须返回布尔值</li>
</ul>
</li>
<li><code>getOwnPropertyDescriptor(target, prop)</code><ul>
<li>拦截 <code>Object.getOwnPropertyDescriptor()</code>，必须返回一个对象或undefined</li>
</ul>
</li>
<li><code>getPrototypeOf(target)</code><ul>
<li>拦截获取原型操作</li>
</ul>
</li>
<li><code>setPrototypeOf(target, prototype)</code><ul>
<li>拦截设置原型操作，返回布尔值</li>
</ul>
</li>
<li><code>preventExtensions(target)</code><ul>
<li>拦截<code>Object.preventExtensions()</code>，返回一个布尔值</li>
</ul>
</li>
<li><code>isExtensible(target)</code><ul>
<li>拦截<code>Object.isExtensible()</code>，必须返回布尔值</li>
</ul>
</li>
<li><code>ownKeys(target)</code><ul>
<li>拦截对象获取自身属性的操作</li>
</ul>
</li>
</ol>
<h1 id="六-Reflect"><a href="#六-Reflect" class="headerlink" title="六 Reflect"></a>六 Reflect</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><ol>
<li><code>Reflect</code> 不是一个构造函数，不能 <code>new</code>，<code>Reflect</code> 的所有属性和方法都是静态的</li>
<li>将 <code>Object</code> 对象的一些明显属于语言内部的方法（如<code>Object.defineProperty()</code>），放到 <code>Reflect</code> 对象上</li>
<li>修改某些 <code>Object</code> 方法的返回结果，让其变得更合理<ul>
<li>如 <code>Object.defineProperty()</code>无法定义属性时，会抛出错误，而<code>Reflect.defineProperty()</code>会返回false</li>
</ul>
</li>
<li>让 <code>Object</code> 操作都变成函数行为<ul>
<li>如 <code>prop in object</code> ，对应<code>Reflect.has(obj, prop)</code></li>
<li><code>delete obj.prop</code>，对应<code>Reflect.deleteProperty(obj, prop)</code></li>
</ul>
</li>
<li><code>Reflect</code> 对象与 <code>Proxy</code> 的 <code>handler</code> 方法完全一致，在使用代理拦截某些操作时，使用 <code>Reflect</code> 的方法可以保证原生行为能正常执行。</li>
</ol>
<h2 id="6-2-静态方法"><a href="#6-2-静态方法" class="headerlink" title="6.2 静态方法"></a>6.2 静态方法</h2><ul>
<li>见 <code>Proxy handler</code></li>
</ul>
<h1 id="七-this"><a href="#七-this" class="headerlink" title="七 this"></a>七 this</h1><table>
<thead>
<tr>
<th>场景</th>
<th><code>this</code> 指向</th>
</tr>
</thead>
<tbody><tr>
<td>全局作用域，普通函数</td>
<td>非严格模式 <code>window</code><br>严格模式 <code>undefined</code></td>
</tr>
<tr>
<td>对象中</td>
<td>当前对象</td>
</tr>
<tr>
<td>对象方法中</td>
<td>调用该方法的对象</td>
</tr>
<tr>
<td>原型对象方法中</td>
<td>调用该方法的对象</td>
</tr>
<tr>
<td>构造函数中</td>
<td>正在构造的新对象</td>
</tr>
<tr>
<td>箭头函数中</td>
<td>与箭头函数所在作用域的 <code>this</code> 指向一致</td>
</tr>
<tr>
<td>DOM 事件处理函数中</td>
<td>绑定事件的元素</td>
</tr>
<tr>
<td>回调函数</td>
<td><code>window</code></td>
</tr>
<tr>
<td>内联事件处理函数中</td>
<td><code>window</code></td>
</tr>
<tr>
<td>立即执行函数</td>
<td><code>window</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>JS基本类型及包装类</title>
    <url>/anyeansan.github.io/2020/11/08/UI/JS%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="一-number"><a href="#一-number" class="headerlink" title="一 number"></a>一 number</h1><h2 id="1-1-说明"><a href="#1-1-说明" class="headerlink" title="1.1 说明"></a>1.1 说明</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>任意数字</code></td>
<td>整数或者浮点数</td>
</tr>
<tr>
<td><code>+Infinity</code></td>
<td>正无穷</td>
</tr>
<tr>
<td><code>-Infinity</code></td>
<td>负无穷</td>
</tr>
<tr>
<td><code>NaN</code></td>
<td><code>not a number</code> 一个不是数字的数字类型</td>
</tr>
</tbody></table>
<ol>
<li>JavaScript 的 number 类型为双精度IEEE 754 64位浮点类型。范围（-2<sup>53</sup>- 2<sup>53</sup>） </li>
<li>JavaScript 内部，整数和浮点数采用的是同样的储存方法。所以<code>1===1.0</code> 为true</li>
<li>进制<ul>
<li>十进制</li>
<li>二进制：以 <code>0b</code> 开头</li>
<li>八进制：以 <code>0o</code>开头</li>
<li>十六进制：以 <code>0x</code> 开头</li>
</ul>
</li>
</ol>
<h2 id="1-2-Number（包装类）"><a href="#1-2-Number（包装类）" class="headerlink" title="1.2 Number（包装类）"></a>1.2 Number（包装类）</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>new Number([value])</code></td>
<td>构造函数</td>
<td>创建一个 <code>Number</code> 对象</td>
</tr>
<tr>
<td><code>Number([value])</code></td>
<td>类型转换函数</td>
<td>将 <code>value</code> 转成一个 <code>number</code></td>
</tr>
</tbody></table>
<h3 id="2-静态属性"><a href="#2-静态属性" class="headerlink" title="2 静态属性"></a>2 静态属性</h3><table>
<thead>
<tr>
<th>静态属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Number.POSITIVE_INFINITY</code></td>
<td>正无穷，指向 <code>+Infinity</code></td>
</tr>
<tr>
<td><code>Number.NEGATIVE_INFINITY</code></td>
<td>负无穷，指向 <code>-Infinity</code></td>
</tr>
<tr>
<td><code>Number.NaN</code></td>
<td><code>NaN</code></td>
</tr>
<tr>
<td><code>Number.MIN_VALUE</code></td>
<td>最小正值</td>
</tr>
<tr>
<td><code>Number.MAX_VALUE</code></td>
<td>最大数值</td>
</tr>
<tr>
<td><code>Number.MIN_SAFE_INTEGER</code></td>
<td>JS 中能够准确表示的整数范围下限</td>
</tr>
<tr>
<td><code>Number.MAX_SAFE_INTEGER</code></td>
<td>JS 中能够准确表示的整数范围上限</td>
</tr>
<tr>
<td><code>Number.EPSILON</code></td>
<td>表示 1 与大于 1 的最小的浮点数之间的差值，即 JS 的精度</td>
</tr>
</tbody></table>
<h3 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="3 静态方法"></a>3 静态方法</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Number.isNaN(value)</code></td>
<td>判断是否是 <code>NaN</code></td>
</tr>
<tr>
<td><code>Number.isFinite(value)</code></td>
<td>判断否是有穷数</td>
</tr>
<tr>
<td><code>Number.isInteger(value)</code></td>
<td>判断是否是整数</td>
</tr>
<tr>
<td><code>Number.parseInt(string[, radix])</code></td>
<td>将一个字符串转换成指定进制的整数，<code>radix</code> ：进制 <code>2-36</code>，默认 <code>10</code></td>
</tr>
<tr>
<td><code>Number.parseFloat(string)</code></td>
<td>将一个字符串转换成浮点数</td>
</tr>
</tbody></table>
<ol>
<li><code>Number.isNaN(value)</code> &amp; <code>window.isNaN()</code><ul>
<li>全局函数 <code>isNaN()</code> 会先将非数值转换为数值，再进行判断</li>
<li><code>Number.isNaN()</code> 只对数值有效，非数值直接返回 <code>false</code></li>
</ul>
</li>
<li><code>Number.isFinite(value)</code> &amp; <code>window.isFinite()</code><ul>
<li>全局函数 <code>isFinite()</code> 会先将非数值转换为数值，再进行判断</li>
<li><code>Number.isFinite()</code> 只对数值有效，非数值直接返回 <code>false</code></li>
</ul>
</li>
</ol>
<h3 id="4-原型方法-Number-prototype"><a href="#4-原型方法-Number-prototype" class="headerlink" title="4 原型方法 Number.prototype."></a>4 原型方法 <code>Number.prototype.</code></h3><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>valueOf()</code></td>
<td>返回 <code>number</code> 值</td>
</tr>
<tr>
<td><code>toString([radix])</code></td>
<td>返回字符串形式</td>
</tr>
<tr>
<td><code>toFixed([digits])</code></td>
<td>返回保留指定位数浮点数的字符串</td>
</tr>
</tbody></table>
<h1 id="二-boolean"><a href="#二-boolean" class="headerlink" title="二 boolean"></a>二 boolean</h1><h2 id="2-1-说明"><a href="#2-1-说明" class="headerlink" title="2.1 说明"></a>2.1 说明</h2><table>
<thead>
<tr>
<th>项</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code>（布尔值）</td>
<td><code>false, true</code></td>
</tr>
<tr>
<td><code>Falsy</code>（类假值）</td>
<td><code>false, 0, &#39;&#39;, undefined, null, NaN</code></td>
</tr>
<tr>
<td><code>Truthy</code>（类真值）</td>
<td>非 <code>Falsy</code> 的值</td>
</tr>
</tbody></table>
<ol>
<li>隐式转换<ul>
<li><code>Falsy</code> 可以隐式转换为 <code>false</code>；<code>Truthy</code> 可以隐式转换为 <code>true</code></li>
<li>注意：值和布尔值是不同的概念</li>
</ul>
</li>
<li>显式转换<ol>
<li><code>Boolean()</code></li>
<li><code>!!</code></li>
<li><code>new Boolean()</code><ul>
<li>不推荐，因为返回一个对象，而对象是 <code>Truthy</code> 转为布尔值必为 <code>true</code></li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="2-2-Boolean（包装类）"><a href="#2-2-Boolean（包装类）" class="headerlink" title="2.2 Boolean（包装类）"></a>2.2 Boolean（包装类）</h2><h3 id="1-构造函数-1"><a href="#1-构造函数-1" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>new Boolean([value])</code></td>
<td>构造函数</td>
<td>创建一个 <code>Boolean</code> 对象</td>
</tr>
<tr>
<td><code>Boolean([value])</code></td>
<td>类型转换函数</td>
<td>将 <code>value</code> 转成一个布尔值</td>
</tr>
</tbody></table>
<h3 id="2-原型方法-Boolean-prototype"><a href="#2-原型方法-Boolean-prototype" class="headerlink" title="2 原型方法 Boolean.prototype."></a>2 原型方法 <code>Boolean.prototype.</code></h3><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>toString()</code></td>
<td>返回布尔值的字符串形式</td>
</tr>
<tr>
<td><code>valueOf()</code></td>
<td>返回布尔值</td>
</tr>
</tbody></table>
<h1 id="三-string"><a href="#三-string" class="headerlink" title="三 string"></a>三 string</h1><h2 id="3-1-说明"><a href="#3-1-说明" class="headerlink" title="3.1 说明"></a>3.1 说明</h2><h3 id="1-字符串字面量"><a href="#1-字符串字面量" class="headerlink" title="1 字符串字面量"></a>1 字符串字面量</h3><table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&quot;&quot;</code> <code>&#39;&#39;</code></td>
<td>单/双引号，特殊字符使用 <code>\</code> 转义</td>
</tr>
<tr>
<td><code>&#96;&#96;</code></td>
<td>反引号，模板字面量，特殊字符（反引号自身需要<code>\</code>转义）可以直接使用</td>
</tr>
<tr>
<td><code>\uxxxx</code></td>
<td>只限 Unicode 编码在 <code>\u0000~\uFFFF</code>（0-65535）之间的字符</td>
</tr>
<tr>
<td><code>\u{xxxx}</code></td>
<td>大于<code>\uFFFF</code>的字符也能正确表示</td>
</tr>
</tbody></table>
<h3 id="2-模板字面量"><a href="#2-模板字面量" class="headerlink" title="2 模板字面量"></a>2 模板字面量</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>模板字面量是增强版的字符串，它用反引号标识</li>
<li>空格换行等都会原样输出</li>
<li><code>${表达式}</code> <ul>
<li>占位符就如同一个普通字符串一样，可以插入到字符串中的任意位置</li>
<li>作用是取表达式的值</li>
</ul>
</li>
<li>反引号可以嵌套</li>
</ol>
<h4 id="2-模板字面量标签"><a href="#2-模板字面量标签" class="headerlink" title="2 模板字面量标签"></a>2 模板字面量标签</h4><ol>
<li><p>模板字面量标签通常是一个函数</p>
</li>
<li><p>调用标签函数，将它放在模板字面量前面即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 内置函数</span><br><span class="line">alert`hello`;</span><br><span class="line">2 自定义函数</span><br><span class="line">function myTag (strings, ...values)&#123;&#125;</span><br><span class="line">myTag`hello`</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用标签函数时，会将模板字面量处理成参数，传递给函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let name = &apos;xiaoming&apos;, age = 18;</span><br><span class="line">alert`hello$&#123;name&#125;,ni$&#123;18&#125;了吗`; </span><br><span class="line">// 相当于</span><br><span class="line">alert ([&apos;hello&apos;, &apos;,ni&apos;, &apos;了吗&apos;], &apos;xiaoming&apos;, 18);</span><br></pre></td></tr></table></figure>

<ol>
<li>第一个参数是数组，存储模板字面量中占位符<code>${}</code>两侧的字符串</li>
<li>第二个参数是可变参数，存储占位符<code>${}</code>的返回值</li>
</ol>
</li>
</ol>
<h3 id="3-字符串换行"><a href="#3-字符串换行" class="headerlink" title="3 字符串换行"></a>3 字符串换行</h3><ol>
<li>末尾加<code>\</code></li>
<li>加号连接</li>
<li>反引号</li>
</ol>
<h2 id="3-2-String（包装类）"><a href="#3-2-String（包装类）" class="headerlink" title="3.2 String（包装类）"></a>3.2 String（包装类）</h2><h3 id="1-构造函数-2"><a href="#1-构造函数-2" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>new String([value])</code></td>
<td>构造函数</td>
<td>创建一个 <code>String</code> 对象</td>
</tr>
<tr>
<td><code>String([value])</code></td>
<td>类型转换函数</td>
<td>将 <code>value</code> 转成一个字符串</td>
</tr>
</tbody></table>
<ul>
<li>由于字符串的不可变性，字符串中的所有方法都不改变原字符串</li>
</ul>
<h3 id="2-实例属性"><a href="#2-实例属性" class="headerlink" title="2 实例属性"></a>2 实例属性</h3><table>
<thead>
<tr>
<th>实例属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>length</code></td>
<td>字符数</td>
</tr>
</tbody></table>
<h3 id="3-静态方法-1"><a href="#3-静态方法-1" class="headerlink" title="3 静态方法"></a>3 静态方法</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String.fromCharCode(charCode1, ..., charCodeN)</code></td>
<td>返回使用指定的 Unicode 编码创建的字符串，不能识别大于<code>0xFFFF</code>的字符</td>
</tr>
<tr>
<td><code>String.fromCodePoint(num1[, ...[, numN]])</code></td>
<td>返回使用指定的 Unicode 编码创建的字符串，识别大于<code>0xFFFF</code>的字符</td>
</tr>
<tr>
<td><code>String.raw&#96;templateString&#96;</code></td>
<td>返回模板字符串的原始字符串</td>
</tr>
</tbody></table>
<h3 id="4-原型方法-String-prototype"><a href="#4-原型方法-String-prototype" class="headerlink" title="4 原型方法 String.prototype."></a>4 原型方法 <code>String.prototype.</code></h3><h4 id="1-查"><a href="#1-查" class="headerlink" title="1 查"></a>1 查</h4><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>charAt(index)</code></td>
<td>返回指定索引的字符</td>
</tr>
<tr>
<td><code>str[index]</code></td>
<td>等效于 <code>charAt(index)</code></td>
</tr>
<tr>
<td><code>charCodeAt(index)</code></td>
<td>返回指定索引字符的 Unicode 码，只能获取两个字节的字符</td>
</tr>
<tr>
<td><code>codePointAt(index)</code></td>
<td>返回指定索引字符的 Unicode 码</td>
</tr>
<tr>
<td><code>indexOf(searchValue[, fromIndex])</code></td>
<td>返回第一次出现的索引，未找到返回 <code>-1</code></td>
</tr>
<tr>
<td><code>lastIndexOf(searchValue[, fromIndex])</code></td>
<td>返回从后往前第一次出现的索引，未找到返回 <code>-1</code></td>
</tr>
</tbody></table>
<h4 id="2-获取"><a href="#2-获取" class="headerlink" title="2 获取"></a>2 获取</h4><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>valueOf()</code></td>
<td>返回字符串对象的原始字符串</td>
</tr>
<tr>
<td><code>repeat(count)</code></td>
<td>返回当前字符串重复 <code>count</code> 次组成的新字符串</td>
</tr>
<tr>
<td><code>concat(str1, str2[, ..., strN])</code></td>
<td>连接字符串并返回</td>
</tr>
<tr>
<td><code>slice(beginIndex[, endIndex])</code></td>
<td>提取 <code>[begin,end)</code> 索引之间的字符串并返回，索引可以为负</td>
</tr>
<tr>
<td><code>substring(beginIndex[, endIndex])</code></td>
<td>提取 <code>[begin,end)</code> 索引之间的字符串并返回，</td>
</tr>
</tbody></table>
<h4 id="3-改"><a href="#3-改" class="headerlink" title="3 改"></a>3 改</h4><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>toLowerCase()</code></td>
<td>转小写</td>
</tr>
<tr>
<td><code>toUpperCase()</code></td>
<td>转大写</td>
</tr>
<tr>
<td><code>trim()</code></td>
<td>去除字符串两端的空格</td>
</tr>
<tr>
<td><code>padStart(targetLength [, padString])</code></td>
<td>以指定字符串 <code>padString</code> 在原字符串开头补充，以达到目标长度 <code>targetLength</code></td>
</tr>
<tr>
<td><code>padEnd(targetLength [, padString])</code></td>
<td>以指定字符串 <code>padString</code> 在原字符串末尾补充，以达到目标长度 <code>targetLength</code></td>
</tr>
</tbody></table>
<h4 id="4-判断"><a href="#4-判断" class="headerlink" title="4 判断"></a>4 判断</h4><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>includes(searchString[, fromIndex])</code></td>
<td>判断是否包含指定字符串</td>
</tr>
<tr>
<td><code>startsWith(searchString[, fromIndex])</code></td>
<td>判断是否以指定字符串开头</td>
</tr>
<tr>
<td><code>endsWith(searchString[, length])</code></td>
<td>判断是否以指定字符串结尾，<code>length</code> 表示只判断原字符串指定长度</td>
</tr>
</tbody></table>
<h4 id="5-正则"><a href="#5-正则" class="headerlink" title="5 正则"></a>5 正则</h4><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>split([separator[, limit]])</code></td>
<td>按照给定规则分割字符串，返回一个由分割出来的子字符串以指定分隔符组成的数组</td>
</tr>
<tr>
<td><code>search(regexp)</code></td>
<td>返回首次匹配项的索引，无匹配返回 <code>-1</code></td>
</tr>
<tr>
<td><code>match(regexp)</code></td>
<td>正则有 <code>g</code>，则返回所有匹配结果的数组（无附加属性），正则无 <code>g</code>，则返回只有第一个匹配结果的数组（有附加属性），无匹配返回 <code>null</code></td>
</tr>
<tr>
<td><code>matchAll(regexp)</code></td>
<td>返回所有匹配结果的迭代器（包含附加属性）</td>
</tr>
</tbody></table>
<h4 id="6-替换"><a href="#6-替换" class="headerlink" title="6 替换"></a>6 替换</h4><ul>
<li><code>replace(regexp|substr, newSubStr|function)</code><ul>
<li><code>regexp|substr</code><ul>
<li>正则匹配的内容或者指定的内容</li>
</ul>
</li>
<li><code>newSubStr</code><ul>
<li>使用新的字符串替换，替换时可以插入特殊变量</li>
</ul>
</li>
<li><code>function</code><ul>
<li>使用函数返回的字符串替换</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">特殊变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>$$</code></td>
<td>插入一个 “$”</td>
</tr>
<tr>
<td align="center"><code>$&amp;</code></td>
<td>插入匹配的子串</td>
</tr>
<tr>
<td align="center">$`</td>
<td>插入当前匹配的子串左边的内容</td>
</tr>
<tr>
<td align="center"><code>$&#39;</code></td>
<td>插入当前匹配的子串右边的内容</td>
</tr>
<tr>
<td align="center"><code>$n</code></td>
<td>如果第一个参数是RegExp对象，表示插入第n组的内容</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">函数参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>match</code></td>
<td>匹配的子串。（对应<code>$&amp;</code>。）</td>
</tr>
<tr>
<td align="center"><code>p1,p2,...</code></td>
<td>如果第一个参数是RegExp对象，表示第n组的内容（对应<code>$n</code>）</td>
</tr>
<tr>
<td align="center"><code>offset</code></td>
<td>匹配到的子字符串在原字符串中起始索引</td>
</tr>
<tr>
<td align="center"><code>string</code></td>
<td>被匹配的原字符串</td>
</tr>
<tr>
<td align="center"><code>NamedCaptureGroup</code></td>
<td>命名捕获组匹配的对象</td>
</tr>
</tbody></table>
<h1 id="四-undefined"><a href="#四-undefined" class="headerlink" title="四 undefined"></a>四 undefined</h1><ol>
<li><code>undefined</code> 是一种类型，且只有一个值 <code>undefined</code></li>
<li>一个变量没有指定类型（没有赋值则不能确定类型），则默认为 <code>undefined</code> 类型，其值也是 <code>undefined</code><ul>
<li>变量或者对象属性没有赋值，默认值为 <code>undefined</code></li>
<li>调用函数时，没有传值的参数默认值为 <code>undefined</code></li>
<li>函数没有返回值时，默认返回 <code>undefined</code></li>
</ul>
</li>
</ol>
<h1 id="五-symbol"><a href="#五-symbol" class="headerlink" title="五 symbol"></a>五 symbol</h1><h2 id="5-1-说明"><a href="#5-1-说明" class="headerlink" title="5.1 说明"></a>5.1 说明</h2><ol>
<li>symbol 的值是唯一的，独一无二的，不会重复的</li>
<li>symbol 值作为对象属性名时，不能用点运算符，只能使用<code>[]</code><ol>
<li>不会被<code>for...in for... of</code>遍历到</li>
<li>不会被 <code>Object.keys() Object.getOwnPropertyNames() JSON.stringify()</code> 返回</li>
<li>使用<code>Object.getOwnPropertySymbols()</code>可以获取</li>
</ol>
</li>
<li>symbol 值不能与其他类型的值进行运算，可以转为字符串和布尔值</li>
</ol>
<h2 id="5-2-Symbol（包装类）"><a href="#5-2-Symbol（包装类）" class="headerlink" title="5.2 Symbol（包装类）"></a>5.2 Symbol（包装类）</h2><h3 id="1-构造函数-3"><a href="#1-构造函数-3" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Symbol([description])</code></td>
<td>返回一个唯一的 <code>symbol</code> 值，不会放入全局 <code>symbol</code> 注册表，<code>description</code>：只是描述，不影响 <code>symbol</code> 值</td>
</tr>
<tr>
<td><code>new Symbol()</code></td>
<td>不支持此语法</td>
</tr>
</tbody></table>
<h3 id="2-静态属性-1"><a href="#2-静态属性-1" class="headerlink" title="2 静态属性"></a>2 静态属性</h3><ul>
<li>ES6 提供了 11 个内置的 <code>symbol</code> 值，指向语言内部使用的方法</li>
</ul>
<table>
<thead>
<tr>
<th>静态属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Symbol.hasInstance</code></td>
<td><code>A instanceof B</code> 实际调用的是 <code>B[Symbol.hasInstance](A)</code></td>
</tr>
<tr>
<td><code>Symbol.iterator</code></td>
<td>指向一个返回对象迭代器的方法, <code>Obj[Symbol.iterator]()</code> 获取此方法并执行，返回对象的迭代器，被 <code>for... of</code> 使用</td>
</tr>
</tbody></table>
<h3 id="3-实例属性"><a href="#3-实例属性" class="headerlink" title="3 实例属性"></a>3 实例属性</h3><table>
<thead>
<tr>
<th>实例属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>description</code></td>
<td>只读属性，返回 Symbol 对象的可选的描述字符串</td>
</tr>
</tbody></table>
<h3 id="4-静态方法"><a href="#4-静态方法" class="headerlink" title="4 静态方法"></a>4 静态方法</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Symbol.for(key)</code></td>
<td>根据 <code>key</code> 从全局 <code>symbol</code> 注册表查询，找到则返回，否则创建一个与 <code>key</code> 关联的 <code>symbol</code> 值并放入全局 <code>symbol</code>注册表</td>
</tr>
<tr>
<td><code>Symbol.keyFor(sym)</code></td>
<td>获取全局 <code>symbol</code> 注册表中与指定 <code>symbole</code> 值关联的 <code>key</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>JS语法</title>
    <url>/anyeansan.github.io/2020/11/08/UI/JS%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一-注释"><a href="#一-注释" class="headerlink" title="一 注释"></a>一 注释</h1><ol>
<li><code>/ 单行注释 /</code></li>
<li><code>/* 多行注释，不能嵌套 */</code></li>
</ol>
<h1 id="二-作用域"><a href="#二-作用域" class="headerlink" title="二 作用域"></a>二 作用域</h1><ol>
<li>全局作用域：<code>&lt;script&gt;</code> 标签中或外部 <code>.js</code> 文件中</li>
<li>函数作用域：函数内部</li>
<li>块作用域：<code>ES 6</code> 之后才有，<code>{}</code> 内部，如 <code>{}, if, for, while, ...</code></li>
</ol>
<h1 id="三-声明关键字"><a href="#三-声明关键字" class="headerlink" title="三 声明关键字"></a>三 声明关键字</h1><table>
<thead>
<tr>
<th align="center">关键字</th>
<th>初始化</th>
<th>变量提升</th>
<th>作用域</th>
<th>window</th>
<th>同一作用域重复声明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>var</code></td>
<td>可选</td>
<td>有</td>
<td><code>全局，函数</code></td>
<td>全局声明会添加到 <code>window</code> 对象</td>
<td>可以，后者覆盖前者</td>
</tr>
<tr>
<td align="center"><code>let</code></td>
<td>可选</td>
<td>无</td>
<td><code>全局，函数，块</code></td>
<td>全局声明不会添加到 <code>window</code> 对象</td>
<td>不能</td>
</tr>
<tr>
<td align="center"><code>const</code></td>
<td>必须</td>
<td>无</td>
<td><code>全局，函数，块</code></td>
<td>全局声明不会添加到 <code>window</code> 对象</td>
<td>不能</td>
</tr>
</tbody></table>
<ol>
<li><p>JS 引擎运行分为两步：预解析和代码执行</p>
</li>
<li><p>预解析：将脚本中所有 <code>var</code> 和 <code>function</code> 语句提升到其作用域的最前面（hoisting）</p>
<ul>
<li>变量提升 <code>var</code>：将变量的声明提升到其作用域最前面，赋值操作不会提升</li>
<li>函数提升 <code>function</code>：将函数的声明提升到其作用域最前面</li>
</ul>
</li>
<li><p><code>var</code> 的问题：</p>
<ol>
<li>在函数及其子作用域声明的变量作用域都是函数</li>
<li>全局声明会添加到 <code>windows</code> 中</li>
</ol>
</li>
<li><p>暂时性死区  TDZ <code>temporal dead zone</code></p>
<ul>
<li><p>从作用域开始到声明语句之间区域，如果使用声明的变量就会会导致 <code>ReferenceError</code>，这块区域称为暂时性死区。</p>
</li>
<li><p>说白了就是要先声明后使用</p>
</li>
<li><p>暂时性死区不会查找全局变量（我觉得应该是特殊情况下）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let num = 10;</span><br><span class="line">if (true) &#123;</span><br><span class="line">	console.log(num); // 报错</span><br><span class="line">	let num = 20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ol>
<h1 id="四-变量"><a href="#四-变量" class="headerlink" title="四 变量"></a>四 变量</h1><ol>
<li><p>变量的声明和赋值，是分开的两个步骤</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;  </span><br><span class="line"><span class="comment">// 其实是下边两步</span></span><br><span class="line"><span class="keyword">let</span> a;</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同一条声明语句中可以声明多个变量</p>
</li>
<li><p>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</p>
</li>
<li><p>变量标识符命名规则</p>
<ol>
<li><code>A-Za-z</code> <code>0-9</code> <code>_</code> <code>$</code></li>
<li>不能用数字开头</li>
<li>不能使用 js 关键字和保留字</li>
</ol>
</li>
</ol>
<h1 id="五-数据类型"><a href="#五-数据类型" class="headerlink" title="五 数据类型"></a>五 数据类型</h1><h2 id="5-1-数据类型分类"><a href="#5-1-数据类型分类" class="headerlink" title="5.1 数据类型分类"></a>5.1 数据类型分类</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/JS/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt=""></p>
<table>
<thead>
<tr>
<th>内置对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object</code></td>
<td>对象都是 <code>Object</code> 的实例</td>
</tr>
<tr>
<td><code>Array</code></td>
<td>数组都是 <code>Array</code> 的实例</td>
</tr>
<tr>
<td><code>Function</code></td>
<td>函数都是 <code>Function</code> 的实例</td>
</tr>
<tr>
<td><code>Map Set WeakMap WeakSet</code></td>
<td>集合</td>
</tr>
<tr>
<td><code>Number Boolean String Symbol BigInt</code></td>
<td>基本类型包装类</td>
</tr>
<tr>
<td><code>Math</code></td>
<td>数学运算</td>
</tr>
<tr>
<td><code>Date</code></td>
<td>日期</td>
</tr>
<tr>
<td><code>JSON</code></td>
<td>Json</td>
</tr>
<tr>
<td><code>RegExp</code></td>
<td>正则表达式都是 <code>RegExp</code> 的实例</td>
</tr>
<tr>
<td><code>Error</code></td>
<td>错误</td>
</tr>
</tbody></table>
<h2 id="5-2-数据类型判断"><a href="#5-2-数据类型判断" class="headerlink" title="5.2 数据类型判断"></a>5.2 数据类型判断</h2><h3 id="1-方式"><a href="#1-方式" class="headerlink" title="1 方式"></a>1 方式</h3><table>
<thead>
<tr>
<th>方式</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>typeof</code></td>
<td><code>typeof operand</code></td>
<td>返回数据类型的字符串形式</td>
</tr>
<tr>
<td><code>instanceof</code></td>
<td><code>obj instanceof constructor</code></td>
<td>检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上</td>
</tr>
</tbody></table>
<h3 id="2-typeof-返回值"><a href="#2-typeof-返回值" class="headerlink" title="2 typeof 返回值"></a>2 typeof 返回值</h3><table>
<thead>
<tr>
<th>type</th>
<th>typeof Result</th>
</tr>
</thead>
<tbody><tr>
<td><code>number</code></td>
<td><code>&quot;number&quot;</code></td>
</tr>
<tr>
<td><code>bigint</code></td>
<td><code>&quot;bigint&quot;</code></td>
</tr>
<tr>
<td><code>string</code></td>
<td><code>&quot;string&quot;</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>&quot;boolean&quot;</code></td>
</tr>
<tr>
<td><code>undefined</code></td>
<td><code>&quot;undefined&quot;</code></td>
</tr>
<tr>
<td><code>null</code></td>
<td><code>&quot;object&quot;</code></td>
</tr>
<tr>
<td><code>symbol</code></td>
<td><code>&quot;symbol&quot;</code></td>
</tr>
<tr>
<td><code>function object (implements [[Call]])</code></td>
<td><code>&quot;function&quot;</code></td>
</tr>
<tr>
<td><code>any other object</code></td>
<td><code>&quot;object&quot;</code></td>
</tr>
</tbody></table>
<ul>
<li><code>typeof null</code>返回<code>object</code>是历史原因</li>
</ul>
<h1 id="六-运算符"><a href="#六-运算符" class="headerlink" title="六 运算符"></a>六 运算符</h1><h2 id="6-1-赋值运算符"><a href="#6-1-赋值运算符" class="headerlink" title="6.1 赋值运算符"></a>6.1 赋值运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
<th>等价于</th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td>赋值</td>
<td><code>x = y</code></td>
<td><code>x = y</code></td>
</tr>
<tr>
<td><code>+=</code></td>
<td>加赋值</td>
<td><code>x += y</code></td>
<td><code>x = x + y</code></td>
</tr>
<tr>
<td><code>-=</code></td>
<td>减赋值</td>
<td><code>x -= y</code></td>
<td><code>x = x - y</code></td>
</tr>
<tr>
<td><code>*=</code></td>
<td>乘赋值</td>
<td><code>x *= y</code></td>
<td><code>x = x * y</code></td>
</tr>
<tr>
<td><code>/=</code></td>
<td>除赋值</td>
<td><code>x /= y</code></td>
<td><code>x = x / y</code></td>
</tr>
<tr>
<td><code>%=</code></td>
<td>模赋值</td>
<td><code>x %= y</code></td>
<td><code>x = x % y</code></td>
</tr>
<tr>
<td><code>**=</code></td>
<td>指数赋值</td>
<td><code>x **= y</code></td>
<td><code>x = x ** y</code></td>
</tr>
<tr>
<td><code>&lt;&lt;=</code></td>
<td>左移赋值</td>
<td><code>x &lt;&lt;= y</code></td>
<td><code>x = x &lt;&lt; y</code></td>
</tr>
<tr>
<td><code>&gt;&gt;=</code></td>
<td>右移赋值</td>
<td><code>x &gt;&gt;= y</code></td>
<td><code>x = x &gt;&gt; y</code></td>
</tr>
<tr>
<td><code>&gt;&gt;&gt;=</code></td>
<td>无符号右移赋值</td>
<td><code>x &gt;&gt;&gt;= y</code></td>
<td><code>x = x &gt;&gt;&gt; y</code></td>
</tr>
<tr>
<td><code>&amp;=</code></td>
<td>按位与赋值</td>
<td><code>x &amp;= y</code></td>
<td><code>x = x &amp; y</code></td>
</tr>
<tr>
<td><code>&#124;=</code></td>
<td>按位或赋值</td>
<td><code>x &#124;= y</code></td>
<td><code>x = x &#124; y</code></td>
</tr>
<tr>
<td><code>^=</code></td>
<td>按位异或赋值</td>
<td><code>x ^= y</code></td>
<td><code>x = x ^ y</code></td>
</tr>
</tbody></table>
<h2 id="6-2-算术运算符"><a href="#6-2-算术运算符" class="headerlink" title="6.2 算术运算符"></a>6.2 算术运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>加法</td>
<td><code>x + y</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td>减法</td>
<td><code>x - y</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘法</td>
<td><code>x * y</code></td>
</tr>
<tr>
<td><code>/</code></td>
<td>除法</td>
<td><code>x / y</code></td>
</tr>
<tr>
<td><code>%</code></td>
<td>求余</td>
<td><code>x % y</code></td>
</tr>
<tr>
<td><code>**</code></td>
<td>幂</td>
<td><code>x ** y</code></td>
</tr>
<tr>
<td><code>++</code></td>
<td>自增</td>
<td><code>x++</code> 或 <code>++x</code></td>
</tr>
<tr>
<td><code>--</code></td>
<td>自减</td>
<td><code>x--</code> 或 <code>--x</code></td>
</tr>
<tr>
<td><code>+</code></td>
<td>一元正号</td>
<td><code>+x</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td>一元负号</td>
<td><code>-x</code></td>
</tr>
</tbody></table>
<h3 id="1-加法"><a href="#1-加法" class="headerlink" title="1 加法"></a>1 加法</h3><ol>
<li><p>遇到字符串会变成连接</p>
</li>
<li><p>对象相加，会先转成原始类型的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line">obj + <span class="number">2</span> <span class="comment">// "[object Object]2"</span></span><br><span class="line"><span class="comment">// obj.valueOf() 结果为&#123;p:1&#125;</span></span><br><span class="line"><span class="comment">// obj.valueOf().toString() 结果为"[object object]"</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-一元加号-减号"><a href="#2-一元加号-减号" class="headerlink" title="2 一元加号/减号"></a>2 一元加号/减号</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一元加号/减号运算符的作用在于可以将任何值转为数值</span></span><br><span class="line">+<span class="literal">true</span> <span class="comment">// 1</span></span><br><span class="line">+[] <span class="comment">// 0</span></span><br><span class="line">+&#123;&#125; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h3 id="3-幂运算符"><a href="#3-幂运算符" class="headerlink" title="3 幂运算符"></a>3 幂运算符</h3><ol>
<li><p>前一个运算子是底数，后一个运算子是指数</p>
</li>
<li><p>幂运算符是右结合：即多个指数运算符连用时，先进行最右边的计算。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">3</span> ** <span class="number">2</span></span><br><span class="line"><span class="comment">// 512 相当于 2 ** (3 ** 2) 即先求3的2次方=9 再求2的9次方</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="6-3-比较运算符"><a href="#6-3-比较运算符" class="headerlink" title="6.3 比较运算符"></a>6.3 比较运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
</tr>
</thead>
<tbody><tr>
<td><code>&gt;</code></td>
<td>大于</td>
<td><code>x &gt; y</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
<td><code>x &lt; y</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
<td><code>x &gt;= y</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
<td><code>x &lt;= y</code></td>
</tr>
<tr>
<td><code>==</code></td>
<td>相等</td>
<td><code>x == y</code></td>
</tr>
<tr>
<td><code>===</code></td>
<td>严格相等</td>
<td><code>x === y</code></td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不相等</td>
<td><code>x != y</code></td>
</tr>
<tr>
<td><code>!==</code></td>
<td>严格不相等</td>
<td><code>x !== y</code></td>
</tr>
</tbody></table>
<h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h3><ol>
<li>基本类型<ol>
<li>非字符串：先转成数值再比较</li>
<li>字符串：按照字典顺序比较（实际上是比较 Unicode 码点）</li>
</ol>
</li>
<li>引用类型<ul>
<li>先转为基本类型的值，再进行比较</li>
</ul>
</li>
<li>严格相等（全等）：符号两边的值类型和值都相等</li>
</ol>
<h3 id="2-总结"><a href="#2-总结" class="headerlink" title="2 总结"></a>2 总结</h3><table>
<thead>
<tr>
<th>方式</th>
<th><code>NaN</code></th>
<th><code>undefined</code></th>
<th><code>null</code></th>
<th><code>+0</code> 和 <code>-0</code></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>==</code></td>
<td>不等于任何值</td>
<td>等于 <code>undefined</code> 和 <code>null</code></td>
<td>等于 <code>undefined</code> 和 <code>null</code></td>
<td>相等</td>
<td>先进行类型转换，之后使用 <code>===</code> 比较</td>
</tr>
<tr>
<td><code>===</code></td>
<td>不等于任何值</td>
<td>等于 <code>undefined</code></td>
<td>等于 <code>null</code></td>
<td>相等</td>
<td>类型不同即为 <code>false</code></td>
</tr>
<tr>
<td><code>Object.is(value1, value2)</code></td>
<td>等于 <code>NaN</code></td>
<td>等于 <code>undefined</code></td>
<td>等于 <code>null</code></td>
<td>不相等</td>
<td>类型不同即为 <code>false</code></td>
</tr>
</tbody></table>
<h2 id="6-4-逻辑运算符"><a href="#6-4-逻辑运算符" class="headerlink" title="6.4 逻辑运算符"></a>6.4 逻辑运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑与</td>
<td><code>expr1 &amp;&amp; expr2</code></td>
<td>若<code>expr1</code>为 <code>true</code>，则返回<code>expr2</code>的值，否则，返回<code>expr1</code>的值，且不再计算<code>expr2</code> （短路）</td>
</tr>
<tr>
<td><code>&#124;&#124;</code></td>
<td>逻辑或</td>
<td><code>expr1 &#124;&#124; expr2</code></td>
<td>若<code>expr1</code>为 <code>false</code>，则返回<code>expr2</code>的值，否则，返回<code>expr1</code>的值，且不再计算<code>expr2</code> （短路）</td>
</tr>
<tr>
<td><code>!</code></td>
<td>逻辑非</td>
<td><code>!expr</code></td>
<td>若<code>expr</code> 为 <code>true</code>，则返回 <code>false</code>，否则，返回<code>true</code></td>
</tr>
<tr>
<td><code>!!</code></td>
<td>双重非</td>
<td><code>!!expr</code></td>
<td>显式地将任意值强制转换为其对应的布尔值</td>
</tr>
</tbody></table>
<ul>
<li>JS 中逻辑运算符返回的不一定是布尔值，而是表达式的值</li>
</ul>
<h2 id="6-5-按位运算符"><a href="#6-5-按位运算符" class="headerlink" title="6.5 按位运算符"></a>6.5 按位运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td>按位与</td>
<td><code>x &amp; y</code></td>
<td>有0则0</td>
</tr>
<tr>
<td><code>&#124;</code></td>
<td>按位或</td>
<td><code>x &#124; y</code></td>
<td>有1则1</td>
</tr>
<tr>
<td><code>~</code></td>
<td>按位非</td>
<td><code>~x</code></td>
<td>1变0，0变1</td>
</tr>
<tr>
<td><code>^</code></td>
<td>按位异或</td>
<td><code>x ^ y</code></td>
<td>相同则0，不同则1</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移</td>
<td><code>x &lt;&lt; y</code></td>
<td>低位补0，相当于<code>x * 2<sup>y</sup></code></td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移</td>
<td><code>x &gt;&gt; y</code></td>
<td>舍去低位，正数高位补 0，负数高位补 1，相当于<code>x / 2<sup>y</sup></code></td>
</tr>
<tr>
<td><code>&gt;&gt;&gt;</code></td>
<td>无符号右移</td>
<td><code>x &gt;&gt;&gt; y</code></td>
<td>舍去低位，高位补 0，相当于<code>x / 2<sup>y</sup></code></td>
</tr>
</tbody></table>
<h2 id="6-6-三元运算符"><a href="#6-6-三元运算符" class="headerlink" title="6.6 三元运算符"></a>6.6 三元运算符</h2><ul>
<li><code>condition ? exprIfTrue : exprIfFalse</code><ol>
<li>若<code>condition</code> 为true，返回<code>exprIfTrue</code>的值，否则，返回<code>exprIfFalse</code>的值</li>
<li>和 <code>if else</code> 的区别：if…else是语句，没有返回值；三元运算符是表达式，具有返回值。</li>
</ol>
</li>
</ul>
<h2 id="6-7-void运算符"><a href="#6-7-void运算符" class="headerlink" title="6.7 void运算符"></a>6.7 void运算符</h2><ul>
<li><code>void expression</code><ol>
<li>对给定的表达式进行求值，然后返回 <code>undefined</code></li>
<li>void 运算符通常只用于获取 <code>undefined</code> 的原始值，一般使用 <code>void(0)</code>（等同于<code>void 0</code>）</li>
<li>应用<ol>
<li><code>javascript: void(0);</code></li>
<li><code>() =&gt; void doSomething();</code></li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="6-8-逗号运算符"><a href="#6-8-逗号运算符" class="headerlink" title="6.8 逗号运算符"></a>6.8 逗号运算符</h2><ul>
<li><p><code>expr1, expr2, expr3...</code></p>
<ul>
<li><p>从左到右依次计算每个表达式，并返回最后一个表达式的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'a'</span>, <span class="string">'b'</span> <span class="comment">// "b"</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> y = (x++, <span class="number">10</span>);  <span class="comment">// x=1 y=10</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="七-语句"><a href="#七-语句" class="headerlink" title="七 语句"></a>七 语句</h1><h2 id="7-1-条件"><a href="#7-1-条件" class="headerlink" title="7.1 条件"></a>7.1 条件</h2><h3 id="1-if-…-else"><a href="#1-if-…-else" class="headerlink" title="1 if … else"></a>1 if … else</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-switch-…-case"><a href="#2-switch-…-case" class="headerlink" title="2 switch … case"></a>2 switch … case</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// switch 内部采用严格相等</span></span><br><span class="line"><span class="keyword">switch</span> (variable) &#123;</span><br><span class="line">    <span class="keyword">case</span> value1:</span><br><span class="line">        statement</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2:</span><br><span class="line">        statement</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-循环"><a href="#7-2-循环" class="headerlink" title="7.2 循环"></a>7.2 循环</h2><h3 id="1-for"><a href="#1-for" class="headerlink" title="1 for"></a>1 for</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化条件【可以有多个】; 循环条件【boolean类型】; 循环迭代条件) &#123;</span><br><span class="line">	循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-while"><a href="#2-while" class="headerlink" title="2 while"></a>2 while</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">	statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-do-…-while"><a href="#3-do-…-while" class="headerlink" title="3 do … while"></a>3 do … while</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (condition)</span><br></pre></td></tr></table></figure>

<h3 id="4-for-…-in"><a href="#4-for-…-in" class="headerlink" title="4 for … in"></a>4 for … in</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object)&#123;</span><br><span class="line">	statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>遍历对象（推荐）<ol>
<li>遍历对象的所有可枚举属性（包括它的原型链上的可枚举属性），属性是否可枚举由属性描述符的<code>enumerable</code>决定</li>
<li>每次循环获取的是属性名</li>
</ol>
</li>
<li>遍历数组（不推荐）<ol>
<li>数组键名是数字，但每次循环获取的是索引的字符串</li>
<li>除了遍历数组元素外，数组本身以及原型链上的可枚举属性也会被遍历到</li>
<li>某些情况下，不能保证按顺序返回索引</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>语句</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>{}</code></td>
<td>声明块作用域</td>
</tr>
<tr>
<td><code>prop in obj</code></td>
<td>判断对象或其原型链上是否包含某个属性</td>
</tr>
</tbody></table>
<h3 id="5-for-…-of"><a href="#5-for-…-of" class="headerlink" title="5 for … of"></a>5 for … of</h3><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>用来遍历可迭代对象，每次循环取出的是值</li>
<li>for… of 内部就是调用了可迭代对象的 <code>Symbol.iterator</code> 生成了迭代器</li>
</ol>
<h4 id="2-迭代器"><a href="#2-迭代器" class="headerlink" title="2 迭代器"></a>2 迭代器</h4><ol>
<li><p>迭代器就是具有指定<code>next()</code>方法的对象</p>
</li>
<li><p>此指定 <code>next()</code> ：返回一个对象，返回对象拥有两个属性</p>
<ol>
<li><p><code>value</code>：当前迭代的值</p>
</li>
<li><p><code>done</code>：布尔值，迭代是否结束。</p>
<ul>
<li><code>false</code> 表示没结束，可以省略    </li>
<li><code>true</code> 表示结束，此时 <code>value</code>为 <code>undefined</code>，<code>value</code> 可以省略</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="3-可迭代对象"><a href="#3-可迭代对象" class="headerlink" title="3 可迭代对象"></a>3 可迭代对象</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h5><ol>
<li>一个可迭代对象必须实现 <code>@@iterator</code> 方法，这意味着对象（或其原型链上的某个对象）必须有一个键为 <code>@@iterator</code> 的属性</li>
<li><code>@@iterator</code> 属性可以通过 <code>Symbol.iterator</code> 访问</li>
<li>对象（或者其原型链）上拥有 <code>Symbol.iterator</code> 属性，就是可迭代对象</li>
</ol>
<h5 id="2-Symbol-iterator"><a href="#2-Symbol-iterator" class="headerlink" title="2 Symbol.iterator"></a>2 <code>Symbol.iterator</code></h5><ol>
<li><code>Symbol.iterator</code> 属性指向一个函数，此函数返回对象的迭代器</li>
<li><code>obj[Symbol.iterator]</code> 返回对象用于获取迭代器的函数</li>
</ol>
<h5 id="3-JS-内置可迭代对象"><a href="#3-JS-内置可迭代对象" class="headerlink" title="3 JS 内置可迭代对象"></a>3 JS 内置可迭代对象</h5><table>
<thead>
<tr>
<th>内置可迭代对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td>字符串</td>
</tr>
<tr>
<td><code>Array</code></td>
<td>数组</td>
</tr>
<tr>
<td><code>Set / Map</code></td>
<td>集合</td>
</tr>
<tr>
<td><code>arguments</code></td>
<td>类数组对象</td>
</tr>
<tr>
<td><code>DOM NodeList</code></td>
<td>类数组对象</td>
</tr>
<tr>
<td><code>Generator</code></td>
<td>生成器对象</td>
</tr>
<tr>
<td><code>TypedArray</code></td>
<td>类型化数组</td>
</tr>
</tbody></table>
<ol>
<li>可枚举属性：属性描述符 <code>enumerable: true</code> 的属性</li>
<li>普通对象：没有数字键和 <code>length</code> 属性的对象</li>
<li>类数组对象：存在数值键名和 <code>length</code> 属性的对象</li>
</ol>
<h4 id="4-自定义-for-…-of"><a href="#4-自定义-for-…-of" class="headerlink" title="4 自定义 for … of"></a>4 自定义 for … of</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myForOf</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 1 获取迭代器</span></span><br><span class="line">	<span class="keyword">let</span> it = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">    <span class="comment">// 2 判断迭代是否结束</span></span><br><span class="line">	<span class="keyword">let</span> res = it.next();</span><br><span class="line">	<span class="keyword">while</span>(!res.done) &#123;</span><br><span class="line">		<span class="comment">// 3 获取值</span></span><br><span class="line">	    <span class="built_in">console</span>.log(res.value);</span><br><span class="line">	    res = it.next();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-3-label"><a href="#7-3-label" class="headerlink" title="7.3 label"></a>7.3 label</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">label（label可自定义名称）:</span><br><span class="line">	statement</span><br></pre></td></tr></table></figure>

<ul>
<li>相当于定位符，用于跳转到程序的任意位置，通常配合 <code>break</code>  和 <code>continue</code> 使用<ul>
<li><code>break [label]</code> </li>
<li><code>continue [label]</code></li>
</ul>
</li>
</ul>
<h1 id="八-展开语法（Spread-syntax）"><a href="#八-展开语法（Spread-syntax）" class="headerlink" title="八 展开语法（Spread syntax）"></a>八 展开语法（Spread syntax）</h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><ol>
<li>展开语法用  <code>...</code> 表示    </li>
<li>展开语法在函数调用或构造字面量数组时, 将<strong>可迭代对象</strong>在语法层面展开</li>
<li>展开语法在构造字面量对象时, 将对象按 <code>key:value</code> 的方式展开</li>
</ol>
<h2 id="8-2-应用"><a href="#8-2-应用" class="headerlink" title="8.2 应用"></a>8.2 应用</h2><h3 id="1-函数调用"><a href="#1-函数调用" class="headerlink" title="1 函数调用"></a>1 函数调用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function show(x, y, z) &#123; &#125;</span><br><span class="line">let args = [0, 1, 2];</span><br><span class="line">show(...args); // 等价于 show(0, 1, 2)</span><br></pre></td></tr></table></figure>

<h3 id="2-构造字面量数组"><a href="#2-构造字面量数组" class="headerlink" title="2 构造字面量数组"></a>2 构造字面量数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr1 = [0, 1, 2];</span><br><span class="line">let arr2 = [3, 4, 5];</span><br><span class="line">let arr3 = [...arr1, ...arr2]; // [0,1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<h3 id="3-构造字面量对象"><a href="#3-构造字面量对象" class="headerlink" title="3 构造字面量对象"></a>3 构造字面量对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj1 = &#123; foo: &apos;bar&apos;, x: 42 &#125;;</span><br><span class="line">let obj2 = &#123; foo: &apos;baz&apos;, y: 13 &#125;;</span><br><span class="line">let clonedObj = &#123; ...obj1 &#125;; // 克隆后的对象: &#123; foo: &quot;bar&quot;, x: 42 &#125;</span><br><span class="line">let mergedObj = &#123; ...obj1, ...obj2 &#125;; // 合并后的对象: &#123; foo: &quot;baz&quot;, x: 42, y: 13 &#125;</span><br></pre></td></tr></table></figure>

<h1 id="九-解构赋值"><a href="#九-解构赋值" class="headerlink" title="九 解构赋值"></a>九 解构赋值</h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><ol>
<li>解构赋值：从数组和对象中提取值，对变量进行赋值</li>
<li>解构对象时会查找原型链（如果属性不在对象自身，将从原型链中查找）</li>
</ol>
<h2 id="9-2-解构数组"><a href="#9-2-解构数组" class="headerlink" title="9.2 解构数组"></a>9.2 解构数组</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 先声明后赋值的解构</span></span><br><span class="line"><span class="keyword">let</span> a, b;</span><br><span class="line">[a, b] = [<span class="number">10</span>, <span class="number">20</span>]; <span class="comment">// a=10 b=20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 声明并赋值的解构</span></span><br><span class="line"><span class="keyword">let</span> [a,b] = [<span class="number">10</span>, <span class="number">20</span>]; <span class="comment">// a=10 b=20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 有默认值的解构</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = <span class="number">4</span>] = [<span class="number">1</span>]; <span class="comment">// a=1 b=4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 变量数量小于数组值数量时，忽略多余值</span></span><br><span class="line"><span class="keyword">let</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; <span class="comment">// a =1 b = 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 可用于交换变量</span></span><br><span class="line"><span class="keyword">let</span> a =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">[a, b] = [b, a]; <span class="comment">// a=2 b=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6 剩余参数</span></span><br><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// a=1 b=[2,3]</span></span><br></pre></td></tr></table></figure>

<h2 id="9-3-解构对象"><a href="#9-3-解构对象" class="headerlink" title="9.3 解构对象"></a>9.3 解构对象</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 基本语法</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">key</span>:变量&#125; = &#123;<span class="attr">key</span>:value&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 变量名与属性名相同可以简写</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">key</span>:key&#125; = &#123;<span class="attr">key</span>:value&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;key&#125; = &#123;<span class="attr">key</span>:value&#125;; <span class="comment">// 简写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 先声明后赋值的解构</span></span><br><span class="line"><span class="keyword">let</span> name, age;</span><br><span class="line"><span class="comment">// 错误： 赋值时必须使用 `()` 包括，因为左边`&#123;name, age&#125;`会被认为是块而不是对象字面量</span></span><br><span class="line">&#123;name,age&#125; =  &#123;<span class="attr">name</span>:<span class="string">'an3'</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;); </span><br><span class="line"><span class="comment">// 正确：name='an3' age=18</span></span><br><span class="line">(&#123;name, age&#125; = &#123;<span class="attr">name</span>:<span class="string">'an3'</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 有默认值的解构</span></span><br><span class="line"><span class="keyword">let</span> &#123;name=<span class="string">'haha'</span>, age=<span class="number">10</span>&#125; = &#123;<span class="attr">name</span>:<span class="string">'an3'</span>&#125;; <span class="comment">// name='an3' age=10</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:n=<span class="string">'haha'</span> age:a=<span class="number">10</span>&#125; = &#123;<span class="attr">name</span>:<span class="string">'an3'</span>&#125;; <span class="comment">// n='an3' a=10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 变量数量小于对象键值对数量时，忽略多余值</span></span><br><span class="line"><span class="keyword">let</span> &#123;name=<span class="string">'haha'</span>, age=<span class="number">10</span>&#125; = &#123;<span class="attr">name</span>:<span class="string">'an3'</span>,<span class="attr">age</span>:<span class="number">10</span>,<span class="attr">sex</span>:<span class="number">1</span>&#125;; <span class="comment">// name='an3' age=18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6 解构嵌套</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">	name:<span class="string">'xiaoming'</span>,</span><br><span class="line">	lesson:&#123;</span><br><span class="line">		title:<span class="string">'js'</span>,</span><br><span class="line">		score:<span class="number">90</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;name,<span class="attr">lesson</span>:&#123;title,score&#125;&#125; = user;</span><br></pre></td></tr></table></figure>

<h1 id="十-全局函数"><a href="#十-全局函数" class="headerlink" title="十 全局函数"></a>十 全局函数</h1><table>
<thead>
<tr>
<th>全局函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>encodeURI(URI)</code></td>
<td>使用 UTF-8 编码，编码后的格式为UTF-8编码的每个字节前加 <code>%</code>，如 <code>安</code> 编码后 <code>%E5%AE%89</code></td>
</tr>
<tr>
<td><code>decodeURI(encodedURI)</code></td>
<td><code>encodeURI(URI)</code> 对应的解码函数</td>
</tr>
<tr>
<td><code>encodeURIComponent(str)</code></td>
<td>类似<code>encodeURI()</code>，区别在于不会编码的字符</td>
</tr>
<tr>
<td><code>decodeURIComponent(encodedURI)</code></td>
<td><code>encodeURIComponent()</code>对应的解码函数</td>
</tr>
<tr>
<td><code>isFinite(value)</code></td>
<td>同 <code>Number.isFinite(value)</code></td>
</tr>
<tr>
<td><code>isNaN(value)</code></td>
<td>同 <code>Number.isNaN(value)</code></td>
</tr>
<tr>
<td><code>parseInt(string[, radix])</code></td>
<td>同 <code>Number.parseInt(string[, radix])</code></td>
</tr>
<tr>
<td><code>parseFloat(string)</code></td>
<td>同 <code>Number.parseFloat(string)</code></td>
</tr>
<tr>
<td><code>eval(string)</code>（不要使用）</td>
<td>将传入的字符串当做 JavaScript 代码进行执行</td>
</tr>
</tbody></table>
<ul>
<li><code>encodeURI(URI)</code> 和 <code>encodeURIComponent(str)</code> 区别<ol>
<li><code>encodeURI(URI)</code> 不会编码的字符    <ol>
<li><code>; , / ? : @ &amp; = + $</code>        </li>
<li><code>字母 数字 - _ . ! ~ * &#39; ( )</code></li>
<li><code>#</code></li>
</ol>
</li>
<li><code>encodeURIComponent(str)</code> 不会编码的字符<ol>
<li><code>字母 数字 - _ . ! ~ * &#39; ( )</code></li>
</ol>
</li>
<li>使用场景<ol>
<li>对整个 URI 编码，使用 <code>encodeURI(URI)</code></li>
<li>对 URI 中的参数编码，使用 <code>encodeURIComponent(str)</code></li>
</ol>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>JS前言</title>
    <url>/anyeansan.github.io/2020/11/08/UI/JS%E5%89%8D%E8%A8%80/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/JS/JS%E7%BB%84%E6%88%90.png" alt=""></p>
<ol>
<li>JavaScript 是运行在客户端的解释性脚本语言，不需要编译，由 JS 引擎逐行解释并执行</li>
<li>浏览器分成两个部分：<ul>
<li>渲染引擎：用来解析 HTML 和 CSS，俗称内核</li>
<li>JS 引擎：专门处理 JavaScript 脚本的虚拟机，也称 JS 解释器<ul>
<li><code>chrome v8</code></li>
<li><code>firefox SpiderMonkey</code></li>
<li><code>edge chakra</code></li>
<li><code>Opera Carakan</code></li>
<li>……</li>
</ul>
</li>
</ul>
</li>
<li>原本 JS 只运行在浏览器上，后来出现了 Node（包含了<code>chrome v8</code> 的 C++ 程序），JS 可以使用 Node 运行在浏览器之外</li>
<li>ECMAScript 是规范，JavaScript 是实现</li>
</ol>
<h1 id="二-引入-JavaScript-脚本"><a href="#二-引入-JavaScript-脚本" class="headerlink" title="二  引入 JavaScript 脚本"></a>二  引入 JavaScript 脚本</h1><h2 id="2-1-网页加载流程-前端"><a href="#2-1-网页加载流程-前端" class="headerlink" title="2.1  网页加载流程 - 前端"></a>2.1  网页加载流程 - 前端</h2><ol>
<li>浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。</li>
<li>css 和 html 是并行加载的，过程中如果遇到css 或者 img，则会向浏览器返回一个请求，待资源返回后，将其添加到dom的相应位置中</li>
<li>解析过程中，浏览器发现<code>&lt;script&gt;</code>元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎（原因是 JavaScript 代码可以修改 DOM，所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题。）</li>
<li>如果<code>&lt;script&gt;</code>元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</li>
<li>JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页</li>
</ol>
<h2 id="2-2-JavaScript-脚本位置"><a href="#2-2-JavaScript-脚本位置" class="headerlink" title="2.2 JavaScript 脚本位置"></a>2.2 JavaScript 脚本位置</h2><ul>
<li>浏览器加载 JavaScript 脚本，主要通过<code>&lt;script&gt;</code>元素完成，<code>&lt;script&gt;</code> 最好放在页面底部（<code>&lt;body&gt;</code> 标签后）<ol>
<li>如果外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。脚本放在页面底部，即使遇到脚本失去响应，网页主体的渲染也已经完成了，用户至少可以看到内容</li>
<li>JS 通常要操作页面中的元素，如果在 DOM 结构生成之前就调用 DOM 节点，JavaScript 会报错，脚本放在页面底部，就不存在这个问题，因为这时 DOM 肯定已经生成了。</li>
</ol>
</li>
</ul>
<h2 id="2-3-JavaScript-脚本引入方式"><a href="#2-3-JavaScript-脚本引入方式" class="headerlink" title="2.3 JavaScript 脚本引入方式"></a>2.3 JavaScript 脚本引入方式</h2><h3 id="1-内联脚本"><a href="#1-内联脚本" class="headerlink" title="1 内联脚本"></a>1 内联脚本</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 第一种：直接写脚本</span></span><br><span class="line">&lt;button onclick=<span class="string">"alert('xxx')"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 2 第二种：传递脚本</span></span><br><span class="line">&lt;button onclick=<span class="string">"fn()"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert(<span class="string">'xxx'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-内部脚本"><a href="#2-内部脚本" class="headerlink" title="2 内部脚本"></a>2 内部脚本</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">	<span class="comment">// 1 type 可以省略，默认 text/javascript</span></span><br><span class="line">	<span class="comment">// 2 新的浏览器可以写 application/javascript</span></span><br><span class="line">&lt;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-外部脚本"><a href="#3-外部脚本" class="headerlink" title="3 外部脚本"></a>3 外部脚本</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"xxx.js&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>标签体不能有内容，<code>&lt;/script&gt;</code>不能省略</li>
<li><code>src</code> 默认是http协议</li>
<li>外部的 <code>.js</code> 脚本文件中不能包含 <code>&lt;script&gt;</code> 标签。</li>
</ol>
<h1 id="三-顶层对象"><a href="#三-顶层对象" class="headerlink" title="三 顶层对象"></a>三 顶层对象</h1><table>
<thead>
<tr>
<th>环境</th>
<th>顶层对象</th>
<th>ES2020</th>
</tr>
</thead>
<tbody><tr>
<td><code>浏览器</code></td>
<td><code>window，self</code></td>
<td><code>globalThis</code></td>
</tr>
<tr>
<td><code>Web Worker</code></td>
<td><code>self</code></td>
<td><code>globalThis</code></td>
</tr>
<tr>
<td><code>Node</code></td>
<td><code>global</code></td>
<td><code>globalThis</code></td>
</tr>
</tbody></table>
<ol>
<li>JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。</li>
<li>顶层对象在各种实现里面是不统一的</li>
<li>ES2020 标准中，引入<code>globalThis</code>作为顶层对象。也就是说，任何环境下，<code>globalThis</code>都是存在的</li>
</ol>
<h1 id="四-严格模式"><a href="#四-严格模式" class="headerlink" title="四 严格模式"></a>四 严格模式</h1><h2 id="4-1-启用"><a href="#4-1-启用" class="headerlink" title="4.1 启用"></a>4.1 启用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"use strict;"</span></span><br><span class="line"><span class="comment">// 1 放在脚本文件的第一行，整个脚本都将以严格模式运行</span></span><br><span class="line"><span class="comment">// 2 放在函数体的第一行，则整个函数以严格模式运行</span></span><br></pre></td></tr></table></figure>

<h2 id="4-2-严格模式中的变化"><a href="#4-2-严格模式中的变化" class="headerlink" title="4.2 严格模式中的变化"></a>4.2 严格模式中的变化</h2><h3 id="1-显式报错"><a href="#1-显式报错" class="headerlink" title="1 显式报错"></a>1 显式报错</h3><ol>
<li>严格模式会使引起静默失败(silently fail，不报错也没有任何效果)的赋值操作抛出异常，如只读属性的写操作，不可扩展对象扩展操作</li>
<li>严格模式下，试图删除不可删除的属性时会抛出异常</li>
<li>严格模式下禁止对象属性重名</li>
<li>严格模式下禁止函数参数重名</li>
<li>严格模式禁止八进制数字语法</li>
</ol>
<h3 id="2-安全措施"><a href="#2-安全措施" class="headerlink" title="2 安全措施"></a>2 安全措施</h3><ol>
<li>严格模式下，变量必须先声明，然后再使用</li>
<li>禁止 this 关键字指向全局对象 <code>window</code></li>
<li>严格模式禁止删除声明变量</li>
</ol>
<h3 id="3-静态绑定"><a href="#3-静态绑定" class="headerlink" title="3 静态绑定"></a>3 静态绑定</h3><ul>
<li>js允许动态绑定，即属性或方法属于哪个对象不是编译时确定的，而是在运行时确定</li>
<li>严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定，即编译时就确定属性或方法属于哪个对象。</li>
</ul>
<h3 id="4-其它"><a href="#4-其它" class="headerlink" title="4 其它"></a>4 其它</h3><ol>
<li>严格模式禁用 <code>with</code>语句</li>
<li>创设 eval 作用域<ul>
<li>正常模式下，eval语句的作用域，取决于它处于全局作用域，还是函数作用域。</li>
<li>严格模式下，eval语句本身就是一个作用域，即eval所生成的变量只能用于eval内部</li>
</ul>
</li>
<li>arguments 不再追踪参数的变化<ul>
<li>变量arguments代表函数的参数。</li>
<li>严格模式下，函数内部改变参数与arguments的联系被切断了，两者不再存在联动关系</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>Less</title>
    <url>/anyeansan.github.io/2020/11/08/UI/Less/</url>
    <content><![CDATA[<h2 id="一-Less-概述"><a href="#一-Less-概述" class="headerlink" title="一 Less 概述"></a>一 Less 概述</h2><ol>
<li><code>Leaner Style Sheets</code></li>
<li>Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。</li>
<li>Less 可以运行在 Node 或浏览器端</li>
</ol>
<h1 id="二-变量"><a href="#二-变量" class="headerlink" title="二 变量"></a>二 变量</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@变量名: 值;</span><br></pre></td></tr></table></figure>

<h1 id="三-嵌套"><a href="#三-嵌套" class="headerlink" title="三 嵌套"></a>三 嵌套</h1><ol>
<li><p>使用选择器嵌套结构即可实现选择器层次关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.fu &#123;</span><br><span class="line">	div &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// .fu div &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&amp;</code> 代表当前选择器，类似于 <code>this</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	&amp;::after&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// div::after &#123;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="四-运算"><a href="#四-运算" class="headerlink" title="四 运算"></a>四 运算</h1><ol>
<li>算术运算符 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 可以对任何数字、颜色或变量进行运算</li>
<li>计算的结果以最左侧操作数的单位类型为准</li>
<li>运算符两侧必须加空格</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>CSS媒体查询</title>
    <url>/anyeansan.github.io/2020/11/08/UI/CSS%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h1 id="一-媒体查询概述"><a href="#一-媒体查询概述" class="headerlink" title="一 媒体查询概述"></a>一 媒体查询概述</h1><ol>
<li><p><code>Media Querie</code></p>
</li>
<li><p>可以针对不同的媒体类型定义不同的样式</p>
</li>
</ol>
<h1 id="二-媒体查询语法-media"><a href="#二-媒体查询语法-media" class="headerlink" title="二 媒体查询语法 @media"></a>二 媒体查询语法 <code>@media</code></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">	@media meidatype and|not|only (media feature) &#123;</span><br><span class="line">		css code;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>语法</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td><code>meidatype</code></td>
<td>媒体类型</td>
</tr>
<tr>
<td><code>and</code></td>
<td>逻辑与</td>
</tr>
<tr>
<td><code>not</code></td>
<td>逻辑非，必须写在查询的最前面，表示对整个条件取反</td>
</tr>
<tr>
<td><code>only</code></td>
<td>必须写在查询的最前面，指定某个特定媒体类型</td>
</tr>
<tr>
<td><code>media feature</code></td>
<td>媒体特性</td>
</tr>
</tbody></table>
<h1 id="三-媒体类型"><a href="#三-媒体类型" class="headerlink" title="三 媒体类型"></a>三 媒体类型</h1><table>
<thead>
<tr>
<th><code>mediatype</code></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>all（默认）</td>
<td>所有媒体类型</td>
</tr>
<tr>
<td>screen</td>
<td>用于电脑屏幕，平板电脑，智能手机等</td>
</tr>
<tr>
<td>print</td>
<td>打印设备</td>
</tr>
<tr>
<td>speech</td>
<td>应用于屏幕阅读器等发声设备</td>
</tr>
</tbody></table>
<ul>
<li>多媒体支持<ul>
<li>可以用逗号分隔同时支持多个媒体设备 如 <code>screen, print</code></li>
</ul>
</li>
</ul>
<h1 id="四-媒体特性"><a href="#四-媒体特性" class="headerlink" title="四 媒体特性"></a>四 媒体特性</h1><table>
<thead>
<tr>
<th>媒体特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>orientation: landscape/portrait</td>
<td>横屏/竖屏</td>
</tr>
<tr>
<td>width</td>
<td>设备宽度</td>
</tr>
<tr>
<td>height</td>
<td>设备高度</td>
</tr>
<tr>
<td>min-width</td>
<td>最小宽度</td>
</tr>
<tr>
<td>max-width</td>
<td>最大宽度</td>
</tr>
<tr>
<td>min-height</td>
<td>最小高度</td>
</tr>
<tr>
<td>max-height</td>
<td>最大高度</td>
</tr>
</tbody></table>
<h1 id="五-引入资源"><a href="#五-引入资源" class="headerlink" title="五 引入资源"></a>五 引入资源</h1><h3 id="1-lt-style-gt"><a href="#1-lt-style-gt" class="headerlink" title="1  &lt;style&gt;"></a>1  <code>&lt;style&gt;</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style media=&quot;meidatype and|not|only (media feature)&gt;</span><br><span class="line">	// 满足条件则使用此内部样式</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-lt-link-gt"><a href="#2-lt-link-gt" class="headerlink" title="2 &lt;link&gt;"></a>2 <code>&lt;link&gt;</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;&quot; href=&quot;&quot; media=&quot;meidatype and|not|only (media feature)&quot;&gt;</span><br><span class="line">// 满足条件则使用导入的外部样式</span><br></pre></td></tr></table></figure>

<h3 id="3-lt-link-gt-import"><a href="#3-lt-link-gt-import" class="headerlink" title="3 &lt;link&gt; + @import"></a>3 <code>&lt;link&gt; + @import</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// test.html</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;</span><br><span class="line">// style.css</span><br><span class="line">@import url(1.css) all;</span><br><span class="line">@import url(2.css) screen;</span><br><span class="line">@import url(3.css) print;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>&lt;link&gt;</code>指定媒体类型需要导入不同的css文件，导致<code>&lt;link&gt;</code>语句过多，可以使用外部 css 文件一起导入</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>CSS动画</title>
    <url>/anyeansan.github.io/2020/11/08/UI/CSS%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>过渡是两个状态间的变化，动画可以理解为帧之间的过渡</li>
<li>制作动画步骤<ol>
<li>定义动画 <code>@keyframes</code></li>
<li>使用动画 <code>animation</code></li>
</ol>
</li>
</ol>
<h1 id="二-keyframes"><a href="#二-keyframes" class="headerlink" title="二 @keyframes"></a>二 <code>@keyframes</code></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@keyframes 动画名称 &#123;</span><br><span class="line">	from &#123;</span><br><span class="line">		margin-left: 100%;</span><br><span class="line">		width: 300%;</span><br><span class="line">	&#125;</span><br><span class="line">	to &#123;</span><br><span class="line">		margin-left: 0%;</span><br><span class="line">		width: 100%;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每个动画中定义一个动画序列，每个动画序列包含 n 个关键帧</li>
</ul>
<table>
<thead>
<tr>
<th>关键帧</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>num%</code></td>
<td>表示此关键帧处于动画的哪个阶段</td>
</tr>
<tr>
<td><code>from</code></td>
<td>相当于 <code>0%</code>，即动画的开始，未设置则使用元素现有状态作为动画开始状态</td>
</tr>
<tr>
<td><code>to</code></td>
<td>相当于 <code>100%</code>，即动画的结束，未设置则使用元素现有状态作为动画结束状态</td>
</tr>
</tbody></table>
<h1 id="三-animation（简写属性）"><a href="#三-animation（简写属性）" class="headerlink" title="三 animation（简写属性）"></a>三 animation（简写属性）</h1><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>animation-name</code></td>
<td>使用的动画，多个动画用逗号隔开，多个动画有相同属性时，后者优先使用</td>
</tr>
<tr>
<td><code>animation-duration</code></td>
<td>动画播放时间，即动画序列的所有帧执行一遍的时间，默认 <code>0s</code></td>
</tr>
<tr>
<td><code>animation-timing-function</code></td>
<td>动画播放速度曲线，值与过渡一样，默认 <code>ease</code></td>
</tr>
<tr>
<td><code>animation-delay</code></td>
<td>动画延迟时间，即多久后开始播放</td>
</tr>
<tr>
<td><code>animation-iteration-count</code></td>
<td>动画重复次数，<code>infinite</code>：表示无限循环</td>
</tr>
<tr>
<td><code>animation-direction</code></td>
<td>动画运行的方向</td>
</tr>
<tr>
<td><code>animation-play-state</code></td>
<td>动画运行状态，<code>running</code> （默认），<code>paused</code>：暂停，不包含在 <code>animation</code> 简写中，常配合事件使用</td>
</tr>
<tr>
<td><code>animation-fill-mode</code></td>
<td>动画在执行之前和之后如何将样式应用于目标</td>
</tr>
</tbody></table>
<h2 id="3-1-animation-direction"><a href="#3-1-animation-direction" class="headerlink" title="3.1 animation-direction"></a>3.1 animation-direction</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>normal</code>（默认）</td>
<td><code>0%</code> → <code>100%</code></td>
</tr>
<tr>
<td><code>reverse</code></td>
<td><code>100%</code> → <code>0%</code></td>
</tr>
<tr>
<td><code>alternate</code></td>
<td><code>0%</code> → <code>100%</code> → <code>0%</code></td>
</tr>
<tr>
<td><code>alternate-reverse</code></td>
<td><code>100%</code> → <code>0%</code> → <code>100%</code></td>
</tr>
</tbody></table>
<h2 id="3-2-animation-fill-mode"><a href="#3-2-animation-fill-mode" class="headerlink" title="3.2 animation-fill-mode"></a>3.2 animation-fill-mode</h2><table>
<thead>
<tr>
<th>值</th>
<th>动画执行前</th>
<th>动画执行后</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code>（默认）</td>
<td>目标在默认初始状态，延迟结束，起始帧才应用</td>
<td>回到默认初始状态</td>
</tr>
<tr>
<td><code>backwards</code></td>
<td>目标在起始帧状态</td>
<td>回到默认初始状态</td>
</tr>
<tr>
<td><code>forwards</code></td>
<td>目标在默认初始状态</td>
<td>停留在最后一帧</td>
</tr>
<tr>
<td><code>both</code></td>
<td>目标在起始帧状态</td>
<td>停止在最后一帧</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>CSS变形</title>
    <url>/anyeansan.github.io/2020/11/08/UI/CSS%E5%8F%98%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="一-坐标轴"><a href="#一-坐标轴" class="headerlink" title="一 坐标轴"></a>一 坐标轴</h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/CSS/3d%E5%9D%90%E6%A0%87.png" alt=""></p>
<h1 id="二-transform（变形）"><a href="#二-transform（变形）" class="headerlink" title="二 transform（变形）"></a>二 transform（变形）</h1><h2 id="2-1-取值"><a href="#2-1-取值" class="headerlink" title="2.1 取值"></a>2.1 取值</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code></td>
<td>无变形</td>
</tr>
<tr>
<td><code>&lt;transform-function&gt;</code></td>
<td>移动，缩放，旋转，倾斜 …</td>
</tr>
</tbody></table>
<ol>
<li>变形操作定义多次，则每次都是相对于原始状态变化</li>
<li>变形操作一次定义多个，使用空格隔开，每个相对于上一个结果变化，有顺序，有位移的建议放前面</li>
<li>行内元素不产生变形效果</li>
<li>变形不会影响其它元素位置</li>
</ol>
<h2 id="2-2-lt-transform-function-gt"><a href="#2-2-lt-transform-function-gt" class="headerlink" title="2.2 &lt;transform-function&gt;"></a>2.2 <code>&lt;transform-function&gt;</code></h2><h3 id="1-移动-translate"><a href="#1-移动-translate" class="headerlink" title="1 移动 translate"></a>1 移动 translate</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>translate(tx [, ty])</code></td>
<td>定义 x，y 轴偏移量</td>
</tr>
<tr>
<td><code>translateX(t)</code></td>
<td>定义 x 轴偏移量</td>
</tr>
<tr>
<td><code>translateY(t)</code></td>
<td>定义 y 轴偏移量</td>
</tr>
<tr>
<td><code>translateZ(t)</code></td>
<td>定义 z 轴偏移量</td>
</tr>
<tr>
<td><code>translate3d(tx, ty, tz)</code></td>
<td>定义 x，y，z 轴偏移量</td>
</tr>
</tbody></table>
<ul>
<li>偏移量 <code>t</code> 为 <code>&lt;length&gt;</code>，x,y 轴可以使用百分比（相对于元素宽高）</li>
</ul>
<h3 id="2-缩放-scale"><a href="#2-缩放-scale" class="headerlink" title="2 缩放 scale"></a>2 缩放 scale</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>scale(sx [, sy])</code></td>
<td>定义 x，y 轴的缩放比例，默认缩放基点是元素中心</td>
</tr>
<tr>
<td><code>scaleX(sx)</code></td>
<td>定义 x 轴的缩放比例</td>
</tr>
<tr>
<td><code>scaleY(sy)</code></td>
<td>定义 y 轴的缩放比例</td>
</tr>
<tr>
<td><code>scaleZ(sz)</code></td>
<td>定义 z 轴的缩放比例</td>
</tr>
<tr>
<td><code>scale3d(sx, sy, sz)</code></td>
<td>定义 x，y，z 轴的缩放比例</td>
</tr>
</tbody></table>
<ul>
<li>缩放比例 <code>s</code> 为 <code>&lt;number&gt;</code>（相对于元素原方向上尺寸）</li>
</ul>
<h3 id="3-旋转"><a href="#3-旋转" class="headerlink" title="3 旋转"></a>3 旋转</h3><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>rotate(angle)</code></td>
<td>定义 2D 旋转，默认旋转基点是元素中心</td>
</tr>
<tr>
<td><code>rotateX(angle)</code></td>
<td>定义沿着 X 轴的 3D 旋转，等价于 <code>rotate3D(1, 0, 0, angle)</code></td>
</tr>
<tr>
<td><code>rotateY(angle)</code></td>
<td>定义沿着 Y 轴的 3D 旋转，等价于 <code>rotate3D(0, 1, 0, angle)</code></td>
</tr>
<tr>
<td><code>rotateZ(angle)</code></td>
<td>定义沿着 Z 轴的 3D 旋转，等价于 <code>rotate3D(0, 0, 1, angle)</code></td>
</tr>
<tr>
<td><code>rotate3d(x,y,z,angle)</code></td>
<td>定义 3D 旋转，<code>(x,y,z)</code> 确定一个向量轴</td>
</tr>
</tbody></table>
<h3 id="4-倾斜"><a href="#4-倾斜" class="headerlink" title="4 倾斜"></a>4 倾斜</h3><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>skewX(angle)</code></td>
<td>定义沿着 X 轴的 2D 倾斜。</td>
</tr>
<tr>
<td><code>skewY(angle)</code></td>
<td>定义沿着 Y 轴的 2D 倾斜。</td>
</tr>
<tr>
<td><code>skew(x-angle,y-angle)</code></td>
<td>定义沿着 X 和 Y 轴的 2D 倾斜。</td>
</tr>
</tbody></table>
<h1 id="三-transform-origin（变形基点）"><a href="#三-transform-origin（变形基点）" class="headerlink" title="三  transform-origin（变形基点）"></a>三  transform-origin（变形基点）</h1><h2 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h2><table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>transform-origin: offset</code></td>
<td>定义 x , y 轴的偏移量</td>
</tr>
<tr>
<td><code>transform-origin: x-offset, y-offset</code></td>
<td>分别定义 x , y 轴的偏移量</td>
</tr>
<tr>
<td><code>transform-origin: x-offset, y-offset, z-offset</code></td>
<td>定义 x , y, z 轴的偏移量</td>
</tr>
</tbody></table>
<h2 id="3-2-取值"><a href="#3-2-取值" class="headerlink" title="3.2 取值"></a>3.2 取值</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;length&gt;</code></td>
<td>x, y, z 轴都可以使用长度作为偏移量</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>x, y 轴可以使用百分比作为偏移量（相对于元素宽高）</td>
</tr>
<tr>
<td><code>关键字</code></td>
<td><code>left right top bottom center</code></td>
</tr>
</tbody></table>
<h1 id="四-perspective（透视：3d眼镜）"><a href="#四-perspective（透视：3d眼镜）" class="headerlink" title="四  perspective（透视：3d眼镜）"></a>四  perspective（透视：3d眼镜）</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ol>
<li><code>perspective</code> 指定了观察者与 <code>z=0</code> 平面的距离，使具有三维位置变换的元素产生透视效果</li>
<li>眼镜看物体远小近大，即透视值越小，说明离得越近，物体越大，反之亦然</li>
<li>取值为 <code>&lt;lenght&gt;</code></li>
</ol>
<h2 id="4-2-透视使用"><a href="#4-2-透视使用" class="headerlink" title="4.2 透视使用"></a>4.2 透视使用</h2><table>
<thead>
<tr>
<th>语法</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>perspective: 100px</code></td>
<td>舞台透视</td>
<td>定义在父级，影响子元素且子元素透视效果不一，就好像在一个地方去观察一排杯子一样</td>
</tr>
<tr>
<td><code>transform: perspective(100px)</code></td>
<td>单独透视</td>
<td>为每个元素单独设置透视</td>
</tr>
</tbody></table>
<h1 id="五-transform-style（3D-呈现）"><a href="#五-transform-style（3D-呈现）" class="headerlink" title="五  transform-style（3D 呈现）"></a>五  transform-style（3D 呈现）</h1><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>flat</code>（默认）</td>
<td>2D 效果</td>
</tr>
<tr>
<td><code>preserve-3d</code></td>
<td>开启 3D立体环境，定义在父级，影响子元素</td>
</tr>
</tbody></table>
<h1 id="六-观看视角-perspective-origin"><a href="#六-观看视角-perspective-origin" class="headerlink" title="六 观看视角 perspective-origin"></a>六 观看视角 <code>perspective-origin</code></h1><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>x-axis</td>
<td>定义该视图在 x 轴上的位置。默认值：50%。可能的值：left、center、right、length、%</td>
</tr>
<tr>
<td>y-axis</td>
<td>定义该视图在 y 轴上的位置。默认值：50%。可能的值：top、center、bottom、length、%</td>
</tr>
</tbody></table>
<ol>
<li>perspective-origin用于控制视线的落点。就好像我们看车展，可以让车转，也可以我们自己转(perspective-origin)</li>
<li>需要设置 perspective 透视后才可以看到效果</li>
<li>一般设置在舞台元素上来控制子元素</li>
</ol>
<h1 id="七-隐藏背面-backface-visibility"><a href="#七-隐藏背面-backface-visibility" class="headerlink" title="七 隐藏背面 backface-visibility"></a>七 隐藏背面 <code>backface-visibility</code></h1><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>visible</td>
<td>背面可见</td>
</tr>
<tr>
<td>hidden</td>
<td>背面隐藏</td>
</tr>
</tbody></table>
<ol>
<li>使用 backface-visibility 用于控制是否可以看到元素的背面</li>
<li>一般设置在元素上而不是舞台元素上</li>
<li>如果设置在舞台元素（父级元素）需要设置 <code>transform-style: preserve-3d</code></li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>CSS过渡</title>
    <url>/anyeansan.github.io/2020/11/08/UI/CSS%E8%BF%87%E6%B8%A1/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>默认情况下 CSS 属性的变化是瞬间完成的</li>
<li>不是所有 css 属性都有过渡效果，一般来讲有中间值的属性都可以设置动画如宽度、透明度等。</li>
</ol>
<h1 id="二-transitionend"><a href="#二-transitionend" class="headerlink" title="二  transitionend"></a>二  transitionend</h1><ul>
<li>过渡完成后触发的事件</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>propertyName</code></td>
<td>结束过渡样式</td>
</tr>
<tr>
<td><code>elapsedTime</code></td>
<td>过渡需要的时间</td>
</tr>
<tr>
<td><code>pseudoElement</code></td>
<td>过渡的伪元素</td>
</tr>
<tr>
<td><code>isTrusted</code></td>
<td><code>true</code> 用户触发，<code>false</code> 脚本触发</td>
</tr>
</tbody></table>
<h1 id="三-transition（简写属性）"><a href="#三-transition（简写属性）" class="headerlink" title="三 transition（简写属性）"></a>三 transition（简写属性）</h1><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>transition-property</code></td>
<td>指定应用过渡的属性，对于简写属性如 <code>background</code>，其完整版属性都应用过渡</td>
</tr>
<tr>
<td><code>transition-duration</code></td>
<td>过渡时间，默认 <code>0s</code> （即不出现过渡动画），不能为负</td>
</tr>
<tr>
<td><code>transition-timing-function</code></td>
<td>过渡速度曲线</td>
</tr>
<tr>
<td><code>transition-delay</code></td>
<td>过渡延迟时间，必须在延迟时间后面</td>
</tr>
</tbody></table>
<h2 id="3-1-transition-property"><a href="#3-1-transition-property" class="headerlink" title="3.1 transition-property"></a>3.1 transition-property</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>all</code>（默认）</td>
<td>所有可过渡的属性都使用过渡</td>
</tr>
<tr>
<td><code>none</code></td>
<td>没有过渡</td>
</tr>
<tr>
<td><code>&lt;custom-ident&gt;</code></td>
<td>属性名称，多个用逗号隔开</td>
</tr>
</tbody></table>
<h2 id="3-2-transition-duration"><a href="#3-2-transition-duration" class="headerlink" title="3.2 transition-duration"></a>3.2 transition-duration</h2><ol>
<li>一个值时，所有属性使用同样的时间</li>
<li>多个值时，如果属性数量大于值数量，超出的属性再从第一个时间开始重复使用</li>
</ol>
<h2 id="3-3-transition-timing-function"><a href="#3-3-transition-timing-function" class="headerlink" title="3.3 transition-timing-function"></a>3.3 transition-timing-function</h2><h3 id="1-曲线"><a href="#1-曲线" class="headerlink" title="1 曲线"></a>1 曲线</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ease</code>（默认）</td>
<td>慢 → 快 → 慢 → 非常慢（等价于 <code>cubic-bezier(0.25,0.1,0.25,1)</code>）</td>
</tr>
<tr>
<td><code>linear</code></td>
<td>匀速（等价于 <code>cubic-bezier(0,0,1,1)</code>）。</td>
</tr>
<tr>
<td><code>ease-in</code></td>
<td>慢 → 快（等价于<code>cubic-bezier(0.42,0,1,1)</code>）</td>
</tr>
<tr>
<td><code>ease-out</code></td>
<td>快 → 慢 （等价于 <code>cubic-bezier(0,0,0.58,1)</code>）</td>
</tr>
<tr>
<td><code>ease-in-out</code></td>
<td>慢 → 快 → 慢（等价于 <code>cubic-bezier(0.42,0,0.58,1)</code>）</td>
</tr>
<tr>
<td><code>cubic-bezier(n,n,n,n)</code></td>
<td>三次贝塞尔曲线</td>
</tr>
</tbody></table>
<h3 id="2-步进"><a href="#2-步进" class="headerlink" title="2 步进"></a>2 步进</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>steps(n, start)</code></td>
<td>将过渡过程分为 n 个阶段，每个阶段从阶段开始就变化，即每个阶段一开始就是此阶段结束时的效果</td>
</tr>
<tr>
<td><code>steps(n, end)</code></td>
<td>将过渡过程分为 n 个阶段，每个阶段到阶段结束才变化，即每个阶段一开始是此阶段开始时的效果</td>
</tr>
<tr>
<td><code>step-start</code></td>
<td>同 <code>steps(1, start)</code></td>
</tr>
<tr>
<td><code>step-end</code></td>
<td>同<code>steps(1,end)</code></td>
</tr>
</tbody></table>
<h2 id="3-4-transition-delay"><a href="#3-4-transition-delay" class="headerlink" title="3.4 transition-delay"></a>3.4 transition-delay</h2><ol>
<li>延迟时间，即等待多久后开始过渡，必须在过渡时间之后</li>
<li>默认为 <code>0s</code>，即立刻开始过渡</li>
<li>值可以为负数，如<code>-3s</code>，表示直接显示在 <code>3s</code> 时的效果</li>
<li>过渡属性数量大于时间数量时，后面的属性从第一个时间开始重复使用</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>CSS栅格布局</title>
    <url>/anyeansan.github.io/2020/11/08/UI/CSS%E6%A0%85%E6%A0%BC%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="一-Grid-概述"><a href="#一-Grid-概述" class="headerlink" title="一 Grid 概述"></a>一 Grid 概述</h1><ol>
<li>将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局</li>
<li>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是二维布局</li>
<li>设为网格布局以后，容器子元素（项目）的float、vertical-align等设置都将失效</li>
</ol>
<h1 id="二-基本概念"><a href="#二-基本概念" class="headerlink" title="二 基本概念"></a>二 基本概念</h1><table>
<thead>
<tr>
<th>概念</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Grid Container</code></td>
<td>栅格容器</td>
<td>采用 grid 布局的元素</td>
</tr>
<tr>
<td><code>Grid Item</code></td>
<td>栅格项目</td>
<td>栅格容器中采用网格定位的子元素</td>
</tr>
<tr>
<td><code>Grid Line</code></td>
<td>栅格线</td>
<td>划分网格的线</td>
</tr>
<tr>
<td><code>Grid Track</code></td>
<td>栅格轨道</td>
<td>两条相邻网格线之间的空间，即行（row）和列（column）</td>
</tr>
<tr>
<td><code>Grid Cell</code></td>
<td>栅格单元格</td>
<td>行和列的交叉区域</td>
</tr>
<tr>
<td><code>Grid Area</code></td>
<td>栅格区域</td>
<td>由任意数量单元格组成的区域（必须为矩形）</td>
</tr>
</tbody></table>
<h2 id="三-声明容器"><a href="#三-声明容器" class="headerlink" title="三 声明容器"></a>三 声明容器</h2><table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>display: grid</code></td>
<td>块级栅格容器</td>
</tr>
<tr>
<td><code>display: inline-grid</code></td>
<td>内联栅格容器</td>
</tr>
</tbody></table>
<h1 id="四-容器属性"><a href="#四-容器属性" class="headerlink" title="四 容器属性"></a>四 容器属性</h1><h2 id="4-1-grid-template"><a href="#4-1-grid-template" class="headerlink" title="4.1 grid-template"></a>4.1 grid-template</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-template: grid-template-rows grid-template-columns grid-template-areas</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>grid-template-rows</code></td>
<td>定义每一行的高度</td>
</tr>
<tr>
<td><code>grid-template-columns</code></td>
<td>定义每一列的宽度</td>
</tr>
<tr>
<td><code>grid-template-areas</code></td>
<td>定义栅格区域</td>
</tr>
</tbody></table>
<h3 id="1-grid-template-rows-amp-grid-template-columns"><a href="#1-grid-template-rows-amp-grid-template-columns" class="headerlink" title="1 grid-template-rows &amp; grid-template-columns"></a>1 grid-template-rows &amp; grid-template-columns</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ &lt;line-names&gt;? [ &lt;track-size&gt; | &lt;track-repeat&gt; ] ]+ </span><br><span class="line">&lt;line-names&gt;?</span><br></pre></td></tr></table></figure>

<h4 id="1-lt-line-names-gt"><a href="#1-lt-line-names-gt" class="headerlink" title="1 &lt;line-names&gt;"></a>1 <code>&lt;line-names&gt;</code></h4><ol>
<li>指定删格线名称，格式：<code>[name1 name2 ...]</code></li>
<li>可以省略，则名称按顺序分配为 <code>1 2 3 ...</code> </li>
</ol>
<h4 id="2-lt-track-size-gt"><a href="#2-lt-track-size-gt" class="headerlink" title="2 &lt;track-size&gt;"></a>2 <code>&lt;track-size&gt;</code></h4><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code></td>
<td>表示由浏览器自己决定长度</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>长度单位</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>栅格容器宽/高的百分比</td>
</tr>
<tr>
<td><code>fr</code></td>
<td>网格剩余空间比例单位（<code>fraction</code> 的缩写，意为”片段”）</td>
</tr>
<tr>
<td><code>minmax(min, max)</code></td>
<td>尺寸在min和max之间，若min&gt;max，则max的值会被忽略</td>
</tr>
</tbody></table>
<h4 id="3-lt-track-repeat-gt"><a href="#3-lt-track-repeat-gt" class="headerlink" title="3 &lt;track-repeat&gt;"></a>3 <code>&lt;track-repeat&gt;</code></h4><ul>
<li><code>repeat( count, [ &lt;line-names&gt;? &lt;track-size&gt; ]+ &lt;line-names&gt;? )</code><ul>
<li>count：重复次数，如果重复次数不确定可以使用<ol>
<li>auto-fill 关键字</li>
<li>auto-fit 关键字</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="2-grid-template-areas"><a href="#2-grid-template-areas" class="headerlink" title="2 grid-template-areas"></a>2 grid-template-areas</h3><ul>
<li>区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code></li>
</ul>
<h4 id="1-为每个单元格设置区域（假如三行三列9个单元格）"><a href="#1-为每个单元格设置区域（假如三行三列9个单元格）" class="headerlink" title="1 为每个单元格设置区域（假如三行三列9个单元格）"></a>1 为每个单元格设置区域（假如三行三列9个单元格）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-template-areas: &quot;a b c&quot;</span><br><span class="line">					&quot;d e f&quot;</span><br><span class="line">					&quot;g h i&quot;;</span><br></pre></td></tr></table></figure>

<h4 id="2-多个单元格合并成一个区域：区域名相同即可"><a href="#2-多个单元格合并成一个区域：区域名相同即可" class="headerlink" title="2 多个单元格合并成一个区域：区域名相同即可"></a>2 多个单元格合并成一个区域：区域名相同即可</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-template-areas: &quot;a a a&quot;</span><br><span class="line">					&quot;b b b&quot;</span><br><span class="line">					&quot;c c c&quot;;</span><br><span class="line">grid-template-areas: &quot;header header header&quot;</span><br><span class="line">					&quot;main main sidebar&quot;</span><br><span class="line">					&quot;footer footer footer&quot;;</span><br></pre></td></tr></table></figure>

<h4 id="3-区域占位符（点）：表示没有用到该单元格，或者该单元格不属于任何区域"><a href="#3-区域占位符（点）：表示没有用到该单元格，或者该单元格不属于任何区域" class="headerlink" title="3 区域占位符（点）：表示没有用到该单元格，或者该单元格不属于任何区域"></a>3 区域占位符（点）：表示没有用到该单元格，或者该单元格不属于任何区域</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-template-areas: &quot;a . c&quot;</span><br><span class="line">					&quot;. . f&quot;</span><br><span class="line">					&quot;g h .&quot;;</span><br></pre></td></tr></table></figure>



<h2 id="4-2-grap"><a href="#4-2-grap" class="headerlink" title="4.2 grap"></a>4.2 grap</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grap: row-gap column-gap # 如果省略了第二个值，则等于第一个值</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>row-gap</code></td>
<td>设置行与行的间隔（行间距）</td>
</tr>
<tr>
<td><code>column-gap</code></td>
<td>设置列与列的间隔（列间距）</td>
</tr>
</tbody></table>
<h2 id="4-3-grid-auto-flow"><a href="#4-3-grid-auto-flow" class="headerlink" title="4.3 grid-auto-flow"></a>4.3 grid-auto-flow</h2><ul>
<li>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。</li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>row</code>（默认）</td>
<td>先行后列</td>
</tr>
<tr>
<td><code>column</code></td>
<td>先列后行</td>
</tr>
<tr>
<td><code>row dense</code></td>
<td>先行后列，并且尽量填满空格</td>
</tr>
<tr>
<td><code>column dense</code></td>
<td>先列后行，并且尽量填满空格</td>
</tr>
</tbody></table>
<ul>
<li>尽量填满的意思是比如第2个元素太宽第一行放不下，可以先放第3,4…个</li>
</ul>
<h2 id="4-4-place-items"><a href="#4-4-place-items" class="headerlink" title="4.4 place-items"></a>4.4 place-items</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">place-items: align-items justify-items # 如果省略了第二个值，则等于第一个值</span><br></pre></td></tr></table></figure>



<h3 id="1-属性"><a href="#1-属性" class="headerlink" title="1 属性"></a>1 属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>justify-items</td>
<td>单元格中的元素在单元格中的水平对齐方式（针对所有单元格）</td>
</tr>
<tr>
<td>align-items</td>
<td>单元格中的元素的在单元格中垂直对齐方式（针对所有单元格）</td>
</tr>
</tbody></table>
<h3 id="2-取值"><a href="#2-取值" class="headerlink" title="2 取值"></a>2 取值</h3><table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>stretch</code>（默认）</td>
<td>拉伸，占满单元格的整个宽度</td>
</tr>
<tr>
<td><code>start</code></td>
<td>对齐单元格的起始边缘</td>
</tr>
<tr>
<td><code>end</code></td>
<td>对齐单元格的结束边缘</td>
</tr>
<tr>
<td><code>center</code></td>
<td>单元格内部居中</td>
</tr>
</tbody></table>
<h2 id="4-5-place-content"><a href="#4-5-place-content" class="headerlink" title="4.5 place-content"></a>4.5 place-content</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">place-content: align-content justify-content # 如果省略了第二个值，则等于第一个值</span><br></pre></td></tr></table></figure>



<h3 id="1-属性-1"><a href="#1-属性-1" class="headerlink" title="1 属性"></a>1 属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>justify-content</td>
<td>所有单元格（整个内容区域）在容器中的水平对齐方式</td>
</tr>
<tr>
<td>align-content</td>
<td>所有单元格（整个内容区域）在容器中的垂直对齐方式</td>
</tr>
</tbody></table>
<h3 id="2-取值-1"><a href="#2-取值-1" class="headerlink" title="2 取值"></a>2 取值</h3><table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>stretch（默认）</td>
<td>拉伸，占满单元格的整个宽度</td>
</tr>
<tr>
<td>start</td>
<td>对齐单元格的起始边缘</td>
</tr>
<tr>
<td>end</td>
<td>对齐单元格的结束边缘</td>
</tr>
<tr>
<td>center</td>
<td>单元格内部居中</td>
</tr>
<tr>
<td>space-between</td>
<td>两端对齐，两端紧挨边框中间平均分配</td>
</tr>
<tr>
<td>space-around</td>
<td>每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍</td>
</tr>
<tr>
<td>space-evenly</td>
<td>项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔</td>
</tr>
</tbody></table>
<h2 id="4-6-grid-auto-columns-amp-grid-auto-rows"><a href="#4-6-grid-auto-columns-amp-grid-auto-rows" class="headerlink" title="4.6 grid-auto-columns &amp; grid-auto-rows"></a>4.6 grid-auto-columns &amp; grid-auto-rows</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>grid-auto-columns</td>
<td>浏览器自动创建的多余网格的列宽</td>
</tr>
<tr>
<td>grid-auto-rows</td>
<td>浏览器自动创建的多余网格的行高</td>
</tr>
</tbody></table>
<ul>
<li>有时，一些项目的指定位置在现有网格的外部，比如网格只有三行，但是有一个项目在第五行，这时，浏览器会自动生成多余的网格，以便放置项目。</li>
<li>如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高</li>
</ul>
<h2 id="4-7-grid"><a href="#4-7-grid" class="headerlink" title="4.7 grid"></a>4.7 grid</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid: grid-template-rows grid-template-columns grid-template-areas  grid-auto-rows grid-auto-columns grid-auto-flow</span><br></pre></td></tr></table></figure>



<h1 id="五-项目属性"><a href="#五-项目属性" class="headerlink" title="五 项目属性"></a>五 项目属性</h1><h2 id="5-1-项目定位"><a href="#5-1-项目定位" class="headerlink" title="5.1 项目定位"></a>5.1 项目定位</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>grid-row-start</td>
<td>行开始栅格线（上边框）</td>
</tr>
<tr>
<td>grid-row-end</td>
<td>行结束栅格线（下边框）</td>
</tr>
<tr>
<td>grid-column-start</td>
<td>列开始栅格线（左边框）</td>
</tr>
<tr>
<td>grid-column-end</td>
<td>列结束栅格线（右边框）</td>
</tr>
</tbody></table>
<h3 id="1-根据栅格线"><a href="#1-根据栅格线" class="headerlink" title="1 根据栅格线"></a>1 根据栅格线</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-column-start: 1;</span><br><span class="line">grid-column-end: 3;</span><br><span class="line">grid-row-start: 2;</span><br><span class="line">grid-row-end: 4;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置栅格线来定位，设置的数值可以是正数和负数</li>
</ul>
<h3 id="2-根据栅格命名"><a href="#2-根据栅格命名" class="headerlink" title="2 根据栅格命名"></a>2 根据栅格命名</h3><ol>
<li>固定命名</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-column-start: header-start;</span><br><span class="line">grid-column-end: header-end;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>自动命名</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 后边数字表示第几个</span><br><span class="line">grid-column-start: c-start 1;</span><br><span class="line">grid-column-end: c-end 3;</span><br></pre></td></tr></table></figure>

<h3 id="3-根据偏移量"><a href="#3-根据偏移量" class="headerlink" title="3 根据偏移量"></a>3 根据偏移量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-row-end: span 1;</span><br><span class="line">grid-column-end: span 1;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>span</code> 可以设置移动单元格数量（即开始栅格线和结束栅格线之间有几个单元格），数值只能为正数</li>
</ul>
<h2 id="5-2-grid-column-amp-grid-row"><a href="#5-2-grid-column-amp-grid-row" class="headerlink" title="5.2 grid-column &amp; grid-row"></a>5.2 grid-column &amp; grid-row</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>grid-row</td>
<td><code>grid-row-start / grid-row-end</code></td>
</tr>
<tr>
<td>grid-column</td>
<td><code>grid-column-start / grid-column-end</code></td>
</tr>
</tbody></table>
<ol>
<li>设置起始栅格线</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-column: 1 / 3;</span><br><span class="line">grid-row: 1 / 2;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用span</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-column: 1 / span 3;</span><br><span class="line">grid-row: 1 / span 2;</span><br><span class="line">// 如果省略斜杠及后面部分，表示span值为1</span><br><span class="line">grid-row: 1;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-grid-area"><a href="#5-3-grid-area" class="headerlink" title="5.3 grid-area"></a>5.3 grid-area</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. grid-area: 区域名;</span><br><span class="line">2. grid-area: grid-row-start / grid-column-start / grid-row-end / grid-column-end</span><br></pre></td></tr></table></figure>



<h2 id="5-4-place-self"><a href="#5-4-place-self" class="headerlink" title="5.4 place-self"></a>5.4 place-self</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">place-self: align-self justify-self # 如果省略了第二个值，则等于第一个值</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>justify-self</td>
<td>单元格中的元素在单元格中的水平对齐方式（针对单个单元格），用法同 <code>justify-items</code></td>
</tr>
<tr>
<td>align-self</td>
<td>单元格中的元素在单元格中的垂直对齐方式（针对单个单元格），用法同 <code>align-items</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>CSS弹性布局</title>
    <url>/anyeansan.github.io/2020/11/08/UI/CSS%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="一-Flex-概述"><a href="#一-Flex-概述" class="headerlink" title="一 Flex 概述"></a>一 Flex 概述</h1><ol>
<li>是 <code>Flexible Box</code> 的缩写，意为”弹性布局”</li>
<li>任何一个容器都可以指定为 Flex 布局</li>
<li>设为 Flex 布局以后，子元素的 <code>float、clear</code> 和 <code>vertical-align</code> 属性将失效</li>
<li>绝对定位的弹性元素不参与弹性布局</li>
</ol>
<h1 id="二-基本概念"><a href="#二-基本概念" class="headerlink" title="二 基本概念"></a>二 基本概念</h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/CSS/Flex%E6%A6%82%E5%BF%B5.png" alt=""></p>
<table>
<thead>
<tr>
<th>概念</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>flex container</code></td>
<td>Flex 容器</td>
<td>采用 Flex 布局的元素</td>
</tr>
<tr>
<td><code>flex item</code></td>
<td>Flex 项目</td>
<td>Flex 容器中的子元素</td>
</tr>
<tr>
<td><code>main axis</code></td>
<td>主轴</td>
<td>默认水平轴为主轴，单个项目占据的主轴空间叫 <code>main size</code></td>
</tr>
<tr>
<td><code>cross axis</code></td>
<td>交叉轴</td>
<td>默认垂直轴为交叉轴，单个项目占据的主轴空间叫 <code>cross size</code></td>
</tr>
</tbody></table>
<h1 id="三-声明容器"><a href="#三-声明容器" class="headerlink" title="三 声明容器"></a>三 声明容器</h1><table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>display:flex</code></td>
<td>块级弹性盒子</td>
</tr>
<tr>
<td><code>display:inline-flex</code></td>
<td>内联级弹性盒子</td>
</tr>
</tbody></table>
<h1 id="四-容器属性"><a href="#四-容器属性" class="headerlink" title="四 容器属性"></a>四 容器属性</h1><h2 id="4-1-flex-flow"><a href="#4-1-flex-flow" class="headerlink" title="4.1 flex-flow"></a>4.1 flex-flow</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex-flow: flex-direction || flex-wrap</span><br></pre></td></tr></table></figure>

<h2 id="4-2-flex-direction"><a href="#4-2-flex-direction" class="headerlink" title="4.2 flex-direction"></a>4.2 flex-direction</h2><ul>
<li>决定主轴的方向</li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>row</code>（默认）</td>
<td>主轴为水平方向，起点在左端（从左到右）</td>
</tr>
<tr>
<td><code>row-reverse</code></td>
<td>主轴为水平方向，起点在右端（从右到左）</td>
</tr>
<tr>
<td><code>column</code></td>
<td>主轴为垂直方向，起点在上沿（从上到下）</td>
</tr>
<tr>
<td><code>column-reverse</code></td>
<td>主轴为垂直方向，起点在下沿（从下到上）</td>
</tr>
</tbody></table>
<h2 id="4-3-flex-wrap"><a href="#4-3-flex-wrap" class="headerlink" title="4.3 flex-wrap"></a>4.3 flex-wrap</h2><ul>
<li>定义如果项目一条轴线排不下，如何换行</li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th>水平主轴</th>
<th>垂直主轴</th>
</tr>
</thead>
<tbody><tr>
<td><code>nowrap</code>（默认）</td>
<td>不换行，会缩小项目来摆放</td>
<td>不换列</td>
</tr>
<tr>
<td><code>wrap</code></td>
<td>换行，新行在下</td>
<td>换列，新列在右</td>
</tr>
<tr>
<td><code>wrap-reverse</code></td>
<td>换行，新行在上</td>
<td>换列，新列在左</td>
</tr>
</tbody></table>
<h2 id="4-4-justify-content"><a href="#4-4-justify-content" class="headerlink" title="4.4 justify-content"></a>4.4 justify-content</h2><ul>
<li>定义项目在主轴上的对齐方式</li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>flex-start</code>（默认）</td>
<td>主轴起点对齐</td>
</tr>
<tr>
<td><code>flex-end</code></td>
<td>主轴终点对齐</td>
</tr>
<tr>
<td><code>center</code></td>
<td>主轴居中对齐</td>
</tr>
<tr>
<td><code>space-between</code></td>
<td>主轴两端对齐，左右项目紧挨边框，中间项目间距相等</td>
</tr>
<tr>
<td><code>space-around</code></td>
<td>每个项目两侧的间距相等。即项目之间的间隔是项目与边框的间隔的2倍</td>
</tr>
<tr>
<td><code>space-evenly</code></td>
<td>所有间距都相等</td>
</tr>
</tbody></table>
<h2 id="4-5-align-items"><a href="#4-5-align-items" class="headerlink" title="4.5 align-items"></a>4.5 align-items</h2><ul>
<li>定义项目在交叉轴上的对齐方式（单行）</li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>stretch</code>（默认）</td>
<td>如果项目未设置高度或设为auto，将占满整个容器的高度</td>
</tr>
<tr>
<td><code>center</code></td>
<td>交叉轴居中对齐</td>
</tr>
<tr>
<td><code>flex-start</code></td>
<td>交叉轴起点对齐</td>
</tr>
<tr>
<td><code>flex-end</code></td>
<td>交叉轴终点对齐</td>
</tr>
<tr>
<td><code>baseline</code></td>
<td>项目的第一行文字的基线对齐</td>
</tr>
</tbody></table>
<h2 id="4-6-align-content"><a href="#4-6-align-content" class="headerlink" title="4.6 align-content"></a>4.6 align-content</h2><ul>
<li>定义项目在交叉轴上的对齐方式（多行），项目有换行，单行无效</li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>stretch</code>（默认）</td>
<td>轴线占满整个交叉轴</td>
</tr>
<tr>
<td><code>flex-start</code></td>
<td>交叉轴起点对齐</td>
</tr>
<tr>
<td><code>flex-end</code></td>
<td>交叉轴终点对齐</td>
</tr>
<tr>
<td><code>center</code></td>
<td>交叉轴居中对齐</td>
</tr>
<tr>
<td><code>space-between</code></td>
<td>交叉轴两端对齐，两侧轴线紧挨边框，中间轴线间距相等</td>
</tr>
<tr>
<td><code>space-around</code></td>
<td>每根轴线两侧的间距都相等。所以，轴线之间的间距是轴线与边框的 2 倍</td>
</tr>
<tr>
<td><code>space-evenly</code></td>
<td>所有间距相等</td>
</tr>
</tbody></table>
<h1 id="五-项目属性"><a href="#五-项目属性" class="headerlink" title="五 项目属性"></a>五 项目属性</h1><h2 id="5-1-flex-grow"><a href="#5-1-flex-grow" class="headerlink" title="5.1 flex-grow"></a>5.1 flex-grow</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/CSS/flex-grow%E8%AE%A1%E7%AE%97%E8%A7%84%E5%88%99.jpg" alt=""></p>
<ol>
<li>当所有项目宽度之和小于容器宽度，即容器有剩余空间 <code>剩余空间 = 容器宽度 - 项目宽度之和</code></li>
<li>所有项目的 <code>flex-grow</code> 之和等于 n ，则把剩余空间分为 n 份</li>
<li>然后根据每个项目 <code>flex-grow</code> 所占比例放大项目</li>
</ol>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;number&gt;</code></td>
<td>放大比例，默认为 0，不能为负</td>
</tr>
</tbody></table>
<h2 id="5-2-flex-shrink"><a href="#5-2-flex-shrink" class="headerlink" title="5.2 flex-shrink"></a>5.2 flex-shrink</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/CSS/flex-shrink%E8%AE%A1%E7%AE%97%E8%A7%84%E5%88%99.jpg" alt=""></p>
<ol>
<li>当所有项目宽度之和大于容器宽度，即容器不足，<code>溢出空间 = 项目宽度之和 - 容器宽度</code></li>
<li>根据计算规则算出每个项目的大小（很复杂）</li>
</ol>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;number&gt;</code></td>
<td>缩小比例，默认为 1，不能为负</td>
</tr>
</tbody></table>
<h2 id="5-3-flex-basis"><a href="#5-3-flex-basis" class="headerlink" title="5.3 flex-basis"></a>5.3 flex-basis</h2><ul>
<li>指定了 项目在主轴方向上的初始大小。</li>
<li>优先级<ul>
<li><code>min-width max width / min-height max-height</code> &gt; <code>flex-basis</code>  &gt;  <code>width / heifht</code></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code>（默认）</td>
<td>项目的本来大小（参照 width 和 height 属性）</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>长度单位</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>相对于弹性容器主轴尺寸的百分比</td>
</tr>
<tr>
<td><code>content</code></td>
<td>基于项目的内容自动调整大小</td>
</tr>
</tbody></table>
<h2 id="5-4-flex"><a href="#5-4-flex" class="headerlink" title="5.4 flex"></a>5.4 flex</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex: flex-grow flex-shrink? || flex-basis</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>0 1 auto</code>（默认）</td>
<td>即三个属性分别的默认值</td>
</tr>
<tr>
<td><code>auto</code></td>
<td>相当于 <code>1 1 auto</code></td>
</tr>
<tr>
<td><code>none</code></td>
<td>相当于 <code>0 0 auto</code></td>
</tr>
</tbody></table>
<h2 id="5-5-align-self"><a href="#5-5-align-self" class="headerlink" title="5.5 align-self"></a>5.5 align-self</h2><ul>
<li>单独定义项目自己在交叉轴上对齐方式</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code>（默认）</td>
<td>设置为父元素的 <code>align-items</code> 值，如果该元素没有父元素的话，就设置为 <code>stretch</code></td>
</tr>
<tr>
<td><code>strech</code></td>
<td>如果项目未设置高度或设为 <code>auto</code>，将占满整个容器的高度</td>
</tr>
<tr>
<td><code>flex-start</code></td>
<td>交叉轴起点对齐</td>
</tr>
<tr>
<td><code>flex-end</code></td>
<td>交叉轴终点对齐</td>
</tr>
<tr>
<td><code>center</code></td>
<td>交叉轴居中对齐</td>
</tr>
<tr>
<td><code>baseline</code></td>
<td>项目的第一行文字的基线对齐</td>
</tr>
</tbody></table>
<h2 id="5-6-order"><a href="#5-6-order" class="headerlink" title="5.6 order"></a>5.6 order</h2><ul>
<li>定义项目的排列顺序。数值越小，排列越靠前</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;integer&gt;</code></td>
<td>默认为 0，可以为负</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>CSS继承和层叠</title>
    <url>/anyeansan.github.io/2020/11/08/UI/CSS%E7%BB%A7%E6%89%BF%E5%92%8C%E5%B1%82%E5%8F%A0/</url>
    <content><![CDATA[<h1 id="一-继承"><a href="#一-继承" class="headerlink" title="一 继承"></a>一 继承</h1><h2 id="1-1-控制继承"><a href="#1-1-控制继承" class="headerlink" title="1.1 控制继承"></a>1.1 控制继承</h2><ul>
<li>CSS 提供了四个通用属性值来控制继承，元素的每个属性都可以设置这四个值</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>inherit</code></td>
<td>开启继承</td>
</tr>
<tr>
<td><code>initial</code></td>
<td>设置 CSS 属性为它的默认值</td>
</tr>
<tr>
<td><code>unset</code></td>
<td>如果该属性默认可继承，该值等同于 <code>inherit</code>，如果该属性是非继承属性，该值等同于 <code>initial</code></td>
</tr>
<tr>
<td><code>revert</code></td>
<td>只有很少的浏览器支持</td>
</tr>
</tbody></table>
<h2 id="1-2-元素可继承属性"><a href="#1-2-元素可继承属性" class="headerlink" title="1.2 元素可继承属性"></a>1.2 元素可继承属性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">azimuth border-collapse border-spacing caption-side color cursor</span><br><span class="line">direction elevation empty-cells font-family font-size font-style </span><br><span class="line">font-variant font-weight font letter-spacing line-height </span><br><span class="line">list-style-image list-style-position list-style-type list-style</span><br><span class="line">orphans pitch-range pitch quotes richness speak-header</span><br><span class="line">speak-numeral speak-punctuation speak speech-rate stress</span><br><span class="line">text-align text-indent text-transform visibility voice-family volume</span><br><span class="line">white-space widows word-spacing</span><br></pre></td></tr></table></figure>

<ol>
<li><code>font-*</code>， <code>color</code></li>
<li><code>text-*</code></li>
<li><code>line-height</code></li>
<li><code>list-*</code></li>
<li><code>visibility</code> <code>cursor</code></li>
<li><code>letter-spacing</code> 和 <code>word-spacing</code></li>
</ol>
<h1 id="二-层叠"><a href="#二-层叠" class="headerlink" title="二 层叠"></a>二 层叠</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><table>
<thead>
<tr>
<th>概念</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>stacking context</code></td>
<td>层叠上下文</td>
<td>层叠上下文是一个概念，可以想象成 z 轴上的一个层叠结界</td>
</tr>
<tr>
<td><code>stacking level</code></td>
<td>层叠等级</td>
<td>决定了同一个层叠上下文中元素在 z 轴上的显示顺序</td>
</tr>
</tbody></table>
<h2 id="2-2-层叠上下文"><a href="#2-2-层叠上下文" class="headerlink" title="2.2 层叠上下文"></a>2.2 层叠上下文</h2><h3 id="1-层叠上下文特性"><a href="#1-层叠上下文特性" class="headerlink" title="1 层叠上下文特性"></a>1 层叠上下文特性</h3><ol>
<li>层叠上下文的层叠水平要比普通元素高。</li>
<li>层叠上下文可以阻断元素的混合模式</li>
<li>层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。</li>
<li>每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。</li>
<li>每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中</li>
</ol>
<h3 id="2-创建层叠上下文"><a href="#2-创建层叠上下文" class="headerlink" title="2 创建层叠上下文"></a>2 创建层叠上下文</h3><ol>
<li>页面根元素<code>&lt;html&gt;</code>天生具有层叠上下文，称为根层叠上下文。</li>
<li>定位元素（position非static）的 z-index 不是auto，会创建层叠上下文</li>
<li>其它css3属性创建层叠上下文<ol>
<li>元素为 flex 布局元素（即父元素 display:flex / inline-flex），同时 z-index值不是 auto。</li>
<li>元素的 opacity 值不是 1。</li>
<li>元素的 transform 值不是 none。</li>
<li>元素 mix-blend-mode 值不是 normal。</li>
<li>元素的 filter 值不是 none。</li>
<li>元素的 isolation 值是 isolate。</li>
<li>元素的 will-change 属性值为上面 2～6 的任意一个（如willchange:opacity、will-chang:transform 等）。</li>
<li>元素的-webkit-overflow-scrolling 设为 touch。</li>
</ol>
</li>
</ol>
<h2 id="2-3-层叠等级"><a href="#2-3-层叠等级" class="headerlink" title="2.3 层叠等级"></a>2.3 层叠等级</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/CSS/stacking-order.png" alt=""></p>
<h3 id="1-同一个层叠上下文中的七层"><a href="#1-同一个层叠上下文中的七层" class="headerlink" title="1 同一个层叠上下文中的七层"></a>1 同一个层叠上下文中的七层</h3><ol>
<li>层叠上下文的背景和边框</li>
<li>层叠上下文中z-index值为负的层叠上下文元素</li>
<li>层叠上下文中块级普通元素</li>
<li>层叠上下文中浮动元素</li>
<li>层级上下文中内联普通元素</li>
<li>此层包含三种<ol>
<li>层叠上下文中不依赖z-index 的层叠上下文元素（即元素创建层叠上下文时不是用的z-index）</li>
<li>层叠上下文中z-index值为 0 的层叠上下文元素</li>
<li>层叠上下文中z-index值为 auto 的普通定位元素<ol>
<li>元素一旦成为定位元素，其z-index就会自动生效，默认为auto</li>
<li>定位元素的z-index值为数值时才是层叠上下文，所以此时是普通定位元素，并非层叠上下文</li>
</ol>
</li>
</ol>
</li>
<li>层叠上下文中z-index值为负的层叠上下文元素</li>
</ol>
<h3 id="2-比较步骤"><a href="#2-比较步骤" class="headerlink" title="2 比较步骤"></a>2 比较步骤</h3><ol>
<li>首先查看两个元素是否在同一个层叠上下文<ol>
<li>否，则查看它们所在的层叠上下文是否在同一个层叠上下文，如果还不是，继续往上…直到两个层叠上下文在同一个层叠上下文中，最终肯定在同一个层叠上下文，因为有根层叠上下文。</li>
<li>是，则根据它们的层叠水平，在层叠顺序中找到位置。</li>
</ol>
</li>
<li>如果在层叠顺序中位置相同<ol>
<li>如果明显的层叠水平标识的，如生效的 <code>z-index</code>，则谁大谁在上</li>
<li>如果没有明显的层叠水平标识的，则后来居上（即在 DOM 流中处于后面的元素会覆盖前面的元素）</li>
</ol>
</li>
</ol>
<h2 id="2-4-z-index"><a href="#2-4-z-index" class="headerlink" title="2.4 z-index"></a>2.4 z-index</h2><ul>
<li>只能用在 <code>定位元素</code> 和 <code>flex 布局中的项目</code></li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code>（默认）</td>
<td>不会创建一个新的本地堆叠上下文</td>
</tr>
<tr>
<td><code>&lt;integer&gt;</code></td>
<td>创建层叠上下文，可以为负</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>CSS浮动定位</title>
    <url>/anyeansan.github.io/2020/11/08/UI/CSS%E6%B5%AE%E5%8A%A8%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ul>
<li>CSS 有三种机制摆放盒子<ol>
<li>正常文档流（标准流）<ol>
<li>块级元素自上而下，独占一行</li>
<li>行内元素从左到右，碰到父元素自动换行</li>
</ol>
</li>
<li>浮动<ul>
<li>元素在正常流元素之上</li>
</ul>
</li>
<li>定位<ul>
<li>元素在正常流元素和浮动元素之上</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="二-浮动"><a href="#二-浮动" class="headerlink" title="二 浮动"></a>二 浮动</h1><h2 id="2-1-浮动的作用"><a href="#2-1-浮动的作用" class="headerlink" title="2.1 浮动的作用"></a>2.1 浮动的作用</h2><ol>
<li>浮动原本是为了实现文字环绕效果</li>
<li>让块级盒子排成一行</li>
<li>盒子左右对齐</li>
</ol>
<h2 id="2-2-浮动的特性"><a href="#2-2-浮动的特性" class="headerlink" title="2.2 浮动的特性"></a>2.2 浮动的特性</h2><h3 id="1-破坏文档流"><a href="#1-破坏文档流" class="headerlink" title="1 破坏文档流"></a>1 破坏文档流</h3><ol>
<li>浮动会使元素脱离正常文档流，漂浮在正常文档流上方且不再占据正常文档流位置，直到左边缘或右边缘触及包含块或另一个浮动框的边缘<ol start="2">
<li>浮动元素不会超过父盒子的边框或内边距</li>
<li>浮动元素的上一个兄弟元素：<ul>
<li>是浮动元素，则当前浮动元素跟随它，一行显示，放不下自动换行</li>
<li>是文档流块级元素，则由于块级元素占据一行，所以那一行没有当前浮动元素的位置了，只能在其下边浮动</li>
<li>是文档流行内或行内块元素，如果行内或行内块元素占满了一行，那么没有当前浮动元素的位置了，只能在其下边浮动；反之，有当前浮动元素的位置，由于浮动元素只会在触及到包含块或另一个浮动的边缘才会停止，所以当前浮动元素会一直浮到行内或行内块元素的前边</li>
</ul>
</li>
<li>浮动元素的下一个兄弟元素：<ul>
<li>是文档流块级元素，则由于浮动元素不占据原位置，所以块级元素会上移</li>
<li>是文档流行内或行内块元素或文字，会环绕</li>
</ul>
</li>
</ol>
</li>
<li>浮动元素只会影响当前和后面的正常文档流中的元素，不影响前面</li>
</ol>
<h3 id="2-块状化元素"><a href="#2-块状化元素" class="headerlink" title="2 块状化元素"></a>2 块状化元素</h3><ul>
<li>浮动会将元素的 <code>display</code> 值改为 <code>block</code>，但是其表现如同行内块 <code>inline-block</code> 元素，不同之处在于行内块元素与其它元素之间默认有空隙，浮动元素紧挨着其它元素</li>
</ul>
<h2 id="2-3-float（浮动）"><a href="#2-3-float（浮动）" class="headerlink" title="2.3 float（浮动）"></a>2.3 float（浮动）</h2><table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code>（默认）</td>
<td>无浮动</td>
</tr>
<tr>
<td><code>left</code></td>
<td>左浮动</td>
</tr>
<tr>
<td><code>right</code></td>
<td>右浮动</td>
</tr>
</tbody></table>
<h2 id="2-4-clear（清除浮动）"><a href="#2-4-clear（清除浮动）" class="headerlink" title="2.4 clear（清除浮动）"></a>2.4 clear（清除浮动）</h2><h3 id="1-为何要清除浮动"><a href="#1-为何要清除浮动" class="headerlink" title="1 为何要清除浮动"></a>1 为何要清除浮动</h3><ol>
<li>由于浮动元素会影响后边正常文档流中的元素，所以通常会把浮动元素放在一个处于正常文档流的父元素中</li>
<li>父元素通常不会固定高度，而是根据子元素高度来撑开高度，而浮动元素脱离文档流，不占据文档流的位置，就会导致父元素高度塌陷</li>
<li>清除浮动就是为了解决父级元素因为子级浮动引起内部高度为 0 的问题</li>
</ol>
<h3 id="2-clear-取值"><a href="#2-clear-取值" class="headerlink" title="2 clear 取值"></a>2 clear 取值</h3><table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code>（默认）</td>
<td>允许浮动元素出现在两侧。</td>
</tr>
<tr>
<td><code>left</code></td>
<td>在左侧不允许浮动元素。</td>
</tr>
<tr>
<td><code>right</code></td>
<td>在右侧不允许浮动元素。</td>
</tr>
<tr>
<td><code>both</code></td>
<td>在左右两侧均不允许浮动元素。</td>
</tr>
</tbody></table>
<ol>
<li><strong>CSS 的清除浮动只能影响清除浮动的元素本身，无法影响其它元素</strong></li>
<li><strong><code>clear</code> 属性只对块级元素有效</strong></li>
</ol>
<h3 id="3-清除浮动的方式"><a href="#3-清除浮动的方式" class="headerlink" title="3 清除浮动的方式"></a>3 清除浮动的方式</h3><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>父元素显式定义高度 height</code></td>
<td>不推荐，只适合高度固定时使用</td>
</tr>
<tr>
<td><code>父元素末尾添加一个空标签 clear 清除浮动</code></td>
<td>不推荐，增加不必要的标签</td>
</tr>
<tr>
<td><code>父元素创建伪元素 clear 清除浮动</code></td>
<td>推荐</td>
</tr>
<tr>
<td><code>父元素 overflow: hidden</code></td>
<td>父元素触发 BFC</td>
</tr>
</tbody></table>
<h4 id="1-父元素创建伪元素的方式"><a href="#1-父元素创建伪元素的方式" class="headerlink" title="1 父元素创建伪元素的方式"></a>1 父元素创建伪元素的方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 父元素添加 class=&quot;.clearfix&quot;</span><br><span class="line">.clearfix::after &#123;</span><br><span class="line">	content: &apos;&apos;;</span><br><span class="line">	display: block; // clear 只对块级元素有效，伪元素默认为内联元素</span><br><span class="line">	height: 0;</span><br><span class="line">	clear: both;</span><br><span class="line">	visibility: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-BFC（Block-Formatting-Context）"><a href="#2-BFC（Block-Formatting-Context）" class="headerlink" title="2 BFC（Block Formatting Context）"></a>2 BFC（Block Formatting Context）</h4><h5 id="1-BFC-概念"><a href="#1-BFC-概念" class="headerlink" title="1 BFC 概念"></a>1 BFC 概念</h5><table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>FC（formattion context）</code></td>
<td>格式化上下文，就是正常文档流</td>
</tr>
<tr>
<td><code>BFC（Block Formatting Context）</code></td>
<td>块级格式化上下文</td>
</tr>
<tr>
<td><code>IFC（inline formattion context）</code></td>
<td>行内格式化上下文</td>
</tr>
<tr>
<td><code>GFC（grid formattion context）</code></td>
<td>栅格格式化上下文</td>
</tr>
</tbody></table>
<ol>
<li>块级格式化上下文，是 css 布局的一个概念，是一块区域，一个环境</li>
</ol>
<h5 id="2-BFC-触发条件"><a href="#2-BFC-触发条件" class="headerlink" title="2 BFC 触发条件"></a>2 BFC 触发条件</h5><table>
<thead>
<tr>
<th>元素</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>根元素</td>
<td><code>&lt;html&gt;</code></td>
</tr>
<tr>
<td>浮动元素</td>
<td><code>float: left / right</code></td>
</tr>
<tr>
<td>绝对定位元素</td>
<td><code>position: absolute / fixed</code></td>
</tr>
<tr>
<td><code>overflow</code> 不为 <code>visible</code></td>
<td><code>overflow: hidden / auto / scroll</code></td>
</tr>
<tr>
<td><code>display</code></td>
<td><code>display: inline-block / table-cell / table-caption / flex / inline-flex</code></td>
</tr>
</tbody></table>
<h5 id="3-BFC-布局规则"><a href="#3-BFC-布局规则" class="headerlink" title="3 BFC 布局规则"></a>3 BFC 布局规则</h5><ol>
<li>计算 BFC 的高度时，浮动元素也参与计算（用来清除浮动影响）</li>
<li>BFC 会形成一个隔离的独立容器，容器中的子元素不会影响到外面的元素；外面的元素也不会影响到容器中的子元素</li>
<li>BFC 中每个子元素的 <code>margin-box</code> 的左边会接触 BFC容器的左边，无论子元素是否浮动</li>
<li>BFC 的区域不会与 <code>float box</code> 重叠</li>
</ol>
<h5 id="4-BFC-应用"><a href="#4-BFC-应用" class="headerlink" title="4 BFC 应用"></a>4 BFC 应用</h5><h6 id="1-清除浮动"><a href="#1-清除浮动" class="headerlink" title="1 清除浮动"></a>1 清除浮动</h6><ul>
<li>由于 BFC 容器计算高度会计算浮动元素，所以只需父元素触发 BFC 即可清除浮动</li>
</ul>
<h6 id="2-两栏自适应布局"><a href="#2-两栏自适应布局" class="headerlink" title="2 两栏自适应布局"></a>2 两栏自适应布局</h6><ol>
<li>左边元素浮动，右边元素触发 BFC即可，因为 BFC 的区域不会与 <code>float box</code> 重叠，如图文两栏布局</li>
<li>图文排列时，图片浮动，就形成文字环绕</li>
<li>如果想让图片在左，文字在右的两列布局，只需文字容器触发 BFC 即可</li>
</ol>
<h6 id="3-解决相邻元素-margin-合并"><a href="#3-解决相邻元素-margin-合并" class="headerlink" title="3 解决相邻元素 margin 合并"></a>3 解决相邻元素 margin 合并</h6><ul>
<li>由于 BFC 与外界元素不会相互影响，所以只需相邻元素不在同一个 BFC 容器中即可</li>
</ul>
<h1 id="三-定位"><a href="#三-定位" class="headerlink" title="三 定位"></a>三 定位</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol>
<li><code>定位 = 定位模式 + 边偏移</code></li>
<li>绝对定位会块级化元素，表现如同行内块：包裹性和自适应性</li>
</ol>
<h2 id="3-2-边偏移"><a href="#3-2-边偏移" class="headerlink" title="3.2 边偏移"></a>3.2 边偏移</h2><table>
<thead>
<tr>
<th>方位属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>top</code></td>
<td>顶部偏移量（CSS 中 X 轴向右为正，Y 轴向下为正）</td>
</tr>
<tr>
<td><code>bottom</code></td>
<td>底部偏移量</td>
</tr>
<tr>
<td><code>left</code></td>
<td>左侧部偏移量</td>
</tr>
<tr>
<td><code>right</code></td>
<td>右侧部偏移量</td>
</tr>
</tbody></table>
<h2 id="3-3-position"><a href="#3-3-position" class="headerlink" title="3.3 position"></a>3.3 position</h2><table>
<thead>
<tr>
<th>取值</th>
<th>名称</th>
<th>基点</th>
<th>特点</th>
<th>元素块级化（行内块）</th>
</tr>
</thead>
<tbody><tr>
<td><code>static</code>（默认）</td>
<td>静态定位，无定位</td>
<td>正常标准流</td>
<td>没有边偏移</td>
<td>×</td>
</tr>
<tr>
<td><code>relative</code></td>
<td>相对定位</td>
<td>相对于元素原来在标准流中的位置定位</td>
<td>占据标准流位置</td>
<td>×</td>
</tr>
<tr>
<td><code>absolute</code></td>
<td>绝对定位</td>
<td>1. 相对于离元素最近的带定位的祖先元素定位<br>2. 若没有，则相对于 <code>&lt;html&gt;</code> 定位</td>
<td>不占据标准流位置，会随着滚动条滚动</td>
<td>√</td>
</tr>
<tr>
<td><code>fixed</code></td>
<td>固定定位（绝对定位的一种特殊形式）</td>
<td>相对于浏览器可视窗口定位</td>
<td>不占据标准流位置，不会随着滚动条滚动</td>
<td>√</td>
</tr>
<tr>
<td><code>sticky</code></td>
<td>粘性定位</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="1-static"><a href="#1-static" class="headerlink" title="1 static"></a>1 static</h3><ol>
<li>元素在正常的流中，按照标准流特性摆放位置</li>
<li>没有边偏移，即忽略 <code>top, bottom, left, right, z-index</code></li>
</ol>
<h3 id="2-sticky"><a href="#2-sticky" class="headerlink" title="2 sticky"></a>2 sticky</h3><ol>
<li>sticky会产生动态效果，很像relative和fixed的结合：一些时候是relative定位（定位基点是自身默认位置），另一些时候自动变成fixed定位（定位基点是视口）</li>
<li>sticky生效的前提是，必须搭配top、bottom、left、right这四个属性中的一个或多个一起使用（看滚动方向），不能省略，否则等同于relative定位，不产生”动态固定”的效果</li>
<li>不能有任何祖先元素设置overflow:hidden，否则没有粘滞效果。因为改变了滚动容器（即使没有出现滚动条）</li>
<li>父元素的高度不能低于sticky元素的高度</li>
<li>sticky元素仅在其父元素内生效，不会超出父元素，滚动时会随着父元素一起消失</li>
<li>当页面滚动，父元素开始脱离视口时（即部分不可见），只要与sticky元素的距离达到生效门槛（设置的top/bottom/left/right），relative定位自动切换为fixed定位，等到父元素完全脱离视口时，fixed定位恢复成relative定位</li>
<li>同一个父容器中的sticky元素，如果定位值相等，则会重叠；如果属于不同父元素，则会随着父元素不再完整占据sticky元素的固定区域以后，再由其他父元素的sticky子元素占据固定位置</li>
<li>我的理解就是设置了粘性定位的元素，没到达所设置的偏移量时，为相对定位，到达后就变为固定定位，但只局限在父元素在视口内，如果父元素都滚走了，也会一同滚走（当然此时为相对定位）</li>
</ol>
<h2 id="3-4-绝对定位元素居中的两种方式"><a href="#3-4-绝对定位元素居中的两种方式" class="headerlink" title="3.4 绝对定位元素居中的两种方式"></a>3.4 绝对定位元素居中的两种方式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1 </span><br><span class="line">position: absolute;</span><br><span class="line">// 1.1 首先向右向下移动父元素宽高的一半</span><br><span class="line">left: 50%; top: 50%;</span><br><span class="line">// 1.2 由于参照点是子元素的左上角，所以要向左向上分别移动子元素宽高的一半（margin或者transform:translate）</span><br><span class="line">margin-left: -50%; margin-top: -50%;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 2</span><br><span class="line">position: absolute;</span><br><span class="line">// 2.1 使水平和垂直方向具有填充特性</span><br><span class="line">left: 0; right: 0; top:0; bottom:0;</span><br><span class="line">// 2.2 margin:auto 触发计算，自动平分</span><br><span class="line">margin: auto;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>CSS盒子模型</title>
    <url>/anyeansan.github.io/2020/11/08/UI/CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="一-组成"><a href="#一-组成" class="headerlink" title="一 组成"></a>一 组成</h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/CSS/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.png" alt=""></p>
<table>
<thead>
<tr>
<th>组成</th>
<th>盒子名称</th>
</tr>
</thead>
<tbody><tr>
<td><code>content</code></td>
<td><code>content-box</code></td>
</tr>
<tr>
<td><code>padding</code></td>
<td><code>padding-box</code></td>
</tr>
<tr>
<td><code>border</code></td>
<td><code>border-box</code></td>
</tr>
<tr>
<td><code>margin</code></td>
<td>没有名称</td>
</tr>
</tbody></table>
<h1 id="二-content-box"><a href="#二-content-box" class="headerlink" title="二 content box"></a>二 content box</h1><h2 id="2-1-content"><a href="#2-1-content" class="headerlink" title="2.1 content"></a>2.1 content</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ul>
<li>content 属性插入的内容都是匿名替换元素，替换元素都是内联元素</li>
<li>content 属性通常用在<code>::before / ::after</code> 这两个伪元素中</li>
<li>content 属性生成的内容特点<ol>
<li>无法选中、无法复制的</li>
<li>content 无法影响<code>:empty</code> 选择器（即有content还是适配<code>:empty</code>）</li>
<li>content 动态生成值无法获取，如计数器</li>
</ol>
</li>
</ul>
<h3 id="2-取值"><a href="#2-取值" class="headerlink" title="2 取值"></a>2 取值</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code></td>
<td>不会产生伪元素</td>
</tr>
<tr>
<td><code>normal</code></td>
<td><code>::before</code> 和 <code>::after</code> 中会被当作none</td>
</tr>
<tr>
<td><code>&lt;string&gt;</code></td>
<td>字符串</td>
</tr>
<tr>
<td><code>&lt;url&gt;</code></td>
<td>图片可以是png、jpg、ico、svg文件以及 base64URL，但不支持 CSS3 渐变背景图</td>
</tr>
<tr>
<td><code>attr()</code></td>
<td>获取原生 html 属性或者自定义属性的值，属性不要加引号</td>
</tr>
<tr>
<td><code>&lt;counter&gt;</code></td>
<td>计数器</td>
</tr>
<tr>
<td><code>open-quote / close-quote</code></td>
<td>开闭引号</td>
</tr>
<tr>
<td><code>no-open-quote / no-close-quote</code></td>
<td>不要开闭引号</td>
</tr>
</tbody></table>
<h3 id="3-应用"><a href="#3-应用" class="headerlink" title="3 应用"></a>3 应用</h3><h4 id="1-content-辅助元素生成"><a href="#1-content-辅助元素生成" class="headerlink" title="1 content 辅助元素生成"></a>1 content 辅助元素生成</h4><ul>
<li>核心点不在于 content 生成的内容，而是伪元素本身，如 最常用的清除浮动，clear只能用在块级元素上，所以要改变display</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.clear::after &#123;</span><br><span class="line">	content: &apos;&apos;;</span><br><span class="line">	display: block; </span><br><span class="line">	clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-计数器"><a href="#2-计数器" class="headerlink" title="2 计数器"></a>2 计数器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1 定义计数器</span><br><span class="line">conter-reset: 计数器名 初始值（默认 0）</span><br><span class="line">// 2 定义计数器递增规则</span><br><span class="line">counter-increment: 计数器名 递增值（默认 1）</span><br><span class="line">// 3 使用计数器</span><br><span class="line">counter(counterName, style)</span><br><span class="line">	style：即 list-style-type 支持的值，默认是数字</span><br><span class="line">	显示结果：1 2 3 ...</span><br><span class="line">counters(counterName, string, style)</span><br><span class="line">	string：指定序号和子序号之间的符号</span><br><span class="line">	显示结果：1.1 1.2 2.1 ...</span><br></pre></td></tr></table></figure>

<h2 id="2-2-width"><a href="#2-2-width" class="headerlink" title="2.2 width"></a>2.2 width</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code>（默认）</td>
<td>浏览器将会为指定的元素计算并选择一个宽度.</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>指定值</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>指定为包含块宽度的百分比</td>
</tr>
<tr>
<td><code>fill-available</code></td>
<td>元素宽度自动填满可用空间</td>
</tr>
<tr>
<td><code>fit-content</code></td>
<td>元素宽度包裹内容，文本内容正常换行。如浮动、绝对定位、inline-block 元素或 table 元素</td>
</tr>
<tr>
<td><code>min-content</code></td>
<td>元素宽度为内部元素”首选最小宽度”最大的那一行的宽度</td>
</tr>
<tr>
<td><code>max-content</code></td>
<td>元素宽度为内部元素宽度值最大的那个元素的宽度</td>
</tr>
</tbody></table>
<h3 id="1-min-content-首选最小宽度"><a href="#1-min-content-首选最小宽度" class="headerlink" title="1 min-content 首选最小宽度"></a>1 min-content 首选最小宽度</h3><ul>
<li>指的是元素最适合的最小宽度</li>
<li>类似图片这样的替换元素的最小宽度就是该元素内容本身的宽度</li>
<li>文本<ul>
<li>CJK（中日韩）可以任意断行，最小宽度就是每个字符的宽度</li>
<li>non-CJK一般在空格、短横线、问号以及其他非英文字符等断行，最小宽度由连续的英文字符单元决定</li>
</ul>
</li>
</ul>
<h3 id="2-fit-content-和-max-content-区别"><a href="#2-fit-content-和-max-content-区别" class="headerlink" title="2 fit-content 和 max-content 区别"></a>2 fit-content 和 max-content 区别</h3><ul>
<li>两者的元素宽度其实都是内部元素最大的那个宽度</li>
<li>区别在于fit-content内部元素文字可以正常换行，而max-content内部元素文字不换行</li>
</ul>
<h3 id="3-CSS-流体布局下的宽度分离原则"><a href="#3-CSS-流体布局下的宽度分离原则" class="headerlink" title="3 CSS 流体布局下的宽度分离原则"></a>3 CSS 流体布局下的宽度分离原则</h3><ul>
<li>宽度分离原则即CSS 中的 width 属性不与影响宽度的 padding/border（有时候包括 margin）属性共存</li>
<li>应该width 独立占用一层标签，而padding、border、margin 利用流动性在内部自适应呈现</li>
</ul>
<h2 id="2-3-height"><a href="#2-3-height" class="headerlink" title="2.3 height"></a>2.3 height</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code>（默认）</td>
<td>浏览器将会为指定的元素计算并选择一个高度.</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>指定值</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>指定为包含块高度的百分比</td>
</tr>
<tr>
<td><code>fill-available</code></td>
<td>充分利用可用空间</td>
</tr>
<tr>
<td><code>fit-content</code></td>
<td>收缩到包裹内容</td>
</tr>
<tr>
<td><code>min-content</code></td>
<td>收缩到最小</td>
</tr>
<tr>
<td><code>max-content</code></td>
<td>最大内容高度</td>
</tr>
</tbody></table>
<h2 id="2-4-min-width-max-width-和-min-height-max-height"><a href="#2-4-min-width-max-width-和-min-height-max-height" class="headerlink" title="2.4 min-width / max-width 和 min-height / max-height"></a>2.4 min-width / max-width 和 min-height / max-height</h2><h4 id="1-与众不同的初始值"><a href="#1-与众不同的初始值" class="headerlink" title="1 与众不同的初始值"></a>1 与众不同的初始值</h4><ul>
<li>width / height 的默认值是 auto</li>
<li>min-width / min-height 的默认值是auto（w3c/mdn上是0）</li>
<li>max-width / max-height的默认值是none</li>
</ul>
<h4 id="2-权重（width-height-规则相同）"><a href="#2-权重（width-height-规则相同）" class="headerlink" title="2 权重（width / height 规则相同）"></a>2 权重（width / height 规则相同）</h4><ol>
<li>width，min-width，max-width只有其中一个，则最终宽度为其值</li>
<li>有width 和 max-width，则最终宽度不能大于max-width<ul>
<li><code>width &lt; max-width</code> 时，最终宽度为width的值</li>
<li><code>width &gt; max-widht</code> 时，最终宽度为max-width的值</li>
</ul>
</li>
</ol>
<ul>
<li>有width 和 min-width，则最终宽度不能小于min-width<ul>
<li><code>width &gt; min-width</code> 时，最终宽度为width的值</li>
<li><code>width &lt; min-widht</code> 时，最终宽度为min-width的值</li>
</ul>
</li>
<li>有min-width和max-width，则最终宽度为二者中较大的那个值<ul>
<li><code>min-width &lt; max-width</code> 时，则最终宽度为max-width的值</li>
<li><code>min-width &gt; max-width</code> 时，则最终宽度为min-width的值</li>
</ul>
</li>
<li>有width，min-width，max-width<ul>
<li><code>min-width &gt; max-width</code>，无论width值如何，最终宽度都是min-width的值</li>
<li><code>min-width &lt; max-width</code>，根据width取值，最终宽度在最小和最大宽度之间<ul>
<li><code>width &lt; min-width &lt; max-width</code>，则最终宽度为min-width的值</li>
<li><code>min-width &lt; width &lt; max-width</code>，则最终宽度为width的值</li>
<li><code>min-width &lt; max-width &lt; width</code>，则最终宽度为max-width的值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="三-padding-box"><a href="#三-padding-box" class="headerlink" title="三 padding box"></a>三 padding box</h1><h2 id="3-1-padding"><a href="#3-1-padding" class="headerlink" title="3.1 padding"></a>3.1 padding</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><table>
<thead>
<tr>
<th>块级元素</th>
<th>替换内联元素</th>
<th>非替换内联元素</th>
</tr>
</thead>
<tbody><tr>
<td>有影响</td>
<td>有影响</td>
<td>水平方向有影响，垂直方向不改变元素高度，但是改变背景高度</td>
</tr>
</tbody></table>
<ul>
<li>如果不指定 <code>width 或 height</code>，<code>padding</code> 不会撑开对应方向的盒子</li>
</ul>
<h3 id="2-取值-1"><a href="#2-取值-1" class="headerlink" title="2 取值"></a>2 取值</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;length&gt;</code></td>
<td>指定值</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>相对于宽度的百分比</td>
</tr>
</tbody></table>
<h3 id="3-设置值规则"><a href="#3-设置值规则" class="headerlink" title="3 设置值规则"></a>3 设置值规则</h3><table>
<thead>
<tr>
<th>值数量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>一个值</td>
<td>同时设置四个边内边距</td>
</tr>
<tr>
<td>二个值</td>
<td><code>上下</code>，<code>左右</code></td>
</tr>
<tr>
<td>三个值</td>
<td><code>上</code>，<code>左右</code>，<code>下</code></td>
</tr>
<tr>
<td>四个值</td>
<td><code>上</code>，<code>右</code>，<code>下</code>，<code>左</code></td>
</tr>
</tbody></table>
<h2 id="3-2-四个边单独的-padding-属性"><a href="#3-2-四个边单独的-padding-属性" class="headerlink" title="3.2 四个边单独的 padding 属性"></a>3.2 四个边单独的 padding 属性</h2><ol>
<li><code>padding-top</code></li>
<li><code>padding-right</code></li>
<li><code>padding-bottom</code></li>
<li><code>padding-left</code></li>
</ol>
<h1 id="四-border-box"><a href="#四-border-box" class="headerlink" title="四 border box"></a>四 border box</h1><h2 id="4-1-border"><a href="#4-1-border" class="headerlink" title="4.1 border"></a>4.1 border</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boder-color ||</span><br><span class="line">boder-style ||</span><br><span class="line">border-width</span><br></pre></td></tr></table></figure>

<h3 id="1-border-width"><a href="#1-border-width" class="headerlink" title="1 border-width"></a>1 border-width</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;legnth&gt;</code></td>
<td>指定值</td>
</tr>
<tr>
<td><code>thin</code></td>
<td>薄，等同于 <code>1px</code></td>
</tr>
<tr>
<td><code>medium</code>（默认）</td>
<td>薄厚均匀，等同于 <code>3px</code></td>
</tr>
<tr>
<td><code>thick</code></td>
<td>厚，等同于 <code>4px</code></td>
</tr>
</tbody></table>
<h3 id="2-border-style"><a href="#2-border-style" class="headerlink" title="2 border-style"></a>2 border-style</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code>（默认）</td>
<td>不显示边框，none 值优先级最低，如果存在其他的重叠边框，则会显示为那个边框</td>
</tr>
<tr>
<td><code>hidden</code></td>
<td>不显示边框，hidden 值优先级最高，如果存在其他的重叠边框，边框也不会显示。</td>
</tr>
<tr>
<td><code>solid</code></td>
<td>单实线</td>
</tr>
<tr>
<td><code>double</code></td>
<td>双实线，边框宽最少3px才有效果</td>
</tr>
<tr>
<td><code>dotted</code></td>
<td>点画线</td>
</tr>
<tr>
<td><code>dashed</code></td>
<td>虚线</td>
</tr>
<tr>
<td><code>groove</code></td>
<td>雕刻效果，与 <code>ridge</code> 相反</td>
</tr>
<tr>
<td><code>ridge</code></td>
<td>浮雕效果，与 <code>groove</code> 相反</td>
</tr>
<tr>
<td><code>inset</code></td>
<td>陷入效果</td>
</tr>
<tr>
<td><code>outset</code></td>
<td>突出效果</td>
</tr>
</tbody></table>
<h3 id="3-border-color"><a href="#3-border-color" class="headerlink" title="3 border-color"></a>3 border-color</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>currentColor</code>（默认）</td>
<td>默认为字体颜色</td>
</tr>
<tr>
<td><code>&lt;color&gt;</code></td>
<td>颜色值</td>
</tr>
</tbody></table>
<h2 id="4-2-四个边单独的-border-属性"><a href="#4-2-四个边单独的-border-属性" class="headerlink" title="4.2 四个边单独的 border 属性"></a>4.2 四个边单独的 border 属性</h2><ol>
<li><code>border-top</code><ul>
<li><code>border-top-color</code></li>
<li><code>border-top-style</code></li>
<li><code>border-top-width</code></li>
</ul>
</li>
<li><code>border-right</code><ul>
<li><code>border-right-color</code></li>
<li><code>border-right-style</code></li>
<li><code>border-right-width</code></li>
</ul>
</li>
<li><code>border-bottom</code><ul>
<li><code>border-bottom-color</code></li>
<li><code>border-bottom-style</code></li>
<li><code>border-bottom-width</code></li>
</ul>
</li>
<li><code>border-left</code><ul>
<li><code>border-left-color</code></li>
<li><code>border-left-style</code></li>
<li><code>border-left-width</code></li>
</ul>
</li>
</ol>
<h2 id="4-3-border-radius（圆角）"><a href="#4-3-border-radius（圆角）" class="headerlink" title="4.3 border-radius（圆角）"></a>4.3 border-radius（圆角）</h2><h3 id="1-取值"><a href="#1-取值" class="headerlink" title="1 取值"></a>1 取值</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;percentage&gt;</code></td>
<td>相对于 <code>border box</code> 的百分比</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>长度</td>
</tr>
</tbody></table>
<h3 id="2-设置值语法"><a href="#2-设置值语法" class="headerlink" title="2 设置值语法"></a>2 设置值语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一组值（水平半径）/ 第二组值（垂直半径） # 垂直省略表示同水平一致</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>每组值的数量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>一个值</td>
<td><code>四个角</code></td>
</tr>
<tr>
<td>二个值</td>
<td><code>左上角右下角</code>，<code>右上角左下角</code></td>
</tr>
<tr>
<td>三个值</td>
<td><code>左上角</code>，<code>右上角左下角</code>，<code>右下角</code></td>
</tr>
<tr>
<td>四个值</td>
<td><code>左上角</code>，<code>右上角</code>，<code>右下角</code>，<code>左下角</code></td>
</tr>
</tbody></table>
<h3 id="3-每个角单独设置"><a href="#3-每个角单独设置" class="headerlink" title="3 每个角单独设置"></a>3 每个角单独设置</h3><ul>
<li><code>border-垂直-水平-radius: 水平半径 垂直半径（可省略）</code><ul>
<li><code>border-top-left-radius</code></li>
<li><code>border-top-right-radius</code></li>
<li><code>border-bottom-right-radius</code></li>
<li><code>border-bottom-left-radius</code></li>
</ul>
</li>
</ul>
<h3 id="4-最大尺寸-amp-等比缩放"><a href="#4-最大尺寸-amp-等比缩放" class="headerlink" title="4 最大尺寸 &amp; 等比缩放"></a>4 最大尺寸 &amp; 等比缩放</h3><ul>
<li>图形尺寸是有限的，所以圆角半径设置过大时，也只会按照最大尺寸来算，且值会根据设置时的比例变化</li>
<li>例如<ul>
<li>border box 宽200px，高300px，此时设置 <code>border-radius: 300px;</code></li>
<li>水平半径最大只能到200px，所以按200px算，垂直半径虽然能到300px，但是设置时<code>300:300</code>水平与垂直比例是<code>1:1</code>，垂直半径也要跟着变化，结果水平和垂直半径都是200px</li>
</ul>
</li>
</ul>
<h1 id="五-margin-box"><a href="#五-margin-box" class="headerlink" title="五 margin box"></a>五 margin box</h1><h2 id="5-1-margin"><a href="#5-1-margin" class="headerlink" title="5.1 margin"></a>5.1 margin</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h3><ul>
<li>margin 对块级元素有影响，且垂直方向有 margin 合并</li>
<li>margin 对替换内联元素有影响，且垂直方向无 margin 合并</li>
<li>margin 对非替换内联元素水平方向有影响，垂直方向无影响</li>
</ul>
<h3 id="2-取值-2"><a href="#2-取值-2" class="headerlink" title="2 取值"></a>2 取值</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code></td>
<td>浏览器会自动选择一个合适的margin来应用</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>指定值</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>相对于宽度的百分比</td>
</tr>
</tbody></table>
<h3 id="3-设置值规则-1"><a href="#3-设置值规则-1" class="headerlink" title="3 设置值规则"></a>3 设置值规则</h3><table>
<thead>
<tr>
<th>值数量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>一个值</td>
<td>同时设置四个边外边距</td>
</tr>
<tr>
<td>二个值</td>
<td><code>上下</code>，<code>左右</code></td>
</tr>
<tr>
<td>三个值</td>
<td><code>上</code>，<code>左右</code>，<code>下</code></td>
</tr>
<tr>
<td>四个值</td>
<td><code>上</code>，<code>右</code>，<code>下</code>，<code>左</code></td>
</tr>
</tbody></table>
<h3 id="4-margin-atuo"><a href="#4-margin-atuo" class="headerlink" title="4 margin: atuo"></a>4 margin: atuo</h3><h4 id="1-计算规则"><a href="#1-计算规则" class="headerlink" title="1 计算规则"></a>1 计算规则</h4><ol>
<li>如果一侧定值，一侧 <code>auto</code>，则 <code>auto</code> 为剩余空间大小。</li>
<li>如果两侧均是 <code>auto</code>，则平分剩余空间</li>
</ol>
<h4 id="2-触发计算前提条件"><a href="#2-触发计算前提条件" class="headerlink" title="2 触发计算前提条件"></a>2 触发计算前提条件</h4><ol>
<li><code>width</code> 或 <code>height</code> 为 <code>auto</code> 时，元素是具有对应方向的自动填充特性</li>
<li>自动填充特性<ol>
<li>块级元素 <code>width</code> 为 <code>auto</code> 时，水平方向会自动填充</li>
<li>绝对定位元素<ol>
<li>如果设置 <code>left</code> 和 <code>right</code> 为 0，则水平方向填充特性</li>
<li>如果设置 <code>top</code> 和 <code>bottom</code> 为 0，则垂直方向有填充特性</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="5-margin-合并"><a href="#5-margin-合并" class="headerlink" title="5 margin 合并"></a>5 margin 合并</h3><h4 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>块级元素的上外边距（margin-top）与下外边距（margin-bottom）有时会合并为单个外边距</li>
<li>不包括浮动和绝对定位元素，尽管浮动和绝对定位可以让元素块状化</li>
</ol>
<h4 id="2-场景"><a href="#2-场景" class="headerlink" title="2 场景"></a>2 场景</h4><ol>
<li>相邻兄弟元素 margin 合并</li>
<li>父级和第一个/最后一个子元素 margin 合并（子元素的 margin 表现得如同作用在父元素上）<ul>
<li>解决margin-top 合并<ol>
<li>父元素设置为块状格式化上下文元素</li>
<li>父元素设置 border-top 值</li>
<li>父元素设置 padding-top 值</li>
<li>父元素和第一个子元素之间添加内联元素进行分隔</li>
</ol>
</li>
<li>解决margin-bottom 合并<ol>
<li>父元素设置为块状格式化上下文元素</li>
<li>父元素设置 border-bottom 值</li>
<li>父元素设置 padding-bottom 值</li>
<li>父元素和最后一个子元素之间添加内联元素进行分隔</li>
<li>父元素设置 height、min-height 或 max-height</li>
</ol>
</li>
</ul>
</li>
<li>空块级元素的 margin 合并<ul>
<li>解决<ol>
<li>设置垂直方向的 border；</li>
<li>设置垂直方向的 padding；</li>
<li>里面添加内联元素（直接 Space 键空格是没用的）；</li>
<li>设置 height 或者 min-height。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="3-计算规则"><a href="#3-计算规则" class="headerlink" title="3 计算规则"></a>3 计算规则</h4><ol>
<li>如果合并外边距皆为正，取最大值</li>
<li>如果合并外边距皆为负，取最小值（即绝对值最大值）</li>
<li>如果合并外边距有正有负，取最大正外边距与最小负外边距之和</li>
</ol>
<h4 id="4-margin-无效的场景"><a href="#4-margin-无效的场景" class="headerlink" title="4 margin 无效的场景"></a>4 margin 无效的场景</h4><ol>
<li>非替换内联元素的垂直方向</li>
<li><code>&lt;tr&gt;&lt;td&gt;</code>标签或者 display为 <code>table-row table-cell</code> 的元素</li>
<li>绝对定位元素非定位方位的 margin 值表面“无效”</li>
</ol>
<h2 id="5-2-四个边单独的-margin-属性"><a href="#5-2-四个边单独的-margin-属性" class="headerlink" title="5.2 四个边单独的 margin 属性"></a>5.2 四个边单独的 margin 属性</h2><ol>
<li><code>margin-top</code></li>
<li><code>margin-right</code></li>
<li><code>margin-bottom</code></li>
<li><code>margin-left</code></li>
</ol>
<h2 id="5-3-应用"><a href="#5-3-应用" class="headerlink" title="5.3 应用"></a>5.3 应用</h2><ol>
<li>块级盒子水平居中<ul>
<li>盒子指定了宽度 <code>width</code></li>
<li>盒子左右外边距都为 <code>auto</code></li>
</ul>
</li>
<li>行内或行内块水平居中，只需父盒子设置 <code>text-align: center</code></li>
</ol>
<h1 id="六-box-sizing"><a href="#六-box-sizing" class="headerlink" title="六 box-sizing"></a>六 box-sizing</h1><ul>
<li>改变盒子模型</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>content-box</code>（默认）</td>
<td>盒子模型为 内容盒子</td>
</tr>
<tr>
<td><code>border-box</code></td>
<td>盒子模型为 边框盒子</td>
</tr>
</tbody></table>
<h1 id="七-box-shadow"><a href="#七-box-shadow" class="headerlink" title="七 box-shadow"></a>七 box-shadow</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ </span><br><span class="line">	inset? </span><br><span class="line">	[&lt;offset-x&gt; &lt;offset-y&gt;] </span><br><span class="line">	&lt;blur-radius&gt;? </span><br><span class="line">	&lt;spred-radius&gt;? </span><br><span class="line">	&lt;color&gt;? </span><br><span class="line">]#</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>inset?</code></td>
<td>默认阴影向外扩散 <code>outset</code>，<code>inset</code> 设置为向内扩散</td>
</tr>
<tr>
<td><code>[&lt;offset-x&gt; &lt;offset-y&gt;]</code></td>
<td>阴影 X 轴和 Y 轴的偏移量（必须），<code>&lt;length&gt;</code></td>
</tr>
<tr>
<td><code>&lt;blur-radius&gt;?</code></td>
<td>模糊半径，即阴影的虚实程度，<code>&lt;length&gt;</code></td>
</tr>
<tr>
<td><code>&lt;spred-radius&gt;?</code></td>
<td>阴影扩散半径，默认为0，取正值时，阴影扩大；取负值时，阴影收缩</td>
</tr>
<tr>
<td><code>&lt;color&gt;?</code></td>
<td>阴影颜色</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>CSS内联盒模型</title>
    <url>/anyeansan.github.io/2020/11/08/UI/CSS%E5%86%85%E8%81%94%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="一-内联盒模型组成"><a href="#一-内联盒模型组成" class="headerlink" title="一 内联盒模型组成"></a>一 内联盒模型组成</h1><h2 id="1-1-内容区域-content-area"><a href="#1-1-内容区域-content-area" class="headerlink" title="1.1 内容区域 content area"></a>1.1 内容区域 <code>content area</code></h2><ol>
<li>文字内容区域可以理解为选中文字时的区域<ol>
<li><code>content area</code> 高度由 <code>font-size</code> 和 <code>font-family</code> 决定</li>
<li><code>font-family</code> 为 <code>simsun(宋体)</code> 时，<code>content area = font-size</code></li>
</ol>
</li>
<li>图片这样的替换元素，内容区域可以看成元素自身</li>
</ol>
<h2 id="1-2-内联盒子-inline-box"><a href="#1-2-内联盒子-inline-box" class="headerlink" title="1.2 内联盒子 inline box"></a>1.2 内联盒子 <code>inline box</code></h2><ol>
<li>内联盒子：内联元素都有一个内联盒子</li>
<li>匿名内联盒子：纯文本<ul>
<li>注意：并不是所有光秃秃的文字都是“匿名内联盒子”，关键要看前后的标签是内联还是块级</li>
</ul>
</li>
</ol>
<h2 id="1-3-行框盒子-line-box"><a href="#1-3-行框盒子-line-box" class="headerlink" title="1.3 行框盒子 line box"></a>1.3 行框盒子 <code>line box</code></h2><ol>
<li>由连续的“内联盒子”组成的一行就是行框盒子<ol>
<li><code>inline</code> 内联元素形成行框盒子的是内部的文字，如果内部为空，就形不成行框盒子</li>
<li><code>inline-block</code> 内联元素形成行框盒子的是元素本身，内部为空也能形成行框盒子</li>
</ol>
</li>
<li>行框盒子的高度是由高度最高的那个“内联盒子”决定</li>
</ol>
<h2 id="1-4-空白幽灵节点-strut"><a href="#1-4-空白幽灵节点-strut" class="headerlink" title="1.4 空白幽灵节点 strut"></a>1.4 空白幽灵节点 <code>strut</code></h2><ol>
<li>每个 <code>line-box</code> 起始位置都有一个具有该元素的字体和行高属性的 0 宽度的内联盒，此内联盒叫做<code>strut</code>（支柱）。 </li>
<li>永远透明，无法获取，表现如同文本节点一样，也是个盒子</li>
</ol>
<h1 id="二-行高"><a href="#二-行高" class="headerlink" title="二 行高"></a>二 行高</h1><h2 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/CSS/%E5%A4%9A%E8%A1%8C.png" alt=""><br><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/CSS/%E5%8D%95%E8%A1%8C.png" alt=""></p>
<table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>x-height</code></td>
<td>小写字母 x 的高度，即基线与中线的距离，CSS 中单位为 <code>ex</code></td>
</tr>
<tr>
<td><code>content area</code></td>
<td><code>≈ font-size</code></td>
</tr>
<tr>
<td><code>line-height</code></td>
<td>行高，即两基线之间的距离，等价于 <code>font-size + 行间距</code></td>
</tr>
</tbody></table>
<ul>
<li>基线<ol>
<li>文本内联元素的基线就是小写 <code>x</code> 的下边缘</li>
<li>类似图片这样的元素的基线就是其下边缘</li>
<li><code>inline-block</code> 元素<ol>
<li>如果该元素中有内联元素，基线就是最后一行内联元素的基线</li>
<li>如果该元素内没有内联元素或者 <code>overflow</code> 不是 <code>visible</code>，其基线就是 <code>margin</code> 的底边缘</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="2-2-line-height-amp-font-size"><a href="#2-2-line-height-amp-font-size" class="headerlink" title="2.2 line-height &amp; font-size"></a>2.2 <code>line-height</code> &amp; <code>font-size</code></h2><h3 id="1-line-height-lt-font-size"><a href="#1-line-height-lt-font-size" class="headerlink" title="1 line-height &lt; font-size"></a>1 <code>line-height &lt; font-size</code></h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/CSS/%E8%A1%8C%E9%AB%98%E5%B0%8F%E4%BA%8E%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F.png" alt=""></p>
<ul>
<li>此时间距为负，会发生重叠</li>
</ul>
<h3 id="2-line-height-font-size"><a href="#2-line-height-font-size" class="headerlink" title="2 line-height = font-size"></a>2 <code>line-height = font-size</code></h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/CSS/%E8%A1%8C%E9%AB%98%E7%AD%89%E4%BA%8E%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F.png" alt=""></p>
<ul>
<li>此时间距为 0，刚好不重叠，所以最好设置 <code>line-height &gt; font-size</code></li>
</ul>
<h2 id="2-3-line-height-amp-height（包含元素的高度）"><a href="#2-3-line-height-amp-height（包含元素的高度）" class="headerlink" title="2.3 line-height &amp; height（包含元素的高度）"></a>2.3 <code>line-height</code> &amp; <code>height</code>（包含元素的高度）</h2><h3 id="1-line-height-lt-height"><a href="#1-line-height-lt-height" class="headerlink" title="1 line-height &lt; height"></a>1 <code>line-height &lt; height</code></h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/CSS/%E8%A1%8C%E9%AB%98%E5%B0%8F%E9%AB%98%E5%BA%A6.png" alt=""></p>
<ul>
<li>此时文字在包含元素中偏上的位置</li>
</ul>
<h3 id="2-line-height-height"><a href="#2-line-height-height" class="headerlink" title="2 line-height = height"></a>2 <code>line-height = height</code></h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/CSS/%E8%A1%8C%E9%AB%98%E7%AD%89%E9%AB%98%E5%BA%A6.png" alt=""></p>
<ul>
<li>此时文字在包含元素中垂直居中</li>
</ul>
<h3 id="3-line-height-gt-height"><a href="#3-line-height-gt-height" class="headerlink" title="3 line-height &gt; height"></a>3 <code>line-height &gt; height</code></h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/CSS/%E8%A1%8C%E9%AB%98%E5%A4%A7%E9%AB%98%E5%BA%A6.png" alt=""></p>
<ul>
<li>此时文字在包含元素中偏下的位置</li>
</ul>
<h2 id="2-4-line-height"><a href="#2-4-line-height" class="headerlink" title="2.4 line-height"></a>2.4 line-height</h2><table>
<thead>
<tr>
<th>元素</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>非替换内联元素</td>
<td><code>line-height</code> 决定高度</td>
</tr>
<tr>
<td>替换元素</td>
<td><code>line-height</code> 无影响</td>
</tr>
<tr>
<td>块级元素</td>
<td><code>line-height</code> 无影响</td>
</tr>
</tbody></table>
<h2 id="2-5-vertical-align"><a href="#2-5-vertical-align" class="headerlink" title="2.5 vertical-align"></a>2.5 vertical-align</h2><ol>
<li>用来指定内联元素（<code>inline inline-block inline-table</code>）或表格单元格（<code>table-cell</code>）元素的垂直对齐方式</li>
<li>内联元素默认都会受到 <code>line-height</code> 和 <code>vertical-align</code> 的影响</li>
</ol>
<h3 id="相对其父元素垂直对齐"><a href="#相对其父元素垂直对齐" class="headerlink" title="相对其父元素垂直对齐"></a>相对其父元素垂直对齐</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>baseline</code>（默认）</td>
<td>使元素的基线与父元素的基线对齐</td>
</tr>
<tr>
<td><code>sub</code></td>
<td>使元素的基线与父元素的下标基线对齐</td>
</tr>
<tr>
<td><code>super</code></td>
<td>使元素的基线与父元素的上标基线对齐</td>
</tr>
<tr>
<td><code>text-top</code></td>
<td>使元素的顶部与父元素的字体顶部对齐</td>
</tr>
<tr>
<td><code>text-bottom</code></td>
<td>使元素的底部与父元素的字体底部对齐</td>
</tr>
<tr>
<td><code>middle</code></td>
<td>使元素的中部与父元素的基线加上父元素x-height的一半对齐</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>使元素的基线对齐到父元素的基线之上的给定长度。可以是负数</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>使元素的基线对齐到父元素的基线之上的给定百分比，该百分比是line-height属性的百分比。可以是负数</td>
</tr>
</tbody></table>
<h3 id="相对整行垂直对齐"><a href="#相对整行垂直对齐" class="headerlink" title="相对整行垂直对齐"></a>相对整行垂直对齐</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>top</code></td>
<td>使元素及其后代元素的顶部与整行的顶部对齐</td>
</tr>
<tr>
<td><code>bottom</code></td>
<td>使元素及其后代元素的底部与整行的底部对齐</td>
</tr>
</tbody></table>
<h1 id="三-对几个现象的理解"><a href="#三-对几个现象的理解" class="headerlink" title="三 对几个现象的理解"></a>三 对几个现象的理解</h1><h2 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;span&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/CSS/lh_va1-1.png" alt=""></p>
<ul>
<li><code>inline</code> 内联元素形成行框盒子的是内部的文字，内部为空，没有形成行框盒子，所以 div 的内部 <code>span</code> 高度为 0，则 div 的高度也为 0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;span style=&quot;display: inline-block;&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/CSS/lh_va1-2.png" alt=""></p>
<ol>
<li><code>inline-block</code> 内联元素形成行框盒子的是元素本身，内部为空也能形成行框盒子，既有了幽灵节点 <code>strut</code></li>
<li>虽然 <code>span</code> 的高度还是 0，但幽灵节点 <code>strut</code> 默认是有行高的，所以 div 的高度不为 0</li>
</ol>
<h2 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">	div &#123;</span><br><span class="line">		background: #ddd;</span><br><span class="line">		border: 1px solid #000;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;img src=&quot;mm.jpg&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/CSS/lh_va2-1.png" alt=""></p>
<ul>
<li>底部有空隙的原因<ol>
<li>img 形成了行框盒子，所以出现了 <code>strut</code></li>
<li><code>vertical-align</code> 默认为 <code>base-line</code> 对齐，strut 的 <code>base-line</code> 为 x 的下边缘，img 的 <code>base-line</code> 为底部</li>
<li>而对于文字而言，内容区域高度是顶线与基线的距离，而不是文字上线边缘，所以底部出现空隙</li>
</ol>
</li>
</ul>
<h3 id="1-在图片前边添加文本现象是一样的"><a href="#1-在图片前边添加文本现象是一样的" class="headerlink" title="1 在图片前边添加文本现象是一样的"></a>1 在图片前边添加文本现象是一样的</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/CSS/lh_va2-2.png" alt=""></p>
<h3 id="2-解决方式"><a href="#2-解决方式" class="headerlink" title="2 解决方式"></a>2 解决方式</h3><ol>
<li>img 块级化，<code>vertical-align</code> 对块级元素无效（且没有了行框盒子，也就没有了 <code>strut</code>）</li>
<li>修改 <code>vertical-align</code> 为其他值比如 <code>bottom top middle ...</code><ul>
<li>如 <code>bottom</code>，指的是文字内容区域的下边缘和图片的下边缘，自然就没了空隙</li>
</ul>
</li>
<li>减小 <code>line-height</code> 的值，也就是减小行间距，会造成文字向下移动</li>
</ol>
<h2 id="3-3-单行未必垂直居中"><a href="#3-3-单行未必垂直居中" class="headerlink" title="3.3 单行未必垂直居中"></a>3.3 单行未必垂直居中</h2><ol>
<li>如果包含块没有设置高度，则只要设置 <code>line-height</code> 即可</li>
<li>如果包含块设置了高度，则设置 <code>line-height = height</code></li>
</ol>
<h2 id="3-4-多行文本垂直居中"><a href="#3-4-多行文本垂直居中" class="headerlink" title="3.4 多行文本垂直居中"></a>3.4 多行文本垂直居中</h2><ol>
<li>与单行文本居中，原理一样，使用 <code>span</code> 包含多行文本，将此 <code>span</code> 看成单行文本</li>
<li>设置包含块 <code>line-height = height</code></li>
<li><code>span</code> 设置 <ol>
<li><code>display: inline-block</code></li>
<li><code>vertical-align: middle</code><ul>
<li>为了让 span 在 div 中居中</li>
</ul>
</li>
<li>一个合适的 <code>line-height</code><ul>
<li>作用于 span 内部文本的显示</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="为何-span-要设置-display-inline-block"><a href="#为何-span-要设置-display-inline-block" class="headerlink" title="为何 span 要设置 display: inline-block ?"></a>为何 span 要设置 <code>display: inline-block</code> ?</h3><ul>
<li>span的display为默认的inline时，形成行框盒子的是span的内容，由于div的line-height会作用于行框盒子的strut，且div的line-height大于span的line-height，所以行框应用的是div的line-height，也就是说span的内容应用的是div的line-height，就会导致文字行距很大</li>
<li>span的display设置为line-block时，形成行框盒子的是span本身，span的内部还会形成一个行框盒子，这时span设置的line-height就会对内部的行框盒子起作用，即span应用的是div的line-height，sanp的内容应用的是span自身的line-height，所以文字就能正常显示</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>CSS元素</title>
    <url>/anyeansan.github.io/2020/11/08/UI/CSS%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="一-display"><a href="#一-display" class="headerlink" title="一 display"></a>一 display</h1><h2 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1 语法"></a>1.1 语法</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[ &lt;display-outside&gt; || &lt;display-inside&gt; ]</span></span><br><span class="line">&lt;display-listitem&gt; | </span><br><span class="line">&lt;display-internal&gt; |</span><br><span class="line">&lt;display-box&gt; |</span><br><span class="line">&lt;<span class="selector-tag">display-legacy</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-属性说明"><a href="#1-2-属性说明" class="headerlink" title="1.2 属性说明"></a>1.2 属性说明</h2><h3 id="1-lt-display-outside-gt"><a href="#1-lt-display-outside-gt" class="headerlink" title="1 &lt;display-outside&gt;"></a>1 <code>&lt;display-outside&gt;</code></h3><ul>
<li>决定了元素类型</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>block</code></td>
<td>块级元素</td>
</tr>
<tr>
<td><code>inline</code></td>
<td>行内元素</td>
</tr>
</tbody></table>
<h3 id="2-lt-display-inside-gt"><a href="#2-lt-display-inside-gt" class="headerlink" title="2 &lt;display-inside&gt;"></a>2 <code>&lt;display-inside&gt;</code></h3><ul>
<li>决定了内部元素布局方式</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>flow-root</code></td>
<td>触发 BFC</td>
</tr>
<tr>
<td><code>table</code></td>
<td>表现如同 <code>&lt;table&gt;</code></td>
</tr>
<tr>
<td><code>flex</code></td>
<td>弹性布局</td>
</tr>
<tr>
<td><code>grid</code></td>
<td>栅格布局</td>
</tr>
<tr>
<td><code>flow</code></td>
<td>了解</td>
</tr>
<tr>
<td><code>ruby</code></td>
<td>了解，可以加旁注标记，如中文的拼音</td>
</tr>
</tbody></table>
<h3 id="3-lt-display-box-gt"><a href="#3-lt-display-box-gt" class="headerlink" title="3 &lt;display-box&gt;"></a>3 <code>&lt;display-box&gt;</code></h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code></td>
<td>不显示，就好像不存在一样，不占空间</td>
</tr>
</tbody></table>
<h3 id="4-lt-display-legacy-gt"><a href="#4-lt-display-legacy-gt" class="headerlink" title="4 &lt;display-legacy&gt;"></a>4 <code>&lt;display-legacy&gt;</code></h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>inline-block</code></td>
<td>行内块</td>
</tr>
<tr>
<td><code>inline-table</code></td>
<td>行表格</td>
</tr>
<tr>
<td><code>inline-flex</code></td>
<td>行弹性</td>
</tr>
<tr>
<td><code>inline-grid</code></td>
<td>行栅格</td>
</tr>
</tbody></table>
<h3 id="5-lt-display-listitem-gt"><a href="#5-lt-display-listitem-gt" class="headerlink" title="5 &lt;display-listitem&gt;"></a>5 <code>&lt;display-listitem&gt;</code></h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">display-outside</span>&gt;? &amp;&amp; <span class="selector-attr">[ flow | flow-root ]</span>? &amp;&amp; <span class="selector-tag">list-item</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>list-item</code></td>
<td>表现如同 <code>&lt;li&gt;</code>，可以搭配 <code>list-style-type</code> 和 <code>list-style-position</code> 使用</td>
</tr>
</tbody></table>
<h3 id="6-lt-display-internal-gt"><a href="#6-lt-display-internal-gt" class="headerlink" title="6 &lt;display-internal&gt;"></a>6 <code>&lt;display-internal&gt;</code></h3><ul>
<li>内部属性值</li>
<li>类似 table 和 ruby 等有复杂内部结构的布局模块，它们的子孙有不同的填充方式</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>table-header-group</code></td>
<td>同 <code>&lt;thead&gt;</code></td>
</tr>
<tr>
<td><code>table-row-group</code></td>
<td>同 <code>&lt;tbody&gt;</code></td>
</tr>
<tr>
<td><code>table-footer-group</code></td>
<td>同 <code>&lt;tfoot&gt;</code></td>
</tr>
<tr>
<td><code>table-caption</code></td>
<td>同 <code>&lt;caption&gt;</code></td>
</tr>
<tr>
<td><code>table-row</code></td>
<td>同 <code>&lt;tr&gt;</code></td>
</tr>
<tr>
<td><code>table-cell</code></td>
<td>同 <code>&lt;td&gt;</code></td>
</tr>
<tr>
<td><code>table-column-group</code></td>
<td>同 <code>&lt;colgroup&gt;</code></td>
</tr>
<tr>
<td><code>table-column</code></td>
<td>同 <code>&lt;col&gt;</code></td>
</tr>
<tr>
<td><code>ruby-base</code></td>
<td>同 <code>&lt;rb&gt;</code></td>
</tr>
<tr>
<td><code>ruby-text</code></td>
<td>同 <code>&lt;rt&gt;</code></td>
</tr>
<tr>
<td><code>ruby-base-container</code></td>
<td>同 <code>&lt;rbc&gt;</code></td>
</tr>
<tr>
<td><code>ruby-text-container</code></td>
<td>同 <code>&lt;rtc&gt;</code></td>
</tr>
</tbody></table>
<h2 id="1-3-单值语法-amp-双值语法"><a href="#1-3-单值语法-amp-双值语法" class="headerlink" title="1.3 单值语法 &amp; 双值语法"></a>1.3 单值语法 &amp; 双值语法</h2><table>
<thead>
<tr>
<th>single value</th>
<th>two value</th>
</tr>
</thead>
<tbody><tr>
<td><code>block</code></td>
<td><code>block flow</code></td>
</tr>
<tr>
<td><code>flow-root</code></td>
<td><code>block flow-root</code></td>
</tr>
<tr>
<td><code>inline</code></td>
<td><code>inline flow</code></td>
</tr>
<tr>
<td><code>inline-block</code></td>
<td><code>inline flow-root</code></td>
</tr>
<tr>
<td><code>flex</code></td>
<td><code>block flex</code></td>
</tr>
<tr>
<td><code>inline-flex</code></td>
<td><code>inline flex</code></td>
</tr>
<tr>
<td><code>grid</code></td>
<td><code>block grid</code></td>
</tr>
<tr>
<td><code>inline-grid</code></td>
<td><code>inline grid</code></td>
</tr>
<tr>
<td><code>table</code></td>
<td><code>block table</code></td>
</tr>
<tr>
<td><code>inline-table</code></td>
<td><code>inline table</code></td>
</tr>
</tbody></table>
<ul>
<li>双值语法未广泛支持，但可以帮助理解单值语法时 <code>&lt;display-outside&gt;</code> 和 <code>&lt;display-inside&gt;</code> 的默认值</li>
</ul>
<h1 id="二-元素类型"><a href="#二-元素类型" class="headerlink" title="二 元素类型"></a>二 元素类型</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><table>
<thead>
<tr>
<th>类型</th>
<th>单值</th>
<th>双值</th>
</tr>
</thead>
<tbody><tr>
<td>块级元素</td>
<td><code>block</code></td>
<td><code>block flow</code></td>
</tr>
<tr>
<td>行内元素</td>
<td><code>inline</code></td>
<td><code>inline flow</code></td>
</tr>
<tr>
<td>内联块元素</td>
<td><code>inline-block</code></td>
<td><code>inline inline-block</code></td>
</tr>
</tbody></table>
<h2 id="2-2-块级元素"><a href="#2-2-块级元素" class="headerlink" title="2.2 块级元素"></a>2.2 块级元素</h2><h3 id="1-特点"><a href="#1-特点" class="headerlink" title="1 特点"></a>1 特点</h3><ol>
<li>独占一行，自上而下排列</li>
<li>宽度、高度和内外边距可以直接设置<ol>
<li>宽度：默认为父元素宽度的 <code>100%</code></li>
<li>高度：默认为 <code>0</code>，高度与其内容高度一致</li>
</ol>
</li>
<li>块级元素是一个容器或盒子，可以容纳行内元素或块级元素<ul>
<li><code>p h1~6 dt</code> 等文字类块级元素内部不能放块级元素</li>
</ul>
</li>
</ol>
<h3 id="2-默认块级元素"><a href="#2-默认块级元素" class="headerlink" title="2 默认块级元素"></a>2 默认块级元素</h3><table>
<thead>
<tr>
<th>默认块级元素</th>
<th>display</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;div&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;header&gt; &lt;main&gt; &lt;footer&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;article&gt; &lt;aside&gt; &lt;section&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;h1&gt;~&lt;h6&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;p&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;ul&gt; &lt;ol&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;li&gt;</code></td>
<td>list-item</td>
</tr>
<tr>
<td><code>&lt;dl&gt; &lt;dt&gt; &lt;dd&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;hr&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;table&gt;</code></td>
<td>table</td>
</tr>
<tr>
<td><code>&lt;form&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;option&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;address&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;blockquote&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;pre&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;menu&gt;</code></td>
<td>block</td>
</tr>
</tbody></table>
<h2 id="2-3-行内元素"><a href="#2-3-行内元素" class="headerlink" title="2.3 行内元素"></a>2.3 行内元素</h2><h3 id="1-特点-1"><a href="#1-特点-1" class="headerlink" title="1 特点"></a>1 特点</h3><ol>
<li>包裹性：默认宽高就是它本身内容的宽高</li>
<li>自适应性：在一行显示，从左至右排列，如果一行不足以容纳，会换行</li>
<li>直接设置宽高无效</li>
<li>只能容纳文本或行内元素<ul>
<li><code>&lt;a&gt;</code> 中不能容纳 <code>&lt;a&gt;</code></li>
<li><code>&lt;a&gt;</code> 中可以容纳块级元素</li>
</ul>
</li>
</ol>
<h3 id="2-默认内联元素"><a href="#2-默认内联元素" class="headerlink" title="2 默认内联元素"></a>2 默认内联元素</h3><table>
<thead>
<tr>
<th>默认内联元素</th>
<th>display</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;span&gt;</code></td>
<td>inline</td>
</tr>
<tr>
<td><code>&lt;a&gt;</code></td>
<td>inline</td>
</tr>
<tr>
<td><code>&lt;strong&gt;</code></td>
<td>inline</td>
</tr>
<tr>
<td><code>&lt;em&gt;</code></td>
<td>inline</td>
</tr>
<tr>
<td><code>&lt;del&gt;</code></td>
<td>inline</td>
</tr>
<tr>
<td><code>&lt;ins&gt;</code></td>
<td>inline</td>
</tr>
<tr>
<td><code>&lt;br&gt;</code></td>
<td>inline</td>
</tr>
<tr>
<td><code>&lt;label&gt;</code></td>
<td>inline</td>
</tr>
</tbody></table>
<h2 id="2-4-行内块元素"><a href="#2-4-行内块元素" class="headerlink" title="2.4 行内块元素"></a>2.4 行内块元素</h2><h3 id="1-特点-2"><a href="#1-特点-2" class="headerlink" title="1 特点"></a>1 特点</h3><ol>
<li>包裹性：默认宽高就是它本身内容的宽高</li>
<li>自适应性：在一行显示，从左至右排列（和其它行内或行内块元素之间会有空白缝隙），如果一行不足以容纳，会换行</li>
<li>宽度、高度和内外边距可以直接设置</li>
</ol>
<h3 id="2-默认行内块元素"><a href="#2-默认行内块元素" class="headerlink" title="2 默认行内块元素"></a>2 默认行内块元素</h3><table>
<thead>
<tr>
<th>默认行内块元素</th>
<th>display</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;img&gt;</code></td>
<td>inline</td>
</tr>
<tr>
<td><code>&lt;input&gt;</code></td>
<td>inline-block（<code>type=hidden</code> 时是 <code>none</code>）</td>
</tr>
<tr>
<td><code>&lt;button&gt;</code></td>
<td>inline-block</td>
</tr>
<tr>
<td><code>&lt;select&gt;</code></td>
<td>inline-block</td>
</tr>
<tr>
<td><code>&lt;textarea&gt;</code></td>
<td>inline-block</td>
</tr>
<tr>
<td><code>&lt;td&gt;</code></td>
<td>table-cell</td>
</tr>
</tbody></table>
<h1 id="三-非替换元素-amp-替换元素"><a href="#三-非替换元素-amp-替换元素" class="headerlink" title="三 非替换元素 &amp; 替换元素"></a>三 非替换元素 &amp; 替换元素</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ul>
<li>根据 “外在盒子” 把元素分为内联元素和块级元素</li>
<li>根据是否具有可替换内容，把元素分为替换元素和非替换元素</li>
</ul>
<h2 id="3-2-非替换元素"><a href="#3-2-非替换元素" class="headerlink" title="3.2 非替换元素"></a>3.2 非替换元素</h2><ul>
<li>如果元素的内容包含在文档中，则称之为非替换元素</li>
<li>html 的大多数元素是不可替换元素，即其内容直接表现给浏览器<ul>
<li>如 <code>&lt;p&gt;</code> 文档内容是什么，显示结果就是什么</li>
</ul>
</li>
</ul>
<h2 id="3-3-替换元素"><a href="#3-3-替换元素" class="headerlink" title="3.3 替换元素"></a>3.3 替换元素</h2><h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h3><ul>
<li>浏览器根据元素的标签和属性，来决定元素的具体显示内容（即content box内容可替换，对应的 CSS 属性是 content）<ul>
<li>如 <code>&lt;img&gt; &lt;object&gt; &lt;video&gt; &lt;iframe&gt; &lt;textarea&gt; &lt;input&gt;</code></li>
<li><code>&lt;img&gt;</code>，修改src属性就会改变显示结果</li>
</ul>
</li>
<li>匿名可替换元素<ul>
<li>通过 CSS content 属性来插入的对象 被称作 匿名可替换元素</li>
</ul>
</li>
<li>所有的替换元素都是内联元素</li>
</ul>
<h3 id="2-替换元素的特性"><a href="#2-替换元素的特性" class="headerlink" title="2 替换元素的特性"></a>2 替换元素的特性</h3><h4 id="1-内容的外观不受页面上的-CSS-的影响"><a href="#1-内容的外观不受页面上的-CSS-的影响" class="headerlink" title="1 内容的外观不受页面上的 CSS 的影响"></a>1 内容的外观不受页面上的 CSS 的影响</h4><ul>
<li>替换元素是一种外部对象，它们外观的渲染，是独立于 CSS 的</li>
<li>样式表现在css作用域之外，如果要替换元素本身的外观，需要类似appearance的属性。或者是浏览器本身暴露的接口。但是直接<code>input[type=&#39;checkbox&#39;]{}</code>没办法改变内间距背景色等特性</li>
</ul>
<h4 id="2-有自己的尺寸"><a href="#2-有自己的尺寸" class="headerlink" title="2 有自己的尺寸"></a>2 有自己的尺寸</h4><ul>
<li>在 Web 中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是 300 像素×150 像素<ul>
<li>如 <code>&lt;video&gt; &lt;iframe&gt; &lt;canvas&gt;</code></li>
</ul>
</li>
<li>少部分替换元素为 0 像素，如<code>&lt;img&gt;</code></li>
<li>表单元素的替换元素的尺寸则和浏览器有关，没有明显的规律</li>
</ul>
<h4 id="3-在很多-CSS-属性上有自己的一套表现规则"><a href="#3-在很多-CSS-属性上有自己的一套表现规则" class="headerlink" title="3 在很多 CSS 属性上有自己的一套表现规则"></a>3 在很多 CSS 属性上有自己的一套表现规则</h4><ul>
<li>如 <code>vertical-align</code> 默认值的 baseline ，但对于替换元素，默认为元素的下边缘</li>
</ul>
<h3 id="3-替换元素的尺寸计算规则"><a href="#3-替换元素的尺寸计算规则" class="headerlink" title="3 替换元素的尺寸计算规则"></a>3 替换元素的尺寸计算规则</h3><h4 id="1-尺寸类型"><a href="#1-尺寸类型" class="headerlink" title="1 尺寸类型"></a>1 尺寸类型</h4><ol>
<li>固有尺寸<ul>
<li>指的是替换内容原本的尺寸</li>
<li>如图片，视频都有自身的尺寸</li>
</ul>
</li>
<li>HTML 尺寸<ul>
<li>HTML 尺寸只能通过HTML 原生属性改变</li>
<li>HTML 原生属性，如<code>&lt;img&gt;</code>的 width 和 height 属性、<code>&lt;input&gt;</code>的 size 属性、<code>&lt;textarea&gt;</code>的 cols 和 rows 属性等</li>
</ul>
</li>
<li>CSS 尺寸<ul>
<li>可以通过 CSS 的 width 和 height 或者 max-width/min-width 和max-height/min-height 设置的尺寸</li>
<li>对应盒尺寸中的 content box</li>
</ul>
</li>
</ol>
<h4 id="2-计算规则"><a href="#2-计算规则" class="headerlink" title="2 计算规则"></a>2 计算规则</h4><ol>
<li>没有 CSS 尺寸和 HTML 尺寸，则使用固有尺寸作为最终的宽高</li>
<li>没有 CSS 尺寸，则使用 HTML尺寸作为最终的宽高</li>
<li>有 CSS 尺寸，则最终尺寸由 CSS 属性决定</li>
<li>如果固有尺寸含有固有的宽高比，css尺寸和html尺寸如果只设置了宽高中的一个，则另一个值根据固有尺寸宽高比变化</li>
<li>如果以上都不符合，则最终宽度表现为 300 像素，高度为 150 像素<ul>
<li><code>&lt;img&gt;</code> 较为特殊<ul>
<li>chrome下默认为0*0</li>
<li>firefox下默认为0*22，且firfox下如果省略src属性，则<code>&lt;img&gt;</code>不是替换元素，而是一个普通的内联元素</li>
</ul>
</li>
</ul>
</li>
<li>内联替换元素和块级替换元素使用上面同一套尺寸计算规则<ul>
<li>即内联替换元素块级化，计算规则不变</li>
</ul>
</li>
<li>无法改变替换元素内容的固有尺寸<ul>
<li>我们为<code>&lt;img&gt;</code>设置宽高，好像是覆盖了固有尺寸，其实改变的是content box的宽高，而<code>&lt;img&gt;</code>的content box替换内容默认适配方式是填充（fill）</li>
<li>css3替换元素的替换内容的适配方式可以通过<code>object-fit</code> 属性修改</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>CSS样式</title>
    <url>/anyeansan.github.io/2020/11/08/UI/CSS%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="一-background（背景）"><a href="#一-background（背景）" class="headerlink" title="一 background（背景）"></a>一 background（背景）</h1><h2 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1 语法"></a>1.1 语法</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">background-color ||</span><br><span class="line">background-image ||</span><br><span class="line">background-position [ / background-size]? || </span><br><span class="line">background-repeat ||</span><br><span class="line">background-attachment ||</span><br><span class="line"><span class="selector-attr">[background-origin background-clip?]</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-属性说明"><a href="#1-2-属性说明" class="headerlink" title="1.2 属性说明"></a>1.2 属性说明</h2><h3 id="1-background-color"><a href="#1-background-color" class="headerlink" title="1 background-color"></a>1 background-color</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>transparent</code>（默认）</td>
<td>透明</td>
</tr>
<tr>
<td><code>currentColor</code></td>
<td>当前元素的字体颜色</td>
</tr>
<tr>
<td><code>&lt;color&gt;</code></td>
<td>设置颜色</td>
</tr>
</tbody></table>
<h3 id="2-background-image"><a href="#2-background-image" class="headerlink" title="2 background-image"></a>2 background-image</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code>（默认）</td>
<td>无背景图</td>
</tr>
<tr>
<td><code>url</code></td>
<td><code>url(地址不提倡加引号)</code></td>
</tr>
<tr>
<td><code>&lt;gradient&gt;</code></td>
<td>渐变</td>
</tr>
</tbody></table>
<h3 id="3-background-repeat"><a href="#3-background-repeat" class="headerlink" title="3 background-repeat"></a>3 background-repeat</h3><ul>
<li>css3 定义时使用两个值，如果只设置一个，也会被解析成两个</li>
</ul>
<table>
<thead>
<tr>
<th>单值</th>
<th>说明</th>
<th>双值</th>
</tr>
</thead>
<tbody><tr>
<td><code>repeat</code>（默认）</td>
<td>平铺</td>
<td><code>repeat repeat</code></td>
</tr>
<tr>
<td><code>repeat-x</code></td>
<td>x 轴平铺</td>
<td><code>repeat no-repeat</code></td>
</tr>
<tr>
<td><code>repeat-y</code></td>
<td>y 轴平铺</td>
<td><code>no-repeat repeat</code></td>
</tr>
<tr>
<td><code>no-repeat</code></td>
<td>不平铺</td>
<td><code>no-repeat no-repeat</code></td>
</tr>
<tr>
<td><code>space</code></td>
<td>两端对齐平铺，多出来的空间用空白代替</td>
<td><code>space space</code></td>
</tr>
<tr>
<td><code>round</code></td>
<td>两端对齐平铺，多出来空间通过自身的拉伸来填充</td>
<td><code>round round</code></td>
</tr>
</tbody></table>
<h3 id="4-background-position"><a href="#4-background-position" class="headerlink" title="4 background-position"></a>4 background-position</h3><ul>
<li><code>x轴 y轴</code>，如果只设置一个值，另一个默认居中</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>关键字</code></td>
<td><code>left right top bottom center</code></td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>长度 <code>px em ...</code></td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>百分比</td>
</tr>
</tbody></table>
<h3 id="5-background-size"><a href="#5-background-size" class="headerlink" title="5 background-size"></a>5 background-size</h3><ul>
<li><code>宽 高</code>，如果只设置一个值，另一个值为 <code>auto</code>，保持宽高比</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code>（默认）</td>
<td>以背景图片的比例缩放背景图片</td>
</tr>
<tr>
<td><code>cover</code></td>
<td>缩放背景图片以完全覆盖背景区，可能背景图片部分看不见</td>
</tr>
<tr>
<td><code>contain</code></td>
<td>缩放背景图片以完全装入背景区，可能背景区部分空白</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>长度</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>背景图片相对背景区的百分比</td>
</tr>
</tbody></table>
<h3 id="6-background-attachment"><a href="#6-background-attachment" class="headerlink" title="6 background-attachment"></a>6 background-attachment</h3><ul>
<li>决定背景图像的位置是在视口内固定，还是随着包含它的区块滚动。</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
<th>元素滚动条</th>
<th>页面滚动条</th>
</tr>
</thead>
<tbody><tr>
<td><code>scroll</code>（默认）</td>
<td>背景相对于元素本身固定，融为一体</td>
<td>背景不动</td>
<td>背景会动</td>
</tr>
<tr>
<td><code>fixed</code></td>
<td>背景相对于视口固定</td>
<td>背景不动</td>
<td>背景不动</td>
</tr>
<tr>
<td><code>local</code></td>
<td>背景相对于元素的内容固定</td>
<td>背景会动</td>
<td>背景会动</td>
</tr>
</tbody></table>
<h3 id="7-background-origin"><a href="#7-background-origin" class="headerlink" title="7 background-origin"></a>7 background-origin</h3><ul>
<li>决定背景图片相对于哪个盒子定位</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>padding-box</code>（默认）</td>
<td>相对于 <code>padding-box</code> 定位</td>
</tr>
<tr>
<td><code>content-box</code></td>
<td>相对于 <code>content-box</code> 定位</td>
</tr>
<tr>
<td><code>border-box</code></td>
<td>相对于 <code>border-box</code> 定位</td>
</tr>
</tbody></table>
<h3 id="8-background-clip"><a href="#8-background-clip" class="headerlink" title="8 background-clip"></a>8 background-clip</h3><ul>
<li>设置元素的背景切割范围，相对于哪个盒子定位不变</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>border-box</code>（默认）</td>
<td>背景延伸至边框外沿（但是在边框下层）</td>
</tr>
<tr>
<td><code>content-box</code></td>
<td>背景被裁剪至内容区外沿</td>
</tr>
<tr>
<td><code>padding-box</code></td>
<td>背景延伸至内边距外沿</td>
</tr>
</tbody></table>
<h1 id="二-list-style（列表）"><a href="#二-list-style（列表）" class="headerlink" title="二 list-style（列表）"></a>二 list-style（列表）</h1><h2 id="2-1-语法"><a href="#2-1-语法" class="headerlink" title="2.1 语法"></a>2.1 语法</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">list-style-type ||</span><br><span class="line">list-style-image ||</span><br><span class="line"><span class="selector-tag">list-style-position</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-属性说明"><a href="#2-2-属性说明" class="headerlink" title="2.2 属性说明"></a>2.2 属性说明</h2><h3 id="1-list-style-type"><a href="#1-list-style-type" class="headerlink" title="1 list-style-type"></a>1 list-style-type</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>disc</code>（默认）</td>
<td>实心圆点</td>
</tr>
<tr>
<td><code>none</code></td>
<td>无样式</td>
</tr>
<tr>
<td><code>circle</code></td>
<td>空心圆点</td>
</tr>
<tr>
<td><code>square</code></td>
<td>实心方块</td>
</tr>
<tr>
<td><code>decimal</code></td>
<td>从1开始的数字</td>
</tr>
<tr>
<td><code>......</code></td>
<td>还有许多样式</td>
</tr>
</tbody></table>
<h3 id="2-list-style-image"><a href="#2-list-style-image" class="headerlink" title="2 list-style-image"></a>2 list-style-image</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code>（默认）</td>
<td>会使用 <code>list-style-type</code></td>
</tr>
<tr>
<td><code>&lt;url&gt;</code></td>
<td><code>url(地址不提倡加引号)</code></td>
</tr>
</tbody></table>
<h3 id="3-list-style-position"><a href="#3-list-style-position" class="headerlink" title="3 list-style-position"></a>3 list-style-position</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>outside</code>（默认）</td>
<td>标记盒 <code>::marker</code> 在主块盒之外</td>
</tr>
<tr>
<td><code>inside</code></td>
<td>标记盒 <code>::marker</code> 在主块盒之内，是主块盒中的第一个行内盒</td>
</tr>
</tbody></table>
<h1 id="三-表格"><a href="#三-表格" class="headerlink" title="三 表格"></a>三 表格</h1><h2 id="3-1-border-collapse"><a href="#3-1-border-collapse" class="headerlink" title="3.1 border-collapse"></a>3.1 border-collapse</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>separate</code>（默认）</td>
<td>分离，HTML 表格的传统模式，相邻单元格都拥有独立的边框</td>
</tr>
<tr>
<td><code>collapse</code></td>
<td>合并，表格中相邻单元格共享边框</td>
</tr>
</tbody></table>
<h2 id="3-2-border-spacing（单元格内边距）"><a href="#3-2-border-spacing（单元格内边距）" class="headerlink" title="3.2 border-spacing（单元格内边距）"></a>3.2 border-spacing（单元格内边距）</h2><ol>
<li>只有 <code>border-collapse: separate</code> 时才有效</li>
<li>单元格没有外边距，有边框和内边距</li>
<li><code>&lt;length&gt; &lt;length&gt;?</code>：<code>水平 垂直</code> 如果省略垂直则与水平间距相等</li>
</ol>
<h2 id="3-3-empty-cells"><a href="#3-3-empty-cells" class="headerlink" title="3.3 empty-cells"></a>3.3 empty-cells</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>show</code>（默认）</td>
<td>空单元格的背景和边框正常显示</td>
</tr>
<tr>
<td><code>hide</code></td>
<td>空单元格的背景和边框隐藏</td>
</tr>
</tbody></table>
<h2 id="3-4-caption-side"><a href="#3-4-caption-side" class="headerlink" title="3.4 caption-side"></a>3.4 caption-side</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>top</code>（默认）</td>
<td>标题在表格顶部，标题是在表格外面的</td>
</tr>
<tr>
<td><code>bottom</code></td>
<td>标题在表格底部，标题是在表格外面的</td>
</tr>
</tbody></table>
<h2 id="3-5-table-layout"><a href="#3-5-table-layout" class="headerlink" title="3.5 table-layout"></a>3.5 table-layout</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code>（默认）</td>
<td>表格及单元格的宽度取决于其包含的内容</td>
</tr>
<tr>
<td><code>fixed</code></td>
<td>表格和列的宽度通过表格的宽度来设置，某一列的宽度仅由该列首行的单元格决定</td>
</tr>
</tbody></table>
<h1 id="四-元素的显示和隐藏"><a href="#四-元素的显示和隐藏" class="headerlink" title="四 元素的显示和隐藏"></a>四 元素的显示和隐藏</h1><h2 id="4-1-方式"><a href="#4-1-方式" class="headerlink" title="4.1 方式"></a>4.1 方式</h2><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>display: none</code></td>
<td>该元素以及它的所有后代元素都会隐藏，不保留位置，不影响计数器的值</td>
</tr>
<tr>
<td><code>visibility: hidden</code></td>
<td>隐藏元素，如果后代元素 <code>visibility: visible</code>，则后代元素依然可见，保留位置，会影响计数器的值</td>
</tr>
</tbody></table>
<h2 id="4-2-visibility（元素可见性）"><a href="#4-2-visibility（元素可见性）" class="headerlink" title="4.2 visibility（元素可见性）"></a>4.2 visibility（元素可见性）</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>visible</code>（默认）</td>
<td>元素正常显示</td>
</tr>
<tr>
<td><code>hidden</code></td>
<td>隐藏元素，但是其他元素的布局不改变，相当于此元素变成透明。若其子元素设为visible，则子元素依然可见</td>
</tr>
<tr>
<td><code>collapse</code></td>
<td>用于 <code>&lt;table&gt;</code> 行、列、列组和行组，隐藏表格的行或列，并且不占用任何空间，就好像折叠了单元格一般（效果同 <code>display:none</code> ）</td>
</tr>
</tbody></table>
<h1 id="五-overflow（元素溢出）"><a href="#五-overflow（元素溢出）" class="headerlink" title="五 overflow（元素溢出）"></a>五 overflow（元素溢出）</h1><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>visible</code>（默认）</td>
<td>内容不会被修剪，超出内容可见</td>
</tr>
<tr>
<td><code>hidden</code></td>
<td>内容会被修剪，超出内容不可见</td>
</tr>
<tr>
<td><code>scroll</code></td>
<td>内容会被修剪，浏览器会显示滚动条以便查看超出内容</td>
</tr>
<tr>
<td><code>auto</code></td>
<td>如果内容超出，就显示滚动条，反之则不显示</td>
</tr>
</tbody></table>
<h1 id="六-opacity（元素透明度）"><a href="#六-opacity（元素透明度）" class="headerlink" title="六 opacity（元素透明度）"></a>六 opacity（元素透明度）</h1><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>1</code>（默认）</td>
<td>元素完全不透明</td>
</tr>
<tr>
<td><code>0~1</code></td>
<td>元素半透明</td>
</tr>
<tr>
<td><code>0</code></td>
<td>元素完全透明</td>
</tr>
</tbody></table>
<h1 id="七-用户界面样式"><a href="#七-用户界面样式" class="headerlink" title="七 用户界面样式"></a>七 用户界面样式</h1><h2 id="7-1-cursor（鼠标样式）"><a href="#7-1-cursor（鼠标样式）" class="headerlink" title="7.1 cursor（鼠标样式）"></a>7.1 cursor（鼠标样式）</h2><ul>
<li>定义鼠标悬浮在元素上方时的样式</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code>（默认）</td>
<td>浏览器根据内容类别自动选择光标形状</td>
</tr>
<tr>
<td><code>default</code></td>
<td>箭头</td>
</tr>
<tr>
<td><code>pointer</code></td>
<td>小手</td>
</tr>
<tr>
<td><code>move</code></td>
<td>移动</td>
</tr>
<tr>
<td><code>text</code></td>
<td>文本</td>
</tr>
<tr>
<td><code>not-allowed</code></td>
<td>禁止</td>
</tr>
<tr>
<td><code>none</code></td>
<td>隐藏光标，比如看视频时</td>
</tr>
<tr>
<td><code>help</code></td>
<td>帮助</td>
</tr>
<tr>
<td><code>...</code></td>
<td>还有很多样式</td>
</tr>
</tbody></table>
<h2 id="7-2-outline（轮廓线）"><a href="#7-2-outline（轮廓线）" class="headerlink" title="7.2 outline（轮廓线）"></a>7.2 outline（轮廓线）</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">outline-style ||</span><br><span class="line">outline-width ||</span><br><span class="line">outline-color</span><br></pre></td></tr></table></figure>

<ol>
<li>轮廓线不占据空间</li>
<li>通常不使用轮廓线 <code>outline: none;</code></li>
</ol>
<h3 id="2-outline-width"><a href="#2-outline-width" class="headerlink" title="2 outline-width"></a>2 outline-width</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;legnth&gt;</code></td>
<td>指定值</td>
</tr>
<tr>
<td><code>thin</code></td>
<td>薄</td>
</tr>
<tr>
<td><code>medium</code></td>
<td>中等</td>
</tr>
<tr>
<td><code>thick</code></td>
<td>厚</td>
</tr>
</tbody></table>
<h3 id="3-outline-style"><a href="#3-outline-style" class="headerlink" title="3 outline-style"></a>3 outline-style</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code></td>
<td>无轮廓线</td>
</tr>
<tr>
<td><code>solid</code></td>
<td>单实线</td>
</tr>
<tr>
<td><code>double</code></td>
<td>双实线</td>
</tr>
<tr>
<td><code>dotted</code></td>
<td>点画线</td>
</tr>
<tr>
<td><code>dashed</code></td>
<td>虚线</td>
</tr>
<tr>
<td><code>groove</code></td>
<td>雕刻效果，与ridge相反</td>
</tr>
<tr>
<td><code>ridge</code></td>
<td>浮雕效果，与groove相反</td>
</tr>
<tr>
<td><code>inset</code></td>
<td>陷入效果</td>
</tr>
<tr>
<td><code>outset</code></td>
<td>突出效果</td>
</tr>
</tbody></table>
<h2 id="7-3-resize"><a href="#7-3-resize" class="headerlink" title="7.3 resize"></a>7.3 resize</h2><ol>
<li><code>resize</code>：是否可以调整元素大小</li>
<li>文本域 <code>textarea</code> 默认是可以调整的，通常会 <code>resize: none;</code></li>
</ol>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code></td>
<td>不允许用户缩放元素</td>
</tr>
<tr>
<td><code>both</code></td>
<td>允许用户在水平和垂直方向上调整元素的大小</td>
</tr>
<tr>
<td><code>horizontal</code></td>
<td>允许用户在水平方向上调整元素的大小</td>
</tr>
<tr>
<td><code>vertical</code></td>
<td>允许用户在垂直方向上调整元素的大小</td>
</tr>
</tbody></table>
<h1 id="八-技巧"><a href="#八-技巧" class="headerlink" title="八 技巧"></a>八 技巧</h1><h2 id="8-1-CSS-精灵技术"><a href="#8-1-CSS-精灵技术" class="headerlink" title="8.1 CSS 精灵技术"></a>8.1 CSS 精灵技术</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度</li>
<li>CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），这样只需要一次请求即可</li>
<li>CSS 精灵技术主要针对于背景图片，插入的图片 img 是不需要这个技术的</li>
</ol>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* background-image</span><br><span class="line">* background-repeat</span><br><span class="line">* background-position </span><br><span class="line">* 最关键的是使用background-position 属性精确地定位精灵图中的指定部分</span><br></pre></td></tr></table></figure>

<ol>
<li>精确测量每个小背景图片的大小和位置</li>
<li>与小背景图大小相同的盒子，并给盒子指定背景图位置</li>
<li>给盒子指定小背景图片时， 背景定位基本都是 负值。</li>
</ol>
<h2 id="8-2-推拉门"><a href="#8-2-推拉门" class="headerlink" title="8.2 推拉门"></a>8.2 推拉门</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a&gt;</span><br><span class="line">	&lt;span&gt;首页&lt;/span&gt;</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>a 设置 背景左侧，padding撑开合适宽度。    </li>
<li>span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。</li>
<li>之所以a包含span就是因为 整个导航都是可以点击的。</li>
</ol>
<h2 id="8-3-margin-负值"><a href="#8-3-margin-负值" class="headerlink" title="8.3 margin 负值"></a>8.3 margin 负值</h2><ul>
<li>盒子浮动后两个边框挨在一起，设置 <code>margin-left: -1</code> 即可压住一个边</li>
</ul>
<h2 id="8-4-css-图形"><a href="#8-4-css-图形" class="headerlink" title="8.4 css 图形"></a>8.4 css 图形</h2><h3 id="1-三角形"><a href="#1-三角形" class="headerlink" title="1 三角形"></a>1 三角形</h3><ol>
<li>宽高为 0</li>
<li>4 个边框都要写， 只保留需要的边框颜色，其余的都改为 <code>transparent</code>透明</li>
</ol>
<h2 id="8-5-浏览器私有前缀"><a href="#8-5-浏览器私有前缀" class="headerlink" title="8.5 浏览器私有前缀"></a>8.5 浏览器私有前缀</h2><ul>
<li>为了兼容老版本</li>
</ul>
<table>
<thead>
<tr>
<th>前缀</th>
<th>浏览器</th>
</tr>
</thead>
<tbody><tr>
<td><code>-webkit-</code></td>
<td><code>chrome safari</code></td>
</tr>
<tr>
<td><code>-moz-</code></td>
<td><code>firefox</code></td>
</tr>
<tr>
<td><code>-ms-</code></td>
<td><code>ie</code></td>
</tr>
<tr>
<td><code>-o-</code></td>
<td><code>Opera</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>CSS文本</title>
    <url>/anyeansan.github.io/2020/11/08/UI/CSS%E6%96%87%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="一-字体"><a href="#一-字体" class="headerlink" title="一 字体"></a>一 字体</h1><h2 id="1-1-font-face"><a href="#1-1-font-face" class="headerlink" title="1.1 @font face"></a>1.1 <code>@font face</code></h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1 作用"></a>1 作用</h3><ol>
<li>自定义字体或字体集</li>
<li>它允许网页开发者为其网页指定在线字体，可以消除对用户电脑字体的依赖</li>
</ol>
<h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2 语法"></a>2 语法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">	[ font-family: &lt;family-name&gt;; ] ||</span><br><span class="line">	[ src: &lt;src&gt;; ] ||</span><br><span class="line">	[ unicode-range: &lt;unicode-range&gt;; ] ||</span><br><span class="line">	[ font-variant: &lt;font-variant&gt;; ] ||</span><br><span class="line">	[ font-feature-settings: &lt;font-feature-settings&gt;; ] ||</span><br><span class="line">	[ font-variation-settings: &lt;font-variation-settings&gt;; ] ||</span><br><span class="line">	[ font-stretch: &lt;font-stretch&gt;; ] ||</span><br><span class="line">	[ font-weight: &lt;font-weight&gt;; ] ||</span><br><span class="line">	<span class="selector-attr">[ font-style: &lt;font-style&gt;; ]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>font-family</code></td>
<td>自定义字体的名称，特殊符号必须使用引号</td>
</tr>
<tr>
<td><code>src</code></td>
<td>指定在线字体或本地字体，<code>fromat(&#39;woff2&#39;)</code> 转换字体格式，用于浏览器识别</td>
</tr>
<tr>
<td><code>unicode-range</code></td>
<td>可以让特定的字符或者字符片段使用特定的字体</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>字体格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>TrueType（.ttf）</code></td>
<td>Windows和Mac上常见的字体格式，是一种原始格式，因此它并没有为网页进行优化处理</td>
</tr>
<tr>
<td><code>OpenType（.otf）</code></td>
<td>以TrueType为基础，也是一种原始格式，但提供更多的功能</td>
</tr>
<tr>
<td><code>Web Open Font（.woff）</code></td>
<td>针对网页进行特殊优化，因此是Web字体中最佳格式</td>
</tr>
<tr>
<td><code>SVG（.svg）</code></td>
<td>基于SVG字体渲染的格式</td>
</tr>
<tr>
<td><code>Embedded Open Type（.eot）</code></td>
<td>IE专用字体格式，可以从TrueType格式创建此格式字体</td>
</tr>
</tbody></table>
<h2 id="1-2-font"><a href="#1-2-font" class="headerlink" title="1.2 font"></a>1.2 <code>font</code></h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[ font-style || font-variant || font-weight || font-stretch ]</span>? </span><br><span class="line"><span class="selector-tag">font-size</span> <span class="selector-attr">[ / line-height ]</span>? </span><br><span class="line"><span class="selector-tag">font-family</span></span><br></pre></td></tr></table></figure>

<h3 id="1-font-size"><a href="#1-font-size" class="headerlink" title="1 font-size"></a>1 font-size</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>关键字</code></td>
<td><code>xx-small, x-small, small, medium, large, x-large, xx-large, xxx-large, larger, smaller</code></td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>长度，如 <code>px em ex rem</code></td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>相对父元素字体大小的百分比</td>
</tr>
</tbody></table>
<h3 id="2-line-height"><a href="#2-line-height" class="headerlink" title="2 line-height"></a>2 line-height</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>normal</code>（默认）</td>
<td>与 <code>font-family</code> 有关，不同浏览器和系统字体不同，默认值就不同，所以通常需要重新设置</td>
</tr>
<tr>
<td><code>&lt;number&gt;</code></td>
<td>推荐，字体大小的倍数。</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>长度值（如 <code>px，em</code>）</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>字体大小的百分比</td>
</tr>
</tbody></table>
<ul>
<li><code>line-height:1.5</code>、<code>line-height:150%</code> 和 <code>line-height:1.5em</code> <ol>
<li>计算方式相同： <code>line-height = font-size * 1.5</code></li>
<li>继承时数值继承的是数值本身，长度和百分比继承的是计算结果，即对于子元素<ol>
<li>数值：<code>line-height = 子元素font-size * 1.5</code></li>
<li>长度和百分比：<code>line-height = 父元素font-size * 1.5</code></li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="3-font-family"><a href="#3-font-family" class="headerlink" title="3 font-family"></a>3 font-family</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;family-name&gt;</code></td>
<td>字体名称，多个用逗号隔开</td>
</tr>
<tr>
<td><code>&lt;generic-name&gt;</code></td>
<td>字体系列名称</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>通用字体系列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>monospace</code></td>
<td>等宽字体，即字体中每个字宽度相同</td>
</tr>
<tr>
<td><code>sans-serif</code></td>
<td>无衬线字体，即笔画结尾是平滑的字体</td>
</tr>
<tr>
<td><code>serif</code></td>
<td>带衬线字体，笔画结尾有特殊的装饰线或衬线</td>
</tr>
<tr>
<td><code>cursive</code></td>
<td>草书字体</td>
</tr>
<tr>
<td><code>fantasy</code></td>
<td>艺术字体</td>
</tr>
</tbody></table>
<h3 id="4-font-style"><a href="#4-font-style" class="headerlink" title="4 font-style"></a>4 font-style</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>normal</code>（默认）</td>
<td>常规</td>
</tr>
<tr>
<td><code>italic</code></td>
<td>斜体</td>
</tr>
<tr>
<td><code>oblique &lt;angle&gt;?</code></td>
<td>倾斜体 可以附加角度</td>
</tr>
</tbody></table>
<h3 id="5-font-weight"><a href="#5-font-weight" class="headerlink" title="5 font-weight"></a>5 font-weight</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>normal</code>（默认）</td>
<td>常规，相当于 <code>400</code></td>
</tr>
<tr>
<td><code>bold</code></td>
<td>加粗，相当于 <code>700</code></td>
</tr>
<tr>
<td><code>lighter</code></td>
<td>较细</td>
</tr>
<tr>
<td><code>bolder</code></td>
<td>较粗</td>
</tr>
<tr>
<td><code>&lt;number&gt;</code></td>
<td>介于 1 和 1000 (包含) 之间</td>
</tr>
</tbody></table>
<h3 id="6-font-variant-amp-font-stretch"><a href="#6-font-variant-amp-font-stretch" class="headerlink" title="6 font-variant &amp; font-stretch"></a>6 font-variant &amp; font-stretch</h3><ul>
<li>更像是专为英文设计的，默认即可</li>
</ul>
<h2 id="1-3-Unicode-字体"><a href="#1-3-Unicode-字体" class="headerlink" title="1.3 Unicode 字体"></a>1.3 Unicode 字体</h2><table>
<thead>
<tr>
<th>字体名称</th>
<th>英文名称</th>
<th>Unicode 编码</th>
</tr>
</thead>
<tbody><tr>
<td>宋体</td>
<td>SimSun</td>
<td>\5B8B\4F53</td>
</tr>
<tr>
<td>微软雅黑</td>
<td>Microsoft YaHei</td>
<td>\5FAE\8F6F\96C5\9ED1</td>
</tr>
<tr>
<td>新宋体</td>
<td>NSimSun</td>
<td>\65B0\5B8B\4F53</td>
</tr>
<tr>
<td>黑体</td>
<td>SimHei</td>
<td>\9ED1\4F53</td>
</tr>
<tr>
<td>楷体_GB2312</td>
<td>KaiTi_GB2312</td>
<td>\6977\4F53_GB2312</td>
</tr>
<tr>
<td>隶书</td>
<td>LiSu</td>
<td>\96B6\4E66</td>
</tr>
<tr>
<td>幼园</td>
<td>YouYuan</td>
<td>\5E7C\5706</td>
</tr>
<tr>
<td>华文细黑</td>
<td>STXihei</td>
<td>\534E\6587\7EC6\9ED1</td>
</tr>
<tr>
<td>细明体</td>
<td>MingLiU</td>
<td>\7EC6\660E\4F53</td>
</tr>
<tr>
<td>新细明体</td>
<td>PMingLiU</td>
<td>\65B0\7EC6\660E\4F53</td>
</tr>
</tbody></table>
<h2 id="1-4-color（字体颜色）"><a href="#1-4-color（字体颜色）" class="headerlink" title="1.4 color（字体颜色）"></a>1.4 color（字体颜色）</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>关键字</code></td>
<td><code>black red green blue ...</code></td>
</tr>
<tr>
<td><code>十六进制</code></td>
<td><code>#000 # FFF # 66CCFF ...</code></td>
</tr>
<tr>
<td><code>RGB</code></td>
<td><code>rgb(r, g, b [, a])</code>，<code>a</code> 透明度（0~1）</td>
</tr>
<tr>
<td><code>HSL</code></td>
<td><code>hsl(h, s, l [,a]</code></td>
</tr>
<tr>
<td><code>transparent</code></td>
<td>透明，可以近似认为是 <code>rgba(0,0,0,0)</code>的缩写</td>
</tr>
</tbody></table>
<h1 id="二-文本排版"><a href="#二-文本排版" class="headerlink" title="二 文本排版"></a>二 文本排版</h1><h2 id="2-1-text-indent"><a href="#2-1-text-indent" class="headerlink" title="2.1 text-indent"></a>2.1 text-indent</h2><ul>
<li>首行缩进量</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;length&gt;</code></td>
<td>长度值 <code>px em ...</code>，允许为负</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>使用包含块宽度的百分比作为缩进</td>
</tr>
</tbody></table>
<h2 id="2-2-text-align"><a href="#2-2-text-align" class="headerlink" title="2.2 text-align"></a>2.2 text-align</h2><ul>
<li>定义 <strong>文字、行内元素（inline，inline-block）</strong> 相对它的包围块元素水平对齐方式</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>left</code></td>
<td>左对齐</td>
</tr>
<tr>
<td><code>right</code></td>
<td>右对齐</td>
</tr>
<tr>
<td><code>center</code></td>
<td>居中对齐</td>
</tr>
<tr>
<td><code>justify</code></td>
<td>两端对齐，对最后一行无效</td>
</tr>
</tbody></table>
<h2 id="2-3-vertical-align"><a href="#2-3-vertical-align" class="headerlink" title="2.3 vertical-align"></a>2.3 vertical-align</h2><ul>
<li>定义 <strong>文字、行内元素（inline，inline-block，inline-table，table-cell）</strong>的垂直对齐方式</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>baseline</code>（默认）</td>
<td>相对于父元素基线对齐</td>
</tr>
<tr>
<td><code>middle</code></td>
<td>相对于与父元素中部对齐，<code>中部 = 基线 + x-heifht/2</code></td>
</tr>
<tr>
<td><code>top</code></td>
<td>相对于整行的顶部对齐</td>
</tr>
<tr>
<td><code>bottom</code></td>
<td>相对于整行底部对齐</td>
</tr>
</tbody></table>
<h2 id="2-4-text-overflow"><a href="#2-4-text-overflow" class="headerlink" title="2.4 text-overflow"></a>2.4 text-overflow</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>clip</code>（默认）</td>
<td>将溢出的文本裁减掉</td>
</tr>
<tr>
<td><code>ellipsis</code></td>
<td>将溢出的文本用省略号 <code>...</code> 来表示</td>
</tr>
</tbody></table>
<h2 id="2-5-overflow-wrap"><a href="#2-5-overflow-wrap" class="headerlink" title="2.5 overflow-wrap"></a>2.5 overflow-wrap</h2><ul>
<li>原 <code>word-wrap</code>，指定一个不可分割的字符串过长，超过容器盒的宽时应该如何处理</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th><code>CJK</code>（中日韩）</th>
<th><code>non-CJK</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>normal</code>（默认）</td>
<td>单个字符之间换行</td>
<td>在正常的单词结束处换行，保留完整性，可能会溢出容器）</td>
</tr>
<tr>
<td><code>break-word</code></td>
<td>单个字符之间换行</td>
<td>内容将在边界内换行。如果需要，单词内部允许断行</td>
</tr>
</tbody></table>
<h2 id="2-6-white-space"><a href="#2-6-white-space" class="headerlink" title="2.6 white-space"></a>2.6 white-space</h2><ul>
<li>设置如何处理空白（空格 <code>space</code>，制表符 <code>tab</code>，换行符 <code>enter</code>）</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>空白</th>
<th>换行</th>
</tr>
</thead>
<tbody><tr>
<td><code>normal</code>（默认）</td>
<td>空格、制表符、换行符合并成一个空格</td>
<td>文本自动换行</td>
</tr>
<tr>
<td><code>nowrap</code></td>
<td>空格、制表符、换行符合并成一个空格</td>
<td>文本不换行，即强制一行显示</td>
</tr>
<tr>
<td><code>pre</code></td>
<td>所有东西原样输出</td>
<td>文本不换行</td>
</tr>
<tr>
<td><code>pre-wrap</code></td>
<td>所有东西原样输出</td>
<td>文本换行</td>
</tr>
<tr>
<td><code>pre-line</code></td>
<td>空格、制表符合并成一个空格，换行符不变</td>
<td>文本换行</td>
</tr>
<tr>
<td><code>break-spaces</code></td>
<td>同<code>pre-wrap</code>，但有一些区别</td>
<td></td>
</tr>
</tbody></table>
<h2 id="2-7-word-break"><a href="#2-7-word-break" class="headerlink" title="2.7 word-break"></a>2.7 word-break</h2><ul>
<li>控制单词如何被拆分</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th><code>CJK</code>（中日韩）</th>
<th><code>non-CJK</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>normal</code>（默认）</td>
<td>可在任意 2 个字符间断行</td>
<td>只能再空白符处断行</td>
</tr>
<tr>
<td><code>keep-all</code></td>
<td>只能在空白符处断行</td>
<td>只能在空白符处断行</td>
</tr>
<tr>
<td><code>break-all</code></td>
<td>可在任意位置断行</td>
<td>可在任意位置断行</td>
</tr>
</tbody></table>
<h2 id="2-8-word-spacing"><a href="#2-8-word-spacing" class="headerlink" title="2.8 word-spacing"></a>2.8 word-spacing</h2><ul>
<li>设置单词之间的距离，中文无效</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>normal</code>（默认）</td>
<td>常规</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>长度 <code>px em ...</code></td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>百分比</td>
</tr>
</tbody></table>
<h2 id="2-9-letter-spacing"><a href="#2-9-letter-spacing" class="headerlink" title="2.9 letter-spacing"></a>2.9 letter-spacing</h2><ul>
<li>设置字符之间的距离，中文有效</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>normal</code>（默认）</td>
<td>常规</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>长度 <code>px em ...</code></td>
</tr>
</tbody></table>
<h1 id="三-文本装饰"><a href="#三-文本装饰" class="headerlink" title="三 文本装饰"></a>三 文本装饰</h1><h2 id="3-1-text-decoration"><a href="#3-1-text-decoration" class="headerlink" title="3.1 text-decoration"></a>3.1 text-decoration</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">text-decoration-line ||</span><br><span class="line">text-decoration-style ||</span><br><span class="line">text-decoration-color ||</span><br><span class="line"><span class="selector-tag">text-decoration-thickness</span></span><br></pre></td></tr></table></figure>

<h3 id="1-text-decoration-line"><a href="#1-text-decoration-line" class="headerlink" title="1 text-decoration-line"></a>1 text-decoration-line</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code>（默认）</td>
<td>无线</td>
</tr>
<tr>
<td><code>underline</code></td>
<td>下划线</td>
</tr>
<tr>
<td><code>overline</code></td>
<td>上划线</td>
</tr>
<tr>
<td><code>line-through</code></td>
<td>删除线</td>
</tr>
</tbody></table>
<h3 id="2-text-decoration-style"><a href="#2-text-decoration-style" class="headerlink" title="2 text-decoration-style"></a>2 text-decoration-style</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>solid</code>（默认）</td>
<td>单实线</td>
</tr>
<tr>
<td><code>double</code></td>
<td>双实线</td>
</tr>
<tr>
<td><code>dotted</code></td>
<td>点划线</td>
</tr>
<tr>
<td><code>dashed</code></td>
<td>虚线</td>
</tr>
<tr>
<td><code>wavy</code></td>
<td>波浪线</td>
</tr>
</tbody></table>
<h3 id="3-text-decoration-color"><a href="#3-text-decoration-color" class="headerlink" title="3 text-decoration-color"></a>3 text-decoration-color</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;color&gt;</code></td>
<td>设置装饰线的颜色</td>
</tr>
</tbody></table>
<h3 id="4-text-decoration-thickness"><a href="#4-text-decoration-thickness" class="headerlink" title="4 text-decoration-thickness"></a>4 text-decoration-thickness</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code></td>
<td>浏览器为文本装饰线选择合适的宽度</td>
</tr>
<tr>
<td><code>from-font</code></td>
<td>如果字体文件中包含了首选的宽度值，则使用此字体文件的宽度值，否则同auto</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>指定装饰线宽度 <code>px em ...</code></td>
</tr>
</tbody></table>
<h2 id="3-2-text-transform"><a href="#3-2-text-transform" class="headerlink" title="3.2 text-transform"></a>3.2 text-transform</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code>（默认）</td>
<td>无影响</td>
</tr>
<tr>
<td><code>capitalize</code></td>
<td>每个单词首字母大写</td>
</tr>
<tr>
<td><code>uppercase</code></td>
<td>所有字母大写</td>
</tr>
<tr>
<td><code>lowercase</code></td>
<td>所有字母小写</td>
</tr>
</tbody></table>
<h2 id="3-3-text-shadow"><a href="#3-3-text-shadow" class="headerlink" title="3.3 text-shadow"></a>3.3 text-shadow</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[&lt;length&gt; &lt;length&gt;]   // 元素在 X 和 Y 方向的偏移量（必须）</span><br><span class="line">&lt;length&gt;? ||		// 模糊半径（可选）</span><br><span class="line">color?		// 阴影颜色（可选）</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>CSS选择器</title>
    <url>/anyeansan.github.io/2020/11/08/UI/CSS%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="一-权重"><a href="#一-权重" class="headerlink" title="一 权重"></a>一 权重</h1><table>
<thead>
<tr>
<th>规则</th>
<th>粒度</th>
</tr>
</thead>
<tbody><tr>
<td><code>!important</code></td>
<td><code>∞</code></td>
</tr>
<tr>
<td><code>行内样式 style</code></td>
<td><code>1, 0, 0, 0</code></td>
</tr>
<tr>
<td><code>id</code></td>
<td><code>0, 1, 0, 0</code></td>
</tr>
<tr>
<td><code>class</code>，<code>伪类</code>，<code>属性</code></td>
<td><code>0, 0, 1, 0</code></td>
</tr>
<tr>
<td><code>标签</code>，<code>伪元素</code></td>
<td><code>0, 0, 0, 1</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td><code>0, 0, 0, 0</code></td>
</tr>
<tr>
<td><code>继承</code></td>
<td><code>null</code>（继承没有权重，比 <code>0</code> 小）</td>
</tr>
</tbody></table>
<ol>
<li>比较样式的优先级：算出所有选择器权重之和，然后从左到右比较大小</li>
<li>注意四个数有低位高位的概念，但不会进位，如 <code>0,0,0,8 + 0,0,0,7 = 0,0,0,15</code></li>
</ol>
<h1 id="二-基础选择器"><a href="#二-基础选择器" class="headerlink" title="二 基础选择器"></a>二 基础选择器</h1><table>
<thead>
<tr>
<th>选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>html</code></td>
<td>标签选择器</td>
</tr>
<tr>
<td><code>#id</code></td>
<td>id 选择器</td>
</tr>
<tr>
<td><code>.class</code></td>
<td>class 选择器</td>
</tr>
<tr>
<td><code>*</code></td>
<td>通配选择器</td>
</tr>
<tr>
<td><code>S₁, S₂, S₃, ...</code></td>
<td>并集</td>
</tr>
<tr>
<td><code>S₁S₂S₃...</code></td>
<td>交集</td>
</tr>
</tbody></table>
<h1 id="三-关系选择器"><a href="#三-关系选择器" class="headerlink" title="三 关系选择器"></a>三 关系选择器</h1><table>
<thead>
<tr>
<th>关系选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>A E</code></td>
<td>E 为 A 的后代元素</td>
</tr>
<tr>
<td><code>A &gt; E</code></td>
<td>E 为 A 的子元素</td>
</tr>
<tr>
<td><code>A ~ E</code></td>
<td>E 为 A 的兄弟元素</td>
</tr>
<tr>
<td><code>A + E</code></td>
<td>E 为 A 的下一个兄弟元素</td>
</tr>
</tbody></table>
<h1 id="三-属性选择器"><a href="#三-属性选择器" class="headerlink" title="三 属性选择器"></a>三 属性选择器</h1><table>
<thead>
<tr>
<th>属性选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>[attr]</code></td>
<td>带有 <code>attr</code> 属性的元素</td>
</tr>
<tr>
<td><code>[attr=value]</code></td>
<td><code>attr</code> 属性值为 <code>value</code> 的元素</td>
</tr>
<tr>
<td><code>[attr^=value]</code></td>
<td><code>attr</code> 属性值以 <code>value</code> 开头的元素</td>
</tr>
<tr>
<td><code>[attr$=value]</code></td>
<td><code>attr</code> 属性值以 <code>value</code> 结尾的元素</td>
</tr>
<tr>
<td><code>[attr*=value]</code></td>
<td><code>attr</code> 属性值包含 <code>value</code> 的元素</td>
</tr>
</tbody></table>
<h1 id="四-伪类选择器"><a href="#四-伪类选择器" class="headerlink" title="四 伪类选择器"></a>四 伪类选择器</h1><h2 id="4-1-链接伪类"><a href="#4-1-链接伪类" class="headerlink" title="4.1 链接伪类"></a>4.1 链接伪类</h2><table>
<thead>
<tr>
<th>选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>:link</code></td>
<td>未访问</td>
</tr>
<tr>
<td><code>:visited</code></td>
<td>已访问</td>
</tr>
<tr>
<td><code>:hover</code></td>
<td>悬停</td>
</tr>
<tr>
<td><code>:active</code></td>
<td>点击</td>
</tr>
</tbody></table>
<ol>
<li>只能用于 <code>&lt;a&gt; &lt;button&gt;</code>，且按顺序 <code>LVHA</code></li>
<li>其它标签也能用，但有兼容性问题 </li>
</ol>
<h2 id="4-2-结构伪类"><a href="#4-2-结构伪类" class="headerlink" title="4.2 结构伪类"></a>4.2 结构伪类</h2><ol>
<li><p>所有类型子元素从 1 开始编号（可以指定类型，如  <code>E:nth-child(3)</code>，但对应编号必须是此类型，否则取不到）</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>:first-child</code></td>
<td>第一个子元素</td>
</tr>
<tr>
<td><code>:last-child</code></td>
<td>最后一个子元素</td>
</tr>
<tr>
<td><code>:noly-child</code></td>
<td>唯一子元素</td>
</tr>
<tr>
<td><code>:nth-child(表达式)</code></td>
<td>从前向后匹配符合表达式结果的子元素</td>
</tr>
<tr>
<td><code>:nth-last-child(表达式)</code></td>
<td>从后向前匹配符合表达式结果的子元素</td>
</tr>
</tbody></table>
</li>
<li><p>所有指定类型子元素从 1 开始编号（若不指定类型则默认父元素类型）</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>:fitst-of-type</code></td>
<td>第一个指定类型的子元素</td>
</tr>
<tr>
<td><code>:last-of-type</code></td>
<td>最后一个指定类型的子元素</td>
</tr>
<tr>
<td><code>:noly-of-type</code></td>
<td>唯一指定类型的子元素</td>
</tr>
<tr>
<td><code>:nth-of-type(表达式)</code></td>
<td>从前向后匹配符合表达式结果的指定类型的子元素</td>
</tr>
<tr>
<td><code>:nth-last-of-type(表达式)</code></td>
<td>从后向前匹配符合表达式结果的指定类型的子元素</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>An+B</code></td>
<td><code>A B</code> 为整数，<code>n</code> 为 非负整数</td>
</tr>
<tr>
<td><code>odd</code></td>
<td>奇数</td>
</tr>
<tr>
<td><code>even</code></td>
<td>偶数</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="4-3-状态伪类"><a href="#4-3-状态伪类" class="headerlink" title="4.3 状态伪类"></a>4.3 状态伪类</h2><table>
<thead>
<tr>
<th>选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>:checked</code></td>
<td>选中的 <code>radio checkbox option</code></td>
</tr>
<tr>
<td><code>:default</code></td>
<td>默认选中的 <code>radio checkbox option</code></td>
</tr>
<tr>
<td><code>:disabled</code></td>
<td>禁用的元素</td>
</tr>
<tr>
<td><code>:enabled</code></td>
<td>启用的元素</td>
</tr>
<tr>
<td><code>:empty</code></td>
<td>没有子元素的元素</td>
</tr>
<tr>
<td><code>:focus</code></td>
<td>获取焦点的元素</td>
</tr>
<tr>
<td><code>:not()</code></td>
<td>非（权重由括号内决定，自身0，不支持复杂选择器）</td>
</tr>
</tbody></table>
<h1 id="五-伪元素选择器"><a href="#五-伪元素选择器" class="headerlink" title="五 伪元素选择器"></a>五 伪元素选择器</h1><table>
<thead>
<tr>
<th>伪元素选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>::before</code></td>
<td>创建一个伪元素（行内元素），作为元素的第一个子元素</td>
</tr>
<tr>
<td><code>::after</code></td>
<td>创建一个伪元素（行内元素），作为元素的最后一个子元素</td>
</tr>
<tr>
<td><code>::first-letter</code></td>
<td>匹配块级元素第一行的第一个字母</td>
</tr>
<tr>
<td><code>::first-line</code></td>
<td>匹配块级元素第一行</td>
</tr>
<tr>
<td><code>::selection</code></td>
<td>匹配被用户选中或者处于高亮状态的部分</td>
</tr>
</tbody></table>
<ul>
<li><code>::before, ::after</code> 必须有 <code>content</code> 属性</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>CSS语法</title>
    <url>/anyeansan.github.io/2020/11/08/UI/CSS%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-CSS"><a href="#1-1-CSS" class="headerlink" title="1.1 CSS"></a>1.1 CSS</h2><ol>
<li><code>Cascading Style Sheets</code> 层叠样式表</li>
<li>负责页面的布局和样式</li>
</ol>
<h2 id="1-2-相关"><a href="#1-2-相关" class="headerlink" title="1.2 相关"></a>1.2 相关</h2><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>CSS1 &amp; CSS2</code></td>
<td>单一规范</td>
</tr>
<tr>
<td><code>CSS3</code></td>
<td>内容增多，CSS 划分了多个模块</td>
</tr>
<tr>
<td><code>less css</code></td>
<td>一种简化的功能更多的 css 语言</td>
</tr>
<tr>
<td><code>sass</code></td>
<td>一种简化的功能更多的 css 语言</td>
</tr>
<tr>
<td><code>postcss</code></td>
<td>一种 css 处理程序</td>
</tr>
</tbody></table>
<h1 id="二-CSS-样式"><a href="#二-CSS-样式" class="headerlink" title="二 CSS 样式"></a>二 CSS 样式</h1><h2 id="2-1-语法"><a href="#2-1-语法" class="headerlink" title="2.1 语法"></a>2.1 语法</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* CSS 注释 */</span></span><br><span class="line">选择器 &#123;</span><br><span class="line">	属性 : 值;</span><br><span class="line">	属性 : 值1 值2 值3 ...;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Html-引入-CSS的方式"><a href="#2-2-Html-引入-CSS的方式" class="headerlink" title="2.2 Html 引入 CSS的方式"></a>2.2 Html 引入 CSS的方式</h2><ol>
<li><p>行内样式（内联样式）：每个 html 标签都有一个 <strong>style 属性</strong>，该属性的值就是 css 样式</p>
</li>
<li><p>内部样式（内嵌样式）：在当前页面的 <code>&lt;style&gt;</code> 标签中书写 css 样式</p>
</li>
<li><p>外部样式（外链样式）：在外部 <code>.css</code> 文件中书写 css 样式，之后导入当前页面</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 方式 1 */</span></span><br><span class="line">&lt;link rel="stylesheet" type="text/css" href=".css 文件路径"&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方式 2 */</span></span><br><span class="line">@<span class="keyword">import</span> url(<span class="string">".css 文件路径"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>link</code> 和 <code>@import</code> 方式的区别<ol>
<li><code>link</code> 属于 HTML 标签，而 <code>@import</code> 是 CSS 提供的，需要写在 <code>&lt;style&gt;</code> 中</li>
<li><code>@import</code> 只在 IE 5 以上才能识别，而 <code>link</code> 是 HTML 标签，无兼容问题</li>
<li>页面被加载时，<code>link</code> 会同时被加载，而 <code>@import</code> 引用的 CSS 会等到页面被加载完再加载</li>
<li><code>link</code> 方式的样式的权重高于 <code>@import</code> 权重</li>
<li><code>@import</code> 不支持js的动态修改</li>
<li>一般推荐<code>link</code>，<code>@import</code> 补充使用</li>
</ol>
</li>
</ul>
</li>
</ol>
<h1 id="三-CSS-文档语法中的符号说明"><a href="#三-CSS-文档语法中的符号说明" class="headerlink" title="三 CSS 文档语法中的符号说明"></a>三 CSS 文档语法中的符号说明</h1><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>[]</td>
<td>表示组</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>空格前后的各部分必须按顺序出现</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>各部分必须出现，但可以不按顺序</td>
</tr>
<tr>
<td>&#124;&#124;</td>
<td>各部分至少出现一个，可以不按顺序</td>
</tr>
<tr>
<td>&#124;</td>
<td>各部分只能出现一个</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>值类型</td>
</tr>
<tr>
<td>*</td>
<td>任意次数</td>
</tr>
<tr>
<td>?</td>
<td>零次或一次</td>
</tr>
<tr>
<td>+</td>
<td>一次或多次</td>
</tr>
<tr>
<td>#</td>
<td>一次或多次，多次出现必须以逗号分隔</td>
</tr>
<tr>
<td>{m,n}</td>
<td>至少m次，至多n次</td>
</tr>
<tr>
<td>!</td>
<td>组后面的叹号表示该组是必需的，并且至少产生一个值；即使组内项目的语法允许省略全部的值，也至少要保留一个值</td>
</tr>
</tbody></table>
<h1 id="四-CSS-属性值单位"><a href="#四-CSS-属性值单位" class="headerlink" title="四 CSS 属性值单位"></a>四 CSS 属性值单位</h1><h2 id="4-1-lt-length-gt"><a href="#4-1-lt-length-gt" class="headerlink" title="4.1 &lt;length&gt;"></a>4.1 <code>&lt;length&gt;</code></h2><table>
<thead>
<tr>
<th>单位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>px</code></td>
<td>像素</td>
</tr>
<tr>
<td><code>rem</code></td>
<td>相对于根元素的字体大小 <code>&lt;html&gt;</code></td>
</tr>
<tr>
<td><code>em</code></td>
<td>相对于父元素的字体大小</td>
</tr>
<tr>
<td><code>ex</code></td>
<td>相对于小写字母 <code>x</code> 的高度即 <code>x-height</code></td>
</tr>
<tr>
<td><code>ch</code></td>
<td>相对于字符数字 <code>0</code> 的宽度</td>
</tr>
<tr>
<td><code>vw</code></td>
<td>相对于视窗的宽度：视窗宽度是100 vw</td>
</tr>
<tr>
<td><code>vh</code></td>
<td>相对于视窗的高度：视窗高度是100 vh</td>
</tr>
<tr>
<td><code>vmin</code></td>
<td>等于 <code>vh</code> 和 <code>vw</code> 中较小的值</td>
</tr>
<tr>
<td><code>vmax</code></td>
<td>等于 <code>vh</code> 和 <code>vw</code> 中较大的值</td>
</tr>
</tbody></table>
<h2 id="4-2-lt-angle-gt"><a href="#4-2-lt-angle-gt" class="headerlink" title="4.2 &lt;angle&gt;"></a>4.2 <code>&lt;angle&gt;</code></h2><table>
<thead>
<tr>
<th>单位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>deg</code></td>
<td>角度，一个完整圆角度是 <code>360deg</code></td>
</tr>
<tr>
<td><code>rad</code></td>
<td>弧度，一个完整圆弧度是 <code>2π</code></td>
</tr>
<tr>
<td><code>turn</code></td>
<td>圈数，一个完整圆圈数是 <code>1turn</code></td>
</tr>
</tbody></table>
<h2 id="4-3-lt-time-gt"><a href="#4-3-lt-time-gt" class="headerlink" title="4.3 &lt;time&gt;"></a>4.3 <code>&lt;time&gt;</code></h2><table>
<thead>
<tr>
<th>单位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>s</td>
<td>秒</td>
</tr>
<tr>
<td>ms</td>
<td>毫秒</td>
</tr>
</tbody></table>
<h2 id="4-4-lt-frequency-gt-（频率）"><a href="#4-4-lt-frequency-gt-（频率）" class="headerlink" title="4.4 &lt;frequency&gt; （频率）"></a>4.4 <code>&lt;frequency&gt;</code> （频率）</h2><table>
<thead>
<tr>
<th>单位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Hz</code></td>
<td>赫兹</td>
</tr>
<tr>
<td><code>kHz</code></td>
<td>千赫兹</td>
</tr>
</tbody></table>
<h2 id="4-5-lt-resolution-gt-（分辨率）"><a href="#4-5-lt-resolution-gt-（分辨率）" class="headerlink" title="4.5 &lt;resolution&gt; （分辨率）"></a>4.5 <code>&lt;resolution&gt;</code> （分辨率）</h2><table>
<thead>
<tr>
<th>单位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>dpi</code></td>
<td>表示每英寸点数</td>
</tr>
<tr>
<td><code>dpcm</code></td>
<td>表示每厘米点数</td>
</tr>
<tr>
<td><code>dppx</code></td>
<td>表示每像素点数</td>
</tr>
<tr>
<td><code>x</code></td>
<td><code>dppx</code> 的别名</td>
</tr>
</tbody></table>
<h1 id="五-CSS-属性值类型"><a href="#五-CSS-属性值类型" class="headerlink" title="五 CSS 属性值类型"></a>五 CSS 属性值类型</h1><h2 id="5-1-文本类型"><a href="#5-1-文本类型" class="headerlink" title="5.1 文本类型"></a>5.1 文本类型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>取值</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;string&gt;</code></td>
<td><code>&#39;&#39;, &quot;&quot;</code></td>
</tr>
<tr>
<td><code>&lt;url&gt;</code></td>
<td><code>url(绝对/相对地址，地址不建议加引号)</code></td>
</tr>
</tbody></table>
<h2 id="5-2-数值类型"><a href="#5-2-数值类型" class="headerlink" title="5.2 数值类型"></a>5.2 数值类型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>取值</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;integer&gt;</code></td>
<td>整数，可以有正负 <code>+ -</code></td>
</tr>
<tr>
<td><code>&lt;number&gt;</code></td>
<td>整数或小数，可以有正负 <code>+ -</code></td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td><code>%</code></td>
</tr>
<tr>
<td><code>&lt;dimension&gt;</code></td>
<td>尺寸，由数字和单位构成，即 <code>&lt;number&gt; + unit = &lt;dimension&gt;</code></td>
</tr>
</tbody></table>
<h2 id="5-3-lt-color-gt"><a href="#5-3-lt-color-gt" class="headerlink" title="5.3 &lt;color&gt;"></a>5.3 <code>&lt;color&gt;</code></h2><table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>颜色关键字</code></td>
<td><code>black red green blue white yelow ...</code></td>
</tr>
<tr>
<td><code>transparent</code></td>
<td>透明，可以近似认为是 <code>rgba(0,0,0,0)</code>的缩写</td>
</tr>
<tr>
<td><code>currentColor</code></td>
<td>当前元素的字体颜色，即 <code>color</code> 的值</td>
</tr>
<tr>
<td><code>#十六进制</code></td>
<td><code>#000 #FFF #1234AB ...</code></td>
</tr>
<tr>
<td><code>RGB</code></td>
<td><code>rgb(r, g, b)</code>，可以使用数值和百分比</td>
</tr>
<tr>
<td><code>RGBA</code></td>
<td><code>rgba(r, g, b, a)</code>，a：<code>alpha</code>，透明度（0~1）</td>
</tr>
<tr>
<td><code>HSL</code></td>
<td><code>hsl(h, s, l)</code>，色调（0<del>360），饱和度（0%</del>100%），亮度（0%~100%）</td>
</tr>
<tr>
<td><code>HSLA</code></td>
<td><code>hsla(h, s, l, a)</code></td>
</tr>
</tbody></table>
<h2 id="5-4-lt-color-stop-gt"><a href="#5-4-lt-color-stop-gt" class="headerlink" title="5.4 &lt;color-stop&gt;"></a>5.4 <code>&lt;color-stop&gt;</code></h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 使用长度或百分比指定颜色起止位置，如果省略，默认 50% */</span></span><br><span class="line">&lt;<span class="selector-tag">color</span>&gt; <span class="selector-attr">[ &lt;length&gt; | &lt;percentage&gt; ]</span>?</span><br></pre></td></tr></table></figure>

<h2 id="5-5-lt-image-gt"><a href="#5-5-lt-image-gt" class="headerlink" title="5.5 &lt;image&gt;"></a>5.5 <code>&lt;image&gt;</code></h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;url&gt;</code></td>
<td><code>url(绝对/相对地址，地址不建议加引号)</code></td>
</tr>
<tr>
<td><code>&lt;gradient&gt;</code></td>
<td>使用渐变</td>
</tr>
<tr>
<td><code>element()</code></td>
<td>可以把页面元素当作背景图片</td>
</tr>
</tbody></table>
<h2 id="5-6-lt-position-gt"><a href="#5-6-lt-position-gt" class="headerlink" title="5.6 &lt;position&gt;"></a>5.6 <code>&lt;position&gt;</code></h2><ul>
<li><code>x轴 y轴</code>，如果只设置一个值，则另一个默认居中</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>位置关键字</code></td>
<td><code>left right top bottom center</code></td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>指定长度</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>指定百分比</td>
</tr>
</tbody></table>
<h2 id="5-7-lt-gradient-gt"><a href="#5-7-lt-gradient-gt" class="headerlink" title="5.7 &lt;gradient&gt;"></a>5.7 <code>&lt;gradient&gt;</code></h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>linear-gradient()</code></td>
<td>线性渐变，颜色值沿着一条隐式的直线逐渐过渡</td>
</tr>
<tr>
<td><code>radial-gradient()</code></td>
<td>径向渐变，颜色值由一个中心点（原点）向外扩散并逐渐过渡到其他颜色值</td>
</tr>
<tr>
<td><code>repeating-linear-gradient()</code></td>
<td>重复线性渐变，重复多次渐变图案直到足够填满指定元素</td>
</tr>
<tr>
<td><code>repeating-radial-gradient()</code></td>
<td>重复径向渐变</td>
</tr>
<tr>
<td><code>conic-gradient()</code></td>
<td>锥形渐变，颜色值围绕圆逐渐过渡</td>
</tr>
</tbody></table>
<h3 id="1-线性渐变"><a href="#1-线性渐变" class="headerlink" title="1 线性渐变"></a>1 线性渐变</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&lt;angle&gt; | [to [ left | right ] || [ top | bottom ]] ,]?</span><br><span class="line">&lt;color-stop&gt; [, &lt;color-stop&gt;]+</span><br></pre></td></tr></table></figure>

<h4 id="1-第一行用于指定渐变方向"><a href="#1-第一行用于指定渐变方向" class="headerlink" title="1 第一行用于指定渐变方向"></a>1 第一行用于指定渐变方向</h4><h5 id="1-角度"><a href="#1-角度" class="headerlink" title="1 角度"></a>1 角度</h5><table>
<thead>
<tr>
<th>例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>0deg</code></td>
<td>向上，即 <code>to top</code></td>
</tr>
<tr>
<td><code>45deg</code></td>
<td>右上，即 <code>to right top</code></td>
</tr>
<tr>
<td><code>90deg</code></td>
<td>向右，即 <code>to right</code></td>
</tr>
<tr>
<td><code>180deg</code></td>
<td>向下，即 <code>to bottom</code></td>
</tr>
</tbody></table>
<h5 id="2-方向关键字"><a href="#2-方向关键字" class="headerlink" title="2 方向关键字"></a>2 方向关键字</h5><table>
<thead>
<tr>
<th>例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>to left</code></td>
<td>向左</td>
</tr>
<tr>
<td><code>to left top</code></td>
<td>左上</td>
</tr>
<tr>
<td><code>to left bottom</code></td>
<td>左下</td>
</tr>
<tr>
<td><code>to right</code></td>
<td>向右</td>
</tr>
<tr>
<td><code>to right top</code></td>
<td>右上</td>
</tr>
<tr>
<td><code>to right bottom</code></td>
<td>右下</td>
</tr>
<tr>
<td><code>to top</code></td>
<td>向上</td>
</tr>
<tr>
<td><code>to bottom</code></td>
<td>向下</td>
</tr>
</tbody></table>
<h4 id="2-第二行指定颜色以及颜色起止位置"><a href="#2-第二行指定颜色以及颜色起止位置" class="headerlink" title="2 第二行指定颜色以及颜色起止位置"></a>2 第二行指定颜色以及颜色起止位置</h4><table>
<thead>
<tr>
<th>例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;color&gt;, &lt;color&gt;, ...</code></td>
<td>至少有两个颜色，不指定位置则颜色平均分配</td>
</tr>
<tr>
<td><code>&lt;color&gt; &lt;length&gt;, &lt;color&gt; &lt;percentage&gt;, ...</code></td>
<td>可以使用长度或百分比指定颜色所占的范围</td>
</tr>
</tbody></table>
<h3 id="2-径向渐变"><a href="#2-径向渐变" class="headerlink" title="2 径向渐变"></a>2 径向渐变</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[ &lt;ending-shape&gt; || &lt;size&gt; ]? [ at &lt;position&gt; ]? ,]?</span><br><span class="line"> &lt;color-stop&gt; [, &lt;color-stop&gt;]+</span><br></pre></td></tr></table></figure>

<h4 id="1-第一行指定渐变形状大小和位置"><a href="#1-第一行指定渐变形状大小和位置" class="headerlink" title="1 第一行指定渐变形状大小和位置"></a>1 第一行指定渐变形状大小和位置</h4><h5 id="1-形状-ending-shape"><a href="#1-形状-ending-shape" class="headerlink" title="1 形状 ending-shape"></a>1 形状 <code>ending-shape</code></h5><table>
<thead>
<tr>
<th>形状</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ellipse</code>（默认）</td>
<td>椭圆</td>
</tr>
<tr>
<td><code>circle</code></td>
<td>圆形</td>
</tr>
</tbody></table>
<h5 id="2-大小-size"><a href="#2-大小-size" class="headerlink" title="2 大小 size"></a>2 大小 <code>size</code></h5><table>
<thead>
<tr>
<th>大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>closest-side</code></td>
<td>近边</td>
</tr>
<tr>
<td><code>farthest-side</code></td>
<td>远边</td>
</tr>
<tr>
<td><code>closest-corner</code></td>
<td>近角</td>
</tr>
<tr>
<td><code>farthest-corner</code></td>
<td>远角</td>
</tr>
</tbody></table>
<h1 id="六-CSS-属性书写顺序"><a href="#六-CSS-属性书写顺序" class="headerlink" title="六 CSS 属性书写顺序"></a>六 CSS 属性书写顺序</h1><table>
<thead>
<tr>
<th>顺序</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1 布局定位属性</td>
<td><code>display position float clear visibility overflow</code></td>
</tr>
<tr>
<td>2 自身属性</td>
<td><code>width height margin padding border background</code></td>
</tr>
<tr>
<td>3 文本属性</td>
<td><code>color font text-decoration text-align vertical-align white-space break-word</code></td>
</tr>
<tr>
<td>4 其它属性（CSS 3）</td>
<td><code>content cursor border-raduis box-shadow text-shadow 渐变</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>Emmet</title>
    <url>/anyeansan.github.io/2020/11/08/UI/Emmet/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>Emmet (前身为 Zen Coding) 是一个能大幅度提高前端开发效率的一个工具</li>
<li>语法默认以 <code>tab</code> 结束</li>
</ol>
<h1 id="二-语法"><a href="#二-语法" class="headerlink" title="二 语法"></a>二 语法</h1><h2 id="2-1-Html"><a href="#2-1-Html" class="headerlink" title="2.1 Html"></a>2.1 Html</h2><h3 id="1-元素"><a href="#1-元素" class="headerlink" title="1 元素"></a>1 元素</h3><ol>
<li><p>快速生成Html模板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!</span><br><span class="line">html:5</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用元素名称生成html标签：<code>元素名</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// div</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数量：<code>元素名*num</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// li*3</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自增符号：<code>$</code> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// div.$*3</span><br><span class="line">&lt;div class=&quot;1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;3&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// div.$$*3</span><br><span class="line">&lt;div class=&quot;01&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;02&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;03&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// 使用`@`来表示从第几开始</span><br><span class="line">// div.$@4*3</span><br><span class="line">&lt;div class=&quot;4&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;5&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;6&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-层级"><a href="#2-层级" class="headerlink" title="2 层级"></a>2 层级</h3><ol>
<li><p>父子：<code>父元素&gt;子元素</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// div&gt;ul&gt;li&gt;a</span><br><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;ul&gt;</span><br><span class="line">		&lt;li&gt;</span><br><span class="line">			&lt;a&gt;&lt;/a&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">	&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>兄弟：<code>兄元素+弟元素</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// div+span+p</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;span&gt;&lt;/span&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：会先算兄弟后算父子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// div&gt;p+a</span><br><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;p&gt;&lt;/p&gt;</span><br><span class="line">	&lt;a href=&quot;&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优先级：<code>()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// div&gt;(header&gt;ul&gt;li*2)+footer</span><br><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;header&gt;</span><br><span class="line">		&lt;ul&gt;</span><br><span class="line">			&lt;li&gt;&lt;/li&gt;</span><br><span class="line">			&lt;li&gt;&lt;/li&gt;</span><br><span class="line">		&lt;/ul&gt;</span><br><span class="line">	&lt;/header&gt;</span><br><span class="line">	&lt;footer&gt;&lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="3-属性"><a href="#3-属性" class="headerlink" title="3 属性"></a>3 属性</h3><ol>
<li><p>创建带 id 的标签：<code>元素名#id</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// div#test</span><br><span class="line">&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建带 class 的标签：<code>元素名.class</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// div.test</span><br><span class="line">&lt;div class=&quot;test&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// div.test1.test2.test3</span><br><span class="line">&lt;div class=&quot;test1 test2 test3&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建带属性的标签：<code>元素名[属性名=&#39;属性值&#39;]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// div[girl=&quot;beauty&quot;]</span><br><span class="line">&lt;div girl=&quot;beauty&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建带内容的标签：<code>元素名{内容}</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// div&#123;haha&#125;</span><br><span class="line">&lt;div&gt;haha&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// #test</span><br><span class="line">&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// .test</span><br><span class="line">&lt;div class=&quot;test&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// ul&gt;.class</span><br><span class="line"> &lt;ul&gt;</span><br><span class="line">	&lt;li class=&quot;class&quot;&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="2-2-CSS"><a href="#2-2-CSS" class="headerlink" title="2.2 CSS"></a>2.2 CSS</h2><ol>
<li><p>常见的CSS样式可以使用省略写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// w20</span><br><span class="line">width: 20px;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>HTML</title>
    <url>/anyeansan.github.io/2020/11/08/UI/HTML/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li><p>HTML（Hyper Text Markup Language）：超文本标记语言</p>
</li>
<li><p>XHTML：可扩展超文本标记语言，是更严格更纯净的 HTML 版本</p>
</li>
<li><p>WEB 标准：W3C 组织及其它标准化组织制定的一系列标准的集合</p>
<ul>
<li><p>结构：Html</p>
</li>
<li><p>表现：Css</p>
</li>
<li><p>行为：Javascript</p>
</li>
</ul>
</li>
</ol>
<h1 id="二-标签"><a href="#二-标签" class="headerlink" title="二 标签"></a>二 标签</h1><h2 id="2-1-文档声明"><a href="#2-1-文档声明" class="headerlink" title="2.1 文档声明"></a>2.1 文档声明</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 告诉浏览器使用哪个 Html 版本显示 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-结构标签"><a href="#2-2-结构标签" class="headerlink" title="2.2 结构标签"></a>2.2 结构标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-lt-html-gt"><a href="#1-lt-html-gt" class="headerlink" title="1 &lt;html&gt;"></a>1 <code>&lt;html&gt;</code></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">""</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>lang 属性<ol>
<li>作用<ul>
<li>搜索引擎无法判断页面中的内容是什么语言，需要我们告诉它</li>
<li>浏览器会将读取到的页面语言和本地语言进行比较判断，如果一致，不做处理，否则提示是否需要翻译（如果有此功能），有时候明明页面是中文由于设置的 <code>lang=&quot;en&quot;</code>，还会提示是否翻译，就是此原因</li>
</ul>
</li>
<li>取值<ul>
<li>英文<ul>
<li><code>en</code></li>
</ul>
</li>
<li>中文<ul>
<li><code>zh-CN</code> 用的最多其实已过时</li>
<li><code>zh-Hans</code> 简体中文</li>
<li><code>zh-cmn-Hans</code> 以简体中文书写的普通话用词</li>
<li><code>zh-yue-Hans</code> 以简体中文书写的粤语用词</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="2-lt-head-gt"><a href="#2-lt-head-gt" class="headerlink" title="2 &lt;head&gt;"></a>2 <code>&lt;head&gt;</code></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文档元数据定义在 head 标签中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">		width：视口 viewport 宽度</span></span><br><span class="line"><span class="comment">		initial-scale：初始缩放比</span></span><br><span class="line"><span class="comment">		maximum-scale：最大缩放比</span></span><br><span class="line"><span class="comment">		minimum-scale：最小缩放比</span></span><br><span class="line"><span class="comment">		user-scalable：是否可以缩放</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, maximu-scale=1.0, minimum-scale=1.0, user-scalable=n0"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">""</span> <span class="attr">content</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"此页面中所有相对 URL 的根 URL"</span> <span class="attr">target</span>=<span class="string">"此页面新连接的打开方式 _self 或 _blank"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">link</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-lt-body-gt-中的标签"><a href="#2-4-lt-body-gt-中的标签" class="headerlink" title="2.4 &lt;body&gt; 中的标签"></a>2.4 <code>&lt;body&gt;</code> 中的标签</h2><h3 id="1-语义化标签"><a href="#1-语义化标签" class="headerlink" title="1 语义化标签"></a>1 语义化标签</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/Html/yuyibq.png" alt=""></p>
<table>
<thead>
<tr>
<th>标签</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;header&gt;</code></td>
<td>头部标签</td>
</tr>
<tr>
<td><code>&lt;nav&gt;</code></td>
<td>导航栏标签</td>
</tr>
<tr>
<td><code>&lt;main&gt;</code></td>
<td>文档主体，只能有一个</td>
</tr>
<tr>
<td><code>&lt;artical&gt;</code></td>
<td>内容标签</td>
</tr>
<tr>
<td><code>&lt;section&gt;</code></td>
<td>区块标签</td>
</tr>
<tr>
<td><code>&lt;aside&gt;</code></td>
<td>侧边栏标签</td>
</tr>
<tr>
<td><code>&lt;footer&gt;</code></td>
<td>尾部标签</td>
</tr>
</tbody></table>
<h3 id="2-排版标签"><a href="#2-排版标签" class="headerlink" title="2 排版标签"></a>2 排版标签</h3><table>
<thead>
<tr>
<th>标签</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;!-- --&gt;</code></td>
<td>注释</td>
</tr>
<tr>
<td><code>&lt;br&gt;</code></td>
<td>换行</td>
</tr>
<tr>
<td><code>&lt;hr&gt;</code></td>
<td>横线</td>
</tr>
<tr>
<td><code>&lt;h1&gt;~&lt;h6&gt;</code></td>
<td>标题标签</td>
</tr>
<tr>
<td><code>&lt;div&gt;</code></td>
<td>块标签</td>
</tr>
<tr>
<td><code>&lt;span&gt;</code></td>
<td>行内标签</td>
</tr>
<tr>
<td><code>&lt;p&gt;</code></td>
<td>段落标签</td>
</tr>
</tbody></table>
<h3 id="3-文本格式化标签"><a href="#3-文本格式化标签" class="headerlink" title="3 文本格式化标签"></a>3 文本格式化标签</h3><table>
<thead>
<tr>
<th>标签</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;strong&gt;</code></td>
<td>强调，加粗显示</td>
</tr>
<tr>
<td><code>&lt;em&gt;</code></td>
<td>着重，斜体显示</td>
</tr>
<tr>
<td><code>&lt;del&gt;</code></td>
<td>删除线</td>
</tr>
<tr>
<td><code>&lt;ins&gt;</code></td>
<td>下划线</td>
</tr>
<tr>
<td><code>&lt;pre&gt;</code></td>
<td>原样显示文本内容包括空白、换行等</td>
</tr>
<tr>
<td><code>&lt;abbr&gt;</code></td>
<td>缩写</td>
</tr>
<tr>
<td><code>&lt;sub&gt;</code></td>
<td>下标</td>
</tr>
<tr>
<td><code>&lt;sup&gt;</code></td>
<td>上标</td>
</tr>
<tr>
<td><code>&lt;blockquote&gt;</code></td>
<td>块引用</td>
</tr>
<tr>
<td><code>&lt;q&gt;</code></td>
<td>行内引用文本</td>
</tr>
<tr>
<td><code>&lt;progress&gt;</code></td>
<td>进度条</td>
</tr>
</tbody></table>
<h3 id="3-图片标签"><a href="#3-图片标签" class="headerlink" title="3 图片标签"></a>3 图片标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"图片地址"</span> <span class="attr">alt</span>=<span class="string">"图片无法正常显示时的替换文字"</span> <span class="attr">title</span>=<span class="string">"鼠标悬浮时的提示文字"</span> <span class="attr">width</span>=<span class="string">""</span> <span class="attr">height</span>=<span class="string">""</span> <span class="attr">border</span>=<span class="string">""</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-超链接标签"><a href="#4-超链接标签" class="headerlink" title="4 超链接标签"></a>4 超链接标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 超链接标签可以用在网页中的各种元素，如文本、图像、表格、音频、视频等等 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">target</span>=<span class="string">""</span> <span class="attr">title</span>=<span class="string">"链接提示文本"</span>&gt;</span> 链接显示文本 <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>href</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>url</code></td>
<td>外部链接：如<code>&lt;a href=&quot;www.baidu.com&quot;&gt;</code><br>内部链接：如 <code>&lt;a href=&quot;index.html&quot;&gt;</code><br>下载链接：url 是一个文件（如 exe, zip…）</td>
</tr>
<tr>
<td><code>#id</code></td>
<td>锚点，跳转到当前页面指定位置</td>
</tr>
<tr>
<td><code>#</code></td>
<td>跳转到当前页面</td>
</tr>
<tr>
<td><code>javascript:void(0);</code></td>
<td>不跳转</td>
</tr>
<tr>
<td><code>javascript:;</code></td>
<td>不跳转</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>target</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>_selt（默认）</code></td>
<td>当前窗口打开</td>
</tr>
<tr>
<td><code>_blank</code></td>
<td>新窗口打开</td>
</tr>
<tr>
<td><code>_parent</code></td>
<td>父级窗口打开</td>
</tr>
<tr>
<td><code>_top</code></td>
<td>祖先窗口打开</td>
</tr>
</tbody></table>
<h3 id="5-表格标签"><a href="#5-表格标签" class="headerlink" title="5 表格标签"></a>5 表格标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">cellspacing</span>=<span class="string">"单元格边框之间的距离"</span> <span class="attr">cellpadding</span>=<span class="string">"单元格内容和边框的距离"</span> <span class="attr">align</span>=<span class="string">"水平对齐方式"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">caption</span>&gt;</span>表格标题<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">th</span>&gt;</span>表头单元格，内容默认居中，加粗<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">tr</span>&gt;</span>	</span><br><span class="line">	<span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"列合并"</span> <span class="attr">rowspan</span>=<span class="string">"行合并"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>使用<code>&lt;thead&gt;&lt;tbody&gt;&lt;tfoot&gt;</code>的好处是规定位置，即使代码的顺序是乱的，显示也是正确的。</li>
<li><code>&lt;thead&gt;&lt;tfoot&gt;</code>可以没有，<code>&lt;tbody&gt;</code>不写也存在，且可以有多个</li>
</ol>
<h3 id="6-列表标签"><a href="#6-列表标签" class="headerlink" title="6 列表标签"></a>6 列表标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1 无序列表 unorder list --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>ul中只能容纳li，li中可以容纳所有元素<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2 有序列表 order list --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">type</span>=<span class="string">"1、A、a、I、i"</span> <span class="attr">start</span>=<span class="string">"首项从第几个开始"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3 定义列表 definition list --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词：孙悟空<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>解释1：美猴王<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>解释2：齐天大圣<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>解释3：斗战胜佛<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-表单标签"><a href="#7-表单标签" class="headerlink" title="7 表单标签"></a>7 表单标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">""</span> <span class="attr">name</span>=<span class="string">"提交key"</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"提交key"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"提交值"</span> <span class="attr">selected</span>=<span class="string">""</span>&gt;</span>页面显示值<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"提交key"</span> <span class="attr">cols</span>=<span class="string">"每行字符数"</span> <span class="attr">rows</span>=<span class="string">"显示的行数"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h4><table>
<thead>
<tr>
<th>标签</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;label&gt;</code></td>
<td>用于描述表单元素，点击时可以使表单元素获取焦点</td>
</tr>
<tr>
<td><code>&lt;button&gt;</code></td>
<td>按钮</td>
</tr>
<tr>
<td><code>&lt;input&gt;</code></td>
<td>表单交互式元素</td>
</tr>
<tr>
<td><code>&lt;select&gt;</code></td>
<td>下拉菜单</td>
</tr>
<tr>
<td><code>&lt;textarea&gt;</code></td>
<td>文本域</td>
</tr>
<tr>
<td><code>&lt;datalist&gt;</code></td>
<td>为表单输入框准备一些选项列表</td>
</tr>
</tbody></table>
<h4 id="2-lt-form-gt"><a href="#2-lt-form-gt" class="headerlink" title="2 &lt;form&gt;"></a>2 <code>&lt;form&gt;</code></h4><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>action</code></td>
<td>提交 url 地址</td>
</tr>
<tr>
<td><code>method</code></td>
<td>提交方式，默认 <code>get</code></td>
</tr>
<tr>
<td><code>enctype</code></td>
<td><code>post</code> 提交时表单内容提交给服务器的 MIME 类型</td>
</tr>
<tr>
<td><code>name</code></td>
<td>表单名称，用于区分同一个页面中的多个表单</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><code>enctype</code> 取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>application/x-www-form-urlencoded</code>（默认）</td>
<td>在发送前编码所有字符，空格转换为 <code>+</code> 加号 ，特殊字符转换为 <code>ASCII HEX</code> 值</td>
</tr>
<tr>
<td><code>multipart/form-data</code></td>
<td>不对字符编码，用于文件上传</td>
</tr>
<tr>
<td><code>text/plain</code></td>
<td>空格转换为 <code>+</code> 加号，但不对特殊字符编码</td>
</tr>
</tbody></table>
<h4 id="3-lt-label-gt"><a href="#3-lt-label-gt" class="headerlink" title="3 &lt;label&gt;"></a>3 <code>&lt;label&gt;</code></h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1 直接包裹要描述的表单元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">	描述 <span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2 使用 for-id --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"test"</span>&gt;</span>描述<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-lt-input-gt"><a href="#4-lt-input-gt" class="headerlink" title="4 &lt;input&gt;"></a>4 <code>&lt;input&gt;</code></h4><h5 id="1-属性"><a href="#1-属性" class="headerlink" title="1 属性"></a>1 属性</h5><table>
<thead>
<tr>
<th>属性</th>
<th>适用于</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>type</code></td>
<td><code>All</code></td>
<td>表单类型，默认为 <code>text</code></td>
</tr>
<tr>
<td><code>name</code></td>
<td><code>All</code></td>
<td>提交的键名</td>
</tr>
<tr>
<td><code>value</code></td>
<td><code>All</code></td>
<td>默认值</td>
</tr>
<tr>
<td><code>disabled</code></td>
<td><code>All</code></td>
<td>表单控件是否被禁用</td>
</tr>
<tr>
<td><code>checked</code></td>
<td><code>radio checkbox</code></td>
<td>单/复选框是否选中</td>
</tr>
<tr>
<td><code>selecked</code></td>
<td><code>option</code></td>
<td>下拉框是否选中</td>
</tr>
<tr>
<td><code>placeholder</code></td>
<td><code>text password ...</code></td>
<td>提示文本内容，得到焦点不会消失，一输入值就消失</td>
</tr>
<tr>
<td><code>multiple</code></td>
<td><code>file email select</code></td>
<td>是否允许多选</td>
</tr>
<tr>
<td><code>required</code></td>
<td><code>almost All</code></td>
<td>必须输入</td>
</tr>
<tr>
<td><code>readonly</code></td>
<td><code>almost All</code></td>
<td>只读，不能修改值，可提交到后台</td>
</tr>
<tr>
<td><code>minlength</code></td>
<td><code>text password ...</code></td>
<td><code>value</code> 的最小长度（最小字符数目）</td>
</tr>
<tr>
<td><code>maxlength</code></td>
<td><code>text password ...</code></td>
<td><code>value</code> 的最大长度（最大字符数目）</td>
</tr>
<tr>
<td><code>autocomplete</code></td>
<td><code>All</code></td>
<td>表单的自动填充功能，<code>off / on</code></td>
</tr>
</tbody></table>
<h5 id="2-type-属性"><a href="#2-type-属性" class="headerlink" title="2 type 属性"></a>2 type 属性</h5><table>
<thead>
<tr>
<th>type</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>text（默认）</code></td>
<td>文本框</td>
</tr>
<tr>
<td><code>password</code></td>
<td>密码框</td>
</tr>
<tr>
<td><code>radio</code></td>
<td>单选框，<code>name</code> 相同的是一个组，<code>value</code> 为提交值</td>
</tr>
<tr>
<td><code>checkbox</code></td>
<td>复选框，<code>name</code> 相同的是一个组，<code>value</code> 为提交值</td>
</tr>
<tr>
<td><code>file</code></td>
<td>上传文件，<code>multiple=&quot;multiple&quot;</code> 支持多选</td>
</tr>
<tr>
<td><code>button</code></td>
<td>没有默认行为的按钮，<code>value</code> 显示值</td>
</tr>
<tr>
<td><code>image</code></td>
<td>图片提交按钮</td>
</tr>
<tr>
<td><code>hidden</code></td>
<td>隐藏域</td>
</tr>
<tr>
<td><code>submit</code></td>
<td>提交按钮，不指定服务端会提交到当前页面</td>
</tr>
<tr>
<td><code>reset</code></td>
<td>复位按钮</td>
</tr>
<tr>
<td><code>number</code></td>
<td>数字框</td>
</tr>
<tr>
<td><code>tel</code></td>
<td>用于输入电话号码的控件</td>
</tr>
<tr>
<td><code>search</code></td>
<td>搜索框</td>
</tr>
<tr>
<td><code>email</code></td>
<td>邮件框</td>
</tr>
<tr>
<td><code>url</code></td>
<td>URL 框</td>
</tr>
<tr>
<td><code>color</code></td>
<td>颜色选择框</td>
</tr>
<tr>
<td><code>datetime-local</code></td>
<td>输入日期和时间的控件</td>
</tr>
<tr>
<td><code>date</code></td>
<td>日期</td>
</tr>
<tr>
<td><code>time</code></td>
<td>时间</td>
</tr>
<tr>
<td><code>month</code></td>
<td>月</td>
</tr>
<tr>
<td><code>week</code></td>
<td>周</td>
</tr>
</tbody></table>
<h5 id="3-表单提交方式"><a href="#3-表单提交方式" class="headerlink" title="3 表单提交方式"></a>3 表单提交方式</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1 如果设置了name，按钮数据也会提交到后台，如果有多个表单项可以判断是哪个表单提交的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">"点我提交"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2 html5 推荐使用&lt;button&gt; 而不是表单的 &lt;input type=button&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>点我提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3 图片也能提交 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"image"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-lt-select-gt"><a href="#5-lt-select-gt" class="headerlink" title="5 &lt;select&gt;"></a>5 <code>&lt;select&gt;</code></h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"提交值"</span>&gt;</span>显示值<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">	// optfroup 仅仅是将 option 分了一下组</span><br><span class="line">	<span class="tag">&lt;<span class="name">optgroup</span> <span class="attr">label</span>=<span class="string">"体育"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"lanqiu"</span>&gt;</span>篮球<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"zuqiu"</span>&gt;</span>足球<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"wangqiu"</span> <span class="attr">selected</span>&gt;</span>网球<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">optgroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-lt-button-gt"><a href="#5-lt-button-gt" class="headerlink" title="5 &lt;button&gt;"></a>5 <code>&lt;button&gt;</code></h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>type</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>submit（默认）</code></td>
<td>提交按钮</td>
</tr>
<tr>
<td><code>reset</code></td>
<td>重置按钮</td>
</tr>
<tr>
<td><code>button</code></td>
<td>纯按钮，没有默认行为</td>
</tr>
</tbody></table>
<h4 id="6-lt-textarea-gt"><a href="#6-lt-textarea-gt" class="headerlink" title="6 &lt;textarea&gt;"></a>6 <code>&lt;textarea&gt;</code></h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">"每行中的字符数"</span> <span class="attr">rows</span>=<span class="string">"显示的行数"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="7-lt-datalist-gt"><a href="#7-lt-datalist-gt" class="headerlink" title="7 &lt;datalist&gt;"></a>7 <code>&lt;datalist&gt;</code></h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 表示从已有数据中选择数据，而不是自定义输入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">list</span>=<span class="string">"dataID"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"dataID"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="8-多媒体标签"><a href="#8-多媒体标签" class="headerlink" title="8 多媒体标签"></a>8 多媒体标签</h3><h4 id="1-lt-audio-gt"><a href="#1-lt-audio-gt" class="headerlink" title="1 &lt;audio&gt;"></a>1 <code>&lt;audio&gt;</code></h4><table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>src</code></td>
<td><code>url</code></td>
<td>音频源</td>
</tr>
<tr>
<td><code>autoplay</code></td>
<td><code>autoplay</code></td>
<td>自动播放，默认 <code>false</code></td>
</tr>
<tr>
<td><code>controls</code></td>
<td><code>controls</code></td>
<td>显示控件</td>
</tr>
<tr>
<td><code>loop</code></td>
<td><code>loop</code></td>
<td>循环播放</td>
</tr>
<tr>
<td><code>muted</code></td>
<td><code>muted</code></td>
<td>静音，默认 <code>false</code></td>
</tr>
<tr>
<td><code>preload</code></td>
<td><code>metadata</code></td>
<td>预加载</td>
</tr>
<tr>
<td><code>volume</code></td>
<td><code>0.0~1.0</code></td>
<td>音量</td>
</tr>
</tbody></table>
<h4 id="2-lt-video-gt"><a href="#2-lt-video-gt" class="headerlink" title="2 &lt;video&gt;"></a>2 <code>&lt;video&gt;</code></h4><table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>src</code></td>
<td><code>url</code></td>
<td>视频源</td>
</tr>
<tr>
<td><code>autoplay</code></td>
<td><code>autoplay</code></td>
<td>自动播放，默认 <code>false</code>，需要静音才生效</td>
</tr>
<tr>
<td><code>controls</code></td>
<td><code>controls</code></td>
<td>显示控件</td>
</tr>
<tr>
<td><code>loop</code></td>
<td><code>loop</code></td>
<td>循环播放</td>
</tr>
<tr>
<td><code>muted</code></td>
<td><code>muted</code></td>
<td>静音，默认 <code>false</code></td>
</tr>
<tr>
<td><code>poster</code></td>
<td><code>url</code></td>
<td>视频封面图</td>
</tr>
<tr>
<td><code>preload</code></td>
<td><code>metadata</code></td>
<td>预加载</td>
</tr>
<tr>
<td><code>width</code></td>
<td><code>px</code></td>
<td>视频宽度</td>
</tr>
<tr>
<td><code>height</code></td>
<td><code>px</code></td>
<td>视频高度</td>
</tr>
</tbody></table>
<h1 id="三-特殊字符"><a href="#三-特殊字符" class="headerlink" title="三 特殊字符"></a>三 特殊字符</h1><table>
<thead>
<tr>
<th>字符</th>
<th>名称</th>
<th>字符代码</th>
<th>码点</th>
</tr>
</thead>
<tbody><tr>
<td>&nbsp;</td>
<td>空格</td>
<td><code>&amp;nbsp;</code></td>
<td><code>&amp;#160;</code></td>
</tr>
<tr>
<td>&gt;</td>
<td>大于号</td>
<td><code>&amp;gt;</code></td>
<td><code>&amp;#62;</code></td>
</tr>
<tr>
<td>&lt;</td>
<td>小于号</td>
<td><code>&amp;lt;</code></td>
<td><code>&amp;#60;</code></td>
</tr>
<tr>
<td>&amp;</td>
<td>与</td>
<td><code>&amp;amp;</code></td>
<td><code>&amp;#38;</code></td>
</tr>
<tr>
<td>“</td>
<td>双引号</td>
<td><code>&amp;quot;</code></td>
<td><code>&amp;#34;</code></td>
</tr>
<tr>
<td>‘</td>
<td>单引号</td>
<td>&nbsp;</td>
<td><code>&amp;#39;</code></td>
</tr>
<tr>
<td>&#96;</td>
<td>反引号</td>
<td>&nbsp;</td>
<td><code>&amp;#96;</code></td>
</tr>
<tr>
<td>&#124;</td>
<td>竖线</td>
<td>&nbsp;</td>
<td><code>&amp;#124</code></td>
</tr>
<tr>
<td>©</td>
<td>版权</td>
<td><code>&amp;copy;</code></td>
<td><code>&amp;#169;</code></td>
</tr>
<tr>
<td>®</td>
<td>注册</td>
<td><code>&amp;reg;</code></td>
<td><code>&amp;#174;</code></td>
</tr>
<tr>
<td>™</td>
<td>商标</td>
<td><code>&amp;trade;</code></td>
<td><code>&amp;#8482;</code></td>
</tr>
<tr>
<td>℃</td>
<td>摄氏度</td>
<td><code>&amp;deg;</code></td>
<td>&nbsp;</td>
</tr>
<tr>
<td>±</td>
<td>正负</td>
<td><code>&amp;plusmn;</code></td>
<td>&nbsp;</td>
</tr>
<tr>
<td>×</td>
<td>乘号</td>
<td><code>&amp;times;</code></td>
<td><code>&amp;#215;</code></td>
</tr>
<tr>
<td>÷</td>
<td>除号</td>
<td><code>&amp;divide;</code></td>
<td><code>&amp;#247;</code></td>
</tr>
</tbody></table>
<h1 id="四-前端字符的表示方式"><a href="#四-前端字符的表示方式" class="headerlink" title="四 前端字符的表示方式"></a>四 前端字符的表示方式</h1><ol>
<li>Html 中使用 <code>&amp;#码点;</code><ul>
<li>码点<ul>
<li>指字符在编码表中对应的编码值</li>
<li>Unicode 采用十六制书写并加上前缀 <code>\u</code></li>
</ul>
</li>
</ul>
</li>
<li>CSS 伪元素的 <code>content</code> 属性，直接使用 <code>\u码点</code></li>
<li>JavaScript 文件中为防止乱码转义，使用 <code>\u码点</code></li>
<li><code>unicode-range</code> 是 <code>U+码点</code></li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>UI</category>
      </categories>
  </entry>
  <entry>
    <title>SSM</title>
    <url>/anyeansan.github.io/2020/11/08/%E6%A1%86%E6%9E%B6/SSM/</url>
    <content><![CDATA[<h1 id="一-包"><a href="#一-包" class="headerlink" title="一 包"></a>一 包</h1><ol>
<li><p><code>Spring + SpringMVC</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01 spring-core</span><br><span class="line">02 spring-beans</span><br><span class="line">03 spring-context</span><br><span class="line">04 spring-expression</span><br><span class="line">05 spring-jcl（commons-logging）</span><br><span class="line">06 spring-aop</span><br><span class="line">07 spring-aspects</span><br><span class="line">08 aspectjweaver</span><br><span class="line">09 spring-web</span><br><span class="line">10 spring-webmvc</span><br><span class="line">11 spring-tx</span><br><span class="line">12 spring-jdbc</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>mybatis</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01 mybatis</span><br><span class="line">02 mybatis-spring</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>SQL</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01 连接池：c3p0 dbcp druid ...</span><br><span class="line">02 数据库驱动</span><br></pre></td></tr></table></figure>
</li>
<li><p>日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j2 slf4j ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>JSON</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JackSon GSON FastSon ...</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="二-Spring-Springmvc"><a href="#二-Spring-Springmvc" class="headerlink" title="二 Spring + Springmvc"></a>二 Spring + Springmvc</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol>
<li>SpringMVC 扫描控制层</li>
<li>Spring 扫描所有并排除控制层，避免创建两次 Bean</li>
<li>Spring 的 IOC 容器包含 SpringMVC 的 IOC 容器，即 Spring 的容器是父级<ol>
<li>SpringMVC 的 IOC 容器可以获取 Spring IOC 容器中的 Bean</li>
<li>Spring 的 IOC 容器不能获取 SpringMVC IOC 容器中的 Bean</li>
</ol>
</li>
</ol>
<h2 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2 配置"></a>2.2 配置</h2><h3 id="1-web-xml"><a href="#1-web-xml" class="headerlink" title="1 web.xml"></a>1 <code>web.xml</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--1 配置 ContextLoaderListener--&gt;</span><br><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line">&lt;!--2 配置 DispatcherServlet --&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--3 配置编码过滤器 CharacterEncodingFilter--&gt;</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;UTF-8&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--4 配置 RestFul 请求处理过滤器--&gt;</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-springMVC-xml"><a href="#2-springMVC-xml" class="headerlink" title="2 springMVC.xml"></a>2 <code>springMVC.xml</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 1 扫描控制层--&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;cn.an.controller&quot;/&gt;</span><br><span class="line">&lt;!-- 2 注解驱动--&gt;</span><br><span class="line">&lt;mvc:annotation-driven/&gt;</span><br><span class="line">&lt;!-- 3 静态资源--&gt;</span><br><span class="line">&lt;mvc:default-servlet-handler/&gt;</span><br><span class="line">&lt;!-- 4 视图解析器--&gt;</span><br><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-applicationContext-xml"><a href="#3-applicationContext-xml" class="headerlink" title="3 applicationContext.xml"></a>3 <code>applicationContext.xml</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 扫描控制层之外的注解--&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;cn.an&quot;&gt;</span><br><span class="line">    &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure>

<h1 id="三-Spring-Mybatis"><a href="#三-Spring-Mybatis" class="headerlink" title="三 Spring + Mybatis"></a>三 Spring + Mybatis</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol>
<li>Mybatis 只配置自己特有的东西<ol>
<li>主配置： <code>setting ...</code></li>
<li>映射配置</li>
</ol>
</li>
<li>交给 Spring 管理：<ol>
<li>数据源和事务</li>
<li><code>SqlSession</code> 对象的创建和管理<ul>
<li><code>mybatis-spring</code> 中的 <code>SqlSessionFactoryBean</code></li>
</ul>
</li>
<li><code>Mapper</code> 接口代理实现类对象的创建和管理<ul>
<li><code>mybatis-spring</code> 中的 <code>MapperScannerConfigurer</code></li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="3-2-配置"><a href="#3-2-配置" class="headerlink" title="3.2 配置"></a>3.2 配置</h2><h3 id="1-mybatis-config-xml"><a href="#1-mybatis-config-xml" class="headerlink" title="1 mybatis-config.xml"></a>1 <code>mybatis-config.xml</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">        &lt;!--开启懒加载 --&gt;</span><br><span class="line">        &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;!--开启时，任一方法的调用都会加载该对象的所有延迟加载属性 --&gt;</span><br><span class="line">        &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;!--开启数据库下划线和Java属性驼峰命名的映射--&gt;</span><br><span class="line">        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-applicationContext-xml"><a href="#2-applicationContext-xml" class="headerlink" title="2 applicationContext.xml"></a>2 <code>applicationContext.xml</code></h3><h4 id="1-数据源和事务"><a href="#1-数据源和事务" class="headerlink" title="1 数据源和事务"></a>1 数据源和事务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 1 引入资源文件--&gt;</span><br><span class="line">&lt;context:property-placeholder location=&quot;classpath:druid.properties&quot;/&gt;</span><br><span class="line">&lt;!-- 2 配置数据源--&gt;</span><br><span class="line">&lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;druid.driverClassName&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;$&#123;druid.url&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;$&#123;druid.username&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;$&#123;druid.password&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;druid.initialSize&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;druid.maxActive&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;minIdle&quot; value=&quot;$&#123;druid.minIdle&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;maxWait&quot; value=&quot;$&#123;druid.maxWait&#125;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 3 事务--&gt;</span><br><span class="line">&lt;!-- 3.1 事务管理器--&gt;</span><br><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!--3.2 开启事务注解驱动--&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-管理-SqlSession"><a href="#2-管理-SqlSession" class="headerlink" title="2 管理 SqlSession"></a>2 管理 <code>SqlSession</code></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;!--1 数据源--&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt;</span><br><span class="line">    &lt;!--2 mybatis 主配置文件位置--&gt;</span><br><span class="line">    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;</span><br><span class="line">    &lt;!--3 mybatis 映射配置文件位置--&gt;</span><br><span class="line">    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:cn/an/mapper/*.xml&quot;/&gt;</span><br><span class="line">    &lt;!--4 为包及其子包配置别名--&gt;</span><br><span class="line">    &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-管理-Mapper-接口代理实现类"><a href="#3-管理-Mapper-接口代理实现类" class="headerlink" title="3 管理 Mapper 接口代理实现类"></a>3 管理 <code>Mapper</code> 接口代理实现类</h4><h5 id="1-单个配置"><a href="#1-单个配置" class="headerlink" title="1 单个配置"></a>1 单个配置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;</span><br><span class="line">	// 指定 Mapper 接口</span><br><span class="line">    &lt;property name=&quot;mapperInterface&quot; value=&quot;&quot;/&gt;</span><br><span class="line">    // 注入 SqlSessionFactory</span><br><span class="line">    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2-批量配置"><a href="#2-批量配置" class="headerlink" title="2 批量配置"></a>2 批量配置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">	// 为包下所有 Mapper 接口生成代理实现类，并由 Spring 容器管理</span><br><span class="line">    &lt;property name=&quot;basePackage&quot; value=&quot;cn.an.mapper&quot;/&gt;</span><br><span class="line">    // 注入 SqlSessionFactory</span><br><span class="line">    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>代理实现类默认 <code>BeanID</code> 为接口名首字母小写</li>
<li><code>SqlSessionFactory</code> 全局只有一个，所以可以省略</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>Frame</category>
      </categories>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/anyeansan.github.io/2020/11/08/%E6%A1%86%E6%9E%B6/SpringMVC/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>轻量级的控制层 MVC 框架</li>
<li>与 Spring 无缝结合，功能强大：RESTful，数据验证，格式化，本地化，主题…</li>
</ol>
<h1 id="二-执行流程"><a href="#二-执行流程" class="headerlink" title="二 执行流程"></a>二 执行流程</h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Frame/SpringMVC/SpringMVC%E6%B5%81%E7%A8%8B.png" alt=""></p>
<ol>
<li>客户端发送请求，<code>DispatcherServlet</code> 捕获请求</li>
<li><code>DispatcherServlet</code>  根据请求从映射器获取 <code>Handler</code> 以及 <code>Handler</code> 对应的拦截器，以 <code>HandlerExcutionChain</code> 的形式返回<ol>
<li>映射器中存储了控制器及其能够处理的请求信息</li>
<li>如果映射不存在，如静态资源，会判断是否配置了 <code>mvc:default-servlet-handler</code></li>
</ol>
</li>
<li><code>DispatcherServlet</code>  根据 <code>Handler</code> 选择适配器执行它，并返回 <code>ModelAndView</code><ol>
<li>正向执行拦截器链的 <code>preHandler()</code></li>
<li>执行 <code>Handler</code></li>
<li>逆向执行拦截器链的 <code>postHandler()</code></li>
</ol>
</li>
<li>使用视图解析器解析 <code>ModelAndView</code></li>
<li>渲染视图</li>
<li>逆向执行拦截器链的 <code>AfterCompletion()</code></li>
<li>响应</li>
</ol>
<h1 id="三-前端控制器-DispatcherServlet"><a href="#三-前端控制器-DispatcherServlet" class="headerlink" title="三 前端控制器 DispatcherServlet"></a>三 前端控制器 <code>DispatcherServlet</code></h1><h2 id="3-1-配置"><a href="#3-1-配置" class="headerlink" title="3.1 配置"></a>3.1 配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">    &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>默认加载的配置文件为 <code>WEB-INF/&lt;servlet-name&gt;-servlet.xml</code></li>
<li><code>&lt;url-pattern&gt;</code><ol>
<li><code>/</code>（建议）<ul>
<li>拦截所有，不包含<code>.jsp</code></li>
</ul>
</li>
<li><code>/*</code>（不建议）<ul>
<li>拦截所有</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="3-2-组件"><a href="#3-2-组件" class="headerlink" title="3.2 组件"></a>3.2 组件</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>一启动就会初始化所有组件，去容器中寻找，如果没有配置则使用默认</li>
<li>默认加载的组件在 <code>DispatcherServlet.properties</code>中</li>
</ol>
<h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2 分类"></a>2 分类</h3><table>
<thead>
<tr>
<th>组件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>List&lt;HandlerMapping&gt;</code></td>
<td>处理器映射器</td>
</tr>
<tr>
<td><code>List&lt;HandlerAdapter&gt;</code></td>
<td>处理器适配器</td>
</tr>
<tr>
<td><code>List&lt;ViewResolver&gt;</code></td>
<td>视图解析器</td>
</tr>
<tr>
<td><code>MultipartResolver</code></td>
<td>文件上传解析器</td>
</tr>
<tr>
<td><code>List&lt;HandlerExceptionResolver&gt;</code></td>
<td>异常解析器</td>
</tr>
<tr>
<td><code>LocaleResolver</code></td>
<td>区域信息解析器，国际化相关</td>
</tr>
<tr>
<td><code>FlashMapManager</code></td>
<td>重定向携带数据的功能</td>
</tr>
<tr>
<td><code>ThemeResolver</code></td>
<td>主题解析器</td>
</tr>
<tr>
<td><code>RequestToViewNameTranslator</code></td>
<td>请求到视图名转换器</td>
</tr>
</tbody></table>
<h3 id="3-处理器映射器-HandlerMapping"><a href="#3-处理器映射器-HandlerMapping" class="headerlink" title="3 处理器映射器 HandlerMapping"></a>3 处理器映射器 <code>HandlerMapping</code></h3><table>
<thead>
<tr>
<th>映射器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>BeanNameUrlHandlerMapping</code></td>
<td>请求 URL 与处理器 <code>BeanID</code> 进行匹配，<code>BeanID</code> 必须以 <code>/</code> 开头</td>
</tr>
<tr>
<td><code>SimpleUrlHandlerMaping</code></td>
<td>请求 URL 与配置的 <code>key</code> 进行匹配获取 <code>value</code> 即为处理器 <code>BeanID</code></td>
</tr>
<tr>
<td><code>RequestMappingHandlerMapping</code></td>
<td>注解映射器</td>
</tr>
</tbody></table>
<h3 id="4-处理器适配器-HandlerAdapter"><a href="#4-处理器适配器-HandlerAdapter" class="headerlink" title="4 处理器适配器 HandlerAdapter"></a>4 处理器适配器 <code>HandlerAdapter</code></h3><table>
<thead>
<tr>
<th>适配器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>HttpRequestHandlerAdapter</code></td>
<td><code>Controller</code> 必须实现 <code>HttpRequesHandler</code>接口</td>
</tr>
<tr>
<td><code>SimpleControllerHandlerAdapter</code></td>
<td><code>Controller</code> 必须实现 <code>Controller</code> 接口</td>
</tr>
<tr>
<td><code>RequestMappingHandlerAdapter</code></td>
<td>注解适配器</td>
</tr>
</tbody></table>
<h3 id="5-视图解析器-ViewResolver"><a href="#5-视图解析器-ViewResolver" class="headerlink" title="5 视图解析器 ViewResolver"></a>5 视图解析器 <code>ViewResolver</code></h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>无论处理器返回值是什么，最终都会变成 <code>ModelAndView</code> 被视图解析器解析</li>
<li>SpringMVC 借助视图解析器得到视图对象 <code>View</code>，最终的视图可以是 <code>Jsp Excel JFreeChart ...</code></li>
<li>所有视图解析器都必须实现 <code>ViewResolve</code> 接口，常用视图解析器<ol>
<li><code>InternalResourceViewResolver</code></li>
<li><code>BeanNameViewResolver</code></li>
</ol>
</li>
<li>视图对象才能真正的转发（会将模型数据全部取出存到请求域中）或重定向</li>
<li>视图对象才能真正的渲染视图，将模型中的数据以某种形式呈现给用户</li>
</ol>
<h4 id="2-InternalResourceViewResolver-配置"><a href="#2-InternalResourceViewResolver-配置" class="headerlink" title="2 InternalResourceViewResolver 配置"></a>2 <code>InternalResourceViewResolver</code> 配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;prefix&quot; value=&quot;/&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>物理视图 = 前缀(prefix) + 逻辑视图 + 后缀(suffix)</code></li>
</ul>
<h4 id="3-lt-mvc-view-controller-gt"><a href="#3-lt-mvc-view-controller-gt" class="headerlink" title="3 &lt;mvc:view-controller&gt;"></a>3 <code>&lt;mvc:view-controller&gt;</code></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mvc:view-controller path=&quot;请求路径&quot; view-name=&quot;响应的页面&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>无需经过控制器来执行结果，直接响应 SpringMVC  渲染的页面</li>
</ul>
<h3 id="6-控制器-Controller-amp-处理器-Handler"><a href="#6-控制器-Controller-amp-处理器-Handler" class="headerlink" title="6 控制器 Controller &amp; 处理器 Handler"></a>6 控制器 <code>Controller</code> &amp; 处理器 <code>Handler</code></h3><ol>
<li><code>Controller</code>：指控制器类</li>
<li><code>Handler</code>：控制器类中的方法</li>
</ol>
<h1 id="五-配置"><a href="#五-配置" class="headerlink" title="五 配置"></a>五 配置</h1><h2 id="5-1-静态资源处理"><a href="#5-1-静态资源处理" class="headerlink" title="5.1 静态资源处理"></a>5.1 静态资源处理</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>所有项目的 <code>web.xml</code> 都继承了 Tomcat 的 <code>web.xml</code>，所以相同配置会覆盖</li>
<li>Tomcat 的 <code>web.xml</code> 中<ol>
<li><code>DefaultServlet</code>：<code>url-pattern = /</code></li>
<li><code>JspServlet</code>：<code>url-pattern = *.jsp</code></li>
</ol>
</li>
<li><code>DispatcheServlet</code> 的 <code>url-pattern = /*</code>，表示所有请求都由 SpringMVC 处理<ol>
<li>静态资源请求：没有对应的处理器，会报错</li>
<li><code>.jsp</code> 请求：没有对应的处理器，会报错</li>
</ol>
</li>
<li><code>DispatcheServlet</code> 的 <code>url-pattern = /</code>，表示除了 <code>.jsp</code> 外的请求由 SpringMVC 处理<ol>
<li>静态资源请求：没有对应的处理器，会报错</li>
<li><code>.jsp</code> 请求：由 Tomcat 的 <code>JspServlet</code> 处理，没有问题</li>
</ol>
</li>
</ol>
<h3 id="2-解决"><a href="#2-解决" class="headerlink" title="2 解决"></a>2 解决</h3><h4 id="1-在-SpringMVC-核心配置文件中配置"><a href="#1-在-SpringMVC-核心配置文件中配置" class="headerlink" title="1 在 SpringMVC 核心配置文件中配置"></a>1 在 SpringMVC 核心配置文件中配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mvc:default-servlet-handler default-servlet-name=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>将在 SpringMVC上下文中定义一个 <code>DefaultServletHttpRequestHandler</code>，它会对进入 <code>DispatcheServlet</code> 的请求进行筛选<ol>
<li>如果不是静态资源的请求，由 <code>DispatcheServlet</code> 处理</li>
<li>如果是静态资源的请求，即没有匹配映射的请求，则交给 WEB应用服务器默认的 Servlet 处理</li>
</ol>
</li>
<li><code>default-servlet-name</code><ul>
<li>一般 WEB应用服务器（如 <code>Tomcat</code>）默认的 Servlet 名称都是 <code>default</code>，此属性可以省略，否则需要手动配置</li>
</ul>
</li>
</ol>
<h4 id="2-在-SpringMVC-核心配置文件中配置"><a href="#2-在-SpringMVC-核心配置文件中配置" class="headerlink" title="2 在 SpringMVC 核心配置文件中配置"></a>2 在 SpringMVC 核心配置文件中配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--配置静态资源访问 **表示的包含自身包和子包的所有文件--&gt;</span><br><span class="line">&lt;mvc:resources mapping=&quot;/statics/**&quot; location=&quot;/statics/&quot; &gt;&lt;/mvc:resources&gt;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-lt-mvc-annotation-driven-gt"><a href="#5-2-lt-mvc-annotation-driven-gt" class="headerlink" title="5.2 &lt;mvc:annotation-driven/&gt;"></a>5.2 <code>&lt;mvc:annotation-driven/&gt;</code></h2><ol>
<li>注册 <code>RequestMappingHandlerMapping</code></li>
<li>注册<code>RequestMappingHandlerAdapter</code></li>
<li>注册<code>ExceptionHandlerExceptionResolver</code></li>
<li>支持<ol>
<li><code>ConversionService</code></li>
<li><code>@NumberFormat annotation 、@DateTimeFormat</code>完成数据类型格式化</li>
<li><code>@Valid</code> 对 JavaBean 进行 JSR303 校验</li>
<li><code>@RequestBody 和 @ResponseBody</code></li>
</ol>
</li>
</ol>
<h1 id="六-原生-Servlet"><a href="#六-原生-Servlet" class="headerlink" title="六 原生 Servlet"></a>六 原生 Servlet</h1><ol>
<li>想获取谁直接在方法上添加相应的形参即可获取</li>
<li>默认支持：<ol>
<li><code>HttpServletRequest</code></li>
<li><code>HttpServletResponse</code></li>
<li><code>HttpSession</code></li>
<li><code>java.security.Principal</code></li>
<li><code>Locale</code></li>
<li><code>InputStream</code></li>
<li><code>OutputStream</code></li>
<li><code>Reader</code></li>
<li><code>Writer</code></li>
</ol>
</li>
</ol>
<h1 id="七-请求"><a href="#七-请求" class="headerlink" title="七 请求"></a>七 请求</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>@RequestMapping</code></td>
<td>请求映射，即确定处理指定请求的方法</td>
</tr>
<tr>
<td><code>@PathVariable</code></td>
<td>请求路径占位符映射</td>
</tr>
<tr>
<td><code>@RequestParam</code></td>
<td>请求参数映射</td>
</tr>
<tr>
<td><code>@RequestHeader</code></td>
<td>获取请求头中的值</td>
</tr>
<tr>
<td><code>@RequestBody</code></td>
<td>获取请求体中的值</td>
</tr>
<tr>
<td><code>@CookieValue</code></td>
<td>获取 <code>Cookie</code>中的值</td>
</tr>
<tr>
<td><code>@RequestAttribute</code></td>
<td>获取 <code>request</code> 域中的值</td>
</tr>
<tr>
<td><code>@SessionAttribute</code></td>
<td>获取 <code>session</code> 域中的值</td>
</tr>
</tbody></table>
<h2 id="7-2-请求映射"><a href="#7-2-请求映射" class="headerlink" title="7.2 请求映射"></a>7.2 请求映射</h2><h3 id="1-RequestMapping"><a href="#1-RequestMapping" class="headerlink" title="1 @RequestMapping"></a>1 <code>@RequestMapping</code></h3><h4 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h4><ol>
<li>定义在类上：第一级的访问路径</li>
<li>定义在方法上：第二级的访问路径</li>
</ol>
<h4 id="2-属性"><a href="#2-属性" class="headerlink" title="2 属性"></a>2 属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String[] value() default {}</code></td>
<td>同 <code>path()</code></td>
</tr>
<tr>
<td><code>String[] path() default {}</code></td>
<td>指定请求路径</td>
</tr>
<tr>
<td><code>RequestMethod[] method() default {}</code></td>
<td>指定请求方法，值为枚举类 <code>RequestMethod</code> 的值 <code>GET POST...</code></td>
</tr>
<tr>
<td><code>String[] params() default {}</code></td>
<td>指定必须匹配的请求参数，支持简单表达式</td>
</tr>
<tr>
<td><code>String[] headers() default {}</code></td>
<td>指定必须包含的请求头</td>
</tr>
</tbody></table>
<h3 id="2-其它映射注解"><a href="#2-其它映射注解" class="headerlink" title="2 其它映射注解"></a>2 其它映射注解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 请求方法确定可以直接使用以下注解代替 @RequestMapping</span><br><span class="line">@GetMapping</span><br><span class="line">@PostMapping</span><br><span class="line">@PutMapping</span><br><span class="line">@DeleteMapping</span><br></pre></td></tr></table></figure>

<h2 id="7-3-请求路径占位符"><a href="#7-3-请求路径占位符" class="headerlink" title="7.3 请求路径占位符"></a>7.3 请求路径占位符</h2><h3 id="1-PathVariable"><a href="#1-PathVariable" class="headerlink" title="1 @PathVariable"></a>1 <code>@PathVariable</code></h3><h4 id="1-说明-1"><a href="#1-说明-1" class="headerlink" title="1 说明"></a>1 说明</h4><ul>
<li>定义在形参上：映射请求 URL 中的占位符，即指定形参与占位符进行匹配的名称</li>
<li>占位符：<code>/usr/{id}</code></li>
</ul>
<h4 id="2-属性-1"><a href="#2-属性-1" class="headerlink" title="2 属性"></a>2 属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String value() default &quot;&quot;</code></td>
<td>同 <code>name()</code></td>
</tr>
<tr>
<td><code>String name() default &quot;&quot;</code></td>
<td>指定占位符映射名称</td>
</tr>
<tr>
<td><code>boolean required() default true</code></td>
<td>请求是否必须包含指定占位符</td>
</tr>
</tbody></table>
<h3 id="2-RESTFul-风格"><a href="#2-RESTFul-风格" class="headerlink" title="2 RESTFul 风格"></a>2 RESTFul 风格</h3><h4 id="1-请求格式"><a href="#1-请求格式" class="headerlink" title="1 请求格式"></a>1 请求格式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">增: /user POST</span><br><span class="line">删: /user/1 DELETE</span><br><span class="line">改: /user/1 PUT</span><br><span class="line">查: /user/1 GET</span><br></pre></td></tr></table></figure>

<h4 id="2-发送-put-delete-请求"><a href="#2-发送-put-delete-请求" class="headerlink" title="2 发送 put delete 请求"></a>2 发送 <code>put delete</code> 请求</h4><ol>
<li>使用 Spring 提供的过滤器 <code>HiddenHttpMethodFilter</code></li>
<li>创建一个 <code>POST</code> 请求的表单</li>
<li>表单项包含一个 <code>name=&quot;_method&quot; value=&quot;put delete...中的一个&quot;</code></li>
<li>可以自动将 <code>Post</code> 请求转换成 <code>_method</code> 指定的请求</li>
</ol>
<h2 id="7-4-请求参数"><a href="#7-4-请求参数" class="headerlink" title="7.4 请求参数"></a>7.4 请求参数</h2><h3 id="1-RequestParam"><a href="#1-RequestParam" class="headerlink" title="1 @RequestParam"></a>1 <code>@RequestParam</code></h3><h4 id="1-说明-2"><a href="#1-说明-2" class="headerlink" title="1 说明"></a>1 说明</h4><ul>
<li>定义在形参上：将指定名称的请求参数的值赋给形参</li>
</ul>
<h4 id="2-属性-2"><a href="#2-属性-2" class="headerlink" title="2 属性"></a>2 属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String value() default &quot;&quot;</code></td>
<td>同 <code>name()</code></td>
</tr>
<tr>
<td><code>String name() default &quot;&quot;</code></td>
<td>指定请求参数名称</td>
</tr>
<tr>
<td><code>boolean required() default true</code></td>
<td>请求参数中是否必须包含此参数</td>
</tr>
<tr>
<td><code>String defaultValue() default ValueConstants.DEFAULT_NONE</code></td>
<td>指定默认值来取代 <code>null</code></td>
</tr>
</tbody></table>
<h3 id="2-请求参数绑定"><a href="#2-请求参数绑定" class="headerlink" title="2 请求参数绑定"></a>2 请求参数绑定</h3><h4 id="1-绑定机制"><a href="#1-绑定机制" class="headerlink" title="1 绑定机制"></a>1 绑定机制</h4><ol>
<li>表单提交数据都是 <code>k=v</code> 格式</li>
<li>SpringMVC 请求参数绑定：指控制器中方法的形参与请求参数绑定，即用形参获取请求参数</li>
</ol>
<h4 id="2-获取请求参数的方式"><a href="#2-获取请求参数的方式" class="headerlink" title="2 获取请求参数的方式"></a>2 获取请求参数的方式</h4><h5 id="1-直接获取"><a href="#1-直接获取" class="headerlink" title="1 直接获取"></a>1 直接获取</h5><ol>
<li>方法形参名称与请求参数名称（表单 <code>name</code>）一致</li>
<li>如果不一致，使用 <code>@RequestParam</code> 指定</li>
</ol>
<h5 id="2-封装对象"><a href="#2-封装对象" class="headerlink" title="2 封装对象"></a>2 封装对象</h5><ol>
<li>如果请求参数过多，可以用 <code>JavaBean</code> 接收，会自动封装</li>
<li>方法形参名称任意，类型为 <code>JavaBean</code> 类型，<code>JavaBean</code> 中的属性名称与请求参数名称（表单 <code>name</code>）一致</li>
</ol>
<h2 id="7-5-请求头：-RequestHeader"><a href="#7-5-请求头：-RequestHeader" class="headerlink" title="7.5 请求头：@RequestHeader"></a>7.5 请求头：<code>@RequestHeader</code></h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String value() default &quot;&quot;</code></td>
<td>同 <code>name()</code></td>
</tr>
<tr>
<td><code>String name() default &quot;&quot;</code></td>
<td>指定请求头的键</td>
</tr>
<tr>
<td><code>boolean required() default true</code></td>
<td>请求头是否必须包含指定键</td>
</tr>
</tbody></table>
<ul>
<li>定义在形参上：将请求头中指定键的值赋给形参</li>
</ul>
<h2 id="7-7-Cookie：-CookieValue"><a href="#7-7-Cookie：-CookieValue" class="headerlink" title="7.7 Cookie：@CookieValue"></a>7.7 Cookie：<code>@CookieValue</code></h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String value() default &quot;&quot;</code></td>
<td>同 <code>name()</code></td>
</tr>
<tr>
<td><code>String name() default &quot;&quot;</code></td>
<td>指定 Cookie 中的键</td>
</tr>
<tr>
<td><code>boolean required() default true</code></td>
<td>Cookie 是否必须包含指定键</td>
</tr>
</tbody></table>
<ul>
<li>定义在形参上：将 Cookie 中指定键的值赋给形参</li>
</ul>
<h2 id="7-8-域"><a href="#7-8-域" class="headerlink" title="7.8 域"></a>7.8 域</h2><h3 id="1-request-域：-RequestAttribute"><a href="#1-request-域：-RequestAttribute" class="headerlink" title="1 request 域：@RequestAttribute"></a>1 <code>request</code> 域：<code>@RequestAttribute</code></h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String value() default &quot;&quot;</code></td>
<td>同 <code>name()</code></td>
</tr>
<tr>
<td><code>String name() default &quot;&quot;</code></td>
<td>指定 <code>request</code> 域的键</td>
</tr>
<tr>
<td><code>boolean required() default true</code></td>
<td><code>request</code> 域是否必须包含指定键</td>
</tr>
</tbody></table>
<ul>
<li>定义在形参上：将 <code>request</code> 域中指定键的值赋给形参</li>
</ul>
<h3 id="2-session-域：-SessionAttribute"><a href="#2-session-域：-SessionAttribute" class="headerlink" title="2 session 域：@SessionAttribute"></a>2 <code>session</code> 域：<code>@SessionAttribute</code></h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String value() default &quot;&quot;</code></td>
<td>同 <code>name()</code></td>
</tr>
<tr>
<td><code>String name() default &quot;&quot;</code></td>
<td>指定 <code>session</code>域的键</td>
</tr>
<tr>
<td><code>boolean required() default true</code></td>
<td><code>session</code>域是否必须包含指定键</td>
</tr>
</tbody></table>
<ul>
<li>定义在形参上：将 <code>session</code> 域中指定键的值赋给形参</li>
</ul>
<h2 id="7-9-POST-请求乱码"><a href="#7-9-POST-请求乱码" class="headerlink" title="7.9 POST 请求乱码"></a>7.9 POST 请求乱码</h2><ul>
<li>在<code>web.xml</code>中配置 Spring 提供的过滤器 <code>CharacterEncodingFilter</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;UTF-8&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<h1 id="八-响应"><a href="#八-响应" class="headerlink" title="八 响应"></a>八 响应</h1><h2 id="8-1-响应数据"><a href="#8-1-响应数据" class="headerlink" title="8.1 响应数据"></a>8.1 响应数据</h2><h3 id="1-Map-Model-ModelMap"><a href="#1-Map-Model-ModelMap" class="headerlink" title="1 Map Model ModelMap"></a>1 <code>Map</code> <code>Model</code> <code>ModelMap</code></h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Frame/SpringMVC/Model%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt=""></p>
<ol>
<li><p>形参声明对应类型，之后添加数据即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Model addAttribute(String attributeName, Object attributeValue)</span><br><span class="line">Model addAllAttributes(Map&lt;String, ?&gt; attributes)</span><br></pre></td></tr></table></figure>
</li>
<li><p>这三种类型最终都是使用 <code>BindingAwareModelMap</code></p>
</li>
<li><p>数据保存在 <code>request</code> 域中</p>
</li>
</ol>
<h3 id="2-ModelAndView"><a href="#2-ModelAndView" class="headerlink" title="2 ModelAndView"></a>2 <code>ModelAndView</code></h3><ol>
<li><p>创建 <code>ModelAndView</code>，之后添加数据，设置视图，最后返回即可</p>
</li>
<li><p>数据保存在  <code>request</code> 域中</p>
</li>
<li><p>处理器无论返回值是什么，其实最终返回的都是 <code>ModelAndView</code></p>
</li>
<li><p>添加数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ModelAndView addObject(String attributeName, Object attributeValue)</span><br><span class="line">ModelAndView addAllObjects(@Nullable Map&lt;String, ?&gt; modelMap)</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置视图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void setViewName(String viewName)</span><br><span class="line">void setView(View view)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="3-SessionAttributes"><a href="#3-SessionAttributes" class="headerlink" title="3 @SessionAttributes"></a>3 <code>@SessionAttributes</code></h3><h4 id="1-说明-3"><a href="#1-说明-3" class="headerlink" title="1 说明"></a>1 说明</h4><ol>
<li>定义在类上</li>
<li>根据配置（属性名称或类型）将存储在 <code>BindingAwareModelMap</code> （即使用 <code>Map Model ModelMap</code>）中的数据，存储一份到  <code>session</code> 域中</li>
</ol>
<h4 id="2-属性-3"><a href="#2-属性-3" class="headerlink" title="2 属性"></a>2 属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String[] value() default {}</code></td>
<td>同 <code>names()</code></td>
</tr>
<tr>
<td><code>String[] names() default {}</code></td>
<td>指定被存入 <code>session</code> 域的 <code>key</code> 名称</td>
</tr>
<tr>
<td><code>Class&lt;?&gt;[] types() default {}</code></td>
<td>指定被存入 <code>session</code> 域的 <code>value</code> 类型</td>
</tr>
</tbody></table>
<h3 id="4-ModelAttribute"><a href="#4-ModelAttribute" class="headerlink" title="4 @ModelAttribute"></a>4 <code>@ModelAttribute</code></h3><h4 id="1-说明-4"><a href="#1-说明-4" class="headerlink" title="1 说明"></a>1 说明</h4><ol>
<li>定义在方法上：则当前方法会在 <code>Controller</code> 中每个方法执行前执行</li>
<li>定义在形参上：以指定 <code>key</code> 从 <code>BindingAwareModelMap</code> 获取数据</li>
</ol>
<h4 id="2-属性-4"><a href="#2-属性-4" class="headerlink" title="2 属性"></a>2 属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String value() default &quot;&quot;</code></td>
<td>同 <code>name()</code></td>
</tr>
<tr>
<td><code>String name() default &quot;&quot;</code></td>
<td>指定 <code>key</code></td>
</tr>
</tbody></table>
<h4 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3 应用场景"></a>3 应用场景</h4><h5 id="1-说明-5"><a href="#1-说明-5" class="headerlink" title="1 说明"></a>1 说明</h5><ol>
<li><p>更新操作时，使用实体类接收表单请求数据，而有些字段并不想修改，所以表单提交的数据可能不是全字段，那么封装的实体类中没有提交的字段就为空，如果此时执行更新操作，就会导致数据库丢失相应字段的原有数据</p>
</li>
<li><p>例如，更新用户的 <code>name</code>，表单提交数据只有 <code>name</code> 的值，使用实体类 <code>name age</code> 接收，则 <code>age</code> 为空，更新之后，就会导致数据库中用户丢失原有 <code>age</code> 值</p>
</li>
<li><p>解决方式</p>
<ol>
<li>使用隐藏域（不安全，字段多麻烦）</li>
<li>在处理方法中，更新前手动设置（麻烦）</li>
<li>不使用新封装的实体类对象，而是从数据库中查询对应对象，需要更新的字段使用提交的更新数据，不需要更新的字段使用数据库中原有数据（店长推荐）</li>
</ol>
</li>
</ol>
<h5 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2 步骤"></a>2 步骤</h5><ol>
<li><code>@ModelAttribute</code> 定义在一个方法上，此方法会在目标方法执行前执行，所以可以在此方法中从数据库查询数据，并存入 <code>BindingAwareModelMap</code></li>
<li>在目标方法中，使用 <code>@ModelAttribute</code>  修饰形参，则 SpringMVC 不会直接创建相应对象，而是从  <code>BindingAwareModelMap</code> 获取，则使用的就是从数据库中查询到的实体类对象</li>
</ol>
<h2 id="8-2-转发和重定向"><a href="#8-2-转发和重定向" class="headerlink" title="8.2 转发和重定向"></a>8.2 转发和重定向</h2><ol>
<li>处理器返回指定前缀的字符串<ol>
<li><code>forward:转发路径</code>：转发</li>
<li><code>redirect:重定向路径</code>：重定向<ul>
<li>SpringMVC 会自动为重定向路径添加应用名，所以不用加应用名</li>
</ul>
</li>
</ol>
</li>
<li>带有前缀时，不会走视图解析器</li>
</ol>
<h1 id="九-JSON"><a href="#九-JSON" class="headerlink" title="九 JSON"></a>九 JSON</h1><h2 id="9-1-HttpMessageConverter-lt-T-gt"><a href="#9-1-HttpMessageConverter-lt-T-gt" class="headerlink" title="9.1 HttpMessageConverter&lt;T&gt;"></a>9.1 <code>HttpMessageConverter&lt;T&gt;</code></h2><h3 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>Spring3.0 新添加的接口 </li>
<li>负责将请求信息转换为 T 类型，或将 T 类型输出为响应信息</li>
<li><code>DispatcherServlet</code> 默认装配 <code>RequestMappingHandlerAdapter</code>，而 <code>RequestMappingHandlerAdapter</code> 默认装配了一些 <code>HttpMessageConverter</code> 的实现</li>
<li>如果导入了 <code>JackSon</code> 的包，<code>RequestMappingHandlerAdapter</code> 就会多装配一个 <code>MappingJackson2HttpMessageConverter</code></li>
</ol>
<h3 id="2-实现类"><a href="#2-实现类" class="headerlink" title="2 实现类"></a>2 实现类</h3><table>
<thead>
<tr>
<th>实现类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>StringHttpMessageConverter</code></td>
<td>读写 String</td>
</tr>
<tr>
<td><code>ByteArrayHttpMessageConverter</code></td>
<td>读写二进制数据</td>
</tr>
<tr>
<td><code>MappingJackson2HttpMessageConverter</code></td>
<td>利用 <code>JackSon</code> 的 <code>ObjectMapper</code> 读写 JSON 数据</td>
</tr>
</tbody></table>
<h2 id="9-2-ResponseBody"><a href="#9-2-ResponseBody" class="headerlink" title="9.2 @ResponseBody"></a>9.2 <code>@ResponseBody</code></h2><ol>
<li>定义在类上或方法上</li>
<li>添加了此注解，则方法不再响应视图，而是直接响应数据</li>
<li>如果想响应 JSON 数据，在方法内部转为 JSON 并返回即可</li>
</ol>
<h2 id="9-3-RequestBody"><a href="#9-3-RequestBody" class="headerlink" title="9.3 @RequestBody"></a>9.3 <code>@RequestBody</code></h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean required() default true</code></td>
<td>是否必须有请求体</td>
</tr>
</tbody></table>
<ul>
<li>定义在形参上：用于获取请求体的内容（GET 不可用）</li>
</ul>
<h2 id="9-4-RestController"><a href="#9-4-RestController" class="headerlink" title="9.4 @RestController"></a>9.4 <code>@RestController</code></h2><ol>
<li>定义在类上</li>
<li>相当于同时添加了 <code>@Controller</code> 和 <code>@ResponseBody</code></li>
</ol>
<h2 id="9-5-JSON-处理"><a href="#9-5-JSON-处理" class="headerlink" title="9.5 JSON 处理"></a>9.5 JSON 处理</h2><ol>
<li><p>配置 <code>&lt;mvc:annotation-driven/&gt;</code>，为了支持 <code>@RequestBody 和 @ResponseBody</code></p>
</li>
<li><p>在处理方法上添加 <code>@ResponseBody</code> 注解</p>
</li>
<li><p>导入所使用的工具包：</p>
<ol>
<li><code>JackSon</code><ul>
<li>SpringMVC 内部有 <code>JackSon</code> 转换器，添加了 <code>JackSon</code> 的依赖后，会自动将返回值转为 JSON</li>
</ul>
</li>
<li><code>GSON FastJson ...</code><ul>
<li>在方法内部手动转为 JSON 并返回</li>
</ul>
</li>
</ol>
</li>
<li><p>注意：</p>
<ul>
<li><p>当使用分步查询时，如果开启了延迟加载，关联属性没有值会导致转 json 异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select s.s_id,s.s_name,s.gender,s.hobby,s.birthday,s.t_id,t.t_id,t.t_name,t.gender sex from student s,teacher t where s.s_id=#&#123;id&#125; and s.t_id=t.t_id</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<h1 id="十-数据绑定的处理"><a href="#十-数据绑定的处理" class="headerlink" title="十 数据绑定的处理"></a>十 数据绑定的处理</h1><h2 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h2><ol>
<li>数据绑定的核心部件是 <code>DataBinder</code></li>
<li><code>ConversionService</code>：数据类型转换和格式化</li>
<li><code>Validator</code>：数据校验</li>
</ol>
<h2 id="10-2-类型转换"><a href="#10-2-类型转换" class="headerlink" title="10.2 类型转换"></a>10.2 类型转换</h2><h3 id="1-概述-4"><a href="#1-概述-4" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>页面提交的数据都是字符串，而 <code>JavaBean</code> 中属性有各种各样的类型</li>
<li>SpringMVC 提供了许多转换器可以完成大多数的转换，如果有特殊需求可以自定义转换器</li>
</ol>
<h3 id="2-自定义转换器"><a href="#2-自定义转换器" class="headerlink" title="2 自定义转换器"></a>2 自定义转换器</h3><ol>
<li><p>Spring 定义了 3 中类型转换接口，实现任意一种</p>
<ol>
<li><code>Converter&lt;S,T&gt;</code></li>
<li><code>ConverterFactory</code></li>
<li><code>GenericConverter</code></li>
</ol>
</li>
<li><p>配置 <code>ConversionService</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;转换器工厂id&quot; class=&quot;org.springframework.format.support.ConversionServiceFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;converters&quot;&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;bean class=&quot;自定义转换器全类名&quot;/&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>让 SpringMVC 使用自定义 <code>ConversionService</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mvc:annotation-driven conversion-service=“转换器工厂id”/&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="10-3-格式化"><a href="#10-3-格式化" class="headerlink" title="10.3 格式化"></a>10.3 格式化</h2><h3 id="1-FormattingConversionService"><a href="#1-FormattingConversionService" class="headerlink" title="1 FormattingConversionService"></a>1 <code>FormattingConversionService</code></h3><ul>
<li>既具有 类 型 转换功能又具有格式化功能</li>
</ul>
<h3 id="2-FormattingConversionServiceFactroyBean"><a href="#2-FormattingConversionServiceFactroyBean" class="headerlink" title="2 FormattingConversionServiceFactroyBean"></a>2 <code>FormattingConversionServiceFactroyBean</code></h3><ol>
<li><code>&lt;mvc:annotation-driven/&gt;</code> 默认创建的 <code>ConversionService</code> 实例即为此工厂 bean</li>
<li><code>@DateTiemFormat</code></li>
<li><code>@NumberFormat</code></li>
</ol>
<h2 id="10-4-校验"><a href="#10-4-校验" class="headerlink" title="10.4 校验"></a>10.4 校验</h2><h3 id="1-JSR303"><a href="#1-JSR303" class="headerlink" title="1 JSR303"></a>1 JSR303</h3><ol>
<li>java 为 bean 数据合法校验提供的标准框架，包含在 javaee6.0 中</li>
<li>通过在字段上加注解<ol>
<li><code>@Null</code></li>
<li><code>@NotNull</code></li>
<li><code>@Pattern(value)</code></li>
<li><code>...</code></li>
</ol>
</li>
</ol>
<h3 id="2-Spring-的校验"><a href="#2-Spring-的校验" class="headerlink" title="2 Spring 的校验"></a>2 Spring 的校验</h3><ol>
<li>Spring 有自己的校验框架，同时支持 jsr303</li>
<li><code>LocalValidatorFactoryBean</code> <ol>
<li>实现了 Spring 的 <code>Validator</code>接口，也实现了 jsr303 的 <code>Validator</code> 接口</li>
<li><code>&lt;mvc:annotation-driver/&gt;</code> 默认会装配好一个此对象</li>
</ol>
</li>
</ol>
<h1 id="十一-拦截器"><a href="#十一-拦截器" class="headerlink" title="十一 拦截器"></a>十一 拦截器</h1><h2 id="11-1-概述"><a href="#11-1-概述" class="headerlink" title="11.1 概述"></a>11.1 概述</h2><ol>
<li>过滤器是 JavaWeb 技术，而拦截器是 SpringMVC 独有的</li>
<li>过滤器可以过滤任意请求，而拦截器只拦截 <code>Controller</code> 中的目标方法</li>
</ol>
<h2 id="11-2-HandlerInterceptor"><a href="#11-2-HandlerInterceptor" class="headerlink" title="11.2 HandlerInterceptor"></a>11.2 <code>HandlerInterceptor</code></h2><h3 id="1-API"><a href="#1-API" class="headerlink" title="1 API"></a>1 API</h3><ol>
<li><code>boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</code><ul>
<li>目标方法执行前调用，<code>true</code>：放行，<code>false</code>：不放行</li>
</ul>
</li>
<li><code>void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</code><ul>
<li>目标方法执行后，渲染视图前调用</li>
</ul>
</li>
<li><code>void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</code><ul>
<li>渲染视图后调用，即到达目标页面之后</li>
</ul>
</li>
<li>`</li>
</ol>
<h3 id="2-多个拦截器执行顺序"><a href="#2-多个拦截器执行顺序" class="headerlink" title="2 多个拦截器执行顺序"></a>2 多个拦截器执行顺序</h3><ol>
<li>按照配置顺序<ol>
<li>正序 <code>preHandler</code></li>
<li>目标方法</li>
<li>逆序 <code>postHandler</code></li>
<li>渲染视图后</li>
<li>逆序 <code>afterCompletion</code></li>
</ol>
</li>
<li>假如有三个拦截器 `1 2 3``<ul>
<li><code>pre1 pre2 pre3 handler post3 post2 post1 after3 after2 after1</code></li>
</ul>
</li>
</ol>
<h2 id="11-3-自定义拦截器"><a href="#11-3-自定义拦截器" class="headerlink" title="11.3 自定义拦截器"></a>11.3 自定义拦截器</h2><ol>
<li><p>实现<code>HandlerInterceptor</code> 或 继承<code>HandlerInterceptorAdapter</code></p>
</li>
<li><p>在 SpringMVC 配置文件中注册拦截器</p>
<ol>
<li><p>拦截所有方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">	// 1 注册拦截器</span><br><span class="line">	&lt;bean class=&quot;自定义拦截器全类名&quot;/&gt; </span><br><span class="line">	// 2 注册拦截器</span><br><span class="line">	&lt;ref bean=&quot;bean的id&quot;/&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义拦截规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">	// 一个拦截器对应一个 &lt;mvc:interceptor&gt;</span><br><span class="line">	&lt;mvc:interceptor&gt;</span><br><span class="line">		&lt;!-- 哪些方法进行拦截 --&gt;</span><br><span class="line">		&lt;mvc:mapping path=&quot;/user/*&quot;/&gt;</span><br><span class="line">		&lt;!-- 哪些方法不进行拦截 --&gt;</span><br><span class="line">		&lt;mvc:exclude-mapping path=&quot;&quot;/&gt;</span><br><span class="line">		&lt;!-- 注册拦截器--&gt;</span><br><span class="line">		&lt;bean class=&quot;自定义拦截器全类名&quot;/&gt;</span><br><span class="line">	&lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h1 id="十二-异常处理"><a href="#十二-异常处理" class="headerlink" title="十二 异常处理"></a>十二 异常处理</h1><h2 id="12-1-异常解析器"><a href="#12-1-异常解析器" class="headerlink" title="12.1 异常解析器"></a>12.1 异常解析器</h2><ol>
<li>SpringMVC 的 <code>DispatcherServlet</code> 组件中有异常解析器<code>HandlerExceptionResolver</code></li>
<li><code>dao，service，controller...</code> 出现异常都往上抛，最后抛给<code>DispatcherServlet</code></li>
<li><code>DispatcherServlet</code><ol>
<li>有异常解析器，则交给异常解析器，能处理则处理，不能处理则继续抛</li>
<li>无异常解析器，则什么都不做直接响应到页面</li>
</ol>
</li>
</ol>
<h2 id="12-2-默认装配解析器"><a href="#12-2-默认装配解析器" class="headerlink" title="12.2 默认装配解析器"></a>12.2 默认装配解析器</h2><table>
<thead>
<tr>
<th>异常解析器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ExceptionHandlerExcptionResolver</code></td>
<td>处理标有 <code>@ExceptionHandler</code> 注解的异常</td>
</tr>
<tr>
<td><code>ResponseStatusExceptionResolver</code></td>
<td>处理标有 <code>@ResponseStatues</code> 注解的异常</td>
</tr>
<tr>
<td><code>DefaultHandlerExceptionResolver</code></td>
<td>处理 SpringMVC 自己的异常</td>
</tr>
</tbody></table>
<h3 id="1-ExceptionHandler"><a href="#1-ExceptionHandler" class="headerlink" title="1 @ExceptionHandler"></a>1 <code>@ExceptionHandler</code></h3><h4 id="1-说明-6"><a href="#1-说明-6" class="headerlink" title="1 说明"></a>1 说明</h4><ol>
<li>定义在方法上，对当前类有效</li>
<li>表示此方法用来处理此类发生的指定异常<ol>
<li>用形参 <code>Exception e</code> 接收异常</li>
<li>携带异常信息只能使用  <code>ModelAndView</code> ，<code>String Model Map...</code> 不行</li>
</ol>
</li>
</ol>
<h4 id="2-属性-5"><a href="#2-属性-5" class="headerlink" title="2 属性"></a>2 属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Class&lt;? extends Throwable&gt;[] value() default {}</code></td>
<td>指定处理哪些异常</td>
</tr>
</tbody></table>
<h4 id="3-ControllerAdvice"><a href="#3-ControllerAdvice" class="headerlink" title="3 @ControllerAdvice"></a>3 <code>@ControllerAdvice</code></h4><ol>
<li>定义在类上，全局有效</li>
<li>表示此类是一个全局的异常处理类</li>
<li>在类中用 <code>@ExceptionHandler</code> 定义异常处理方法</li>
</ol>
<h3 id="2-ResponseStatues"><a href="#2-ResponseStatues" class="headerlink" title="2 @ResponseStatues"></a>2 <code>@ResponseStatues</code></h3><ol>
<li><p>定义在方法上：方法发生异常时就会触发</p>
</li>
<li><p>定义在自定义异常类上：发生此自定义异常时就会触发</p>
</li>
<li><p>属性</p>
<ol>
<li><code>value</code>：状态码</li>
<li><code>reason</code>：错误信息</li>
</ol>
</li>
</ol>
<h2 id="12-3-手动装配解析器"><a href="#12-3-手动装配解析器" class="headerlink" title="12.3 手动装配解析器"></a>12.3 手动装配解析器</h2><h3 id="SimpleMappingExceptionResolver"><a href="#SimpleMappingExceptionResolver" class="headerlink" title="SimpleMappingExceptionResolver"></a><code>SimpleMappingExceptionResolver</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;</span><br><span class="line">	// 配置哪些异常去哪些页面</span><br><span class="line">	&lt;property name=&quot;exceptionMappings&quot;&gt;</span><br><span class="line">		&lt;props&gt;</span><br><span class="line">			&lt;prop key=&quot;异常全类名&quot;&gt;页面视图名&lt;/prop&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	// 错误信息</span><br><span class="line">	&lt;property name=&quot;exceptionAttribute&quot; value=&quot;自定义request域的key&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>



<ul>
<li>为每个异常指定特定页面，会自动将异常存入request域默认key为<code>exception</code>，也可以自定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean class=&quot;SimpleMappingExceptionResolver&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;exceptionAttribute&quot; value=&quot;自定义request域的key&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;exceptionMappings&quot;&gt;</span><br><span class="line">		&lt;props&gt;</span><br><span class="line">			&lt;prop key=&quot;java.lang.NullPointException&quot;&gt;error1&lt;/prop&gt;</span><br><span class="line">			&lt;prop key=&quot;java.lang.IndexOutOfBoundsException&quot;&gt;error2&lt;/prop&gt;</span><br><span class="line">		&lt;/props&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="处理步骤"><a href="#处理步骤" class="headerlink" title="处理步骤"></a>处理步骤</h3><ol>
<li>使用自定义异常类 或 已有异常类<ul>
<li>用于设置异常信息</li>
</ul>
</li>
<li>异常处理器<ol>
<li>使用内置异常处理器<ul>
<li>内置异常处理器有相应注解来实现携带异常信息跳到特定页面等</li>
</ul>
</li>
<li>自定义异常处理器<ol>
<li>实现<code>HandlerExceptionResoler</code><ul>
<li>在自定义处理器中携带异常信息跳到特定页面</li>
</ul>
</li>
<li>在<code>springmvc.xml</code>中配置异常处理器bean</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="文件上传-amp-下载"><a href="#文件上传-amp-下载" class="headerlink" title="文件上传 &amp; 下载"></a>文件上传 &amp; 下载</h1><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><ul>
<li>其实也是一种参数绑定(安)</li>
<li>使用的是MultipartResolver接口，实现使用的是<code>commons-fileupload</code></li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol>
<li>form表单post请求，<code>enctype=multipart/form-data</code></li>
<li>配置MultipartResolver接口实现类<code>CommonsMultipartResolver</code><ul>
<li>bean id 必须为<code>multipartResolver</code></li>
<li>依赖<code>commons-fileupload和commons-io</code></li>
</ul>
</li>
<li>上传方法中形参<code>MultipartFile file</code><ul>
<li><code>file</code>为表单上传name属性名</li>
</ul>
</li>
<li>使用<code>MultipartFile</code>可以获取文件名，输入流，保存文件等等</li>
</ol>
<h3 id="MultipartFile"><a href="#MultipartFile" class="headerlink" title="MultipartFile"></a>MultipartFile</h3><ul>
<li><code>getOriginalFilename()</code></li>
<li><code>getInputStream()</code></li>
<li><code>void transferTo(File file)</code></li>
<li><code>default void transferTo(Path path)</code></li>
</ul>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><h3 id="基于ResponseEntity实现"><a href="#基于ResponseEntity实现" class="headerlink" title="基于ResponseEntity实现"></a>基于ResponseEntity实现</h3><ul>
<li>返回一个<code>ResponseEntity</code></li>
</ul>
<h3 id="Java通用下载实现"><a href="#Java通用下载实现" class="headerlink" title="Java通用下载实现"></a>Java通用下载实现</h3><ul>
<li>设置响应头告诉浏览器是下载文件<ul>
<li><code>response.setHeader(&quot;content-disposition&quot;, &quot;attachment;filename=&quot;+fileName);</code></li>
</ul>
</li>
<li>设置响应头说明是文件类型<ul>
<li><code>response.setHeader(&quot;content-type&quot;, &quot;image/jpeg&quot;);</code><ul>
<li>设置文件类型是图片</li>
</ul>
</li>
<li><code>response.setContentType(this.getServletContext().getMimeType(fileName))</code><ul>
<li>设置类型为根据文件名获取的类型</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>Frame</category>
      </categories>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/anyeansan.github.io/2020/11/08/%E6%A1%86%E6%9E%B6/Spring/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li><p>Spring 是一个轻量级的控制反转 <code>IOD(DI)</code> 和 面向切面编程 <code>AOP</code> 的开源框架</p>
</li>
<li><p>下载 <code>https://repo.spring.io/webapp/#/home</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">artifacts → libs-release-loacl → springframework → spring</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="二-Spring-优良特性"><a href="#二-Spring-优良特性" class="headerlink" title="二 Spring 优良特性"></a>二 Spring 优良特性</h1><ol>
<li>非侵入式<ul>
<li>基于Spring开发的应用中的对象可以不依赖于 Spring 的 API</li>
</ul>
</li>
<li>依赖注入<ul>
<li><code>DI——Dependency Injection</code>，反转控制（IOC）最经典的实现</li>
</ul>
</li>
<li>面向切面编程<ul>
<li>Aspect Oriented Programming——AOP</li>
</ul>
</li>
<li>容器<ul>
<li>Spring 是一个容器，因为它包含并且管理应用对象的生命周期</li>
</ul>
</li>
<li>组件化<ul>
<li>Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML 和 Java 注解组合这些对象</li>
</ul>
</li>
<li>一站式<ul>
<li>在 IOC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库（实际上 Spring 自身也提供了表述层的 SpringMVC 和持久层的 Spring JDBC）</li>
</ul>
</li>
</ol>
<h1 id="三-Spring-模块"><a href="#三-Spring-模块" class="headerlink" title="三 Spring 模块"></a>三 Spring 模块</h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Frame/Spring/spring-overview.png" alt=""></p>
<h1 id="四-IOC"><a href="#四-IOC" class="headerlink" title="四 IOC"></a>四 IOC</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ol>
<li><code>Inversion of Control</code> 控制反转</li>
<li>控制：资源的获取方式<ol>
<li>主动式：需要什么资源自己创建</li>
<li>被动式：资源不是自己创建的，而是由容器来创建和管理，需要什么资源由容器注入</li>
</ol>
</li>
<li>控制反转：主动的创建资源变为被动的接受资源</li>
</ol>
<h2 id="4-2-DI"><a href="#4-2-DI" class="headerlink" title="4.2 DI"></a>4.2 DI</h2><ol>
<li><code>Dependency Injection</code> 依赖注入</li>
<li><code>IOC</code> 是一种思想，<code>DI</code> 是 <code>IOC</code> 的一种实现</li>
<li>bean 之间的关系<ol>
<li>依赖： <code>has a</code></li>
<li>继承： <code>is a</code></li>
</ol>
</li>
<li>容器通过反射为组件（类）注入运行时所依赖的其它组件</li>
</ol>
<h2 id="4-3-IOC-容器"><a href="#4-3-IOC-容器" class="headerlink" title="4.3 IOC 容器"></a>4.3 IOC 容器</h2><h3 id="1-BeanFactory"><a href="#1-BeanFactory" class="headerlink" title="1 BeanFactory"></a>1 <code>BeanFactory</code></h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>IOC 容器的基本实现，Spring 最底层的接口，负责 Bean 的创建</li>
<li>延迟加载，第一次获取对象 <code>getBean()</code> 时才实例化 Bean</li>
</ol>
<h4 id="2-API"><a href="#2-API" class="headerlink" title="2 API"></a>2 API</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object getBean(String name)</code></td>
<td>根据名称获取 Bean 对象</td>
</tr>
<tr>
<td><code>T getBean(String name, Class&lt;T&gt; requiredType)</code></td>
<td>根据名称和类型获取 Bean 对象</td>
</tr>
</tbody></table>
<h3 id="2-ApplicationContext"><a href="#2-ApplicationContext" class="headerlink" title="2 ApplicationContext"></a>2 <code>ApplicationContext</code></h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li><code>BeanFactory</code> 子接口，更多的负责容器功能的实现</li>
<li>立即加载，创建容器时就会实例化配置的所有 Bean</li>
</ol>
<h4 id="2-小弟"><a href="#2-小弟" class="headerlink" title="2 小弟"></a>2 小弟</h4><table>
<thead>
<tr>
<th>小弟</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ClassPathXmlApplicationContext</code></td>
<td>加载类路径下的 XML 配置创建容器</td>
</tr>
<tr>
<td><code>AnnotationConfigApplicationContext</code></td>
<td>加载注解配置创建容器</td>
</tr>
<tr>
<td><code>FileSystemXmlApplicaitonContext</code></td>
<td>加载磁盘路径下的 XML 配置创建容器</td>
</tr>
<tr>
<td><code>WebApplicationContext</code></td>
<td>WEB 容器</td>
</tr>
</tbody></table>
<h1 id="五-XML-配置"><a href="#五-XML-配置" class="headerlink" title="五 XML 配置"></a>五 XML 配置</h1><h2 id="5-1-配置"><a href="#5-1-配置" class="headerlink" title="5.1 配置"></a>5.1 配置</h2><h3 id="1-import"><a href="#1-import" class="headerlink" title="1 import"></a>1 import</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;import resource=&quot;导入其它配置文件&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-bean"><a href="#2-bean" class="headerlink" title="2 bean"></a>2 bean</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; name=&quot;&quot; class=&quot;&quot; scope=&quot;&quot; autowire=&quot;&quot; parent=&quot;&quot; abstract=&quot;&quot; depends-on=&quot;&quot; init-method=&quot;&quot; destroy-method=&quot;&quot;&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>id</code></td>
<td>唯一标识</td>
</tr>
<tr>
<td><code>name</code></td>
<td>别名，可以有多个用逗号隔开</td>
</tr>
<tr>
<td><code>class</code></td>
<td>全限定类名</td>
</tr>
<tr>
<td><code>scope</code></td>
<td>作用域</td>
</tr>
<tr>
<td><code>autowire</code></td>
<td>自动导入</td>
</tr>
<tr>
<td><code>parent</code></td>
<td>指定当前 Bean 的配置信息继承于哪个 Bean，注意：只是配置信息的继承</td>
</tr>
<tr>
<td><code>abstract</code></td>
<td>表示当前 Bean 是抽象的，不能创建实例，用来被其它 Bean 继承</td>
</tr>
<tr>
<td><code>depends-on</code></td>
<td>表示当前 Bean 依赖于哪些 Bean，多个用逗号隔开，只是改变实例化顺序（默认按配置顺序实例化）</td>
</tr>
<tr>
<td><code>init-method</code></td>
<td>自定义初始化方法</td>
</tr>
<tr>
<td><code>destroy-method</code></td>
<td>自定义销毁方法</td>
</tr>
</tbody></table>
<h3 id="3-引入资源文件"><a href="#3-引入资源文件" class="headerlink" title="3 引入资源文件"></a>3 引入资源文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1</span><br><span class="line">&lt;context:property-placeholder location=&quot;&quot;/&gt;</span><br><span class="line">// 2</span><br><span class="line">&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;location&quot; value=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-Bean-实例化"><a href="#5-2-Bean-实例化" class="headerlink" title="5.2 Bean 实例化"></a>5.2 Bean 实例化</h2><h3 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1 构造方法"></a>1 构造方法</h3><h4 id="1-无参构造"><a href="#1-无参构造" class="headerlink" title="1 无参构造"></a>1 无参构造</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-有参构造"><a href="#2-有参构造" class="headerlink" title="2 有参构造"></a>2 有参构造</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</span><br><span class="line">	&lt;constructor-arg name=&quot;构造参数名&quot; value=&quot;&quot;/&gt;</span><br><span class="line">	&lt;constructor-arg index=&quot;构造参数索引，从0开始&quot; value=&quot;&quot;/&gt;</span><br><span class="line">	&lt;constructor-arg type=&quot;构造参数类型&quot; value=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-静态工厂"><a href="#2-静态工厂" class="headerlink" title="2 静态工厂"></a>2 静态工厂</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot;  class=&quot;静态工厂全类名&quot;  factory-method=&quot;静态工厂中获取 bean的静态方法&quot;&gt;</span><br><span class="line">	// 方法传参</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-实例工厂"><a href="#3-实例工厂" class="headerlink" title="3 实例工厂"></a>3 实例工厂</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 必须先有工厂实例对象，通过工厂实例对象创建对象</span><br><span class="line">&lt;bean id=&quot;&quot; class=&quot;工厂全限定类名&quot;&gt;</span><br><span class="line">&lt;bean id=&quot;&quot; factory-bean=&quot;工厂beanID&quot; factory-method=&quot;工厂中获取 bean 的方法&quot;&gt;</span><br><span class="line">	// 方法传参</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-FactoryBean"><a href="#4-FactoryBean" class="headerlink" title="4 FactoryBean"></a>4 FactoryBean</h3><h4 id="1-API"><a href="#1-API" class="headerlink" title="1 API"></a>1 API</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>T getObject()</code></td>
<td>Spring 自动调用，返回创建对象</td>
</tr>
<tr>
<td><code>Class&lt;?&gt; getObjectType()</code></td>
<td>Spring 自动调用，获取创建对象的类型</td>
</tr>
<tr>
<td><code>boolean isSingleton()</code></td>
<td>Spring 自动调用，确定是否是单例</td>
</tr>
</tbody></table>
<h4 id="2-说明"><a href="#2-说明" class="headerlink" title="2 说明"></a>2 说明</h4><ol>
<li>对于实现了 <code>FactoryBean</code> 接口的类，Spring 会把它当成一个工厂 <code>factory bean</code> </li>
<li>配置工厂 Bean 不会返回此工厂本身，而是返回其 <code>getObject()</code> 方法返回的Bean 对象</li>
</ol>
<h2 id="5-3-Bean-作用域"><a href="#5-3-Bean-作用域" class="headerlink" title="5.3 Bean 作用域"></a>5.3 Bean 作用域</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;  scope=&quot;&quot;&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><code>scope</code></th>
<th>说明</th>
<th>创建时机</th>
</tr>
</thead>
<tbody><tr>
<td><code>singleton</code>（默认）</td>
<td>并非 bean 本身是单例的，而是指 bean 在 IOC 容器中是单例的</td>
<td>IOC 容器创建时就会创建 bean</td>
</tr>
<tr>
<td><code>prototype</code></td>
<td>多例</td>
<td>每次获取时创建一个新的 bean</td>
</tr>
<tr>
<td><code>request</code></td>
<td>请求范围，仅适用于 <code>WebApplicationContext</code> 环境</td>
<td>每次 HTTP 请求共享一个bean</td>
</tr>
<tr>
<td><code>session</code></td>
<td>会话范围，仅适用于 <code>WebApplicationContext</code> 环境</td>
<td>每个 session 共享一个 bean</td>
</tr>
<tr>
<td><code>application</code></td>
<td>应用范围，仅适用于 <code>WebApplicationContext</code> 环境</td>
<td>每个 application 共享一个 bean</td>
</tr>
</tbody></table>
<h2 id="5-4-依赖注入方式"><a href="#5-4-依赖注入方式" class="headerlink" title="5.4 依赖注入方式"></a>5.4 依赖注入方式</h2><h3 id="1-手动装配"><a href="#1-手动装配" class="headerlink" title="1 手动装配"></a>1 手动装配</h3><h4 id="1-构造器注入（有参构造）"><a href="#1-构造器注入（有参构造）" class="headerlink" title="1 构造器注入（有参构造）"></a>1 构造器注入（有参构造）</h4><h4 id="2-set-注入"><a href="#2-set-注入" class="headerlink" title="2 set 注入"></a>2 set 注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;&quot; value=&quot;基本类型&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;&quot; ref=&quot;引用类型&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-c-命名空间"><a href="#3-c-命名空间" class="headerlink" title="3 c 命名空间"></a>3 c 命名空间</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot; c:name=value c:name-ref=value&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>用 <code>c</code> 替换构造注入中的 <code>&lt;constructor-arg&gt;</code>，直接注入构造参数</li>
</ol>
<h4 id="4-P-命名空间"><a href="#4-P-命名空间" class="headerlink" title="4 P 命名空间"></a>4 P 命名空间</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot; p:name=value p:name-ref=value&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>用 <code>p</code> 替换 set 注入中的 <code>&lt;property&gt;</code> 标签，直接注入属性值</li>
<li><code>&lt;property name=&quot;key&quot; value=&quot;value&quot;/&gt;</code> → <code>p:key=&quot;value&quot;</code></li>
<li><code>&lt;property name=&quot;key&quot; ref=&quot;value&quot;&gt;</code> → <code>p:key-ref=&quot;value&quot;</code></li>
</ol>
<h4 id="5-SpEL"><a href="#5-SpEL" class="headerlink" title="5 SpEL"></a>5 SpEL</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;&quot; value=&quot;#&#123;spEL表达式&#125;&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>#{123}</code></td>
<td>数字</td>
</tr>
<tr>
<td><code>#{&#39;abc&#39;}</code></td>
<td>字符串</td>
</tr>
<tr>
<td><code>#{beanId}</code></td>
<td>bean</td>
</tr>
<tr>
<td><code>#{beanId.propName}</code></td>
<td>bean 的属性</td>
</tr>
<tr>
<td><code>#{beanId.method()}</code></td>
<td>执行 bean 的方法</td>
</tr>
<tr>
<td><code>#{xx?.method()}</code></td>
<td>如果 <code>xx</code> 不为空则调用方法，否则不调用</td>
</tr>
<tr>
<td><code>#{Type.field/method()}</code></td>
<td>静态属性/方法</td>
</tr>
</tbody></table>
<h3 id="2-自动装配-autowire"><a href="#2-自动装配-autowire" class="headerlink" title="2 自动装配 autowire"></a>2 自动装配 autowire</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; name=&quot;&quot; class=&quot;&quot; autowire=&quot;&quot;&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><code>autowire</code></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>default/no</code></td>
<td>默认，不自动装配</td>
</tr>
<tr>
<td><code>byName</code></td>
<td>查找与 <code>set</code> 方法后边的值（第一个字母小写） 相同的 <code>beanID</code></td>
</tr>
<tr>
<td><code>byType</code></td>
<td>查找与属性类型相同的 <code>bean</code> ，如果此类型有多个会报错</td>
</tr>
<tr>
<td><code>constructor</code></td>
<td>按照构造器注入</td>
</tr>
</tbody></table>
<h2 id="5-5-依赖注入类型"><a href="#5-5-依赖注入类型" class="headerlink" title="5.5 依赖注入类型"></a>5.5 依赖注入类型</h2><h3 id="1-null"><a href="#1-null" class="headerlink" title="1 null"></a>1 null</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean&gt;</span><br><span class="line">	&lt;property name=&quot;&quot;&gt;</span><br><span class="line">		&lt;null/&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-基本类型及其包装类，String"><a href="#2-基本类型及其包装类，String" class="headerlink" title="2 基本类型及其包装类，String"></a>2 基本类型及其包装类，String</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean&gt;</span><br><span class="line">	&lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-Java-Bean"><a href="#3-Java-Bean" class="headerlink" title="3 Java Bean"></a>3 Java Bean</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1 外部 bean</span><br><span class="line">&lt;bean&gt;</span><br><span class="line">	&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">// 2 内部 bean</span><br><span class="line">&lt;bean&gt;</span><br><span class="line">    &lt;property name=&quot;&quot;&gt;</span><br><span class="line">        &lt;bean&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-数组-集合"><a href="#4-数组-集合" class="headerlink" title="4 数组/集合"></a>4 数组/集合</h3><h4 id="1-数组"><a href="#1-数组" class="headerlink" title="1 数组"></a>1 数组</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean&gt;</span><br><span class="line">    &lt;property name=&quot;&quot;&gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">        	// 1 简单类型值</span><br><span class="line">            &lt;value&gt;&lt;/value&gt;</span><br><span class="line">            // 2 外部 bean</span><br><span class="line">            &lt;ref bean=&quot;&quot;/&gt;</span><br><span class="line">            // 3 内部 bean</span><br><span class="line">            &lt;bean&gt;&lt;/bean&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-List"><a href="#2-List" class="headerlink" title="2 List"></a>2 List</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean&gt;</span><br><span class="line">    &lt;property name=&quot;&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;&lt;/value&gt;</span><br><span class="line">            &lt;ref bean=&quot;&quot;/&gt;</span><br><span class="line">            &lt;bean&gt;&lt;/bean&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-Set"><a href="#3-Set" class="headerlink" title="3 Set"></a>3 Set</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean&gt;</span><br><span class="line">    &lt;property name=&quot;&quot;&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;value&gt;&lt;/value&gt;</span><br><span class="line">            &lt;ref bean=&quot;&quot;/&gt;</span><br><span class="line">            &lt;bean&gt;&lt;/bean&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-Map"><a href="#4-Map" class="headerlink" title="4 Map"></a>4 Map</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean&gt;</span><br><span class="line">    &lt;property name=&quot;&quot;&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=&quot;&quot; value=&quot;&quot;/&gt;</span><br><span class="line">            &lt;entry key=&quot;&quot; value-ref=&quot;&quot;/&gt;</span><br><span class="line">            &lt;entry key=&quot;&quot;&gt;</span><br><span class="line">            	&lt;bean&gt;&lt;/bean&gt;</span><br><span class="line">            &lt;/entry&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="5-Properties"><a href="#5-Properties" class="headerlink" title="5 Properties"></a>5 Properties</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean&gt;</span><br><span class="line">    &lt;property name=&quot;&quot;&gt;</span><br><span class="line">        &lt;props&gt;</span><br><span class="line">            &lt;prop key=&quot;&quot;&gt;value&lt;/prop&gt;</span><br><span class="line">        &lt;/props&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="6-util-名称空间"><a href="#6-util-名称空间" class="headerlink" title="6 util 名称空间"></a>6 <code>util</code> 名称空间</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 使用 Util 名称空间创建集合类型的 bean，方便其它人引用</span><br><span class="line">&lt;util:list id=&quot;&quot;&gt;&lt;/util:list&gt;</span><br><span class="line">&lt;util:set id=&quot;&quot;&gt;&lt;/util:set&gt;</span><br><span class="line">&lt;util:map id=&quot;&quot;&gt;&lt;/util:map&gt;</span><br><span class="line">&lt;util:properties id=&quot;&quot;&gt;&lt;/util:properties&gt;</span><br></pre></td></tr></table></figure>

<h2 id="5-6-Bean-生命周期"><a href="#5-6-Bean-生命周期" class="headerlink" title="5.6 Bean 生命周期"></a>5.6 Bean 生命周期</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Frame/Spring/Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt=""></p>
<h3 id="1-BeanPostProcessor"><a href="#1-BeanPostProcessor" class="headerlink" title="1 BeanPostProcessor"></a>1 BeanPostProcessor</h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>后置处理器</li>
<li>spring 提供的工厂勾子，用于修改实例对象，如可以生成代理对象，是AOP 底层</li>
<li>只要实现此接口，并将实现类提供给 spring 容器，则会自动针对 spring 容器中的所有 bean，如果要针对某一个目标类，可以利用方法中的 <code>beanName</code> （即 BeanID）参数</li>
</ol>
<h4 id="2-API-1"><a href="#2-API-1" class="headerlink" title="2 API"></a>2 API</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object postProcessBeforeInitialization(Object bean, String beanName)</code></td>
<td>初始化方法前执行</td>
</tr>
<tr>
<td><code>Object postProcessAfterInitialization(Object bean, String beanName)</code></td>
<td>初始化方法后执行</td>
</tr>
</tbody></table>
<h4 id="3-类创建流程"><a href="#3-类创建流程" class="headerlink" title="3 类创建流程"></a>3 类创建流程</h4><ol>
<li>一般过程</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A a=new A()</span><br><span class="line">a.init()</span><br><span class="line">a.add()</span><br><span class="line">a.destroy()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>现有一类 B 实现了 BeanPostProcessor 接口</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A a=new A()</span><br><span class="line">// 在后处理 Bean 方法前后都可以返回代理对象</span><br><span class="line">a/aProxy=B.postProcessBeforeInitialization(a)</span><br><span class="line">a.init()</span><br><span class="line">a/aproxy=B.postProcessAfterInitialization(a)</span><br><span class="line">a.add()</span><br><span class="line">a.destroy()</span><br></pre></td></tr></table></figure>

<h1 id="六-注解配置"><a href="#六-注解配置" class="headerlink" title="六 注解配置"></a>六 注解配置</h1><h2 id="6-1-配置"><a href="#6-1-配置" class="headerlink" title="6.1 配置"></a>6.1 配置</h2><h3 id="1-开启注解"><a href="#1-开启注解" class="headerlink" title="1 开启注解"></a>1 开启注解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;context:annotation-config/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-注解扫描"><a href="#2-注解扫描" class="headerlink" title="2 注解扫描"></a>2 注解扫描</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;&quot; use-default-filters=&quot;&quot;&gt;</span><br><span class="line">    &lt;context:include-filter type=&quot;&quot; expression=&quot;&quot;/&gt;</span><br><span class="line">    &lt;context:exclude-filter type=&quot;&quot; expression=&quot;&quot;/&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>配置了注解扫描则会开启注解，即不需要再配置 <code>&lt;context:annotation-config/&gt;</code> </li>
<li><code>use-default-filters</code><ol>
<li><code>true</code>，默认，表示使用 <code>exclude</code>，排除某些类</li>
<li><code>false</code>，表示使用 <code>include</code>，仅扫描某些类</li>
</ol>
</li>
<li><code>type</code><ol>
<li><code>annotation</code>，则 <code>expression</code> 为注解全限定类名</li>
<li><code>assignable</code>，则 <code>expression</code> 为 bean 全限定类名</li>
</ol>
</li>
</ol>
<h2 id="6-2-Bean-实例化"><a href="#6-2-Bean-实例化" class="headerlink" title="6.2 Bean 实例化"></a>6.2 Bean 实例化</h2><h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1 分类"></a>1 分类</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Component</code></td>
<td>用在任意层，不指定 <code>beanID</code> 则默认为类名首字母小写</td>
</tr>
<tr>
<td><code>@Controller</code></td>
<td>用在 WEB 层，不指定 <code>beanID</code> 则默认为类名首字母小写</td>
</tr>
<tr>
<td><code>@Service</code></td>
<td>用在 Service 层，不指定 <code>beanID</code> 则默认为类名首字母小写</td>
</tr>
<tr>
<td><code>@Repository</code></td>
<td>用在 DAO 层，不指定 <code>beanID</code> 则默认为类名首字母小写</td>
</tr>
</tbody></table>
<h3 id="2-实例化注解属性"><a href="#2-实例化注解属性" class="headerlink" title="2 实例化注解属性"></a>2 实例化注解属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String value() default &quot;&quot;</code></td>
<td>指定 <code>beanID</code></td>
</tr>
</tbody></table>
<h2 id="6-3-Bean-作用域-Scope"><a href="#6-3-Bean-作用域-Scope" class="headerlink" title="6.3 Bean 作用域 @Scope"></a>6.3 Bean 作用域 <code>@Scope</code></h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String scopeName() default &quot;&quot;</code></td>
<td>作用域名，<code>singleton prototype ...</code></td>
</tr>
<tr>
<td><code>String value() default &quot;&quot;</code></td>
<td>同 <code>scopeName()</code></td>
</tr>
</tbody></table>
<h2 id="6-4-依赖注入"><a href="#6-4-依赖注入" class="headerlink" title="6.4 依赖注入"></a>6.4 依赖注入</h2><h3 id="1-value"><a href="#1-value" class="headerlink" title="1 @value"></a>1 <code>@value</code></h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String value()</code></td>
<td>注入基本数据类型和 String，值可以使用 <code>${spEL}</code> 表达式</td>
</tr>
</tbody></table>
<h3 id="2-Autowired"><a href="#2-Autowired" class="headerlink" title="2 @Autowired"></a>2 <code>@Autowired</code></h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean required() default true</code></td>
<td><code>true</code> 表示此属性必须注入值，<code>false</code> 表示若没有注入则为 <code>null</code></td>
</tr>
</tbody></table>
<ol>
<li>可用在 <code>构造 属性 方法 形参</code> 上，如果定义在方法上，则此方法会在 Bean 创建时自动运行，且为每个形参自动注入</li>
<li>首先按照 <code>byType</code> 注入，如果有多个相同类型则再按照 <code>byName</code> 注入</li>
</ol>
<h3 id="3-Qualifier"><a href="#3-Qualifier" class="headerlink" title="3 @Qualifier"></a>3 <code>@Qualifier</code></h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String value() default &quot;&quot;</code></td>
<td>值为 <code>beanID</code></td>
</tr>
</tbody></table>
<ol>
<li>作用在属性上<ol>
<li>不能单独使用，要配合 <code>@autowire</code></li>
<li>按照类型注入且指定 <code>beanID</code></li>
</ol>
</li>
<li>作用在 <code>set</code> 方法上<ol>
<li>可单独使用</li>
<li>按照 <code>beanID</code> 注入</li>
</ol>
</li>
</ol>
<h3 id="4-Resource"><a href="#4-Resource" class="headerlink" title="4 @Resource"></a>4 <code>@Resource</code></h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String name() default &quot;&quot;</code></td>
<td><code>beanID</code></td>
</tr>
<tr>
<td><code>Class&lt;?&gt; type default Object.class</code></td>
<td><code>bean</code> 的类型</td>
</tr>
</tbody></table>
<ol>
<li>JDK 中的注解</li>
<li>指定 <code>name</code> 和 <code>type</code><ul>
<li>则 Spring 查找指定 <code>beanID</code> 且为指定类型的 bean</li>
</ul>
</li>
<li>指定 <code>name</code><ul>
<li>则 Spring 查找指定 <code>beanID</code> 的 bean</li>
</ul>
</li>
<li>指定 <code>type</code><ul>
<li>则 Spring 查找指定类型的 bean</li>
</ul>
</li>
<li>都不指定<ul>
<li>则首先按照 <code>byName</code> 注入，若找不到则按照 <code>byType</code> 注入</li>
</ul>
</li>
</ol>
<h2 id="6-5-生命周期"><a href="#6-5-生命周期" class="headerlink" title="6.5 生命周期"></a>6.5 生命周期</h2><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>@PostConstruct</code></td>
<td>初始化</td>
</tr>
<tr>
<td><code>@PreDestroy</code></td>
<td>销毁</td>
</tr>
</tbody></table>
<ul>
<li>这两个注解包括 <code>@Resource</code> 都是 JDK 中的注解，在 JDK11 之后移除了，想要使用需要 <code>javax.annotation-api</code> </li>
</ul>
<h2 id="6-6-其它注解"><a href="#6-6-其它注解" class="headerlink" title="6.6 其它注解"></a>6.6 其它注解</h2><h3 id="1-Configuration"><a href="#1-Configuration" class="headerlink" title="1 @Configuration"></a>1 <code>@Configuration</code></h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String value() default &quot;&quot;</code></td>
<td>指定配置类的字节码</td>
</tr>
</tbody></table>
<ol>
<li>定义配置类，用于代替 XML 配置文件</li>
<li>相当于 <code>&lt;beans&gt;</code> 标签</li>
<li>创建容器要使用 <code>ApplicationContext</code> 的注解实现类<code>AnnotationApplicationContext</code></li>
</ol>
<h3 id="2-Bean"><a href="#2-Bean" class="headerlink" title="2 @Bean"></a>2 <code>@Bean</code></h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String[] name() default {}</code></td>
<td>为当前方法创建的 bean 指定 <code>beanID</code>，默认 <code>beanID</code> 为方法名</td>
</tr>
<tr>
<td><code>String[] value() default {}</code></td>
<td>等价于 <code>name()</code></td>
</tr>
</tbody></table>
<ol>
<li><code>@Configuration + @Bean</code></li>
<li><code>@Bean</code> 定义在方法上，相当于 <code>&lt;bean&gt;</code> 标签，将当前方法的返回值作为 Bean 存入 Spring 容器  </li>
</ol>
<h3 id="3-ComponentScan"><a href="#3-ComponentScan" class="headerlink" title="3 @ComponentScan"></a>3 <code>@ComponentScan</code></h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String[] basePackages() default {}</code></td>
<td>指定要扫描的包</td>
</tr>
<tr>
<td><code>String[] value() default {}</code></td>
<td>等价于 <code>basePackages()</code></td>
</tr>
</tbody></table>
<h3 id="4-PropertySource"><a href="#4-PropertySource" class="headerlink" title="4 @PropertySource"></a>4 <code>@PropertySource</code></h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String[] value()</code></td>
<td>指定 <code>.properties</code> 文件路径</td>
</tr>
</tbody></table>
<h3 id="5-Import"><a href="#5-Import" class="headerlink" title="5 @Import"></a>5 <code>@Import</code></h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Class&lt;?&gt;[] value()</code></td>
<td>指定其他配置类的字节码</td>
</tr>
</tbody></table>
<h1 id="七-AOP"><a href="#七-AOP" class="headerlink" title="七 AOP"></a>七 AOP</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ol>
<li><code>Aspect Oriented Programming</code> 面向切面编程</li>
<li>运行期间，将某段代码动态的切入到指定方法的指定位置</li>
<li>AOP 采取横向抽取机制，取代了传统纵向继承体系重复性代码，将核心业务与外围业务（如日志记录、权限校验、异常处理、事务控制…）分离，提高模块化，降低耦合度</li>
</ol>
<h2 id="7-2-AOP-术语"><a href="#7-2-AOP-术语" class="headerlink" title="7.2 AOP 术语"></a>7.2 AOP 术语</h2><table>
<thead>
<tr>
<th>术语</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>横切关注点</td>
<td>从每个方法中抽取出来的同一类非核心业务</td>
</tr>
<tr>
<td><code>Target</code></td>
<td>目标类，需要被代理的类</td>
</tr>
<tr>
<td><code>Joinpoint</code></td>
<td>连接点，目标类中能够被增强的方法</td>
</tr>
<tr>
<td><code>PointCut</code></td>
<td>切入点，已经被增强的连接点</td>
</tr>
<tr>
<td><code>Advice</code></td>
<td>通知，即增强的代码，一个方法</td>
</tr>
<tr>
<td><code>Aspect</code></td>
<td>切面，<code>通知+切入点</code> ，一个类</td>
</tr>
<tr>
<td><code>Weaving</code></td>
<td>织入，把切面应用到目标对象并创建新的代理对象的过程</td>
</tr>
<tr>
<td><code>proxy</code></td>
<td>代理对象</td>
</tr>
</tbody></table>
<h2 id="7-3-AspectJ-amp-Spring-AOP"><a href="#7-3-AspectJ-amp-Spring-AOP" class="headerlink" title="7.3 AspectJ &amp; Spring-AOP"></a>7.3 AspectJ &amp; Spring-AOP</h2><h3 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>AOP 是一种思想，AOP 的底层是动态代理</li>
<li>AspectJ 和 Spring-AOP 是 AOP 的实现框架</li>
<li>Spring-AOP 借用了 AspectJ的配置语法</li>
<li>AspectJ 是静态织入：<ul>
<li>在编译期使用 Aspect J的 acj 编译器(类似javac)把aspect 类编译成 class 字节码后，在 java 目标类编译时织入</li>
</ul>
</li>
<li>Spring-AOP 是动态织入：<ul>
<li>在运行时动态将要增强的代码织入到目标类中</li>
</ul>
</li>
</ol>
<h3 id="2-包"><a href="#2-包" class="headerlink" title="2 包"></a>2 包</h3><ol>
<li><code>spring-aop.jar</code><ul>
<li>aop 实现，依赖于 aop 联盟包 <code>aopalliance.jar</code>（已经集成）</li>
</ul>
</li>
<li><code>spring-aspects.jar</code><ul>
<li>集成 AspectJ，依赖于 aspect 规范包 <code>aspectjweaver.jar</code></li>
</ul>
</li>
</ol>
<h3 id="3-通知-Advice"><a href="#3-通知-Advice" class="headerlink" title="3 通知 Advice"></a>3 通知 Advice</h3><h4 id="1-概述-4"><a href="#1-概述-4" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>AOP 联盟的通知类型  <code>org.aopalliance.aop.Advice</code><ol>
<li>不同的接口代表不同的通知类型</li>
<li>自定义通知实现指定接口即代表此类通知</li>
</ol>
</li>
<li>AspectJ 的通知类型<ol>
<li>每种通知类型有特定的方法格式</li>
<li>自定义通知首先定义指定格式的方法，然后配置为指定类型的通知</li>
</ol>
</li>
</ol>
<h4 id="2-AOP-联盟通知类型"><a href="#2-AOP-联盟通知类型" class="headerlink" title="2 AOP 联盟通知类型"></a>2 AOP 联盟通知类型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>前置通知</td>
<td><code>org.springframework.aop.MethodBeforeAdvice</code></td>
</tr>
<tr>
<td>后置通知</td>
<td><code>org.springframework.aop.AfterReturningAdvice</code></td>
</tr>
<tr>
<td>环绕通知</td>
<td><code>org.aopalliance.intercept.MethodInterceptor</code></td>
</tr>
<tr>
<td>异常通知</td>
<td><code>org.springframework.aop.ThrowsAdvice</code></td>
</tr>
<tr>
<td>引介通知</td>
<td><code>org.springframework.aop.IntroductionInterceptor</code></td>
</tr>
</tbody></table>
<h5 id="1-环绕通知"><a href="#1-环绕通知" class="headerlink" title="1 环绕通知"></a>1 环绕通知</h5><ul>
<li>因为环绕通知是在目标方法前后执行，而系统无法判断哪些代码在前哪些在后，所以需要在环绕通知中手动执行目标方法，用以区分前后</li>
</ul>
<h5 id="2-执行顺序"><a href="#2-执行顺序" class="headerlink" title="2 执行顺序"></a>2 执行顺序</h5><ol>
<li>前置通知</li>
<li>环绕通知（前）</li>
<li>目标方法</li>
<li>环绕通知（后）</li>
<li>后置通知</li>
</ol>
<h4 id="3-AspectJ-通知类型"><a href="#3-AspectJ-通知类型" class="headerlink" title="3 AspectJ 通知类型"></a>3 AspectJ 通知类型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>方法格式</th>
</tr>
</thead>
<tbody><tr>
<td>前置通知 <code>before</code></td>
<td><code>方法名([JoinPoint jp])</code></td>
</tr>
<tr>
<td>后置通知 <code>afterReturning</code></td>
<td><code>方法名([JoinPoint jp], [Object obj])</code>，obj：目标方法返回值</td>
</tr>
<tr>
<td>环绕通知 <code>round</code></td>
<td><code>方法名(ProceedingJoinPoint pjp)</code></td>
</tr>
<tr>
<td>异常通知 <code>afterThrowing</code></td>
<td><code>方法名([JoinPoint jp], [Throwable e])</code></td>
</tr>
<tr>
<td>最终通知 <code>after</code></td>
<td><code>方法名([JoinPoint jp])</code></td>
</tr>
</tbody></table>
<h5 id="1-org-aspectj-lang-JoinPoint"><a href="#1-org-aspectj-lang-JoinPoint" class="headerlink" title="1 org.aspectj.lang.JoinPoint"></a>1 <code>org.aspectj.lang.JoinPoint</code></h5><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Signature getSignature()</code></td>
<td>获取封装了署名信息的对象，该对象可以获取到目标方法名，所属类的 Class 等信息</td>
</tr>
<tr>
<td><code>Object getTarget()</code></td>
<td>获取目标对象</td>
</tr>
<tr>
<td><code>Ojbect getThis()</code></td>
<td>获取代理对象</td>
</tr>
<tr>
<td><code>Object[] getArgs()</code></td>
<td>获取目标方法的形参</td>
</tr>
</tbody></table>
<h5 id="2-org-aspectj-lang-ProceedingJoinPoint-extends-JoinPoint"><a href="#2-org-aspectj-lang-ProceedingJoinPoint-extends-JoinPoint" class="headerlink" title="2 org.aspectj.lang.ProceedingJoinPoint extends JoinPoint"></a>2 <code>org.aspectj.lang.ProceedingJoinPoint extends JoinPoint</code></h5><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object proceed()</code></td>
<td>执行目标方法</td>
</tr>
<tr>
<td><code>Object proceed(Object[] args)</code></td>
<td>使用新的参数执行目标方法</td>
</tr>
</tbody></table>
<h3 id="4-AspectJ-切入点表达式"><a href="#4-AspectJ-切入点表达式" class="headerlink" title="4 AspectJ 切入点表达式"></a>4 AspectJ 切入点表达式</h3><table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>execution(修饰符 返回值 包.类.方法(参数)throws 异常)</code></td>
<td>匹配符合的方法</td>
</tr>
<tr>
<td><code>within(包)</code></td>
<td>匹配包或子包中的方法</td>
</tr>
<tr>
<td><code>this(接口全限定名)</code></td>
<td>匹配实现接口的代理对象中的方法</td>
</tr>
<tr>
<td><code>target(接口全限定名)</code></td>
<td>匹配实现接口的目标对象中的方法</td>
</tr>
<tr>
<td><code>args(参数)</code></td>
<td>匹配符合参数格式的方法</td>
</tr>
<tr>
<td><code>bean(&quot;beanId&quot;)</code></td>
<td>匹配指定 bean 中的所有方法</td>
</tr>
</tbody></table>
<h5 id="execution"><a href="#execution" class="headerlink" title="execution"></a><code>execution</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">execution(修饰符 返回值 包.类.方法(参数)throws 异常)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>修饰符</td>
<td>一般省略</td>
<td><code>*</code>：任意<br><code>public</code>：公有</td>
</tr>
<tr>
<td>返回值</td>
<td>不可省略</td>
<td><code>*</code>：任意<br/><code>void String ...</code></td>
</tr>
<tr>
<td>包</td>
<td>不可省略</td>
<td><code>*</code>：任意<br/><code>..</code>：当前包及其子包</td>
</tr>
<tr>
<td>类</td>
<td>不可省略</td>
<td><code>*</code>：任意<br/><code>XXX *XXX XXX*</code></td>
</tr>
<tr>
<td>方法</td>
<td>不可省略</td>
<td><code>*</code>：任意<br/><code>XXX *XXX XXX*</code></td>
</tr>
<tr>
<td>参数</td>
<td>不可省略</td>
<td><code>..</code>：任意类型参数，有无参数皆可<br><code>*</code>：任意类型参数，且必须有参数<br/><code>int</code>：基本类型直接写名称<br><code>java.lang.String</code>：引用类型写全限定名</td>
</tr>
<tr>
<td>异常</td>
<td>一般省略</td>
<td></td>
</tr>
</tbody></table>
<h2 id="7-4-AOP-实现"><a href="#7-4-AOP-实现" class="headerlink" title="7.4 AOP 实现"></a>7.4 AOP 实现</h2><h3 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1 代理模式"></a>1 代理模式</h3><ol>
<li>静态代理</li>
<li>动态代理</li>
</ol>
<h3 id="2-Spring-AOP"><a href="#2-Spring-AOP" class="headerlink" title="2 Spring-AOP"></a>2 Spring-AOP</h3><h4 id="1-编程式-ProxyFactory"><a href="#1-编程式-ProxyFactory" class="headerlink" title="1 编程式 ProxyFactory"></a>1 编程式 <code>ProxyFactory</code></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ProxyFactory factory = new ProxyFactory();</span><br><span class="line">factory.setTarget();</span><br><span class="line">factory.setInterfaces();</span><br><span class="line">factory.addAdvice();</span><br><span class="line">factory.getProxy();</span><br></pre></td></tr></table></figure>

<h4 id="2-配置式-ProxyFactoryBean"><a href="#2-配置式-ProxyFactoryBean" class="headerlink" title="2 配置式 ProxyFactoryBean"></a>2 配置式 <code>ProxyFactoryBean</code></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;interfaces&quot; value=&quot;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;target&quot; ref=&quot;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;interceptorNames&quot; value=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-Spring-AOP-AspectJ"><a href="#3-Spring-AOP-AspectJ" class="headerlink" title="3 Spring-AOP + AspectJ"></a>3 Spring-AOP + AspectJ</h3><h4 id="1-AOP-联盟的通知类型"><a href="#1-AOP-联盟的通知类型" class="headerlink" title="1 AOP 联盟的通知类型"></a>1 AOP 联盟的通知类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;aop:config proxy-target-class=&quot;&quot;&gt;</span><br><span class="line">	// 配置切入点，可以被此 AOP 配置下的所有配置引用</span><br><span class="line">	&lt;aop:pointcut id=&quot;&quot; expression=&quot;&quot;/&gt;</span><br><span class="line">	// 特殊的切面，只有一个通知 和 一个切入点</span><br><span class="line">	&lt;aop:advisor advice-ref=&quot;&quot; pointcut-ref=&quot;&quot; order=&quot;切面优先级&quot;/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>proxy-target-class</code><ul>
<li><code>false</code>：默认，使用 JDK 代理</li>
<li><code>true</code>：使用 cglib 代理</li>
</ul>
</li>
</ul>
<h4 id="2-AspectJ-的通知类型"><a href="#2-AspectJ-的通知类型" class="headerlink" title="2 AspectJ 的通知类型"></a>2 AspectJ 的通知类型</h4><h5 id="1-XML-配置"><a href="#1-XML-配置" class="headerlink" title="1 XML 配置"></a>1 XML 配置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;aop:config proxy-target-class=&quot;&quot;&gt;</span><br><span class="line">    &lt;aop:aspect ref=&quot;引入通知&quot; order=&quot;切面优先级&quot;&gt;</span><br><span class="line">    	// 配置切入点，只能被当前 aspect 引用</span><br><span class="line">        &lt;aop:pointcut id=&quot;&quot; expression=&quot;&quot;/&gt;</span><br><span class="line">        &lt;aop:before method=&quot;&quot; pointcut-ref=&quot;&quot;/&gt;</span><br><span class="line">        &lt;aop:after-returning method=&quot;&quot; pointcut-ref=&quot;&quot; returning=&quot;&quot;/&gt;</span><br><span class="line">        &lt;aop:around method=&quot;&quot; pointcut-ref=&quot;&quot;/&gt;</span><br><span class="line">        &lt;aop:after method=&quot;&quot; pointcut-ref=&quot;&quot;/&gt;</span><br><span class="line">        &lt;aop:after-throwing method=&quot;&quot; pointcut-ref=&quot;&quot; throwing=&quot;&quot;/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2-注解"><a href="#2-注解" class="headerlink" title="2 注解"></a>2 注解</h5><h6 id="1-开启-AOP-注解"><a href="#1-开启-AOP-注解" class="headerlink" title="1 开启 AOP 注解"></a>1 开启 AOP 注解</h6><ol>
<li><p>xml 配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;aop:aspectj-autoproxy proxy-target-class=&quot;默认false&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 作用在配置类上（带有 @Configuraction 的类）</span><br><span class="line">@EnableAspectJAutoProxy</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h6 id="2-通知类上"><a href="#2-通知类上" class="headerlink" title="2 通知类上"></a>2 通知类上</h6><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Aspect</code></td>
<td>声明切面，等价于 <code>&lt;aop:aspect&gt;</code></td>
</tr>
<tr>
<td><code>@Order</code></td>
<td>切面的优先级</td>
</tr>
</tbody></table>
<h6 id="3-通知方法上"><a href="#3-通知方法上" class="headerlink" title="3 通知方法上"></a>3 通知方法上</h6><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>@PointCut</code></td>
<td><code>execution()</code>：声明切入点，ID 为方法名<br><code>方法名()</code>：引入切入点</td>
</tr>
<tr>
<td><code>@Before</code></td>
<td>前置通知</td>
</tr>
<tr>
<td><code>@AfterReturning</code></td>
<td>后置通知</td>
</tr>
<tr>
<td><code>@Around</code></td>
<td>环绕通知</td>
</tr>
<tr>
<td><code>@After</code></td>
<td>最终通知</td>
</tr>
<tr>
<td><code>@AfterThrowing</code></td>
<td>异常通知</td>
</tr>
</tbody></table>
<h1 id="八-JdbcTemplate"><a href="#八-JdbcTemplate" class="headerlink" title="八 JdbcTemplate"></a>八 JdbcTemplate</h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><ol>
<li>Spring 提供用于操作JDBC工具类，类似：DBUtils</li>
<li>依赖 <code>DataSource</code> （数据源）</li>
</ol>
<h2 id="8-2-API"><a href="#8-2-API" class="headerlink" title="8.2 API"></a>8.2 API</h2><h3 id="1-构造"><a href="#1-构造" class="headerlink" title="1 构造"></a>1 构造</h3><ol>
<li><code>JdbcTemplate()</code></li>
<li><code>JdbcTemplate(DataSource dataSource)</code></li>
<li><code>JdbcTemplate(DataSource dataSource, boolean lazyInit)</code></li>
</ol>
<h3 id="2-增删改"><a href="#2-增删改" class="headerlink" title="2 增删改"></a>2 增删改</h3><ol>
<li><code>int update(String sql, Object... args)</code></li>
<li><code>int batchUpdate(String sql, List&lt;Object[]&gt; batchArgs)</code></li>
</ol>
<h3 id="3-查"><a href="#3-查" class="headerlink" title="3 查"></a>3 查</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper, Object... args)</code></td>
<td>将查询结果封装为对象并存储到 List 集合中</td>
</tr>
<tr>
<td><code>T queryForObject(String sql, Class&lt;T&gt; requiredType, Object... args)</code></td>
<td>查询单个值</td>
</tr>
<tr>
<td><code>T queryForObject(String sql, RowMapper&lt;T&gt; rowMapper, Object... args)</code></td>
<td>查询单行数据，返回一个对象</td>
</tr>
<tr>
<td><code>Map&lt;String, Object&gt; queryForMap(String sql, Object... args)</code></td>
<td>查询的结果集封装为 map 集合，此方法查询结果集长度只能是 1</td>
</tr>
<tr>
<td><code>List&lt;Map&lt;String, Object&gt;&gt; queryForList(String sql, Object... args)</code></td>
<td>将每一条记录封装为 map 集合，然后将 map 集合存到到 list 集合中</td>
</tr>
</tbody></table>
<h3 id="4-RowMapper"><a href="#4-RowMapper" class="headerlink" title="4 RowMapper"></a>4 RowMapper</h3><h4 id="1-概述-5"><a href="#1-概述-5" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>类似于 DBUtils 的 <code>ResultSetHandler</code></li>
<li>可以自己实现，也可使用 spring 提供的</li>
</ol>
<h4 id="2-方法"><a href="#2-方法" class="headerlink" title="2 方法"></a>2 方法</h4><ul>
<li><code>T mapRow(ResultSet rs, int rowNum)</code></li>
</ul>
<h4 id="3-Srpng-的实现"><a href="#3-Srpng-的实现" class="headerlink" title="3 Srpng 的实现"></a>3 Srpng 的实现</h4><table>
<thead>
<tr>
<th>实现</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>BeanPropertyRowMapper</code></td>
<td>将结果集封装为对象</td>
</tr>
</tbody></table>
<h2 id="8-3-使用"><a href="#8-3-使用" class="headerlink" title="8.3 使用"></a>8.3 使用</h2><h3 id="1-手动方式"><a href="#1-手动方式" class="headerlink" title="1 手动方式"></a>1 手动方式</h3><ol>
<li>创建数据源</li>
<li>创建 <code>JdbcTemplate</code>，并设置数据源（构造或者 <code>set</code> 方法）</li>
<li>使用 <code>JdbcTemplate</code> 操作 </li>
</ol>
<h3 id="2-Spring-IOC-之-JdbcTemplate"><a href="#2-Spring-IOC-之-JdbcTemplate" class="headerlink" title="2 Spring IOC 之 JdbcTemplate"></a>2 Spring IOC 之 JdbcTemplate</h3><ol>
<li>配置数据源 Bean</li>
<li>配置 <code>JdbcTemplate</code> Bean ，并注入数据源</li>
<li>将 <code>JdbcTemplate</code> 注入到 DAO 中进行操作</li>
</ol>
<h3 id="3-Spring-IOC-之-JdbcDaoSupport"><a href="#3-Spring-IOC-之-JdbcDaoSupport" class="headerlink" title="3 Spring IOC 之 JdbcDaoSupport"></a>3 Spring IOC 之 JdbcDaoSupport</h3><h4 id="1-API-1"><a href="#1-API-1" class="headerlink" title="1 API"></a>1 API</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>private JdbcTemplate jdbcTemplate</code></td>
<td>内部有一个 <code>JdbcTemplate</code> 属性</td>
</tr>
<tr>
<td><code>void setDataSource(DataSource dataSource)</code></td>
<td>如果内部 <code>JdbcTemplate</code> 为空或非此数据源创建的，则使用此数据源创建一个新的 <code>JdbcTemplate</code></td>
</tr>
<tr>
<td><code>JdbcTemplate createJdbcTemplate(DataSource dataSource)</code></td>
<td>使用数据源创建一个新的 <code>JdbcTemplate</code></td>
</tr>
<tr>
<td><code>DataSource getDataSource()</code></td>
<td>获取 <code>JdbcTemplate</code> 的数据源</td>
</tr>
<tr>
<td><code>void setJdbcTemplate(JdbcTemplate jdbcTemplate)</code></td>
<td>设置 <code>JdbcTemplate</code></td>
</tr>
<tr>
<td><code>JdbcTemplate getJdbcTemplate()</code></td>
<td>获取 <code>JdbcTemplate</code></td>
</tr>
</tbody></table>
<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h4><ol>
<li><code>JdbcDaoSupport</code> 中只需注入数据源，会自动根据数据源创建 <code>JdbcTemplate</code></li>
<li>DAO 继承  <code>JdbcDaoSupport</code></li>
<li>配置数据源 Bean</li>
<li>将数据源注入到 DAO 中，在 DAO 中获取 <code>JdbcTemplate</code> 进行操作</li>
</ol>
<h1 id="九-事务管理"><a href="#九-事务管理" class="headerlink" title="九 事务管理"></a>九 事务管理</h1><h2 id="9-1-结构"><a href="#9-1-结构" class="headerlink" title="9.1 结构"></a>9.1 结构</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Frame/Spring/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84.png" alt=""></p>
<h3 id="1-PlatformTransactionManager"><a href="#1-PlatformTransactionManager" class="headerlink" title="1 PlatformTransactionManager"></a>1 PlatformTransactionManager</h3><h4 id="1-概述-6"><a href="#1-概述-6" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>平台事务管理器在  <code>spring-tx.jar</code> 中</li>
<li>因为不同平台，操作事务的代码各不相同，spring 提供了此接口</li>
<li>spring 要管理事务，必须使用事务管理器</li>
</ol>
<h4 id="2-API-2"><a href="#2-API-2" class="headerlink" title="2 API"></a>2 API</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>TransactionStatus getTransaction(TransactionDefinition definition)</code></td>
<td>获取事务状态 <code>TransactionStatus</code></td>
</tr>
<tr>
<td><code>void commit(TransactionStatus status)</code></td>
<td>根据状态提交</td>
</tr>
<tr>
<td><code>void rollback(TransactionStatus status)</code></td>
<td>根据状态回滚</td>
</tr>
</tbody></table>
<h4 id="3-实现"><a href="#3-实现" class="headerlink" title="3 实现"></a>3 实现</h4><table>
<thead>
<tr>
<th>实现</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>DataSourceTransactionManager</code></td>
<td>jdbc 事务管理器，采用 <code>JdbcTemplate</code>，在 <code>spring-jdbc.jar</code> 中</td>
</tr>
<tr>
<td><code>HibernateTransactionManager</code></td>
<td>Hibernate 事务管理器，在 <code>spring-orm.jar</code> 中</td>
</tr>
</tbody></table>
<h3 id="2-TransactionDefinition"><a href="#2-TransactionDefinition" class="headerlink" title="2 TransactionDefinition"></a>2 TransactionDefinition</h3><h4 id="1-概述-7"><a href="#1-概述-7" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>事务详情（或叫事务定义、事务属性），如隔离级别，传播行为，是否只读，超时时间…</li>
<li>进行事务配置时，必须配置事务详情，Spring 将配置封装到此对象实例</li>
</ol>
<h4 id="2-API-3"><a href="#2-API-3" class="headerlink" title="2 API"></a>2 API</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int getIsolationLevel()</code></td>
<td>获取隔离级别</td>
</tr>
<tr>
<td><code>int getPropagationBehavior()</code></td>
<td>获取传播行为</td>
</tr>
<tr>
<td><code>String getName()</code></td>
<td>获取事务名称</td>
</tr>
<tr>
<td><code>boolean isReadOnly()</code></td>
<td>事务是否只读，默认 false</td>
</tr>
<tr>
<td><code>int getTimeout()</code></td>
<td>获取超时时间</td>
</tr>
</tbody></table>
<h4 id="3-传播行为"><a href="#3-传播行为" class="headerlink" title="3 传播行为"></a>3 传播行为</h4><h5 id="1-概述-8"><a href="#1-概述-8" class="headerlink" title="1 概述"></a>1 概述</h5><ol>
<li>如果有多个事务嵌套运行，子事务是否与大事务共用一个事务</li>
<li>一个方法运行在了一个开启了事务的方法中时，当前方法是使用原来的事务还是开启一个新的事务</li>
</ol>
<h5 id="2-分类"><a href="#2-分类" class="headerlink" title="2 分类"></a>2 分类</h5><table>
<thead>
<tr>
<th>名称</th>
<th>int 值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>PROPAGATION_REQUIRED</code></strong>（默认）</td>
<td><code>0</code></td>
<td>如果调用者 A 有事务，则被调用者 B 使用该事务，反之 B 创建一个新事务</td>
</tr>
<tr>
<td><code>PROPAGATION_SUPPORTS</code></td>
<td><code>1</code></td>
<td>如果 A 有事务，则 B 使用此事务，反之 B 不使用事务</td>
</tr>
<tr>
<td><code>PROPAGATION_MANDATORY</code></td>
<td><code>2</code></td>
<td>如果 A 有事务，则 B 使用此事务，反之 B 抛异常</td>
</tr>
<tr>
<td><strong><code>PROPAGATION_REQUIRES_NEW</code></strong></td>
<td><code>3</code></td>
<td>无论 A 是否有事务，B 都创建一个新事务</td>
</tr>
<tr>
<td><code>PROPAGATION_NOT_SUPPORTED</code></td>
<td><code>4</code></td>
<td>无论 A 是否有事务，B 都不使用事务</td>
</tr>
<tr>
<td><code>PROPAGATION_NEVER</code></td>
<td><code>5</code></td>
<td>如果 A 有事务，则 B 抛异常，反之 B 不使用事务</td>
</tr>
<tr>
<td><strong><code>PROPAGATION_NESTED</code></strong></td>
<td><code>6</code></td>
<td>A 和 B 底层采用保存点机制，形成嵌套事务</td>
</tr>
</tbody></table>
<h4 id="4-隔离级别"><a href="#4-隔离级别" class="headerlink" title="4 隔离级别"></a>4 隔离级别</h4><table>
<thead>
<tr>
<th>名称</th>
<th>int 值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ISOLATION_DEFAULT</code>（默认）</td>
<td><code>-1</code></td>
<td>使用数据库的默认隔离级别</td>
</tr>
<tr>
<td><code>ISOLATION_READ_UNCOMMITTED</code></td>
<td><code>1</code></td>
<td>读未提交</td>
</tr>
<tr>
<td><code>ISOLATION_READ_COMMITTED</code></td>
<td><code>2</code></td>
<td>读已提交</td>
</tr>
<tr>
<td><code>ISOLATION_REPEATABLE_READ</code></td>
<td><code>4</code></td>
<td>可重复度</td>
</tr>
<tr>
<td><code>ISOLATION_SERIALIZABLE</code></td>
<td><code>8</code></td>
<td>串行化</td>
</tr>
</tbody></table>
<h3 id="3-TransactionStatus"><a href="#3-TransactionStatus" class="headerlink" title="3 TransactionStatus"></a>3 TransactionStatus</h3><h4 id="1-概述-9"><a href="#1-概述-9" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>事务状态</li>
<li>spring 用于记录当前事务运行状态，如是否有保存点，是否完成…</li>
</ol>
<h4 id="2-API-4"><a href="#2-API-4" class="headerlink" title="2 API"></a>2 API</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean isNewTransaction()</code></td>
<td>是否是新事务</td>
</tr>
<tr>
<td><code>boolean hasSavepoint()</code></td>
<td>事务是否有保存点</td>
</tr>
<tr>
<td><code>void setRollbackOnly()</code></td>
<td>设置事务 <code>rollback-only</code></td>
</tr>
<tr>
<td><code>boolean isRollbackOnly()</code></td>
<td>事务是否设置了 <code>rollback-only</code></td>
</tr>
<tr>
<td><code>boolean isCompleted()</code></td>
<td>事务是否完成</td>
</tr>
<tr>
<td><code>void flush()</code></td>
<td>刷新事务</td>
</tr>
</tbody></table>
<h2 id="9-2-事务管理"><a href="#9-2-事务管理" class="headerlink" title="9.2 事务管理"></a>9.2 事务管理</h2><h3 id="1-概述-10"><a href="#1-概述-10" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>Spring 使用 <code>TransactionTemplate</code> 模板管理事务</li>
<li>模板需要注入事务管理器，事务管理器需要事务，事务从连接 <code>Connection</code> 中获取，而无论直接创建连接还是从连接池中获取连接都需要数据源</li>
<li>先给事务管理器注入数据源，之后再将事务管理器注入到模板中</li>
</ol>
<h3 id="2-管理事务方式"><a href="#2-管理事务方式" class="headerlink" title="2 管理事务方式"></a>2 管理事务方式</h3><h4 id="1-手动管理事务（了解）"><a href="#1-手动管理事务（了解）" class="headerlink" title="1 手动管理事务（了解）"></a>1 手动管理事务（了解）</h4><ol>
<li>配置 <code>TransactionTemplate</code> ，并注入 Service 中</li>
<li>在 Service 中使用事务模板操作 <code>transactionTemplate.execute();</code></li>
</ol>
<h4 id="2-TransactionProxyFactoryBean（半自动管理事务）"><a href="#2-TransactionProxyFactoryBean（半自动管理事务）" class="headerlink" title="2 TransactionProxyFactoryBean（半自动管理事务）"></a>2 TransactionProxyFactoryBean（半自动管理事务）</h4><h5 id="1-概述-11"><a href="#1-概述-11" class="headerlink" title="1 概述"></a>1 概述</h5><ol>
<li>spring 提供的管理事务的 <code>FactoryBean</code></li>
<li>使用此 <code>FactoryBean</code> 生成代理，为代理对象注入事务管理器及事务详情</li>
<li>使用代理对象执行业务方法</li>
</ol>
<h5 id="2-配置"><a href="#2-配置" class="headerlink" title="2 配置"></a>2 配置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;代理对象ID&quot; class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;proxyInterfaces&quot; value=&quot;目标接口&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;target&quot; ref=&quot;目标对象&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;transactionManager&quot; ref=&quot;事务管理器&quot;/&gt;</span><br><span class="line">	// 事务详情</span><br><span class="line">	&lt;property name=&quot;transactionAttributes&quot;&gt;</span><br><span class="line">		&lt;props&gt;</span><br><span class="line">			&lt;prop key=&quot;方法名&quot;&gt;格式：PROPAGATION,ISOLATION,readOnly,-Exception,+Exception&lt;/prop&gt;</span><br><span class="line">		&lt;/props&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-AOP-（自动管理事务）"><a href="#3-AOP-（自动管理事务）" class="headerlink" title="3 AOP （自动管理事务）"></a>3 <code>AOP</code> （自动管理事务）</h4><h5 id="1-XML"><a href="#1-XML" class="headerlink" title="1 XML"></a>1 XML</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--1 配置事务管理器--&gt;</span><br><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!--2 配置事务详情--&gt;</span><br><span class="line">&lt;tx:advice id=&quot;&quot; transaction-manager=&quot;&quot;&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">        &lt;tx:method name=&quot;&quot; propagation=&quot;&quot; isolation=&quot;&quot; readOnly=&quot;&quot;/&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br><span class="line">&lt;!--3 AOP 配置--&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut id=&quot;&quot; expression=&quot;&quot;/&gt;</span><br><span class="line">    &lt;aop:advisor advice-ref=&quot;&quot; pointcut-ref=&quot;&quot;/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2-注解-1"><a href="#2-注解-1" class="headerlink" title="2 注解"></a>2 注解</h5><h6 id="1-配置"><a href="#1-配置" class="headerlink" title="1 配置"></a>1 配置</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--1 配置事务管理器 --&gt;</span><br><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;dataSource&quot; ref=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!--2 开启事务注解--&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h6 id="2-Transactional"><a href="#2-Transactional" class="headerlink" title="2 @Transactional"></a>2 <code>@Transactional</code></h6><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String transactionManager() default &quot;&quot;</code></td>
<td>事务管理器</td>
</tr>
<tr>
<td><code>String value() default &quot;&quot;</code></td>
<td>同 <code>transactionManager()</code></td>
</tr>
<tr>
<td><code>Propagation propagation() default Propagation.REQUIRED</code></td>
<td>事务传播行为</td>
</tr>
<tr>
<td><code>Isolation isolation() default Isolation.DEFAULT</code></td>
<td>事务隔离级别</td>
</tr>
<tr>
<td><code>boolean readOnly() default false</code></td>
<td>事务是否只读</td>
</tr>
<tr>
<td><code>int timeout() default TransactionDefinition.TIMEOUT_DEFAULT</code></td>
<td>事务超时时间，超过事务自动终止并回滚</td>
</tr>
<tr>
<td><code>rollbackFor/rollbackForClassName</code></td>
<td>遇到指定类型的异常回滚，Spring 默认运行时异常回滚，编译时异常不会滚</td>
</tr>
<tr>
<td><code>noRollbackFor/noRollbackForClassName</code></td>
<td>遇到指定类型的异常不回滚</td>
</tr>
</tbody></table>
<ol>
<li>作用在类上：所有方法都开启事务</li>
<li>作用在方法上：当前方法开启事务</li>
</ol>
<h2 id="10-1-Spring-Junit"><a href="#10-1-Spring-Junit" class="headerlink" title="10.1 Spring + Junit"></a>10.1 Spring + Junit</h2><h3 id="1-包"><a href="#1-包" class="headerlink" title="1 包"></a>1 包</h3><ol>
<li>Junit 的包</li>
<li>Spring 的包<ol>
<li><code>spring-core</code></li>
<li><code>spring-beans</code></li>
<li><code>spring-context</code></li>
<li><code>spring-expression</code></li>
<li><code>spring-jcl</code></li>
<li><code>spring-test</code></li>
</ol>
</li>
</ol>
<h3 id="2-使用-1"><a href="#2-使用-1" class="headerlink" title="2 使用"></a>2 使用</h3><h4 id="1-RunWith"><a href="#1-RunWith" class="headerlink" title="1 @RunWith"></a>1 <code>@RunWith</code></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringJunit4ClassRunner.class)</span><br></pre></td></tr></table></figure>

<ol>
<li>Junit 的注解，作用在类上</li>
<li>替换原有运行器</li>
</ol>
<h4 id="2-ContextConfiguration"><a href="#2-ContextConfiguration" class="headerlink" title="2 @ContextConfiguration"></a>2 <code>@ContextConfiguration</code></h4><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String[] locations() default {}</code></td>
<td>指定 spring 配置文件的位置</td>
</tr>
<tr>
<td><code>String[] value() default {}</code></td>
<td>同 <code>locations()</code></td>
</tr>
<tr>
<td><code>Class&lt;?&gt;[] classes() default {}</code></td>
<td>指定注解配置类</td>
</tr>
</tbody></table>
<h4 id="3-通过-Autowired-注入即可"><a href="#3-通过-Autowired-注入即可" class="headerlink" title="3 通过 @Autowired 注入即可"></a>3 通过 <code>@Autowired</code> 注入即可</h4><h2 id="10-2-Spring-Web"><a href="#10-2-Spring-Web" class="headerlink" title="10.2 Spring + Web"></a>10.2 Spring + Web</h2><h3 id="1-概述-12"><a href="#1-概述-12" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>普通 Java 项目：需要手动读取 Spring 配置，创建 Spring 容器</li>
<li>Web 项目：服务器启动就创建 Spring 容器</li>
<li>Web 技术中启动服务器救加载配置文件的方式<ol>
<li><code>Servlet</code></li>
<li><code>Filter</code></li>
<li><code>Listener</code></li>
</ol>
</li>
</ol>
<h3 id="2-Web-技术：服务器启动就加载配置文件"><a href="#2-Web-技术：服务器启动就加载配置文件" class="headerlink" title="2 Web 技术：服务器启动就加载配置文件"></a>2 Web 技术：服务器启动就加载配置文件</h3><h4 id="1-Servlet"><a href="#1-Servlet" class="headerlink" title="1 Servlet"></a>1 <code>Servlet</code></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init(ServletConfig config)</span><br><span class="line">// 配置一启动就初始化 Servlet</span><br><span class="line">&lt;Servlet&gt;</span><br><span class="line">	&lt;load-on-startup&gt;</span><br><span class="line">&lt;/Servlet&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-Filter"><a href="#2-Filter" class="headerlink" title="2 Filter"></a>2 <code>Filter</code></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init(FilterConfig config)</span><br><span class="line">// 注册过滤器自动调用初始化</span><br><span class="line">&lt;Filter&gt;&lt;/Filter&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-Listener"><a href="#3-Listener" class="headerlink" title="3 Listener"></a>3 <code>Listener</code></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注册监听器 ServletContextListener</span><br></pre></td></tr></table></figure>

<h3 id="3-Spring-Web"><a href="#3-Spring-Web" class="headerlink" title="3 Spring + Web"></a>3 Spring + Web</h3><h4 id="1-概述-13"><a href="#1-概述-13" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li><code>WebApplicationContext</code>：Spring Web 容器</li>
<li>Spring 初始化  <code>WebApplicationContext</code> ：<ol>
<li><code>ContextLoaderServlet</code></li>
<li><code>ContextLoaderListener</code></li>
</ol>
</li>
</ol>
<h4 id="2-web-xml-配置-Spring-监听器"><a href="#2-web-xml-配置-Spring-监听器" class="headerlink" title="2 web.xml 配置 Spring 监听器"></a>2 <code>web.xml</code> 配置 Spring 监听器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">	&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">	&lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>此监听器默认加载的是 <code>WEB-INF/applicationContext.xml</code></li>
<li>而配置文件通常是 <code>WEB-INF/classes/applicationContext.cml</code></li>
</ol>
<h3 id="4-手动获取-Spring-容器"><a href="#4-手动获取-Spring-容器" class="headerlink" title="4 手动获取 Spring 容器"></a>4 手动获取 Spring 容器</h3><ol>
<li><p>一个应用中只有一个 Spring 容器，存放在 <code>ServletContext</code> 域中，key 为 <code>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code></p>
</li>
<li><p>从域中手动获取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.getServletContext().getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE)</span><br></pre></td></tr></table></figure>
</li>
<li><p>工具类 <code>WebApplicationContextUtils</code>，封装了手动获取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WebApplicationContextUtils.getWebApplicationContext(this.getServletContext())</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ContextLoader</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ContextLoader.getCurrentWebApplicationContext()</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>Frame</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatis</title>
    <url>/anyeansan.github.io/2020/11/08/%E6%A1%86%E6%9E%B6/MyBatis/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>MyBatis 是一个持久层框架，是一个不完全的 orm 框架</li>
<li>MyBatis 让程序员只关注 SQL 本身，而不需要去关注 其它 JDBC 代码以及设置参数和获取结果集的工作</li>
<li>MyBatis 支持自定义 SQL、存储过程以及高级映射</li>
<li>JDBC 的问题<ol>
<li>在创建连接时，存在硬编码，解决：配置文件（全局配置文件）</li>
<li>在执行 <code>statement</code> 时存在硬编码，解决：配置文件（映射文件）</li>
<li>频繁开关数据库连接，解决：数据库连接池（全局配置文件）</li>
</ol>
</li>
</ol>
<h1 id="二-API"><a href="#二-API" class="headerlink" title="二 API"></a>二 API</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><table>
<thead>
<tr>
<th>类/接口</th>
<th>说明</th>
<th>推荐作用域</th>
</tr>
</thead>
<tbody><tr>
<td><code>SqlSessionFactoryBuilder</code></td>
<td>用于创建 <code>SqlSessionFactory</code></td>
<td>方法作用域</td>
</tr>
<tr>
<td><code>SqlSessionFactory</code></td>
<td>一个应用只存在一个，单例</td>
<td>应用作用域</td>
</tr>
<tr>
<td><code>SqlSession</code></td>
<td>每个线程都应该有它自己的 SqlSession 实例，提供了在数据库执行 SQL 命令所需的所有方法</td>
<td>请求作用域</td>
</tr>
<tr>
<td>映射器实例 <code>XxxMapper</code></td>
<td>绑定映射语句的接口，从 <code>SqlSession</code> 中获取</td>
<td>方法作用域</td>
</tr>
</tbody></table>
<h2 id="2-2-SqlSessionFactoryBuilder"><a href="#2-2-SqlSessionFactoryBuilder" class="headerlink" title="2.2 SqlSessionFactoryBuilder"></a>2.2 <code>SqlSessionFactoryBuilder</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SqlSessionFactory build(InputStream inputStream)</span><br><span class="line">SqlSessionFactory build(InputStream inputStream, String environment)</span><br><span class="line">SqlSessionFactory build(InputStream inputStream, Properties properties)</span><br><span class="line">SqlSessionFactory build(InputStream inputStream, String env, Properties props)</span><br><span class="line">SqlSessionFactory build(Configuration config)</span><br></pre></td></tr></table></figure>

<h2 id="2-3-SqlSessionFactory"><a href="#2-3-SqlSessionFactory" class="headerlink" title="2.3 SqlSessionFactory"></a>2.3 <code>SqlSessionFactory</code></h2><ol>
<li><code>SqlSession openSession()</code><ol>
<li>事务作用域将会开启（也就是不自动提交）</li>
<li>由当前环境配置的 <code>DataSource</code> 实例中获取 <code>Connection</code> 对象</li>
<li>事务隔离级别将会使用驱动或数据源的默认设置</li>
<li>预处理语句不会被复用，也不会批量处理更新</li>
</ol>
</li>
<li><code>SqlSession openSession(boolean autoCommit)</code><ul>
<li><code>true</code> ：开启自动提交</li>
</ul>
</li>
<li><code>SqlSession openSession(Connection connection)</code><ul>
<li>使用指定的 <code>Connection</code> 实例</li>
</ul>
</li>
</ol>
<h2 id="2-4-SqlSession"><a href="#2-4-SqlSession" class="headerlink" title="2.4 SqlSession"></a>2.4 <code>SqlSession</code></h2><h3 id="1-增删改查"><a href="#1-增删改查" class="headerlink" title="1 增删改查"></a>1 增删改查</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int insert(String statement, Object parameter)</code></td>
<td>增，<code>statement</code>：为 <code>namespace.id</code></td>
</tr>
<tr>
<td><code>int delete(String statement, Object parameter)</code></td>
<td>删</td>
</tr>
<tr>
<td><code>int update(String statement, Object parameter)</code></td>
<td>改</td>
</tr>
<tr>
<td><code>T selectOne(String statement, Object parameter)</code></td>
<td>返回一个对象或 <code>null</code></td>
</tr>
<tr>
<td><code>List&lt;E&gt; selectList(String statement, Object parameter)</code></td>
<td>返回 n 个对象的 List 集合</td>
</tr>
<tr>
<td><code>Map&lt;K, V&gt; selectMap(String statement, Object parameter, String mapKey)</code></td>
<td>对象某个属性作为 key，对象作为 value</td>
</tr>
</tbody></table>
<h3 id="2-其它"><a href="#2-其它" class="headerlink" title="2 其它"></a>2 其它</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>T getMapper(Class&lt;T&gt; type)</code></td>
<td>获取映射器 Mapper</td>
</tr>
<tr>
<td><code>Connection getConnection()</code></td>
<td>获取连接</td>
</tr>
<tr>
<td><code>void commit()</code></td>
<td>提交</td>
</tr>
<tr>
<td><code>void rollback()</code></td>
<td>回滚</td>
</tr>
<tr>
<td><code>void close()</code></td>
<td>关闭</td>
</tr>
</tbody></table>
<h3 id="3-关闭模板"><a href="#3-关闭模板" class="headerlink" title="3 关闭模板"></a>3 关闭模板</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  // 你的应用逻辑代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-Mybatis-应用方式"><a href="#4-Mybatis-应用方式" class="headerlink" title="4 Mybatis 应用方式"></a>4 Mybatis 应用方式</h3><h4 id="1-直接使用-SqlSession-的-API"><a href="#1-直接使用-SqlSession-的-API" class="headerlink" title="1  直接使用 SqlSession 的 API"></a>1  直接使用 <code>SqlSession</code> 的 API</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  Blog blog = (Blog) session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-使用-Mapper-接口"><a href="#2-使用-Mapper-接口" class="headerlink" title="2 使用 Mapper 接口"></a>2 使用 Mapper 接口</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">  Blog blog = mapper.selectBlog(101);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三-Mapper-接口规范"><a href="#三-Mapper-接口规范" class="headerlink" title="三 Mapper 接口规范"></a>三 Mapper 接口规范</h1><ol>
<li>Mapper 接口的全限定名要和 Mapper 映射文件的 <code>namespace</code> 值一致</li>
<li>Mapper 接口的方法名要和 Mapper 映射文件的 <code>statement</code> 的 <code>id</code> 一致</li>
<li>Mapper 接口的方法参数类型要和 Mapper 映射文件的 <code>statement</code> 的 <code>parameterType</code> 一致，且它的参数是一个</li>
<li>Mapper 接口的方法返回值类型要和 Mapper 映射文件的 <code>statement</code> 的 <code>resultType</code> 一致</li>
</ol>
<h1 id="四-全局配置文件"><a href="#四-全局配置文件" class="headerlink" title="四 全局配置文件"></a>四 全局配置文件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">	* properties （属性）</span><br><span class="line">	* settings （设置）</span><br><span class="line">	* typeAliases （类型别名）</span><br><span class="line">	* typeHandlers （类型处理器）</span><br><span class="line">	* objectFactory （对象工厂）</span><br><span class="line">	* plugins （插件）</span><br><span class="line">	* environments （环境）</span><br><span class="line">		* environment （环境变量）</span><br><span class="line">		* transactionManager （事务管理器）</span><br><span class="line">		* dataSource （数据源）</span><br><span class="line">	* databaseIdProvider （数据库厂商标识）</span><br><span class="line">	* mappers （映射器）</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<h2 id="4-1-properties"><a href="#4-1-properties" class="headerlink" title="4.1 properties"></a>4.1 properties</h2><h3 id="1-引入外部资源文件"><a href="#1-引入外部资源文件" class="headerlink" title="1 引入外部资源文件"></a>1 引入外部资源文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;properties resource=&quot;类路径资源文件&quot; url=&quot;网络或磁盘资源文件&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-在配置文件内部定义属性"><a href="#2-在配置文件内部定义属性" class="headerlink" title="2 在配置文件内部定义属性"></a>2 在配置文件内部定义属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">  &lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&gt;</span><br><span class="line">  &lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-动态配置属性"><a href="#3-动态配置属性" class="headerlink" title="3 动态配置属性"></a>3 动态配置属性</h3><h4 id="1-方式"><a href="#1-方式" class="headerlink" title="1 方式"></a>1 方式</h4><ol>
<li>内部定义属性</li>
<li>外部资源文件中定义属性</li>
<li><code>SqlSessionFactoryBuilder</code> 构造 <code>SqlSessionFactory</code> 时 <code>build()</code> 方法中传递属性</li>
</ol>
<h4 id="2-说明"><a href="#2-说明" class="headerlink" title="2 说明"></a>2 说明</h4><ol>
<li>动态属性可以在配置文件中使用 <code>${属性名}</code></li>
<li>优先级：后加载覆盖前边的，所以 <code>3 &gt; 2 &gt; 1</code></li>
</ol>
<h2 id="4-2-settings"><a href="#4-2-settings" class="headerlink" title="4.2 settings"></a>4.2 settings</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">	&lt;setting name=&quot;&quot; value=&quot;&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>cacheEnabled</code></td>
<td>是否开启缓存，默认 <code>true</code></td>
</tr>
<tr>
<td><code>lazyLoadingEnabled</code></td>
<td>是否开启懒加载，默认 <code>false</code></td>
</tr>
<tr>
<td><code>aggressiveLazyLoading</code></td>
<td><code>true</code>：任一方法的调用都会加载该对象的所有延迟加载属性，默认 <code>false</code>：按需加载延迟属性</td>
</tr>
<tr>
<td><code>autoMappingBehavior</code></td>
<td>自动映射，默认 <code>partial</code>：只会自动映射没有定义嵌套结果映射的字段</td>
</tr>
<tr>
<td><code>mapUnderscoreToCamelCase</code></td>
<td>是否开启驼峰命名自动映射，即属性 <code>userName</code> 对应列 <code>USER_NAME</code>，默认 <code>false</code></td>
</tr>
<tr>
<td><code>logImpl</code></td>
<td>指定 MyBatis 所用日志的具体实现，未指定时将自动查找</td>
</tr>
</tbody></table>
<h2 id="4-3-typeAliases"><a href="#4-3-typeAliases" class="headerlink" title="4.3 typeAliases"></a>4.3 typeAliases</h2><h3 id="1-单个定义"><a href="#1-单个定义" class="headerlink" title="1 单个定义"></a>1 单个定义</h3><h4 id="1-XML"><a href="#1-XML" class="headerlink" title="1 XML"></a>1 XML</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">	&lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&gt;</span><br><span class="line">	&lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-注解"><a href="#2-注解" class="headerlink" title="2 注解"></a>2 注解</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Alias(&quot;别名&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="2-批量定义"><a href="#2-批量定义" class="headerlink" title="2 批量定义"></a>2 批量定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">	&lt;package name=&quot;domain.blog&quot;/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>为包及其子包下的类配置别名</li>
<li>默认别名为首字母小写的非限定类名</li>
</ol>
<h3 id="3-内置别名"><a href="#3-内置别名" class="headerlink" title="3 内置别名"></a>3 内置别名</h3><table>
<thead>
<tr>
<th>类型</th>
<th>别名</th>
</tr>
</thead>
<tbody><tr>
<td>基本类型</td>
<td><code>_基本类型</code>，如 <code>int</code>：<code>_int</code></td>
</tr>
<tr>
<td>基本类型包装类</td>
<td>对应基本类型，如 <code>Integer</code>：<code>int</code></td>
</tr>
<tr>
<td>引用类型</td>
<td>对应类型首字母小写，如 <code>string list map...</code></td>
</tr>
</tbody></table>
<h2 id="4-4-plugins"><a href="#4-4-plugins" class="headerlink" title="4.4 plugins"></a>4.4 plugins</h2><ol>
<li><code>mybatis-pluse</code></li>
<li><code>mybatis-generator-core</code></li>
<li>…</li>
</ol>
<h2 id="4-5-environments"><a href="#4-5-environments" class="headerlink" title="4.5 environments"></a>4.5 environments</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">	&lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">		&lt;transactionManager type=&quot;JDBC&quot;&gt;</span><br><span class="line">			&lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt;</span><br><span class="line">		&lt;/transactionManager&gt;</span><br><span class="line">		&lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">			&lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;</span><br><span class="line">			&lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;</span><br><span class="line">			&lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;</span><br><span class="line">			&lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;</span><br><span class="line">		&lt;/dataSource&gt;</span><br><span class="line">	&lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;</span><br></pre></td></tr></table></figure>

<h3 id="1-environments"><a href="#1-environments" class="headerlink" title="1 environments"></a>1 environments</h3><ol>
<li>可以配置多个环境，但 <strong>每个 SqlSessionFactory 实例只能选择一种环境</strong>，即 <strong>每个数据库对应一个 SqlSessionFactory 实例</strong></li>
<li><code>default</code><ul>
<li>通过 <code>&lt;enviroment&gt;</code> 的 <code>id</code> 指定使用哪个环境</li>
</ul>
</li>
</ol>
<h3 id="2-transactionManager"><a href="#2-transactionManager" class="headerlink" title="2 transactionManager"></a>2 transactionManager</h3><ol>
<li>事务管理器，<code>type</code> 有两种类型<ol>
<li><code>JDBC</code></li>
<li><code>MANAGED</code></li>
</ol>
</li>
<li><code>Spring + MyBatis</code> 没有必要配置事务管理器，因为 Spring 模块会使用自带的管理器来覆盖前面的配置</li>
</ol>
<h3 id="3-dataSource"><a href="#3-dataSource" class="headerlink" title="3 dataSource"></a>3 dataSource</h3><ol>
<li>数据源，<code>type</code> 有三种类型<ol>
<li><code>UNPOOLED</code><ul>
<li><code>UnpooledDataSourceFactory</code></li>
<li>采用传统的获取连接的方式，虽然也实现了 <code>javax.sql.DataSource</code> 接口，但并没有使用池的思想</li>
</ul>
</li>
<li><code>POOLED</code><ul>
<li><code>PooledDataSourceFactory</code></li>
<li>采用传统的 <code>javax.sql.DataSource</code> 规范中的连接池，mybatis 中有规范的实现</li>
</ul>
</li>
<li><code>JNDI</code><ul>
<li><code>PooledDataSourceFactory</code></li>
<li>采用服务器提供的JNDI技术实现，来获取 <code>DataSource</code> ，不同的服务器所能拿到的 <code>DataSource</code> 是不同的</li>
</ul>
</li>
</ol>
</li>
<li>数据源交给 Spring 配置</li>
</ol>
<h2 id="4-6-databaseIdProvider"><a href="#4-6-databaseIdProvider" class="headerlink" title="4.6 databaseIdProvider"></a>4.6 databaseIdProvider</h2><h3 id="1-配置"><a href="#1-配置" class="headerlink" title="1 配置"></a>1 配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;MySQL&quot; value=&quot;别名&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;Oracle&quot; value=&quot;别名&quot;/&gt;</span><br><span class="line">&lt;/databaseIdProvider&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-作用"><a href="#2-作用" class="headerlink" title="2 作用"></a>2 作用</h3><ol>
<li>获取数据库厂商标识（驱动 <code>getDatabaseProductName()</code>），mybatis 就能根据数据库厂商标识执行不同 sql</li>
<li>在映射配置文件中的增删改查配置 <code>databaseId</code>：数据库标识别名，表示该 crud 操作是针对哪个数据库的</li>
</ol>
<h2 id="4-7-mappers"><a href="#4-7-mappers" class="headerlink" title="4.7 mappers"></a>4.7 mappers</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1 作用"></a>1 作用</h3><ul>
<li>注册映射器，即告诉 MyBatis 到哪里去找映射文件</li>
</ul>
<h3 id="2-方式"><a href="#2-方式" class="headerlink" title="2 方式"></a>2 方式</h3><h4 id="1-使用相对于类路径的资源引用"><a href="#1-使用相对于类路径的资源引用" class="headerlink" title="1 使用相对于类路径的资源引用"></a>1 使用相对于类路径的资源引用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">	&lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-使用完全限定资源定位符（磁盘或网络-URL）"><a href="#2-使用完全限定资源定位符（磁盘或网络-URL）" class="headerlink" title="2 使用完全限定资源定位符（磁盘或网络 URL）"></a>2 使用完全限定资源定位符（磁盘或网络 URL）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">	&lt;mapper url=&quot;file:///&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-使用映射器接口的全限定名"><a href="#3-使用映射器接口的全限定名" class="headerlink" title="3 使用映射器接口的全限定名"></a>3 使用映射器接口的全限定名</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">	&lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>要求 Mapper 接口和 Mapper 映射文件名称相同且在同一个目录下</li>
</ul>
<h4 id="4-包名"><a href="#4-包名" class="headerlink" title="4 包名"></a>4 包名</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">	&lt;package name=&quot;org.mybatis.builder&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>将包内的映射器接口实现全部注册为映射器</li>
<li>要求 Mapper 接口和 Mapper 映射文件名称相同且在同一个目录下</li>
</ol>
<h1 id="五-映射配置文件"><a href="#五-映射配置文件" class="headerlink" title="五 映射配置文件"></a>五 映射配置文件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;Mapper接口全限定名&quot;&gt;</span><br><span class="line">	* cache – 该命名空间的缓存配置</span><br><span class="line">	* cache-ref – 引用其它命名空间的缓存配置</span><br><span class="line">	* resultMap – 描述如何从数据库结果集中加载对象</span><br><span class="line">	* sql – 可被其它语句引用的可重用语句块</span><br><span class="line">	* insert – 映射插入语句</span><br><span class="line">	* update – 映射更新语句</span><br><span class="line">	* delete – 映射删除语句</span><br><span class="line">	* select – 映射查询语句</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<h2 id="5-1-select"><a href="#5-1-select" class="headerlink" title="5.1 select"></a>5.1 select</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;&quot; parameterType=&quot;&quot; resultType=&quot;&quot; resultMap=&quot;&quot;&gt;</span><br><span class="line">  SELECT * FROM PERSON WHERE ID = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>id</code></td>
<td>在命名空间中唯一的标识符，可以被用来引用这条语句</td>
</tr>
<tr>
<td><code>parameterType</code></td>
<td>参数的类全限定名或别名</td>
</tr>
<tr>
<td><code>resultType</code></td>
<td>返回结果的类全限定名或别名，如果返回集合，应设置为集合包含的类型</td>
</tr>
<tr>
<td><code>resultMap</code></td>
<td>对外部 <code>resultMap</code> 的命名引用，<code>resultType</code> 和 <code>resultMap</code> 只能选其一</td>
</tr>
<tr>
<td><code>useCache</code></td>
<td><code>true</code>：本条语句的结果会被二级缓存缓存起来，默认 ：对 select 元素为 <code>true</code></td>
</tr>
<tr>
<td><code>flushCache</code></td>
<td><code>true</code>：只要语句被调用，都会导致本地缓存和二级缓存被清空，默认 <code>false</code></td>
</tr>
</tbody></table>
<h2 id="5-2-insert-update-delete"><a href="#5-2-insert-update-delete" class="headerlink" title="5.2 insert update delete"></a>5.2 insert update delete</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>id</code></td>
<td>在命名空间中唯一的标识符，可以被用来引用这条语句</td>
</tr>
<tr>
<td><code>parameterType</code></td>
<td>参数的类全限定名或别名</td>
</tr>
<tr>
<td><code>useGeneratedKeys</code></td>
<td>（仅适用于 insert 和 update）MyBatis 使用 JDBC 的 <code>getGeneratedKeys()</code> 方法来取出由数据库内部生成的主键，默认 <code>false</code></td>
</tr>
<tr>
<td><code>keyProperty</code></td>
<td>（仅适用于 insert 和 update）指定用对象的哪个属性保存主键，Mybatis 使用 <code>getGeneratedKeys()</code> 的返回值或 <code>insert</code> 语句的 <code>selectKey</code> 子元素设置它的值</td>
</tr>
<tr>
<td><code>flushCache</code></td>
<td><code>true</code>：只要语句被调用，都会导致本地缓存和二级缓存被清空，默认 <code>true</code></td>
</tr>
</tbody></table>
<h3 id="1-selectKey"><a href="#1-selectKey" class="headerlink" title="1 selectKey"></a>1 selectKey</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;insert id=&quot;&quot; parameterType=&quot;&quot;&gt;</span><br><span class="line">	&lt;selectKey keyProperty=&quot;&quot; resultType=&quot;&quot; order=&quot;AFTER&quot;&gt;</span><br><span class="line">	&lt;/selectKey&gt;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>keyProperty</code></td>
<td><code>selectKey</code> 语句结果应该被设置到的目标属性</td>
</tr>
<tr>
<td><code>keyColumn</code></td>
<td>返回结果集中生成列属性的列名</td>
</tr>
<tr>
<td><code>resultType</code></td>
<td>结果的类型</td>
</tr>
<tr>
<td><code>order</code></td>
<td><code>BEFORE</code>：先生成主键，设置 <code>keyProperty</code>，再执行插入语句<br/><code>AFTER</code>：先执行插入语句，然后是 <code>selectKey</code> 中的语句</td>
</tr>
</tbody></table>
<h3 id="2-insert-update-获取主键"><a href="#2-insert-update-获取主键" class="headerlink" title="2 insert update 获取主键"></a>2 <code>insert update</code> 获取主键</h3><h4 id="1-支持自动生成主键（Mysql-Sql-Server）"><a href="#1-支持自动生成主键（Mysql-Sql-Server）" class="headerlink" title="1 支持自动生成主键（Mysql, Sql Server）"></a>1 支持自动生成主键（Mysql, Sql Server）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1 将生成的主键赋值给 keyProperty 指定的属性</span><br><span class="line">&lt;insert id=&quot;&quot; parameterType=&quot;&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;&quot;&gt;</span><br><span class="line">&lt;/insert&gt;</span><br><span class="line">// 2</span><br><span class="line">&lt;insert id=&quot;&quot; parameterType=&quot;&quot;&gt;</span><br><span class="line">	&lt;selectKey keyProperty=&quot;&quot; resultType=&quot;&quot; order=&quot;AFTER&quot;&gt;</span><br><span class="line">		SELECT LAST_INSERT_ID() </span><br><span class="line">	&lt;/selectKey&gt;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-不支持自动生成主键（oracle）"><a href="#2-不支持自动生成主键（oracle）" class="headerlink" title="2 不支持自动生成主键（oracle）"></a>2 不支持自动生成主键（oracle）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;insert id=&quot;&quot; parameterType=&quot;&quot;&gt;</span><br><span class="line">	&lt;selectKey keyProperty=&quot;&quot; resultType=&quot;&quot; order=&quot;before&quot;&gt;</span><br><span class="line">	&lt;/selectKey&gt;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-sql"><a href="#5-3-sql" class="headerlink" title="5.3 sql"></a>5.3 sql</h2><h3 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1 作用"></a>1 作用</h3><ol>
<li>用来定义可重用的 SQL 代码片段，以便在其它语句中使用</li>
<li>定义时可以确定参数，引用时插入值</li>
</ol>
<h3 id="2-定义"><a href="#2-定义" class="headerlink" title="2 定义"></a>2 定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;sql id=&quot;&quot;&gt;</span><br><span class="line">	$&#123;alias&#125;.id,$&#123;alias&#125;.username</span><br><span class="line">&lt;/sql&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-引用"><a href="#3-引用" class="headerlink" title="3 引用"></a>3 引用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;include refid=&quot;&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;alias&quot; value=&quot;t1&quot;/&gt;</span><br><span class="line">&lt;/include&gt;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-动态-SQL"><a href="#5-4-动态-SQL" class="headerlink" title="5.4 动态 SQL"></a>5.4 动态 SQL</h2><h3 id="1-if"><a href="#1-if" class="headerlink" title="1 if"></a>1 if</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt;</span><br><span class="line">	SELECT * FROM BLOG </span><br><span class="line">	WHERE </span><br><span class="line">	&lt;if test=&quot;state != null&quot;&gt;</span><br><span class="line">		state = #&#123;state&#125;</span><br><span class="line">	&lt;/if&gt; </span><br><span class="line">	&lt;if test=&quot;title != null&quot;&gt;</span><br><span class="line">		AND title like #&#123;title&#125;</span><br><span class="line">	&lt;/if&gt;</span><br><span class="line">	&lt;if test=&quot;author != null and author.name != null&quot;&gt;</span><br><span class="line">		AND author_name like #&#123;author.name&#125;</span><br><span class="line">	&lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-where"><a href="#2-where" class="headerlink" title="2 where"></a>2 where</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;findActiveBlogLike&quot;</span><br><span class="line">     resultType=&quot;Blog&quot;&gt;</span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  &lt;where&gt;</span><br><span class="line">    &lt;if test=&quot;state != null&quot;&gt;</span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;title != null&quot;&gt;</span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;author != null and author.name != null&quot;&gt;</span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">  &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>if 标签的问题：<ol>
<li>如果条件全都匹配不上，则最终语句 <code>SELECT * FROM BLOG WHERE</code></li>
<li>如果仅第二个匹配上，则最终语句 <code>SELECT * FROM BLOG WHERE AND title like ‘someTitle’</code></li>
</ol>
</li>
</ul>
<h3 id="3-trim"><a href="#3-trim" class="headerlink" title="3 trim"></a>3 trim</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;&quot; suffix=&quot;&quot; suffixOverrides=&quot;and | or&quot;&gt;</span><br><span class="line">&lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/trim&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>prefix</code></td>
<td>添加一个前缀</td>
</tr>
<tr>
<td><code>prefixOverrides</code></td>
<td>去掉一个前缀</td>
</tr>
<tr>
<td><code>suffix</code></td>
<td>添加一个后缀</td>
</tr>
<tr>
<td><code>suffixOverrides</code></td>
<td>去掉一个后缀</td>
</tr>
</tbody></table>
<ul>
<li><code>trim</code> ：可以实现 <code>where</code> 和 <code>set</code> 的功能</li>
</ul>
<h3 id="4-set"><a href="#4-set" class="headerlink" title="4 set"></a>4 set</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt;</span><br><span class="line">  update Author</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">      &lt;if test=&quot;username != null&quot;&gt;username=#&#123;username&#125;,&lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;password != null&quot;&gt;password=#&#123;password&#125;,&lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;email != null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;bio != null&quot;&gt;bio=#&#123;bio&#125;&lt;/if&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>set</code> 会动态地在行首插入 SET 关键字，并会删掉额外的逗号</li>
</ul>
<h3 id="5-choose（when-otherwise）"><a href="#5-choose（when-otherwise）" class="headerlink" title="5 choose（when/otherwise）"></a>5 choose（when/otherwise）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;findActiveBlogLike&quot;</span><br><span class="line">     resultType=&quot;Blog&quot;&gt;</span><br><span class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line">  &lt;choose&gt;</span><br><span class="line">    &lt;when test=&quot;title != null&quot;&gt;</span><br><span class="line">      AND title like #&#123;title&#125;</span><br><span class="line">    &lt;/when&gt;</span><br><span class="line">    &lt;when test=&quot;author != null and author.name != null&quot;&gt;</span><br><span class="line">      AND author_name like #&#123;author.name&#125;</span><br><span class="line">    &lt;/when&gt;</span><br><span class="line">    &lt;otherwise&gt;</span><br><span class="line">      AND featured = 1</span><br><span class="line">    &lt;/otherwise&gt;</span><br><span class="line">  &lt;/choose&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h3 id="6-foreach"><a href="#6-foreach" class="headerlink" title="6 foreach"></a>6 foreach</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt;</span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  WHERE ID in</span><br><span class="line">  &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot;</span><br><span class="line">      open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  &lt;/foreach&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>collection</code></td>
<td>对象：属性名，数组：<code>array</code>，集合：<code>collection/list</code></td>
</tr>
<tr>
<td><code>item</code></td>
<td>遍历变量名</td>
</tr>
<tr>
<td><code>index</code></td>
<td>元素索引或键</td>
</tr>
<tr>
<td><code>open</code></td>
<td>遍历开始时拼接的字符串</td>
</tr>
<tr>
<td><code>close</code></td>
<td>遍历结束时拼接的字符串</td>
</tr>
<tr>
<td><code>separator</code></td>
<td>拼接的连接符</td>
</tr>
</tbody></table>
<h2 id="5-5-输入映射（参数）"><a href="#5-5-输入映射（参数）" class="headerlink" title="5.5 输入映射（参数）"></a>5.5 输入映射（参数）</h2><h3 id="1-参数获取方式"><a href="#1-参数获取方式" class="headerlink" title="1 参数获取方式"></a>1 参数获取方式</h3><table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
<th>使用场景</th>
<th>基本类型（包装类）和 String</th>
</tr>
</thead>
<tbody><tr>
<td><code>#{}</code></td>
<td>表示一个占位符，<code>PreparedStatement</code>：预编译</td>
<td>能用就用</td>
<td><code>#{任意名称}</code></td>
</tr>
<tr>
<td><code>${}</code></td>
<td>表示 SQL 连接，<code>Statement</code>：将接收到参数的内容直接拼接到 sql 语句上，存在 sql 注入</td>
<td>原生 JDBC 不支持占位符的地方</td>
<td><code>${value}</code> 或 <code>${_参数名}</code></td>
</tr>
</tbody></table>
<h4 id=""><a href="#" class="headerlink" title="#{}"></a><code>#{}</code></h4><ol start="3">
<li><p>扩展：规定参数的一些规则</p>
<ul>
<li><code>javaType，jdbcType，mode(存储过程)，numericScale</code></li>
<li><code>resultMap，typeHandler，jdbcTypeName...</code></li>
</ul>
</li>
<li><p><code>jdbcType</code></p>
<ol>
<li><p>当数据为 <code>null</code> 时，Mybatis 默认映射的是原生 jdbc 的 <code>OTHER</code> 类型</p>
</li>
<li><p>有些数据库（如Oracle）可能不识别 Mybatis 对 <code>null</code> 的默认处理，错误信息：<code>JdbcType OTHER: 无效的类型</code></p>
</li>
<li><p>解决</p>
<ol>
<li>取值时可以指定 jdbcType：<code>#{xxx, jdbcType=NULL}</code></li>
<li>在全局配置中的<code>setting</code>的<code>jdbcTypeForNull</code>设置为<code>NULL</code></li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="2-参数传递"><a href="#2-参数传递" class="headerlink" title="2 参数传递"></a>2 参数传递</h3><h4 id="1-单个参数"><a href="#1-单个参数" class="headerlink" title="1 单个参数"></a>1 单个参数</h4><h5 id="1"><a href="#1" class="headerlink" title="1"></a>1</h5><table>
<thead>
<tr>
<th>类型</th>
<th>获取</th>
</tr>
</thead>
<tbody><tr>
<td><code>基本类型，基本类型包装类，String</code></td>
<td><code>#{任意名}</code></td>
</tr>
<tr>
<td><code>JavaBean</code></td>
<td><code>#{JavaBean.属性名}</code></td>
</tr>
<tr>
<td><code>Map</code></td>
<td><code>#{key}</code></td>
</tr>
</tbody></table>
<h5 id="2-Collection-Array"><a href="#2-Collection-Array" class="headerlink" title="2 Collection / Array"></a>2 Collection / Array</h5><ol>
<li>Mybatis 对 <code>Collection List Array</code> 类型的参数做了特殊处理，封装到了 Map 中，不用配置 <code>parameterType</code>，使用 <code>&lt;foreach&gt;</code> 标签获取</li>
<li>Key<ol>
<li><code>Collection（List/Set）</code>：<code>collection</code></li>
<li><code>List</code>：<code>list</code></li>
<li><code>Array</code>：<code>array</code></li>
</ol>
</li>
</ol>
<h4 id="2-多个参数"><a href="#2-多个参数" class="headerlink" title="2 多个参数"></a>2 多个参数</h4><table>
<thead>
<tr>
<th>方式</th>
<th>key</th>
</tr>
</thead>
<tbody><tr>
<td><code>默认</code></td>
<td>1 <code>0,1...n</code><br>2 <code>param1,param2...paramn</code></td>
</tr>
<tr>
<td><code>@param</code></td>
<td>1 <code>自定义</code><br/>2 <code>param1,param2...paramn</code></td>
</tr>
</tbody></table>
<ol>
<li><p>Mybatis 将多个参数封装到了 Map 中，获取： <code>#{key}</code></p>
</li>
<li><p><code>@param</code> ：使用此注解在 Mapper 接口方法的形参上自定义 <code>key</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insertUser(@param(&quot;id&quot;)int id, @param(&quot;name&quot;)String name)&#123;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="5-6-输出映射（结果）"><a href="#5-6-输出映射（结果）" class="headerlink" title="5.6 输出映射（结果）"></a>5.6 输出映射（结果）</h2><h3 id="1-resultType"><a href="#1-resultType" class="headerlink" title="1 resultType"></a>1 resultType</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li><code>resultType</code> 结果映射时查询出的列名与映射属性名一致，才能赋值成功</li>
<li>如果查询的列有别名，则按照别名匹配</li>
</ol>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><table>
<thead>
<tr>
<th>类型</th>
<th><code>resultType</code> 值</th>
</tr>
</thead>
<tbody><tr>
<td>基本类型</td>
<td>对应基本类型</td>
</tr>
<tr>
<td><code>JavaBean</code></td>
<td>对应 <code>JavaBean</code> 类型</td>
</tr>
<tr>
<td><code>Collection, Array</code></td>
<td>集合或数组中的元素类型</td>
</tr>
</tbody></table>
<h4 id="3-Map"><a href="#3-Map" class="headerlink" title="3 Map"></a>3 Map</h4><h5 id="1-单行结果映射"><a href="#1-单行结果映射" class="headerlink" title="1 单行结果映射"></a>1 单行结果映射</h5><ol>
<li><code>resultType</code>：<code>map/java.util.Map</code></li>
<li><code>Map&lt;String, Object&gt;</code><ol>
<li>key：列名</li>
<li>value：列值</li>
</ol>
</li>
</ol>
<h5 id="2-多行结果映射"><a href="#2-多行结果映射" class="headerlink" title="2 多行结果映射"></a>2 多行结果映射</h5><ol>
<li><code>resultType</code>：Map 中 <code>value</code> 的类型</li>
<li><code>Map&lt;自定义, Object&gt;</code><ol>
<li>key：<code>@MapKey</code> 在方法上定义哪个属性作为 key</li>
<li>value：一行数据封装的对象</li>
</ol>
</li>
</ol>
<h3 id="2-resultMap"><a href="#2-resultMap" class="headerlink" title="2 resultMap"></a>2 resultMap</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id=&quot;&quot; type=&quot;结果集封装的类型&quot;&gt;</span><br><span class="line">	&lt;id property=&quot;javabean中的属性名&quot; column=&quot;结果集的列名&quot; /&gt;</span><br><span class="line">	&lt;result property=&quot;&quot; column=&quot;&quot;/&gt;</span><br><span class="line">	&lt;association&gt;</span><br><span class="line">	&lt;collection&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>子标签</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;id&gt;</code></td>
<td>完成主键列的映射</td>
</tr>
<tr>
<td><code>&lt;result&gt;</code></td>
<td>1 完成普通列的映射<br/>2 通过对象导航图也能完成高级映射</td>
</tr>
<tr>
<td><code>&lt;association&gt;</code></td>
<td>完成 <code>多对一（一对一）</code>的映射</td>
</tr>
<tr>
<td><code>&lt;collection&gt;</code></td>
<td>完成 <code>一对多（多对多）</code>的映射</td>
</tr>
</tbody></table>
<h4 id="1-lt-association-gt"><a href="#1-lt-association-gt" class="headerlink" title="1 &lt;association&gt;"></a>1 <code>&lt;association&gt;</code></h4><h5 id="1-直接查询"><a href="#1-直接查询" class="headerlink" title="1 直接查询"></a>1 直接查询</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;association property=&quot;&quot; javaType=&quot;&quot; fetchType=&quot;&quot;&gt;</span><br><span class="line">	&lt;!-- id标签：建议在关联查询时必须写上，不写不会报错，但是会影响性能 --&gt;</span><br><span class="line">	&lt;id column=&quot;&quot; property=&quot;&quot; /&gt;</span><br><span class="line">	&lt;result column=&quot;&quot; property=&quot;&quot; /&gt;</span><br><span class="line">&lt;/association&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>fetchType</code>：<ol>
<li>值<ul>
<li><code>lazy</code>：本次查询使用懒加载</li>
<li><code>eager</code>：本次查询不使用懒加载</li>
</ul>
</li>
<li>设置此属性则忽略全局配置 <code>lazyLoadingEnabled</code></li>
</ol>
</li>
</ul>
<h5 id="2-分步查询"><a href="#2-分步查询" class="headerlink" title="2 分步查询"></a>2 分步查询</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;association property=&quot;关联属性&quot; column=&quot;关联属性中的关联列&quot; select=&quot;引入一个&lt;select&gt;&quot;&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>column</code> 作为分步查询 <code>select</code> 的参数，是本次查询查出的值</li>
<li><code>select</code> 的结果会赋值给 <code>property</code></li>
<li>我发现直接查询，即使字段可以自动映射也必须配置，分步查询能自动映射则不用配置</li>
<li>为何用分步查询？<ol>
<li>通常每个实体都有对应的 CURD，所以既然有了就拿来用</li>
<li>懒加载</li>
</ol>
</li>
</ol>
<h4 id="4-lt-collection-gt"><a href="#4-lt-collection-gt" class="headerlink" title="4 &lt;collection&gt;"></a>4 <code>&lt;collection&gt;</code></h4><h5 id="1-直接查询-1"><a href="#1-直接查询-1" class="headerlink" title="1 直接查询"></a>1 直接查询</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;collection property=&quot;&quot; ofType=&quot;属性中封装的类型（集合泛型）&quot;&gt;</span><br><span class="line">	&lt;id column=&quot;&quot; property=&quot;&quot; /&gt;</span><br><span class="line">	&lt;result column=&quot;&quot; property=&quot;&quot; /&gt;</span><br><span class="line">&lt;/collection&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2-分步查询-1"><a href="#2-分步查询-1" class="headerlink" title="2 分步查询"></a>2 分步查询</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;collection property=&quot;关联属性&quot; column=&quot;关联属性中的关联列&quot; select=&quot;&quot;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="5-7-模糊查询"><a href="#5-7-模糊查询" class="headerlink" title="5.7 模糊查询"></a>5.7 模糊查询</h2><h3 id="1-传参时手动拼接"><a href="#1-传参时手动拼接" class="headerlink" title="1 传参时手动拼接"></a>1 传参时手动拼接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mapper.getUser(&quot;%安%&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="2-映射配置文件中配置"><a href="#2-映射配置文件中配置" class="headerlink" title="2 映射配置文件中配置"></a>2 映射配置文件中配置</h3><h4 id="1-不推荐，存在-sql-注入"><a href="#1-不推荐，存在-sql-注入" class="headerlink" title="1 不推荐，存在 sql 注入"></a>1 不推荐，存在 sql 注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">like &apos;%#&#123;name&#125;%&apos; // 错误，#&#123;&#125; 在字符串中不能识别</span><br><span class="line">like &apos;%&apos;#&#123;name&#125;&apos;%&apos;</span><br><span class="line">like &apos;%$&#123;name&#125;%&apos;</span><br></pre></td></tr></table></figure>

<h4 id="2-推荐"><a href="#2-推荐" class="headerlink" title="2 推荐"></a>2 推荐</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">like concat(&apos;%&apos;, #&#123;name&#125;, &apos;%&apos;)</span><br><span class="line">like concat(&apos;%&apos;, &apos;$&#123;name&#125;&apos;, &apos;%&apos;)</span><br></pre></td></tr></table></figure>

<h1 id="六-注解"><a href="#六-注解" class="headerlink" title="六 注解"></a>六 注解</h1><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Param</code></td>
<td>用在 Mapper 接口方法的参数上，自定义参数名</td>
</tr>
<tr>
<td><code>@Insert</code></td>
<td>用在 Mapper 接口方法上，等价于 <code>&lt;insert&gt;</code></td>
</tr>
<tr>
<td><code>@Update</code></td>
<td>用在 Mapper 接口方法上，等价于 <code>&lt;update&gt;</code></td>
</tr>
<tr>
<td><code>@Delete</code></td>
<td>用在 Mapper 接口方法上，等价于 <code>&lt;delete&gt;</code></td>
</tr>
<tr>
<td><code>@Select</code></td>
<td>用在 Mapper 接口方法上，等价于 <code>&lt;select&gt;</code></td>
</tr>
<tr>
<td><code>@ResultMap</code></td>
<td>引用 XML 中定义的 <code>&lt;resultMap&gt;</code></td>
</tr>
</tbody></table>
<h1 id="七-日志"><a href="#七-日志" class="headerlink" title="七 日志"></a>七 日志</h1><h2 id="7-1-配置日志（全局配置中）"><a href="#7-1-配置日志（全局配置中）" class="headerlink" title="7.1 配置日志（全局配置中）"></a>7.1 配置日志（全局配置中）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">  &lt;setting name=&quot;logImpl&quot; value=&quot;&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-值"><a href="#7-2-值" class="headerlink" title="7.2 值"></a>7.2 值</h2><ol>
<li><code>STDOUT_LOGGING</code>：标准日志，配置即可使用</li>
<li><code>SLF4J</code></li>
<li><code>LOG4J, LOG4J2</code></li>
<li><code>JDK_LOGGING</code></li>
<li><code>COMMONS_LOGGING</code></li>
<li><code>NO_LOGGING</code></li>
</ol>
<h1 id="八-分页"><a href="#八-分页" class="headerlink" title="八 分页"></a>八 分页</h1><h2 id="8-1-SQL-语句-limit-实现"><a href="#8-1-SQL-语句-limit-实现" class="headerlink" title="8.1 SQL 语句 limit 实现"></a>8.1 SQL 语句 limit 实现</h2><ol>
<li>物理分页：直接从数据库中获取所需数据</li>
<li>物理分页每次都要访问数据库</li>
<li>物理分页每次获取的数据都是最新的</li>
<li>物理分页占用内存小</li>
</ol>
<h2 id="8-2-RowBounds"><a href="#8-2-RowBounds" class="headerlink" title="8.2 RowBounds"></a>8.2 RowBounds</h2><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>RowBounds()</code></td>
<td>默认 <code>offset=0</code>，<code>limit=Integer.MAX_VALUE</code></td>
</tr>
<tr>
<td><code>RowBounds(int offset, int limit)</code></td>
<td><code>offset</code>：起始行，<code>limit</code>：获取行数</td>
</tr>
</tbody></table>
<ol>
<li>逻辑分页：从数据库中拿出所有符合要求的数据，然后再从这些数据中获取所需的分页数据</li>
<li>逻辑分页只需访问一次数据库</li>
<li>逻辑分页的数据有可能滞后</li>
<li>逻辑分页占用内存多</li>
</ol>
<h2 id="8-3-分页插件"><a href="#8-3-分页插件" class="headerlink" title="8.3 分页插件"></a>8.3 分页插件</h2><h1 id="九-缓存"><a href="#九-缓存" class="headerlink" title="九 缓存"></a>九 缓存</h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><ol>
<li>缓存即存于内存中的临时数据，为了减少和数据库的交互次数，提高效率</li>
<li>适合缓存的数据<ul>
<li>经常使用且不经常改变的</li>
<li>数据正确与否对最终结果影响不大的</li>
</ul>
</li>
<li>Mybatis 使用到了两种缓存<ol>
<li>本地缓存（local cache），或者叫一级缓存</li>
<li>二级缓存（second level cache）</li>
</ol>
</li>
</ol>
<h2 id="9-2-本地缓存"><a href="#9-2-本地缓存" class="headerlink" title="9.2 本地缓存"></a>9.2 本地缓存</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>本地缓存指定是 <code>SqlSession</code> 对象的缓存，是一个 Map 结构</li>
<li>每当一个新的 <code>SqlSession</code> 创建，MyBatis 就会创建一个与之相关联的本地缓存</li>
<li>任何查询结果都会被保存在本地缓存中<ol>
<li><code>key</code>：由 <code>sql语句、条件、statement</code> 等信息组成一个唯一值</li>
<li><code>value</code>：查询结果</li>
</ol>
</li>
</ol>
<h3 id="2-清除缓存"><a href="#2-清除缓存" class="headerlink" title="2 清除缓存"></a>2 清除缓存</h3><ol>
<li>增删改：<code>insert update delete</code></li>
<li>事务提交或回滚：<code>commit rollback</code></li>
<li><code>SqlSession</code> 关闭：<code>close</code></li>
<li><code>SqlSession</code>  手动清理：<code>void clearCache()</code></li>
</ol>
<h2 id="9-3-二级缓存"><a href="#9-3-二级缓存" class="headerlink" title="9.3 二级缓存"></a>9.3 二级缓存</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>二级缓存指的是 <code>SqlSessionFactory</code>对象的缓存，默认关闭</li>
<li>同一个 <code>SqlSessionFactory</code> 创建的 <code>SqlSession</code> 共享缓存数据</li>
<li>二级缓存是事务性的，即每个 <code>SqlSession</code> 提交或关闭时才会将数据写入二级缓存</li>
<li>二级缓存的对象必须实现 <code>Serializable</code> 接口</li>
<li>二级缓存获取的对象可能不能，但数据一样</li>
</ol>
<h3 id="2-开启"><a href="#2-开启" class="headerlink" title="2 开启"></a>2 开启</h3><ol>
<li><p><code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code></p>
<ul>
<li>全局配置文件，缓存总开关，默认 <code>true</code></li>
</ul>
</li>
<li><p><code>&lt;cache type=&quot;org.apache.ibatis.cache.impl.PerpetualCache&quot;/&gt;</code></p>
<ol>
<li><p>映射配置文件，二级缓存开关，</p>
</li>
<li><p><code>type</code></p>
<ol>
<li>默认 <code>PerpetualCache</code>，可省略</li>
<li>可使用自定义缓存或第三方缓存</li>
</ol>
</li>
<li><p>缓存效果</p>
<ol>
<li>映射语句文件中的所有 <code>select</code> 语句的结果将会被缓存</li>
<li>映射语句文件中的所有 <code>insert、update、delete</code> 语句会刷新缓存</li>
<li>缓存不会定时进行刷新</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>Frame</category>
      </categories>
  </entry>
  <entry>
    <title>过滤器和监听器</title>
    <url>/anyeansan.github.io/2020/11/08/JavaWeb/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/</url>
    <content><![CDATA[<h1 id="一-过滤器-Filter"><a href="#一-过滤器-Filter" class="headerlink" title="一 过滤器 Filter"></a>一 过滤器 Filter</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ol>
<li>过滤器可以过滤客户端和 WEB 资源之间的请求和响应信息</li>
<li>一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤…</li>
<li>过滤器都需要直接或间接实现 <code>javax.servlet.Filter</code> 接口</li>
<li>创建过滤器可以继承 <code>javax.servlet.http.HttpFilter</code></li>
</ol>
<h2 id="1-2-API"><a href="#1-2-API" class="headerlink" title="1.2 API"></a>1.2 API</h2><h3 id="1-javax-servlet-Filter"><a href="#1-javax-servlet-Filter" class="headerlink" title="1 javax.servlet.Filter"></a>1 <code>javax.servlet.Filter</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>init(FilterConfig config)</code></td>
<td>初始化</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>doFilter(ServletRequest req, ServletResponse res, FilterChain chain)</code></td>
<td>过滤方法</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>destroy()</code></td>
<td>销毁</td>
</tr>
</tbody></table>
<h3 id="2-javax-servlet-http-HttpFilter"><a href="#2-javax-servlet-http-HttpFilter" class="headerlink" title="2 javax.servlet.http.HttpFilter"></a>2 <code>javax.servlet.http.HttpFilter</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>doFilter(ServletRequest req, ServletResponse res, FilterChain chain)</code></td>
<td>重写方法，会调用特有方法</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>doFilter(HttpServletRequest req, HttpServletResponse res, FilterChain chain)</code></td>
<td>特有的过滤方法</td>
</tr>
<tr>
<td><code>FilterConfig</code></td>
<td><code>getFilterConfig()</code></td>
<td>获取 <code>FilterConfig</code></td>
</tr>
</tbody></table>
<h3 id="3-javax-servlet-FilterChain"><a href="#3-javax-servlet-FilterChain" class="headerlink" title="3 javax.servlet.FilterChain"></a>3 <code>javax.servlet.FilterChain</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>doFilter(ServletRequest req, ServletResponse res)</code></td>
<td>放行</td>
</tr>
</tbody></table>
<h3 id="4-javax-servlet-FilterConfig"><a href="#4-javax-servlet-FilterConfig" class="headerlink" title="4 javax.servlet.FilterConfig"></a>4 <code>javax.servlet.FilterConfig</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>getFilterName()</code></td>
<td>获取过滤器名称</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getInitParameter(String name)</code></td>
<td>根据键获取初始化参数的值</td>
</tr>
<tr>
<td><code>Enumeration&lt;String&gt;</code></td>
<td><code>getInitParameterNames()</code></td>
<td>获取所有初始化参数键的枚举</td>
</tr>
<tr>
<td><code>ServletContext</code></td>
<td><code>getServletContext()</code></td>
<td>获取 <code>ServletContext</code></td>
</tr>
</tbody></table>
<h2 id="1-3-Filter-配置"><a href="#1-3-Filter-配置" class="headerlink" title="1.3 Filter 配置"></a>1.3 Filter 配置</h2><h3 id="1-xml-方式：web-xml"><a href="#1-xml-方式：web-xml" class="headerlink" title="1 xml 方式：web.xml"></a>1 xml 方式：<code>web.xml</code></h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span><span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span><span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span><span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>过滤指定 url<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>过滤指定 servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>过滤哪种模式的请求，必须写在最后<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>过滤器链执行顺序由 <code>&lt;filter-mapping&gt;</code> 配置顺序决定</li>
</ul>
<h3 id="2-注解：-WebFilter"><a href="#2-注解：-WebFilter" class="headerlink" title="2 注解：@WebFilter"></a>2 注解：<code>@WebFilter</code></h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>等价于</th>
</tr>
</thead>
<tbody><tr>
<td><code>String filterName()</code></td>
<td>过滤器名称</td>
<td><code>&lt;filter-name&gt;</code></td>
</tr>
<tr>
<td><code>String[] urlPatterns()</code></td>
<td>映射</td>
<td><code>&lt;url-pattern&gt;</code></td>
</tr>
<tr>
<td><code>String[] value()</code></td>
<td>同 <code>urlPatterns</code></td>
<td><code>&lt;url-pattern&gt;</code></td>
</tr>
<tr>
<td><code>String[] servletNames()</code></td>
<td>过滤哪些<code>Servlet</code></td>
<td><code>&lt;servlet-name&gt;</code></td>
</tr>
<tr>
<td><code>DispatcherType dispatcherTypes()</code></td>
<td>过滤哪种模式的请求</td>
<td><code>&lt;dispatcher&gt;</code></td>
</tr>
<tr>
<td><code>WebInitParam[] initParams()</code></td>
<td>初始化参数</td>
<td><code>&lt;init-param&gt;</code></td>
</tr>
</tbody></table>
<ul>
<li>按照类名的字符串比较规则比较，值小的先执行</li>
</ul>
<h3 id="3-映射规则-lt-url-pattern-gt"><a href="#3-映射规则-lt-url-pattern-gt" class="headerlink" title="3 映射规则 &lt;url-pattern&gt;"></a>3 映射规则 <code>&lt;url-pattern&gt;</code></h3><table>
<thead>
<tr>
<th>优先级 高 → 低</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>/XXX/XX</code></td>
<td>精确匹配</td>
</tr>
<tr>
<td><code>/*</code></td>
<td>任意路径</td>
</tr>
<tr>
<td><code>*.do</code></td>
<td>任意扩展名</td>
</tr>
</tbody></table>
<h3 id="4-lt-dispatcher-gt"><a href="#4-lt-dispatcher-gt" class="headerlink" title="4 &lt;dispatcher&gt;"></a>4 <code>&lt;dispatcher&gt;</code></h3><table>
<thead>
<tr>
<th>值</th>
<th>过滤</th>
</tr>
</thead>
<tbody><tr>
<td><code>REQUEST</code> （默认）</td>
<td>直接请求，重定向请求</td>
</tr>
<tr>
<td><code>FORWARD</code></td>
<td>转发请求</td>
</tr>
<tr>
<td><code>INCLUDE</code></td>
<td>包含请求</td>
</tr>
<tr>
<td><code>ERROR</code></td>
<td>声明式异常处理请求</td>
</tr>
</tbody></table>
<h2 id="1-4-Filter-生命周期"><a href="#1-4-Filter-生命周期" class="headerlink" title="1.4 Filter 生命周期"></a>1.4 Filter 生命周期</h2><table>
<thead>
<tr>
<th>阶段</th>
<th>方法</th>
<th>执行时机</th>
<th>执行次数</th>
</tr>
</thead>
<tbody><tr>
<td>1 实例化</td>
<td>构造函数</td>
<td>启动服务器时</td>
<td>执行一次</td>
</tr>
<tr>
<td>2 初始化</td>
<td><code>init()</code></td>
<td>启动服务器时</td>
<td>执行一次</td>
</tr>
<tr>
<td>3 过滤</td>
<td><code>doFilter()</code></td>
<td>过滤请求时</td>
<td>每次过滤都执行，且在请求处理前后各执行一次</td>
</tr>
<tr>
<td>4 销毁</td>
<td><code>destroy()</code></td>
<td>关闭服务器时</td>
<td>执行一次</td>
</tr>
</tbody></table>
<h2 id="1-5-Filter-执行流程"><a href="#1-5-Filter-执行流程" class="headerlink" title="1.5 Filter 执行流程"></a>1.5 Filter 执行流程</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/JavaWEB/Filter%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt=""></p>
<ol>
<li>请求</li>
<li>正序执行过滤器链中各个过滤器放行前的代码</li>
<li>处理请求</li>
<li>倒叙执行过滤器链中各个过滤器放行后的代码</li>
<li>响应</li>
</ol>
<h1 id="二-监听器-Listener"><a href="#二-监听器-Listener" class="headerlink" title="二 监听器 Listener"></a>二 监听器 Listener</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol>
<li>监听器用于监听 WEB 程序中的事件<ol>
<li>域对象 <code>HttpRequest HttpSession ServletContext</code> 的创建，属性变化，销毁</li>
<li>Session 域中对象的绑定</li>
<li>Session 的钝化活化</li>
</ol>
</li>
<li>监听器基于观察者设计模式</li>
</ol>
<h2 id="2-2-事件监听机制"><a href="#2-2-事件监听机制" class="headerlink" title="2.2 事件监听机制"></a>2.2 事件监听机制</h2><table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>事件源</td>
<td>监听的对象</td>
</tr>
<tr>
<td>事件</td>
<td>监听的事件</td>
</tr>
<tr>
<td>监听器</td>
<td>监听器</td>
</tr>
<tr>
<td>注册监听</td>
<td>将事件源、事件、监听器绑定，当事件源上发生某个事件时，执行监听器代码</td>
</tr>
</tbody></table>
<h2 id="2-3-注册监听器"><a href="#2-3-注册监听器" class="headerlink" title="2.3 注册监听器"></a>2.3 注册监听器</h2><h3 id="1-XML-方式-web-xml"><a href="#1-XML-方式-web-xml" class="headerlink" title="1 XML 方式  web.xml"></a>1 XML 方式  <code>web.xml</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">	&lt;listener-class&gt;&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-注解-WebListener"><a href="#2-注解-WebListener" class="headerlink" title="2 注解 @WebListener"></a>2 注解 <code>@WebListener</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@WebListener</span><br><span class="line">// 在监听器类上添加此注解即可</span><br></pre></td></tr></table></figure>

<h2 id="2-4-常见监听器"><a href="#2-4-常见监听器" class="headerlink" title="2.4 常见监听器"></a>2.4 常见监听器</h2><h3 id="1-监听域对象的创建与销毁"><a href="#1-监听域对象的创建与销毁" class="headerlink" title="1 监听域对象的创建与销毁"></a>1 监听域对象的创建与销毁</h3><h4 id="1-ServletRequestListener"><a href="#1-ServletRequestListener" class="headerlink" title="1 ServletRequestListener"></a>1 <code>ServletRequestListener</code></h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>requestInitialized(ServletRequestEvent event)</code></td>
<td>监听 <code>ServletRequest</code> 域的创建</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>requestDestroyed(ServletRequestEvent event)</code></td>
<td>监听 <code>ServletRequest</code> 域的销毁</td>
</tr>
</tbody></table>
<h4 id="2-HttpSessionListener"><a href="#2-HttpSessionListener" class="headerlink" title="2 HttpSessionListener"></a>2 <code>HttpSessionListener</code></h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>sessionCreated(HttpSessionEvent event)</code></td>
<td>监听 <code>HttpSession</code> 域的创建</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>sessionDestroyed(HttpSessionEvent event)</code></td>
<td>监听 <code>HttpSession</code> 域的销毁</td>
</tr>
</tbody></table>
<h4 id="3-ServletContextListener"><a href="#3-ServletContextListener" class="headerlink" title="3 ServletContextListener"></a>3 <code>ServletContextListener</code></h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>contextInitialized(ServletContextEvent event)</code></td>
<td>监听 <code>ServletContext</code> 域的创建</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>contextDestroyed(ServletContextEvent event)</code></td>
<td>监听 <code>ServletContext</code> 域的销毁</td>
</tr>
</tbody></table>
<h3 id="2-监听域对象的属性变化"><a href="#2-监听域对象的属性变化" class="headerlink" title="2 监听域对象的属性变化"></a>2 监听域对象的属性变化</h3><h4 id="1-ServletRequestAttributeListener"><a href="#1-ServletRequestAttributeListener" class="headerlink" title="1 ServletRequestAttributeListener"></a>1 <code>ServletRequestAttributeListener</code></h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>attributeAdded(ServletRequestAttributeEvent event)</code></td>
<td>监听 <code>ServletRequest</code> 域中属性的添加</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>attributeRemoved(ServletRequestAttributeEvent event)</code></td>
<td>监听 <code>ServletRequest</code> 域中属性的删除</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>attributeReplaced(ServletRequestAttributeEvent event)</code></td>
<td>监听 <code>ServletRequest</code> 域中属性的修改</td>
</tr>
</tbody></table>
<h4 id="2-HttpSessionAttributeListener"><a href="#2-HttpSessionAttributeListener" class="headerlink" title="2 HttpSessionAttributeListener"></a>2 <code>HttpSessionAttributeListener</code></h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>attributeAdded(HttpSessionBindingEvent event)</code></td>
<td>监听 <code>HttpSession</code> 域中属性的添加</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>attributeRemoved(HttpSessionBindingEvent event)</code></td>
<td>监听 <code>HttpSession</code> 域中属性的删除</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>attributeReplaced(HttpSessionBindingEvent event)</code></td>
<td>监听 <code>HttpSession</code>域中属性的修改</td>
</tr>
</tbody></table>
<h4 id="3-ServletContextAttributeListener"><a href="#3-ServletContextAttributeListener" class="headerlink" title="3 ServletContextAttributeListener"></a>3 <code>ServletContextAttributeListener</code></h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>attributeAdded(ServletContextAttributeEvent event)</code></td>
<td>监听 <code>ServletContext</code> 域中属性的添加</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>attributeRemoved(ServletContextAttributeEvent event)</code></td>
<td>监听 <code>ServletContext</code> 域中属性的删除</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>attributeReplaced(ServletContextAttributeEvent event)</code></td>
<td>监听 <code>ServletContext</code> 域中属性的修改</td>
</tr>
</tbody></table>
<h3 id="3-监听-HttpSession-域中的对象"><a href="#3-监听-HttpSession-域中的对象" class="headerlink" title="3 监听 HttpSession 域中的对象"></a>3 监听 HttpSession 域中的对象</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>此类监听器不用注册</li>
<li>要用被监听对象实现此类监听器</li>
</ol>
<h4 id="2-HttpSessionBindingListener"><a href="#2-HttpSessionBindingListener" class="headerlink" title="2 HttpSessionBindingListener"></a>2 <code>HttpSessionBindingListener</code></h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>valueBound(HttpSessionBindingEvent event)</code></td>
<td>对象绑定到 <code>HttpSession</code> 域中时触发</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>valueUnBound(HttpSessionBindingEvent event)</code></td>
<td>对象从 <code>HttpSession</code> 域中解绑时触发</td>
</tr>
</tbody></table>
<h4 id="3-HttpSessionActivationListener"><a href="#3-HttpSessionActivationListener" class="headerlink" title="3 HttpSessionActivationListener"></a>3 <code>HttpSessionActivationListener</code></h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>sessionDidActivate(HttpSessionEvetn event)</code></td>
<td>监听 <code>HttpSession</code> 的钝化</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>sessionWillPassivate(HttpSessionEvetn event)</code></td>
<td>监听 <code>HttpSession</code> 的活化</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CS</category>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>文件上传和下载</title>
    <url>/anyeansan.github.io/2020/11/08/JavaWeb/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="一-上传"><a href="#一-上传" class="headerlink" title="一 上传"></a>一 上传</h1><h2 id="1-1-文件上传前提"><a href="#1-1-文件上传前提" class="headerlink" title="1.1 文件上传前提"></a>1.1 文件上传前提</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>form</code> 表单，包含文本域 <code>&lt;input type=&quot;file&quot;&gt;</code></li>
<li><code>method = post</code></li>
<li><code>enctype = multipart/form-data</code></li>
</ol>
<h2 id="1-2-文件上传原理"><a href="#1-2-文件上传原理" class="headerlink" title="1.2 文件上传原理"></a>1.2 文件上传原理</h2><ol>
<li><code>enctype=multipart/form-data</code> 时，使用 <code>request.getParameter(key)</code>取不到表单数据</li>
<li>通过流解析请求体，获取上传文件</li>
</ol>
<h2 id="1-3-Apache-Commons-Fileupload"><a href="#1-3-Apache-Commons-Fileupload" class="headerlink" title="1.3 Apache Commons Fileupload"></a>1.3 <code>Apache Commons Fileupload</code></h2><h3 id="1-API"><a href="#1-API" class="headerlink" title="1 API"></a>1 API</h3><table>
<thead>
<tr>
<th>类/接口</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>DiskFileItemFactory</code></td>
<td>工厂类，用来创建 <code>ServletFileUpload</code></td>
</tr>
<tr>
<td><code>ServletFileUpload</code></td>
<td>解析器对象</td>
</tr>
<tr>
<td><code>FileItem</code></td>
<td>对应一个表单项，分为普通字段和文件字段</td>
</tr>
</tbody></table>
<h4 id="1-DiskFileItemFactory"><a href="#1-DiskFileItemFactory" class="headerlink" title="1 DiskFileItemFactory"></a>1 <code>DiskFileItemFactory</code></h4><h5 id="1-构造"><a href="#1-构造" class="headerlink" title="1 构造"></a>1 构造</h5><table>
<thead>
<tr>
<th>构造函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>DiskFileItemFactory()</code></td>
<td>创建工厂类</td>
</tr>
<tr>
<td><code>DiskFileItemFactory(int sizeThreshold, File repository)</code></td>
<td>创建工厂类，并指定缓存文件的大小和临时文件的位置</td>
</tr>
</tbody></table>
<h5 id="2-方法"><a href="#2-方法" class="headerlink" title="2 方法"></a>2 方法</h5><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>setSizeThreshold(int sizeThreshold)</code></td>
<td>设置缓存文件的大小</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setRepository((File repository))</code></td>
<td>设置临时文件位置</td>
</tr>
</tbody></table>
<h4 id="2-ServletFileUpload"><a href="#2-ServletFileUpload" class="headerlink" title="2 ServletFileUpload"></a>2 <code>ServletFileUpload</code></h4><h5 id="1-构造-1"><a href="#1-构造-1" class="headerlink" title="1 构造"></a>1 构造</h5><table>
<thead>
<tr>
<th>构造函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ServletFileUpload()</code></td>
<td>创建解析器</td>
</tr>
<tr>
<td><code>ServletFileUpload(FileItemFactory factory)</code></td>
<td>根据工厂创建解析器</td>
</tr>
</tbody></table>
<h5 id="2-方法-1"><a href="#2-方法-1" class="headerlink" title="2 方法"></a>2 方法</h5><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>isMultipartContent(HttpServletRequest request)</code></td>
<td>判断请求是否包含上传</td>
</tr>
<tr>
<td><code>List&lt;FileItem&gt;</code></td>
<td><code>parseRequest(HttpServletRequest request)</code></td>
<td>解析请求</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setFileSizeMax(long fileSizeMax)</code></td>
<td>单个上传文件大小最大值</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setSizeMax(long sizeMax)</code></td>
<td>多上传文件总大小最大值</td>
</tr>
</tbody></table>
<h4 id="3-FileItem"><a href="#3-FileItem" class="headerlink" title="3 FileItem"></a>3 <code>FileItem</code></h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>isFormField()</code></td>
<td>判断是否是普通表单项，<code>false</code> ：表示是文件字段</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getFieldName()</code></td>
<td>获取字段名</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getName()</code></td>
<td>获取文件名</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getContentType()</code></td>
<td>获取文件的 MIME 类型</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getString([String encoding])</code></td>
<td>普通字段：返回 value，文件字段：返回内容</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getSize()</code></td>
<td>获取文件大小</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>write(File file)</code></td>
<td>保存上传文件到指定文件</td>
</tr>
<tr>
<td><code>InputStream</code></td>
<td><code>getInputStream()</code></td>
<td>获取上传文件对应的字节输入流</td>
</tr>
<tr>
<td><code>OutputStream</code></td>
<td><code>getOutputStream()</code></td>
<td>获取上传文件对应的字节输出流</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>delete()</code></td>
<td>清理临时文件</td>
</tr>
</tbody></table>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建工厂类 DiskFileItemFactory</span></span><br><span class="line">DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 根据工厂创建解析器 ServletFileUpload </span></span><br><span class="line">ServletFileUpload fileUpload = <span class="keyword">new</span> ServletFileUpload(factory)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 解析请求</span></span><br><span class="line">List&lt;FileItem&gt; list = fileUpload.parseRequest(request)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 获取文件名和文件内容。。。，保存文件</span></span><br></pre></td></tr></table></figure>

<h3 id="3-文件上传注意事项"><a href="#3-文件上传注意事项" class="headerlink" title="3 文件上传注意事项"></a>3 文件上传注意事项</h3><ol>
<li>上传的文件名是全路径，有的浏览器会自动处理，有的不会，最好处理一下</li>
<li>存储的文件名唯一，避免文件被覆盖</li>
<li>多目录，避免同一目录文件过多</li>
<li>限制文件的大小：web 方式不适合上传大的文件</li>
<li>临时文件<ol>
<li><code>DiskFileItemFactory</code> 内部有一个默认 <code>10KB</code> 的缓存，如果上传文件超过缓存大小，会用磁盘作为缓存</li>
<li>存放缓存文件的目录即临时文件目录</li>
<li>如果自己用 IO 流实现的文件上传，要在流关闭后，清理临时文件</li>
</ol>
</li>
</ol>
<h2 id="1-4-Apache-Commons-IO"><a href="#1-4-Apache-Commons-IO" class="headerlink" title="1.4 Apache Commons IO"></a>1.4 <code>Apache Commons IO</code></h2><h3 id="1-FilenameUtils"><a href="#1-FilenameUtils" class="headerlink" title="1 FilenameUtils"></a>1 FilenameUtils</h3><h3 id="2-IOUtils"><a href="#2-IOUtils" class="headerlink" title="2 IOUtils"></a>2 IOUtils</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>copy(InputStream in, OutputStream out, [int bufferSize])</code></td>
<td>从字节输入流向字节输出流拷贝</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>copy(Reader in, writer out)</code></td>
<td>从字符输入流向字符输出流拷贝</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>copy(InputStream in, Writer out, String inEncoding)</code></td>
<td>从字节输入流向字符输出流拷贝</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>copy(Reader in, OutputStream out, String outEncoding)</code></td>
<td>从字符输入流向字节输出流拷贝</td>
</tr>
</tbody></table>
<h1 id="二-下载"><a href="#二-下载" class="headerlink" title="二 下载"></a>二 下载</h1><h2 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h2><ul>
<li><code>Content-disposition</code><ul>
<li>响应头，服务器告诉客户端以什么格式打开响应体数据</li>
<li><code>in-line</code>：默认值，在当前页面内打开</li>
<li><code>attachment;filename=</code>：以附件形式打开响应体（文件下载）</li>
</ul>
</li>
</ul>
<h2 id="2-2-文件下载步骤"><a href="#2-2-文件下载步骤" class="headerlink" title="2.2 文件下载步骤"></a>2.2 文件下载步骤</h2><ol>
<li><p>发送请求，包含要下载的文件名</p>
</li>
<li><p>获取文件在服务器的真实路径</p>
</li>
<li><p>根据文件路径创建输入流</p>
</li>
<li><p>设置响应头</p>
<ol>
<li><p>下载文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response.setHeader(&quot;content-disposition&quot;, &quot;attachment;filename=&quot;+fileName)</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1 手动设置类型</span><br><span class="line">response.setHeader(&quot;content-type&quot;, &quot;image/jpeg&quot;);</span><br><span class="line">// 2 根据文件名获取类型</span><br><span class="line">response.setContentType(this.getServletContext().getMimeType(fileName))</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>获取响应输出流，不断读写</p>
</li>
</ol>
<h2 id="2-3-下载文件名中文问题"><a href="#2-3-下载文件名中文问题" class="headerlink" title="2.3 下载文件名中文问题"></a>2.3 下载文件名中文问题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// agent就是请求头 User-Agent 的值</span><br><span class="line">public class DownLoadUtils &#123;</span><br><span class="line">    public static String getFileName(String agent, String filename) throws UnsupportedEncodingException &#123;</span><br><span class="line">        if (agent.contains(&quot;MSIE&quot;)) &#123;</span><br><span class="line">            // IE浏览器</span><br><span class="line">            filename = URLEncoder.encode(filename, &quot;utf-8&quot;);</span><br><span class="line">            filename = filename.replace(&quot;+&quot;, &quot; &quot;);</span><br><span class="line">        &#125; else if (agent.contains(&quot;Firefox&quot;)) &#123;</span><br><span class="line">            // 火狐浏览器</span><br><span class="line">            BASE64Encoder base64Encoder = new BASE64Encoder();</span><br><span class="line">            filename = &quot;=?utf-8?B?&quot; + base64Encoder.encode(filename.getBytes(&quot;utf-8&quot;)) + &quot;?=&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 其它浏览器</span><br><span class="line">            filename = URLEncoder.encode(filename, &quot;utf-8&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return filename;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CS</category>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>会话</title>
    <url>/anyeansan.github.io/2020/11/08/JavaWeb/%E4%BC%9A%E8%AF%9D/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>打开浏览器，不管是多标签，还是多窗口，直到全部关闭，是一次会话</li>
<li>本质上：从 Session 对象的创建到最终 Session 的销毁，才是真正意义上的一次完整会话</li>
<li>保存会话数据有两种技术：<ol>
<li>Cookie</li>
<li>Session</li>
</ol>
</li>
</ol>
<h1 id="二-Cookie"><a href="#二-Cookie" class="headerlink" title="二 Cookie"></a>二 Cookie</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol>
<li><p>Cookie  基于响应头 <code>set-cookie</code> 和请求头 <code>cookie</code> 实现</p>
</li>
<li><p>Cookie 是由服务器创建，响应给客户端的（一次可响应多个）</p>
<ul>
<li>可以保存在浏览器缓存中（默认），浏览器关闭则 Cookie 消失</li>
<li>可以保存在客户端硬盘中（设置有效时间），浏览器关闭 Cookie 还在，直到失效</li>
</ul>
</li>
<li><p>Cookie 只能存储字符串</p>
</li>
<li><p>Cookie 是与请求路径绑定的，只有有效路径的请求才会携带 Cookie，默认有效路径为创建 Cookie 那个请求路径的父路径</p>
</li>
<li><p>流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 在服务端创建 Cookie</span></span><br><span class="line">Cookie cookie=<span class="keyword">new</span> Cookie(String name,String value)</span><br><span class="line"><span class="comment">// 2. 设置有效时间</span></span><br><span class="line">cookie.setMaxAge(<span class="number">3600</span>)</span><br><span class="line"><span class="comment">// 3. 响应给客户端，可响应多个 Cookie</span></span><br><span class="line">response.addCookie(cookie)</span><br><span class="line"><span class="comment">// 4. 再次请求时获取 Cookie</span></span><br><span class="line">Cookie[] cs=request.getCookies()</span><br></pre></td></tr></table></figure>

<ol>
<li>第一次请求时，服务器创建 Cookie，然后响应给客户端，并保存在客户端</li>
<li>之后的请求会携带 Cookie，服务器可以获取 Cookie 信息</li>
</ol>
</li>
</ol>
<h2 id="2-2-javax-servlet-http-Cookie"><a href="#2-2-javax-servlet-http-Cookie" class="headerlink" title="2.2 javax.servlet.http.Cookie"></a>2.2 <code>javax.servlet.http.Cookie</code></h2><h3 id="1-构造"><a href="#1-构造" class="headerlink" title="1 构造"></a>1 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Cookie(String name, String value)</code></td>
<td>创建 Cookie，指定键值</td>
</tr>
</tbody></table>
<h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2 方法"></a>2 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>getName()</code></td>
<td>获取 Cookie 的键</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getValue()</code></td>
<td>获取 Cookie 的值</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setValue(String newVal)</code></td>
<td>修改 Cookie 的值</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPath(String url)</code></td>
<td>设置 Cookie 有效路径，只有以此路径开头的请求才可以携带</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getPath()</code></td>
<td>获取 Cookie 有效路径</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setMaxAge(int second)</code></td>
<td>设置有效时间（默认会话结束则消失），正表示有效时间，负表示不保存，0 表示删除</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setDomain(String domain)</code></td>
<td>设置 Cookie 一级域名</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getDomain()</code></td>
<td>获取 Cookie 一级域名</td>
</tr>
</tbody></table>
<h2 id="2-3-Cookie-存中文"><a href="#2-3-Cookie-存中文" class="headerlink" title="2.3 Cookie 存中文"></a>2.3 Cookie 存中文</h2><ol>
<li>Tomcat 8 之前，不可以，需要 URL 编码</li>
<li>Tomcat 8 之后，键可以，但特殊字符不支持，还是建议 URL 编码</li>
<li>URL 编码：使用 <code>URLEncoder</code> 的 <code>encode()</code> 和 <code>decode()</code> 方法</li>
</ol>
<h2 id="2-4-Cookie-共享"><a href="#2-4-Cookie-共享" class="headerlink" title="2.4 Cookie 共享"></a>2.4 Cookie 共享</h2><ol>
<li>同一个服务器下的多个项目<ol>
<li>Cookie 默认 <code>path</code> 是创建时的项目的虚拟路径，所以其它项目是访问不到的</li>
<li>通过 <code>setPath(&quot;/&quot;)</code> 实现共享</li>
</ol>
</li>
<li>不同服务器的共享<ul>
<li><code>setDomain(String path)</code><ul>
<li>如果设置一级域名相同，那么多个服务器间的 Cookie 可以共享</li>
<li><code>setDomain(&quot;.baidu.com&quot;)</code><ul>
<li>则 <code>tieba.baidu.com</code>和 <code>news.baidu.com</code>…之间就可以共享</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="三-Session"><a href="#三-Session" class="headerlink" title="三 Session"></a>三 Session</h1><h2 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h2><ol>
<li>第一次请求服务器时，服务器创建 HttpSession 对象，并创建一个特殊的 Cookie，此特殊 Cookie：<ul>
<li>键： <code>JSessionID</code></li>
<li>值： Session 的 id</li>
</ul>
</li>
<li>将 Cookie 响应到客户端</li>
<li>再次请求时携带此 Cookie，服务器就可以获取 Session 的 id</li>
<li>服务器中维护了一个 Session 列表，根据获取的 Session 的 id 就可以获取对应的 HttpSession 对象</li>
</ol>
<h2 id="3-2-javax-servlet-http-HttpSession"><a href="#3-2-javax-servlet-http-HttpSession" class="headerlink" title="3.2 javax.servlet.http.HttpSession"></a>3.2 <code>javax.servlet.http.HttpSession</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>getId()</code></td>
<td>获取 Session 的 id</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setMaxInactiveInterval(int second)</code></td>
<td>设置 Session 有效期，默认 30 分钟</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getMaxInactiveInterval()</code></td>
<td>获取 Session 有效时间</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>invalidate</code></td>
<td>销毁 Session</td>
</tr>
</tbody></table>
<h2 id="3-3-Session-的创建-获取"><a href="#3-3-Session-的创建-获取" class="headerlink" title="3.3 Session 的创建/获取"></a>3.3 Session 的创建/获取</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 若存在则获取，不存在则创建</span></span><br><span class="line">HttpSession session = request.getSession()</span><br><span class="line">HttpSession session = request.getSession(<span class="keyword">true</span>)</span><br><span class="line"><span class="comment">// 若存在则获取，不存在则返回 null</span></span><br><span class="line">HttpSession session = request.getSession(<span class="keyword">false</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-4-Session-的有效期"><a href="#3-4-Session-的有效期" class="headerlink" title="3.4 Session 的有效期"></a>3.4 Session 的有效期</h2><ol>
<li>虽然 Session 默认有效期为 30 分钟，但 Session 依赖于 Cookie，而 Cookie 默认是会话级别的，所以 Session 默认也是会话级别</li>
<li>设置 Session 的有效期，需要同时设置 Cookie 和 Session</li>
</ol>
<h2 id="3-5-Session-的销毁"><a href="#3-5-Session-的销毁" class="headerlink" title="3.5 Session 的销毁"></a>3.5 Session 的销毁</h2><ol>
<li>服务器关闭</li>
<li>调用<code>invalidate()</code></li>
<li>Tomcat 的 <code>/conf/web.xml</code> 中的配置 <code>&lt;session-config&gt;</code>，默认是 30 分钟，可修改</li>
</ol>
<h2 id="3-6-Session-的钝化和活化"><a href="#3-6-Session-的钝化和活化" class="headerlink" title="3.6 Session 的钝化和活化"></a>3.6 Session 的钝化和活化</h2><ol>
<li>当服务器关闭再开启时，由于对象的地址是随机性的，可能导致两次的 Session 不一致，通过 Session 的钝化和活化可以解决此问题</li>
<li>钝化<ol>
<li>将 Session 对象和对象中的数据从内存序列化到硬盘的过程</li>
<li>钝化时机：服务器关闭</li>
</ol>
</li>
<li>活化<ol>
<li>将 Session 对象和对象中的数据从硬盘反序列化到内存的过程</li>
<li>活化时机：服务器重启</li>
</ol>
</li>
<li>Tomcat<ol>
<li>DOS 命令下，正常关闭 Tomcat ，会自动钝化 Session，在 <code>work</code> 目录下生成 <code>SESSIONS.ser</code> 文件，再次启动，会活化</li>
<li>IDEA 中，正常关闭 Tomcat ，也会钝化，但由于 IDEA 采用虚拟目录方式部署应用，重启 Tomcat 时，IDEA会先删除虚拟目录中的 <code>work</code> 目录，即钝化文件被删除了，也就无法活化了</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>JSP</title>
    <url>/anyeansan.github.io/2020/11/08/JavaWeb/JSP/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li><code>Java Server Pages</code></li>
<li>Jsp 本质是 Servlet<ol>
<li><code>.jsp</code> 翻译成的 <code>.java</code> 文件继承了 <code>HttpJspBase</code></li>
<li><code>HttpJspBase</code> 继承了 <code>HttpServlet</code></li>
</ol>
</li>
</ol>
<h1 id="二-执行过程"><a href="#二-执行过程" class="headerlink" title="二 执行过程"></a>二 执行过程</h1><ol>
<li>第一次访问会把 <code>.jsp</code> 先翻译成 <code>.java</code> 文件</li>
<li><code>.java</code>编译成<code>.class</code>文件</li>
<li>此后访问直接只需 <code>.class</code> 文件</li>
<li>如果 <code>.jsp</code> 发生变化，则视为第一次访问，从头开始</li>
</ol>
<h1 id="三-语法"><a href="#三-语法" class="headerlink" title="三 语法"></a>三 语法</h1><h2 id="3-1-注释"><a href="#3-1-注释" class="headerlink" title="3.1 注释"></a>3.1 注释</h2><table>
<thead>
<tr>
<th>注释</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;!-- --&gt;</code></td>
<td>不能注释脚本，会被写到最终页面</td>
</tr>
<tr>
<td><code>&lt;%-- --%&gt;</code></td>
<td>可以注释脚本，不会被写到最终页面</td>
</tr>
</tbody></table>
<h2 id="3-2-脚本"><a href="#3-2-脚本" class="headerlink" title="3.2 脚本"></a>3.2 脚本</h2><table>
<thead>
<tr>
<th>语法</th>
<th>名称</th>
<th>最终位置</th>
</tr>
</thead>
<tbody><tr>
<td>页面内容（HTML, CSS, JS, 文本…）</td>
<td></td>
<td><code>service()</code> 方法中： <code>out.write(&quot;翻译到这里&quot;)</code></td>
</tr>
<tr>
<td><code>&lt;% %&gt;</code></td>
<td>脚本</td>
<td><code>service()</code> 方法中</td>
</tr>
<tr>
<td><code>&lt;%= %&gt;</code></td>
<td>表达式</td>
<td><code>service()</code> 方法中： <code>out.write(&quot;翻译到这里&quot;)</code></td>
</tr>
<tr>
<td><code>&lt;%! %&gt;</code></td>
<td>声明</td>
<td><code>.java</code> 文件下成员位置</td>
</tr>
</tbody></table>
<h2 id="3-3-指令"><a href="#3-3-指令" class="headerlink" title="3.3 指令"></a>3.3 指令</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@指令名 属性<span class="number">1</span>=<span class="string">"值"</span> 属性<span class="number">2</span>=<span class="string">"值"</span>... %&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>jsp 指令不直接产生任何可见输出，而只告诉 jsp 引擎如何处理 jsp 页面中的内容。</li>
<li>页面中可出现多次</li>
</ol>
<h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2 分类"></a>2 分类</h3><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>page</code></td>
<td>用于定义 jsp 页面的各种属性</td>
</tr>
<tr>
<td><code>taglib</code></td>
<td>在 JSP 页面中导入标签库</td>
</tr>
<tr>
<td><code>include</code></td>
<td>静态包含</td>
</tr>
</tbody></table>
<h4 id="1-page"><a href="#1-page" class="headerlink" title="1 page"></a>1 page</h4><table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>import</code></td>
<td>导包</td>
<td>jsp 默认导入的包：<code>java.lang.*，javax.servlet.*，javax.servlet.http.*，javax.servlet.jsp.*</code></td>
</tr>
<tr>
<td><code>language</code></td>
<td>语言</td>
<td>默认 <code>java</code></td>
</tr>
<tr>
<td><strong><code>pageEncoding</code></strong></td>
<td>设置响应编码方式</td>
<td>告诉服务器用什么编码把 <code>.jsp</code> 翻译成 <code>.java</code> 文件</td>
</tr>
<tr>
<td><code>contentType</code></td>
<td>设置响应内容，同时可以设置响应编码方式</td>
<td>等价于<code>response.setContentType(&quot;text/html;charset=utf-8&quot;);</code>，如果不设置则使用 <code>pageEncoding</code> 的编码</td>
</tr>
<tr>
<td><code>session</code></td>
<td>当前页面是否启用 session</td>
<td>默认 <code>true</code></td>
</tr>
<tr>
<td><code>buffer</code></td>
<td>输出数据的缓存大小(<code>out</code> 的缓冲区)</td>
<td>默认 <code>8KB</code></td>
</tr>
<tr>
<td><code>errorPage</code></td>
<td>配置错误页面</td>
<td>jsp 页面出现错误跳转的页面</td>
</tr>
<tr>
<td><code>isErrorPage</code></td>
<td>是否是错误页面，即是否可以使用内置对象 <code>exception</code></td>
<td>默认 <code>false</code></td>
</tr>
<tr>
<td><code>isELIgnored</code></td>
<td>是否忽略 EL 表达式</td>
<td>默认 <code>false</code></td>
</tr>
</tbody></table>
<h4 id="2-taglib"><a href="#2-taglib" class="headerlink" title="2 taglib"></a>2 taglib</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib uri=&quot;库地址&quot; prefix=&quot;页面使用库所用的前缀&quot; %&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-include"><a href="#3-include" class="headerlink" title="3 include"></a>3 include</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ include file=&quot;&quot; %&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>静态包含</strong>，被包含文件可以是任意网络资源</li>
<li>先合并成一个文件，再翻译，所以被包含的文件不会单独翻译和编译</li>
</ul>
<h2 id="3-4-jsp-编码问题"><a href="#3-4-jsp-编码问题" class="headerlink" title="3.4 jsp 编码问题"></a>3.4 jsp 编码问题</h2><h3 id="1-jsp-编解码过程"><a href="#1-jsp-编解码过程" class="headerlink" title="1 jsp 编解码过程"></a>1 jsp 编解码过程</h3><ol>
<li><code>.jsp</code>的存储编码，<code>pageEncoding</code> 要与此编码一致否则翻译就会乱码</li>
<li><code>.jsp</code> → <code>.java</code><ul>
<li>使用 <code>pageEncoding</code> 指定的编码</li>
</ul>
</li>
<li><code>.java</code>→ <code>.class</code><ul>
<li>jvm 使用 <code>utf-8</code> 编译，不可修改</li>
</ul>
</li>
<li>浏览器解析<ul>
<li>使用的是 <code>contentType</code> 指定的编码</li>
</ul>
</li>
</ol>
<h3 id="2-解决乱码"><a href="#2-解决乱码" class="headerlink" title="2 解决乱码"></a>2 解决乱码</h3><ol>
<li>想要不乱码，保证以下三码一致即可<ol>
<li><code>.jsp</code>的存储编码</li>
<li><code>pageEncoding</code>的编码</li>
<li><code>contentType</code>的编码</li>
</ol>
</li>
<li>由于 <code>contentType</code> 不设置会使用 <code>pageEncoding</code> 的编码，所以保证 <code>.jsp</code>的存储编码和 <code>pageEncoding</code> 的编码一致即可</li>
<li>ide 通常设置为 <code>utf-8</code>，即存储编码为 <code>utf-8</code>，所以只需设置 <code>pageEncoding=&quot;utf-8&quot;</code> 即可</li>
</ol>
<h2 id="3-5-动作"><a href="#3-5-动作" class="headerlink" title="3.5 动作"></a>3.5 动作</h2><table>
<thead>
<tr>
<th>动作</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>动态包含</td>
<td><code>&lt;jsp:include page=&quot;&quot;&gt;</code></td>
<td>不会合并文件，当执行到时，才包含另一个文件的内容；被包含文件也会被翻译和编译</td>
</tr>
<tr>
<td>转发</td>
<td><code>&lt;jsp:forward page=&quot;path&quot;/&gt;</code></td>
<td>相当于 <code>req.getRequestDispatcher(path).forward(req,res);</code></td>
</tr>
<tr>
<td>请求参数</td>
<td><code>&lt;jsp:param name=&quot;&quot; value=&quot;&quot; /&gt;</code></td>
<td>相当于 <code>url?name=value</code></td>
</tr>
<tr>
<td>创建对象</td>
<td><code>&lt;jsp:useBean id=&quot;p&quot; class=&quot;a.Person&quot;&gt;</code></td>
<td>相当于 <code>a.Person p = new a.Person()</code></td>
</tr>
<tr>
<td>为对象属性赋值</td>
<td><code>&lt;jsp:setProperty property=&quot;age&quot; name=&quot;p&quot; value=&quot;8&quot;/&gt;</code></td>
<td>相当于 <code>p.setAge(8)</code></td>
</tr>
<tr>
<td>获取对象属性值</td>
<td><code>&lt;jsp:getProperty property=&quot;age&quot; name=&quot;p&quot;/&gt;</code></td>
<td>相当于 <code>p.getAge()</code></td>
</tr>
</tbody></table>
<h1 id="四-内置对象"><a href="#四-内置对象" class="headerlink" title="四 内置对象"></a>四 内置对象</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><table>
<thead>
<tr>
<th>对象名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>request</code></td>
<td><code>javax.servlet.http.HttpServletRequest</code></td>
<td>请求对象</td>
</tr>
<tr>
<td><code>response</code></td>
<td><code>javax.servlet.http.HttpServletResponse</code></td>
<td>响应对象</td>
</tr>
<tr>
<td><code>session</code></td>
<td><code>javax.servlet.http.HttpSession</code></td>
<td>会话对象</td>
</tr>
<tr>
<td><code>application</code></td>
<td><code>javax.servlet.ServletContext</code></td>
<td><code>ServletContext</code> 对象</td>
</tr>
<tr>
<td><code>pageContext</code></td>
<td><code>javax.servlet.jsp.PageContext</code></td>
<td><code>PageContext</code> 对象</td>
</tr>
<tr>
<td><code>exception</code></td>
<td><code>java.lang.Throwable</code></td>
<td>页面异常对象</td>
</tr>
<tr>
<td><code>page</code></td>
<td><code>java.lang.Object</code></td>
<td>当前 <code>servlet</code> 实例，即 <code>this</code></td>
</tr>
<tr>
<td><code>config</code></td>
<td><code>javax.servlet.ServletConfig</code></td>
<td><code>ServletConfig</code> 对象</td>
</tr>
<tr>
<td><code>out</code></td>
<td><code>javax.servlet.jsp.JspWriter</code></td>
<td>字符输出流</td>
</tr>
</tbody></table>
<ul>
<li>内置对象即 <code>service()</code> 方法中的局部变量，在 <code>&lt;%= %&gt;</code> 和 <code>&lt;% %&gt;</code> 中可以直接使用</li>
</ul>
<h2 id="4-2-out"><a href="#4-2-out" class="headerlink" title="4.2 out"></a>4.2 out</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1. tomcat 会先从 response 中获取数据，然后才从 out 中获取数据</span></span><br><span class="line"><span class="comment">* 2. 所以无论何时，总是 response 先输出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">out.write()</span><br><span class="line">response.getWriter().write()</span><br></pre></td></tr></table></figure>

<h2 id="4-3-pageContext"><a href="#4-3-pageContext" class="headerlink" title="4.3 pageContext"></a>4.3 pageContext</h2><h3 id="1-获取其它内置对象"><a href="#1-获取其它内置对象" class="headerlink" title="1 获取其它内置对象"></a>1 获取其它内置对象</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ServletRequest</code></td>
<td><code>getRequest()</code></td>
<td>获取 <code>request</code></td>
</tr>
<tr>
<td><code>ServletResponse</code></td>
<td><code>getResponse()</code></td>
<td>获取 <code>response</code></td>
</tr>
<tr>
<td><code>ServletContext</code></td>
<td><code>getServletContext()</code></td>
<td>获取 <code>application</code></td>
</tr>
<tr>
<td><code>ServletConfig</code></td>
<td><code>getServletConfig()</code></td>
<td>获取 <code>config</code></td>
</tr>
<tr>
<td><code>HttpSession</code></td>
<td><code>getSession()</code></td>
<td>获取 <code>session</code></td>
</tr>
<tr>
<td><code>Object</code></td>
<td><code>getPage()</code></td>
<td>获取 <code>page</code></td>
</tr>
<tr>
<td><code>Exception</code></td>
<td><code>getException</code></td>
<td>获取 <code>exception</code></td>
</tr>
</tbody></table>
<h3 id="2-域对象"><a href="#2-域对象" class="headerlink" title="2 域对象"></a>2 域对象</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>setAttribute(String name, Object value)</code></td>
<td>向 <code>page</code> 域中设置键值对</td>
</tr>
<tr>
<td><code>Object</code></td>
<td><code>getAttribute(String name)</code></td>
<td>根据键获取<code>page</code>域中键值对的值</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeAttribute(String name)</code></td>
<td>根据键移除<code>page</code>域中键值对</td>
</tr>
</tbody></table>
<h3 id="3-操作其它域对象"><a href="#3-操作其它域对象" class="headerlink" title="3 操作其它域对象"></a>3 操作其它域对象</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>setAttribute(String name, Object value, int scope)</code></td>
<td>向指定域中设置键值对</td>
</tr>
<tr>
<td><code>Object</code></td>
<td><code>getAttribute(String name, int scope)</code></td>
<td>根据键获取指定域中键值对的值</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeAttribute(String name, int scope)</code></td>
<td>根据键移除指定域中键值对</td>
</tr>
<tr>
<td><code>Object</code></td>
<td><code>findAttribute(String name)</code></td>
<td>按照 <code>page request session application</code> 的顺序查找</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>scope</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>PageContext.PAGE_SCOPE</code></td>
<td><code>page</code> 域</td>
</tr>
<tr>
<td><code>PageContext.REQUEST_SCOPE</code></td>
<td><code>request</code> 域</td>
</tr>
<tr>
<td><code>PageContext.SESSION_SCOPE</code></td>
<td><code>response</code> 域</td>
</tr>
<tr>
<td><code>PageContext.APPLICATION_SCOPE</code></td>
<td><code>application</code> 域</td>
</tr>
</tbody></table>
<h3 id="4-转发-amp-包含"><a href="#4-转发-amp-包含" class="headerlink" title="4 转发 &amp; 包含"></a>4 转发 &amp; 包含</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>forward(String relativeUrlPath)</code></td>
<td>转发</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>include(String relativeUrlPath, [boolean flush])</code></td>
<td>动态包含</td>
</tr>
</tbody></table>
<h1 id="五-EL-表达式"><a href="#五-EL-表达式" class="headerlink" title="五 EL 表达式"></a>五 EL 表达式</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol>
<li><code>expression language</code></li>
<li>EL 是 jsp 的内置表达式语言，可用于获取域中的值，简单的运算或判断操作<ol>
<li>EL 表达式只能从域中获取数据，且只能读不能写</li>
<li>EL 获取的值若为 <code>null</code> 会显示为 <code>&quot;&quot;</code></li>
</ol>
</li>
<li>EL 用于代替 jsp 表达式 <code>&lt;%= %&gt;</code></li>
<li>EL 会自动作类型转换</li>
<li>语法：<code>${表达式}</code></li>
</ol>
<h2 id="5-2-语法"><a href="#5-2-语法" class="headerlink" title="5.2 语法"></a>5.2 语法</h2><h3 id="1-运算"><a href="#1-运算" class="headerlink" title="1 运算"></a>1 运算</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>算术运算符</td>
<td><code>+ - * /(div) %(mod)</code></td>
</tr>
<tr>
<td>比较运算符</td>
<td><code>&gt; &lt; &gt;= &lt;= == !=</code></td>
</tr>
<tr>
<td>逻辑运算符</td>
<td><code>&& || !</code></td>
</tr>
<tr>
<td>空运算符</td>
<td><code>empty</code>，<code>null &quot;&quot; 空集合</code> 这三种情况为 <code>true</code></td>
</tr>
<tr>
<td>三元运算符</td>
<td><code>${empty key?&quot;为空&quot;:&quot;不为空&quot;}</code></td>
</tr>
</tbody></table>
<h3 id="2-获取域中数据"><a href="#2-获取域中数据" class="headerlink" title="2 获取域中数据"></a>2 获取域中数据</h3><table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>${key}</code></td>
<td>相当于 <code>pageContext.findAttribute()</code>，从四个域中依次查找</td>
</tr>
<tr>
<td><code>${scope.key}</code></td>
<td>从指定域中查找</td>
</tr>
</tbody></table>
<h2 id="5-3-EL-中的隐式对象"><a href="#5-3-EL-中的隐式对象" class="headerlink" title="5.3 EL 中的隐式对象"></a>5.3 EL 中的隐式对象</h2><table>
<thead>
<tr>
<th>隐式对象</th>
<th>类型</th>
<th>对应 jsp 内置对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>pageContext</code></td>
<td><code>javax.servlet.jsp.PageContex</code></td>
<td><code>pageContext</code></td>
<td>二者一样</td>
</tr>
<tr>
<td><code>pageScope</code></td>
<td><code>java.util.Map&lt;String,Object&gt;</code></td>
<td>无</td>
<td><code>page</code> 域</td>
</tr>
<tr>
<td><code>requestScope</code></td>
<td><code>java.util.Map&lt;String,Object&gt;</code></td>
<td>无</td>
<td><code>request</code> 域</td>
</tr>
<tr>
<td><code>sessionScope</code></td>
<td><code>java.util.Map&lt;String,Object&gt;</code></td>
<td>无</td>
<td><code>session</code> 域</td>
</tr>
<tr>
<td><code>applicationScope</code></td>
<td><code>java.util.Map&lt;String,Object&gt;</code></td>
<td>无</td>
<td><code>application</code> 域</td>
</tr>
<tr>
<td><code>param</code></td>
<td><code>java.util.Map&lt;String,String&gt;</code></td>
<td>无</td>
<td>请求参数</td>
</tr>
<tr>
<td><code>paramValues</code></td>
<td><code>java.util.Map&lt;String,String[]&gt;</code></td>
<td>无</td>
<td>请求参数有多个值</td>
</tr>
<tr>
<td><code>header</code></td>
<td><code>java.util.Map&lt;String,String&gt;</code></td>
<td>无</td>
<td>请求消息头</td>
</tr>
<tr>
<td><code>headerValues</code></td>
<td><code>java.util.Map&lt;String,String[]</code></td>
<td>无</td>
<td>请求消息头有多个值</td>
</tr>
<tr>
<td><code>initParam</code></td>
<td><code>java.util.Map&lt;String,String&gt;</code></td>
<td>无</td>
<td>初始化参数</td>
</tr>
<tr>
<td><code>cookie</code></td>
<td><code>java.util.Map&lt;String,Cookie&gt;</code></td>
<td>无</td>
<td><code>cookie</code></td>
</tr>
</tbody></table>
<h1 id="六-JSTL"><a href="#六-JSTL" class="headerlink" title="六 JSTL"></a>六 JSTL</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><ol>
<li><code>JavaServerPages Standard Tag Library</code></li>
<li>JSP 标准标签库，由五个库组成，用于替代 jsp 脚本 </li>
<li>EL 用于简化数据获取方面的 java 代码，而 JSTL 用于简化逻辑方面的 java 代码</li>
</ol>
<h2 id="6-2-组成"><a href="#6-2-组成" class="headerlink" title="6.2 组成"></a>6.2 组成</h2><table>
<thead>
<tr>
<th>功能</th>
<th>URI</th>
<th>前缀</th>
</tr>
</thead>
<tbody><tr>
<td>核心 <code>Core</code></td>
<td><code>http://java.sun.com/jsp/jstl/core</code></td>
<td><code>c</code></td>
</tr>
<tr>
<td>格式化 <code>I18N</code></td>
<td><code>http://java.sun.com/jsp/jstl/fmt</code></td>
<td><code>fmt</code></td>
</tr>
<tr>
<td>函数 <code>Function</code></td>
<td><code>http://java.sun.com/jsp/jstl/functions</code></td>
<td><code>fn</code></td>
</tr>
<tr>
<td>数据库 <code>SQL</code></td>
<td><code>http://java.sun.com/jsp/jstl/sql</code></td>
<td><code>sql</code></td>
</tr>
<tr>
<td>XML</td>
<td><code>http://java.sun.com/jsp/jstl/xml</code></td>
<td><code>x</code></td>
</tr>
</tbody></table>
<h2 id="6-3-使用-JSTL"><a href="#6-3-使用-JSTL" class="headerlink" title="6.3 使用 JSTL"></a>6.3 使用 JSTL</h2><ol>
<li><p>导包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">taglibs-standard-spec-1.2.5.jar (规范包)</span><br><span class="line">taglibs-standard-impl-1.2.5.jar（实现包）</span><br></pre></td></tr></table></figure>
</li>
<li><p>引入 JSTL 核心库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;自定义&quot; %&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="6-4-标签"><a href="#6-4-标签" class="headerlink" title="6.4 标签"></a>6.4 标签</h2><h3 id="1-通用标签"><a href="#1-通用标签" class="headerlink" title="1 通用标签"></a>1 通用标签</h3><h4 id="1-set"><a href="#1-set" class="headerlink" title="1 set"></a>1 set</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;c:set var=&quot;num&quot; value=&quot;10&quot; scope=&quot;session&quot; /&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>声明变量并赋值，存入指定域中</li>
<li>相当于 <code>setAttribute(String name, Object value, int scope)</code></li>
</ol>
<h4 id="2-out"><a href="#2-out" class="headerlink" title="2 out"></a>2 out</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;c:out value=&quot;$&#123;num&#125;&quot; scope=&quot;session&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>从指定域中获取值，<code>value</code>要使用 EL</li>
<li>相当于 <code>getAttribute(String name, int scope)</code></li>
<li>可以直接使用 EL 代替 <code>out</code> 标签</li>
</ol>
<h4 id="3-remove"><a href="#3-remove" class="headerlink" title="3 remove"></a>3 remove</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;c:remove var=&quot;num&quot; scope=&quot;session&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>从指定域中删除</li>
<li>相当于 <code>removeAttribute(String name, int Scopte)</code></li>
</ol>
<h3 id="2-条件标签"><a href="#2-条件标签" class="headerlink" title="2 条件标签"></a>2 条件标签</h3><h4 id="1-if"><a href="#1-if" class="headerlink" title="1 if"></a>1 if</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;c:if test=&quot;&quot;&gt;&lt;/c:if&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-choose"><a href="#2-choose" class="headerlink" title="2 choose"></a>2 choose</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;c:choose&gt;</span><br><span class="line">	&lt;c:when test=&quot;&quot;&gt;&lt;/c:when&gt;</span><br><span class="line">	&lt;c:when test=&quot;&quot;&gt;&lt;/c:when&gt;</span><br><span class="line">	...</span><br><span class="line">	&lt;c:otherwise&gt;&lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-迭代标签-forEach"><a href="#3-迭代标签-forEach" class="headerlink" title="3 迭代标签 forEach"></a>3 迭代标签 <code>forEach</code></h3><h4 id="1-普通循环"><a href="#1-普通循环" class="headerlink" title="1 普通循环"></a>1 普通循环</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;c:forEach var=&quot;&quot; begin=&quot;&quot; end=&quot;&quot; step=&quot;&quot; varStatus=&quot;vs&quot;&gt;&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-增强循环"><a href="#2-增强循环" class="headerlink" title="2 增强循环"></a>2 增强循环</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;c:forEach items=&quot;&quot; var=&quot;&quot; varStatus=&quot;vs&quot;&gt;&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-varStatus"><a href="#3-varStatus" class="headerlink" title="3 varStatus"></a>3 varStatus</h4><ol>
<li>指向一个对象，此对象记录着当前遍历元素的信息</li>
<li>通过 EL 可以获取当前遍历元素的信息</li>
</ol>
<table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>${vs.index}</code></td>
<td>获取当前元素索引，索引从 0 开始</td>
</tr>
<tr>
<td><code>${vs.count}</code></td>
<td>获取当前元素是第几个，计数从 1 开始</td>
</tr>
<tr>
<td><code>${vs.current}</code></td>
<td>获取当前元素</td>
</tr>
<tr>
<td><code>${vs.first}</code></td>
<td>判断当前元素是否是第一个</td>
</tr>
<tr>
<td><code>${vs.last}</code></td>
<td>判断当前元素是否是最后一个</td>
</tr>
</tbody></table>
<h1 id="七-域对象"><a href="#七-域对象" class="headerlink" title="七 域对象"></a>七 域对象</h1><table>
<thead>
<tr>
<th>域</th>
<th>对象</th>
<th>生命周期</th>
</tr>
</thead>
<tbody><tr>
<td><code>page</code></td>
<td><code>PageContext</code></td>
<td>当前页面</td>
</tr>
<tr>
<td><code>request</code></td>
<td><code>ServletRequest</code></td>
<td>一次请求</td>
</tr>
<tr>
<td><code>session</code></td>
<td><code>HttpSession</code></td>
<td>一次会话</td>
</tr>
<tr>
<td><code>application</code></td>
<td><code>ServletContext</code></td>
<td>整个应用</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CS</category>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/anyeansan.github.io/2020/11/08/JavaWeb/Servlet/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-JavaEE"><a href="#1-1-JavaEE" class="headerlink" title="1.1 JavaEE"></a>1.1 JavaEE</h2><ol>
<li>Java 企业版</li>
<li>SUN 公司提供的一套庞大类库，用于企业级开发，可以认为是平台或者规范</li>
<li>13 种技术规范<ol>
<li>Servlet</li>
<li>JSP：Java Server Pages</li>
<li>JDBC：Java Data Base Connectivity</li>
<li>XML：Extensible Markup Language</li>
<li>JNDI：Java Naming and Directory Interfaces</li>
<li>EJB：Enterprise Java Beans</li>
<li>RMI：Remote Method Invocation</li>
<li>Java IDL/CORBA：Java Interface Definiyion Language/Common Object Request  Broker Architecture</li>
<li>JMS：Java Message Service</li>
<li>JTA：Java Transaction API</li>
<li>JTS：Java Transaction Service</li>
<li>JavaMail</li>
<li>JAF：JavaBeans Activation Framework</li>
</ol>
</li>
</ol>
<h2 id="1-2-MVC"><a href="#1-2-MVC" class="headerlink" title="1.2 MVC"></a>1.2 MVC</h2><ol>
<li>MVC 是一种概念<ol>
<li><code>Model</code> <ul>
<li><code>&quot;什么&quot;</code></li>
<li>数据模型</li>
</ul>
</li>
<li><code>View</code> <ul>
<li><code>&quot;怎么显示什么</code></li>
<li>显示数据</li>
</ul>
</li>
<li><code>Controller</code> <ul>
<li><code>&quot;怎么操作什么&quot;</code></li>
<li>处理数据</li>
</ul>
</li>
</ol>
</li>
<li>三层架构是一种应用<ol>
<li>表现层</li>
<li>业务层</li>
<li>持久层</li>
</ol>
</li>
</ol>
<h2 id="1-3-Servlet"><a href="#1-3-Servlet" class="headerlink" title="1.3 Servlet"></a>1.3 Servlet</h2><ol>
<li>Server Applet，用 java 编写的运行在服务端的小程序，作为 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层</li>
<li>Servlet 必须运行在 Servlet 容器中（如 Tomcat…）</li>
<li>Servlet 对象是单例的（但不符合单例模式，单例模式构造方法是私有的），Tomcat 服务器支持多线程，所以 Servlet 是在单实例多线程的环境下运行的，如果 Servlet 中有实例变量，会存在线程安全问题，所以不建议使用实例变量</li>
<li>所有 Servlet 都要直接或间接实现 <code>javax.servlet.Servlet</code> 接口，所以 Servlet 本质就是一种规范，所有实现 Servlet 的类，或者说，所有想要处理网络请求的类，都需要回答这三个问题：<ul>
<li>你初始化时要做什么</li>
<li>你销毁时要做什么</li>
<li>你接受到请求时要做什么</li>
</ul>
</li>
<li>Web 服务器和 Servlet 容器<ol>
<li>Web 服务器的作用说穿了就是：将某个主机上的资源映射为一个URL供外界访问</li>
<li>通过 URL 访问 Web 服务器资源，通常有三个过程<ul>
<li>接收请求</li>
<li>处理请求</li>
<li>响应请求</li>
</ul>
</li>
<li>其中接收请求和响应请求是共性功能，可以抽取由 Web 服务器完成，而处理请求的逻辑各不相同，抽取出来做成Servlet，交给程序员自己编写</li>
<li>Servlet 容器：顾名思义即用来存放 Servlet 对象</li>
</ol>
</li>
<li>所以 Servlet 并不会直接和客户端打交道，而是由 Tomcat 监听端口，接收请求，然后根据 URL 等信息决定交给哪个 Servlet 处理，之后再由 Tomcat 响应请求</li>
</ol>
<h1 id="二-配置"><a href="#二-配置" class="headerlink" title="二 配置"></a>二 配置</h1><h2 id="2-1-映射规则"><a href="#2-1-映射规则" class="headerlink" title="2.1 映射规则"></a>2.1 映射规则</h2><table>
<thead>
<tr>
<th>优先级（高 →低）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>/xxx/xx/x</code></td>
<td>绝对匹配</td>
</tr>
<tr>
<td><code>/*</code></td>
<td>所有</td>
</tr>
<tr>
<td><code>*.do</code></td>
<td>指定扩展名</td>
</tr>
<tr>
<td><code>/</code></td>
<td>除了 <code>.jsp</code> 之外的</td>
</tr>
</tbody></table>
<h3 id="和"><a href="#和" class="headerlink" title="/ 和 /*"></a><code>/</code> 和 <code>/*</code></h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>jsp<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.jasper.servlet.JspServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>jsp<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jspx<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>上述为 tomcat 的 <code>web.xml</code> 中的配置，可以看到服务器中的所有资源（包括静态）都会经过 Servlet<ol>
<li><code>.jsp</code> 外的资源有匹配则走匹配，没有匹配的 Servlet 则会走默认的 <code>DefaultServlet</code></li>
<li><code>.jsp</code> 会走 <code>JspServlet</code></li>
</ol>
</li>
<li>如果自定义 Servlet 的映射设置为 <code>/</code>，会覆盖默认设置，则结果是<ol>
<li><code>.jsp</code> 外的资源有匹配则走匹配，没有匹配的 Servlet 则会走此自定义 Servlet</li>
<li><code>.jsp</code> 会走 <code>JspServlet</code></li>
</ol>
</li>
<li>如果自定义 <code>servlet</code> 的映射设置为 <code>/*</code>，由于 <code>/*</code> 优先级高于 <code>*.jsp</code> 和 <code>/</code>，则结果是<ul>
<li>所有资源如果没有匹配的 Servlet 则都会走此自定义 Servlet</li>
</ul>
</li>
</ol>
<h2 id="3-2-xml-配置：web-xml"><a href="#3-2-xml-配置：web-xml" class="headerlink" title="3.2 xml 配置：web.xml"></a>3.2 xml 配置：<code>web.xml</code></h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span><span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span><span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span><span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;url-pattern&gt; 可以写多个 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span><span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-注解配置：-WebServlet"><a href="#3-3-注解配置：-WebServlet" class="headerlink" title="3.3 注解配置：@WebServlet"></a>3.3 注解配置：<code>@WebServlet</code></h2><ul>
<li><code>@WebServlet</code> 注解用在类或接口上，仅在运行阶段生效</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>等价于</th>
</tr>
</thead>
<tbody><tr>
<td><code>String name() default &quot;&quot;</code></td>
<td><code>servlet</code> 名称</td>
<td><code>&lt;Servlet-name&gt;</code></td>
</tr>
<tr>
<td><code>String[] urlPatterns() default {}</code></td>
<td>映射 url</td>
<td><code>&lt;url-pattern&gt;</code></td>
</tr>
<tr>
<td><code>String[] value() default {}</code></td>
<td>同 <code>urlPatterns()</code></td>
<td><code>&lt;url-pattern&gt;</code></td>
</tr>
<tr>
<td><code>int loadOnStartup() default -1</code></td>
<td>实例化顺序</td>
<td><code>&lt;load-on-startup&gt;</code></td>
</tr>
<tr>
<td><code>WebInitParam[] initParams() default {}</code></td>
<td>初始化参数</td>
<td><code>&lt;init-param&gt;</code></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(name=<span class="string">""</span>, urlPatterns=&#123;<span class="string">""</span>, <span class="string">""</span>, ...&#125;)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 由于注解直接作用在类上，所以可以省略 name</span></span><br><span class="line"><span class="comment">2. value 等价于 urlPatterns，所以可以使用 value 代替 </span></span><br><span class="line"><span class="comment">3. 注解中只有一个属性且为 value 时可以省略属性名</span></span><br><span class="line"><span class="comment">4. 最终简化版</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">""</span>, <span class="string">""</span>, ...)</span><br></pre></td></tr></table></figure>

<h1 id="三-体系"><a href="#三-体系" class="headerlink" title="三 体系"></a>三 体系</h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/JavaWEB/Servlet%E4%BD%93%E7%B3%BB.png" alt=""></p>
<ul>
<li>每个 <code>Servlet</code> 都对应一个 <code>ServletConfig</code></li>
<li>所有 <code>Servlet</code> 共享一个 <code>ServletContext</code></li>
</ul>
<h2 id="3-1-Servlet"><a href="#3-1-Servlet" class="headerlink" title="3.1 Servlet"></a>3.1 Servlet</h2><h3 id="1-API"><a href="#1-API" class="headerlink" title="1 API"></a>1 API</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>init(ServletConfig config)</code></td>
<td>初始化</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>destroy()</code></td>
<td>销毁</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>service(ServletRequest req, ServletResponse res)</code></td>
<td>处理请求</td>
</tr>
<tr>
<td><code>ServletConfig</code></td>
<td><code>getServletConfig()</code></td>
<td>获取 <code>ServletConfig</code>（每个 Servlet 对应一个 ）</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getServletInfo()</code></td>
<td>获取 <code>servlet</code> 信息，如作者，版本，版权…</td>
</tr>
</tbody></table>
<h3 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2  生命周期"></a>2  生命周期</h3><table>
<thead>
<tr>
<th>阶段</th>
<th>方法</th>
<th>执行时机</th>
<th>执行次数</th>
</tr>
</thead>
<tbody><tr>
<td>1 实例化</td>
<td>构造函数</td>
<td>默认第一接收请求时</td>
<td>只执行一次</td>
</tr>
<tr>
<td>2 初始化</td>
<td><code>init(ServletConfig config)</code></td>
<td>默认第一接收请求时</td>
<td>只执行一次</td>
</tr>
<tr>
<td>3 处理请求</td>
<td><code>service(ServletRequest req, ServletResponse res)</code></td>
<td>接收请求时</td>
<td>每次请求都会执行</td>
</tr>
<tr>
<td>4 销毁</td>
<td><code>destroy()</code></td>
<td>关闭服务器</td>
<td>只执行一次</td>
</tr>
</tbody></table>
<ol>
<li><p>Servlet 的生命周期，包括其相关方法的调用，都是由 Web 容器来管理的，程序员无权干涉</p>
</li>
<li><p>配置 <code>web.xml</code> 或注解实现服务器一启动就实例化 <code>servlet</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Num &gt; 0，web 容器启动时实例化顺序是由小到大 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>Num<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="3-2-ServletConfig"><a href="#3-2-ServletConfig" class="headerlink" title="3.2 ServletConfig"></a>3.2 ServletConfig</h2><h3 id="1-API-1"><a href="#1-API-1" class="headerlink" title="1 API"></a>1 API</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ServletContext</code></td>
<td><code>getServletContext()</code></td>
<td>获取 <code>ServletContext</code>（所有 Servlet 共享一个）</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getInitParameter(String name)</code></td>
<td>获取 Servlet 初始化配置中指定键的值</td>
</tr>
<tr>
<td><code>Enumeration&lt;String&gt;</code></td>
<td><code>getInitParameterNames()</code></td>
<td>获取 Servlet 初始化配置所有键的枚举</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getServletName()</code></td>
<td>获取 Servlet 的名称</td>
</tr>
</tbody></table>
<h3 id="2-初始化配置"><a href="#2-初始化配置" class="headerlink" title="2 初始化配置"></a>2 初始化配置</h3><h4 id="1-web-xml-中"><a href="#1-web-xml-中" class="headerlink" title="1 web.xml 中"></a>1 <code>web.xml</code> 中</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servelt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span><span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span><span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servelt</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-注解中"><a href="#2-注解中" class="headerlink" title="2 注解中"></a>2 注解中</h4><h2 id="3-3-GenericServlet"><a href="#3-3-GenericServlet" class="headerlink" title="3.3 GenericServlet"></a>3.3 GenericServlet</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/JavaWEB/GenericServlet.jpg" alt=""></p>
<table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>init(ServletConfig config)</code></td>
<td>重写 Servlet 的 初始化方法，内部调用了 <code>init()</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>init()</code></td>
<td>特有方法，内容为空，可自定义一些初始化内容</td>
</tr>
</tbody></table>
<h2 id="3-4-HttpServlet"><a href="#3-4-HttpServlet" class="headerlink" title="3.4 HttpServlet"></a>3.4 HttpServlet</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>service(ServletRequest req, ServletResponse res)</code></td>
<td>重写 Servlet 的方法</td>
</tr>
<tr>
<td><code>protected void</code></td>
<td><code>service(HttpServletRequest req, HttpServletResponse resp)</code></td>
<td>特有方法</td>
</tr>
<tr>
<td><code>protected void</code></td>
<td><code>doXxx(HttpServletRequest req, HttpServletResponse resp)</code></td>
<td>处理 <code>GET POST PUT DELETE ...</code></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1 重写的 service() 方法，内部判断是否是 HTTP 请求，不是则抛异常，是则强转后调用特有的 service() 方法</span></span><br><span class="line"><span class="comment">* 2 特有的 service() 方法，内部根据请求方法的类型，调用对应的 doXxx() 方法</span></span><br><span class="line"><span class="comment">* 3 所以继承 HtttpServlet 的 Servlet 只需要重写 doXxx() 方法即可（模板方法设计模式）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    HttpServletRequest  request;</span><br><span class="line">    HttpServletResponse response;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        request = (HttpServletRequest) req;</span><br><span class="line">        response = (HttpServletResponse) res;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(lStrings.getString(<span class="string">"http.non_http"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    service(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-ServletContext"><a href="#3-5-ServletContext" class="headerlink" title="3.5 ServletContext"></a>3.5 ServletContext</h2><h3 id="1-API-2"><a href="#1-API-2" class="headerlink" title="1 API"></a>1 API</h3><h4 id="1-获取"><a href="#1-获取" class="headerlink" title="1 获取"></a>1 获取</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>getInitParameter(String name)</code></td>
<td>获取全局配置中指定键的值</td>
</tr>
<tr>
<td><code>Enumeration&lt;String&gt;</code></td>
<td><code>getInitParameterNames()</code></td>
<td>获取全局配置所有键的枚举</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getRealPath(String path)</code></td>
<td>获取资源的绝对路径，<code>path</code> 要以 <code>/</code> 开头</td>
</tr>
<tr>
<td><code>RequestDispatcher</code></td>
<td><code>getRequestDispatcher(String path)</code></td>
<td>获取 <code>RequestDispatcher</code>，<code>path</code> 为要转发到的请求路径</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getMimeType(String file)</code></td>
<td>获取文件的 MIME 类型</td>
</tr>
</tbody></table>
<h4 id="2-域对象"><a href="#2-域对象" class="headerlink" title="2 域对象"></a>2 域对象</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object</code></td>
<td><code>getAttribute(String name)</code></td>
<td>获取 <code>ServletContext</code> 域中指定键的值</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setAttribute(String name, Object obj)</code></td>
<td>添加或修改 <code>ServletContext</code> 域中指定键的键值对</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeAttribute(String name)</code></td>
<td>移除 <code>ServletContext</code> 域中指定键的键值对</td>
</tr>
</tbody></table>
<h3 id="2-全局配置：web-xml-中"><a href="#2-全局配置：web-xml-中" class="headerlink" title="2 全局配置：web.xml 中"></a>2 全局配置：<code>web.xml</code> 中</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span><span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span><span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-6-RequestDispatcher"><a href="#3-6-RequestDispatcher" class="headerlink" title="3.6 RequestDispatcher"></a>3.6 RequestDispatcher</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>forward(ServletRequest req, ServletResponse res)</code></td>
<td>请求转发</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>include(ServletRequest req, ServletResponse res)</code></td>
<td>请求包含</td>
</tr>
</tbody></table>
<h2 id="3-7-HttpServletRequest"><a href="#3-7-HttpServletRequest" class="headerlink" title="3.7 HttpServletRequest"></a>3.7 HttpServletRequest</h2><h3 id="1-请求信息"><a href="#1-请求信息" class="headerlink" title="1 请求信息"></a>1 请求信息</h3><h4 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1 请求行"></a>1 请求行</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><strong><code>getContextPath()</code></strong></td>
<td>获取 webapp 根路径，<code>ROOT</code> 为 <code>&quot;&quot;</code></td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getServletPath()</code></td>
<td>获取 Servlet 路径，<code>&lt;url-pattern&gt;</code> 配置的路径</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getMethod()</code></td>
<td>获取请求方法名</td>
</tr>
<tr>
<td><code>StringBuffer</code></td>
<td><code>getRequestURL()</code></td>
<td>获取请求 URL</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getRequestURI()</code></td>
<td>获取请求 URI</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getQueryString()</code></td>
<td>获取请求 URL 中的请求参数</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getProtocol()</code></td>
<td>获取协议</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getRemoteAddr()</code></td>
<td>获取请求客户端的 IP</td>
</tr>
</tbody></table>
<h4 id="2-请求头"><a href="#2-请求头" class="headerlink" title="2 请求头"></a>2 请求头</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>getHeader(String name)</code></td>
<td>获取请求头中指定键的值</td>
</tr>
<tr>
<td><code>Enumeration&lt;String&gt;</code></td>
<td><code>getHeaderNames()</code></td>
<td>获取请求头所有键的枚举</td>
</tr>
</tbody></table>
<h4 id="3-请求体"><a href="#3-请求体" class="headerlink" title="3 请求体"></a>3 请求体</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>BufferedReader</code></td>
<td><code>getReader()</code></td>
<td>获取字符输入流</td>
</tr>
<tr>
<td><code>ServletInputStream</code></td>
<td><code>getInputStream()</code></td>
<td>获取字节输入流</td>
</tr>
</tbody></table>
<h3 id="2-请求参数"><a href="#2-请求参数" class="headerlink" title="2 请求参数"></a>2 请求参数</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><strong><code>getParameter(String name)</code></strong></td>
<td>获取请求参数中指定键的值</td>
</tr>
<tr>
<td><code>String[]</code></td>
<td><code>getParameterValues(String name)</code></td>
<td>获取请求参数中指定键的值的数组</td>
</tr>
<tr>
<td><code>Map&lt;String,String[]&gt;</code></td>
<td><code>getParameterMap()</code></td>
<td>获取请求参数的所有键值<code>map</code></td>
</tr>
<tr>
<td><code>Enumeration&lt;String&gt;</code></td>
<td><code>getParameterNames()</code></td>
<td>获取请求参数所有键的枚举</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setCharacterEncoding(String env)</code></td>
<td>获取请求参数前进行设置，告诉服务器用什么编码接收请求参数（只对 POST 有效）</td>
</tr>
</tbody></table>
<h4 id="请求参数乱码问题"><a href="#请求参数乱码问题" class="headerlink" title="* 请求参数乱码问题"></a>* 请求参数乱码问题</h4><ol>
<li><p>不管哪个国家的文字，在浏览器发给服务器时，都采用 <code>ISO-8859-1</code> 编码，Tomcat 服务器默认编码和解码为 <code>iso-8859-1</code>，可通过 <code>CATALINA_HOME/conf/server.xml</code> 修改</p>
</li>
<li><p>客户端编码为 <code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code> ，默认解码为 <code>GBK</code></p>
</li>
<li><p>解决请求乱码</p>
<ol>
<li><p><code>POST</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在获取参数前，设置解码与客户端编码一致即可 </span></span><br><span class="line">request.setCharacterEncoding(<span class="string">"UTF-8"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>GET</code> 和 <code>POST</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.1 获取请求参数，获取的是由服务器默认 `iso-8859-1` 解码的参数</span></span><br><span class="line">String name = request.getParameter(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">// 1.2 使用 `iso-8859-1` 编码，获取原始数据</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = name.getBytes(<span class="string">"iso-8859-1"</span>);</span><br><span class="line"><span class="comment">// 1.3 使用与客户端编码（假如是 utf-8）一致的码表解码即可</span></span><br><span class="line">name = <span class="keyword">new</span> String(bytes, <span class="string">"utf-8"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>GET</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 修改 tomcat 的 server.xml 配置 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">URIEncoding</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<h3 id="3-获取"><a href="#3-获取" class="headerlink" title="3 获取"></a>3 获取</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>RequestDispatcher</code></td>
<td><code>getRequestDispatcher(String path)</code></td>
<td>获取 <code>RequestDispatcher</code>，<code>path</code> 为要转发到的请求路径</td>
</tr>
<tr>
<td><code>ServletContext</code></td>
<td><code>getServletContext()</code></td>
<td>获取 <code>ServletContext</code></td>
</tr>
<tr>
<td><code>Cookie[]</code></td>
<td><code>getCookies()</code></td>
<td>获取 <code>Cookie</code></td>
</tr>
<tr>
<td><code>HttpSession</code></td>
<td><code>getSession()</code></td>
<td>获取或创建 <code>Session</code></td>
</tr>
</tbody></table>
<h3 id="4-域对象"><a href="#4-域对象" class="headerlink" title="4 域对象"></a>4 域对象</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object</code></td>
<td><code>getAttribute(String name)</code></td>
<td>获取 <code>request</code> 域中指定键的值</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setAttribute(String name, Object obj)</code></td>
<td>添加或修改 <code>request</code> 域中指定键的键值对</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>removeAttribute(String name)</code></td>
<td>移除 <code>request</code> 域中指定键的键值对</td>
</tr>
</tbody></table>
<h2 id="3-8-HttpServletResponse"><a href="#3-8-HttpServletResponse" class="headerlink" title="3.8 HttpServletResponse"></a>3.8 HttpServletResponse</h2><h3 id="1-响应信息"><a href="#1-响应信息" class="headerlink" title="1 响应信息"></a>1 响应信息</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>setStatus(int sc)</code></td>
<td>设置响应状态码</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setHeader(String name, String value)</code></td>
<td>设置响应头</td>
</tr>
<tr>
<td>`void</td>
<td><code>setChracterEncoding(String charset)</code></td>
<td>设置响应数据编码</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setContentType(String type)</code></td>
<td>设置响应数据 MIME 类型及编码</td>
</tr>
<tr>
<td><code>PrintWriter</code></td>
<td><code>getWriter()</code></td>
<td>获取字符输出流</td>
</tr>
<tr>
<td><code>ServletOutputStream</code></td>
<td><code>getOutputStream()</code></td>
<td>获取字节输出流</td>
</tr>
</tbody></table>
<h4 id="响应乱码"><a href="#响应乱码" class="headerlink" title="* 响应乱码"></a>* 响应乱码</h4><ol>
<li><p>响应乱码原因</p>
<ol>
<li>响应流不是我们自己创建的，而是由 tomcat 获取的，默认码表是<code>iso-8859-1</code></li>
<li>浏览器解码的码表不确定，可能与响应数据码表不一致</li>
</ol>
</li>
<li><p>解决乱码原则</p>
<ol>
<li>设置响应数据的编码</li>
<li>设置浏览器解码与响应数据编码一致</li>
</ol>
</li>
<li><p>编码设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 设置响应数据类型及浏览编码方式</span></span><br><span class="line">response.setheader(<span class="string">"content-type"</span>,<span class="string">"text/html;charset=utf-8"</span>)</span><br><span class="line"><span class="comment">// 2. 设置响应数据编码方式</span></span><br><span class="line">response.setChracterEncoding(<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="comment">// 3. 简化以上两步</span></span><br><span class="line">response.setContentType(<span class="string">"text/html;charset=utf-8"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-重定向"><a href="#2-重定向" class="headerlink" title="2 重定向"></a>2 重定向</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>sendRedirect(String location)</code></td>
<td>重定向，<code>location</code> 要加项目名</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 设置状态码，告诉客户端需要重定向</span></span><br><span class="line">response.setStatus(<span class="number">302</span>)</span><br><span class="line"><span class="comment">// 2. 告诉客户端重定向的地址</span></span><br><span class="line">response.setHeander(<span class="string">"location"</span>, String location)</span><br><span class="line"><span class="comment">// 3. 简化以上两步</span></span><br><span class="line">response.sendRedirect(String location)</span><br></pre></td></tr></table></figure>

<h3 id="3-Cookie"><a href="#3-Cookie" class="headerlink" title="3 Cookie"></a>3 Cookie</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>addCookie(Cookie cookie)</code></td>
<td>将 cookie 响应给客户端</td>
</tr>
</tbody></table>
<h1 id="四-转发-amp-重定向"><a href="#四-转发-amp-重定向" class="headerlink" title="四 转发 &amp; 重定向"></a>四 转发 &amp; 重定向</h1><h2 id="4-1-对比"><a href="#4-1-对比" class="headerlink" title="4.1 对比"></a>4.1 对比</h2><table>
<thead>
<tr>
<th>转发</th>
<th>重定向</th>
</tr>
</thead>
<tbody><tr>
<td><code>request</code> 转发</td>
<td><code>response</code> 重定向</td>
</tr>
<tr>
<td>一次请求</td>
<td>二次请求</td>
</tr>
<tr>
<td>浏览器地址栏不变</td>
<td>浏览器地址栏改变</td>
</tr>
<tr>
<td>只能访问当前应用下的资源</td>
<td>可以访问其它站点下的资源</td>
</tr>
</tbody></table>
<ul>
<li>注：重定向或者转发后，后边的代码还会执行，但通常不会写</li>
<li>重定向可以解决浏览器刷新问题</li>
</ul>
<h2 id="4-2-路径"><a href="#4-2-路径" class="headerlink" title="4.2 路径"></a>4.2 路径</h2><ul>
<li>以 <code>/</code> 开头的叫做绝对路径<ol>
<li>由服务器解析，代表当前项目路径 <code>http://localhost:8080/应用名</code><ol>
<li><code>web.xml</code> 中的 <code>/</code> 路径</li>
<li>转发中的 <code>/</code> 路径</li>
<li><code>servletContext.getRealPath(&quot;/&quot;)</code></li>
</ol>
</li>
<li>由客户端解析，代表当前服务器路径 <code>http://localhost:8080</code>，也就是需要手动添加项目名<ol>
<li><code>html</code> 中的 <code>/</code> 路径</li>
<li>重定向中的 <code>/</code> 路径</li>
<li><code>&lt;form action=&quot;/&quot;&gt;</code> </li>
</ol>
</li>
</ol>
</li>
</ul>
<h1 id="五-web-xml"><a href="#五-web-xml" class="headerlink" title="五 web.xml"></a>五 <code>web.xml</code></h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol>
<li>全局配置：<code>CATALINA_HOMT/conf/web.xml</code></li>
<li>局部配置：<code>CATALINA_HOME/webapps/webapp/WEB-INF/web.xml</code></li>
</ol>
<h2 id="5-2-欢迎页面（首页）"><a href="#5-2-欢迎页面（首页）" class="headerlink" title="5.2 欢迎页面（首页）"></a>5.2 欢迎页面（首页）</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span><span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span><span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>如果不配置，则使用全局配置<ul>
<li><code>index.html</code></li>
<li><code>index.htm</code></li>
<li><code>index.jsp</code></li>
</ul>
</li>
<li>欢迎页面可以有多个，前边优先级高，前边找不到则向下查找</li>
<li>欢迎页面不一定是 HTML，可以是任意资源</li>
<li>路径不需要以 <code>/</code> 开头</li>
</ol>
<h2 id="5-3-错误页面"><a href="#5-3-错误页面" class="headerlink" title="5.3 错误页面"></a>5.3 错误页面</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CS</category>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>XML</title>
    <url>/anyeansan.github.io/2020/11/08/JavaWeb/XML/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li><code>Extensible Markup Language</code></li>
<li>可扩展标记语言</li>
<li>XML 中全部是自定义标签</li>
</ol>
<h1 id="二-语法"><a href="#二-语法" class="headerlink" title="二 语法"></a>二 语法</h1><h2 id="2-1-文档声明"><a href="#2-1-文档声明" class="headerlink" title="2.1 文档声明"></a>2.1 文档声明</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="默认iso-8859-1" ?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-规范"><a href="#2-2-规范" class="headerlink" title="2.2 规范"></a>2.2 规范</h2><ol>
<li><p>只有一个根元素</p>
</li>
<li><p>元素正确闭合，嵌套</p>
</li>
<li><p>元素名区分大小写，不能以数字开头</p>
</li>
<li><p>属性值必须用引号<code>&#39;&#39;</code>或<code>&quot;&quot;</code></p>
</li>
<li><p>注释<code>&lt;!-- --&gt;</code></p>
</li>
</ol>
<h2 id="2-3-原样输出数据"><a href="#2-3-原样输出数据" class="headerlink" title="2.3 原样输出数据"></a>2.3 原样输出数据</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;![CDATA[要输出的数据]]&gt;</span><br></pre></td></tr></table></figure>

<h1 id="三-约束"><a href="#三-约束" class="headerlink" title="三 约束"></a>三 约束</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol>
<li>约束就是 xml 的书写规则</li>
<li>根元素是什么，可以写哪些标签，有哪些属性，顺序….</li>
</ol>
<h2 id="3-2-分类"><a href="#3-2-分类" class="headerlink" title="3.2 分类"></a>3.2 分类</h2><h3 id="1-dtd-约束"><a href="#1-dtd-约束" class="headerlink" title="1 dtd 约束"></a>1 dtd 约束</h3><ol>
<li><p>内部 dtd：将约束规则定义在 xml 文档中</p>
</li>
<li><p>外部 dtd：将约束的规则定义在外部的 dtd 文件中</p>
<ul>
<li><p>本地 <code>dtd</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE 根标签名 SYSTEM "dtd文件位置"&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>网络 <code>dtd</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE 根标签名 PUBLIC "名称空间(dtd文件名)" "dtd文件位置"&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="2-schema-约束"><a href="#2-schema-约束" class="headerlink" title="2 schema 约束"></a>2 schema 约束</h3><ol>
<li><p>引入实例名称空间， <code>xsi</code> 前缀</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br></pre></td></tr></table></figure>
</li>
<li><p>引入名称空间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xsi:schemaLocation="xsd地址"</span><br><span class="line">// 如果不声明别名，使用标签格式：<span class="tag">&lt;<span class="name">地址值:标签名</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>命名空间声明：为每一个名称空间设置别名</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">1. 默认</span><br><span class="line">xmlns="..."</span><br><span class="line">2. 别名</span><br><span class="line">xmlns:别名="..."</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="四-解析"><a href="#四-解析" class="headerlink" title="四 解析"></a>四 解析</h1><h2 id="4-1-解析方式"><a href="#4-1-解析方式" class="headerlink" title="4.1 解析方式"></a>4.1 解析方式</h2><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>DOM</code></td>
<td>将文档加载进内存形成 DOM 树，可以增删改查，但占内存，解析速度慢</td>
</tr>
<tr>
<td><code>SAX</code></td>
<td>逐行读取，基于事件驱动，不占内存，解析速度快，只能往下读，不能写</td>
</tr>
</tbody></table>
<h2 id="4-2-解析器"><a href="#4-2-解析器" class="headerlink" title="4.2 解析器"></a>4.2 解析器</h2><table>
<thead>
<tr>
<th>解析器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>JAXP</code></td>
<td>sun 公司提供的解析，支持 <code>dom</code> 和 <code>sax</code></td>
</tr>
<tr>
<td><code>PULL</code></td>
<td>android 内置的解析器，<code>sax</code> 方式</td>
</tr>
<tr>
<td><code>DOM4J</code></td>
<td><code>dom for java</code>，民间方式，但好用，<code>dom</code> 方式</td>
</tr>
<tr>
<td><code>xpath</code></td>
<td>XML 路径语言，它是一种用来确定 XML 文档中某部分位置的语言，专门用于查询</td>
</tr>
<tr>
<td><code>Jsoup</code></td>
<td>可以解析 <code>html</code> 或 <code>xml</code></td>
</tr>
</tbody></table>
<h3 id="1-DOM4J"><a href="#1-DOM4J" class="headerlink" title="1 DOM4J"></a>1 DOM4J</h3><ol>
<li><p>导入 <code>dom4j.jar</code></p>
</li>
<li><p>创建解析器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SAXReader reader = new SAXReader();</span><br></pre></td></tr></table></figure>
</li>
<li><p>解析 <code>xml</code> 获得 <code>document</code> 对象 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Document document = reader.read(url);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-Jsoup"><a href="#2-Jsoup" class="headerlink" title="2 Jsoup"></a>2 Jsoup</h3><table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Jsoup</code></td>
<td>工具类，可以解析 <code>html</code> 或 <code>xml</code> 文档，返回 <code>Document</code> 对象</td>
</tr>
<tr>
<td><code>Document</code></td>
<td>文档对象，继承 <code>Element</code></td>
</tr>
<tr>
<td><code>Element</code></td>
<td>元素对象，继承 <code>Node</code></td>
</tr>
<tr>
<td><code>Elements</code></td>
<td>元素集合</td>
</tr>
<tr>
<td><code>Node</code></td>
<td>节点对象</td>
</tr>
</tbody></table>
<h4 id="1-Jsoup"><a href="#1-Jsoup" class="headerlink" title="1 Jsoup"></a>1 Jsoup</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Document parse(File file, String character)</code></td>
<td>解析 <code>html</code> 或  <code>xml</code>文件</td>
</tr>
<tr>
<td><code>static Document parse(String html)</code></td>
<td>解析 <code>html</code> 或  <code>xml</code> 字符串</td>
</tr>
<tr>
<td><code>static Document parse(Url url, int timoutMillis)</code></td>
<td>解析网络上的 <code>html</code> 或 <code>xml</code></td>
</tr>
</tbody></table>
<h4 id="2-Document"><a href="#2-Document" class="headerlink" title="2 Document"></a>2 Document</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Element getElementById(String id)</code></td>
<td>根据 id 获取元素对象</td>
</tr>
<tr>
<td><code>Elements getElementsByClass(String className)</code></td>
<td>根据 class 获取元素对象集合</td>
</tr>
<tr>
<td><code>Elements getElementsByTag(String tagName)</code></td>
<td>根据标签名获取元素对象集合</td>
</tr>
<tr>
<td><code>Elements getElementsByAttribute(String key)</code></td>
<td>根据属性名获取元素对象集合</td>
</tr>
<tr>
<td><code>Elements getElementsByAttribute(String key, String value)</code></td>
<td>根据属性名和值获取元素对象集合</td>
</tr>
</tbody></table>
<h3 id="3-Element"><a href="#3-Element" class="headerlink" title="3 Element"></a>3 Element</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String attr(String key)</code></td>
<td>根据属性名获取值</td>
</tr>
<tr>
<td><code>String text()</code></td>
<td>获取标签体文本内容</td>
</tr>
<tr>
<td><code>String html()</code></td>
<td>获取标签体所有内容</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CS</category>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>服务器</title>
    <url>/anyeansan.github.io/2020/11/08/JavaWeb/%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-服务器分类"><a href="#1-1-服务器分类" class="headerlink" title="1.1 服务器分类"></a>1.1 服务器分类</h2><table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
<th>例</th>
</tr>
</thead>
<tbody><tr>
<td>WEB 服务器 <code>HTTP Server</code></td>
<td>解析静态资源</td>
<td><code>apache, nginx, ...</code></td>
</tr>
<tr>
<td>应用服务器 <code>Application Server</code></td>
<td>解析静态资源和动态资源</td>
<td><code>tomcat, jetty, weblogic, ...</code></td>
</tr>
</tbody></table>
<h2 id="1-2-前后端分离"><a href="#1-2-前后端分离" class="headerlink" title="1.2 前后端分离"></a>1.2 前后端分离</h2><h3 id="1-Servlet"><a href="#1-Servlet" class="headerlink" title="1 Servlet"></a>1 Servlet</h3><ol>
<li><code>Servlet</code> 即负责业务逻辑又负责页面展示</li>
<li><code>Servlet</code> 页面展示要多痛苦有多痛苦：通过代码将数据和 <code>HTML</code> 响应给客户端</li>
</ol>
<h3 id="2-JSP"><a href="#2-JSP" class="headerlink" title="2 JSP"></a>2 JSP</h3><ol>
<li><code>JSP</code> 即负责业务逻辑又负责页面展示</li>
<li><code>JSP</code> 即能写 java 代码又能使用标签，但会造成 <code>JSP</code> 庞大而混乱</li>
</ol>
<h3 id="3-Servlet-JSP"><a href="#3-Servlet-JSP" class="headerlink" title="3 Servlet + JSP"></a>3 Servlet + JSP</h3><ol>
<li><code>Servlet</code> 负责业务逻辑，<code>JSP</code> 负责页面展示 </li>
<li><code>Servlet</code> 将响应数据存在域对象中，<code>JSP</code> 也是 <code>Servlet</code> ，可以从域中获取响应数据</li>
<li>问题：<ol>
<li><code>JSP</code> 要获取数据还是要在 <code>&lt;% %&gt;</code>  中写 java 代码，于是出现了 <code>EL 表达式</code> 用于获取数据</li>
<li>一些复杂的展示逻辑如循环，判断，也需要在 <code>&lt;% %&gt;</code>  中写 java 代码，于是出现了 <code>JSTL</code> 用于页面展示逻辑</li>
</ol>
</li>
<li>最终就是 <code>Servlet + JSP + EL + JSTL</code></li>
</ol>
<h3 id="4-Servlet-HTML-AJAX-JSON-JS"><a href="#4-Servlet-HTML-AJAX-JSON-JS" class="headerlink" title="4 Servlet + HTML + AJAX + JSON + JS"></a>4 Servlet + HTML + AJAX + JSON + JS</h3><ol>
<li><code>Servlet</code> 负责业务逻辑</li>
<li><code>AJAX</code> 负责请求动态数据，通常是 <code>JSON</code></li>
<li><code>JS</code> 负责 DOM，展示 <code>HTML</code></li>
</ol>
<h2 id="1-3-动静分离"><a href="#1-3-动静分离" class="headerlink" title="1.3 动静分离"></a>1.3 动静分离</h2><ol>
<li>静态资源部署在 <code>nginx</code> 服务器上，动态资源部署在 <code>tomcat</code> 应用服务器上</li>
<li>如果请求静态资源，则直接请求 <code>nginx</code></li>
<li>如果请求动态资源，则 <code>nginx</code> 利用 <strong>反向代理</strong> 将请求交给 <code>tomcat</code></li>
</ol>
<h1 id="二-JavaWeb项目"><a href="#二-JavaWeb项目" class="headerlink" title="二 JavaWeb项目"></a>二 JavaWeb项目</h1><h2 id="2-1-标准目录结构"><a href="#2-1-标准目录结构" class="headerlink" title="2.1 标准目录结构"></a>2.1 标准目录结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">部署项目名</span><br><span class="line">	资源文件（html、js、css、img ...）</span><br><span class="line">	WEB-INF</span><br><span class="line">		classes</span><br><span class="line">		lib</span><br><span class="line">		web.xml</span><br></pre></td></tr></table></figure>

<h2 id="2-2-源代码目录结构"><a href="#2-2-源代码目录结构" class="headerlink" title="2.2 源代码目录结构"></a>2.2 源代码目录结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 IDEA</span></span><br><span class="line">开发项目名</span><br><span class="line">    src</span><br><span class="line">    web</span><br><span class="line">        WEB-INF</span><br><span class="line">            classes</span><br><span class="line">            lib</span><br><span class="line">            web.xml</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 Eclipse</span></span><br><span class="line">开发项目名</span><br><span class="line">    src</span><br><span class="line">    WebContent</span><br><span class="line">        WEB-INF</span><br><span class="line">            classes</span><br><span class="line">            lib</span><br><span class="line">            web.xml</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 3 MyEclipse</span></span><br><span class="line">开发项目名</span><br><span class="line">    src</span><br><span class="line">    WebRoot    </span><br><span class="line">        WEB-INF</span><br><span class="line">            classes</span><br><span class="line">            lib</span><br><span class="line">            web.xml</span><br></pre></td></tr></table></figure>

<ol>
<li><code>src</code> 目录下的文件，编译后放在  <code>/WEB-INF/classes</code> 下</li>
<li><code>web/WebContent/WebRoot</code> 就相当于标准目录结构</li>
</ol>
<h1 id="二-Tomcat"><a href="#二-Tomcat" class="headerlink" title="二 Tomcat"></a>二 Tomcat</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol>
<li>服务器接收客户端请求封装 <code>HttpServletRequest</code> 对象，并传递给 web 应用</li>
<li>web 应用处理请求</li>
<li>服务器将处理结果封装到 <code>HttpServletResponse</code> 对象，响应给客户端</li>
</ol>
<h2 id="2-2-Tomcat-目录结构"><a href="#2-2-Tomcat-目录结构" class="headerlink" title="2.2 Tomcat 目录结构"></a>2.2 Tomcat 目录结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── bin</span><br><span class="line">│   ├── startup.sh </span><br><span class="line">│   ├── shutdown.sh</span><br><span class="line">│   ├── catalina.sh # Tomcat核心管理脚本</span><br><span class="line">│   └── version.sh # Tomcat版本信息脚本</span><br><span class="line">├── conf </span><br><span class="line">│   ├── Catalina</span><br><span class="line">│   ├── context.xml</span><br><span class="line">│   ├── server.xml</span><br><span class="line">│   ├── web.xml</span><br><span class="line">│   └── tomcat-users.xml # Tomcat管理用户配置文件</span><br><span class="line">├── logs</span><br><span class="line">│   ├── catalina.out # 启动信息日志</span><br><span class="line">│   └── localhost_access_log.2020-03-25.txt # 访问日志</span><br><span class="line">├── lib # 存放web应用能访问的JAR包</span><br><span class="line">├── webapps # Web应用程序根目录</span><br><span class="line">└── work # 编译目录</span><br></pre></td></tr></table></figure>

<ol>
<li><code>bin</code> 和 <code>lib</code> 目录可以被多个 Tomcat 实例共用</li>
<li><code>conf</code>、<code>logs</code>、<code>temp</code>、<code>webapps</code> 和 <code>work</code> 目录每个 Tomcat 实例必须拥有自己独立的一份</li>
</ol>
<h2 id="2-3-Tomcat-管理"><a href="#2-3-Tomcat-管理" class="headerlink" title="2.3 Tomcat 管理"></a>2.3 Tomcat 管理</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>Tomcat 管理功能用于对 Tomcat 自身以及部署在 Tomcat 的应用进行管理</li>
<li>测试用，生产环境禁用（默认禁止）</li>
<li>开启管理功能需要配置管理用户</li>
</ol>
<h3 id="2-配置管理用户"><a href="#2-配置管理用户" class="headerlink" title="2 配置管理用户"></a>2 配置管理用户</h3><ul>
<li><code>basedir/conf/tomcat-users.xml</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;tomcat-users xmlns=&quot;http://tomcat.apache.org/xml&quot;</span><br><span class="line">              xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">              xsi:schemaLocation=&quot;http://tomcat.apache.org/xml tomcat-users.xsd&quot;</span><br><span class="line">              version=&quot;1.0&quot;&gt;</span><br><span class="line"># 配置角色</span><br><span class="line">&lt;role rolename=&quot;manager-gui&quot;/&gt;</span><br><span class="line">&lt;role rolename=&quot;admin-gui&quot;/&gt;</span><br><span class="line">&lt;role rolename=&quot;host-gui&quot;/&gt;</span><br><span class="line"># 配置用户和密码并分配角色</span><br><span class="line">&lt;user username=&quot;&quot; password=&quot;&quot; roles=&quot;manager-gui,admin-gui,host-gui&quot;/&gt;</span><br><span class="line">&lt;/tomcat-users&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-允许访问"><a href="#3-允许访问" class="headerlink" title="3 允许访问"></a>3 允许访问</h3><ul>
<li><code>basedir/webapps/[host-]manager/META-INF/context.xml</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Context antiResourceLocking=&quot;false&quot; privileged=&quot;true&quot; &gt;</span><br><span class="line">	# allow：允许指定 ip 和 端口</span><br><span class="line">	&lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot;</span><br><span class="line">         allow=&quot;127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1&quot; /&gt;</span><br><span class="line">&lt;/Context&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-配置文件"><a href="#2-4-配置文件" class="headerlink" title="2.4 配置文件"></a>2.4 配置文件</h2><h3 id="1-web-xml"><a href="#1-web-xml" class="headerlink" title="1 web.xml"></a>1 <code>web.xml</code></h3><ol>
<li>Web 应用程序描述文件，都是关于是 Web 应用程序的配置文件</li>
<li>所有 Web 应用的 <code>web.xml</code> 文件的父文件</li>
</ol>
<h3 id="2-context-xml"><a href="#2-context-xml" class="headerlink" title="2 context.xml"></a>2 <code>context.xml</code></h3><ol>
<li>Tomcat 公用的环境配置，tomcat 服务器会定时去扫描这个文件</li>
<li>一旦发现文件被修改（时间戳改变了），就会自动重新加载这个文件，而不需要重启服务器</li>
</ol>
<h3 id="3-server-xml"><a href="#3-server-xml" class="headerlink" title="3 server.xml"></a>3 <code>server.xml</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</span><br><span class="line">	&lt;Service name=&quot;Catalina&quot;&gt;</span><br><span class="line">		&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;</span><br><span class="line">		&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</span><br><span class="line">		&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;</span><br><span class="line">			&lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;</span><br><span class="line">				&lt;Context/&gt;</span><br><span class="line">			&lt;/Host&gt;</span><br><span class="line">		&lt;/Engine&gt;</span><br><span class="line">	&lt;/Service&gt;</span><br><span class="line">&lt;/Server&gt;</span><br></pre></td></tr></table></figure>

<h4 id="1-lt-Server-gt"><a href="#1-lt-Server-gt" class="headerlink" title="1 &lt;Server&gt;"></a>1 <code>&lt;Server&gt;</code></h4><ol>
<li><p>顶层元素，表示一个运行于JVM中的 tomcat 实例</p>
</li>
<li><p>一个 Server 可以有多个 Service</p>
</li>
<li><p><code>&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</code></p>
<ul>
<li><p><code>port</code>：表示接收 shutdown 指令的端口号</p>
</li>
<li><p><code>shutdonw</code>：表示关闭此 Server 的指令</p>
</li>
</ul>
</li>
</ol>
<h4 id="2-lt-Service-gt"><a href="#2-lt-Service-gt" class="headerlink" title="2 &lt;Service&gt;"></a>2 <code>&lt;Service&gt;</code></h4><ol>
<li>将连接器 Connector 关联至引擎 Engine</li>
<li>一个 Service 可以有多个 Connector，但只能有一个 Engine</li>
</ol>
<h4 id="3-lt-Connector-gt"><a href="#3-lt-Connector-gt" class="headerlink" title="3 &lt;Connector&gt;"></a>3 <code>&lt;Connector&gt;</code></h4><ol>
<li><p>用于从客户端接收请求，之后将请求分配给引擎进行处理</p>
</li>
<li><p>HTTP 协议</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>表示客户端可以通过 8080 端口使用 HTTP 协议访问 tomcat</li>
<li><code>connectionTimeout</code>：超时时间</li>
<li><code>redirectPort</code>：表示当强制要求 https 而请求却是 http 时，重定向至端口号为 8443 的 Connector</li>
</ol>
</li>
<li><p>AJP协议</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>表示客户端可以通过 8009 端口使用 AJP 协议访问 tomcat</li>
<li>AJP 协议负责和其他的 Http 服务器（如Apache）建立连接，在把 Tomcat 与其他服务器集成时，就需要用到这个连接器（动静分离）</li>
</ol>
</li>
</ol>
<h4 id="4-lt-Engine-gt"><a href="#4-lt-Engine-gt" class="headerlink" title="4 &lt;Engine&gt;"></a>4 <code>&lt;Engine&gt;</code></h4><ol>
<li>用于从一个或多个 Connector 中接收请求，然后转至对应的虚拟主机 Host 处理请求，并将响应返回给 Connector，最终传递给客户端</li>
<li>一个 Engine 中可以有多个 Host</li>
<li><code>&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;</code><ul>
<li><code>name</code><ul>
<li>用于日志和错误信息，在整个 Server 中应该是唯一的</li>
</ul>
</li>
<li><code>defaultHost</code><ul>
<li>当发往本机的请求指定的 host 不存在时，一律使用 defaultHost 指定的 host 进行处理</li>
<li>因此，defaultHost 的值，必须与 Engine 中的一个 Host 组件的 name 属性值匹配</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="5-lt-Host-gt"><a href="#5-lt-Host-gt" class="headerlink" title="5 &lt;Host&gt;"></a>5 <code>&lt;Host&gt;</code></h4><ol>
<li>一个 Host 组件代表 Engine 中的一个虚拟主机</li>
<li>一个 Host 可以有多个 Context </li>
<li><code>&lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;</code><ul>
<li><code>name</code><ul>
<li>虚拟主机的主机名</li>
<li>一个 Engine 有且只有一个 Host 组件的 name 属性和 Engine 的 defaultHost 属性相匹配</li>
</ul>
</li>
<li><code>appBase</code><ul>
<li>Web 应用默认所在目录</li>
</ul>
</li>
<li><code>unpackWARS</code><ul>
<li>是否将代表 Web 应用的 WAR 文件解压</li>
<li><code>true</code><ul>
<li>通过解压后的文件结构运行该Web应用</li>
</ul>
</li>
<li><code>false</code><ul>
<li>直接使用WAR文件运行Web应用</li>
</ul>
</li>
</ul>
</li>
<li><code>autoDeploy</code><ul>
<li>是否自动部署</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="6-lt-Context-gt"><a href="#6-lt-Context-gt" class="headerlink" title="6 &lt;Context&gt;"></a>6 <code>&lt;Context&gt;</code></h4><ol>
<li>一个 Context 代表在虚拟主机上运行的一个Web应用</li>
<li><code>&lt;Context docBase=&quot;&quot; path=&quot;&quot; reloadable=&quot;&quot;/&gt;</code><ul>
<li><code>docBase</code><ol>
<li>指定了该Web应用使用的WAR包路径或应用目录</li>
<li>自动部署时<ol>
<li>如果 <code>docBase</code> 指定的WAR包或应用目录就在 <code>appBase</code> 中，不要指定 <code>docBase</code></li>
<li>否则，需要指定 <code>docBase</code></li>
</ol>
</li>
</ol>
</li>
<li><code>path</code><ol>
<li>指定了访问该Web应用的上下文路径，会与请求URI进行匹配</li>
<li><code>path=&quot;&quot;</code> 表示这个 Context 是虚拟主机的默认 Web 应用，当请求的URI与所有的path都不匹配时，使用该默认Web应用来处理</li>
<li>自动部署时<ol>
<li>如果没有XML配置文件且应用不在 <code>appBase</code> 下，则需要配置 <code>path</code></li>
<li>否则，不需配置 <code>path</code>，而是根据配置文件名、WAR文件名或应用目录名推导而出，例：<ol>
<li><code>xmlBase/test.xml</code> 则 <code>path=&quot;test&quot;</code></li>
<li><code>appBase/test.WAR</code> 则 <code>path=&quot;test&quot;</code></li>
<li><code>appBase/test/</code> 则 <code>path=&quot;test&quot;</code></li>
<li>如果上述文件名为 <code>ROOT</code> 则 <code>path=&quot;&quot;</code> </li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><code>reloadable</code><ul>
<li>指示 tomcat 是否在运行时监控 <code>WEB-INF/classes</code> 和 <code>WEB-INF/lib</code> 目录下变动</li>
<li><code>true</code><ul>
<li>当有变动时，会触发 Web 应用的重新加载</li>
<li>开发环境下，方便调试</li>
</ul>
</li>
<li><code>false</code><ul>
<li>默认，因为在生产环境中设置为 true 会给服务器带来性能压力</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="2-5-Tomcat-请求流程"><a href="#2-5-Tomcat-请求流程" class="headerlink" title="2.5 Tomcat 请求流程"></a>2.5 Tomcat 请求流程</h2><ol>
<li>请求此 Server </li>
<li>根据 Connector 配置协议和端口号选定 Service 和 Engine</li>
<li>根据域名和 IP 选定 Host</li>
<li>根据 URI 选定 Context/Web应用</li>
</ol>
<h2 id="2-6-Tomcat-部署应用"><a href="#2-6-Tomcat-部署应用" class="headerlink" title="2.6 Tomcat 部署应用"></a>2.6 Tomcat 部署应用</h2><h3 id="1-部署形式"><a href="#1-部署形式" class="headerlink" title="1 部署形式"></a>1 部署形式</h3><ol>
<li>应用目录</li>
<li>WAR包</li>
</ol>
<h3 id="2-部署方式"><a href="#2-部署方式" class="headerlink" title="2 部署方式"></a>2 部署方式</h3><h4 id="1-静态部署"><a href="#1-静态部署" class="headerlink" title="1 静态部署"></a>1 静态部署</h4><ol>
<li>在 <code>server.xml</code> 中通过 <code>&lt;context&gt;</code> 元素静态部署Web应用</li>
<li>不推荐静态部署，因为 <code>server.xml</code> 是不可动态重加载的资源，服务器一旦启动，要修改这个文件，就得重启服务器才能重新加载。</li>
<li>自动部署可以在 Tomcat 运行时通过定期的扫描来实现重新部署应用，不需要重启服务器</li>
</ol>
<h4 id="2-自动部署"><a href="#2-自动部署" class="headerlink" title="2 自动部署"></a>2 自动部署</h4><h5 id="1-开启自动部署"><a href="#1-开启自动部署" class="headerlink" title="1 开启自动部署"></a>1 开启自动部署</h5><ol>
<li>要开启自动部署，需要配置所在的虚拟主机，即 <code>server.xml</code> 中的 <code>&lt;Host&gt;</code></li>
<li><code>&lt;Host xmlBase=&quot;&quot; appBase=&quot;&quot; autoDeploy=&quot;true&quot; deployOnStartup=&quot;true&quot;</code><ul>
<li><code>xmlBase</code><ul>
<li>指定Web应用的XML配置文件所在的目录，默认值 <code>basedir/conf/&lt;engine_name&gt;/&lt;host_name&gt;</code></li>
</ul>
</li>
<li><code>appBase</code><ul>
<li>指定Web应用所在的目录，默认值 <code>webapps</code></li>
</ul>
</li>
<li><code>autoDeploy=&quot;true&quot;</code><ul>
<li>表示 Tomcat 在运行时定期检查新的Web应用或Web应用的更新</li>
</ul>
</li>
<li><code>deployOnStartup=&quot;true&quot;</code><ul>
<li>表示 Tomcat 在启动时检查Web应用，且将所有检测到的Web应用视作新应用</li>
</ul>
</li>
</ul>
</li>
<li>开启自动部署之后，通过检查 <code>xmlBase</code> 和 <code>appBase</code> 指定的目录是否有新的或更新的应用来实现自动部署，检查顺序<ol>
<li><code>xmlBase</code> 下的 XML 配置文件</li>
<li><code>appBase</code> 下的 WAR 文件</li>
<li><code>appBase</code> 下的应用目录</li>
</ol>
</li>
</ol>
<h5 id="2-自动部署实现方式"><a href="#2-自动部署实现方式" class="headerlink" title="2 自动部署实现方式"></a>2 自动部署实现方式</h5><ol>
<li>WAR 文件或应用目录直接添加到 tomcat 的 <code>appBase</code> 指定的目录下</li>
<li>WAR 文件或应用目录在别处，通过在 <code>basedir/conf/server.xml</code> 中配置 <code>Conctext</code> 指明应用路径<ul>
<li>由于要配置 <code>server.xml</code> ，所以重新部署需要重启</li>
</ul>
</li>
<li>WAR 文件或应用目录在别处，通过配置 <code>xmlBase</code> 下的 XML 配置文件指明应用路径<ul>
<li>重新部署不需要重启</li>
</ul>
</li>
</ol>
<h5 id="3-IDE-的自动部署"><a href="#3-IDE-的自动部署" class="headerlink" title="3 IDE 的自动部署"></a>3 IDE 的自动部署</h5><h6 id="1-MyEclipse"><a href="#1-MyEclipse" class="headerlink" title="1 MyEclipse"></a>1 MyEclipse</h6><ol>
<li>MyEclipse 使用方式一</li>
<li>直接将 WAR 文件或应用目录复制到 <code>basedir/webapps</code> 下</li>
<li>因为应用就在 <code>appBase</code> 中，所以不需要配置 <code>Context</code></li>
</ol>
<h6 id="2-Eclipse"><a href="#2-Eclipse" class="headerlink" title="2 Eclipse"></a>2 Eclipse</h6><ol>
<li><p>Eclipse 使用方式二</p>
</li>
<li><p>Eclipse 本质是在其 <code>workspace</code> 下映射了一个 tomcat 的镜像，每创建一个 tomcat，就生成文件名为 <code>tmp编号</code> 的 tomcat 镜像，Eclipse 通过这个镜像 tomcat 运行应用</p>
</li>
<li><p><code>Catalina_Base</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">workspace/.metadata/.plugins/org.eclipse.wst.server.core/tmp0/wtpwebapps</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>basedir/conf/server.xml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Host&gt;</span><br><span class="line">	&lt;Context docBase=&quot;应用的真实路径&quot; path=&quot;网络访问的虚拟路径名(自定义)&quot; /&gt;</span><br><span class="line">&lt;/Host&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h6 id="3-Intellij"><a href="#3-Intellij" class="headerlink" title="3 Intellij"></a>3 Intellij</h6><ol>
<li><p>Intellij 使用方式三</p>
</li>
<li><p>Intellij 在 <code>configdir/system/tomcat/</code> 创建了新的 tomcat 实例</p>
</li>
<li><p>部署应用时，会在 tomcat 实例的 <code>conf/catalina/localhost</code> 目录下自动创建 XML 配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Context docBase=&quot;应用的真实路径&quot; path=&quot;与 XML 配置文件名相同，其实不用配置&quot;/&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果部署时指定了应用名，如 <code>/test</code>，则 XML 配置文件名称为 <code>test.xml</code>，<code>paht=&quot;test&quot;</code></li>
<li>如果部署时省略了应用名，即 <code>/</code>，则 XML 配置文件名称为 <code>ROOT.xml</code>，<code>paht=&quot;&quot;</code></li>
</ol>
</li>
</ol>
<h2 id="2-7-Tomcat-启动-amp-访问"><a href="#2-7-Tomcat-启动-amp-访问" class="headerlink" title="2.7 Tomcat 启动 &amp; 访问"></a>2.7 Tomcat 启动 &amp; 访问</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><h4 id="1-CATALINA-HOME"><a href="#1-CATALINA-HOME" class="headerlink" title="1 CATALINA_HOME"></a>1 <code>CATALINA_HOME</code></h4><ol>
<li>是 Tomcat 的安装目录</li>
<li>指向公用信息的位置，就是 <code>bin</code> 和 <code>lib</code> 目录的父目录</li>
</ol>
<h4 id="2-CATALINA-BASE"><a href="#2-CATALINA-BASE" class="headerlink" title="2 CATALINA_BASE"></a>2 <code>CATALINA_BASE</code></h4><ol>
<li>是 Tomcat 的工作目录</li>
<li>指向每个 Tomcat 目录私有信息的位置，即 <code>conf、logs、temp、webapps</code> 和 <code>work</code> 目录的父目录</li>
<li>一个 <code>CATALINA_BASE</code> 就代表一个 Tomcat 实例 </li>
<li>如果 <code>CATALINA_BASE</code> 没有值的话，则默认值就是 <code>CATALINA_HOME</code></li>
</ol>
<h3 id="2-启动"><a href="#2-启动" class="headerlink" title="2 启动"></a>2 启动</h3><ol>
<li>执行 <code>startup.bat</code> ，其实最终是执行 <code>catalina.bat</code> </li>
<li>Tomcat 启动时，需要查找 <code>CATALINA_HOME</code> 这个环境变量，并判断是否为空<ol>
<li><code>CATALINA_HOME</code>  不为空，则根据值查找 <code>bin/catalina.bat</code> ，找到就执行，找不到报错</li>
<li><code>CATALINA_HOME</code>  为空<ol>
<li>就将当前目录设为 <code>CATALINA_HOME</code> 的值，接着判断当前目录下是否存在 <code>bin/catalina.bat</code></li>
<li>如果不存在，将当前目录的父目录设为 <code>CATALINA_HOME</code> 的值，继续判断 <code>bin/catalina.bat</code>，一直循环</li>
<li>最后如果找到就执行，找不到就报错</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="3-访问"><a href="#3-访问" class="headerlink" title="3 访问"></a>3 访问</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://ip:port/path/source</span><br></pre></td></tr></table></figure>

<ol>
<li><code>port</code> <ul>
<li>省略则访问 <code>80</code> 端口</li>
</ul>
</li>
<li><code>path</code> <ul>
<li>省略则访问 <code>ROOT</code></li>
</ul>
</li>
<li><code>source</code><ul>
<li>省略则访问首页</li>
</ul>
</li>
</ol>
<h1 id="三-Nginx"><a href="#三-Nginx" class="headerlink" title="三 Nginx"></a>三 Nginx</h1><h2 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h2><ol>
<li><p>配置官方yum源（官网查看）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/yum.repos.d/nginx.repo</span><br><span class="line"></span><br><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install nginx -y</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="3-2-目录结构"><a href="#3-2-目录结构" class="headerlink" title="3.2 目录结构"></a>3.2 目录结构</h2><table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>/etc/logrotate.d/nginx</code></td>
<td>实现nginx日志切割</td>
</tr>
<tr>
<td><code>/etc/nginx</code></td>
<td>配置文件所在目录</td>
</tr>
<tr>
<td><code>/var/log/nginx</code></td>
<td>日志目录</td>
</tr>
<tr>
<td><code>var/cache/nginx</code></td>
<td>缓存目录</td>
</tr>
<tr>
<td><code>/usr/sbin/nginx</code></td>
<td>命令文件</td>
</tr>
<tr>
<td><code>/usr/sbin/nginx-debug</code></td>
<td>debug命令文件</td>
</tr>
<tr>
<td><code>/usr/share/nginx/html</code></td>
<td>默认站点目录（图片 音视频 附件… ）</td>
</tr>
</tbody></table>
<h2 id="3-3-配置文件"><a href="#3-3-配置文件" class="headerlink" title="3.3 配置文件"></a>3.3 配置文件</h2><h3 id="1-etc-nginx-nginx-conf（主配置文件）"><a href="#1-etc-nginx-nginx-conf（主配置文件）" class="headerlink" title="1 /etc/nginx/nginx.conf（主配置文件）"></a>1 <code>/etc/nginx/nginx.conf</code>（主配置文件）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 基本配置</span><br><span class="line">user  nginx;  # 定义 worker_process 的管理用户，所有请求都会映射成此用户</span><br><span class="line">worker_processes  1; # 定义有几个worder_process（建议=cpu核数）</span><br><span class="line">error_log  /var/log/nginx/error.log warn; # 定义错误日志路径信息</span><br><span class="line">pid        /var/run/nginx.pid; # 定义pid文件路径信息</span><br><span class="line">2 事件区域配置</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024; # 1 个worker process可以同时接收1024访问请求</span><br><span class="line">&#125;</span><br><span class="line"># http区域配置</span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types; # 加载一个配置文件</span><br><span class="line">    default_type  application/octet-stream; # 指定默认识别文件类型</span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;  # 定义日志的格式</span><br><span class="line">    access_log  /var/log/nginx/access.log  main; # 指定日志路径（main 表示使用main定义的格式）</span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line">    keepalive_timeout  65; # 超时时间</span><br><span class="line">    #gzip  on;</span><br><span class="line">    include /etc/nginx/conf.d/*.conf; # 加载一个配置文件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Nginx 有两个进程<ol>
<li><code>master process</code><ul>
<li>管理服务是否正常运行</li>
</ul>
</li>
<li><code>worker process</code><ul>
<li>处理用户的访问请求</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="2-etc-nginx-conf-d-default-conf（扩展配置-默认虚拟主机配置文件-）"><a href="#2-etc-nginx-conf-d-default-conf（扩展配置-默认虚拟主机配置文件-）" class="headerlink" title="2 /etc/nginx/conf.d/default.conf（扩展配置(默认虚拟主机配置文件)）"></a>2 <code>/etc/nginx/conf.d/default.conf</code>（扩展配置(默认虚拟主机配置文件)）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 server区域信息（配置一个网站，即一个虚拟主机）</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80; # 监听端口</span><br><span class="line">    server_name  localhost; # 网站域名</span><br><span class="line">    location / &#123; # 表示匹配URI以 / 开头的请求</span><br><span class="line">        root   /usr/share/nginx/html; # 定义站点目录的位置</span><br><span class="line">        index  index.html index.htm; # 定义首页文件</span><br><span class="line">    &#125;</span><br><span class="line">    error_page   500 502 503 504  /50x.html; # 优雅显示错误页面信息</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-利用-Nginx-搭建网站"><a href="#3-4-利用-Nginx-搭建网站" class="headerlink" title="3.4 利用 Nginx 搭建网站"></a>3.4 利用 Nginx 搭建网站</h2><ol>
<li><p>创建虚拟主机配置文件 <code>/etc/nginx/conf.d/xxx.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       8090;</span><br><span class="line">    server_name  www.iisfive.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">一个端口可配置多个域名 www、blog、bbs...</span><br></pre></td></tr></table></figure>
</li>
<li><p>网站代码文件</p>
</li>
<li><p>DNS 配置</p>
<ol>
<li>真实域名，在域名网站配置</li>
<li>模拟域名，在 Windows 的 hosts 文件配置</li>
</ol>
</li>
</ol>
<h2 id="3-5-虚拟主机访问方式"><a href="#3-5-虚拟主机访问方式" class="headerlink" title="3.5 虚拟主机访问方式"></a>3.5 虚拟主机访问方式</h2><ol>
<li>基于域名访问</li>
<li>基于地址访问<ul>
<li>服务器可能有多个IP，在虚拟主机配置的server中指定只能访问指定地址 <code>listen ip:port</code></li>
</ul>
</li>
<li>基于端口访问</li>
</ol>
<h2 id="3-6-模块-Module"><a href="#3-6-模块-Module" class="headerlink" title="3.6 模块 Module"></a>3.6 模块 Module</h2><ol>
<li><code>ngx_http_access_module</code><ul>
<li>根据访问的服务器地址进行指定资源的控制</li>
</ul>
</li>
<li><code>ngx_http_auth_basic_module</code><ul>
<li>访问认证</li>
</ul>
</li>
<li><code>ngx_http_autoindex_module</code><ul>
<li>文件共享</li>
</ul>
</li>
<li><code>ngx_http_stub_status_module</code><ul>
<li>状态监控</li>
</ul>
</li>
<li><code>ngx_http_rewrite_module</code><ul>
<li>页面跳转</li>
</ul>
</li>
<li><code>ngx_http_upstream_module</code><ul>
<li>负载均衡</li>
</ul>
</li>
<li><code>ngx_http_proxy_module</code><ul>
<li>反向代理</li>
</ul>
</li>
<li><code>ngx_http_core_module</code><ul>
<li>核心模块</li>
<li>location<ol>
<li><code>location = /</code><ul>
<li>精确匹配</li>
</ul>
</li>
<li><code>location /</code><ul>
<li>默认匹配，没有匹配时匹配默认</li>
</ul>
</li>
<li><code>location = /test</code><ul>
<li>目录匹配</li>
</ul>
</li>
<li><code>location ^~ /text</code><ul>
<li>优先匹配</li>
</ul>
</li>
<li><code>location ~* \.jpg</code><ul>
<li>扩展名</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="3-7-负载均衡"><a href="#3-7-负载均衡" class="headerlink" title="3.7 负载均衡"></a>3.7 负载均衡</h2><ol>
<li>集群<ul>
<li>完成相同任务的一组服务器</li>
</ul>
</li>
<li>负载均衡<ul>
<li>对用户访问请求进行调度分配，实现用户访问压力分担</li>
</ul>
</li>
<li>正向代理 &amp; 反向代理<ol>
<li>正向代理<ol>
<li>正向代理代理的对象是客户端</li>
<li>客户端明确知道要访问的目标服务器，但由于一些原因不能直接访问，则通过代理服务器来访问。</li>
<li>正向代理隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求</li>
</ol>
</li>
<li>反向代理<ol>
<li>反向代理代理的对象是服务端</li>
<li>客户端请求代理服务器，代理服务器帮客户端把请求转发到真实的服务器那里去</li>
<li>反向代理隐藏了真实的服务端，可能有许多台服务器提供服务，客户端并不知道也不需要知道具体是哪一台服务器处理此次请求。</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/anyeansan.github.io/2020/11/08/JavaWeb/JDBC/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/JDBC.png" alt=""></p>
<ol>
<li><code>Java Database Connectivity</code> </li>
<li>JDBC 是 SUN 公司提供的一套访问数据库的标准规范，由各个数据库厂商来实现（数据库驱动）</li>
<li>Java 开发时面向接口编程，运行时加载对应的数据库驱动即可</li>
<li>JDBC 主要完成三件事<ol>
<li>建立连接</li>
<li>发送SQL语句</li>
<li>处理返回的结果</li>
</ol>
</li>
</ol>
<h1 id="二-API"><a href="#二-API" class="headerlink" title="二 API"></a>二 API</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><table>
<thead>
<tr>
<th>接口/类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>java.sql.DriverManager</code></td>
<td>驱动管理类，用于注册驱动</td>
</tr>
<tr>
<td><code>java.sql.Connection</code></td>
<td>连接</td>
</tr>
<tr>
<td><code>java.sql.Statement</code></td>
<td>执行 SQL 语句</td>
</tr>
<tr>
<td><code>java.sql.PreparedStatement</code></td>
<td><code>Statement</code> 子接口，预编译</td>
</tr>
<tr>
<td><code>java.sql.ResultSet</code></td>
<td>结果集，提供一个游标，默认指向结果集第一行之前</td>
</tr>
</tbody></table>
<h2 id="2-2-DriverManager"><a href="#2-2-DriverManager" class="headerlink" title="2.2 DriverManager"></a>2.2 DriverManager</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static void</code></td>
<td><code>registerDriver​(Driver driver)</code></td>
<td>注册驱动</td>
</tr>
<tr>
<td><code>static Connection</code></td>
<td><code>getConnection​(String url)</code></td>
<td>获取连接</td>
</tr>
<tr>
<td><code>static Connection</code></td>
<td><code>getConnection​(String url, String user, String password)</code></td>
<td>获取连接</td>
</tr>
<tr>
<td><code>static Connection</code></td>
<td><code>getConnection​(String url, Properties info)</code></td>
<td>获取连接</td>
</tr>
</tbody></table>
<h2 id="2-3-Connection"><a href="#2-3-Connection" class="headerlink" title="2.3 Connection"></a>2.3 Connection</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Statement</code></td>
<td><code>createStatement()</code></td>
<td>获取 Statement</td>
</tr>
<tr>
<td><code>PreparedStatement</code></td>
<td><code>prepareStatement​(String sql)</code></td>
<td>获取 PreparedStatement</td>
</tr>
<tr>
<td><code>CallableStatement</code></td>
<td><code>prepareCall​(String sql)</code></td>
<td>获取 CallableStatement</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setAutoCommit​(boolean autoCommit)</code></td>
<td>是否开启自动提交</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setTransactionIsolation​(int level)</code></td>
<td>设置隔离级别</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>rollback()</code></td>
<td>回滚</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>commit()</code></td>
<td>提交</td>
</tr>
</tbody></table>
<h2 id="2-4-Statement"><a href="#2-4-Statement" class="headerlink" title="2.4 Statement"></a>2.4 Statement</h2><h3 id="1-方法"><a href="#1-方法" class="headerlink" title="1 方法"></a>1 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ResultSet</code></td>
<td><code>executeQuery​(String sql)</code></td>
<td>执行 DQL <code>select</code>，返回结果集</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>executeUpdate​(String sql)</code></td>
<td>执行 DML <code>insert update delete</code> 返回影响行数，执行 DDL 返回 <code>0</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>execute​(String sql)</code></td>
<td>执行任意 SQL 语句，仅当执行 DQL 且有结果集时返回 <code>true</code></td>
</tr>
</tbody></table>
<h3 id="2-Statement-的问题"><a href="#2-Statement-的问题" class="headerlink" title="2 Statement 的问题"></a>2 Statement 的问题</h3><ol>
<li>SQL 拼接，各种单引号和双引号嵌套，很麻烦</li>
<li>SQL 注入<ul>
<li>使用字符串拼接，导致 SQL 语句判断条件总是为 <code>true</code>，安全隐患</li>
<li>如 <code>select * from test where name = &#39;wangcai&#39; or 1=1</code></li>
</ul>
</li>
<li>无法处理 <code>blob</code> 等二进制类型数据</li>
</ol>
<h2 id="2-5-PreparedStatement"><a href="#2-5-PreparedStatement" class="headerlink" title="2.5 PreparedStatement"></a>2.5 PreparedStatement</h2><h3 id="1-方法-1"><a href="#1-方法-1" class="headerlink" title="1 方法"></a>1 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ResultSet</code></td>
<td><code>executeQuery()</code></td>
<td>执行 DQL <code>select</code>，返回结果集</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>executeUpdate()</code></td>
<td>执行 DML <code>insert update delete</code> 返回影响行数，执行 DDL 返回 <code>0</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>execute()</code></td>
<td>执行任意 SQL 语句，仅当执行 DQL 且有结果集时返回 <code>true</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setInt​(int parameterIndex, int x)</code></td>
<td>为指定类型占位符赋值，根据占位符顺序，从 1 开始</td>
</tr>
</tbody></table>
<ul>
<li>有一系列的 <code>setXxx()</code> 重载方法，为不同的类型赋值</li>
</ul>
<h3 id="2-解决-Statement-的问题"><a href="#2-解决-Statement-的问题" class="headerlink" title="2 解决 Statement 的问题"></a>2 解决 Statement 的问题</h3><ol>
<li>SQL 语句使用 <code>?</code> 占位符，不需要手动拼接，从而也避免了 SQL 注入</li>
<li>为占位符赋值时可以使用二进制</li>
</ol>
<h3 id="3-插入数据后获取自增长的值"><a href="#3-插入数据后获取自增长的值" class="headerlink" title="3 插入数据后获取自增长的值"></a>3 插入数据后获取自增长的值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// autoGeneratedKeys：Statement 中定义的常量，其中 RETURN_GENERATED_KEYS 可以获取自增值的值</span></span><br><span class="line"><span class="function">PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql, <span class="keyword">int</span> autoGeneratedKeys)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 2 设置之后，插入时可以使用 PreparedStatement 对象获取一个结果集</span></span></span><br><span class="line"><span class="function">ResultSet <span class="title">getGeneratedKeys</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h2 id="2-6-ResultSet"><a href="#2-6-ResultSet" class="headerlink" title="2.6 ResultSet"></a>2.6 ResultSet</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>next()</code></td>
<td>将游标从当前位置向下移一行</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getInt​(int columnIndex)</code></td>
<td>根据索引获取指定类型的值，索引从 1 开始</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getInt​(String columnLabel)</code></td>
<td>根据列名获取指定类型的值</td>
</tr>
<tr>
<td><code>Object</code></td>
<td><code>getObject​(int columnIndex)</code></td>
<td>不清楚类型可以使用Object</td>
</tr>
<tr>
<td><code>Object</code></td>
<td><code>getObject​(String columnLabel)</code></td>
<td>不清楚类型可以使用Object</td>
</tr>
<tr>
<td><code>ResultSetMetaData</code></td>
<td><code>getMetaData()</code></td>
<td>获取结果集元数据，包含记录数，字段信息（个数，类型，名称 …）</td>
</tr>
</tbody></table>
<ul>
<li>有一系列的各种数据类型的 <code>getXxx()</code> 重载方法，且都有根据列名和索引获取两种方式</li>
</ul>
<h1 id="三-Mysql-和-java-类型"><a href="#三-Mysql-和-java-类型" class="headerlink" title="三 Mysql 和 java 类型"></a>三 Mysql 和 java 类型</h1><h2 id="3-1-java-sql-ResultSetMetaData（结果集元数据）"><a href="#3-1-java-sql-ResultSetMetaData（结果集元数据）" class="headerlink" title="3.1 java.sql.ResultSetMetaData（结果集元数据）"></a>3.1 <code>java.sql.ResultSetMetaData</code>（结果集元数据）</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>getColumnCount()</code></td>
<td>获取记录数</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getColumnTypeName​(int column)</code></td>
<td>获取字段对应的数据库类型，编号从 1 开始</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getColumnClassName​(int column)</code></td>
<td>获取字段对应的 java 类型，编号从 1 开始</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getColumnName​(int column)</code></td>
<td>获取字段在数据库中的名称</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getColumnLabel​(int column)</code></td>
<td>获取字段别名</td>
</tr>
</tbody></table>
<ol>
<li>使用反射根据属性名获取 <code>Field</code> 对象时，如果数据库字段名和类属性名不一致，就获取不到</li>
<li>可以使用别名，让别名=类属性名</li>
<li>类属性名建议都是用引用类型，因为数据库数据可能为空</li>
</ol>
<h2 id="3-2-类型对照"><a href="#3-2-类型对照" class="headerlink" title="3.2 类型对照"></a>3.2 类型对照</h2><table>
<thead>
<tr>
<th><code>Mysql Type name</code>（数据库设计类型）</th>
<th><code>GetColumnTypeName</code>（数据库类型）</th>
<th><code>GetColumnClassName</code>（java 类型）</th>
</tr>
</thead>
<tbody><tr>
<td><code>INT</code></td>
<td><code>INTEGER</code></td>
<td><code>java.lang.Integer</code></td>
</tr>
<tr>
<td><code>INT UNSIGNED</code></td>
<td><code>INTEGER UNSIGNED</code></td>
<td><code>java.lang.Long</code></td>
</tr>
<tr>
<td><code>CHAR(M)</code></td>
<td><code>CHAR</code></td>
<td><code>java.lang.String</code></td>
</tr>
<tr>
<td><code>VARCHAR(M)</code></td>
<td><code>VARCHAR</code></td>
<td><code>java.lang.String</code></td>
</tr>
<tr>
<td><code>ENUM(&#39;value1&#39;,&#39;value2&#39;,...)</code></td>
<td><code>CHAR</code></td>
<td><code>java.lang.String</code></td>
</tr>
<tr>
<td><code>SET(&#39;value1&#39;,&#39;value2&#39;,...)</code></td>
<td><code>CHAR</code></td>
<td><code>java.lang.String</code></td>
</tr>
<tr>
<td><code>DATE</code></td>
<td><code>DATE</code></td>
<td><code>java.sql.Date</code></td>
</tr>
<tr>
<td><code>DATETIME</code></td>
<td><code>DATETIME</code></td>
<td><code>java.sql.Timestamp</code></td>
</tr>
<tr>
<td><code>TIMESTAMP</code></td>
<td><code>TIMESTAMP</code></td>
<td><code>java.sql.Timestamp</code></td>
</tr>
</tbody></table>
<h1 id="四-JDBC-步骤"><a href="#四-JDBC-步骤" class="headerlink" title="四 JDBC 步骤"></a>四 JDBC 步骤</h1><ol>
<li><p>导入数据库驱动包</p>
</li>
<li><p>注册驱动</p>
<ol>
<li><p>手动注册（不推荐）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> DriverManager.registerDriver(Driver driver)</span><br></pre></td></tr></table></figure>

<ol>
<li>对具体的驱动类产生了依赖，不方便扩展</li>
<li>驱动重复注册<ol>
<li>调用此方法注册一次</li>
<li>加载 <code>Driver</code> 类又注册一次，因为 <code>Driver</code> 类中的静态代码块就是调用了此方法</li>
</ol>
</li>
</ol>
</li>
<li><p>反射注册（推荐）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过反射加载 Driver 类时执行静态代码块，注册驱动</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql..cj.jdbc.Driver"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>获取连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection conn = DriverManager.getConnection(url,user.passwd)</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 SQL 语句，获取结果集</p>
<ol>
<li>Statement（不推荐）<ol>
<li>编写静态 SQL 语句</li>
<li>根据连接获取 <code>Statement</code> 对象</li>
<li>使用 <code>Statement</code> 对象执行 SQL，获取结果集</li>
</ol>
</li>
<li>PreparedStatement（推荐）<ol>
<li>编写动态 SQL 语句（参数使用 <code>?</code> 作为占位符）</li>
<li>根据连接获取 <code>PreparedStatement</code> 对象</li>
<li>使用 <code>PreparedStatement</code> 对象为 SQL 占位符赋值</li>
<li>使用 <code>PreparedStatement</code> 对象执行，获取结果集</li>
</ol>
</li>
</ol>
</li>
<li><p>处理结果集</p>
</li>
<li><p>关闭资源（ResultSet Statement Connection）</p>
</li>
</ol>
<h1 id="五-批处理"><a href="#五-批处理" class="headerlink" title="五 批处理"></a>五 批处理</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol>
<li>当需要成批插入或者更新记录时，可以采用 Java 的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。</li>
<li>通常情况下比单独提交处理更有效率，类似缓冲区的效果</li>
</ol>
<h2 id="5-2-使用"><a href="#5-2-使用" class="headerlink" title="5.2 使用"></a>5.2 使用</h2><ol>
<li>Mysql 服务器默认是关闭批处理的，需要<code>url</code> 配置 <code>rewriteBatchedStatements=true</code> 来开启</li>
<li><code>void addBatch()</code><ul>
<li>将需要批量处理的SQL语句或参数添加到批处理组中，类似添加到缓冲区</li>
</ul>
</li>
<li><code>int[] executeBatch()</code><ul>
<li>执行批处理</li>
</ul>
</li>
</ol>
<h1 id="六-JDBC-事务"><a href="#六-JDBC-事务" class="headerlink" title="六 JDBC 事务"></a>六 JDBC 事务</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 关闭自动提交：开启事务</span></span><br><span class="line">conn.setAutoCommit(<span class="keyword">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 回滚或提交</span></span><br><span class="line">conn.rollback()</span><br><span class="line">conn.commit()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 关闭连接前恢复自动提交，因为连接通常从连接池中获取，是重复使用的</span></span><br><span class="line">conn.setAutoCommit(<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>

<h1 id="七-MySQL-数据库驱动"><a href="#七-MySQL-数据库驱动" class="headerlink" title="七 MySQL 数据库驱动"></a>七 MySQL 数据库驱动</h1><h2 id="7-1-Connector-J-5"><a href="#7-1-Connector-J-5" class="headerlink" title="7.1 Connector/J 5"></a>7.1 Connector/J 5</h2><table>
<thead>
<tr>
<th>属性</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td><code>driver</code></td>
<td><code>com.mysql.jdbc.Driver</code></td>
</tr>
<tr>
<td><code>url</code></td>
<td><code>jdbc:mysql://localhost:3306/db_name</code></td>
</tr>
</tbody></table>
<h2 id="7-2-Connector-J-8"><a href="#7-2-Connector-J-8" class="headerlink" title="7.2 Connector/J 8"></a>7.2 Connector/J 8</h2><table>
<thead>
<tr>
<th>属性</th>
<th>语法</th>
<th>例</th>
</tr>
</thead>
<tbody><tr>
<td><code>driver</code></td>
<td><code>com.mysql.cj.jdbc.Driver</code></td>
<td><code>com.mysql.cj.jdbc.Driver</code></td>
</tr>
<tr>
<td><code>url</code></td>
<td><code>protocol//[hosts][/database][?properties]</code></td>
<td><code>jdbc:mysql://localhost:3306/db_name?useSSL=false&amp;serverTimezone=GMT%2B8&amp;characterEncoding=UTF-8</code></td>
</tr>
</tbody></table>
<h2 id="7-3-Connector-J-8-中-url-的-properties"><a href="#7-3-Connector-J-8-中-url-的-properties" class="headerlink" title="7.3 Connector/J 8 中 url 的 properties"></a>7.3 Connector/J 8 中 url 的 properties</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>格式 <code>key=value</code>，多个之间使用 <code>&amp;</code> 连接</li>
<li>在 Xml 中应该使用字符的特殊编码：<code>&amp;</code> 对应 <code>&amp;amp;</code></li>
</ol>
<h3 id="2-key"><a href="#2-key" class="headerlink" title="2 key"></a>2 key</h3><table>
<thead>
<tr>
<th>key</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>useSSL</code></td>
<td>是否使用 SSL 连接，默认 <code>true</code></td>
</tr>
<tr>
<td><code>characterEncoding</code></td>
<td>设置字符集</td>
</tr>
<tr>
<td><code>serverTimezone</code></td>
<td>设置时区</td>
</tr>
<tr>
<td><code>rewriteBatchedStatements</code></td>
<td>是否开启批处理，默认 <code>false</code></td>
</tr>
</tbody></table>
<h4 id="1-SSL-（Secure-Socket-Layer）"><a href="#1-SSL-（Secure-Socket-Layer）" class="headerlink" title="1 SSL （Secure Socket Layer）"></a>1 SSL （Secure Socket Layer）</h4><ol>
<li>安全套接字层，用于安全连接，但是影响性能</li>
<li>若要使用 SSL 需要在 Mysql 服务端配置</li>
<li>Mysql 8.0 之前<ol>
<li><code>5.5.45+，5.6.26+，5.7.6+</code> 默认为 <code>true</code></li>
<li>其它默认为 <code>false</code></li>
</ol>
</li>
<li>Mysql 8.0 之后，默认为 <code>true</code></li>
</ol>
<h4 id="2-serverTimezone"><a href="#2-serverTimezone" class="headerlink" title="2 serverTimezone"></a>2 serverTimezone</h4><ol>
<li><code>UTC</code><ul>
<li>世界标准时间，0 时区时间</li>
</ul>
</li>
<li><code>GMT+8</code> ，url 中写为 <code>GMT%2B8</code><ul>
<li>东八区时间，比 UTC 快 8 个小时</li>
</ul>
</li>
<li>如果不想时间有差异：接收的类型使用的时区和连接设置的时区要相同，因为不管数据库时区和连接时区是什么，从数据库获取的值是不变的，只是所代表的时区会改变<ol>
<li><code>timestamp dateTime localDateTime ...</code> 等类型使用的时区是本地系统时区，所以使用这些类型接收时，<code>serverTimezone</code> 要与本地系统时区一致</li>
<li><code>Instant</code> 是 UTC 时间，使用 <code>Instant</code> 接收时，<code>serverTimezone</code> 要设置为 UTC</li>
</ol>
</li>
</ol>
<h4 id="3-关于时区的例子"><a href="#3-关于时区的例子" class="headerlink" title="3 关于时区的例子"></a>3 关于时区的例子</h4><ol>
<li>数据库都设置为东八区时间 <code>00:00:00</code></li>
<li><code>serverTimezone=UTC</code>，从数据库获取的就是 UTC 时间 <code>00:00:00</code><ol>
<li><code>timestamp dateTime localDateTime ...</code> 这些类型接收会转换为东八区时间，也就是要+8，最终结果为 <code>08:00:00</code></li>
<li><code>Instant</code> 使用的是 UTC 时间，不用转换，最终结果为 <code>00:00:00</code></li>
</ol>
</li>
<li><code>serverTimezone=GMT%2B8</code>，从数据库获取的就是 东八区 时间 <code>00:00:00</code><ol>
<li>使用 <code>timestamp dateTime localDateTime ...</code> 接收不需要转换</li>
<li>使用 <code>Instant</code> 接收需要转为 UTC 时间，也就是要 - 8，最终结果是前一天的 <code>16:00:00</code></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>Java-日志</title>
    <url>/anyeansan.github.io/2020/09/29/Java/Java-%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li><p>日志门面（接口）：</p>
<ol>
<li><code>JCL（jakarta commons logging）</code></li>
<li><code>slf4j（simple logging facade for java）</code> </li>
</ol>
</li>
<li><p>日志实现</p>
<ol>
<li><code>JUL（Java util Logging）</code></li>
<li><code>logback</code></li>
<li><code>log4j</code></li>
<li><code>log4j2</code></li>
</ol>
</li>
</ol>
<h1 id="二-日志门面"><a href="#二-日志门面" class="headerlink" title="二 日志门面"></a>二 日志门面</h1><h2 id="2-1-JCL"><a href="#2-1-JCL" class="headerlink" title="2.1 JCL"></a>2.1 <code>JCL</code></h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>Jakarta Commons Logging</code></li>
<li>包： <code>commons-looging.jar</code></li>
<li>Apache 提供的一个通用日志接口，它是为 “所有的 Java 日志实现”提供一个统一的接口，它自身也提供一个日志的实现 <code>SimpleLog</code>，但是功能非常弱</li>
<li>通过动态查找的机制，在程序运行时自动找出真正使用的日志库，如果未提供任何第三方实现，则默认使用 <code>JUL</code></li>
</ol>
<h3 id="2-API"><a href="#2-API" class="headerlink" title="2 API"></a>2 API</h3><ol>
<li><code>Log</code>：日志记录器</li>
<li><code>LogFactory</code>：负责创建 <code>Log</code></li>
</ol>
<h2 id="2-2-slf4j"><a href="#2-2-slf4j" class="headerlink" title="2.2 slf4j"></a>2.2 <code>slf4j</code></h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><p><code>Simple Logging Facade For Java</code></p>
</li>
<li><p>SLF4J 主要是为了给 Java 日志访问提供一套标准、规范的 API 框架，其主要意义在于提供接口，具体的实现可以交由其他日志框架</p>
</li>
<li><p>slf4j 内置一个简单的日志实现 <code>slf4j-simple</code> ，不过很少使用</p>
</li>
<li><p>通常 slf4j 作为门面，配上具体的实现框架，中接使用桥接器完成桥接</p>
</li>
<li><p>主要功能：</p>
<ol>
<li>日志框架的绑定</li>
<li>日志框架的桥接</li>
</ol>
</li>
<li><p><code>slf4j-api.jar</code> 核心 API 包</p>
</li>
<li><p>日志级别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-绑定日志实现"><a href="#2-绑定日志实现" class="headerlink" title="2 绑定日志实现"></a>2 绑定日志实现</h3><h4 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1 步骤"></a>1 步骤</h4><ol>
<li>添加 slf4j 的依赖包 <code>slf4j-api.jar</code></li>
<li>绑定具体的日志实现框架<ol>
<li>已经实现 slf4j 的日志框架，如 <code>logback</code>，直接添加其依赖即可</li>
<li>没有实现 slf4j 的日志框架，如 <code>JUL log4j log4j2</code>，除了日志框架的依赖包外，还需要适配器（包）</li>
</ol>
</li>
<li>如果绑定了多个实现，默认使用第一个</li>
</ol>
<h4 id="2-包"><a href="#2-包" class="headerlink" title="2 包"></a>2 包</h4><h5 id="1-slf4j-JUL"><a href="#1-slf4j-JUL" class="headerlink" title="1 slf4j + JUL"></a>1 slf4j + JUL</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">slf4j-api.jar</span><br><span class="line">slf4j-jdk14.jar</span><br></pre></td></tr></table></figure>

<h5 id="2-slf4j-log4j"><a href="#2-slf4j-log4j" class="headerlink" title="2 slf4j + log4j"></a>2 slf4j + log4j</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">slf4j-api.jar</span><br><span class="line">log4j.jar</span><br><span class="line">slf4j-log4j12.jar</span><br></pre></td></tr></table></figure>

<h5 id="3-slf4j-log4j2"><a href="#3-slf4j-log4j2" class="headerlink" title="3 slf4j + log4j2"></a>3 slf4j + log4j2</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">slf4j-api.jar</span><br><span class="line">log4j-api.jar</span><br><span class="line">log4j-core.jar</span><br><span class="line">log4j-slf4j-impl.jar</span><br></pre></td></tr></table></figure>

<h5 id="4-slf4j-logback"><a href="#4-slf4j-logback" class="headerlink" title="4 slf4j + logback"></a>4 slf4j + logback</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">slf4j-api.jar</span><br><span class="line">logback-core.jar</span><br><span class="line">logback-classic.jar</span><br></pre></td></tr></table></figure>

<h3 id="3-桥接旧的日志框架"><a href="#3-桥接旧的日志框架" class="headerlink" title="3 桥接旧的日志框架"></a>3 桥接旧的日志框架</h3><h4 id="1-步骤-1"><a href="#1-步骤-1" class="headerlink" title="1 步骤"></a>1 步骤</h4><ol>
<li>去除旧的日志依赖</li>
<li>配置桥接器（包）</li>
<li>绑定新的日志实现</li>
</ol>
<h4 id="2-桥接器"><a href="#2-桥接器" class="headerlink" title="2 桥接器"></a>2 桥接器</h4><ol>
<li><code>jul-to-slf4j.jar</code><ul>
<li>将 JUL 的日志桥接到 slf4j ，即不再使用 JUL，而使用新的日志实现</li>
</ul>
</li>
<li><code>log4j-over-slf4j.jar</code><ul>
<li>将 log4j 的日志桥接到 slf4j</li>
</ul>
</li>
<li><code>jcl-over-slf4j.jar</code><ul>
<li>将 JCL 的日志桥接到 slf4j</li>
</ul>
</li>
</ol>
<h3 id="4-API"><a href="#4-API" class="headerlink" title="4 API"></a>4 API</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Logger LoggerFactory.getLogger(字节码文件)</span><br><span class="line">Logger LoggerFactory.getLogger(全限定类名)</span><br></pre></td></tr></table></figure>

<h1 id="三-日志实现"><a href="#三-日志实现" class="headerlink" title="三 日志实现"></a>三 日志实现</h1><h2 id="3-1-log4j2"><a href="#3-1-log4j2" class="headerlink" title="3.1 log4j2"></a>3.1 <code>log4j2</code></h2><h3 id="1-配置"><a href="#1-配置" class="headerlink" title="1 配置"></a>1 配置</h3><ul>
<li>默认加载类路径下 <code>log4j2.xml</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	日志级别： </span></span><br><span class="line"><span class="comment">		OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL</span></span><br><span class="line"><span class="comment">    日期格式：</span></span><br><span class="line"><span class="comment">        %d 输出的时间</span></span><br><span class="line"><span class="comment">        %t 输出当前线程名称</span></span><br><span class="line"><span class="comment">        %F 输出所在的类文件名</span></span><br><span class="line"><span class="comment">        %L 输出行号</span></span><br><span class="line"><span class="comment">        %M 输出所在方法名</span></span><br><span class="line"><span class="comment">        %n 换行</span></span><br><span class="line"><span class="comment">        %-5level 输出日志级别，-5表示左对齐并且固定输出5个字符，如果不足在右边补0</span></span><br><span class="line"><span class="comment">        %logger 输出logger名称，Root Logger没有名称</span></span><br><span class="line"><span class="comment">        %l 输出语句所在的行数, 包括类名、方法名、文件名、行数</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">status：设置log4j2自身内部的信息输出，可以不设置</span></span><br><span class="line"><span class="comment">monitorInterval：指定每隔多久重新读取配置文件，可以不重启应用的情况下修改配置</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span> <span class="attr">monitorInterval</span>=<span class="string">"30"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1 定义属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 2 配置 appender--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 2.1 console--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!--输出日志格式--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 2.2 file--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">fileName</span>=<span class="string">"文件路径"</span> <span class="attr">append</span>=<span class="string">"是否追加"</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!--输出日志格式--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 2.3 rollingFile--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">fileName</span>=<span class="string">""</span> <span class="attr">filePattern</span>=<span class="string">"指定当发生Rolling时，文件的转移和重命名规则"</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!--输出日志格式--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 过滤器--&gt;</span>      </span><br><span class="line">			<span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">""</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 日志拆分规则--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">            	<span class="comment">&lt;!-- 系统启动就触发拆分规则，产生一个新的日志文件--&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">OnStartupTriggeringPolicy</span>/&gt;</span></span><br><span class="line">            	<span class="comment">&lt;!-- 按照时间节点拆分，根据 filePattern 的配置，如最小时间粒度是HH，则表示每小时产生一个新的日志文件--&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- 按照文件大小拆分，超过大小就产生一个新的--&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!--同一目录最多保存的文件个数，超过则覆盖--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 3 logger 只有定义了logger并引入的appender，appender才会生效--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--3.1 root--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!--3.2 自定义 logger--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">level</span>=<span class="string">""</span> <span class="attr">additivity</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-异步日志"><a href="#2-异步日志" class="headerlink" title="2 异步日志"></a>2 异步日志</h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>异步日志需要添加依赖 <code>com.lmax.disruptor</code></li>
<li>有两种实现方式<ol>
<li><code>AsyncLogger</code>（官方推荐）：全局+混合</li>
<li><code>AsyncAppender</code></li>
</ol>
</li>
<li>注意三种方式不要同时使用</li>
</ol>
<h4 id="2-AsyncLogger"><a href="#2-AsyncLogger" class="headerlink" title="2 AsyncLogger"></a>2 <code>AsyncLogger</code></h4><h5 id="1-全局异步"><a href="#1-全局异步" class="headerlink" title="1 全局异步"></a>1 全局异步</h5><ol>
<li><p>所有的日志都异步的记录，在配置文件上不用做任何改动，只需要添加一个 <code>log4j2.component.properties</code> 配置</p>
</li>
<li><p><code>log4j2.component.properties</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Log4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="2-混合异步"><a href="#2-混合异步" class="headerlink" title="2 混合异步"></a>2 混合异步</h5><ol>
<li><p>同时使用同步日志和异步日志，通过配置指定哪些同步哪些异步</p>
</li>
<li><p>配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">		自定义异步 logger</span></span><br><span class="line"><span class="comment">		includeLocation：是否包含日志记录的行号信息，要关闭</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">AsyncLogger</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">level</span>=<span class="string">""</span> <span class="attr">includeLocation</span>=<span class="string">"false"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">AsyncLogger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="3-AsyncAppender"><a href="#3-AsyncAppender" class="headerlink" title="3 AsyncAppender"></a>3 <code>AsyncAppender</code></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 定义异步 appender ，之后引入 logger 即可</span><br><span class="line"><span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Async</span> <span class="attr">name</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Async</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-logback"><a href="#3-2-logback" class="headerlink" title="3.2 logback"></a>3.2 <code>logback</code></h2><h3 id="1-模块"><a href="#1-模块" class="headerlink" title="1 模块"></a>1 模块</h3><ol>
<li><code>logback-core</code>：其它两个模块的基础模块</li>
<li><code>logback-classic</code>：它是 log4j 的一个改良版本，同时它完整实现了slf4j API</li>
<li><code>logback-access</code>：访问模块与 Servlet 容器集成提供通过 Http 来访问日志的功能</li>
</ol>
<h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2 配置"></a>2 配置</h3><h4 id="1-依次读取"><a href="#1-依次读取" class="headerlink" title="1 依次读取"></a>1 依次读取</h4><ol>
<li><code>logback.groovy</code></li>
<li><code>logback-test.xml</code></li>
<li><code>logback.xml</code></li>
</ol>
<h4 id="2-详解"><a href="#2-详解" class="headerlink" title="2 详解"></a>2 详解</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 1 配置集中管理属性，获取value语法 $&#123;name&#125; --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 2 Appdender 配置 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 2.1 console --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--输出流对象 默认 System.out--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">target</span>&gt;</span><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--日志输出格式--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">pattern</span>&gt;</span><span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span>	</span><br><span class="line">	<span class="comment">&lt;!-- 2.2 file --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.FileAppender"</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--日志输出路径--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">file</span>&gt;</span><span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--日志输出格式--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">pattern</span>&gt;</span><span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">&lt;!-- 2.3 htmlFile --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.FileAppender"</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--日志输出路径--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">file</span>&gt;</span><span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--日志输出格式--&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.encoder.LayoutWrappingEncoder"</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.html.HTMLLayout"</span>&gt;</span></span><br><span class="line">    			<span class="tag">&lt;<span class="name">pattern</span>&gt;</span><span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">&lt;!-- 2.4 rollingFile --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--日志输出路径--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">file</span>&gt;</span><span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--日志输出格式--&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">pattern</span>&gt;</span><span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--指定日志文件拆分和压缩规则--&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">    		<span class="comment">&lt;!--按照时间和压缩格式声明拆分的文件名--&gt;</span></span><br><span class="line">   		 	<span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span><span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">    		<span class="comment">&lt;!--按照文件大小拆分--&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span><span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--日志级别过滤器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">      		<span class="comment">&lt;!--过滤规则--&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">level</span>&gt;</span><span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">      		// 超过指定级别放行还是拦截</span><br><span class="line">      		<span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">      		// 低于指定级别放行还是拦截</span><br><span class="line">      		<span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 2.5 异步 async --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.AsyncAppender"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 3 root Logger 配置--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"默认debug"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"console"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--4 自定义 logger --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.itheima"</span> <span class="attr">level</span>=<span class="string">"debug"</span> <span class="attr">additivity</span>=<span class="string">"是否继承rootLogger，默认true"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-JUL"><a href="#3-3-JUL" class="headerlink" title="3.3 JUL"></a>3.3 <code>JUL</code></h2><h3 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>Java util Logging</code></li>
<li>是 Java 原生的日志框架，使用时不需要另外引用第三方类库</li>
<li>配置文件：<code>$JAVA_HOME\conf\logging.properties</code></li>
<li>所在包：<code>java.util.logging</code> </li>
</ol>
<h3 id="2-架构"><a href="#2-架构" class="headerlink" title="2 架构"></a>2 架构</h3><table>
<thead>
<tr>
<th>对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Logger</code></td>
<td>日志记录器，程序通过此对象的 API 来发布日志，每个 <code>Logger</code> 可以关联多个 <code>Appender / Handler</code></td>
</tr>
<tr>
<td><code>Appender / Handler</code></td>
<td>日志处理器，决定日志记录的位置，如 控制台、文件…</td>
</tr>
<tr>
<td><code>Layout / Formatter</code></td>
<td>负责日志记录的数据转换和格式化</td>
</tr>
<tr>
<td><code>Level</code></td>
<td>日志级别</td>
</tr>
</tbody></table>
<h3 id="2-API-1"><a href="#2-API-1" class="headerlink" title="2 API"></a>2 API</h3><h4 id="1-Logger"><a href="#1-Logger" class="headerlink" title="1 Logger"></a>1 Logger</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Logger</code></td>
<td><code>getLogger(String name)</code></td>
<td>获取或创建 <code>Logger</code> 对象</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>log(Level, String msg)</code></td>
<td>输出指定级别的信息</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>info(String msg)</code></td>
<td>输出指定级别的信息，还有其它级别方法</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addHandler(Handler handler)</code></td>
<td>关联 <code>Handler</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setUseParentHandlers(Boolean useParentHandlers)</code></td>
<td>是否会输出到父 <code>Logger</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setLevel(Level newLevel)</code></td>
<td>设置日志级别</td>
</tr>
</tbody></table>
<ol>
<li><code>Logger</code> 之间存在父子关系，根据名称会自动继承，如 <code>com.cn.an 和 com.cn 和 com</code></li>
<li>最顶层是一个 <code>RootLogger</code></li>
<li>子 <code>Logger</code> 输出会同时传递给父 <code>Logger</code> 输出</li>
</ol>
<h4 id="2-Lever"><a href="#2-Lever" class="headerlink" title="2 Lever"></a>2 Lever</h4><table>
<thead>
<tr>
<th>静态属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ALL</code></td>
<td>启用所有级别信息</td>
</tr>
<tr>
<td><code>OFF</code></td>
<td>关闭日志</td>
</tr>
<tr>
<td><code>SEVERE</code></td>
<td>错误</td>
</tr>
<tr>
<td><code>WARNING</code></td>
<td>警告</td>
</tr>
<tr>
<td><code>INFO</code>（默认）</td>
<td>信息</td>
</tr>
<tr>
<td><code>CONFIG</code></td>
<td>配置</td>
</tr>
<tr>
<td><code>FINE FINER FINEST</code></td>
<td>debug <code>详细 较详细 非常详细</code></td>
</tr>
</tbody></table>
<h4 id="3-Handler"><a href="#3-Handler" class="headerlink" title="3 Handler"></a>3 Handler</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>setLevel(Level newLevel)</code></td>
<td>设置日志级别</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setForMatter(Formater newFormatter)</code></td>
<td>关联  <code>Formatter</code></td>
</tr>
</tbody></table>
<h2 id="3-4-Log4j"><a href="#3-4-Log4j" class="headerlink" title="3.4 Log4j"></a>3.4 <code>Log4j</code></h2><h3 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1 配置文件"></a>1 配置文件</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定日志级别和使用的输出端appender：console为自定义名称</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">INFO,console</span></span><br><span class="line"><span class="comment"># 控制台输出配置</span></span><br><span class="line"><span class="meta">log4j.appender.console</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="string">%d [%t] %-5p [%c] - %m%n</span></span><br></pre></td></tr></table></figure>

<ol>
<li>名称：<code>log4j.properties</code></li>
<li>将配置文件放在类路径下，会自动读取</li>
</ol>
<h3 id="2-组件"><a href="#2-组件" class="headerlink" title="2 组件"></a>2 组件</h3><h4 id="1-Looger"><a href="#1-Looger" class="headerlink" title="1 Looger"></a>1 Looger</h4><ol>
<li>Log4j 有一个根 <code>Logger</code>：<code>root</code></li>
<li>其它所有的 <code>Logger</code> 都会直接或间接继承 <code>root</code></li>
</ol>
<h4 id="2-Appender"><a href="#2-Appender" class="headerlink" title="2 Appender"></a>2 Appender</h4><ol>
<li><code>ConsoleAppender</code></li>
<li><code>FileAppender</code></li>
<li><code>DailyRollingFileAppender</code></li>
<li><code>RollingFileAppender</code></li>
<li><code>JDBCAppender</code></li>
</ol>
<h4 id="3-Layout"><a href="#3-Layout" class="headerlink" title="3 Layout"></a>3 Layout</h4><ol>
<li><code>HTMLLayout</code></li>
<li><code>SimpleLayout</code></li>
<li><code>PatternLayout</code></li>
</ol>
<ul>
<li><h1 id="配置文件log4j2-xml"><a href="#配置文件log4j2-xml" class="headerlink" title="配置文件log4j2.xml"></a><strong>配置文件<code>log4j2.xml</code></strong></h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span> <span class="attr">monitorInterval</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n"</span> /&gt;</span></span><br><span class="line">        	<span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">   	 <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span> /&gt;</span></span><br><span class="line">        	<span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>log4j2默认会在classpath目录下寻找log4j.json、log4j.jsn、log4j2.xml等名称的文件，如果都没有找到，则会按默认配置输出，也就是输出到控制台。</li>
<li><code>status</code><ul>
<li>表示log4j2本身的日志信息打印级别</li>
<li>用于设置log4j2自身内部的信息输出,可以不设置,当设置成trace时,会看到log4j2内部各种详细输出</li>
</ul>
</li>
<li><code>monitorInterval</code><ul>
<li>Log4j能够自动检测修改配置文件和重新配置本身, 设置间隔秒数。</li>
</ul>
</li>
<li><code>Appender</code><ul>
<li>定义日志的输出目的地</li>
<li><code>Console</code><ul>
<li>定义输出到控制台的Appender</li>
<li><code>name</code><ul>
<li>指定Appender的名字</li>
</ul>
</li>
<li><code>target</code><ul>
<li>SYSTEM_OUT 或 SYSTEM_ERR,一般只设置默认:SYSTEM_OUT.</li>
</ul>
</li>
<li><code>PatternLayout</code><ul>
<li>输出格式，不设置默认为:%m%n.</li>
</ul>
</li>
</ul>
</li>
<li><code>File</code><ul>
<li>定义输出到指定位置的文件的Appender</li>
<li><code>name</code><ul>
<li>指定Appender的名字</li>
</ul>
</li>
<li><code>fileName</code><ul>
<li>指定输出日志的目的文件带全路径的文件名</li>
</ul>
</li>
<li><code>PatternLayout</code><ul>
<li>输出格式，不设置默认为:%m%n.</li>
</ul>
</li>
</ul>
</li>
<li><code>RollingFile</code><ul>
<li>定义超过指定大小自动删除旧的创建新的的Appender.</li>
<li><code>name</code><ul>
<li>指定Appender的名字</li>
</ul>
</li>
<li><code>fileName</code><ul>
<li>指定输出日志的目的文件带全路径的文件名</li>
</ul>
</li>
<li><code>PatternLayout</code><ul>
<li>输出格式，不设置默认为:%m%n.</li>
</ul>
</li>
<li><code>filePattern</code><ul>
<li>指定新建日志文件的名称格式.</li>
</ul>
</li>
<li><code>Policies</code><ul>
<li>指定滚动日志的策略，就是什么时候进行新建日志文件输出日志</li>
<li><code>TimeBasedTriggeringPolicy</code><ul>
<li>基于时间的滚动策略</li>
<li><code>interval</code><ul>
<li>指定多久滚动一次，默认是1 hour</li>
</ul>
</li>
<li><code>modulate</code><ul>
<li>=true用来调整时间</li>
<li>比如现在是早上3am，interval是4，那么第一次滚动是在4am，接着是8am，12am…而不是7am</li>
</ul>
</li>
</ul>
</li>
<li><code>SizeBasedTriggeringPolicy</code><ul>
<li>基于指定文件大小的滚动策略</li>
<li><code>size</code><ul>
<li>定义每个日志文件的大小</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>DefaultRolloverStrategy</code><ul>
<li>指定同一个文件夹下最多有几个日志文件时开始删除最旧的，创建新的</li>
<li><code>max</code><ul>
<li>配置最多日志文件数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>Loggers</code><ul>
<li><code>Root</code><ul>
<li>指定项目的根日志，如果没有单独指定Logger，那么就会默认使用该Root日志输出</li>
<li><code>level</code><ul>
<li>日志输出级别，共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF</li>
</ul>
</li>
<li><code>AppenderRef</code><ul>
<li>指定该日志输出到哪个Appender</li>
</ul>
</li>
</ul>
</li>
<li><code>Logger</code><ul>
<li>单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等</li>
<li><code>level</code></li>
<li><code>name</code><ul>
<li>指定该Logger所适用的类或者类所在的包全路径,继承自Root节点</li>
</ul>
</li>
<li><code>AppenderRef</code><ul>
<li>指定该日志输出到哪个Appender,如果没有指定，就会默认继承自Root.如果指定了，那么会在指定的这个Appender和Root的Appender中都会输出。<ul>
<li>若设置Logger的additivity=”false”只在自定义的Appender中进行输出。        </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java-时间日期</title>
    <url>/anyeansan.github.io/2020/09/29/Java/Java-%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="一-JDK8-之前的日期时间"><a href="#一-JDK8-之前的日期时间" class="headerlink" title="一 JDK8 之前的日期时间"></a>一 JDK8 之前的日期时间</h1><h2 id="1-1-java-util-Date"><a href="#1-1-java-util-Date" class="headerlink" title="1.1 java.util.Date"></a>1.1 <code>java.util.Date</code></h2><h3 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1 构造方法"></a>1 构造方法</h3><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Date()</code></td>
<td>当前时间，使用的是当前时间到 <code>1970-01-01 00:00:00</code> 的毫秒值创建</td>
</tr>
<tr>
<td><code>Date​(long date)</code></td>
<td>使用指定毫秒值</td>
</tr>
</tbody></table>
<h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2 方法"></a>2 方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>long getTime()</code></td>
<td>获取 <code>1970-01-01 00:00:00</code> 到此时间的毫秒值</td>
</tr>
</tbody></table>
<h2 id="1-2-java-util-Calendar"><a href="#1-2-java-util-Calendar" class="headerlink" title="1.2 java.util.Calendar"></a>1.2 <code>java.util.Calendar</code></h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>Calendar</code> 类是一个抽象类，提供了很多关于日期时间计算的方法</li>
<li><code>GregorianCalendar</code>（公历）是 <code>Calendar</code> 的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统</li>
</ol>
<h3 id="2-方法-1"><a href="#2-方法-1" class="headerlink" title="2 方法"></a>2 方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Calendar getInstance()</code></td>
<td>使用默认时区和语言环境获得一个日历</td>
</tr>
<tr>
<td><code>static Calendar getInstance​(TimeZone zone, Locale aLocale)</code></td>
<td>使用指定时区和语言环境获得一个日历</td>
</tr>
</tbody></table>
<h2 id="1-3-java-text-SimpleDateFormat"><a href="#1-3-java-text-SimpleDateFormat" class="headerlink" title="1.3 java.text.SimpleDateFormat"></a>1.3 <code>java.text.SimpleDateFormat</code></h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>SimpleDateFormat​(String pattern)</code></td>
<td>指定格式创建对象</td>
</tr>
<tr>
<td><code>String format​(Date date)</code></td>
<td>日期 → 字符串</td>
</tr>
<tr>
<td><code>Date parse​(String source)</code></td>
<td>字符串 → 日期</td>
</tr>
</tbody></table>
<h1 id="二-JDK8-的日期时间"><a href="#二-JDK8-的日期时间" class="headerlink" title="二 JDK8 的日期时间"></a>二 JDK8 的日期时间</h1><table>
<thead>
<tr>
<th>包</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>java.time</code></td>
<td>基础包，使用标准的 <code>iso-8601</code> 历法（公历）</td>
</tr>
<tr>
<td><code>java.time.format</code></td>
<td>格式化和解析日期时间</td>
</tr>
<tr>
<td><code>java.time.temporal</code></td>
<td>包括底层框架和扩展特性</td>
</tr>
<tr>
<td><code>java.time.chrono</code></td>
<td>提供对不同的日历系统的访问</td>
</tr>
<tr>
<td><code>java.time.zone</code></td>
<td>包含支持不同时区以及相关规定的类</td>
</tr>
</tbody></table>
<h1 id="三-java-time-包"><a href="#三-java-time-包" class="headerlink" title="三 java.time 包"></a>三 <code>java.time</code> 包</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>LocalDateTime</code></td>
<td>本地日期时间（不包含时区）</td>
</tr>
<tr>
<td><code>LocalDate</code></td>
<td>本地日期</td>
</tr>
<tr>
<td><code>LocalTime</code></td>
<td>本地时间</td>
</tr>
<tr>
<td><code>Instant</code></td>
<td>瞬时（时间戳），是 UTC 时间，没有时区概念</td>
</tr>
<tr>
<td><code>Period</code></td>
<td>日期间隔</td>
</tr>
<tr>
<td><code>Duration</code></td>
<td>时间间隔</td>
</tr>
<tr>
<td><code>ZoneOffset</code></td>
<td>时区偏移量</td>
</tr>
<tr>
<td><code>ZonedDateTime</code></td>
<td>指定时区的日期时间</td>
</tr>
<tr>
<td><code>ZoneId</code></td>
<td>包含了所有的时区信息，格式 <code>区域/城市</code></td>
</tr>
<tr>
<td><code>Clock</code></td>
<td>时钟</td>
</tr>
</tbody></table>
<h2 id="3-2-LocalDateTime-amp-LocalDate-amp-LocalTime"><a href="#3-2-LocalDateTime-amp-LocalDate-amp-LocalTime" class="headerlink" title="3.2 LocalDateTime &amp; LocalDate &amp; LocalTime"></a>3.2 <code>LocalDateTime &amp; LocalDate &amp; LocalTime</code></h2><h3 id="1-创建（now，of）"><a href="#1-创建（now，of）" class="headerlink" title="1 创建（now，of）"></a>1 创建（<code>now，of</code>）</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static LocalDateTime</code></td>
<td><code>now()</code></td>
<td>获取当前日期时间（默认时区）</td>
</tr>
<tr>
<td><code>static LocalDateTime</code></td>
<td><code>now​(ZoneId zone)</code></td>
<td>获取当前日期时间（指定时区）</td>
</tr>
<tr>
<td><code>static LocalDateTime</code></td>
<td><code>of(xxx)</code></td>
<td>获取指定日期时间（一系列重载）</td>
</tr>
</tbody></table>
<h3 id="2-获取（get）"><a href="#2-获取（get）" class="headerlink" title="2 获取（get）"></a>2 获取（<code>get</code>）</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>getYear()</code></td>
<td>获取年份</td>
</tr>
<tr>
<td><code>Month</code></td>
<td><code>getMonth()</code></td>
<td>获取月份（<code>Month</code> 是枚举类）</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getMonthValue()</code></td>
<td>获取一年中的第几个月 <code>1 ~ 12</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getDayOfYear()</code></td>
<td>获取一年中的第几天 <code>1 ~ 365/366</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getDayOfMonth()</code></td>
<td>获取一月中的第几天 <code>1 ~ 31</code></td>
</tr>
<tr>
<td><code>DayOfWeek</code></td>
<td><code>getDayOfWeek()</code></td>
<td>获取星期几（<code>DayOfWeek</code> 是枚举类）</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getHour()</code></td>
<td>获取时</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getMinute()</code></td>
<td>获取分</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getSecond()</code></td>
<td>获取秒</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getNano()</code></td>
<td>获取纳秒</td>
</tr>
</tbody></table>
<h3 id="3-格式化和解析（format，parse）"><a href="#3-格式化和解析（format，parse）" class="headerlink" title="3 格式化和解析（format，parse）"></a>3 格式化和解析（<code>format，parse</code>）</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>format​(DateTimeFormatter formatter)</code></td>
<td>日期时间转成指定格式的字符串</td>
</tr>
<tr>
<td><code>static LocalDateTime</code></td>
<td><code>parse​(CharSequence text)</code></td>
<td>解析默认格式字序列</td>
</tr>
<tr>
<td><code>static LocalDateTime</code></td>
<td><code>parse​(CharSequence text, DateTimeFormatter formatter)</code></td>
<td>解析指定格式字符序列</td>
</tr>
</tbody></table>
<h3 id="4-判断（is）"><a href="#4-判断（is）" class="headerlink" title="4 判断（is）"></a>4 判断（<code>is</code>）</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>isAfter​(ChronoLocalDate other)</code></td>
<td>是否在之后</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isBefore(ChronoLocalDate other)</code></td>
<td>是否在之前</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isEqual(ChronoLocalDate other)</code></td>
<td>是否相等</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isLeapYear()</code></td>
<td>是否是闰年</td>
</tr>
</tbody></table>
<h3 id="5-修改（with）"><a href="#5-修改（with）" class="headerlink" title="5 修改（with）"></a>5 修改（<code>with</code>）</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>LocalDateTime</code></td>
<td><code>with​(TemporalAdjuster adjuster)</code></td>
<td>将当前日期时间设置为校对器指定的日期时间</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>withYear(int year)</code></td>
<td>修改年</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>withMonth(int month)</code></td>
<td>修改月</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>withDayOfYear(int dayOfYear)</code></td>
<td>修改年第几天</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>withDayOfMonth(int dayOfMonth)</code></td>
<td>修改月第几天</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>withHour(int hour)</code></td>
<td>修改时</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>withMinute(int minute)</code></td>
<td>修改分</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>withSecond(int second)</code></td>
<td>修改秒</td>
</tr>
</tbody></table>
<h3 id="6-计算-plus，minus"><a href="#6-计算-plus，minus" class="headerlink" title="6 计算 plus，minus"></a>6 计算 <code>plus，minus</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>LocalDateTime</code></td>
<td><code>minus(TemporalAmount amountToSubtract)</code></td>
<td>减去一个 <code>Duration</code> 或 <code>Period</code></td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>plus(TemporalAmount amountToAdd)</code></td>
<td>添加一个 <code>Duration</code> 或 <code>Period</code></td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>plusYears(long years)</code></td>
<td>当前日期时间加指定年</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>plusMonths(long months)</code></td>
<td>当前日期时间加指定月</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>plusDays(long days)</code></td>
<td>当前日期时间加指定日</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>plusWeeks(long weeks)</code></td>
<td>当前日期时间加指定周</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>plusHours(long hours)</code></td>
<td>当前日期时间加指定时</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>plusMinutes(long minutes)</code></td>
<td>当前日期时间加指定分</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>plusSeconds(long seconds)</code></td>
<td>当前日期时间加指定秒</td>
</tr>
</tbody></table>
<h3 id="7-转换（to）"><a href="#7-转换（to）" class="headerlink" title="7 转换（to）"></a>7 转换（<code>to</code>）</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>toString()</code></td>
<td>获取字符串</td>
</tr>
<tr>
<td><code>LocalDate</code></td>
<td><code>toLocalDate()</code></td>
<td>获取日期</td>
</tr>
<tr>
<td><code>LocalTime</code></td>
<td><code>toLocalTime()</code></td>
<td>获取时间</td>
</tr>
</tbody></table>
<h2 id="3-3-Instant"><a href="#3-3-Instant" class="headerlink" title="3.3 Instant"></a>3.3 <code>Instant</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Instant</code></td>
<td><code>now()</code></td>
<td>获取当前UTC时间的时间戳</td>
</tr>
<tr>
<td><code>static Instant</code></td>
<td><code>ofEpochMilli​(long epochMilli)</code></td>
<td>获取指定毫秒值距元时间的时间戳</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toEpochMilli()</code></td>
<td>获取距元时间的毫秒数</td>
</tr>
<tr>
<td><code>OffsetDateTime</code></td>
<td><code>atOffset​(ZoneOffset offset)</code></td>
<td>结合时区偏移创建 <code>OffsetDateTime</code></td>
</tr>
</tbody></table>
<h2 id="3-4-Period"><a href="#3-4-Period" class="headerlink" title="3.4 Period"></a>3.4 <code>Period</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Period</code></td>
<td><code>between​(LocalDate startDateInclusive, LocalDate endDateExclusive)</code></td>
<td>获取两个日期的间隔对象  <code>Period</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getYears()</code></td>
<td>相隔年份</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getMonths()</code></td>
<td>相隔月份（只比较月字段）</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getDays()</code></td>
<td>相隔天数（只比较日字段）</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toTotalMonths()</code></td>
<td>相隔总月份</td>
</tr>
</tbody></table>
<h2 id="3-5-Duration"><a href="#3-5-Duration" class="headerlink" title="3.5 Duration"></a>3.5 <code>Duration</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Duration</code></td>
<td><code>between​(Temporal startInclusive, Temporal endExclusive)</code></td>
<td>获取两个时间的间隔对象  <code>Duration</code></td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toDays()</code></td>
<td>相隔总天数</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toHours()</code></td>
<td>相隔总小时数</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toMinutes()</code></td>
<td>相隔总分钟数</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toSeconds()</code></td>
<td>相隔总秒数</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toMillis()</code></td>
<td>相隔总毫秒数</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toNanos()</code></td>
<td>相隔总纳秒数</td>
</tr>
</tbody></table>
<h2 id="3-6-ZoneId"><a href="#3-6-ZoneId" class="headerlink" title="3.6 ZoneId"></a>3.6 <code>ZoneId</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Set&lt;String&gt;</code></td>
<td><code>getAvailableZoneIds()</code></td>
<td>获取所有时区ID，格式<code>区域/城市</code></td>
</tr>
<tr>
<td><code>static ZoneId</code></td>
<td><code>systemDefault()</code></td>
<td>获取系统默认时区</td>
</tr>
<tr>
<td><code>static ZoneId</code></td>
<td><code>of​(String zoneId)</code></td>
<td>根据时区ID获取时区</td>
</tr>
</tbody></table>
<h1 id="四-DateTimeFormatter"><a href="#四-DateTimeFormatter" class="headerlink" title="四 DateTimeFormatter"></a>四 <code>DateTimeFormatter</code></h1><h2 id="4-1-预定义标准格式"><a href="#4-1-预定义标准格式" class="headerlink" title="4.1 预定义标准格式"></a>4.1 预定义标准格式</h2><table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ISO_LOCAL_DATE_TIME</code></td>
<td><code>YYYY-MM-DD HH:MM:SS</code></td>
</tr>
<tr>
<td><code>ISO_LOCAL_DATE</code></td>
<td><code>YYYY-MM-DD</code></td>
</tr>
<tr>
<td><code>ISO_LOCAL_TIME</code></td>
<td><code>HH:MM:SS</code></td>
</tr>
<tr>
<td><code>...</code></td>
<td><code>...</code></td>
</tr>
</tbody></table>
<h2 id="4-2-本地化相关格式"><a href="#4-2-本地化相关格式" class="headerlink" title="4.2 本地化相关格式"></a>4.2 本地化相关格式</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static DateTimeFormatter</code></td>
<td><code>ofLocalizedDateTime​(FormatStyle dateTimeStyle)</code></td>
<td><code>FormatStyle</code> 是枚举类，其中 <code>FULL，LONG</code>适用于 <code>DateTime</code></td>
</tr>
<tr>
<td><code>static DateTimeFormatter</code></td>
<td><code>ofLocalizedDate​(FormatStyle dateStyle)</code></td>
<td><code>MEDIUM，SHORT</code> 适用于 <code>Date</code></td>
</tr>
<tr>
<td><code>static DateTimeFormatter</code></td>
<td><code>ofLocalizedTime​(FormatStyle timeStyle)</code></td>
<td><code>MEDIUM，SHORT</code> 适用于 <code>Time</code></td>
</tr>
</tbody></table>
<h2 id="4-3-自定义格式"><a href="#4-3-自定义格式" class="headerlink" title="4.3 自定义格式"></a>4.3 自定义格式</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static DateTimeFormatter</code></td>
<td><code>ofPattern​(String pattern)</code></td>
<td>使用自定义格式和默认地区</td>
</tr>
<tr>
<td><code>static DateTimeFormatter</code></td>
<td><code>ofPattern​(String pattern, Locale locale)</code></td>
<td>使用自定义格式和指定地区</td>
</tr>
</tbody></table>
<h1 id="五-TemporalAdjusters"><a href="#五-TemporalAdjusters" class="headerlink" title="五 TemporalAdjusters"></a>五 <code>TemporalAdjusters</code></h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol>
<li>时间校正器工具类</li>
<li>获取时间校正器对象，之后可以通过日期时间对象的 <code>with</code> 方法来调整</li>
</ol>
<h2 id="5-2-API"><a href="#5-2-API" class="headerlink" title="5.2 API"></a>5.2 API</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> TemporalAdjuster <span class="title">firstXxx</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> TemporalAdjuster <span class="title">lastXxx</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> TemporalAdjuster <span class="title">nextXxx</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> TemporalAdjuster <span class="title">previousXxx</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h1 id="六-新旧日期时间的转换"><a href="#六-新旧日期时间的转换" class="headerlink" title="六 新旧日期时间的转换"></a>六 新旧日期时间的转换</h1><table>
<thead>
<tr>
<th>旧类</th>
<th>新类</th>
<th>旧 → 新</th>
<th>新 → 旧</th>
</tr>
</thead>
<tbody><tr>
<td><code>java.util.Date</code></td>
<td><code>java.time.Instant</code></td>
<td><code>date.toInstant()</code></td>
<td><code>Date.from(instant)</code></td>
</tr>
<tr>
<td><code>java.sql.Timestamp</code></td>
<td><code>java.time.Instant</code></td>
<td><code>timestamp.toInstant()</code></td>
<td><code>Timestamp.from(instant)</code></td>
</tr>
<tr>
<td><code>java.sql.Timestamp</code></td>
<td><code>java.time.LocalDateTime</code></td>
<td><code>timestamp.toLocalDateTime()</code></td>
<td><code>Timestamp.valueOf(localDateTIme)</code></td>
</tr>
<tr>
<td><code>java.sql.Date</code></td>
<td><code>java.time.LocalDate</code></td>
<td><code>date.toLocalDate()</code></td>
<td><code>Date.valueOf(LocalDate)</code></td>
</tr>
<tr>
<td><code>java.sql.Time</code></td>
<td><code>java.time.LocalTime</code></td>
<td><code>time.toLocalTime()</code></td>
<td><code>TIme.valueOf(LocalTime)</code></td>
</tr>
</tbody></table>
<ol>
<li>旧转为新 <code>to</code></li>
<li>新转为旧 <code>from，valueOf</code></li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java-常用API</title>
    <url>/anyeansan.github.io/2020/09/29/Java/Java-%E5%B8%B8%E7%94%A8API/</url>
    <content><![CDATA[<h1 id="一-java-lang-Object"><a href="#一-java-lang-Object" class="headerlink" title="一 java.lang.Object"></a>一 <code>java.lang.Object</code></h1><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>hashCode()</code></td>
<td>返回该对象的哈希码值</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>equals(Object obj)</code></td>
<td>默认比较对象的地址值</td>
</tr>
<tr>
<td><code>Class&lt;?&gt;</code></td>
<td><code>getClass()</code></td>
<td>返回此对象的字节码对象</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>toString()</code></td>
<td><code>getClass().getName() + &#39;@&#39; + Integer.toHexString(hashCode())</code></td>
</tr>
<tr>
<td><code>protected Object</code></td>
<td><code>clone()</code></td>
<td>浅拷贝</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>wait()</code></td>
<td>无限等待直到被唤醒，相当于 <code>wait(0)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>wait(long timeoutMillis)</code></td>
<td>等待指定时间或被唤醒</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>wait(long timeoutMillis, int nanos)</code></td>
<td>等待指定时间或被唤醒</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>notify()</code></td>
<td>唤醒一个</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>notifyAll()</code></td>
<td>唤醒所有</td>
</tr>
</tbody></table>
<h2 id="1-1-和-equals"><a href="#1-1-和-equals" class="headerlink" title="1.1 ==  和  equals()"></a>1.1 <code>==</code>  和  <code>equals()</code></h2><table>
<thead>
<tr>
<th>比较符</th>
<th>基本数据类型</th>
<th>引用数据类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>==</code></td>
<td>比较值，<code>==</code> 是运算符所以同样适用基本类型运算时的类型转换 <code>byte short char -&gt; int -&gt; long -&gt; float -&gt; double</code></td>
<td>比较地址值</td>
</tr>
<tr>
<td><code>equals()</code></td>
<td>&nbsp;</td>
<td>比较地址值</td>
</tr>
</tbody></table>
<h2 id="1-2-重写-equals-时也要重写-hashCode"><a href="#1-2-重写-equals-时也要重写-hashCode" class="headerlink" title="1.2 重写 equals() 时也要重写 hashCode()"></a>1.2 重写 <code>equals()</code> 时也要重写 <code>hashCode()</code></h2><ol>
<li>判断元素是否相同：<ol>
<li>判断两个元素哈希值是否相同（判断的是对象的 <code>hashCode()</code></li>
<li>如果哈希值相同判断内容是否相同（判断的是对象的 <code>equals()</code>）</li>
</ol>
</li>
<li>两个对象相同则哈希值一定相同，如果只重写 <code>equals()</code> 方法，结果返回 <code>true</code> 时，<code>hashCode()</code> 返回值可能不一样</li>
</ol>
<h1 id="二-java-util-Objects"><a href="#二-java-util-Objects" class="headerlink" title="二 java.util.Objects"></a>二 <code>java.util.Objects</code></h1><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static boolean</code></td>
<td><code>equals​(Object a, Object b)</code></td>
<td>判断是否是同一对象</td>
</tr>
<tr>
<td><code>static boolean</code></td>
<td><code>isNull​(Object obj)</code></td>
<td>判断对象是否为空</td>
</tr>
<tr>
<td><code>static boolean</code></td>
<td><code>nonNull​(Object obj)</code></td>
<td>判断对象是否不为空</td>
</tr>
<tr>
<td><code>static &lt;T&gt; T</code></td>
<td><code>requireNonNull​(T obj [, String message])</code></td>
<td>如果对象不为空则返回，为空则抛空指针异常（可指定异常信息）</td>
</tr>
<tr>
<td><code>static &lt;T&gt; int</code></td>
<td><code>compare​(T a, T b, Comparator&lt;? super T&gt; c)</code></td>
<td>如果 <code>a==b</code> 返回 0，否则使用比较器比较</td>
</tr>
<tr>
<td><code>static String</code></td>
<td><code>toString​(Object o)</code></td>
<td>如果对象不为空则调用 <code>toString()</code>，为空则返回 <code>&quot;null&quot;</code></td>
</tr>
</tbody></table>
<h1 id="三-基本类型包装类"><a href="#三-基本类型包装类" class="headerlink" title="三 基本类型包装类"></a>三 基本类型包装类</h1><h2 id="3-1-包装类"><a href="#3-1-包装类" class="headerlink" title="3.1 包装类"></a>3.1 包装类</h2><table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类（<code>java.lang</code>）</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte</code></td>
<td><code>Byte</code></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>Short</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>Integer</code></td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>Long</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>Float</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>Double</code></td>
</tr>
<tr>
<td><code>char</code></td>
<td><code>Character</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>Boolean</code></td>
</tr>
</tbody></table>
<ul>
<li>除了 <code>Character</code> 和 <code>Boolean</code> 外，都是 <code>Number</code> 类的子类</li>
</ul>
<h2 id="3-2-自动装箱和拆箱"><a href="#3-2-自动装箱和拆箱" class="headerlink" title="3.2 自动装箱和拆箱"></a>3.2 自动装箱和拆箱</h2><ul>
<li>装箱：<code>基本数据类型 → 包装类对象</code></li>
<li>拆箱：<code>包装类对象 → 基本数据类型</code></li>
</ul>
<h2 id="3-3-包装类的缓存"><a href="#3-3-包装类的缓存" class="headerlink" title="3.3 包装类的缓存"></a>3.3 包装类的缓存</h2><table>
<thead>
<tr>
<th>包装类</th>
<th>缓存范围</th>
</tr>
</thead>
<tbody><tr>
<td><code>Boolean</code></td>
<td><code>true false</code></td>
</tr>
<tr>
<td><code>Byte Short Long</code></td>
<td><code>-128~127</code></td>
</tr>
<tr>
<td><code>Integer</code></td>
<td><code>-128~127</code>（上限可以调整）</td>
</tr>
<tr>
<td><code>Character</code></td>
<td><code>0~127</code> （最早的 ASCII 码的128个字符）</td>
</tr>
<tr>
<td><code>Double Float</code></td>
<td>没有缓存</td>
</tr>
</tbody></table>
<ul>
<li><p>自动装箱时，如果在缓存范围内，则不会创建新对象，而是使用缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">i1 == i2;	 <span class="comment">// false ，因为不是同一个对象</span></span><br><span class="line">i1.equals(i2); <span class="comment">// true ，Integer重写了equals方法，比较的是数值</span></span><br><span class="line"></span><br><span class="line">Integer i1 = <span class="number">127</span>;</span><br><span class="line">Integer i2 = <span class="number">127</span>;</span><br><span class="line">i1 == i2;	 <span class="comment">// true ，因为缓存，指向同一个地址</span></span><br><span class="line">i1.equals(i2); <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line">Integer i1 = <span class="number">128</span>;</span><br><span class="line">Integer i2 = <span class="number">128</span>;</span><br><span class="line">i1 == i2; <span class="comment">// false ，不在缓存范围，则需要重新 new 是两个不同的地址</span></span><br><span class="line">i1.equals(i2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-4-基本类型及其包装类与字符串的转换"><a href="#3-4-基本类型及其包装类与字符串的转换" class="headerlink" title="3.4 基本类型及其包装类与字符串的转换"></a>3.4 基本类型及其包装类与字符串的转换</h2><ol>
<li><code>int/Integer -&gt; string</code><ol>
<li><code>+ &quot;&quot;</code></li>
<li><code>toString()</code></li>
<li><code>String.valueOf()</code></li>
</ol>
</li>
<li><code>String -&gt; int/Integer</code><ol>
<li><code>Integer.parseInt(String s)</code></li>
</ol>
</li>
</ol>
<h1 id="四-比较器"><a href="#四-比较器" class="headerlink" title="四 比较器"></a>四 比较器</h1><h2 id="4-1-java-lang-Comparable"><a href="#4-1-java-lang-Comparable" class="headerlink" title="4.1 java.lang.Comparable"></a>4.1 <code>java.lang.Comparable</code></h2><ol>
<li>实现此接口的类具有比较性</li>
<li>实现 <code>int compareTo(T o)</code> 方法<ul>
<li>如果当前对象大于形参对象则返回正整数</li>
<li>如果当前对象等于形参对象则返回 0</li>
<li>如果当前对象小于形参对象则返回负整数</li>
</ul>
</li>
</ol>
<h2 id="4-2-java-util-Comparator"><a href="#4-2-java-util-Comparator" class="headerlink" title="4.2 java.util.Comparator"></a>4.2 <code>java.util.Comparator</code></h2><ol>
<li>比较器接口，实现此接口创建新的比较器</li>
<li>实现 <code>int compare(T o1, T o2)</code> 方法<ul>
<li><code>o1 &gt; o2</code> 返回正整数</li>
<li><code>o1 == o2</code> 返回 0</li>
<li><code>o1 &lt; o2</code> 返回负整数</li>
</ul>
</li>
</ol>
<h1 id="五-java-lang-System"><a href="#五-java-lang-System" class="headerlink" title="五 java.lang.System"></a>五 <code>java.lang.System</code></h1><h2 id="5-1-属性"><a href="#5-1-属性" class="headerlink" title="5.1 属性"></a>5.1 属性</h2><table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>in</code></td>
<td>标准输入</td>
</tr>
<tr>
<td><code>out</code></td>
<td>标准输出</td>
</tr>
<tr>
<td><code>err</code></td>
<td>标准错误输出</td>
</tr>
</tbody></table>
<h2 id="5-2-方法"><a href="#5-2-方法" class="headerlink" title="5.2 方法"></a>5.2 方法</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static long</code></td>
<td><code>currentTimeMillis()</code></td>
<td><code>1970-01-01 00:00:00</code> 到当前时间的毫秒值</td>
</tr>
<tr>
<td><code>static Properties</code></td>
<td><code>getProperties()</code></td>
<td>获取系统属性值</td>
</tr>
<tr>
<td><code>static String</code></td>
<td><code>getProperty(String key)</code></td>
<td>获取系统指定属性的值</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>gc()</code></td>
<td>运行垃圾回收器</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>exit(int status)</code></td>
<td>终止当前正在运行的 Java 虚拟机， <code>0</code> 表示正常终止，非 <code>0</code> 异常退出</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code></td>
<td>拷贝数组</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>setIn​(InputStream in)</code></td>
<td>重新分配标准输入</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>setOut​(PrintStream out)</code></td>
<td>重新分配标准输出</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>setErr​(PrintStream err)</code></td>
<td>重新分配标准错误输出</td>
</tr>
</tbody></table>
<h1 id="六-java-util-Scanner"><a href="#六-java-util-Scanner" class="headerlink" title="六 java.util.Scanner"></a>六 <code>java.util.Scanner</code></h1><h2 id="6-1-构造"><a href="#6-1-构造" class="headerlink" title="6.1 构造"></a>6.1 构造</h2><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Scanner(File source [, String charsetName])</code></td>
<td>扫描文件</td>
</tr>
<tr>
<td><code>Scanner​(InputStream source [, String charsetName])</code></td>
<td>扫描字节输入流</td>
</tr>
<tr>
<td><code>Scanner​(String source)</code></td>
<td>扫描字符串</td>
</tr>
</tbody></table>
<h2 id="6-2-方法"><a href="#6-2-方法" class="headerlink" title="6.2 方法"></a>6.2 方法</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>hasNext()</code></td>
<td>是否有下一个字符串</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>next()</code></td>
<td>获取下一个字符串，遇到空白符结束（空格 制表符 回车）</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>nextLine()</code></td>
<td>获取下一个字符串，遇到换行符结束</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>hasNextXxx()</code></td>
<td>是否有下一个指定类型的数据，<code>hasNextInt ()hasNextDouble() ...</code></td>
</tr>
<tr>
<td><code>Xxx</code></td>
<td><code>nextXxx()</code></td>
<td>获取下一个指定类型的数据，<code>nextInt() nextDouble() ...</code></td>
</tr>
</tbody></table>
<ul>
<li>当 <code>nextXxx()</code> 和 <code>nextLine()</code> 连用时的问题<ul>
<li>比如输入 <code>8</code> ，实际输入的是 <code>8\r\n</code>，而 <code>nextInt()</code> 读到 <code>8</code> 就结束了，下一个使用 <code>nextLine()</code> 读到 <code>\r\n</code> 直接就结束了</li>
</ul>
</li>
<li>解决<ol>
<li>在语句之后加一个 <code>nextLine()</code> 语句用来读取没有读到的 <code>\r\n</code></li>
<li>都使用 <code>nextLine()</code>，输入字符串，需要数字就转换。</li>
</ol>
</li>
</ul>
<h1 id="七-java-util-Random"><a href="#七-java-util-Random" class="headerlink" title="七 java.util.Random"></a>七 <code>java.util.Random</code></h1><h2 id="7-1-构造"><a href="#7-1-构造" class="headerlink" title="7.1 构造"></a>7.1 构造</h2><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Random()</code></td>
<td>默认种子是系统时间的纳秒值</td>
</tr>
<tr>
<td><code>Random​(long seed)</code></td>
<td>指定种子，种子相同，多次执行获得的随机数是一样的</td>
</tr>
</tbody></table>
<h2 id="7-2-方法"><a href="#7-2-方法" class="headerlink" title="7.2 方法"></a>7.2 方法</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>nextInt()</code></td>
<td>获取 int 范围内的随机数</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>nextInt(int bound)</code></td>
<td>获取 <code>0&lt; x &lt; bound</code> 的随机数</td>
</tr>
</tbody></table>
<h1 id="八-Arrays"><a href="#八-Arrays" class="headerlink" title="八 Arrays"></a>八 <code>Arrays</code></h1><h2 id="8-1-数组-→-集合"><a href="#8-1-数组-→-集合" class="headerlink" title="8.1 数组 → 集合"></a>8.1 数组 → 集合</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static &lt;T&gt; List&lt;T&gt;</code></td>
<td><code>asList(T... a)</code></td>
<td>数组 → <code>List</code></td>
</tr>
</tbody></table>
<ol>
<li>数组长度固定，所以转成的集合的增删方法不能使用</li>
<li>集合中只能存储引用数据类型，所以：<ul>
<li>如果数组中的元素是引用类型，则直接作为集合元素</li>
<li>如果数组中的元素是基本类型，则将数组作为集合元素</li>
</ul>
</li>
</ol>
<h2 id="8-2-二分查找"><a href="#8-2-二分查找" class="headerlink" title="8.2 二分查找"></a>8.2 二分查找</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static int</code></td>
<td><code>binarySearch(T[] a, T key)</code></td>
<td>找到则返回索引，没找到返回 <code>-插入点-1</code></td>
</tr>
<tr>
<td><code>static int</code></td>
<td><code>binarySearch(T[] a, int fromIndex, int toIndex, T key)</code></td>
<td>指定范围 <code>[from, to)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; int</code></td>
<td><code>binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c)</code></td>
<td>指定比较器</td>
</tr>
<tr>
<td><code>static &lt;T&gt; int</code></td>
<td><code>binarySearch(T[] a, int fromIndex, int toIndex, T key, Comparator&lt;? super T&gt; c)</code></td>
<td>指定比较器，并指定范围 <code>[from, to)</code></td>
</tr>
</tbody></table>
<h2 id="8-3-排序"><a href="#8-3-排序" class="headerlink" title="8.3 排序"></a>8.3 排序</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static void</code></td>
<td><code>sort(T[] a)</code></td>
<td>数组排序</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>sort(T[] a, int fromIndex, int toIndex)</code></td>
<td>指定范围 <code>[from, to)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; void</code></td>
<td><code>sort(T[] a, Comparator&lt;? super T&gt; c)</code></td>
<td>指定比较器</td>
</tr>
<tr>
<td><code>static &lt;T&gt; void</code></td>
<td><code>sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; c)</code></td>
<td>指定比较器，并指定范围 <code>[from, to)</code></td>
</tr>
</tbody></table>
<h2 id="8-4-复制"><a href="#8-4-复制" class="headerlink" title="8.4 复制"></a>8.4 复制</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static &lt;T&gt; T[]</code></td>
<td><code>copyOf(T[] original, int newLength)</code></td>
<td>将原数组复制到新数组并指定新数组长度，新数组长度大的话根据类型使用 <code>0 false null</code> 填充</td>
</tr>
<tr>
<td><code>static &lt;T&gt; T[]</code></td>
<td><code>copyOfRange(T[] original, int from, int to)</code></td>
<td>复制原数组指定内容到新数组</td>
</tr>
</tbody></table>
<h2 id="8-5-填充"><a href="#8-5-填充" class="headerlink" title="8.5 填充"></a>8.5 填充</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static void</code></td>
<td><code>fill(T[], T val)</code></td>
<td>将数组所有元素用 <code>val</code> 替换</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>fill(T[], int fromIndex, int toIndex, T val)</code></td>
<td>将数组 <code>[from, to)</code> 范围的元素用 <code>val</code> 替换</td>
</tr>
</tbody></table>
<h2 id="8-6-相等比较"><a href="#8-6-相等比较" class="headerlink" title="8.6 相等比较"></a>8.6 相等比较</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static boolean</code></td>
<td><code>equals(T[] a1, T[] a2)</code></td>
<td>比较两个数组的长度和元素是否相等</td>
</tr>
<tr>
<td><code>static boolean</code></td>
<td><code>deepEquals(Object[] a1, Object[] a2)</code></td>
<td>深度相等比较</td>
</tr>
</tbody></table>
<h2 id="8-7-toString"><a href="#8-7-toString" class="headerlink" title="8.7 toString"></a>8.7 <code>toString</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static String</code></td>
<td><code>toString(T[] arr)</code></td>
<td>将数组元素以 <code>[元素1, 元素2 ...]</code> 格式拼接成一个字符串</td>
</tr>
</tbody></table>
<h2 id="8-8-流"><a href="#8-8-流" class="headerlink" title="8.8 流"></a>8.8 流</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>static IntStream</code></td>
<td><code>stream(int[] array)</code></td>
</tr>
<tr>
<td><code>static IntStream</code></td>
<td><code>stream(int[] array, int startInclusive, int endExclusive)</code></td>
</tr>
<tr>
<td><code>static LongStream</code></td>
<td><code>stream(long[] array)</code></td>
</tr>
<tr>
<td><code>static LongStream</code></td>
<td><code>stream(long[] array, int startInclusive, int endExclusive)</code></td>
</tr>
<tr>
<td><code>static DoubleStream</code></td>
<td><code>stream(double[] array)</code></td>
</tr>
<tr>
<td><code>static DoubleStream</code></td>
<td><code>stream(double[] array, int startInclusive, int endExclusive)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td>
<td><code>stream(T[] array)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td>
<td><code>stream(T[] array, int startInclusive, int endExclusive)</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CS</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java-Stream</title>
    <url>/anyeansan.github.io/2020/09/29/Java/Java-Stream/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li><code>java.util.stream</code> 包</li>
<li>流：从支持数据处理操作的源生成的元素序列<ol>
<li>流不存储元素，只是对数据进行处理</li>
<li>流的操作不会修改数据源，而是返回一个持有结果的新流</li>
<li>惰性求值：流的中间操作形成一条流水线，但不会真正执行，只有在执行终端操作时才会一次性全部处理</li>
<li>流只能消费一次</li>
</ol>
</li>
<li>集合关注的是数据存储，与内存打交道</li>
<li>流关注的是数据运算，与CPU打交道</li>
</ol>
<h1 id="二-流的操作"><a href="#二-流的操作" class="headerlink" title="二 流的操作"></a>二 流的操作</h1><h2 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h2><ol>
<li>流水线</li>
<li>内部迭代<ul>
<li>使用集合：需要用户去做迭代，这称为外部迭代</li>
<li>使用流：数据处理完全是在库内部进行的，这称为内部迭代</li>
</ul>
</li>
</ol>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%86%85%E9%83%A8-%E5%A4%96%E9%83%A8%E8%BF%AD%E4%BB%A3.png" alt=""></p>
<h2 id="2-2-流程"><a href="#2-2-流程" class="headerlink" title="2.2 流程"></a>2.2 流程</h2><table>
<thead>
<tr>
<th>流程</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1 创建流</td>
<td>通过一个数据源（如：集合、数组），获取一个流</td>
</tr>
<tr>
<td>2 中间操作</td>
<td>对数据源的数据进行 n 次处理，多个中间操作形成操作链（在终端操作前，并不会真正执行中间操作链）</td>
</tr>
<tr>
<td>3 终端操作</td>
<td>一旦执行终端操作，就执行中间操作链，最终产生结果并结束流</td>
</tr>
</tbody></table>
<h1 id="三-创建流"><a href="#三-创建流" class="headerlink" title="三 创建流"></a>三 创建流</h1><h2 id="3-1-由值创建流：java-util-stream-Stream"><a href="#3-1-由值创建流：java-util-stream-Stream" class="headerlink" title="3.1 由值创建流：java.util.stream.Stream"></a>3.1 由值创建流：<code>java.util.stream.Stream</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td>
<td><code>ofNullable(T t)</code></td>
<td>若 <code>t</code> 为 <code>null</code> ，则返回空流，否则返回包含 <code>t</code> 的流</td>
</tr>
<tr>
<td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td>
<td><code>empty()</code></td>
<td>获取一个不包含任何元素的空流</td>
</tr>
<tr>
<td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td>
<td><code>of(T... values)</code></td>
<td>获取一个有限流，元素固定</td>
</tr>
<tr>
<td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td>
<td><code>generate(Supplier&lt;? extends T&gt; s)</code></td>
<td>获取一个无限流，元素通过反复调用 <code>s</code> 生成</td>
</tr>
<tr>
<td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td>
<td><code>iterate(T seed, UnaryOperator&lt;T&gt; f)</code></td>
<td>获取一个无限流，元素： <code>seed</code> 为初始值，之后依次由上一个值通过 <code>f</code> 生成下一个值</td>
</tr>
<tr>
<td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td>
<td><code>iterate(T seed, Predicate&lt;? super T&gt; hasNext, UnaryOperator&lt;T&gt; f)</code></td>
<td>获取一个有限流，和无限流的区别是会在某个元素不满足 <code>hasNext</code> 时停止</td>
</tr>
</tbody></table>
<h2 id="3-2-由集合创建流：-java-util-Collection-lt-E-gt"><a href="#3-2-由集合创建流：-java-util-Collection-lt-E-gt" class="headerlink" title="3.2 由集合创建流： java.util.Collection&lt;E&gt;"></a>3.2 由集合创建流： <code>java.util.Collection&lt;E&gt;</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>default Stream&lt;E&gt;</code></td>
<td><code>stream()</code></td>
<td>获取一个顺序流</td>
</tr>
<tr>
<td><code>default Stream&lt;E&gt;</code></td>
<td><code>parallelStream()</code></td>
<td>获取一个并行流</td>
</tr>
</tbody></table>
<h2 id="3-3-由数组创建流：java-util-Arrays"><a href="#3-3-由数组创建流：java-util-Arrays" class="headerlink" title="3.3 由数组创建流：java.util.Arrays"></a>3.3 由数组创建流：<code>java.util.Arrays</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td>
<td><code>stream(T[] array[, int start, int end])</code></td>
<td>获取 <code>Stream</code> 流，可指定范围 <code>[start, end)</code></td>
</tr>
<tr>
<td><code>static IntStream</code></td>
<td><code>stream(int[] array[, int start, int end])</code></td>
<td>获取 <code>IntStream</code> 流，可指定范围 <code>[start, end)</code></td>
</tr>
<tr>
<td><code>static LongStream</code></td>
<td><code>stream(long[] array[, int start, int end])</code></td>
<td>获取 <code>LongStream</code> 流，可指定范围 <code>[start, end)</code></td>
</tr>
<tr>
<td><code>static DoubleStream</code></td>
<td><code>stream(double[] array[, int start, int end])</code></td>
<td>获取 <code>DoubleStream</code> 流，可指定范围 <code>[start, end)</code></td>
</tr>
</tbody></table>
<h2 id="3-4-由文件生成流：java-nio-file-Files"><a href="#3-4-由文件生成流：java-nio-file-Files" class="headerlink" title="3.4 由文件生成流：java.nio.file.Files"></a>3.4 由文件生成流：<code>java.nio.file.Files</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Stream&lt;String&gt;</code></td>
<td><code>lines(Path path)</code></td>
<td>流元素为文件中的行，字符集默认为 <code>UTF-8</code></td>
</tr>
<tr>
<td><code>static Stream&lt;String&gt;</code></td>
<td><code>lines(Path path, Charset cs)</code></td>
<td>流元素为文件中的行，可指定字符集</td>
</tr>
</tbody></table>
<h1 id="四-中间操作"><a href="#四-中间操作" class="headerlink" title="四 中间操作"></a>四 中间操作</h1><h2 id="4-1-筛选和切片"><a href="#4-1-筛选和切片" class="headerlink" title="4.1 筛选和切片"></a>4.1 筛选和切片</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Stream&lt;T&gt;</code></td>
<td><code>filter(Predicate&lt;? super T&gt; predicate)</code></td>
<td>由所有符合条件的元素构成一个流</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt;</code></td>
<td><code>takeWhile(Predicate&lt;? super T&gt; predicate)</code></td>
<td>从第一个元素开始匹配，遇到不匹配就停止，由所有筛选出的元素构成一个流</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt;</code></td>
<td><code>dropWhile(Predicate&lt;? super T&gt; predicate)</code></td>
<td>从第一个元素开始匹配，由第一个不匹配的元素及其之后的所有元素构成一个流</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt;</code></td>
<td><code>distinct()</code></td>
<td>去重</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt;</code></td>
<td><code>limit(long maxSize)</code></td>
<td>限制数量</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt;</code></td>
<td><code>skip(long n)</code></td>
<td>跳过前 n 个元素，若数量不够则返回空流</td>
</tr>
</tbody></table>
<h2 id="4-2-排序"><a href="#4-2-排序" class="headerlink" title="4.2 排序"></a>4.2 排序</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Stream&lt;T&gt;</code></td>
<td><code>sorted()</code></td>
<td>自然排序</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt;</code></td>
<td><code>sorted​(Comparator&lt;? super T&gt; comparator)</code></td>
<td>定制排序</td>
</tr>
</tbody></table>
<h2 id="4-3-映射"><a href="#4-3-映射" class="headerlink" title="4.3 映射"></a>4.3 映射</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;R&gt; Stream&lt;R&gt;</code></td>
<td><code>map​(Function&lt;? super T,​? extends R&gt; mapper)</code></td>
<td>流中每个元素映射为一个新元素，所有新元素组成流，新旧流元素个数相同</td>
</tr>
<tr>
<td><code>&lt;R&gt; Stream&lt;R&gt;</code></td>
<td><code>flatMap​(Function&lt;? super T,​? extends Stream&lt;? extends R&gt;&gt; mapper)</code></td>
<td>流中每个元素都映射为一个流，所有流连接为一个新流（即映射成的每个流中的元素组成新流），新旧流元素个数可能不同</td>
</tr>
</tbody></table>
<h2 id="4-4-操作"><a href="#4-4-操作" class="headerlink" title="4.4 操作"></a>4.4 操作</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Stream&lt;T&gt;</code></td>
<td><code>peek​(Consumer&lt;? super T&gt; action)</code></td>
<td>流中元素不变，对每个元素进行一些操作</td>
</tr>
<tr>
<td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td>
<td><code>concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</code></td>
<td>由流 <code>a</code> 的一个元素后跟流 <code>b</code> 的一个元素组成的元素构成一个流</td>
</tr>
</tbody></table>
<h1 id="五-终止操作"><a href="#五-终止操作" class="headerlink" title="五 终止操作"></a>五 终止操作</h1><h2 id="5-1-迭代"><a href="#5-1-迭代" class="headerlink" title="5.1 迭代"></a>5.1 迭代</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>forEach​(Consumer&lt;? super T&gt; action)</code></td>
<td>迭代流中元素</td>
</tr>
<tr>
<td><code>Iterator&lt;T&gt;</code></td>
<td><code>iterator()</code></td>
<td>旧式迭代器</td>
</tr>
</tbody></table>
<h2 id="5-2-统计"><a href="#5-2-统计" class="headerlink" title="5.2 统计"></a>5.2 统计</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>long</code></td>
<td><code>count()</code></td>
<td>统计流中元素个数</td>
</tr>
</tbody></table>
<h2 id="5-3-匹配"><a href="#5-3-匹配" class="headerlink" title="5.3 匹配"></a>5.3 匹配</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>anyMatch​(Predicate&lt;? super T&gt; predicate)</code></td>
<td>是否有任意元素匹配</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>allMatch​(Predicate&lt;? super T&gt; predicate)</code></td>
<td>是否全部元素都匹配</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>noneMatch​(Predicate&lt;? super T&gt; predicate)</code></td>
<td>是否没有元素匹配</td>
</tr>
</tbody></table>
<h2 id="5-4-查找"><a href="#5-4-查找" class="headerlink" title="5.4 查找"></a>5.4 查找</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Optional&lt;T&gt;</code></td>
<td><code>findFirst()</code></td>
<td>返回流中第一个元素</td>
</tr>
<tr>
<td><code>Optional&lt;T&gt;</code></td>
<td><code>findAny()</code></td>
<td>返回流中任意一个元素（如果是稳定流，也返回第一个元素）</td>
</tr>
<tr>
<td><code>Optional&lt;T&gt;</code></td>
<td><code>max​(Comparator&lt;? super T&gt; comparator)</code></td>
<td>返回流中最大元素，使用给定比较器定义的排序规则</td>
</tr>
<tr>
<td><code>Optional&lt;T&gt;</code></td>
<td><code>min​(Comparator&lt;? super T&gt; comparator)</code></td>
<td>返回流中最小元素</td>
</tr>
</tbody></table>
<h2 id="5-5-归约"><a href="#5-5-归约" class="headerlink" title="5.5 归约"></a>5.5 归约</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Optional&lt;T&gt;</code></td>
<td><code>reduce​(BinaryOperator&lt;T&gt; accumulator)</code></td>
<td>元素1和元素2运算获取累计结果，结果再和下一个元素运算获取累计结果…，直到获取最终结果，由于流可能没有元素，所以返回 <code>Optional</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>reduce​(T identity, BinaryOperator&lt;T&gt; accumulator)</code></td>
<td>同上，只是指定一个初始元素，由于肯定有值，所以不用返回 <code>Optional</code></td>
</tr>
</tbody></table>
<h2 id="5-6-收集"><a href="#5-6-收集" class="headerlink" title="5.6 收集"></a>5.6 收集</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;R,A&gt; R</code></td>
<td><code>collect​(Collector&lt;? super T,​A,​R&gt; collector)</code></td>
<td>使用指定收集器收集流中元素</td>
</tr>
<tr>
<td><code>Object[]</code></td>
<td><code>toArray[]</code></td>
<td>收集到对象数组中</td>
</tr>
<tr>
<td><code>&lt;A&gt; A[]</code></td>
<td><code>toArray(IntFunction&lt;A[]&gt; generator)</code></td>
<td>传入 <code>A[]::new</code> 收集到 <code>A[]</code> 类型数组中</td>
</tr>
</tbody></table>
<h1 id="六-流收集器"><a href="#六-流收集器" class="headerlink" title="六 流收集器"></a>六 流收集器</h1><h2 id="6-1-收集器接口：Collector-lt-T-A-R-gt"><a href="#6-1-收集器接口：Collector-lt-T-A-R-gt" class="headerlink" title="6.1 收集器接口：Collector&lt;T,A,R&gt;"></a>6.1 收集器接口：<code>Collector&lt;T,A,R&gt;</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Supplier&lt;A&gt; <span class="title">supplier</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">BiConsumer&lt;A, T&gt; <span class="title">accumulator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Function&lt;A, R&gt; <span class="title">finisher</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">BinaryOperator&lt;A&gt; <span class="title">combiner</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span></span>;</span><br><span class="line">T：是流中要收集的元素的泛型。</span><br><span class="line">A：是累加器的类型，累加器是在收集过程中用于累积部分结果的对象。</span><br><span class="line">R 是收集操作得到的对象（通常但并不一定是集合）的类型</span><br></pre></td></tr></table></figure>

<h3 id="1-supplier：建立新的结果容器"><a href="#1-supplier：建立新的结果容器" class="headerlink" title="1 supplier：建立新的结果容器"></a>1 <code>supplier</code>：建立新的结果容器</h3><ol>
<li><code>supplier</code> 方法必须返回一个结果为空的 <code>Supplier</code> ，调用此 <code>Supplier</code> 时创建一个空的累加器实例（结果容器），供数据收集过程使用</li>
<li>累加器类型为 <code>A</code></li>
</ol>
<h3 id="2-accumulator：将元素添加到结果容器"><a href="#2-accumulator：将元素添加到结果容器" class="headerlink" title="2 accumulator：将元素添加到结果容器"></a>2 <code>accumulator</code>：将元素添加到结果容器</h3><ol>
<li><code>accumulator</code> 方法会返回执行归约操作的函数</li>
<li>返回的函数有两个参数（假设遍历到流中第 <code>n</code> 个元素）<ol>
<li>保存归约结果的累加器（已收集了流中的前 <code>n - 1</code> 个项目）</li>
<li>第 <code>n</code> 个元素本身</li>
</ol>
</li>
</ol>
<h3 id="3-finisher：对结果容器应用最终转换"><a href="#3-finisher：对结果容器应用最终转换" class="headerlink" title="3 finisher：对结果容器应用最终转换"></a>3 <code>finisher</code>：对结果容器应用最终转换</h3><ol>
<li>在遍历完流后， <code>finisher</code> 方法必须返回在累积过程的最后要调用的一个函数，以便将累加器对象转换为整个集合操作的最终结果</li>
<li>如果累加器对象恰好符合预期的最终结果，则无需进行转换，只需返回 <code>Function.identity()</code></li>
</ol>
<h3 id="4-combiner：合并两个结果容器"><a href="#4-combiner：合并两个结果容器" class="headerlink" title="4 combiner：合并两个结果容器"></a>4 <code>combiner</code>：合并两个结果容器</h3><ol>
<li><code>combiner</code> 方法会返回一个供归约操作使用的函数，它定义了对流的各个子部分进行并行处理时，各个子部分归约所得的累加器要如何合并</li>
<li>并行流使用，将多个线程产生的结果容器合并</li>
</ol>
<h3 id="5-characteristics"><a href="#5-characteristics" class="headerlink" title="5 characteristics"></a>5 <code>characteristics</code></h3><ol>
<li><code>characteristics</code> 会返回一个不可变的 <code>Characteristics</code> 集合，它定义了收集器的行为——尤其是关于流是否可以并行归约，以及可以使用哪些优化的提示</li>
<li><code>Characteristics</code> 是一个包含三个项目的枚举<ul>
<li><code>UNORDERED</code><ul>
<li>归约结果不受流中元素的遍历和累积顺序的影响</li>
</ul>
</li>
<li><code>CONCURRENT</code><ul>
<li><code>accumulator</code> 函数可以从多个线程同时调用，且该收集器可以并行归约流</li>
<li>如果收集器没有标为 <code>UNORDERED</code> ，那它仅在用于无序数据源时才可以并行归约</li>
</ul>
</li>
<li><code>IDENTITY_FINISH</code><ul>
<li>表明完成器方法返回的函数是一个恒等函数，可以跳过。</li>
<li>这种情况下，累加器对象将会直接用作归约过程的最终结果。这也意味着，将累加器 <code>A</code> 不加检查地转换为结果 <code>R</code> 是安全的</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="6-2-预定于收集器：Collectors"><a href="#6-2-预定于收集器：Collectors" class="headerlink" title="6.2 预定于收集器：Collectors"></a>6.2 预定于收集器：<code>Collectors</code></h2><h3 id="1-收集"><a href="#1-收集" class="headerlink" title="1 收集"></a>1 收集</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()</span><br><span class="line">toMap()</span><br><span class="line">toConcurrentMap()</span><br><span class="line"><span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt; Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>toList</code></td>
<td><code>List&lt;T&gt;</code></td>
<td>把流中所有项目收集到一个 List（类型不确定）</td>
</tr>
<tr>
<td><code>toSet</code></td>
<td><code>Set&lt;T&gt;</code></td>
<td>把流中所有项目收集到一个 Set（类型不确定），删除重复项</td>
</tr>
<tr>
<td><code>toCollection</code></td>
<td><code>Collection&lt;T&gt;</code></td>
<td>把流中所有项目收集到给定的供应源创建的集合，既可以指定集合具体类型</td>
</tr>
</tbody></table>
<h3 id="2-归约和汇总"><a href="#2-归约和汇总" class="headerlink" title="2 归约和汇总"></a>2 归约和汇总</h3><h4 id="1-统计个数，最小-大值"><a href="#1-统计个数，最小-大值" class="headerlink" title="1 统计个数，最小/大值"></a>1 统计个数，最小/大值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Long&gt; counting()</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; minBy(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>counting</code></td>
<td><code>Long</code></td>
<td>计算流中元素的个数</td>
</tr>
<tr>
<td><code>minBy</code></td>
<td><code>Optional&lt;T&gt;</code></td>
<td>一个包裹了流中按照给定比较器选出的最小元素的 <code>Optional</code> ，或如果流为空则为 <code>Optional.empty()</code></td>
</tr>
<tr>
<td><code>maxBy</code></td>
<td><code>Optional&lt;T&gt;</code></td>
<td>一个包裹了流中按照给定比较器选出的最大元素的 <code>Optional</code> ，或如果流为空则为 <code>Optional.empty()</code></td>
</tr>
</tbody></table>
<h4 id="2-和-平均值"><a href="#2-和-平均值" class="headerlink" title="2 和/平均值"></a>2 和/平均值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Long&gt; summingLong(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; summingDouble(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingLong(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>summingInt</code></td>
<td><code>Integer</code></td>
<td>对流中元素的一个整数属性求和</td>
</tr>
<tr>
<td><code>summingLong</code></td>
<td><code>Long</code></td>
<td>对流中元素的一个长整型属性求和</td>
</tr>
<tr>
<td><code>summingDouble</code></td>
<td><code>Double</code></td>
<td>对流中元素的一个浮点型属性求和</td>
</tr>
<tr>
<td><code>averagingInt</code></td>
<td><code>Double</code></td>
<td>对流中元素的一个整数属性求平均值</td>
</tr>
<tr>
<td><code>averagingLong</code></td>
<td><code>Double</code></td>
<td>对流中元素的一个长整型属性求平均值</td>
</tr>
<tr>
<td><code>averagingDouble</code></td>
<td><code>Double</code></td>
<td>对流中元素的一个浮点型属性求平均值</td>
</tr>
</tbody></table>
<h4 id="3-统计个数-最小-大值-和-平均值"><a href="#3-统计个数-最小-大值-和-平均值" class="headerlink" title="3 统计个数 + 最小/大值 + 和/平均值"></a>3 统计个数 + 最小/大值 + 和/平均值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, LongSummaryStatistics&gt; summarizingLong(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, DoubleSummaryStatistics&gt; summarizingDouble(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>summarizingInt</code></td>
<td><code>IntSummaryStatistics</code></td>
<td>收集流中元素统计个数 + 最小/大值 + 和/平均值</td>
</tr>
<tr>
<td><code>summarizingLong</code></td>
<td><code>LongSummaryStatistics</code></td>
<td>收集流中元素统计个数 + 最小/大值 + 和/平均值</td>
</tr>
<tr>
<td><code>summarizingDouble</code></td>
<td><code>DoubleSummaryStatistics</code></td>
<td>收集流中元素统计个数 + 最小/大值 + 和/平均值</td>
</tr>
</tbody></table>
<ul>
<li><p>返回类型中提供了相应的 <code>getter</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getCount()</span><br><span class="line">getMin()</span><br><span class="line">getMax()</span><br><span class="line">getSum()</span><br><span class="line">getAverage()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="4-连接字符串"><a href="#4-连接字符串" class="headerlink" title="4 连接字符串"></a>4 连接字符串</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static Collector&lt;CharSequence, ?, String&gt; joining()</span><br><span class="line">static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter)</span><br><span class="line">static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>joining</code></td>
<td><code>String</code></td>
<td>连接对流中每个元素调用 <code>toString</code> 方法所生成的字符串，可指定分隔符、前缀、后缀</td>
</tr>
</tbody></table>
<h4 id="5-广义的归约汇总"><a href="#5-广义的归约汇总" class="headerlink" title="5 广义的归约汇总"></a>5 广义的归约汇总</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; reducing(BinaryOperator&lt;T&gt; op)</span><br><span class="line">static &lt;T&gt; Collector&lt;T, ?, T&gt; reducing(T identity, BinaryOperator&lt;T&gt; op)</span><br><span class="line">static &lt;T, U&gt; Collector&lt;T, ?, U&gt; reducing(U identity, Function&lt;? super T, ? extends U&gt; mapper, BinaryOperator&lt;U&gt; op)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>reducing</code></td>
<td>归约操作产生的类型</td>
<td>从一个作为累加器的初始值开始，利用 <code>BinaryOperator</code> 与流中的元素逐个结合，从而将流归约为单个值</td>
</tr>
</tbody></table>
<ol>
<li>以上所有归约和汇总收集器都是 <code>reducing</code> 工厂方法定义的归约过程的特殊情况而已，仅仅是为了方便程序员使用而已</li>
<li>三个参数<ul>
<li>初始值</li>
<li>转换函数</li>
<li>累计函数</li>
</ul>
</li>
</ol>
<h3 id="3-分组"><a href="#3-分组" class="headerlink" title="3 分组"></a>3 分组</h3><h4 id="1-分组"><a href="#1-分组" class="headerlink" title="1 分组"></a>1 分组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一级分组：根据 T 的某个属性 K 分组，返回 Map&lt;K, list&lt;T&gt;&gt;</span></span><br><span class="line"><span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier)</span><br><span class="line"><span class="comment">// 多级分组：根据 T 的某个属性 K 分组，返回 Map&lt;K, list&lt;T&gt;&gt;，之后使用第三个参数队属性 K 收集，返回 Map&lt;K, D&gt;</span></span><br><span class="line"><span class="keyword">static</span> &lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier, Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream)</span><br><span class="line"><span class="comment">// 多级分组：可以自己提供 Map 类型</span></span><br><span class="line"><span class="keyword">static</span> &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt; Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier, Supplier&lt;M&gt; mapFactory, Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>groupingBy</code></td>
<td><code>Map&lt;K, List&lt;T&gt;&gt;</code></td>
<td>根据元素某个属性映射的值分组，并作为键，元素收集到 <code>List</code> 中作为值（单参数的 <code>groupingBy</code> 其实第二个参数省略了 <code>Collectors.toList()</code>）</td>
</tr>
<tr>
<td><code>groupingBy</code></td>
<td><code>Map&lt;K, D&gt;</code></td>
<td>根据元素某个属性映射的值分组，并作为键，第二个收集器返回值作为值</td>
</tr>
</tbody></table>
<ul>
<li><code>groupingByConcurrent</code> 返回的是 <code>ConcurrentMap</code></li>
</ul>
<h4 id="2-常与分组联合使用的收集器"><a href="#2-常与分组联合使用的收集器" class="headerlink" title="2 常与分组联合使用的收集器"></a>2 常与分组联合使用的收集器</h4><h5 id="1-collectingAndThen"><a href="#1-collectingAndThen" class="headerlink" title="1 collectingAndThen"></a>1 <code>collectingAndThen</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 将第一个参数（旧收集器）的结果传入第二个参数（转换函数）返回新的类型</span><br><span class="line">static &lt;T, A, R, RR&gt; Collector&lt;T, A, RR&gt; collectingAndThen(Collector&lt;T, A, R&gt; downstream, Function&lt;R, RR&gt; finisher)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>collectingAndThen</code></td>
<td>转换函数返回的类型</td>
<td>包裹另一个收集器，对其结果应用转换函数</td>
</tr>
</tbody></table>
<h5 id="2-mapping"><a href="#2-mapping" class="headerlink" title="2 mapping"></a>2 <code>mapping</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static &lt;T, U, A, R&gt; Collector&lt;T, ?, R&gt; mapping(Function&lt;? super T, ? extends U&gt; mapper, Collector&lt;? super U, A, R&gt; downstream)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>mapping</code></td>
<td>转换函数返回的类型</td>
<td>原收集器中的每个元素映射为一个新值，并使用一个新收集器收集</td>
</tr>
</tbody></table>
<h3 id="4-分区"><a href="#4-分区" class="headerlink" title="4 分区"></a>4 分区</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一级分区</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span><br><span class="line"><span class="comment">// 多级分区</span></span><br><span class="line"><span class="keyword">static</span> &lt;T, D, A&gt; Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate, Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>partitioningBy</code></td>
<td><code>Map&lt;Boolean,List&lt;T&gt;&gt;</code></td>
<td>根据对流中每个元素应用谓词的结果来对元素进行分区</td>
</tr>
</tbody></table>
<ol>
<li>分区是分组的特殊情况：由一个谓词（返回一个布尔值的函数）作为分类函数，它称分区函数</li>
<li>分区函数返回一个布尔值，这意味着得到的分组 Map 的键类型是 <code>Boolean</code> ，即最多可以分为两组—— <code>true</code> 是一组， <code>false</code> 是一组</li>
</ol>
<h1 id="七-基本类型流"><a href="#七-基本类型流" class="headerlink" title="七 基本类型流"></a>七 基本类型流</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ol>
<li>流操作基本类型时暗含装箱操作，Java8 提供了基本类型流来解决<ol>
<li><code>IntStream</code>：<code>byte short char int boolean</code></li>
<li><code>DoubleStream</code>：<code>float double</code></li>
<li><code>LongStream</code>：<code>long</code></li>
</ol>
</li>
<li><code>IntStream DoubleStream LongStream</code> 分别将流中的元素转为 <code>int double long</code> ，从而避免了暗含的装箱成本，且每个接口有新的常用数值归约方法以及转回对象流的方法</li>
</ol>
<h2 id="7-2-对象流与基本类型流的转换"><a href="#7-2-对象流与基本类型流的转换" class="headerlink" title="7.2 对象流与基本类型流的转换"></a>7.2 对象流与基本类型流的转换</h2><h3 id="1-对象流-→-基本类型流"><a href="#1-对象流-→-基本类型流" class="headerlink" title="1 对象流 → 基本类型流"></a>1 对象流 → 基本类型流</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">IntStream <span class="title">mapToInt</span><span class="params">(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span></span><br><span class="line"><span class="function">DoubleStream <span class="title">mapToDouble</span><span class="params">(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span></span><br><span class="line"><span class="function">LongStream <span class="title">mapToLong</span><span class="params">(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-基本类型流-→-对象流"><a href="#2-基本类型流-→-对象流" class="headerlink" title="2 基本类型流 → 对象流"></a>2 基本类型流 → 对象流</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Stream&lt;Integer&gt; <span class="title">boxed</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Stream&lt;Double&gt; <span class="title">boxed</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Stream&lt;Long&gt; <span class="title">boxed</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&lt;U&gt; Stream&lt;U&gt; <span class="title">mapToObj</span><span class="params">(IntFunction&lt;? extends U&gt; mapper)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="7-3-IntStream"><a href="#7-3-IntStream" class="headerlink" title="7.3 IntStream"></a>7.3 <code>IntStream</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static IntStream</code></td>
<td><code>range(int start, int end)</code></td>
<td><code>[start, end)</code> 范围内数值构成流</td>
</tr>
<tr>
<td><code>static IntStream</code></td>
<td><code>rangeClosed(int start, int end)</code></td>
<td><code>[start, end]</code> 范围内数值构成流</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>sum()</code></td>
<td>求和</td>
</tr>
<tr>
<td><code>OptionalInt</code></td>
<td><code>max()</code></td>
<td>求最大值</td>
</tr>
<tr>
<td><code>OptionalInt</code></td>
<td><code>min()</code></td>
<td>求最小值</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>count()</code></td>
<td>统计个数</td>
</tr>
</tbody></table>
<h1 id="八-并行流"><a href="#八-并行流" class="headerlink" title="八 并行流"></a>八 并行流</h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><ol>
<li>并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流</li>
<li>并行流背后使用的基础架构是 Java 7 中引入的分支/合并框架（<code>Fork/Join</code>）</li>
</ol>
<h2 id="8-2-转换"><a href="#8-2-转换" class="headerlink" title="8.2 转换"></a>8.2 转换</h2><ol>
<li><code>parallel()</code>：顺序流 → 并行流</li>
<li><code>sequential()</code>：并行流 → 顺序流</li>
</ol>
<h2 id="8-3-Spliterator-lt-T-gt"><a href="#8-3-Spliterator-lt-T-gt" class="headerlink" title="8.3 Spliterator&lt;T&gt;"></a>8.3 <code>Spliterator&lt;T&gt;</code></h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/spliterator.png" alt=""></p>
<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>Spliterator</code> 是 Java 8中加入的一个新接口；这个名字代表“可分迭代器”（<code>splitable iterator</code>）</li>
<li>和 <code>Iterator</code> 一样， <code>Spliterator</code> 也用于遍历数据源中的元素，但它是为了并行执行而设计的</li>
<li>Java 8 为集合框架中包含的所有数据结构提供了一个默认的 <code>Spliterator</code> 实现</li>
</ol>
<h3 id="2-API"><a href="#2-API" class="headerlink" title="2 API"></a>2 API</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>tryAdvance(Consumer&lt;? super T&gt; action)</code></td>
<td>按顺序一个一个使用 <code>Spliterator</code> 中的元素，并且如果还有元素要遍历就返回 <code>true</code></td>
</tr>
<tr>
<td><code>Spliterator&lt;T&gt;</code></td>
<td><code>trySplit()</code></td>
<td>把一些元素划出去分给第二个 <code>Spliterator</code> （由该方法返回），让它们两个并行处理。当返回 <code>null</code> 时 ，表明它处理的数据结构不能再分割</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>estimateSize()</code></td>
<td>估计还剩下多少元素要遍历</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>characteristics()</code></td>
<td>返回一个 <code>int</code> ，代表 <code>Spliterator</code> 本身特性集的编码</td>
</tr>
</tbody></table>
<h3 id="3-特性"><a href="#3-特性" class="headerlink" title="3 特性"></a>3 特性</h3><table>
<thead>
<tr>
<th>特性 <code>int</code></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ORDERED</code></td>
<td>元素有既定的顺序（例如 <code>List</code> ），因此 <code>Spliterator</code> 在遍历和划分时也会遵循这一顺序</td>
</tr>
<tr>
<td><code>DISTINCT</code></td>
<td>对于任意一对遍历过的元素 x 和 y ， <code>x.equals(y)</code> 返回 <code>false</code></td>
</tr>
<tr>
<td><code>SORTED</code></td>
<td>遍历的元素按照一个预定义的顺序排序</td>
</tr>
<tr>
<td><code>SIZED</code></td>
<td>该 <code>Spliterator</code> 由一个已知大小的源建立（例如 <code>Set</code> ），因此 <code>estimatedSize()</code> 返回的是准确值</td>
</tr>
<tr>
<td><code>NONNULL</code></td>
<td>保证遍历的元素不会为 <code>null</code></td>
</tr>
<tr>
<td><code>IMMUTABLE</code></td>
<td><code>Spliterator</code> 的数据源不能修改。这意味着在遍历时不能添加、删除或修改任何元素</td>
</tr>
<tr>
<td><code>CONCURRENT</code></td>
<td>该 <code>Spliterator</code> 的数据源可以被其他线程同时修改而无需同步</td>
</tr>
<tr>
<td><code>SUBSIZED</code></td>
<td>该 <code>Spliterator</code> 和所有从它拆分出来的 <code>Spliterator</code> 都是 <code>SIZED</code></td>
</tr>
</tbody></table>
<h1 id="九-java-util-Optional-lt-T-gt"><a href="#九-java-util-Optional-lt-T-gt" class="headerlink" title="九 java.util.Optional&lt;T&gt;"></a>九 <code>java.util.Optional&lt;T&gt;</code></h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><ol>
<li><code>Optional&lt;T&gt;</code> 是一种包装器对象，且只包装一个对象：<code>T</code> 或 <code>null</code><ul>
<li>对象存在时，则返回封装对象的 <code>Optional</code></li>
<li>对象不存在时，由方法 <code>Optional.empty()</code> 返回一个空的 <code>Optional</code></li>
</ul>
</li>
<li>使用原则<ul>
<li>不能为 <code>null</code> 的属性正常声明 <code>T</code></li>
<li>可能为 <code>null</code> 的属性声明为 <code>Optional&lt;T&gt;</code></li>
</ul>
</li>
<li><code>Optional&lt;T&gt;</code> 也有三个基本类型版本：<code>OptionalInt、OptionalDouble、OptionalLong</code></li>
</ol>
<h2 id="9-2-API"><a href="#9-2-API" class="headerlink" title="9.2 API"></a>9.2 API</h2><h3 id="1-创建-Optional"><a href="#1-创建-Optional" class="headerlink" title="1 创建 Optional"></a>1 创建 <code>Optional</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static &lt;T&gt; Optional&lt;T&gt;</code></td>
<td><code>empty()</code></td>
<td>返回空的 <code>Optional</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; Optional&lt;T&gt;</code></td>
<td><code>of​(T t)</code></td>
<td>将指定值用 <code>Optional</code> 封装之后返回，如果该值为 <code>null</code> ，则抛出一个 <code>NullPointerException</code> 异常</td>
</tr>
<tr>
<td><code>static &lt;T&gt; Optional&lt;T&gt;</code></td>
<td><code>ofNullable​(T t)</code></td>
<td>将指定值用 <code>Optional</code> 封装之后返回，如果该值为 <code>null</code> ，则返回一个空的 <code>Optional</code> 对象</td>
</tr>
</tbody></table>
<h3 id="2-获取-Optional-容器中的值"><a href="#2-获取-Optional-容器中的值" class="headerlink" title="2 获取 Optional 容器中的值"></a>2 获取 <code>Optional</code> 容器中的值</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>T</code></td>
<td><code>get()</code></td>
<td>如果值存在则返回，否则抛 <code>NoSuchElementException</code> 异常</td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>orElse​(T other)</code></td>
<td>如果值存在则返回，否则返回 <code>other</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>orElseGet​(Supplier&lt;? extends T&gt; supplier)</code></td>
<td>如果值存在则返回，否则返回由 <code>Supplier</code> 提供的值</td>
</tr>
<tr>
<td><code>&lt;X extends Throwable&gt; T</code></td>
<td><code>orElseThrow​(Supplier&lt;? extends X&gt; exceptionSupplier)</code></td>
<td>如果值存在则返回，否则抛出由 <code>Supplier</code> 提供的异常</td>
</tr>
</tbody></table>
<h3 id="3-操作-Optional-中的值"><a href="#3-操作-Optional-中的值" class="headerlink" title="3 操作 Optional 中的值"></a>3 操作 <code>Optional</code> 中的值</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>isPresent()</code></td>
<td>如果值存在就返回 <code>true</code> ，否则返回 <code>false</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>ifPresent​(Consumer&lt;? super T&gt; action)</code></td>
<td>如果值存在则传递给 <code>action</code> 执行；否则就不进行任何操作</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)</code></td>
<td>如果值存在则传递给 <code>action</code> 执行；否则调用 <code>emptyAction</code></td>
</tr>
<tr>
<td><code>&lt;U&gt; Optional&lt;U&gt;</code></td>
<td><code>map​(Function&lt;? super T,​? extends U&gt; mapper)</code></td>
<td>如果值存在则映射一个新值（如果映射值为 <code>null</code> 会空指针异常），然后返回存储新值的 <code>Optional</code>；否则返回空的 <code>Optional</code></td>
</tr>
<tr>
<td><code>&lt;U&gt; Optional&lt;U&gt;</code></td>
<td><code>flatMap​(Function&lt;? super T,​? extends Optional&lt;? extends U&gt;&gt; mapper)</code></td>
<td><code>map</code> 方法的问题在于如果映射成的值还是一个 <code>Optional</code>，会形成多层 <code>Optional&lt;Optional&lt;T&gt;&gt;</code>，此方法能将多层的 <code>Optional</code> 合并为一个</td>
</tr>
<tr>
<td><code>Optional&lt;T&gt;</code></td>
<td><code>filter​(Predicate&lt;? super T&gt; predicate)</code></td>
<td>如果值存在并且满足提供的谓词，就返回包含该值的 <code>Optional</code> 对象；否则返回空的 <code>Optional</code> 对象</td>
</tr>
<tr>
<td><code>Optional&lt;T&gt;</code></td>
<td><code>or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</code></td>
<td>如果值存在，则返回存储此值的 <code>Optional</code>，否则返回由 <code>Supplier</code> 提供的 <code>Optional</code></td>
</tr>
</tbody></table>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/flatmap.png" alt=""></p>
<h3 id="4-其它"><a href="#4-其它" class="headerlink" title="4 其它"></a>4 其它</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Stream&lt;T&gt;</code></td>
<td><code>stream()</code></td>
<td>如果值存在则获取只包含此元素的流，否则获取空流</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CS</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java-Lambda</title>
    <url>/anyeansan.github.io/2020/09/29/Java/Java-Lambda/</url>
    <content><![CDATA[<h1 id="一-Lambda-概述"><a href="#一-Lambda-概述" class="headerlink" title="一 Lambda 概述"></a>一 Lambda 概述</h1><ol>
<li>Lambda 是一个匿名函数，但在 Java 中 Lambda 表达式的本质是函数式接口的一个实例，也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用 Lambda 表达式来表示</li>
<li>Lambda 需要函数式接口的支持</li>
<li>闭包<ol>
<li>在 Lambda 表达式中引用了局部变量，会形成闭包，延长局部变量声明周期</li>
<li>此被引用的局部变量会变成 <code>final</code> 的</li>
</ol>
</li>
</ol>
<h1 id="二-Lambda-语法"><a href="#二-Lambda-语法" class="headerlink" title="二 Lambda 语法"></a>二 Lambda 语法</h1><h2 id="2-1-基础语法"><a href="#2-1-基础语法" class="headerlink" title="2.1 基础语法"></a>2.1 基础语法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(形参列表) -&gt; &#123;方法体&#125;</span><br><span class="line"><span class="comment">// 形参列表：对应函数式接口中抽象方法的形参列表</span></span><br><span class="line"><span class="comment">// 方法体：即重写的函数式接口中抽象方法的方法体</span></span><br></pre></td></tr></table></figure>

<ol>
<li>参数类型可以省略（类型推断）</li>
<li>当且仅当参数只有一个时，可以省略小括号</li>
<li>如果方法体只有一句，可以省略大括号</li>
<li>如果方法体只有一句且是返回语句，大括号和 <code>return</code> 要一致<ul>
<li>省略大括号的同时必须省略 <code>return</code> 关键字</li>
<li>不省略大括号那么也不能省略 <code>return</code> 关键字</li>
</ul>
</li>
</ol>
<h2 id="2-2-方法引用"><a href="#2-2-方法引用" class="headerlink" title="2.2 方法引用"></a>2.2 方法引用</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><p>方法引用即将 Lambda 表达式的实现指向一个已经实现的方法，也就是说通过调用一个现有的方法来完成功能</p>
</li>
<li><p>方法引用其实返回的就是一个函数式接口的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只要符合条件就能当成对应函数式接口的实例</span></span><br><span class="line"><span class="comment">// 所谓的符合条件：引用的方法与函数式接口的抽象方法有着相同形参和返回值，比如接收一个类型的参数，返回另一个类型...</span></span><br><span class="line">Consumer consumer = System.out::println;</span><br><span class="line">Runable runable = System.out::println;</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件</p>
<ol>
<li>引用方法的形参列表（数量、顺序和类型）必须与接口中的方法一致<ul>
<li>特殊情况：接口中方法的第一个形参是方法的调用者，剩余形参与引用方法一致（即指向类的实例方法的方法引用）</li>
</ul>
</li>
<li>引用方法的返回值必须和接口中的方法一致</li>
</ol>
</li>
</ol>
<h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2 语法"></a>2 语法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line">方法隶属者::方法名</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有三种使用情况</span></span><br><span class="line">对象::实例方法名</span><br><span class="line">类::静态方法名</span><br><span class="line">类::实例方法名</span><br></pre></td></tr></table></figure>

<ol>
<li><p>指向对象的实例方法的方法引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(args) -&gt; expr.instanceMethod(args)</span><br><span class="line">expr::instanceMethod</span><br></pre></td></tr></table></figure>
</li>
<li><p>指向类的静态方法的方法引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(args) -&gt; ClassName.staticMethod(args)</span><br><span class="line">CLassName::staticMethod</span><br></pre></td></tr></table></figure>
</li>
<li><p>指向类的实例方法的方法引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(arg0, rest) -&gt; arg0.instanceMethod(rest)</span><br><span class="line">CLassName::instanceMethod</span><br><span class="line"><span class="comment">// arg0 是 ClassName 类型的实例，即是实例方法的调用者又是方法的第一个参数</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="2-3-构造器引用"><a href="#2-3-构造器引用" class="headerlink" title="2.3 构造器引用"></a>2.3 构造器引用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类::<span class="keyword">new</span></span><br></pre></td></tr></table></figure>

<ol>
<li>构造器形参列表要与函数式接口中抽象方法的形参列表一致</li>
<li>新创建的对象与函数式接口中抽象方法的返回值一致</li>
</ol>
<h2 id="2-4-数组引用"><a href="#2-4-数组引用" class="headerlink" title="2.4 数组引用"></a>2.4 数组引用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组类型[]::<span class="keyword">new</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以把数组看作一个构造器</li>
</ul>
<h1 id="三-函数式接口"><a href="#三-函数式接口" class="headerlink" title="三 函数式接口"></a>三 函数式接口</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol>
<li><code>SAM：Simple Abstract Method</code></li>
<li>有且仅有一个抽象方法的接口就是函数式接口，可以有其它方法（静态，默认…）</li>
<li><code>@FunctionalInterface</code>：此注解用来标识函数式接口</li>
<li><code>java.lang.util.function</code> 包下定义了许多函数式接口</li>
</ol>
<h2 id="3-2-常用函数式接口"><a href="#3-2-常用函数式接口" class="headerlink" title="3.2 常用函数式接口"></a>3.2 常用函数式接口</h2><table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>接口方法</th>
<th>说明</th>
<th>原始类型特化</th>
</tr>
</thead>
<tbody><tr>
<td><code>Predicate&lt;T&gt;</code></td>
<td><code>T</code></td>
<td><code>boolean</code></td>
<td><code>boolean test(T t)</code></td>
<td>传入 <code>T</code>，返回布尔值</td>
<td><code>IntPredicate</code><br><code>LongPredicate</code><br/><code>DoublePredicate</code></td>
</tr>
<tr>
<td><code>BiPredicate&lt;T, U&gt;</code></td>
<td><code>T, U</code></td>
<td><code>boolean</code></td>
<td><code>boolean test(T t, U u)</code></td>
<td>传入 <code>T U</code>，返回布尔值</td>
<td></td>
</tr>
<tr>
<td><code>Consumer&lt;T&gt;</code></td>
<td><code>T</code></td>
<td><code>void</code></td>
<td><code>void accept(T t)</code></td>
<td>传入 <code>T</code>，无返回</td>
<td><code>IntConsumer</code><br><code>LongConsumer</code><br/><code>DoubleConsumer</code></td>
</tr>
<tr>
<td><code>BiConsumer&lt;T, U&gt;</code></td>
<td><code>T, U</code></td>
<td><code>void</code></td>
<td><code>void accept(T t, U u)</code></td>
<td>传入 <code>T U</code>，无返回</td>
<td><code>ObjIntConsumer&lt;T&gt;</code><br><code>ObjLongConsumer&lt;T&gt;</code><br><code>ObjDoubleConsumer&lt;T&gt;</code></td>
</tr>
<tr>
<td><code>Supplier&lt;T&gt;</code></td>
<td><code>无</code></td>
<td><code>T</code></td>
<td><code>T get()</code></td>
<td>无传入，返回 <code>T</code></td>
<td><code>IntSupplier</code><br><code>BooleanSupplier</code><br/><code>LongSupplier</code><br/><code>DoubleSupplier</code></td>
</tr>
<tr>
<td><code>Function&lt;T, R&gt;</code></td>
<td><code>T</code></td>
<td><code>R</code></td>
<td><code>R apply(T t)</code></td>
<td>传入 <code>T</code>，返回 <code>R</code></td>
<td><code>IntFunction&lt;R&gt;</code><br><code>LongFunction&lt;R&gt;</code><br/><code>DoubleFunction&lt;R&gt;</code><br><code>ToIntFunction&lt;T&gt;</code><br><code>ToLongFunction&lt;T&gt;</code><br/><code>ToDoubleFunction&lt;T&gt;</code><br><code>IntToLongFunction</code><br><code>IntToDoubleFunction</code><br/><code>LongToIntFunction</code><br/><code>LongToDoubleFunction</code></td>
</tr>
<tr>
<td><code>UnaryOperator&lt;T&gt;</code></td>
<td><code>T</code></td>
<td><code>T</code></td>
<td><code>T apply(T t)</code></td>
<td>传入 <code>T</code>，返回 <code>T</code>，继承 <code>Function&lt;T, T&gt;</code> 接口</td>
<td><code>IntUnaryOperator</code><br><code>LongUnaryOperator</code><br><code>DoubleUnaryOperator</code></td>
</tr>
<tr>
<td><code>BiFunction&lt;T, U, R&gt;</code></td>
<td><code>T, U</code></td>
<td><code>R</code></td>
<td><code>R apply(T t, U u)</code></td>
<td>传入 <code>T U</code> ，返回 <code>R</code></td>
<td><code>ToIntBiFunction&lt;T,U&gt;</code><br><code>ToLongBiFunction&lt;T,U&gt;</code><br><code>ToDoubleBiFunction&lt;T,U&gt;</code></td>
</tr>
<tr>
<td><code>BinaryOperator&lt;T&gt;</code></td>
<td><code>T, T</code></td>
<td><code>T</code></td>
<td><code>T apply(T t1, T t2)</code></td>
<td>传入 <code>T T</code> ，返回 <code>T</code>，继承 <code>BiFunction&lt;T, T, T&gt;</code> 接口</td>
<td><code>IntBinaryOperator</code><br><code>LongBinaryOperator</code><br><code>DoubleBinaryOperator</code></td>
</tr>
<tr>
<td><code>Runnable</code></td>
<td><code>无</code></td>
<td><code>void</code></td>
<td><code>void run()</code></td>
<td>无传入，无返回</td>
<td></td>
</tr>
<tr>
<td><code>Comparator&lt;T&gt;</code></td>
<td><code>T, T</code></td>
<td><code>int</code></td>
<td><code>int compare(T t1, T t2)</code></td>
<td>传入 <code>T T</code>，返回 <code>int</code></td>
<td></td>
</tr>
</tbody></table>
<h2 id="3-3-复合-Lambda-表达式的有用方法"><a href="#3-3-复合-Lambda-表达式的有用方法" class="headerlink" title="3.3 复合 Lambda 表达式的有用方法"></a>3.3 复合 Lambda 表达式的有用方法</h2><h3 id="1-比较器复合"><a href="#1-比较器复合" class="headerlink" title="1 比较器复合"></a>1 比较器复合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">逆序：reversed</span><br><span class="line">比较器链：thenComparing</span><br></pre></td></tr></table></figure>

<h3 id="2-谓词复合"><a href="#2-谓词复合" class="headerlink" title="2 谓词复合"></a>2 谓词复合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">非：negate</span><br><span class="line">与：and</span><br><span class="line">或：or</span><br></pre></td></tr></table></figure>

<h3 id="3-函数复合"><a href="#3-函数复合" class="headerlink" title="3 函数复合"></a>3 函数复合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">andThen</span><br><span class="line">	f.anThen(g)：先执行 f 后 执行 g，即 g(f(x))</span><br><span class="line">compose</span><br><span class="line">	f.compose(g)：先执行 g 后 执行 f，即 f(g(x))</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>CS</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java-网络编程</title>
    <url>/anyeansan.github.io/2020/09/29/Java/Java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-网络模型"><a href="#1-1-网络模型" class="headerlink" title="1.1 网络模型"></a>1.1 网络模型</h2><h3 id="1-OSI（Open-System-Interconnection）"><a href="#1-OSI（Open-System-Interconnection）" class="headerlink" title="1 OSI（Open System Interconnection）"></a>1 OSI（<code>Open System Interconnection</code>）</h3><table>
<thead>
<tr>
<th>层</th>
<th>说明</th>
<th>相关协议</th>
</tr>
</thead>
<tbody><tr>
<td><code>应用层</code></td>
<td>网络服务和最终用户的接口</td>
<td><code>HTTP HTTPS FTP SMTP POP3 DNS ...</code></td>
</tr>
<tr>
<td><code>表示层</code></td>
<td>数据的表示、安全、压缩</td>
<td></td>
</tr>
<tr>
<td><code>会话层</code></td>
<td>建立、管理和终止会话</td>
<td></td>
</tr>
<tr>
<td><code>传输层</code></td>
<td>定义传输数据的协议端口号，以及流量控制和差错校验</td>
<td><code>TCP UDP</code></td>
</tr>
<tr>
<td><code>网络层</code></td>
<td>进行逻辑地址寻找，实现不同网络间的路径选择</td>
<td><code>IP ARP RARP ICMP IGMP ...</code></td>
</tr>
<tr>
<td><code>数据链路层</code></td>
<td>建立逻辑连接、进行硬件地址寻址、差错校验等功能</td>
<td><code>MAC</code> 地址</td>
</tr>
<tr>
<td><code>物理层</code></td>
<td>建立，维护，断开物理连接</td>
<td></td>
</tr>
</tbody></table>
<h3 id="2-TCP-IP-分层模型"><a href="#2-TCP-IP-分层模型" class="headerlink" title="2 TCP/IP 分层模型"></a>2 TCP/IP 分层模型</h3><table>
<thead>
<tr>
<th>层</th>
<th>相关协议</th>
</tr>
</thead>
<tbody><tr>
<td><code>应用层</code></td>
<td><code>HTTP HTTPS FTP DNS ...</code></td>
</tr>
<tr>
<td><code>传输层</code></td>
<td><code>TCP UDP</code></td>
</tr>
<tr>
<td><code>网络层</code></td>
<td><code>IP ARP ICMP...</code></td>
</tr>
<tr>
<td><code>物理+数据链路层</code></td>
<td>硬件层面</td>
</tr>
</tbody></table>
<h2 id="1-2-网络编程"><a href="#1-2-网络编程" class="headerlink" title="1.2 网络编程"></a>1.2 网络编程</h2><ol>
<li>目的：直接或间接的通过网络协议与其它计算机通信，进行数据交换</li>
<li>两个问题：<ul>
<li>如何准确定位网络上的一台或多台主机，以及如果定位主机上特定的应用</li>
<li>定位后，如何可靠高速的进行数据传输</li>
</ul>
</li>
</ol>
<h2 id="1-3-网络通信三要素"><a href="#1-3-网络通信三要素" class="headerlink" title="1.3 网络通信三要素"></a>1.3 网络通信三要素</h2><ol>
<li>IP 地址：确定设备</li>
<li>端口：确定设备上的程序</li>
<li>网络协议</li>
</ol>
<h2 id="1-4-常见端口"><a href="#1-4-常见端口" class="headerlink" title="1.4 常见端口"></a>1.4 常见端口</h2><table>
<thead>
<tr>
<th>服务</th>
<th>端口</th>
</tr>
</thead>
<tbody><tr>
<td><code>HTTP</code></td>
<td><code>80</code></td>
</tr>
<tr>
<td><code>HTTPS</code></td>
<td><code>443</code></td>
</tr>
<tr>
<td><code>SSH</code></td>
<td><code>22</code></td>
</tr>
<tr>
<td><code>Tomcat</code></td>
<td><code>8080</code></td>
</tr>
<tr>
<td><code>MySQL</code></td>
<td><code>3306</code></td>
</tr>
<tr>
<td><code>Oracle</code></td>
<td><code>1521</code></td>
</tr>
<tr>
<td><code>SMTP</code></td>
<td><code>25</code></td>
</tr>
<tr>
<td><code>POP3</code></td>
<td><code>110</code></td>
</tr>
</tbody></table>
<h1 id="二-java-net-InetAddress"><a href="#二-java-net-InetAddress" class="headerlink" title="二 java.net.InetAddress"></a>二 <code>java.net.InetAddress</code></h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol>
<li>用来包装 IP 地址对象</li>
<li>子类<ol>
<li><code>Inet4Address</code></li>
<li><code>Inet6Address</code></li>
</ol>
</li>
</ol>
<h2 id="2-2-方法"><a href="#2-2-方法" class="headerlink" title="2.2 方法"></a>2.2 方法</h2><h3 id="1-获取-IP-对象"><a href="#1-获取-IP-对象" class="headerlink" title="1 获取 IP 对象"></a>1 获取 IP 对象</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static InetAddress</code></td>
<td><code>getLocalHost()</code></td>
<td>获取本地主机 IP 对象，等价于 <code>getByName(&quot;127.0.0.1&quot;)</code></td>
</tr>
<tr>
<td><code>static InetAddress</code></td>
<td><code>getByName​(String host)</code></td>
<td>根据主机名（<code>ip</code> 或 域名）获取 IP 对象</td>
</tr>
</tbody></table>
<h3 id="2-获取主机信息"><a href="#2-获取主机信息" class="headerlink" title="2 获取主机信息"></a>2 获取主机信息</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>getHostName()</code></td>
<td>获取主机名（域名）</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getHostAddress()</code></td>
<td>获取主机 IP 地址</td>
</tr>
</tbody></table>
<h1 id="三-Socket"><a href="#三-Socket" class="headerlink" title="三 Socket"></a>三 <code>Socket</code></h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol>
<li>IP 和端口组合得出一个网络套接字：<code>Socket</code></li>
<li><code>Socket</code> 是网络通信的一种机制，是两台机器间通信的端点</li>
<li>分类<ol>
<li>流套接字（TCP）</li>
<li>数据报套接字（UDP）</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>java.net.Socket</code></td>
<td>TCP 客户端 Socket</td>
</tr>
<tr>
<td><code>java.net.ServerSocket</code></td>
<td>TCP 服务端 Socket</td>
</tr>
<tr>
<td><code>java.net.DatagramSocket</code></td>
<td>UDP Socket</td>
</tr>
<tr>
<td><code>java.net.DatagramPacket</code></td>
<td>UDP 数据包</td>
</tr>
</tbody></table>
<h2 id="3-2-TCP"><a href="#3-2-TCP" class="headerlink" title="3.2 TCP"></a>3.2 TCP</h2><h3 id="1-java-net-Socket（客户端）"><a href="#1-java-net-Socket（客户端）" class="headerlink" title="1 java.net.Socket（客户端）"></a>1 <code>java.net.Socket</code>（客户端）</h3><h4 id="1-构造"><a href="#1-构造" class="headerlink" title="1 构造"></a>1 构造</h4><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Socket​(String host, int port)</code></td>
<td>指定服务端主机地址，以及要连接的服务端口</td>
</tr>
<tr>
<td><code>Socket​(InetAddress address, int port)</code></td>
<td>指定服务端主机 IP 地址对象，以及要连接的服务端口</td>
</tr>
</tbody></table>
<h4 id="2-方法"><a href="#2-方法" class="headerlink" title="2 方法"></a>2 方法</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>InputStream</code></td>
<td><code>getInputStream()</code></td>
<td>获取字节输入流</td>
</tr>
<tr>
<td><code>OutputStream</code></td>
<td><code>getOutputStream()</code></td>
<td>获取字节输出流</td>
</tr>
<tr>
<td><code>InetAddress</code></td>
<td><code>getLocalAddress()</code></td>
<td>获取 <code>Socket</code> 绑定的本地主机 IP 对象</td>
</tr>
<tr>
<td><code>InetAddress</code></td>
<td><code>getInetAddress()</code></td>
<td>获取 <code>Socket</code> 连接的主机 IP 对象</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>shutdownInput()</code></td>
<td>关闭 Socket 输入通道</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>shutdownOutput()</code></td>
<td>关闭 Socket 输出通道</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>close()</code></td>
<td>关闭 <code>Socket</code>，会自动关闭流</td>
</tr>
</tbody></table>
<h3 id="2-java-net-ServerSocket（服务端）"><a href="#2-java-net-ServerSocket（服务端）" class="headerlink" title="2 java.net.ServerSocket（服务端）"></a>2 <code>java.net.ServerSocket</code>（服务端）</h3><h4 id="1-构造-1"><a href="#1-构造-1" class="headerlink" title="1 构造"></a>1 构造</h4><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ServerSocket​(int port)</code></td>
<td>指定服务监听端口</td>
</tr>
</tbody></table>
<h4 id="2-方法-1"><a href="#2-方法-1" class="headerlink" title="2 方法"></a>2 方法</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Socket</code></td>
<td><code>accept()</code></td>
<td>等待并接收客户端连接，阻塞方法</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>close()</code></td>
<td>关闭 Socket，会自动关闭流</td>
</tr>
</tbody></table>
<h3 id="3-应用"><a href="#3-应用" class="headerlink" title="3 应用"></a>3 应用</h3><h4 id="1-客户端"><a href="#1-客户端" class="headerlink" title="1 客户端"></a>1 客户端</h4><ol>
<li>创建 <code>Socket</code> 对象</li>
<li>使用 <code>Socket</code> 对象获取输入输出流来读写</li>
<li>关闭 <code>Socket</code></li>
</ol>
<h4 id="2-服务端"><a href="#2-服务端" class="headerlink" title="2 服务端"></a>2 服务端</h4><ol>
<li>创建 <code>ServerSocket</code> 对象，指定监听端口</li>
<li>使用 <code>ServerSokcet</code> 接收客户端 <code>Socket</code></li>
<li>使用 <code>Socket</code> 对象获取输入输出流来读写</li>
<li>关闭 <code>Socket</code></li>
</ol>
<h3 id="4-注意：如果服务端和客户端都等待"><a href="#4-注意：如果服务端和客户端都等待" class="headerlink" title="4 注意：如果服务端和客户端都等待"></a>4 注意：如果服务端和客户端都等待</h3><ol>
<li>数据没有刷新，使用 <code>BufferedReader</code> 包装字节输入流时，<code>readLIne()</code> 结束标记是换行符<ol>
<li>使用 <code>PrintStream</code> 包装字节输出流，可以自动刷新，如使用 <code>println()</code> </li>
<li>使用 <code>PrintWrter</code> 包装字节输出流，使用 <code>println()</code> 需要手动刷新或者构造函数中设置自动刷新</li>
<li>使用 <code>BufferedWriter</code> 包装字节输出流，输出后需要 <code>newLine()</code></li>
</ol>
</li>
<li>阻塞式方法没有结束标记<ul>
<li><code>void shutdownInput()</code></li>
<li>``void shutdownOutput()`</li>
</ul>
</li>
</ol>
<h3 id="5-服务端接收多个客户端连接"><a href="#5-服务端接收多个客户端连接" class="headerlink" title="5 服务端接收多个客户端连接"></a>5 服务端接收多个客户端连接</h3><ol>
<li><p>将每个客户端的业务封装为线程任务</p>
</li>
<li><p>使用多线程实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket ss=<span class="keyword">new</span> ServerSocket(<span class="number">8866</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">	Socket socket = ss.accept();</span><br><span class="line">	<span class="keyword">new</span> ClientTask(socket).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="3-3-UDP"><a href="#3-3-UDP" class="headerlink" title="3.3 UDP"></a>3.3 UDP</h2><h3 id="1-java-net-DatagramSocket"><a href="#1-java-net-DatagramSocket" class="headerlink" title="1 java.net.DatagramSocket"></a>1 <code>java.net.DatagramSocket</code></h3><h4 id="1-构造-2"><a href="#1-构造-2" class="headerlink" title="1 构造"></a>1 构造</h4><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>DatagramSocket()</code></td>
<td>发送端不用指定端口</td>
</tr>
<tr>
<td><code>DatagramSocket(int port)</code></td>
<td>接收端需要指定端口</td>
</tr>
</tbody></table>
<h4 id="2-方法-2"><a href="#2-方法-2" class="headerlink" title="2 方法"></a>2 方法</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>send(DatagramPacket p)</code></td>
<td>发送数据包</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>receive(DatagramPacket p)</code></td>
<td>接收数据包</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>close()</code></td>
<td>关闭 Socket，会自动关闭流</td>
</tr>
</tbody></table>
<h3 id="2-java-net-DatagramPacket"><a href="#2-java-net-DatagramPacket" class="headerlink" title="2 java.net.DatagramPacket"></a>2 <code>java.net.DatagramPacket</code></h3><h4 id="1-构造-3"><a href="#1-构造-3" class="headerlink" title="1 构造"></a>1 构造</h4><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>DatagramPacket​(byte[] buf, int length)</code></td>
<td>接收端接收数据包</td>
</tr>
<tr>
<td><code>DatagramPacket​(byte[] buf, int length, InetAddress address, int port)</code></td>
<td>发送端打包需要指定接收端 IP 和 Port</td>
</tr>
</tbody></table>
<h4 id="2-方法-3"><a href="#2-方法-3" class="headerlink" title="2 方法"></a>2 方法</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte[]</code></td>
<td><code>getData()</code></td>
<td>接收的数据</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getLength()</code></td>
<td>接收的数据实际长度</td>
</tr>
</tbody></table>
<h3 id="3-应用-1"><a href="#3-应用-1" class="headerlink" title="3 应用"></a>3 应用</h3><h4 id="1-发送端"><a href="#1-发送端" class="headerlink" title="1 发送端"></a>1 发送端</h4><ol>
<li>创建 <code>DatagramSocket</code>，不需端口</li>
<li>创建 <code>DatagramPacket</code> 数据包，指定数据存储数组，长度，接收端 IP 和 Port</li>
<li>发送数据包</li>
<li>关闭 <code>DatagramSocket</code></li>
</ol>
<h4 id="2-接收端"><a href="#2-接收端" class="headerlink" title="2 接收端"></a>2 接收端</h4><ol>
<li>创建 <code>DatagramSocket</code>，指定端口</li>
<li>创建 <code>DatagramPacket</code>，指定数据存储数组，长度</li>
<li>接收数据包</li>
<li>从数据包提取数据</li>
<li>关闭 <code>DatagramSocket</code></li>
</ol>
<h1 id="四-java-net-URL"><a href="#四-java-net-URL" class="headerlink" title="四 java.net.URL"></a>四 <code>java.net.URL</code></h1><h2 id="4-1-构造"><a href="#4-1-构造" class="headerlink" title="4.1 构造"></a>4.1 构造</h2><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>URL​(String spec)</code></td>
<td>根据 URL 地址字符串构造 URL 对象</td>
</tr>
<tr>
<td><code>URL​(String protocol, String host, int port, String file)</code></td>
<td>根据指定 protocol、host、port 号和 file 创建 URL 对象</td>
</tr>
</tbody></table>
<h2 id="4-2-方法"><a href="#4-2-方法" class="headerlink" title="4.2 方法"></a>4.2 方法</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>getProtocol()</code></td>
<td>获取此 URL 的协议名称</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getHost()</code></td>
<td>获取此 URL 的主机地址</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getPort()</code></td>
<td>获取此 URL 的端口号</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getFile()</code></td>
<td>获取此 URL 的文件资源路径（完整 URI）</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getPath()</code></td>
<td>获取此 URL 的路径部分（URI不带参数）</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getQuery()</code></td>
<td>获取此 URL 的查询部分（参数）</td>
</tr>
<tr>
<td><code>URLConnection</code></td>
<td><code>openConnection()</code></td>
<td>返回一个 <code>URLConnection</code> 对象，它表示到 URL 所引用的远程对象的连接</td>
</tr>
<tr>
<td><code>InputStream</code></td>
<td><code>openStream()</code></td>
<td>打开到此 URL 的连接并返回一个用于从该连接读入的 <code>InputStream</code></td>
</tr>
</tbody></table>
<h1 id="五-java-net-URLConnection"><a href="#五-java-net-URLConnection" class="headerlink" title="五 java.net.URLConnection"></a>五 <code>java.net.URLConnection</code></h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol>
<li>URL 连接器对象</li>
<li>表示与 URL 建立的通信连接</li>
</ol>
<h2 id="5-2-方法"><a href="#5-2-方法" class="headerlink" title="5.2 方法"></a>5.2 方法</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>URL</code></td>
<td><code>getURL()</code></td>
<td>获取此链接的 URL 对象</td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code>connect()</code></td>
<td>连接</td>
</tr>
<tr>
<td><code>InputStream</code></td>
<td><code>getInputStream()</code></td>
<td>获取此链接的字节输入流</td>
</tr>
<tr>
<td><code>OutputStream</code></td>
<td><code>getOutputStream()</code></td>
<td>获取此连接的字节输出流</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CS</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java-反射</title>
    <url>/anyeansan.github.io/2020/09/29/Java/Java-%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="一-反射"><a href="#一-反射" class="headerlink" title="一 反射"></a>一 反射</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ol>
<li>反射 <code>Reflection</code> 允许程序在运行期间：<ul>
<li>获取任意类型的详细信息</li>
<li>创建任意类型的对象</li>
<li>读写任意对象的任意属性</li>
<li>调用任意对象的任意方法</li>
<li>读取某个注解信息</li>
<li>读取某个类的泛型信息</li>
<li>生成动态代理</li>
<li>。。。</li>
</ul>
</li>
<li>加载完类之后，在方法区中旧产生了一个 <code>Class</code> 对象（一个类对应一个），此对象包含了类的完整结构信息</li>
</ol>
<h2 id="1-2-动态语言-amp-静态语言"><a href="#1-2-动态语言-amp-静态语言" class="headerlink" title="1.2 动态语言 &amp; 静态语言"></a>1.2 动态语言 &amp; 静态语言</h2><ol>
<li>动态语言：<ul>
<li>运行时可以根据某些条件改变自身结构</li>
<li><code>Object-C、C#、JavaScript、PHP、Python、Erlang</code></li>
</ul>
</li>
<li>静态语言：<ul>
<li>运行时结构不可变</li>
<li><code>Java、C、C++</code></li>
<li>Java 不是动态语言，但有一定的动态性（利用反射）</li>
</ul>
</li>
</ol>
<h1 id="二-Java-类型"><a href="#二-Java-类型" class="headerlink" title="二 Java 类型"></a>二 Java 类型</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/Java%E7%B1%BB%E5%9E%8B.png" alt=""></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>例</th>
</tr>
</thead>
<tbody><tr>
<td><code>Type</code></td>
<td>Java 中所有类型的公共高级接口</td>
<td></td>
</tr>
<tr>
<td><code>Class</code></td>
<td>普通类型（类，接口，数组，枚举，注解，基本数据类型，<code>void</code>），没有泛型信息</td>
<td><code>Person</code></td>
</tr>
<tr>
<td><code>ParameterizedType</code></td>
<td>参数化类型（即泛型）</td>
<td><code>Map&lt;String, Integer&gt;</code>，<code>List&lt;T&gt;</code></td>
</tr>
<tr>
<td><code>GenericArrayType</code></td>
<td>泛型数组类型</td>
<td><code>T[]</code>，<code>List&lt;T&gt;[]</code></td>
</tr>
<tr>
<td><code>TypeVariable&lt;D&gt;</code></td>
<td>类型变量（即泛型中的变量）</td>
<td><code>T K V</code></td>
</tr>
<tr>
<td><code>WildcardType</code></td>
<td>带通配符 <code>?</code> 的类型</td>
<td><code>List&lt;?&gt;</code>，<code>List&lt;? extends Object&gt;</code></td>
</tr>
</tbody></table>
<h2 id="2-2-ParameterizedType"><a href="#2-2-ParameterizedType" class="headerlink" title="2.2 ParameterizedType"></a>2.2 <code>ParameterizedType</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Type[]</code></td>
<td><code>getActualTypeArguments()</code></td>
<td>获取泛型的实际类型，泛型可能有多个，所以返回数组（<strong>该方法只返回最外层的<code>&lt;&gt;</code>中的类型，无论该<code>&lt;&gt;</code>内有多少个<code>&lt;&gt;</code></strong>）</td>
</tr>
<tr>
<td><code>Type</code></td>
<td><code>getRawType()</code></td>
<td>获取声明泛型的类或者接口，也就是泛型中<code>&lt;&gt;</code>前面的那个值</td>
</tr>
<tr>
<td><code>Type</code></td>
<td><code>getOwnerType()</code></td>
<td>获取泛型的拥有者，例如： <code>Map</code> 就是 <code>Map.Entry&lt;String,String&gt;</code> 的拥有者</td>
</tr>
</tbody></table>
<h1 id="三-java-lang-ClassLoader"><a href="#三-java-lang-ClassLoader" class="headerlink" title="三 java.lang.ClassLoader"></a>三 <code>java.lang.ClassLoader</code></h1><h2 id="3-1-获取-ClassLoader"><a href="#3-1-获取-ClassLoader" class="headerlink" title="3.1 获取 ClassLoader"></a>3.1 获取 ClassLoader</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 获取当前类的 ClassLoader</span></span><br><span class="line">clazz.getClassLoader()</span><br><span class="line"><span class="comment">// 2 获取当前线程上下文的 ClassLoader</span></span><br><span class="line">Thread.currentThread().getContextClassLoader()</span><br><span class="line"><span class="comment">// 3 获取系统的 ClassLoader</span></span><br><span class="line">ClassLoader.getSystemClassLoader()</span><br><span class="line"><span class="comment">// 4 获取调用者的 ClassLoader</span></span><br><span class="line">DriverManager.getCallClassLoader()</span><br><span class="line">Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br></pre></td></tr></table></figure>

<h2 id="3-2-API"><a href="#3-2-API" class="headerlink" title="3.2 API"></a>3.2 API</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Class&lt;?&gt;</code></td>
<td><code>loadClass​(String name)</code></td>
<td>加载指定全限定名的类，返回 <code>Class</code> 对象</td>
</tr>
<tr>
<td><code>protected Class&lt;?&gt;</code></td>
<td><code>findClass(String name)</code></td>
<td>查找指定全限定名的类，返回 <code>Class</code> 对象</td>
</tr>
<tr>
<td><code>protected Class&lt;?&gt;</code></td>
<td><code>defineClass(String name, byte[] b, int off, int len)</code></td>
<td>将字节数组转为一个 <code>Class</code> 对象</td>
</tr>
<tr>
<td><code>InputStream</code></td>
<td><code>getResourceAsStream​(String name)</code></td>
<td>获取指定资源文件的流</td>
</tr>
<tr>
<td><code>URL</code></td>
<td><code>getResource​(String name)</code></td>
<td>获取指定资源文件的 URL 对象</td>
</tr>
<tr>
<td><code>ClassLoader</code></td>
<td><code>getParent()</code></td>
<td>获取父加载器</td>
</tr>
</tbody></table>
<h2 id="3-3-Class-和-ClassLoader-获取资源"><a href="#3-3-Class-和-ClassLoader-获取资源" class="headerlink" title="3.3 Class 和 ClassLoader 获取资源"></a>3.3 <code>Class</code> 和 <code>ClassLoader</code> 获取资源</h2><h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line">App</span><br><span class="line">	src</span><br><span class="line">		a</span><br><span class="line">			b</span><br><span class="line">				Test.java</span><br><span class="line">				hello.xml</span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line">App</span><br><span class="line">	WEB-INF</span><br><span class="line">		classes</span><br><span class="line">			a</span><br><span class="line">				b</span><br><span class="line">					Test<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">					<span class="title">hello</span>.<span class="title">xml</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>Class</code> 和 <code>ClassLoader</code> 资源路径都是相对于编译后的工程结构来说</li>
<li><code>getResource()</code> 和 <code>getResourceAsStream()</code> 两个方法路径用法是一样的</li>
</ol>
<h3 id="2-Class"><a href="#2-Class" class="headerlink" title="2 Class"></a>2 <code>Class</code></h3><ol>
<li><p>相对路径：相对于当前类的 <code>.class</code> 文件路径</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">class.getResouce("hello.xml")</span><br></pre></td></tr></table></figure>
</li>
<li><p>绝对路径：<code>/</code> 代表 <code>classpath</code> 根路径，即 <code>classes</code> 目录</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">class.getResource("/a/b/hello.xml")</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="3-ClassLoader"><a href="#3-ClassLoader" class="headerlink" title="3 ClassLoader"></a>3 <code>ClassLoader</code></h3><ul>
<li><p>默认就是从 <code>classpath</code> 下寻找资源，所以不能写 <code>/</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">classLoader.getResource(<span class="string">"a/b/hello.xml"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-文件流"><a href="#4-文件流" class="headerlink" title="4 文件流"></a>4 文件流</h3><ul>
<li>文件流是相对于当前工程</li>
</ul>
<h1 id="四-java-lang-Class"><a href="#四-java-lang-Class" class="headerlink" title="四 java.lang.Class"></a>四 <code>java.lang.Class</code></h1><h2 id="4-1-获取-Class-对象的方式"><a href="#4-1-获取-Class-对象的方式" class="headerlink" title="4.1 获取 Class 对象的方式"></a>4.1 获取 <code>Class</code> 对象的方式</h2><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>类.class</code></td>
<td>编译期这个类型就要存在</td>
</tr>
<tr>
<td><code>类对象.getClass()</code></td>
<td>需要先创建对象</td>
</tr>
<tr>
<td><code>Class.forName(&quot;全限定类名&quot;)</code></td>
<td>类型可以在编译期未知，类名可以在代码中或配置文件中等等</td>
</tr>
<tr>
<td><code>类加载器对象.loadClass(&quot;全限定类名&quot;)</code></td>
<td>一般用在自定义类加载器去加载指定路径的类</td>
</tr>
</tbody></table>
<h2 id="4-2-API"><a href="#4-2-API" class="headerlink" title="4.2 API"></a>4.2 API</h2><h3 id="1-获取-Class-和-ClassLoader"><a href="#1-获取-Class-和-ClassLoader" class="headerlink" title="1 获取 Class 和 ClassLoader"></a>1 获取 <code>Class</code> 和 <code>ClassLoader</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Class&lt;?&gt;</code></td>
<td><code>forName​(String className)</code></td>
<td>根据全限定类名获取 <code>Class</code> 对象</td>
</tr>
<tr>
<td><code>ClassLoader</code></td>
<td><code>getClassLoader()</code></td>
<td>获取类加载器对象</td>
</tr>
</tbody></table>
<h3 id="2-获取类信息"><a href="#2-获取类信息" class="headerlink" title="2 获取类信息"></a>2 获取类信息</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Package</code></td>
<td><code>getPackage()</code></td>
<td>获取包</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getPackageName()</code></td>
<td>获取包名</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getName()</code></td>
<td>获取类名</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getModifiers()</code></td>
<td>获取类修饰符编号 <code>mod</code></td>
</tr>
<tr>
<td><code>Class&lt;? super T&gt;</code></td>
<td><code>getSuperclass()</code></td>
<td>获取父类（不带泛型）</td>
</tr>
<tr>
<td><code>Type</code></td>
<td><code>getGenericSuperclass()</code></td>
<td>获取带泛型的父类</td>
</tr>
<tr>
<td><code>Class&lt;?&gt;[]</code></td>
<td><code>getInterfaces()</code></td>
<td>获取所有实现的接口（不带泛型）</td>
</tr>
<tr>
<td><code>Type[]</code></td>
<td><code>getGenericInterfaces()</code></td>
<td>获取所有实现接口（带泛型）</td>
</tr>
</tbody></table>
<h3 id="3-获取构造器-Constructor"><a href="#3-获取构造器-Constructor" class="headerlink" title="3 获取构造器  Constructor"></a>3 获取构造器  <code>Constructor</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Constructor&lt;?&gt;[]</code></td>
<td><code>getConstructors()</code></td>
<td>获取本类所有 <code>public</code> 构造器</td>
</tr>
<tr>
<td><code>Constructor&lt;?&gt;[]</code></td>
<td><code>getDeclaredConstructors()</code></td>
<td>获取本类所有构造器</td>
</tr>
<tr>
<td><code>Constructor&lt;T&gt;</code></td>
<td><code>getConstructor(Class&lt;?&gt;... parameterTypes)</code></td>
<td>获取本类指定参数类型的 <code>public</code> 构造器</td>
</tr>
<tr>
<td><code>Constructor&lt;T&gt;</code></td>
<td><code>getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code></td>
<td>获取本类指定参数类型的构造器</td>
</tr>
</tbody></table>
<h3 id="4-获取属性-Field"><a href="#4-获取属性-Field" class="headerlink" title="4 获取属性 Field"></a>4 获取属性 <code>Field</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Field[]</code></td>
<td><code>getFields()</code></td>
<td>获取本类及父类的所有 <code>public</code> 属性</td>
</tr>
<tr>
<td><code>Field[]</code></td>
<td><code>getDeclaredFields()</code></td>
<td>获取本类的所有属性</td>
</tr>
<tr>
<td><code>Field</code></td>
<td><code>getField​(String name)</code></td>
<td>获取本类及父类中指定名称的 <code>public</code> 属性</td>
</tr>
<tr>
<td><code>Field</code></td>
<td><code>getDeclaredField​(String name)</code></td>
<td>获取本类中指定名称的属性</td>
</tr>
</tbody></table>
<h3 id="5-获取方法-Method"><a href="#5-获取方法-Method" class="headerlink" title="5 获取方法 Method"></a>5 获取方法 <code>Method</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Method[]</code></td>
<td><code>getMethods()</code></td>
<td>获取本类及父类的所有 <code>public</code> 方法</td>
</tr>
<tr>
<td><code>Method[]</code></td>
<td><code>getDeclaredMethods()</code></td>
<td>获取本类的所有方法</td>
</tr>
<tr>
<td><code>Method</code></td>
<td><code>getMethod​(String name, Class&lt;?&gt;... parameterTypes)</code></td>
<td>获取本类及父类中指定方法名和参数类型的 <code>public</code> 方法</td>
</tr>
<tr>
<td><code>Method</code></td>
<td><code>getDeclaredMethod​(String name, Class&lt;?&gt;... parameterTypes)</code></td>
<td>获取本类中指定方法名和参数类型的方法</td>
</tr>
</tbody></table>
<h3 id="6-获取注解-Annotation"><a href="#6-获取注解-Annotation" class="headerlink" title="6 获取注解 Annotation"></a>6 获取注解 <code>Annotation</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Annotation[]</code></td>
<td><code>getAnnotations()</code></td>
<td>获取类上的所有注解</td>
</tr>
<tr>
<td><code>&lt;A extends Annotation&gt; A</code></td>
<td><code>getAnnotation​(Class&lt;A&gt; annotationClass)</code></td>
<td>获取类上指定注解类型的注解</td>
</tr>
</tbody></table>
<h1 id="五-java-lang-reflect-包"><a href="#五-java-lang-reflect-包" class="headerlink" title="五 java.lang.reflect 包"></a>五 <code>java.lang.reflect</code> 包</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%8F%8D%E5%B0%84%E5%8C%85.png" alt=""></p>
<table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>AccessibleObject</code></td>
<td>访问修饰符控制</td>
</tr>
<tr>
<td><code>Modifier</code></td>
<td>修饰符</td>
</tr>
<tr>
<td><code>Constructor&lt;T&gt;</code></td>
<td>构造器</td>
</tr>
<tr>
<td><code>Field</code></td>
<td>属性</td>
</tr>
<tr>
<td><code>Method</code></td>
<td>方法</td>
</tr>
<tr>
<td><code>Proxy</code></td>
<td>代理</td>
</tr>
</tbody></table>
<h2 id="5-2-Modifier"><a href="#5-2-Modifier" class="headerlink" title="5.2 Modifier"></a>5.2 <code>Modifier</code></h2><h3 id="1-属性"><a href="#1-属性" class="headerlink" title="1 属性"></a>1 属性</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>属性</th>
</tr>
</thead>
<tbody><tr>
<td><code>static int</code></td>
<td><code>PUBLIC</code></td>
</tr>
<tr>
<td><code>static int</code></td>
<td><code>PRIVATE</code></td>
</tr>
<tr>
<td><code>...</code></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>此类为修饰符定义了常量值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PUBLIC = <span class="number">0x00000001</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRIVATE = <span class="number">0x00000002</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2 方法"></a>2 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static String</code></td>
<td><code>toString(int mod)</code></td>
<td>获取编号对应的修饰符</td>
</tr>
</tbody></table>
<h2 id="5-3-AccessibleObject"><a href="#5-3-AccessibleObject" class="headerlink" title="5.3 AccessibleObject"></a>5.3 <code>AccessibleObject</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Annotation[]</code></td>
<td><code>getAnnotations()</code></td>
<td>获取当前元素（构造、属性、方法）上的所有注解</td>
</tr>
<tr>
<td><code>&lt;T extends Annotation&gt; T</code></td>
<td><code>getAnnotation(Class&lt;T&gt; annotationClass)</code></td>
<td>获取当前元素上的指定类型的注解</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setAccessible​(boolean flag)</code></td>
<td><code>true</code> 表示不启用 Java 访问修饰符的检查，可以访问非 <code>public</code> 修饰的成员</td>
</tr>
</tbody></table>
<h2 id="5-4-Constructor"><a href="#5-4-Constructor" class="headerlink" title="5.4 Constructor"></a>5.4 <code>Constructor</code></h2><h3 id="1-构造器信息"><a href="#1-构造器信息" class="headerlink" title="1 构造器信息"></a>1 构造器信息</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>getModifiers()</code></td>
<td>获取构造方法修饰符</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getName()</code></td>
<td>获取构造方法名</td>
</tr>
<tr>
<td><code>Class&lt;?&gt;[]</code></td>
<td><code>getParameterTypes()</code></td>
<td>获取构造方法形参类型列表</td>
</tr>
</tbody></table>
<h3 id="2-构造器操作"><a href="#2-构造器操作" class="headerlink" title="2 构造器操作"></a>2 构造器操作</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>T</code></td>
<td><code>newInstance​(Object... initargs)</code></td>
<td>使用构造器创建对象</td>
</tr>
</tbody></table>
<h2 id="5-4-Field"><a href="#5-4-Field" class="headerlink" title="5.4 Field"></a>5.4 <code>Field</code></h2><h3 id="1-属性信息"><a href="#1-属性信息" class="headerlink" title="1 属性信息"></a>1 属性信息</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>getModifiers()</code></td>
<td>获取属性修饰符</td>
</tr>
<tr>
<td><code>Class&lt;?&gt;</code></td>
<td><code>getType()</code></td>
<td>获取属性类型</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getName()</code></td>
<td>获取属性名</td>
</tr>
</tbody></table>
<h3 id="2-属性操作"><a href="#2-属性操作" class="headerlink" title="2 属性操作"></a>2 属性操作</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object</code></td>
<td><code>get​(Object obj)</code></td>
<td>获取指定对象此属性的值</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>set​(Object obj, Object value)</code></td>
<td>为指定对象设置此属性的值</td>
</tr>
</tbody></table>
<h2 id="5-5-Method"><a href="#5-5-Method" class="headerlink" title="5.5 Method"></a>5.5 <code>Method</code></h2><h3 id="1-方法信息"><a href="#1-方法信息" class="headerlink" title="1 方法信息"></a>1 方法信息</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>getModifiers()</code></td>
<td>获取方法修饰符</td>
</tr>
<tr>
<td><code>Class&lt;?&gt;</code></td>
<td><code>getReturnType()</code></td>
<td>获取返回值类型</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getName()</code></td>
<td>获取方法名</td>
</tr>
<tr>
<td><code>Class&lt;?&gt;[]</code></td>
<td><code>getParameterTypes()</code></td>
<td>获取方法形参类型列表</td>
</tr>
<tr>
<td><code>Class&lt;?&gt;[]</code></td>
<td><code>getExceptionTypes()</code></td>
<td>获取抛出异常类型列表</td>
</tr>
</tbody></table>
<h3 id="2-方法操作"><a href="#2-方法操作" class="headerlink" title="2 方法操作"></a>2 方法操作</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object</code></td>
<td><code>invoke​(Object obj, Object... args)</code></td>
<td>调用非静态方法传入指定对象，调用静态方法传入 <code>null</code> 或 <code>类.class</code></td>
</tr>
</tbody></table>
<h2 id="5-6-Proxy"><a href="#5-6-Proxy" class="headerlink" title="5.6 Proxy"></a>5.6 <code>Proxy</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Object</code></td>
<td><code>newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code></td>
<td>创建代理对象</td>
</tr>
</tbody></table>
<h1 id="六-应用"><a href="#六-应用" class="headerlink" title="六 应用"></a>六 应用</h1><ol>
<li><p><code>List&lt;Integer&gt;</code> 中添加字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 泛型只在编译期，在运行期通过反射即可实现</span></span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"java.util.ArrayList"</span>);</span><br><span class="line">Method method = clazz.getMethod(<span class="string">"add"</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">method.invoke(list, <span class="string">"哈哈哈"</span>);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java-多线程</title>
    <url>/anyeansan.github.io/2020/09/29/Java/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一-概念"><a href="#一-概念" class="headerlink" title="一 概念"></a>一 概念</h1><h2 id="1-1-同步（Synchronous）-amp-异步（Asynchronous）"><a href="#1-1-同步（Synchronous）-amp-异步（Asynchronous）" class="headerlink" title="1.1 同步（Synchronous）&amp; 异步（Asynchronous）"></a>1.1 同步（Synchronous）&amp; 异步（Asynchronous）</h2><ol>
<li>同步和异步都用来形容一次方法调用</li>
<li>同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为</li>
<li>异步方法调用一旦开始，方法调用会立即返回，调用者可以继续后续操作，而异步方法通常会在另一个线程中 “真实” 的执行。异步调用的整个过程不会阻碍调用者的工作，如果异步调用需要返回结果，那么当此异步调用真正完成时，会通知调用者。</li>
</ol>
<h2 id="1-2-并发（Concurrency）-amp-并行（Parallelism）"><a href="#1-2-并发（Concurrency）-amp-并行（Parallelism）" class="headerlink" title="1.2 并发（Concurrency）&amp; 并行（Parallelism）"></a>1.2 并发（Concurrency）&amp; 并行（Parallelism）</h2><ol>
<li>并发：<ul>
<li>同一时间多个任务交替执行，只是切换速度较快，看起来是同时执行而并非真正同时执行</li>
<li>同一时间应对多件事情的能力</li>
</ul>
</li>
<li>并行：<ul>
<li>同一时间多个任务真正的同时执行</li>
<li>同一时间做多件事情的能力</li>
</ul>
</li>
</ol>
<h2 id="1-3-进程（Process）-amp-线程（Thread）"><a href="#1-3-进程（Process）-amp-线程（Thread）" class="headerlink" title="1.3 进程（Process）&amp; 线程（Thread）"></a>1.3 进程（Process）&amp; 线程（Thread）</h2><ol>
<li><p>进程：</p>
<ul>
<li>正在运行的程序的实例，是系统进行资源分配的基本单位</li>
<li>进程是容纳线程的容器</li>
</ul>
</li>
<li><p>线程：</p>
<ul>
<li><p>线程是调度 CPU 的基本单位</p>
</li>
<li><p>进程中的一条执行路径，一个进程至少有一个线程</p>
</li>
<li><p>线程是程序执行的最小单位</p>
</li>
</ul>
</li>
</ol>
<h1 id="二-体系"><a href="#二-体系" class="headerlink" title="二 体系"></a>二 体系</h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E7%BA%BF%E7%A8%8B%E4%BD%93%E7%B3%BB.png" alt=""></p>
<ol>
<li><code>Runnable</code> 和 <code>Callable</code> 都可以作为线程的任务<ul>
<li><code>Runnable</code> 没有返回值，不能抛异常</li>
<li><code>Callable</code> 有返回值，能抛异常，主要用于线程池</li>
</ul>
</li>
<li><code>Future</code> 用来存储将会产生的结果</li>
<li><code>FutureTask</code> 技能存储结果也能作为任务，相当于 <code>Future + Runnable</code></li>
</ol>
<h1 id="三-Thread"><a href="#三-Thread" class="headerlink" title="三 Thread"></a>三 <code>Thread</code></h1><h2 id="3-1-创建线程"><a href="#3-1-创建线程" class="headerlink" title="3.1 创建线程"></a>3.1 创建线程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 使用 Thread 自身的任务</span></span><br><span class="line">Thread()</span><br><span class="line">Thread(String name)</span><br><span class="line">Thread(ThreadGroup group, String name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 使用 Runnable 任务</span></span><br><span class="line">Thread(Runnable target)</span><br><span class="line">Thread(Runnable target, String name)</span><br><span class="line">Thread(ThreadGroup group, Runnable target)</span><br><span class="line">Thread(ThreadGroup group, Runnable target, String name)</span><br></pre></td></tr></table></figure>

<ol>
<li>若不指定线程名称，默认为  <code>Thread-0,1,2...</code></li>
<li>若不指定线程组，默认为父线程（创建此线程的线程）的线程组</li>
<li>构造函数中的 <code>statcksize</code> 代表该线程占用的栈大小，如果未指定，默认为 0，0 代表忽略该参数，该参数会被 JNI 函数去使用。（该参数有些平台有效，有些则无效）</li>
</ol>
<h2 id="3-2-启动线程"><a href="#3-2-启动线程" class="headerlink" title="3.2 启动线程"></a>3.2 启动线程</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>start()</code></td>
<td>启动线程</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>run()</code></td>
<td>子类必须重写，任务方法</td>
</tr>
<tr>
<td><code>static void</code></td>
<td>sleep(long millis)`</td>
<td>控制线程休眠若干毫秒</td>
</tr>
</tbody></table>
<h2 id="3-3-线程信息"><a href="#3-3-线程信息" class="headerlink" title="3.3 线程信息"></a>3.3 线程信息</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>getName()</code></td>
<td>获取线程名称</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setName(String name)</code></td>
<td>设置线程名字</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>getId()</code></td>
<td>获取线程 ID</td>
</tr>
<tr>
<td><code>Thread.state</code></td>
<td><code>getState()</code></td>
<td>获取线程状态</td>
</tr>
<tr>
<td><code>static Thread</code></td>
<td><code>currentThread()</code></td>
<td>获取当前线程对象</td>
</tr>
</tbody></table>
<h2 id="3-4-加入线程"><a href="#3-4-加入线程" class="headerlink" title="3.4 加入线程"></a>3.4 加入线程</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>join()</code></td>
<td>当前线程阻塞，等待插入线程执行完毕</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>join(long millis)</code></td>
<td>当前线程阻塞，等待插入线程执行完毕，但最多只等待指定时间</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>join(long millis, int nanos)</code></td>
<td>时间更精确一点</td>
</tr>
</tbody></table>
<h2 id="3-5-中断线程"><a href="#3-5-中断线程" class="headerlink" title="3.5 中断线程"></a>3.5 中断线程</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>interrupt()</code></td>
<td>1 运行线程： 设置中断标志位，不代表会退出线程<br/>2 阻塞线程（ <code>wait join sleep</code>）：终止阻塞状态并抛出 <code>InterruptedException</code> 异常，且清除中断标志位</td>
</tr>
<tr>
<td><code>static boolean</code></td>
<td><code>interrupted()</code></td>
<td>判断当前线程是否被中断，会清除中断标志位</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isInterrupted()</code></td>
<td>判断此线程是否中断，不会清除中断标志位</td>
</tr>
</tbody></table>
<ol>
<li>每个线程都有一个表示 <code>中断状态</code> 的 <code>boolean</code> 标记</li>
<li>每个线程都应该不时检查此标记，以判断线程是否被中断</li>
</ol>
<h2 id="3-6-守护线程"><a href="#3-6-守护线程" class="headerlink" title="3.6 守护线程"></a>3.6 守护线程</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>setDaemon(boolean on)</code></td>
<td>是否将线程设置为守护线程，必须在线程启动前调用</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isDaemon</code></td>
<td>判断是否是守护线程</td>
</tr>
</tbody></table>
<h2 id="3-7-礼让线程"><a href="#3-7-礼让线程" class="headerlink" title="3.7 礼让线程"></a>3.7 礼让线程</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static void</code></td>
<td><code>yield()</code></td>
<td>让出本次 CPU 执行权，加入下一次的抢夺中，效果不明显</td>
</tr>
</tbody></table>
<h2 id="3-8-线程组"><a href="#3-8-线程组" class="headerlink" title="3.8 线程组"></a>3.8 线程组</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ThreadGroup</code></td>
<td><code>getThreadGroup()</code></td>
<td>获取线程所在线程组</td>
</tr>
</tbody></table>
<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>线程组可以对一批线程进行分类管理，Java 允许程序直接对线程组进行控制</li>
<li>创建线程对象时，如果未指定线程组，则默认为父线程的线程组</li>
<li>主线程的线程组为 <code>main</code></li>
</ol>
<h3 id="2-ThreadGroup"><a href="#2-ThreadGroup" class="headerlink" title="2 ThreadGroup"></a>2 <code>ThreadGroup</code></h3><h4 id="1-构造"><a href="#1-构造" class="headerlink" title="1 构造"></a>1 构造</h4><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ThreadGroup(String name)</code></td>
<td>创建线程组并指定名称</td>
</tr>
<tr>
<td><code>ThreadGroup(ThreadGroup parent, String name)</code></td>
<td>创建线程组并指定父线程组及名称</td>
</tr>
</tbody></table>
<h4 id="2-方法"><a href="#2-方法" class="headerlink" title="2 方法"></a>2 方法</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>getName()</code></td>
<td>获取线程组名称</td>
</tr>
<tr>
<td><code>ThreadGroup</code></td>
<td><code>getParent()</code></td>
<td>获取线程组的父线程组</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>activeCount()</code></td>
<td>获取线程组中活动线程数</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>enumerate(Thread[] list)</code></td>
<td>枚举线程组中的活动线程</td>
</tr>
</tbody></table>
<h2 id="3-9-线程优先级"><a href="#3-9-线程优先级" class="headerlink" title="3.9 线程优先级"></a>3.9 线程优先级</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>getPriority()</code></td>
<td>获取线程优先级</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPriority(int newPriority)</code></td>
<td>设置线程优先级 <code>1-10</code>，仅仅是概率增加了，玄不改命</td>
</tr>
<tr>
<td></td>
<td><code>Thread.MIN_PRIORITY</code></td>
<td>最小优先级 <code>1</code></td>
</tr>
<tr>
<td></td>
<td><code>Thread.NORM_PRIORITY</code></td>
<td>默认优先级 <code>5</code></td>
</tr>
<tr>
<td></td>
<td><code>Thread.MAX_PRIORITY</code></td>
<td>最大优先级 <code>10</code></td>
</tr>
</tbody></table>
<h1 id="四-线程状态"><a href="#四-线程状态" class="headerlink" title="四 线程状态"></a>四 线程状态</h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt=""></p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>New</code></td>
<td>新建状态</td>
</tr>
<tr>
<td><code>Runnable</code></td>
<td>可运行状态：一个线程可能正在运行也可能没有运行</td>
</tr>
<tr>
<td><code>Blocked</code></td>
<td>阻塞状态</td>
</tr>
<tr>
<td><code>Waiting</code></td>
<td>无限等待</td>
</tr>
<tr>
<td><code>Timed waiting</code></td>
<td>限时等待</td>
</tr>
<tr>
<td><code>Terminated</code></td>
<td>终止状态：正常结束或异常意外终止</td>
</tr>
</tbody></table>
<h1 id="五-终止线程"><a href="#五-终止线程" class="headerlink" title="五 终止线程"></a>五 终止线程</h1><ol>
<li><p><code>stop()</code></p>
<ol>
<li>已过时</li>
<li><code>stop()</code> 方法过于暴力，会强行把执行到一半的线程终止，可能会引起一些数据不一致的问题</li>
</ol>
</li>
<li><p><code>suspend() resume()</code></p>
<ol>
<li>已过时</li>
<li>挂起和恢复线程这两个方法同样会破坏同步</li>
</ol>
</li>
<li><p>定义标记，自行决定线程何时退出</p>
</li>
<li><p><code>Two Phase Termination</code>：两阶段终止模式</p>
<p><img src="https://gitee.com/anis5/pic/raw/master/Java/%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B.png" alt=""></p>
<ol>
<li>通过中断标记实现</li>
<li><code>volatile</code> 实现</li>
</ol>
</li>
</ol>
<h1 id="六-JMM"><a href="#六-JMM" class="headerlink" title="六 JMM"></a>六 JMM</h1><h2 id="6-1-CPU-缓存"><a href="#6-1-CPU-缓存" class="headerlink" title="6.1 CPU 缓存"></a>6.1 CPU 缓存</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7.png" alt=""></p>
<ol>
<li>读写速度（离 CPU 越近，速度越快）：<code>寄存器 &gt; cache L1 &gt; cache L2 &gt; cache L3 &gt; 内存 &gt; 硬盘</code></li>
<li><code>cache line</code> 是 <code>cache</code> 的最小存储单元</li>
<li>在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，这就有了<strong>缓存一致性（CacheCoherence）</strong>问题</li>
<li>为了解决一致性的问题，有许多协议，如 MSI、<br>MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol，等等</li>
</ol>
<h3 id="2-MESI-缓存一致性协议"><a href="#2-MESI-缓存一致性协议" class="headerlink" title="2 MESI 缓存一致性协议"></a>2 <code>MESI</code> 缓存一致性协议</h3><table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>M（Modified）</code></td>
<td>该 <code>cache line</code> 有效，数据被修改了，和内存中的数据不一致，数据只存在于本 <code>Cache</code> 中</td>
</tr>
<tr>
<td><code>E（Exclusive）</code></td>
<td>该 <code>cache line</code> 有效，数据和内存中的数据一致，数据只存在于本 <code>Cache</code> 中</td>
</tr>
<tr>
<td><code>S（Shared）</code></td>
<td>该 <code>cache line</code> 有效，数据和内存中的数据一致，数据存在于多个 <code>Cache</code> 中</td>
</tr>
<tr>
<td><code>I（Invalid）</code></td>
<td>该 <code>cache line</code> 无效</td>
</tr>
</tbody></table>
<ol>
<li>内存中数据，只有一个  <code>cache</code> 中有，则为独占状态 <code>E</code></li>
<li>当不止一个 <code>cache</code> 中有时，则全为共享状态 <code>S</code></li>
<li>当某个 <code>cache</code> 修改了数据，则其变为修改状态 <code>M</code>，且其它 <code>cache</code> 变为无效状态 <code>I</code></li>
<li>多个 CPU 从主内存读取同一个数据到各自的高速缓存，当其中某个 CPU 修改了缓存里的数据，该数据会马上同步回主内存，其它 CPU 通过 <strong>总线嗅探机制</strong> （类似于事件监听）可以感知到数据的变化从而将自己缓存里的数据失效</li>
<li>底层实现通过汇编 <code>lock</code> 指令<ol>
<li>锁定这块内存区域的缓存（缓存行锁定），并立即将修改数据写回系统内存</li>
<li>这个写回内存的操作会引起在其它 CPU 里缓存了该内存地址的数据无效</li>
</ol>
</li>
</ol>
<h2 id="6-2-JMM-概述"><a href="#6-2-JMM-概述" class="headerlink" title="6.2 JMM 概述"></a>6.2 JMM 概述</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/JMM.png" alt=""></p>
<ol>
<li><p><code>Java Memory Model</code> </p>
</li>
<li><p>Java内存模型是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p>
<ul>
<li>实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享，受到内存模型控制</li>
<li>局部变量，方法参数，异常处理参数不会在线程之间共享，不受内存模型影响</li>
</ul>
</li>
<li><p>相关概念</p>
<ol>
<li><p><strong>临界区 <code>Critical Section</code></strong></p>
<ul>
<li><p>表示一种公共资源或共享数据，可以被多个线程使用，但每次只能有一个线程使用，一旦临界区资源被占用，其它线程就必须等待</p>
</li>
<li><p>一段代码内如果存在对共享数据的多线程读写操作，则这段代码称为临界区</p>
</li>
</ul>
</li>
<li><p><strong>竞态条件 <code>Race Condition</code></strong></p>
<ul>
<li>多个线程在临界区内执行，由于代码执行序列不同而导致结果无法预测，称为发生了竞态条件</li>
</ul>
</li>
<li><p>为避免临界区的竞态条件发生</p>
<ol>
<li>阻塞式解决方案：<code>synchronized, Lock</code> </li>
<li>非阻塞式解决方案：原子变量 CAS</li>
</ol>
</li>
<li><p>同步和互斥</p>
<ol>
<li>同步：是由于线程执行的顺序不同，需要一个线程等待其它线程运行到某个点</li>
<li>互斥：保证同一时刻只有一个线程执行临界区代码</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="6-3-JMM-内存交互操作（原子操作）"><a href="#6-3-JMM-内存交互操作（原子操作）" class="headerlink" title="6.3 JMM 内存交互操作（原子操作）"></a>6.3 JMM 内存交互操作（原子操作）</h2><table>
<thead>
<tr>
<th>操作</th>
<th>作用对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>read</code></td>
<td>主内存</td>
<td>从主内存读取数据到工作内存中</td>
</tr>
<tr>
<td><code>load</code></td>
<td>工作内存</td>
<td>将 <code>read</code> 读取的数据载入工作内存变量副本中</td>
</tr>
<tr>
<td><code>use</code></td>
<td>工作内存</td>
<td>从工作内存读取数据传递给执行引擎计算</td>
</tr>
<tr>
<td><code>assign</code></td>
<td>工作内存</td>
<td>将执行引擎计算好的值重新赋值给工作内存</td>
</tr>
<tr>
<td><code>store</code></td>
<td>工作内存</td>
<td>将工作内存数据传送到主内存</td>
</tr>
<tr>
<td><code>write</code></td>
<td>工作内存</td>
<td>将 <code>stroe</code> 传送的数据赋值给主内存的变量</td>
</tr>
<tr>
<td><code>lock</code></td>
<td>主内存</td>
<td>将主内存变量加锁，标记为线程独占状态</td>
</tr>
<tr>
<td><code>unlock</code></td>
<td>主内存</td>
<td>将主内存变量解锁，解锁后才可以被其他线程锁定</td>
</tr>
</tbody></table>
<h2 id="6-4-JMM-特性"><a href="#6-4-JMM-特性" class="headerlink" title="6.4 JMM 特性"></a>6.4 JMM 特性</h2><h3 id="1-原子性-Atomicity"><a href="#1-原子性-Atomicity" class="headerlink" title="1 原子性 Atomicity"></a>1 原子性 <code>Atomicity</code></h3><ol>
<li><p>原子性指一个操作是不可分割的单元，是不可中断的，要嘛都执行，要嘛都不执行</p>
</li>
<li><p>一个原子性操作一旦开始，就不会被其它线程干扰，而一个非原子性操作，在多线程环境下有可能被其它线程所干扰</p>
</li>
<li><p>从一个线程观察另外一个线程的时候，看到的都是一个个原子性的操作</p>
</li>
<li><p>例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">	a = <span class="number">1</span>;</span><br><span class="line">	b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">从一个线程观察另一个线程执行上述代码，只有两种结果</span><br><span class="line">	<span class="number">1</span> a,b 都被赋值成功</span><br><span class="line">	<span class="number">2</span> a,b 都未被赋值</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-可见性-Visibility"><a href="#2-可见性-Visibility" class="headerlink" title="2 可见性 Visibility"></a>2 可见性 <code>Visibility</code></h3><ol>
<li>可见性指当一个线程修改了某个共享变量后，其他线程是否能够立即知道这个修改</li>
<li>每个线程都有自己的工作内存，所以当线程修改完某个变量之后，在其他的线程中，未必能观察到该变量已经被修改</li>
</ol>
<h3 id="3-有序性-Ordering"><a href="#3-有序性-Ordering" class="headerlink" title="3 有序性 Ordering"></a>3 有序性 <code>Ordering</code></h3><ol>
<li>指令重排序<ol>
<li>JVM 在不影响正确性的前提下，可以调整指令的执行顺序，这种特性称之为『指令重排』，指令重排可以提高 CPU 的处理性能</li>
<li><code>as-if-serial</code> 语义：不管如何重排序，必须保证串行语义一致，即单线程下，程序的执行结果不会改变</li>
</ol>
</li>
<li>指令重排在多线程下有可能影响正确性</li>
</ol>
<h2 id="6-5-Happens-Before-规则"><a href="#6-5-Happens-Before-规则" class="headerlink" title="6.5 Happens-Before 规则"></a>6.5 <code>Happens-Before</code> 规则</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>happens-before</code> 规则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据</li>
<li>可以通过此规则分析一个并发程序是否安全</li>
<li>如果 <code>A happens-bofore B</code>，则 A 操作先于 B 操作发生，且 <code>A</code> 操作的结果对 B 可见</li>
</ol>
<h3 id="2-规则"><a href="#2-规则" class="headerlink" title="2 规则"></a>2 规则</h3><table>
<thead>
<tr>
<th>规则</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>程序顺序规则（<code>Program Order Rule</code>）</td>
<td>一个线程内保证语义的串行性，即按照代码顺序执行，前面的操作 <code>happens-before</code> 后续的任何操作</td>
</tr>
<tr>
<td>管程锁定规则（<code>Monitor Lock Rule</code>）</td>
<td>同一个锁的解锁操作 <code>happens-before</code> 后续对这个锁的加锁操作</td>
</tr>
<tr>
<td><code>volatile</code> 变量规则（<code>volatile Variable Rule</code>）</td>
<td><code>volatile</code> 变量的写操作，<code>happens-before</code> 后续对这个变量的读操作</td>
</tr>
<tr>
<td>线程启动规则（<code>Thread Start Rule</code>）</td>
<td>线程 <code>start()</code> 方法 <code>happens-before</code> 线程中的每一个操作</td>
</tr>
<tr>
<td>线程终止规则（<code>Thread Termination Rule</code>）</td>
<td>线程的所有操作 <code>happens-before</code> 线程的终结</td>
</tr>
<tr>
<td>线程中断规则（<code>Thread Interruption Rule</code>）</td>
<td>线程 <code>interrupt()</code> 方法的调用 <code>happens—before</code> 被中断线程的代码检测到中断事件的发生</td>
</tr>
<tr>
<td>对象终结规则（<code>Finalizer Rule</code>）</td>
<td>一个对象的初始化完成（构造函数执行）<code>happens—before</code> 它的 <code>finalize()</code> 方法</td>
</tr>
<tr>
<td>传递性（<code>Transitivity</code>）</td>
<td>如果 <code>A happens-before B，B happens-before C</code>，那么 <code>A happens-before C</code></td>
</tr>
</tbody></table>
<h2 id="6-6-volatile"><a href="#6-6-volatile" class="headerlink" title="6.6 volatile"></a>6.6 <code>volatile</code></h2><h3 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>volatile</code> 是Java虚拟机提供的轻量级的同步机制</li>
<li><code>volatile</code> 有两个作用：<ol>
<li>保证可见性</li>
<li>禁止指令重排序</li>
</ol>
</li>
<li><code>volatile</code> 无法保证原子性</li>
<li>内存屏障 <code>Memory Barrier</code><ol>
<li>对 <code>volatile</code> 变量的写指令后会加入写屏障 <code>storefence</code></li>
<li>对<code>volatile</code> 变量的读指令前会加入读屏障 <code>loadfence</code></li>
</ol>
</li>
</ol>
<h3 id="2-Volatile-可见性"><a href="#2-Volatile-可见性" class="headerlink" title="2 Volatile 可见性"></a>2 <code>Volatile</code> 可见性</h3><ol>
<li>硬件层面：<code>MESI</code><ul>
<li>当某个线程修改了被 <code>volatile</code> 修饰的共享变量的值，会马上同步到主内存，而开启了 CPU 总线嗅探机制的线程就会得知此修改，然后将自己工作内存中的共享变量副本失效，这样使用时就需要重新从主内存中读取</li>
</ul>
</li>
<li>JVM 层面：<code>Memory Barrier</code><ol>
<li>写屏障保证在该屏障之前的，对共享变量的改动，都同步到主内存当中</li>
<li>读屏障保证在该屏障之后，对共享变量的读取，加载的是主内存中最新数据</li>
</ol>
</li>
</ol>
<h3 id="3-Volatile-有序性"><a href="#3-Volatile-有序性" class="headerlink" title="3 Volatile 有序性"></a>3 <code>Volatile</code> 有序性</h3><ol>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li>
<li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li>
</ol>
<h2 id="6-7-synchronized"><a href="#6-7-synchronized" class="headerlink" title="6.7 synchronized"></a>6.7 <code>synchronized</code></h2><h3 id="1-概述-4"><a href="#1-概述-4" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>synchronized</code> 内置锁是一种对象锁（锁的是对象而非引用），作用粒度是对象，可以用来实现对临界资源的同步互斥访问，是可重入的</li>
<li><code>synchronized</code> 可以保证原子性和可见性，不能保证有序性，但如果共享变量完全被 <code>synchronized</code> 控制，则不会出现有序性问题</li>
</ol>
<h3 id="2-同步代码块"><a href="#2-同步代码块" class="headerlink" title="2 同步代码块"></a>2 同步代码块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized(锁) &#123;</span><br><span class="line">	1. 同步代码块的锁可以是任意对象</span><br><span class="line">	2. 不要使用 String Integer Long 作为锁对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-同步函数"><a href="#3-同步函数" class="headerlink" title="3 同步函数"></a>3 同步函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 synchronized 返回值 方法名(形参列表)&#123;</span><br><span class="line">	1. 非静态同步函数的锁是 this</span><br><span class="line">	2. 静态同步函数的锁是当前类的字节码对象 类.class</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-synchronized-原理"><a href="#4-synchronized-原理" class="headerlink" title="4 synchronized 原理"></a>4 <code>synchronized</code> 原理</h3><h4 id="1-对象头"><a href="#1-对象头" class="headerlink" title="1 对象头"></a>1 对象头</h4><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" alt=""></p>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/MarkWord32.png" alt=""></p>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/MarkWord64.png" alt=""></p>
<h4 id="2-Monitor：监视器-管程"><a href="#2-Monitor：监视器-管程" class="headerlink" title="2 Monitor：监视器/管程"></a>2 <code>Monitor</code>：监视器/管程</h4><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/monitor.png" alt=""></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Owner</code></td>
<td>当一个线程获取锁，并正常执行，则将 <code>Owner</code> 指向此线程，<code>Owner</code> 只能有一个值</td>
</tr>
<tr>
<td><code>EntryList</code></td>
<td>尝试获取此锁的线程如果获取不到，会阻塞进入 <code>EntryList</code></td>
</tr>
<tr>
<td><code>WaitSet</code></td>
<td>已经获取锁但条件不满足，进入等待状态的线程会进入 <code>WaitSet</code></td>
</tr>
</tbody></table>
<h4 id="3-原理"><a href="#3-原理" class="headerlink" title="3 原理"></a>3 原理</h4><ol>
<li><p>每个 Java 对象都有一个自己的 <code>Monitor</code> 对象，当给对象上锁（重量级锁）后，该对象头的 <code>Mark Word</code> 就会指向 <code>Monitor</code></p>
</li>
<li><p><code>Monitor</code> 的实现依赖底层操作系统的 <code>Mutex lock</code>（互斥锁）实现，它是一个重量级锁性能较低</p>
</li>
<li><p><code>synchronized</code> JVM内置锁通过内部对象 <code>Monitor</code> 实现，基于进入与退出 <code>Monitor</code> 对象实现方法与代码块同步</p>
</li>
<li><p><code>synchronized</code> 关键字被编译成字节码后会被翻译成 <code>monitorenter</code> 和 <code>monitorexit</code> 两条指令分别在同步块逻辑代码的起始位置与结束位置</p>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/smonitor.png" alt=""></p>
</li>
</ol>
<h3 id="4-锁优化"><a href="#4-锁优化" class="headerlink" title="4 锁优化"></a>4 锁优化</h3><h4 id="1-锁粗化"><a href="#1-锁粗化" class="headerlink" title="1 锁粗化"></a>1 锁粗化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sb.append(<span class="number">1</span>);</span><br><span class="line">    sb.append(<span class="number">2</span>);</span><br><span class="line">    sb.append(<span class="number">3</span>);</span><br><span class="line">    sb.append(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">StringBuffer是线程安全的，append方法有sychronized修饰，那么调用了4次append方法，就相当于有了四个同步块</span></span><br><span class="line"><span class="comment">    sychronized()&#123;</span></span><br><span class="line"><span class="comment">        append(1);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    sychronized()&#123;</span></span><br><span class="line"><span class="comment">        append(2);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    sychronized()&#123;</span></span><br><span class="line"><span class="comment">        append(3);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    sychronized()&#123;</span></span><br><span class="line"><span class="comment">        append(4);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">而这是没有必要的，锁粗化相当于</span></span><br><span class="line"><span class="comment">    sychronized()&#123;</span></span><br><span class="line"><span class="comment">        append(1);</span></span><br><span class="line"><span class="comment">        append(2);</span></span><br><span class="line"><span class="comment">        append(3);</span></span><br><span class="line"><span class="comment">        append(4);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<h4 id="2-锁消除"><a href="#2-锁消除" class="headerlink" title="2 锁消除"></a>2 锁消除</h4><ul>
<li>Java虚拟机在 JIT 编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间</li>
</ul>
<h4 id="3-锁膨胀升级"><a href="#3-锁膨胀升级" class="headerlink" title="3 锁膨胀升级"></a>3 锁膨胀升级</h4><h5 id="1-概述-5"><a href="#1-概述-5" class="headerlink" title="1 概述"></a>1 概述</h5><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/synchronized%E9%94%81%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png" alt=""></p>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E9%94%81%E5%8D%87%E7%BA%A7.png" alt=""></p>
<ul>
<li>偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁</li>
<li>轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争</li>
<li>重量级锁：有实际竞争，且锁竞争时间长</li>
</ul>
<h5 id="2-偏向锁"><a href="#2-偏向锁" class="headerlink" title="2 偏向锁"></a>2 偏向锁</h5><ol>
<li>在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁（会涉及到一些 CAS 操作）的代价而引入偏向锁</li>
<li>偏向锁核心思想：如果一个线程获得了锁，那么锁就进入偏向模式，此时 <code>Mark Word</code> 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作（即获取锁的过程），这样就省去了大量有关锁申请的操作</li>
<li>偏向锁默认开启，但有延迟</li>
<li>调用了对象的 <code>hashCode</code> ，会导致偏向锁被撤销</li>
<li>如果发生了竞争，则偏向锁会失效，会膨胀为轻量级锁</li>
</ol>
<h5 id="3-轻量级锁"><a href="#3-轻量级锁" class="headerlink" title="3 轻量级锁"></a>3 轻量级锁</h5><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%811.png" alt=""></p>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%812.png" alt=""></p>
<ol>
<li>轻量级锁所适应的场景是线程交替执行同步块的场合</li>
<li>轻量级锁在没有竞争时，每次锁重入仍需要执行 <code>CAS</code> 操作</li>
<li>如果在尝试加轻量级锁的过程中，<code>CAS</code> 操作无法成功，一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），则轻量级锁会失败，轻量级锁失败后并不会立即膨胀为重量级锁，而是会先使用锁自旋的优化手段</li>
<li><strong>自旋锁</strong><ol>
<li>在大多数情况下，线程持有锁的时间都不会太长，如果当前线程获取轻量级锁失败后直接挂起，可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高</li>
<li>自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，将轻量级锁膨胀为重量级锁</li>
</ol>
</li>
</ol>
<h3 id="5-锁活跃性"><a href="#5-锁活跃性" class="headerlink" title="5 锁活跃性"></a>5 锁活跃性</h3><ol>
<li>死锁：一个线程需要同时获取多把锁，这时就容易发生死锁（例如锁嵌套）</li>
<li>活锁：两个线程互相改变对方的结束条件，导致谁也无法结束</li>
<li>饥饿：一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束</li>
</ol>
<h2 id="6-8-常见线程安全类"><a href="#6-8-常见线程安全类" class="headerlink" title="6.8 常见线程安全类"></a>6.8 常见线程安全类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String</span><br><span class="line">Integer</span><br><span class="line">StringBuffer</span><br><span class="line">Random</span><br><span class="line">Vector</span><br><span class="line">Hashtable</span><br><span class="line">java.util.concurrent.*</span><br></pre></td></tr></table></figure>

<ol>
<li>线程安全指的是多个线程调用这些类的同一实例的同一方法是线程安全的</li>
<li>它们每个方法是原子的，但多个方法的组合不是原子的</li>
</ol>
<h1 id="七-等待唤醒机制"><a href="#七-等待唤醒机制" class="headerlink" title="七 等待唤醒机制"></a>七 等待唤醒机制</h1><h2 id="7-1-wait-notify"><a href="#7-1-wait-notify" class="headerlink" title="7.1 wait/notify"></a>7.1 <code>wait/notify</code></h2><h3 id="1-概述-6"><a href="#1-概述-6" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>只有重量级锁才有等待唤醒方法<ol>
<li><code>wait()</code>：相当于 <code>wait(0)</code>，无限等待直到被唤醒</li>
<li><code>wait(long timeout)</code>：等待指定时间或被唤醒</li>
<li><code>notify()</code></li>
<li><code>notifyAll()</code></li>
</ol>
</li>
<li>获取锁之后才能调用等待唤醒方法，即等待唤醒的方法要在同步代码中执行，且需要同一个锁对象来调用</li>
<li>等待时释放锁，进入 <code>Monitor</code> 的 <code>WaitSet</code>，唤醒之后不会立即获取锁，而是进入 <code>Monitor</code> 的 <code>EntrySet</code> 重新竞争</li>
</ol>
<h3 id="2-wait-amp-sleep"><a href="#2-wait-amp-sleep" class="headerlink" title="2 wait &amp; sleep"></a>2 <code>wait</code> &amp; <code>sleep</code></h3><table>
<thead>
<tr>
<th>方法</th>
<th>所属</th>
<th>参数</th>
<th>锁</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td><code>wait()</code></td>
<td><code>Object</code></td>
<td>无参：无限等待<br/>有参：有限等待</td>
<td>释放锁</td>
<td>必须先获取锁，在同步代码中使用</td>
</tr>
<tr>
<td><code>sleep()</code></td>
<td><code>Thread</code></td>
<td>有参：有限睡眠</td>
<td>不释放锁</td>
<td>可直接使用</td>
</tr>
</tbody></table>
<h3 id="3-模式"><a href="#3-模式" class="headerlink" title="3 模式"></a>3 模式</h3><ol>
<li>同步模式之保护性暂停 <ol>
<li><code>Guarded Suspension</code>：用在一个线程等待另一个线程的执行结果</li>
<li>结果需要从一个线程传递到另一个线程，让他们关联同一个 <code>GuardedObject</code></li>
<li>产生结果的线程与消费结果的线程需要一一对应</li>
<li>JDK 中，<code>join</code> 的实现、<code>Future</code> 的实现，采用的就是此模式</li>
</ol>
</li>
<li>异步模式之生产者/消费者<ol>
<li>产生结果的线程与消费结果的线程不需要一一对应</li>
<li>JDK 中各种阻塞队列，采用的就是这种模式</li>
</ol>
</li>
</ol>
<h2 id="7-2-park-unpark"><a href="#7-2-park-unpark" class="headerlink" title="7.2 park/unpark"></a>7.2 <code>park/unpark</code></h2><h3 id="1-与-wait-amp-notify-相比"><a href="#1-与-wait-amp-notify-相比" class="headerlink" title="1 与 wait &amp; notify 相比"></a>1 与 <code>wait &amp; notify</code> 相比</h3><ol>
<li><code>wait &amp; notify</code> 必须配合 <code>Object Monitor</code> 使用，<code>park &amp; unpark</code> 则不必</li>
<li><code>wait &amp; notify</code> 只能随机唤醒等待线程，<code>park &amp; unpark</code> 是以线程为单位来等待唤醒的，所以精确</li>
<li><code>wait &amp; notify</code> 不能先 <code>notify</code>，<code>park &amp; unpark</code> 可以先 <code>unpark</code>，即先 <code>unpark</code> 也能恢复 <code>park</code> 的线程</li>
</ol>
<h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2 原理"></a>2 原理</h3><ol>
<li>每个线程都有自己的一个 <code>Parker</code> 对象，由三部分组成<ul>
<li><code>_counter</code></li>
<li><code>_cond</code></li>
<li><code>_mutex</code></li>
</ul>
</li>
<li><code>park()</code><ol>
<li>判断 <code>_counter</code><ul>
<li><code>_counter == 0</code> 则等待</li>
<li><code>_counter == 1</code> 则继续运行</li>
</ul>
</li>
<li>将 <code>_counter</code> 设置为 <code>0</code></li>
</ol>
</li>
<li><code>unpark()</code><ol>
<li>将 <code>_counter</code> 设置为 <code>1</code></li>
<li>判断线程状态<ol>
<li>如果线程正在等待，则唤醒线程</li>
<li>如果线程正在运行，则继续运行，且由于 <code>_counter</code> 设置为了 <code>1</code> ，线程下次调用 <code>park()</code> 时，会继续执行</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="八-CAS"><a href="#八-CAS" class="headerlink" title="八 CAS"></a>八 <code>CAS</code></h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><ol>
<li><code>Compare And Swap</code> 或 <code>Compare And Set</code></li>
<li>CAS 是一种无锁算法，体现的是无锁并发、无阻塞并发</li>
<li>CAS 必须借助 <code>volatile</code> ，因为需要保证可见性来读取最新值</li>
<li>内部通过 <code>Unsafe</code> 实现，<code>Unsafe</code> 直接操作虚拟机内存，类似 <code>C C++</code> 的指针</li>
<li><code>ABA</code> 问题：<code>version</code></li>
</ol>
<h2 id="8-2-原理"><a href="#8-2-原理" class="headerlink" title="8.2 原理"></a>8.2 原理</h2><ol>
<li>CAS 包含三个操作数：<ul>
<li>内存值 <code>V</code></li>
<li>预估值 <code>A</code></li>
<li>更新值 <code>B</code></li>
</ul>
</li>
<li>第一次读取内存值记录为 <code>A</code>，之后进行一些操作</li>
<li>当真正写入数据时，再次读取内存值 <code>V</code>，当且仅当 <code>V == A</code> 时，才会更新 <code>V = B</code></li>
</ol>
<h1 id="九-java-util-concurrent-atomic"><a href="#九-java-util-concurrent-atomic" class="headerlink" title="九 java.util.concurrent.atomic"></a>九 <code>java.util.concurrent.atomic</code></h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td>基本类型原子类</td>
<td><code>AtomicInteger</code><br><code>AtomicBoolean</code><br><code>AtomicLong</code></td>
</tr>
<tr>
<td>引用类型原子类</td>
<td><code>AtomicReference&lt;V&gt;</code><br><code>AtomicStampedReference&lt;V&gt;</code><br><code>AtomicMarkableReference&lt;V&gt;</code></td>
</tr>
<tr>
<td>数组类型原子类</td>
<td><code>AtomicIntegerArray</code><br/><code>AtomicLongArray</code><br/><code>AtomicReferenceArray&lt;E&gt;</code></td>
</tr>
<tr>
<td>原子字段更新器</td>
<td><code>AtomicIntegerFieldUpdater&lt;T&gt;</code><br/><code>AtomicLongFieldUpdater&lt;T&gt;</code><br/><code>AtomicReferenceFieldUpdater&lt;T, V&gt;</code></td>
</tr>
<tr>
<td>原子累加器</td>
<td><code>LongAdder</code><br/><code>DoubleAdder</code><br/><code>LongAccumulator</code><br><code>DoubleAccumulator</code></td>
</tr>
</tbody></table>
<ol>
<li><code>AtomicReference&lt;V&gt;</code><ul>
<li>只关心当前值和预期值是否相等，不知道值是否被修改过（ABA问题），如 <code>A → B → C → A</code></li>
</ul>
</li>
<li><code>AtomicStampedReference&lt;V&gt;</code><ul>
<li>增加一个版本号属性，每次修改都使版本号 + 1，可以知道值被修改过几次</li>
</ul>
</li>
<li><code>AtomicMarkableReference&lt;V&gt;</code><ul>
<li>增加要给布尔属性，判断值是否被修改过</li>
</ul>
</li>
</ol>
<h2 id="9-2-AtomicInteger"><a href="#9-2-AtomicInteger" class="headerlink" title="9.2 AtomicInteger"></a>9.2 <code>AtomicInteger</code></h2><h3 id="1-构造-1"><a href="#1-构造-1" class="headerlink" title="1 构造"></a>1 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>AtomicInteger()</code></td>
<td>使用默认值 <code>0</code></td>
</tr>
<tr>
<td><code>AtomicInteger(int initialValue)</code></td>
<td>使用指定值</td>
</tr>
</tbody></table>
<h3 id="2-方法-1"><a href="#2-方法-1" class="headerlink" title="2 方法"></a>2 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>get()</code></td>
<td>获取当前值</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>compareAndSet(int expectedValue, int newValue)</code></td>
<td>如果当前值与预期值相等，则将当前值设置为新值并返回 <code>true</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getAndIncrement()</code></td>
<td><code>i++</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>incrementAndGet()</code></td>
<td><code>++i</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getAndDecrement()</code></td>
<td><code>i--</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>decrementAndGet()</code></td>
<td><code>--i</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getAndAdd(int delta)</code></td>
<td>返回原值，之后将值加上指定值</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>addAndGet(int delta)</code></td>
<td>将值加上指定值并返回</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getAndUpdate(IntUnaryOperator updateFunction)</code></td>
<td>获取原值并计算</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>updateAndGet(IntUnaryOperator updateFunction)</code></td>
<td>计算并返回</td>
</tr>
</tbody></table>
<h1 id="十-java-util-concurrent-locks"><a href="#十-java-util-concurrent-locks" class="headerlink" title="十 java.util.concurrent.locks"></a>十 <code>java.util.concurrent.locks</code></h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/JUC-locks.png" alt=""></p>
<h2 id="10-1-Lock"><a href="#10-1-Lock" class="headerlink" title="10.1 Lock"></a>10.1 <code>Lock</code></h2><h3 id="1-API"><a href="#1-API" class="headerlink" title="1 API"></a>1 API</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>lock()</code></td>
<td>获取锁</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>unlock()</code></td>
<td>释放锁</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>tryLock()</code></td>
<td>尝试获取锁</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>tryLock(long time, TimeUnit unit)</code></td>
<td>尝试获取锁，会尝试指定时间</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>lockInterruptibly()</code></td>
<td>功能同 <code>locak</code>，如果线程被中断会抛出异常</td>
</tr>
<tr>
<td><code>Condition</code></td>
<td><code>newCondition()</code></td>
<td>创建一个该锁的 <code>Condition</code> 对象</td>
</tr>
</tbody></table>
<h3 id="2-典型使用"><a href="#2-典型使用" class="headerlink" title="2 典型使用"></a>2 典型使用</h3><h4 id="1-lock"><a href="#1-lock" class="headerlink" title="1 lock()"></a>1 <code>lock()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock l = ...;</span><br><span class="line">l.lock(); <span class="comment">// 获取锁后要紧跟 try</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// access the resource protected by this lock</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  l.unlock(); <span class="comment">// 释放锁要在 finally 的第一行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-tryLock"><a href="#2-tryLock" class="headerlink" title="2 tryLock()"></a>2 <code>tryLock()</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line"><span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// manipulate protected state</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// perform alternative actions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-ReentrantLock"><a href="#3-ReentrantLock" class="headerlink" title="3 ReentrantLock"></a>3 <code>ReentrantLock</code></h3><h4 id="1-构造-2"><a href="#1-构造-2" class="headerlink" title="1 构造"></a>1 构造</h4><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ReentrantLock()</code></td>
<td>默认为非公平锁</td>
</tr>
<tr>
<td><code>ReentrantLock(boolean fair)</code></td>
<td>可创建公平锁（但没有必要，会降低并发度）</td>
</tr>
</tbody></table>
<h4 id="2-与-synchronized-比较"><a href="#2-与-synchronized-比较" class="headerlink" title="2 与 synchronized 比较"></a>2 与 <code>synchronized</code> 比较</h4><ol>
<li>在 <code>synchronized</code> 未优化之前，皆为重量级锁，所以才引入 <code>ReentrantLock</code>，<code>ReentrantLock</code> 提供了更丰富的 API</li>
<li><code>synchronized</code> 和 <code>ReetrantLock</code> 都是可重入锁</li>
<li><code>synchronized</code> 获取不到锁会一直阻塞；<code>ReentrantLock</code> 获取不到锁可以被中断或超时</li>
<li><code>ReetrantLock</code> 可设置公平锁</li>
<li><code>synchronized</code>只有一个条件，不满足时进入 <code>WaitSet</code> 等待；<code>ReetrantLock</code> 一个锁可以对应多个 <code>Condition</code></li>
</ol>
<h2 id="10-2-Condition"><a href="#10-2-Condition" class="headerlink" title="10.2 Condition"></a>10.2 <code>Condition</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>await()</code></td>
<td>当前线程等待，直到被打断或被唤醒</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>await(long time, TimeUnit unit)</code></td>
<td>当前线程等待，直到被打断或被唤醒或超时</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>awaitNanos(long nanosTimeout)</code></td>
<td>当前线程等待，直到被打断或被唤醒或超时</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>awaitUninterruptibly()</code></td>
<td>当前线程等待，直到被唤醒</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>signal()</code></td>
<td>唤醒一个等待线程</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>signalAll()</code></td>
<td>唤醒所有等待线程</td>
</tr>
</tbody></table>
<h2 id="10-3-ReadWriteLock"><a href="#10-3-ReadWriteLock" class="headerlink" title="10.3 ReadWriteLock"></a>10.3 <code>ReadWriteLock</code></h2><h3 id="1-概述-7"><a href="#1-概述-7" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>读写锁，将锁更细粒度的划分：<ul>
<li>共享锁（读）</li>
<li>排他锁（写）</li>
</ul>
</li>
<li>读锁可以被多个线程共享（当读操作多时，多个读线程可以并发执行，提高效率），写锁则只能一个线程独占</li>
<li><code>ReentrantReadWriteLock</code>：唯一实现类</li>
<li><code>StampedLock</code>：能力更强的读写锁</li>
</ol>
<h3 id="2-API"><a href="#2-API" class="headerlink" title="2 API"></a>2 API</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Lock</code></td>
<td><code>readLock()</code></td>
<td>获取读锁</td>
</tr>
<tr>
<td><code>Lock</code></td>
<td><code>writeLock()</code></td>
<td>获取写锁</td>
</tr>
</tbody></table>
<h2 id="10-4-LockSupport"><a href="#10-4-LockSupport" class="headerlink" title="10.4 LockSupport"></a>10.4 <code>LockSupport</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Object</code></td>
<td><code>getBlocker(Thread t)</code></td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>park()</code></td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>park(Object blocker)</code></td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>parkNanos(long nanos)</code></td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>parkNanos(Object blocker, long nanos)</code></td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>parkUntil(long deadline)</code></td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>parkUntil(Object blocker, long deadline)</code></td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>unpark(Thread thread)</code></td>
</tr>
</tbody></table>
<h1 id="十一-辅助工具类"><a href="#十一-辅助工具类" class="headerlink" title="十一 辅助工具类"></a>十一 辅助工具类</h1><h2 id="11-1-Semaphore"><a href="#11-1-Semaphore" class="headerlink" title="11.1 Semaphore"></a>11.1 <code>Semaphore</code></h2><h3 id="1-概述-8"><a href="#1-概述-8" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>Semaphore</code> 是一个计数信号量，必须由获取它的线程释放</li>
<li>用来控制同时访问资源的线程数量（限流）</li>
</ol>
<h3 id="2-构造"><a href="#2-构造" class="headerlink" title="2 构造"></a>2 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Semaphore(int permits)</code></td>
<td>创建具有给定许可数的计数信号量，默认为非公平信号量</td>
</tr>
<tr>
<td><code>Semaphore(int permits, boolean fair)</code></td>
<td>创建具有给定许可数的计数信号量，可设置为公平信号量</td>
</tr>
</tbody></table>
<h3 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>acquire()</code></td>
<td>从信号量中获取一个许可，在提供一个可用许可之前一直等待</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>acquire(int permits)</code></td>
<td>从信号量中获取指定数量的许可</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>release()</code></td>
<td>释放一个许可，将其返回给信号量</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>release(int permits)</code></td>
<td>释放指定数量的许可，将其返回给信号量</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>availablePermits()</code></td>
<td>获取当前可用的许可个数</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>hasQueuedThreads()</code></td>
<td>是否有线程在等待获取许可</td>
</tr>
<tr>
<td>`int</td>
<td><code>getQueueLength()</code></td>
<td>获取正在等待获取许可的线程数</td>
</tr>
<tr>
<td><code>protected Collection&lt;Thread&gt;</code></td>
<td><code>getQueuedThreads()</code></td>
<td>获取所有等待获取许可的线程集合</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>drainPermits()</code></td>
<td>获取可用许可个数，并将可用许可置为 0</td>
</tr>
</tbody></table>
<h2 id="11-2-CountDownLatch"><a href="#11-2-CountDownLatch" class="headerlink" title="11.2 CountDownLatch"></a>11.2 <code>CountDownLatch</code></h2><h3 id="1-概述-9"><a href="#1-概述-9" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>用来进行线程同步写作，等待所有线程完成倒计时</li>
<li>允许一个或多个线程等待其他线程完成操作</li>
</ol>
<h3 id="2-构造-1"><a href="#2-构造-1" class="headerlink" title="2 构造"></a>2 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>CountDownLatch(int count)</code></td>
<td>构造时传入一个计数</td>
</tr>
</tbody></table>
<h3 id="3-方法-1"><a href="#3-方法-1" class="headerlink" title="3 方法"></a>3 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>countDown()</code></td>
<td>计数减 <code>1</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>await()</code></td>
<td>当前线程等待，当计数归 <code>0</code>，当前线程继续执行</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>await(long timeout, TimeUnit unit)</code></td>
<td>当前线程等待，当计数归 <code>0</code> 或者超时，当前线程继续执行</td>
</tr>
</tbody></table>
<h2 id="11-3-CyclicBarrier"><a href="#11-3-CyclicBarrier" class="headerlink" title="11.3 CyclicBarrier"></a>11.3 <code>CyclicBarrier</code></h2><h3 id="1-概述-10"><a href="#1-概述-10" class="headerlink" title="1 概述"></a>1 概述</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/CyclicBarrier.gif" alt=""></p>
<ol>
<li>循环栅栏，用来进行线程协作，等待线程满足某个计数</li>
<li>阻塞一组线程直到某个事件的发生</li>
<li><code>CountDownLatch</code> 只能拦截一轮，<code>CyclicBarrier</code> 可以实现循环拦截</li>
<li>构造时设置计数，每个线程执行到某个需要同步的时刻则等待，当等待的线程数满足计数时，继续执行</li>
</ol>
<h3 id="2-构造-2"><a href="#2-构造-2" class="headerlink" title="2 构造"></a>2 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>CyclicBarrier(int parties)</code></td>
<td>构造时传入一个计数，表示需要等待的线程数</td>
</tr>
<tr>
<td><code>CyclicBarrier(int parties, Runnable barrierAction)</code></td>
<td><code>barrierAction</code>：等待线程数达到时首先执行的任务</td>
</tr>
</tbody></table>
<h3 id="3-方法-2"><a href="#3-方法-2" class="headerlink" title="3 方法"></a>3 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>await()</code></td>
<td>当前线程等待，直到等待线程数达到初始计数</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>await(long timeout, TimeUnit unit)</code></td>
<td>当前线程等待，直到等待线程数达到初始计数或超时</td>
</tr>
</tbody></table>
<h1 id="十二-线程池"><a href="#十二-线程池" class="headerlink" title="十二 线程池"></a>十二 线程池</h1><h2 id="12-1-线程池体系"><a href="#12-1-线程池体系" class="headerlink" title="12.1 线程池体系"></a>12.1 线程池体系</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/JUC-executor.png" alt=""></p>
<h2 id="12-2-线程池执行过程"><a href="#12-2-线程池执行过程" class="headerlink" title="12.2 线程池执行过程"></a>12.2 线程池执行过程</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%87%E7%A8%8B01.png" alt=""></p>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%87%E7%A8%8B02.png" alt=""></p>
<h2 id="12-3-线程池状态"><a href="#12-3-线程池状态" class="headerlink" title="12.3 线程池状态"></a>12.3 线程池状态</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.png" alt=""></p>
<table>
<thead>
<tr>
<th>状态</th>
<th>高 3 位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Running</code></td>
<td><code>111</code></td>
<td>接收新任务，能处理已添加任务</td>
</tr>
<tr>
<td><code>Shutdown</code></td>
<td><code>000</code></td>
<td>不接收新任务，能处理已添加任务</td>
</tr>
<tr>
<td><code>Stop</code></td>
<td><code>001</code></td>
<td>不接收新任务，不处理已添加任务，且中断正在处理的任务</td>
</tr>
<tr>
<td><code>Tidying</code></td>
<td><code>010</code></td>
<td>所有任务已终止，<code>ctl</code> 记录的活动线程为 0，即将进入终结</td>
</tr>
<tr>
<td><code>Terminated</code></td>
<td><code>011</code></td>
<td>线程池彻底终止</td>
</tr>
</tbody></table>
<ol start="2">
<li>线程池的运行状态和活动线程数信息存储在一个原子变量 <code>AtomicInteger ctl</code> 中，目的是将线程池状态和线程个数合二为一，这样就可以用一次 <code>CAS</code> 原子操作进行赋值</li>
<li><code>ctl</code> 高 3 位表示线程池状态，低 29 位表示线程池数量</li>
</ol>
<h2 id="12-4-线程池数量"><a href="#12-4-线程池数量" class="headerlink" title="12.4 线程池数量"></a>12.4 线程池数量</h2><ol>
<li><code>N<sub>threds</sub> = N<sub>CPU</sub> * U<sub>CPU</sub> * (1 + W/C)</code><ul>
<li><code>N<sub>CPU</sub></code> ：CPU 的核数</li>
<li><code>U<sub>CPU</sub></code> ：CPU 期望利用率 <code>(0, 1]</code></li>
<li><code>W/C</code> ：等待时间和计算时间比率</li>
</ul>
</li>
<li>CPU 密集型运算：<code>线程数 = CPU核数 + 1</code></li>
<li>I/O 密集型运算：<code>线程数 = CPU核数 * 期望CPU利用率 *（CPU计算时间 + 等待时间）/ CPU计算时间</code></li>
</ol>
<h2 id="12-5-ThreadPoolExecutor"><a href="#12-5-ThreadPoolExecutor" class="headerlink" title="12.5 ThreadPoolExecutor"></a>12.5 <code>ThreadPoolExecutor</code></h2><h3 id="1-构造-3"><a href="#1-构造-3" class="headerlink" title="1 构造"></a>1 构造</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, </span><br><span class="line">                    <span class="keyword">int</span> maximumPoolSize, </span><br><span class="line">                    <span class="keyword">long</span> keepAliveTime, </span><br><span class="line">                    TimeUnit unit, </span><br><span class="line">                    BlockingQueue&lt;Runnable&gt; workQueue, </span><br><span class="line">                    ThreadFactory threadFactory, </span><br><span class="line">                    RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int corePoolSize</code></td>
<td>核心线程数</td>
</tr>
<tr>
<td><code>int maximumPoolSize</code></td>
<td>最大线程数</td>
</tr>
<tr>
<td><code>long keepAliveTime</code></td>
<td>线程最大空闲时间，如果线程池中线程数量超过 <code>corePoolSize</code>，超出线程空闲时间超过 <code>keepAliveTime</code> 会被终止</td>
</tr>
<tr>
<td><code>TimeUnit unit</code></td>
<td>空闲时间单位</td>
</tr>
<tr>
<td><code>BlockingQueue&lt;Runnable&gt; workQueue</code></td>
<td>任务阻塞队列</td>
</tr>
<tr>
<td><code>ThreadFactory threadFactory</code></td>
<td>线程工厂</td>
</tr>
<tr>
<td><code>RejectedExecutionHandler handler</code></td>
<td>拒绝策略</td>
</tr>
</tbody></table>
<h4 id="1-Enum-TimeUnit"><a href="#1-Enum-TimeUnit" class="headerlink" title="1 Enum TimeUnit"></a>1 <code>Enum TimeUnit</code></h4><h5 id="1-枚举项：时间粒度"><a href="#1-枚举项：时间粒度" class="headerlink" title="1 枚举项：时间粒度"></a>1 枚举项：时间粒度</h5><table>
<thead>
<tr>
<th>粒度</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>NANOSECONDS</code></td>
<td>纳秒 <code>ns</code></td>
<td><code>1 s  = 10<sup>9</sup> ns</code></td>
</tr>
<tr>
<td><code>MICROSECONDS</code></td>
<td>微秒 <code>μs</code></td>
<td><code>1 s  = 10<sup>6</sup> μs</code></td>
</tr>
<tr>
<td><code>MILLISECONDS</code></td>
<td>毫秒 <code>ms</code></td>
<td><code>1 s  = 10<sup>3</sup> ms</code></td>
</tr>
<tr>
<td><code>SECONDS</code></td>
<td>秒 <code>s</code></td>
<td></td>
</tr>
<tr>
<td><code>MINUTES</code></td>
<td>分 <code>min</code></td>
<td></td>
</tr>
<tr>
<td><code>HOURS</code></td>
<td>时 <code>h</code></td>
<td></td>
</tr>
<tr>
<td><code>DAYS</code></td>
<td>日 <code>d</code></td>
<td></td>
</tr>
</tbody></table>
<h5 id="2-方法：线程"><a href="#2-方法：线程" class="headerlink" title="2 方法：线程"></a>2 方法：线程</h5><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>sleep(long timeout)</code></td>
<td>当前线程睡眠当前粒度的 <code>timout</code>，替代 <code>Thread.sleep(timeout)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>timedJoin(Thread thread, long timeout)</code></td>
<td>指定线程 <code>join</code> 当前粒度的 <code>timeout</code>，替代 <code>t.join(timout)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>timedWait(Object obj, long timeout)</code></td>
<td>锁对象 <code>obj</code> 等待当前粒度的 <code>timout</code>，替代 <code>obj.wait(timout)</code></td>
</tr>
</tbody></table>
<h5 id="3-方法：时间粒度转换"><a href="#3-方法：时间粒度转换" class="headerlink" title="3 方法：时间粒度转换"></a>3 方法：时间粒度转换</h5><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>long</code></td>
<td><code>convert(Duration duration)</code></td>
<td>将指定时间间隔 <code>duration</code> 转换为当前粒度</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>convert(long sourceDuration, TimeUnit sourceUnit)</code></td>
<td>将指定数值 <code>sourceDuration</code> 的指定粒度 <code>sourceUnit</code> 转换为当前粒度</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toNanos(long duration)</code></td>
<td>将指定数值 <code>duration</code> 的当前粒度转换为纳秒</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toMicros(long duration)</code></td>
<td>将指定数值 <code>duration</code> 的当前粒度转换为微秒</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toMillis(long duration)</code></td>
<td>将指定数值 <code>duration</code> 的当前粒度转换为毫秒</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toSeconds(long duration)</code></td>
<td>将指定数值 <code>duration</code> 的当前粒度转换为秒</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toMinutes(long duration)</code></td>
<td>将指定数值 <code>duration</code> 的当前粒度转换为分</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toHours(long duration)</code></td>
<td>将指定数值 <code>duration</code> 的当前粒度转换为时</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toDays(long duration)</code></td>
<td>将指定数值 <code>duration</code> 的当前粒度转换为日</td>
</tr>
</tbody></table>
<h4 id="2-ThreadFactory"><a href="#2-ThreadFactory" class="headerlink" title="2 ThreadFactory"></a>2 <code>ThreadFactory</code></h4><ol>
<li>默认使用 <code>Executors.defaultThreadFactory()</code></li>
<li>自定义线程工厂实现此接口</li>
<li>使用不同的工厂，可以更改线程名称，线程组，优先级，守护线程状态等等</li>
</ol>
<h4 id="3-RejectedExecutionHandler"><a href="#3-RejectedExecutionHandler" class="headerlink" title="3 RejectedExecutionHandler"></a>3 <code>RejectedExecutionHandler</code></h4><table>
<thead>
<tr>
<th>内置拒绝策略</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>AbortPolicy</code>（默认）</td>
<td>放弃本次任务，抛 <code>RejectedExecutionException</code> 异常</td>
</tr>
<tr>
<td><code>DiscardPolicy</code></td>
<td>放弃本次任务</td>
</tr>
<tr>
<td><code>DiscardOldestPolicy</code></td>
<td>放弃队列中最早的任务，本次任务取而代之</td>
</tr>
<tr>
<td><code>CallerRunsPolicy</code></td>
<td>让调用者处理任务</td>
</tr>
</tbody></table>
<ul>
<li>自定义拒绝策略实现此接口<ol>
<li><code>Dubbo</code> 的实现：抛 异常之前会记录日志，并 <code>dump</code> 线程栈信息，方便定位</li>
<li><code>Netty</code> 的实现：创建一个新线程来执行任务</li>
<li><code>ActiveMQ</code> 的实现：带超时等待（60s）尝试放入队列</li>
<li><code>PinPoint</code> 的实现：使用了一个拒绝策略链，会逐一尝试</li>
</ol>
</li>
</ul>
<h3 id="2-方法-2"><a href="#2-方法-2" class="headerlink" title="2 方法"></a>2 方法</h3><h4 id="1-提交任务"><a href="#1-提交任务" class="headerlink" title="1 提交任务"></a>1 提交任务</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>`void</td>
<td><code>execute(Runnable command)</code></td>
<td>执行任务 <code>Runnable</code> 任务</td>
</tr>
<tr>
<td><code>&lt;T&gt; Future&lt;T&gt;</code></td>
<td><code>submit(Callable&lt;T&gt; task)</code></td>
<td>提交 <code>Callable</code> 任务，使用 <code>Future</code> 获取任务执行结果</td>
</tr>
<tr>
<td><code>Future&lt;?&gt;</code></td>
<td><code>submit(Runnable task)</code></td>
<td>提交 <code>Runnbale</code> 任务，使用 <code>Future</code> 获取任务执行结果</td>
</tr>
<tr>
<td>`<T> Future<T></td>
<td><code>submit(Runnable task, T result)</code></td>
<td>提交带返回值的 <code>Runnbale</code> 任务，使用 <code>Future</code> 获取任务执行结果</td>
</tr>
<tr>
<td><code>&lt;T&gt; List&lt;Future&lt;T&gt;&gt;</code></td>
<td><code>invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</code></td>
<td>提交多个任务</td>
</tr>
<tr>
<td><code>&lt;T&gt; List&lt;Future&lt;T&gt;&gt;</code></td>
<td><code>invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)</code></td>
<td>提交多个任务，带超时时间</td>
</tr>
<tr>
<td><code>&lt;T&gt; T</code></td>
<td><code>invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</code></td>
<td>提交多个任务，哪个任务先成功执行完毕则返回其结果，其它任务取消</td>
</tr>
<tr>
<td><code>&lt;T&gt; T</code></td>
<td><code>invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)</code></td>
<td>提交多个任务，哪个任务先成功执行完毕则返回其结果，其它任务取消，带超时时间</td>
</tr>
</tbody></table>
<h4 id="2-关闭线程池"><a href="#2-关闭线程池" class="headerlink" title="2 关闭线程池"></a>2 关闭线程池</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>shutdown()</code></td>
<td>线程池状态变为 <code>Shutdown</code>，不再接收新任务，已提交任务会被执行完，此方法不会阻塞调用线程的执行</td>
</tr>
<tr>
<td><code>List&lt;Runnable&gt;</code></td>
<td><code>shutdownNow()</code></td>
<td>线程池状态变为 <code>Stop</code>，不再接收新任务，用 <code>interrupt()</code> 中断正在执行的任务，返回队列中等待执行的任务</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isShutdown()</code></td>
<td>测试线程池是否关闭，线程池状态不为 <code>Running</code>，都会返回 <code>true</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isTerminated()</code></td>
<td>测试是否所有任务都执行完毕了，线程池状态为 <code>Terminated</code>，返回 <code>true</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>awaitTermination(long timeout, TimeUnit unit)</code></td>
<td>由于调用 <code>shutdown</code> 后，调用线程并不会等待所有任务执行完毕，可以使用此方法等待线程池状态变为 <code>Terminated</code></td>
</tr>
</tbody></table>
<h2 id="12-6-Executors"><a href="#12-6-Executors" class="headerlink" title="12.6 Executors"></a>12.6 <code>Executors</code></h2><h3 id="1-固定大小线程池"><a href="#1-固定大小线程池" class="headerlink" title="1 固定大小线程池"></a>1 固定大小线程池</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">	return new ThreadPoolExecutor(nThreads, nThreads, </span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS, </span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>核心线程数 = 最大线程数，即不会有救急线程被创建，也就没有超时时间</li>
<li>阻塞队列 <code>LinkedBlockingQueue</code> 最大为 <code>Integer.MAX_VALUE</code></li>
<li>适合任务量已知，相对耗时的任务</li>
</ol>
<h3 id="2-带缓冲线程池"><a href="#2-带缓冲线程池" class="headerlink" title="2 带缓冲线程池"></a>2 带缓冲线程池</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">	return new ThreadPoolExecutor(0, Integer.MAX_VALUE, </span><br><span class="line">                                    60L, TimeUnit.SECONDS, </span><br><span class="line">                                    new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>核心线程数为 <code>0</code>，最大线程数为 <code>Integer.MAX_VALUE</code>，意味着全为救急线程，且超时时间为 <code>60s</code></li>
<li>阻塞队列 <code>SynchronousQueue</code> 没有容量，读写操作一一对应，意味着提交一个任务就必须马上执行</li>
<li>适合任务数比较密集，但每个任务耗时较短的情况</li>
</ol>
<h3 id="3-单线程线程池"><a href="#3-单线程线程池" class="headerlink" title="3 单线程线程池"></a>3 单线程线程池</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService(</span><br><span class="line">    		new ThreadPoolExecutor(1, 1, </span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS, </span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>核心线程数 = 最大线程数 = 1，即线程数固定为 1</li>
<li>适合多个任务排队执行</li>
<li>单线程线程池 &amp; 自己创建一个线程的区别<ol>
<li>自己创建一个线程，如果某个任务执行失败而终止，那么没有任何补救措施</li>
<li>单线程线程池会新创建一个线程，保证池中始终有一个工作线程，且线程池有任务阻塞队列</li>
</ol>
</li>
<li>单线程线程池 &amp; 数量为 1 的固定大小线程池的区别<ol>
<li>固定大小线程池对外暴漏的是 <code>ThreadPoolExecutor</code> 对象，所以可以使用其方法修改核心线程数</li>
<li>单线程线程池 <code>FinalizableDelegatedExecutorService</code> 使用的是装饰着模式，只对外暴漏了 <code>ExecutorService</code> 的方法，不能使用  <code>ThreadPoolExecutor</code> 的特有方法，无法修改</li>
</ol>
</li>
</ol>
<h3 id="4-任务调度线程池"><a href="#4-任务调度线程池" class="headerlink" title="4 任务调度线程池"></a>4 任务调度线程池</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">	return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">	super(corePoolSize, Integer.MAX_VALUE, </span><br><span class="line">		DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">		new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>没有任务调度线程池之前，<code>java.util.Timer</code> 可以用来实现定时功能，缺点：<ol>
<li>所有任务由一个线程调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行</li>
<li>如果某一个任务出现异常，会影响到之后的任务</li>
</ol>
</li>
<li>任务调度线程池可以由不同的线程来执行任务，且某个任务出现异常也不会影响其它任务</li>
</ol>
<h2 id="12-7-ScheduledThreadPoolExecutor"><a href="#12-7-ScheduledThreadPoolExecutor" class="headerlink" title="12.7 ScheduledThreadPoolExecutor"></a>12.7 <code>ScheduledThreadPoolExecutor</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ScheduledFuture&lt;?&gt;</code></td>
<td><code>schedule(Runnable command, long delay, TimeUnit unit)</code></td>
<td>指定延迟后，执行 <code>Runnable</code> 任务</td>
</tr>
<tr>
<td><code>&lt;V&gt; ScheduledFuture&lt;V&gt;</code></td>
<td><code>schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code></td>
<td>指定延迟后，执行 <code>Callable</code> 任务</td>
</tr>
<tr>
<td><code>ScheduledFuture&lt;?&gt;</code></td>
<td><code>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code></td>
<td>初始延迟时间后开始执行任务，到达 <code>period</code> 间隔时间后，判断上一个任务是否执行完毕，若执行完毕则执行下一个任务，否则等待其执行完毕</td>
</tr>
<tr>
<td><code>ScheduledFuture&lt;?&gt;</code></td>
<td><code>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code></td>
<td>初始延迟时间后开始执行任务，上一个任务执行完毕后延迟指定时间再开始执行下一个任务</td>
</tr>
</tbody></table>
<h2 id="12-8-Fork-Join"><a href="#12-8-Fork-Join" class="headerlink" title="12.8 Fork/Join"></a>12.8 <code>Fork/Join</code></h2><h3 id="1-概述-11"><a href="#1-概述-11" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>Fork/Join</code> 是 JDK 7 加入的新的线程池实现，体现的是一种分治思想，适用于能够进行任务拆分的 CPU 密集型运算</li>
<li>分支/合并框架的目的是以递归方式将可以并行的任务拆分成更小的任务，然后将每个子任务的结果合并起来生成整体结果</li>
<li><code>Fork/Join</code> 是 <code>ExecutorService</code> 接口的一个实现，它把子任务分配给线程池（称为 <code>ForkJoinPool</code> ）中的工作线程</li>
</ol>
<h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2 任务"></a>2 任务</h3><h4 id="1-概述-12"><a href="#1-概述-12" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li><p>提交给 <code>Fork/Join</code> 线程池的任务需要继承 <code>ForkJoinTask&lt;V&gt;</code></p>
<ol>
<li><code>RecursiveTask&lt;V&gt;</code>：有返回值，<code>V</code>是并行化任务（以及所有子任务）产生的结果类型</li>
<li><code>RecursiveAction</code>：无返回值</li>
</ol>
</li>
<li><p>定义的任务， 只需实现它唯一的抽象方法 <code>V compute()</code>，此方法同时定义了：</p>
<ol>
<li>将任务拆分成子任务的逻辑</li>
<li>无法再拆分或不方便再拆分时，生成单个子任务结果的逻辑</li>
</ol>
</li>
<li><p><code>compute()</code> 伪代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (任务足够小或不可分) &#123;</span><br><span class="line">	顺序计算该任务</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    将任务分成两个子任务</span><br><span class="line">    递归调用本方法，拆分每个子任务，等待所有子任务完成</span><br><span class="line">    合并每个子任务的结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2-ForkJoinTask-lt-V-gt"><a href="#2-ForkJoinTask-lt-V-gt" class="headerlink" title="2 ForkJoinTask&lt;V&gt;"></a>2 <code>ForkJoinTask&lt;V&gt;</code></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ForkJoinTask&lt;V&gt; fork()：使用 ForkJoinPool 中另一个线程异步执行子任务</span><br><span class="line">V join()：获取子任务结果，如果尚未完成就等待</span><br></pre></td></tr></table></figure>

<h3 id="3-工作窃取"><a href="#3-工作窃取" class="headerlink" title="3 工作窃取"></a>3 工作窃取</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96.png" alt=""></p>
<ol>
<li>理想情况下，划分并行任务时，应该让每个任务都用完全相同的时间完成，让所有的CPU内核都同样繁忙。不幸的是，实际中，每个子任务所花的时间可能天差地别</li>
<li>分支/合并框架工程用一种称为工作窃取（<code>work stealing</code>）的技术来解决这个问题</li>
<li>工作窃取算法用于在池中的工作线程之间重新分配和平衡任务<ol>
<li>每个线程都为分配给它的任务保存一个双向链式队列，每完成一个任务，就会从队列头上取出下一个任务开始执<br>行</li>
<li>某个线程可能早早完成了分配给它的所有任务，也就是它的队列已经空了，而其他的线程还很忙。这时，这个线程并没有闲下来，而是随机选了一个别的线程，从其队列的尾巴上“偷走”一个任务</li>
<li>这个过程一直继续下去，直到所有的任务都执行完毕，所有的队列都清空</li>
</ol>
</li>
</ol>
<h3 id="4-ForkJoinPool"><a href="#4-ForkJoinPool" class="headerlink" title="4 ForkJoinPool"></a>4 <code>ForkJoinPool</code></h3><h4 id="1-构造-4"><a href="#1-构造-4" class="headerlink" title="1 构造"></a>1 构造</h4><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ForkJoinPool()</code></td>
<td>默认会创建和 CPU 核心数相同大小的线程池</td>
</tr>
<tr>
<td><code>ForkJoinPool(int parallelism)</code></td>
<td>指定线程数</td>
</tr>
</tbody></table>
<h4 id="2-方法-3"><a href="#2-方法-3" class="headerlink" title="2 方法"></a>2 方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; T invoke(ForkJoinTask&lt;T&gt; task)</span><br><span class="line">void execute(ForkJoinTask&lt;?&gt; task)</span><br><span class="line">&lt;T&gt; ForkJoinTask&lt;T&gt; submit(ForkJoinTask&lt;T&gt; task)</span><br></pre></td></tr></table></figure>

<h1 id="十三-线程安全集合"><a href="#十三-线程安全集合" class="headerlink" title="十三 线程安全集合"></a>十三 线程安全集合</h1><h2 id="13-1-概述"><a href="#13-1-概述" class="headerlink" title="13.1 概述"></a>13.1 概述</h2><ol>
<li><p>遗留的线程安全集合如  <code>Hashtable</code> ， <code>Vector</code></p>
</li>
<li><p>使用 <code>Collections</code> 装饰的线程安全集合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Collections.synchronizedCollection</span><br><span class="line">Collections.synchronizedList</span><br><span class="line">Collections.synchronizedMap</span><br><span class="line">Collections.synchronizedSet</span><br><span class="line">Collections.synchronizedNavigableMap</span><br><span class="line">Collections.synchronizedNavigableSet</span><br><span class="line">Collections.synchronizedSortedMap</span><br><span class="line">Collections.synchronizedSortedSet</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>java.util.concurrent.*</code></p>
<ol>
<li><code>Blocking</code>：大部分实现基于锁，并提供用来阻塞的方法</li>
<li><code>CopyOnWrite</code>：写开销相对较重</li>
<li><code>Concurrent</code>：<ol>
<li>内部很多操作使用 <code>CAS</code> 优化，一般可以提供较高吞吐量</li>
<li>弱一致性<ul>
<li>遍历时弱一致性：当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍<br>历，但这时内容是旧的（非安全容器会抛异常）</li>
<li>求大小弱一致性：size 操作未必是 100% 准确</li>
<li>读取弱一致性</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="13-2-ConcurrentHashMap-lt-K-V-gt"><a href="#13-2-ConcurrentHashMap-lt-K-V-gt" class="headerlink" title="13.2 ConcurrentHashMap&lt;K,V&gt;"></a>13.2 <code>ConcurrentHashMap&lt;K,V&gt;</code></h2><h3 id="1-概述-13"><a href="#1-概述-13" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>JDK 7 中非线程安全的 Map 集合当元素下标相同时，会添加到链表的头部，而 JDK 8 则是添加到链表的尾部</li>
<li>JDK 7 中在多线程环境使用非线程安全的 Map 集合，当扩容时可能出现并发死链，JDK 8 虽然将扩容算法做了调整，但还是会出现其他问题，如扩容丢数据</li>
</ol>
<h3 id="2-重要属性和内部类"><a href="#2-重要属性和内部类" class="headerlink" title="2 重要属性和内部类"></a>2 重要属性和内部类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 默认为 0</span><br><span class="line">// 当初始化时, 为 -1</span><br><span class="line">// 当扩容时, 为 -(1 + 扩容线程数)</span><br><span class="line">// 当初始化或扩容完成后，为 下一次的扩容的阈值大小</span><br><span class="line">private transient volatile int sizeCtl;</span><br><span class="line"></span><br><span class="line">// 整个 ConcurrentHashMap 就是一个 Node[]</span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">// hash 表</span><br><span class="line">transient volatile Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">// 扩容时的 新 hash 表</span><br><span class="line">private transient volatile Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点</span><br><span class="line">static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node</span><br><span class="line">static final class ReservationNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 作为 treebin 的头节点, 存储 root 和 first</span><br><span class="line">static final class TreeBin&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 作为 treebin 的节点, 存储 parent, left, right</span><br><span class="line">static final class TreeNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-重要方法"><a href="#3-重要方法" class="headerlink" title="3 重要方法"></a>3 重要方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 获取 Node[] 中第 i 个 Node</span><br><span class="line">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i)</span><br><span class="line"></span><br><span class="line">// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值</span><br><span class="line">static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span><br><span class="line"></span><br><span class="line">// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值</span><br><span class="line">static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v)</span><br></pre></td></tr></table></figure>

<h2 id="13-3-CopyOnWriteArrayList"><a href="#13-3-CopyOnWriteArrayList" class="headerlink" title="13.3 CopyOnWriteArrayList"></a>13.3 <code>CopyOnWriteArrayList</code></h2><ol>
<li><code>ArrayList</code></li>
<li>每次写入时都会复制一个新的容器再写入</li>
<li>在迭代并添加时没有并发修改异常</li>
<li>每次写入都会复制，效率低，适合并发迭代</li>
</ol>
<h1 id="十四-java-lang-ThreadLocal-lt-T-gt"><a href="#十四-java-lang-ThreadLocal-lt-T-gt" class="headerlink" title="十四 java.lang.ThreadLocal&lt;T&gt;"></a>十四 <code>java.lang.ThreadLocal&lt;T&gt;</code></h1><h2 id="14-1-概述"><a href="#14-1-概述" class="headerlink" title="14.1 概述"></a>14.1 概述</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 ThreadLocal</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 Thread</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>ThreadLocal</code> 中有一个静态内部类 <code>ThreadLocalMap</code>，<code>ThreadLocalMap</code> 中有一个静态内部类 <code>Entry</code>，且维护了一个 <code>Entry</code> 类型的数组，其实数据最终存储在了 <code>Entry[]</code> 中</li>
<li><code>TheadLocalMap</code> 的键为 <code>ThreaLoal</code> 本身，值为自定义添加的值</li>
<li>一个 <code>ThreadLocalMap</code> 可以存储 <code>n</code> 个 <code>ThreadLocal</code>，所以存储时，会根据不同的  <code>ThreadLocal</code> 计算出不同的索引，此索引即存储到 <code>ThreadLocalMap</code> 中的 <code>Entry[]</code> 中的位置</li>
<li>每个线程对应一个 <code>ThreadLoaclMap</code> ，不同线程互不干扰</li>
<li>每个线程可以有多个不同的 <code>ThreadLocal</code>（如 <code>ThreadLocal&lt;A&gt;, ThreadLoacl&lt;B&gt;...</code>），所有 <code>ThreadLocal</code> 使用同一个 <code>ThreadLocalMap</code></li>
<li><code>Entry</code> 是一个弱引用<ol>
<li>如果是强引用，即使 <code>ThreadLocal tl = null</code> ，<code>Entry</code> 中的键依然指向 <code>ThreadLocal</code> ，会导致内存泄漏</li>
<li>弱引用还是有内存泄漏问题：当 <code>ThreadLocal</code> 为 <code>null</code> 被当成垃圾回收，但 <code>ThreadLocalMap</code> 生命周期和 <code>Thread</code> 一样，它不会回收，即 <code>Entry</code> 中的键为 <code>null</code> 了，而值还存在，但无法访问到了，所以使用完 <code>ThreadLocal</code> 后，执行 <code>remove()</code> 操作</li>
</ol>
</li>
</ol>
<h2 id="14-2-API"><a href="#14-2-API" class="headerlink" title="14.2 API"></a>14.2 API</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>set(T value)</code></td>
<td>此 <code>ThreadLocal</code> 作为键，<code>value</code> 作为值，存储到当前线程的 <code>ThreadLoaclMap</code> 中</td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>get()</code></td>
<td>从当前线程的 <code>ThreadLoaclMap</code> 中，获取键 <code>ThreadLocal</code> 对应的值</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>remove()</code></td>
<td>从当前线程的 <code>ThreadLoaclMap</code> 中，移除此 <code>ThreadLocal</code> 的键值对</td>
</tr>
</tbody></table>
<h3 id="1-set"><a href="#1-set" class="headerlink" title="1 set"></a>1 <code>set</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的 ThreadLocalMap，如果已存在则直接使用，否则创建一个</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-get"><a href="#2-get" class="headerlink" title="2 get"></a>2 <code>get</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CS</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java-集合</title>
    <url>/anyeansan.github.io/2020/09/29/Java/Java-%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="一-java-util-Collection-lt-E-gt"><a href="#一-java-util-Collection-lt-E-gt" class="headerlink" title="一 java.util.Collection&lt;E&gt;"></a>一 <code>java.util.Collection&lt;E&gt;</code></h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/Collection.png" alt=""></p>
<h2 id="1-1-API"><a href="#1-1-API" class="headerlink" title="1.1 API"></a>1.1 API</h2><h3 id="1-增"><a href="#1-增" class="headerlink" title="1 增"></a>1 增</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>add(E e)</code></td>
<td>添加一个元素</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>addAll(Collection&lt;? extends E&gt; c)</code></td>
<td>添加一个集合的元素</td>
</tr>
</tbody></table>
<h3 id="2-删"><a href="#2-删" class="headerlink" title="2 删"></a>2 删</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>remove(Object o)</code></td>
<td>删除一个元素</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>removeAll(Collection&lt;?&gt; c)</code></td>
<td>删除交集</td>
</tr>
<tr>
<td><code>default boolean</code></td>
<td><code>removeIf(Predicate&lt;? super E&gt; filter)</code></td>
<td>删除符合条件的元素</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
<td>清空集合</td>
</tr>
</tbody></table>
<h3 id="3-判断"><a href="#3-判断" class="headerlink" title="3 判断"></a>3 判断</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>contains(Object o)</code></td>
<td>判断是否包含指定元素</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>containsAll(Collection&lt;?&gt; c)</code></td>
<td>判断是否包含指定集合</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isEmpty()</code></td>
<td>判断是否为空</td>
</tr>
</tbody></table>
<h3 id="4-获取"><a href="#4-获取" class="headerlink" title="4 获取"></a>4 获取</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>size()</code></td>
<td>获取元素个数</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>retainAll(Collection&lt;?&gt; c)</code></td>
<td>取交集</td>
</tr>
</tbody></table>
<h3 id="5-转换"><a href="#5-转换" class="headerlink" title="5 转换"></a>5 转换</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object[]</code></td>
<td><code>toArray()</code></td>
<td>集合 → 数组</td>
</tr>
<tr>
<td><code>&lt;T&gt; T[]</code></td>
<td><code>toArray(T[] a)</code></td>
<td>集合 → 指定类型的数组（建议传入数组 <code>length = size</code>）</td>
</tr>
<tr>
<td><code>default &lt;T&gt; T[]</code></td>
<td><code>toArray(IntFunction&lt;T[]&gt; generator)</code></td>
<td>集合 → 指定类型的数组（由函数生成）</td>
</tr>
</tbody></table>
<h3 id="6-遍历"><a href="#6-遍历" class="headerlink" title="6 遍历"></a>6 遍历</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Iterator&lt;E&gt;</code></td>
<td><code>iterator()</code></td>
<td>获取迭代器</td>
</tr>
<tr>
<td><code>default Spliterator&lt;E&gt;</code></td>
<td><code>spliterator()</code></td>
<td>获取并行迭代器</td>
</tr>
</tbody></table>
<h3 id="7-流"><a href="#7-流" class="headerlink" title="7 流"></a>7 流</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>default Stream&lt;E&gt;</code></td>
<td><code>stream()</code></td>
<td>获取顺序流</td>
</tr>
<tr>
<td><code>default Stream&lt;E&gt;</code></td>
<td><code>parallelStream()</code></td>
<td>获取并行流</td>
</tr>
</tbody></table>
<h2 id="1-2-java-util-List-lt-E-gt"><a href="#1-2-java-util-List-lt-E-gt" class="headerlink" title="1.2 java.util.List&lt;E&gt;"></a>1.2 <code>java.util.List&lt;E&gt;</code></h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>元素有序（存取顺序一致）</li>
<li>元素有索引</li>
<li>元素可以重复</li>
</ol>
<h3 id="2-API"><a href="#2-API" class="headerlink" title="2 API"></a>2 API</h3><h4 id="1-增-1"><a href="#1-增-1" class="headerlink" title="1 增"></a>1 增</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>add(int index, E element)</code></td>
<td>在指定位置插入元素</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>addAll(int index, Collection&lt;? extends E&gt; c)</code></td>
<td>在指定位置插入一个集合的元素</td>
</tr>
</tbody></table>
<h4 id="2-删-1"><a href="#2-删-1" class="headerlink" title="2 删"></a>2 删</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>E</code></td>
<td><code>remove(int index)</code></td>
<td>删除指定位置的元素并返回</td>
</tr>
</tbody></table>
<h4 id="3-改"><a href="#3-改" class="headerlink" title="3 改"></a>3 改</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>E</code></td>
<td><code>set(int index, E element)</code></td>
<td>修改指定位置的元素</td>
</tr>
</tbody></table>
<h4 id="4-查"><a href="#4-查" class="headerlink" title="4 查"></a>4 查</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>indexOf(Object o)</code></td>
<td>从头开始查询元素第一次出现的索引</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>lastIndexOf(Object o)</code></td>
<td>从尾开始查询元素第一次出现的索引</td>
</tr>
</tbody></table>
<h4 id="5-获取"><a href="#5-获取" class="headerlink" title="5 获取"></a>5 获取</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>E</code></td>
<td><code>get(int index)</code></td>
<td>获取指定位置的元素</td>
</tr>
<tr>
<td><code>List&lt;E&gt;</code></td>
<td><code>subList(int fromIndex, int toIndex)</code></td>
<td>截取集合 <code>[from, to)</code></td>
</tr>
<tr>
<td><code>static &lt;E&gt; List&lt;E&gt;</code></td>
<td><code>of(E... elements)</code></td>
<td>获取包含指定元素的不可修改（只读）的 <code>List</code> 集合</td>
</tr>
<tr>
<td><code>static &lt;E&gt; List&lt;E&gt;</code></td>
<td><code>copyOf(Collection&lt;? extends E&gt; coll)</code></td>
<td>如果传入的集合是不可变的则直接返回，否则通过 <code>of</code> 创建一个包含其元素的不可修改的 <code>List</code> 集合（顺序为指定集合元素的迭代顺序）</td>
</tr>
</tbody></table>
<h4 id="6-遍历-1"><a href="#6-遍历-1" class="headerlink" title="6 遍历"></a>6 遍历</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ListIterator&lt;E&gt;</code></td>
<td><code>listIterator()</code></td>
<td>获取 <code>ListIterator</code> 迭代器</td>
</tr>
<tr>
<td><code>ListIterator&lt;E&gt;</code></td>
<td><code>listIterator(int index)</code></td>
<td>获取 <code>ListIterator</code> 迭代器，从指定索引开始</td>
</tr>
</tbody></table>
<h3 id="3-ArrayList"><a href="#3-ArrayList" class="headerlink" title="3 ArrayList"></a>3 <code>ArrayList</code></h3><h4 id="1-构造"><a href="#1-构造" class="headerlink" title="1 构造"></a>1 构造</h4><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ArrayList()</code></td>
<td>默认容量为 <code>10</code>，每次扩容为原容量的 1.5 倍（JDK8以后，创建时 <code>{}</code>，第一次添加时才创建容量 10 的数组）</td>
</tr>
<tr>
<td><code>ArrayList(int initialCapacity)</code></td>
<td>指定容量</td>
</tr>
<tr>
<td><code>ArrayList(Collection&lt;? extends E&gt; c)</code></td>
<td>包含指定集合元素</td>
</tr>
</tbody></table>
<h4 id="2-ArrayList-VS-Vector"><a href="#2-ArrayList-VS-Vector" class="headerlink" title="2 ArrayList VS Vector"></a>2 <code>ArrayList VS Vector</code></h4><ol>
<li><code>ArrayList</code> 非同步，<code>Vector</code> 同步</li>
<li><code>ArrayList</code> 扩容是原来的 1.5 倍，<code>Vector</code> 扩容是原来的 2 倍</li>
<li><code>Vector</code> 支持 <code>Enumeration</code> </li>
</ol>
<h3 id="4-Stack"><a href="#4-Stack" class="headerlink" title="4 Stack"></a>4 <code>Stack</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>empty()</code></td>
<td>判断是否为空</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>peek()</code></td>
<td>获取但不弹出栈顶元素</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>pop()</code></td>
<td>弹栈（获取并弹出栈顶元素）</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>push(E item)</code></td>
<td>压栈（将元素添加到栈顶）</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>serach(Object o)</code></td>
<td>返回指定元素的位置编号（栈顶为 1）</td>
</tr>
</tbody></table>
<h2 id="1-3-java-util-Set-lt-E-gt"><a href="#1-3-java-util-Set-lt-E-gt" class="headerlink" title="1.3 java.util.Set&lt;E&gt;"></a>1.3 <code>java.util.Set&lt;E&gt;</code></h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>元素唯一，不保证存取顺序<ul>
<li><code>HashSet</code>：元素存取无序</li>
<li><code>LinkedHashSet</code>：元素存取有序</li>
<li><code>TreeSet</code>：元素存取无序但会排序</li>
</ul>
</li>
<li><code>Set</code> 集合底层依赖于 <code>Map</code> 集合，添加到 <code>Set</code> 中的元素作为键，一个内部的共享对象作为值</li>
</ol>
<h3 id="2-API-1"><a href="#2-API-1" class="headerlink" title="2 API"></a>2 API</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static &lt;E&gt; Set&lt;E&gt;</code></td>
<td><code>of(E... elements)</code></td>
<td>获取包含指定元素的不可修改的 <code>Set</code> 集合</td>
</tr>
<tr>
<td><code>static &lt;E&gt; Set&lt;E&gt;</code></td>
<td><code>copyOf(Collection&lt;? extends E&gt; coll)</code></td>
<td>获取包含指定集合中所有元素的不可修改的 <code>Set</code> 集合</td>
</tr>
</tbody></table>
<h3 id="3-HashSet-amp-LinkedHashSet"><a href="#3-HashSet-amp-LinkedHashSet" class="headerlink" title="3 HashSet &amp; LinkedHashSet"></a>3 <code>HashSet</code> &amp; <code>LinkedHashSet</code></h3><ol>
<li>添加元素时，首先 <code>hashCode()</code> 获取元素的哈希值，然后根据某种算法，算出底层数组中的存放位置<ul>
<li>如果此位置上没有元素，则添加成功</li>
<li>如果此位置上有元素<ul>
<li>首先比较哈希值，如果哈希值不同，则添加成功</li>
<li>如果哈希值相同，则比较 <code>equals()</code></li>
</ul>
</li>
</ul>
</li>
<li>元素要存入 <code>HashSet</code> 需要重写 <code>hashCode()</code> 和 <code>equals()</code> 方法</li>
<li>一个位置多个元素以链表形式存储多个元素，七上八下：<ul>
<li>jdk7：新元素在上，指向旧元素</li>
<li>jdk8：新元素在下，旧元素指向新元素</li>
</ul>
</li>
</ol>
<h3 id="4-TreeSet"><a href="#4-TreeSet" class="headerlink" title="4 TreeSet"></a>4 <code>TreeSet</code></h3><ol>
<li>元素具有比较性，元素实现 <code>Comparable</code> 接口</li>
<li>集合具有比较性，集合传入一个实现了 <code>Comparator</code> 接口的比较器</li>
<li><code>TreeSet</code> 判断元素是否相同，就是看到比较结果</li>
</ol>
<h2 id="1-4-Queue-lt-E-gt"><a href="#1-4-Queue-lt-E-gt" class="headerlink" title="1.4 Queue&lt;E&gt;"></a>1.4 <code>Queue&lt;E&gt;</code></h2><h3 id="1-API"><a href="#1-API" class="headerlink" title="1 API"></a>1 API</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>add(E e)</code></td>
<td>向队列末尾添加元素，如果队列已满则抛异常 <code>IllegalStateException</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>offer(E e)</code></td>
<td>向队列末尾添加元素，如果队列已满则返回 <code>false</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>element()</code></td>
<td>获取但不移除队列第一个元素，如果队列为空则抛异常 <code>NoSuchElementEsxception</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>peek()</code></td>
<td>获取但不移除队列第一个元素，如果队列为空则返回 <code>null</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>remove()</code></td>
<td>获取并移除队列第一个元素，如果队列为空则则抛异常 <code>NoSuchElementEsxception</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>poll()</code></td>
<td>获取并移除队列第一个元素，如果队列为空则返回 <code>null</code></td>
</tr>
</tbody></table>
<h3 id="2-Deque-lt-E-gt"><a href="#2-Deque-lt-E-gt" class="headerlink" title="2 Deque&lt;E&gt;"></a>2 <code>Deque&lt;E&gt;</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>addFirst(E e)</code></td>
<td>向队列首部添加元素，如果队列已满则抛异常 <code>IllegalStateException</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>offerFirst(E e)</code></td>
<td>向队列首部添加元素，如果队列已满则返回 <code>false</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addLast(E e)</code></td>
<td>向队列尾部添加元素，如果队列已满则抛异常 <code>IllegalStateException</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>offerLast(E e)</code></td>
<td>向队列尾部添加元素，如果队列已满则返回 <code>false</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>getFirst()</code></td>
<td>获取但不移除队列第一个元素，如果队列为空则抛异常 <code>NoSuchElementEsxception</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>peekFirst()</code></td>
<td>获取但不移除队列第一个元素，如果队列为空则返回 <code>null</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>getLast()</code></td>
<td>获取但不移除队列最后一个元素，如果队列为空则抛异常 <code>NoSuchElementEsxception</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>peekLast()</code></td>
<td>获取但不移除队列最后一个元素，如果队列为空则返回 <code>null</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>removeFirst()</code></td>
<td>获取并移除队列第一个元素，如果队列为空则则抛异常 <code>NoSuchElementEsxception</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>pollFirst()</code></td>
<td>获取并移除队列第一个元素，如果队列为空则返回 <code>null</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>removeLast()</code></td>
<td>获取并移除队列最后一个元素，如果队列为空则则抛异常 <code>NoSuchElementEsxception</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>pollLast()</code></td>
<td>获取并移除队列最后一个元素，如果队列为空则返回 <code>null</code></td>
</tr>
</tbody></table>
<h3 id="3-BlockingQueue-lt-E-gt"><a href="#3-BlockingQueue-lt-E-gt" class="headerlink" title="3 BlockingQueue&lt;E&gt;"></a>3 <code>BlockingQueue&lt;E&gt;</code></h3><h4 id="1-API-1"><a href="#1-API-1" class="headerlink" title="1 API"></a>1 API</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>add(E e)</code></td>
<td>向队列末尾添加元素，如果队列已满则抛异常 <code>IllegalStateException</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>offer(E e)</code></td>
<td>向队列末尾添加元素，如果队列已满则返回 <code>false</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>offer(E e, long timeout, TimeUnit unit)</code></td>
<td>向队列末尾添加元素，如果队列已满会尝试指定时间，超时则返回 <code>false</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>put(E e)</code></td>
<td>向队列末尾添加元素，如果队列已满则阻塞等待</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>remove()</code></td>
<td>获取并移除队列第一个元素，如果队列为空则则抛异常 <code>NoSuchElementEsxception</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>poll()</code></td>
<td>获取并移除队列第一个元素，如果队列为空则返回 <code>null</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>poll(long timeout, TimeUnit unit)</code></td>
<td>获取并移除队列第一个元素，如果队列为空会尝试指定时间，超时则返回 <code>null</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>take()</code></td>
<td>获取并移除队列第一个元素，如果队列为空则阻塞等待</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>element()</code></td>
<td>获取但不移除队列第一个元素，如果队列为空则抛异常 <code>NoSuchElementEsxception</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>peek()</code></td>
<td>获取但不移除队列第一个元素，如果队列为空则返回 <code>null</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th><code>Throws exception</code></th>
<th><code>Special value</code></th>
<th><code>Times out</code></th>
<th><code>Blocks</code></th>
</tr>
</thead>
<tbody><tr>
<td>增加</td>
<td><code>add(e)</code></td>
<td><code>offer(e)</code></td>
<td><code>offer(e, time, unit)</code></td>
<td><code>put(e)</code></td>
</tr>
<tr>
<td>删除</td>
<td><code>remove()</code></td>
<td><code>poll()</code></td>
<td><code>poll(time, unit)</code></td>
<td><code>take()</code></td>
</tr>
<tr>
<td>检测队首元素</td>
<td><code>element()</code></td>
<td><code>peek()</code></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="2-实现类"><a href="#2-实现类" class="headerlink" title="2 实现类"></a>2 实现类</h4><table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ArrayBlockingQueue</code></td>
<td>数组结构的有界阻塞队列</td>
</tr>
<tr>
<td><code>LinkedBlockingQueue</code></td>
<td>链表结构的有界阻塞队列（默认 <code>Integer.MAX_VALUE</code>，也可以看作是无界的）</td>
</tr>
<tr>
<td><code>SynchronousQueue</code></td>
<td>容量为 0，是一个不存储元素的阻塞队列，读写操作配对出现，只有一个时会阻塞等待</td>
</tr>
<tr>
<td><code>DelayQueue</code></td>
<td>优先级堆支持的，基于时间的调度队列（元素按阻塞程度排序，会先获取阻塞低的元素）</td>
</tr>
<tr>
<td><code>PriorityBlockingQueue</code></td>
<td>优先级堆支持的无界优先级队列（内部使用二叉树排好了序）</td>
</tr>
</tbody></table>
<h1 id="二-java-util-Map-lt-K-V-gt"><a href="#二-java-util-Map-lt-K-V-gt" class="headerlink" title="二 java.util.Map&lt;K,V&gt;"></a>二 <code>java.util.Map&lt;K,V&gt;</code></h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/Map.png" alt=""></p>
<table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>HashMap</code></td>
<td>键唯一，存取无序，<code>null</code> 可以作为键和值，线程不安全（非同步）</td>
</tr>
<tr>
<td><code>HashTable</code></td>
<td>键唯一，存取无序，<code>null</code> 不能作为键和值，线程安全（同步）</td>
</tr>
<tr>
<td><code>LinkedHashMap</code></td>
<td>键唯一，存取有序</td>
</tr>
<tr>
<td><code>Properties</code></td>
<td>键唯一，存取无序，键值必须是字符串</td>
</tr>
<tr>
<td><code>TreeMap</code></td>
<td>键唯一，存取无序，元素根据键排序</td>
</tr>
</tbody></table>
<h2 id="2-2-键唯一性"><a href="#2-2-键唯一性" class="headerlink" title="2.2 键唯一性"></a>2.2 键唯一性</h2><h3 id="1-HashMap-HashTable-LinkedHashMap-Properties"><a href="#1-HashMap-HashTable-LinkedHashMap-Properties" class="headerlink" title="1 HashMap HashTable LinkedHashMap Properties"></a>1 <code>HashMap HashTable LinkedHashMap Properties</code></h3><ol>
<li><code>hashCode()</code></li>
<li><code>equals()</code></li>
</ol>
<h3 id="2-TreeMap"><a href="#2-TreeMap" class="headerlink" title="2 TreeMap"></a>2 <code>TreeMap</code></h3><ol>
<li>键具有比较性</li>
<li>集合传入比较器</li>
</ol>
<h2 id="2-3-API"><a href="#2-3-API" class="headerlink" title="2.3 API"></a>2.3 API</h2><h3 id="1-增-2"><a href="#1-增-2" class="headerlink" title="1 增"></a>1 增</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>V</code></td>
<td><code>put​(K key, V value)</code></td>
<td>添加键值对，若 key 已存在返回 value，否则返回 null</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>putAll(Map m)</code></td>
<td>添加一个集合的键值对</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>putIfAbsent(K key, V value)</code></td>
<td>如果指定的 <code>key</code> 没有值或值为 <code>null</code>，则将其值设置为指定 <code>value</code>，否则返回已有的值</td>
</tr>
</tbody></table>
<h3 id="2-删-2"><a href="#2-删-2" class="headerlink" title="2 删"></a>2 删</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>V</code></td>
<td><code>remove(Object key)</code></td>
<td>根据指定 <code>key</code> 删除并返回 <code>value</code>，若不存在则返回 <code>null</code></td>
</tr>
<tr>
<td><code>default boolean</code></td>
<td><code>remove(Object key, Object value)</code></td>
<td>删除指定键值对</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
<td>清空集合</td>
</tr>
</tbody></table>
<h3 id="3-获取"><a href="#3-获取" class="headerlink" title="3 获取"></a>3 获取</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>V</code></td>
<td><code>get(Object key)</code></td>
<td>根据指定 <code>key</code> 获取 <code>value</code>，若不存在则返回 <code>null</code></td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>getOrDefault(Object key, V defaultValue)</code></td>
<td>根据指定 <code>key</code> 获取 <code>value</code>，若不存在则返回 <code>defaultValue</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size()</code></td>
<td>获取键值对个数</td>
</tr>
<tr>
<td><code>static &lt;K, V&gt; Map&lt;K, V&gt;</code></td>
<td><code>copyOf(Map&lt;? extends K, ? extends V&gt; map)</code></td>
<td>获取包含指定集合键值对的不可修改的 <code>Map</code> 集合</td>
</tr>
</tbody></table>
<h3 id="4-判断"><a href="#4-判断" class="headerlink" title="4 判断"></a>4 判断</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>isEmpty()</code></td>
<td>是否为空</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>containsKey(Object key)</code></td>
<td>是否包含指定 <code>key</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>containsValue(Object value)</code></td>
<td>是否包含指定 <code>value</code></td>
</tr>
</tbody></table>
<h3 id="5-遍历"><a href="#5-遍历" class="headerlink" title="5 遍历"></a>5 遍历</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Set&lt;K&gt;</code></td>
<td><code>keySet()</code></td>
<td>获取所有 <code>key</code> 的 <code>Set</code> 集合</td>
</tr>
<tr>
<td><code>Collection&lt;V&gt;</code></td>
<td><code>values()</code></td>
<td>获取所有 <code>value</code> 的集合</td>
</tr>
<tr>
<td><code>Set&lt;Map.Entry&lt;K, V&gt;&gt;</code></td>
<td><code>entrySet()</code></td>
<td>获取所有键值对映射关系的 <code>Set</code> 集合</td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code>forEach(BiConsumer&lt;? super K, ? super V&gt; action)</code></td>
<td>遍历键值对并消费</td>
</tr>
</tbody></table>
<h2 id="2-4-HashMap"><a href="#2-4-HashMap" class="headerlink" title="2.4 HashMap"></a>2.4 <code>HashMap</code></h2><h3 id="1-JDK7：数组-链表"><a href="#1-JDK7：数组-链表" class="headerlink" title="1 JDK7：数组 + 链表"></a>1 JDK7：数组 + 链表</h3><h4 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1 相关概念"></a>1 相关概念</h4><ol>
<li><code>DEFAULT_INITIAL_CAPACITY = 16</code> <ul>
<li>默认初始容量</li>
</ul>
</li>
<li><code>DEFAULT_LOAD_FACTOR = 0.75f</code><ul>
<li>默认加载因子</li>
</ul>
</li>
<li><code>threshold = capacity * loadFactor</code><ul>
<li>阈值/临界值，到达此值数组需要扩容</li>
</ul>
</li>
</ol>
<h4 id="2-过程"><a href="#2-过程" class="headerlink" title="2 过程"></a>2 过程</h4><ol>
<li>构造时，初始化一个长度为 16 的 <code>Entry[]</code> 数组，并算出 <code>threshold</code> 阈值</li>
<li>每次 <code>put()</code>  添加时，先获取 <code>key</code> 的哈希值，然后根据某种算法计算出在 <code>Entry[]</code> 数组中的存放位置<ul>
<li>如果此位置没有数据，则将键值对构建为 <code>Entry</code> 对象添加成功</li>
<li>如果此位置有数据，则比较新加 <code>key</code> 与已存在 <code>key</code> 的哈希值<ul>
<li>如果不同，则添加成功</li>
<li>如果相同，则继续比较 <code>key</code> 的 <code>equals()</code><ul>
<li>如果不同，则添加成功</li>
<li>如果相同，则覆盖 <code>value</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>key</code> 不重复时，当大于等于阈值且要存储的位置没有数据时需要扩容（默认变为原容量 2 倍），且集合元素重新计算位置</li>
<li>同一位置的多个数据以链表形式存在，新元素在上边，旧元素会作为新元素的 <code>next</code></li>
</ol>
<h3 id="2-JDK8：数组-链表-红黑树"><a href="#2-JDK8：数组-链表-红黑树" class="headerlink" title="2 JDK8：数组 + 链表/红黑树"></a>2 JDK8：数组 + 链表/红黑树</h3><h4 id="1-相关概念-1"><a href="#1-相关概念-1" class="headerlink" title="1 相关概念"></a>1 相关概念</h4><ol>
<li><code>DEFAULT_INITIAL_CAPACITY = 16</code> <ul>
<li>默认初始容量</li>
</ul>
</li>
<li><code>DEFAULT_LOAD_FACTOR = 0.75f</code><ul>
<li>默认加载因子</li>
</ul>
</li>
<li><code>MAXIMUM_CAPACITY = 1 &lt;&lt; 30</code><ul>
<li>最大容量</li>
</ul>
</li>
<li><code>TREEIFY_THRESHOLD = 8</code><ul>
<li>树化阈值，当链表长度达到此长度时，要考虑树化</li>
</ul>
</li>
<li><code>UNTREEIFY_THRESHOLD = 6</code><ul>
<li>反树化阈值，当树中的节点个数到达此值时，要考虑变为链表</li>
</ul>
</li>
<li><code>MIN_TREEIFY_CAPACITY = 64</code><ul>
<li>最小树化容量，当达到树化阈值且容量不小于次之时，才会树化</li>
</ul>
</li>
<li><code>threshold = capacity * loadFactor</code><ul>
<li>阈值/临界值，当已用容量到达此值数值时，要考虑扩容</li>
</ul>
</li>
</ol>
<h4 id="2-过程-1"><a href="#2-过程-1" class="headerlink" title="2 过程"></a>2 过程</h4><ol>
<li>构造时，没有初始化数组</li>
<li>第一次 <code>put()</code> 添加时，将数组初始化为长度为 16 的 <code>Node[]</code> 数组，并算出 <code>threshold</code> 阈值</li>
<li>添加时过程相同，区别在于链表存储时七上八下，jdk8新的元素在下边，旧元素的 <code>next</code> 指向新元素</li>
<li>添加时还需要判断该索引下是否已经是树结构<ol>
<li>如果不是，则判断是否需要树化，当达到树化阈值及树化容量时，会将链表变为红黑树</li>
<li>如果是，则添加</li>
</ol>
</li>
<li>添加时还需要判断扩容问题</li>
</ol>
<h2 id="2-5-Properties"><a href="#2-5-Properties" class="headerlink" title="2.5 Properties"></a>2.5 <code>Properties</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>getProperty(String key)</code></td>
<td>根据 <code>key</code> 获取 <code>value</code>，若不存在则返回 <code>null</code></td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getProperty(String key, String defaultValue)</code></td>
<td>根据 <code>key</code> 获取 <code>value</code>，若不存在则返回 <code>defaultValue</code></td>
</tr>
<tr>
<td><code>Object</code></td>
<td><code>setProperty(String key, String value)</code></td>
<td>添加键值对，调用的 <code>HashTable</code> 的 <code>put</code> 方法</td>
</tr>
<tr>
<td><code>Set&lt;String&gt;</code></td>
<td><code>stringPropertyNames()</code></td>
<td>获取所有 <code>key</code> 的 <code>Set</code> 集合</td>
</tr>
<tr>
<td><code>Enumeration&lt;?&gt;</code></td>
<td><code>propertyNames()</code></td>
<td>获取所有 <code>key</code> 的枚举</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>load(InputStream inStream)</code></td>
<td>从字节输入流中读取键值对数据</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>load(Reader reader)</code></td>
<td>从字符输入流中读取键值对数据</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>store(OutputStream out, String comments)</code></td>
<td>将键值对数据写入字节输出流，<code>comment</code> 为描述信息</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>store(Writer writer, String comments)</code></td>
<td>将键值对数据写入字符输出流</td>
</tr>
</tbody></table>
<h1 id="三-集合遍历"><a href="#三-集合遍历" class="headerlink" title="三 集合遍历"></a>三 集合遍历</h1><h2 id="3-1-java-lang-Iterable-lt-T-gt"><a href="#3-1-java-lang-Iterable-lt-T-gt" class="headerlink" title="3.1 java.lang.Iterable&lt;T&gt;"></a>3.1 <code>java.lang.Iterable&lt;T&gt;</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Iterator&lt;T&gt;</code></td>
<td><code>iterator()</code></td>
<td>获取迭代器</td>
</tr>
<tr>
<td><code>default Spliterator&lt;T&gt;</code></td>
<td><code>spliterator()</code></td>
<td>获取并行迭代器</td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code>forEach(Consumer&lt;? super T&gt; action)</code></td>
<td>增强 for 循环</td>
</tr>
</tbody></table>
<h2 id="3-2-java-util-Iterator-lt-E-gt"><a href="#3-2-java-util-Iterator-lt-E-gt" class="headerlink" title="3.2 java.util.Iterator&lt;E&gt;"></a>3.2 <code>java.util.Iterator&lt;E&gt;</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>hasNext()</code></td>
<td>判断是否有下一个元素</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>next()</code></td>
<td>获取下一个元素</td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code>remove()</code></td>
<td>删除 <code>next()</code> 获取的元素，即删除之前要先获取</td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code>forEachRemaining​(Consumer&lt;? super E&gt; action)</code></td>
<td>遍历并消费元素</td>
</tr>
</tbody></table>
<h2 id="3-3-java-util-ListIterator-lt-E-gt"><a href="#3-3-java-util-ListIterator-lt-E-gt" class="headerlink" title="3.3 java.util.ListIterator&lt;E&gt;"></a>3.3 <code>java.util.ListIterator&lt;E&gt;</code></h2><h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h3><ol>
<li><code>ListIterator</code> 是 <code>Iterator</code> 的子接口</li>
<li>在迭代时可以添加修改元素，且可以往回迭代</li>
</ol>
<h3 id="2-API-2"><a href="#2-API-2" class="headerlink" title="2 API"></a>2 API</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>hasNext()</code></td>
<td>判断是否有下一个元素</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>next()</code></td>
<td>获取下一个元素</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>nextIndex()</code></td>
<td>获取下一个元素的索引</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>hasPrevious()</code></td>
<td>判断是否有上一个元素</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>previous()</code></td>
<td>获取上一个元素</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>previousIndex()</code></td>
<td>获取上一个元素的索引</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>add(E e)</code></td>
<td>添加元素</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>remove()</code></td>
<td>删除 <code>next()</code> 或 <code>previous()</code> 获取的元素</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>set(E e)</code></td>
<td>修改 <code>next()</code> 或 <code>previous()</code> 获取的元素</td>
</tr>
</tbody></table>
<h2 id="3-4-集合遍历的方式"><a href="#3-4-集合遍历的方式" class="headerlink" title="3.4 集合遍历的方式"></a>3.4 集合遍历的方式</h2><h3 id="1-集合转为数组，使用普通-for-循环"><a href="#1-集合转为数组，使用普通-for-循环" class="headerlink" title="1 集合转为数组，使用普通 for 循环"></a>1 集合转为数组，使用普通 for 循环</h3><ul>
<li>遍历时可以增删，索引要相应变化</li>
</ul>
<h3 id="2-迭代器"><a href="#2-迭代器" class="headerlink" title="2 迭代器"></a>2 迭代器</h3><ol>
<li>遍历时如果增会发生并发修改异常 <code>ConcurrentModifyException</code></li>
<li>遍历时可以使用迭代器的删除方法进行删除</li>
</ol>
<h3 id="3-增强-for-循环"><a href="#3-增强-for-循环" class="headerlink" title="3 增强 for 循环"></a>3 增强 for 循环</h3><ol>
<li><code>Iterable</code> 接口的子类或子接口都可以使用 <code>foreach</code>，如数组，集合</li>
<li>遍历时不能增删，因为增强 for 循环底层还是迭代器，增删会发生并发修改异常</li>
</ol>
<h2 id="3-5-modCount"><a href="#3-5-modCount" class="headerlink" title="3.5 modCount"></a>3.5 <code>modCount</code></h2><ol>
<li>在 <code>ArrayList，LinkedList，HashMap...</code> 等集合中有此属性，用来记录集合被修改的次数（添加 删除）</li>
<li>使用迭代器或 <code>foreach</code> 遍历集合时，会记录遍历开始时的 <code>modCount</code><ol>
<li>遍历时使用迭代器自身的增删方法修改集合，不会改变 <code>modCount</code></li>
<li>遍历时使用集合的增删方法，会修改 <code>modCount</code>，前后 <code>modCount</code> 不一致，说明有两个线程在同时操作集合，这种操作有风险，为了保证安全性就会报异常</li>
</ol>
</li>
</ol>
<h1 id="四-泛型（Generics）"><a href="#四-泛型（Generics）" class="headerlink" title="四 泛型（Generics）"></a>四 泛型（Generics）</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ol>
<li>如果没有泛型，就意味着你并不知道集合中存储的是什么类型的数据，那就只能认为都是 Object，所以在使用时，你想要把数据当作某种具体的类型来使用<ol>
<li>需要强制类型转换</li>
<li>有可能 <code>ClassCastException</code> 异常</li>
</ol>
</li>
<li>泛型就是一种可以在使用时明确数据类型的功能（类似形参实参）<ol>
<li>定义时声明了泛型</li>
<li>使用时就可以使用泛型这种功能来明确数据类型</li>
</ol>
</li>
<li>泛型的好处<ol>
<li>明确了数据类型，使用时就不用再做类型转换</li>
<li>限定了数据类型，就意味着如果不合法，编译通不过，把运行期的错误提前到了编译期</li>
</ol>
</li>
<li>泛型：参数化类型 Parameterized type<ul>
<li><code>&lt;引用数据类型&gt;</code></li>
</ul>
</li>
</ol>
<h2 id="4-2-泛型定义"><a href="#4-2-泛型定义" class="headerlink" title="4.2 泛型定义"></a>4.2 泛型定义</h2><h3 id="1-定义语法"><a href="#1-定义语法" class="headerlink" title="1 定义语法"></a>1 定义语法</h3><table>
<thead>
<tr>
<th>目标</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td><code>泛型类</code></td>
<td><code>修饰符 class 类名&lt;泛型形参列表&gt;{}</code></td>
</tr>
<tr>
<td><code>泛型接口</code></td>
<td><code>修饰符 interface 接口名&lt;泛型形参列表&gt;{}</code></td>
</tr>
<tr>
<td><code>泛型方法</code></td>
<td><code>修饰符 &lt;泛型形参列表&gt; 返回值类型 方法名(形参列表) {}</code></td>
</tr>
</tbody></table>
<ol>
<li>泛型形参可以为任意标识符，如 <code>E T K V ...</code></li>
<li>泛型定义时可以限定使用时的类型上下限<ol>
<li><code>T extends 上限</code></li>
<li><code>T super 下限</code></li>
</ol>
</li>
<li>类/接口上定义的泛型，内部非静态成员可以直接使用<ol>
<li>创建对象时指定具体类型</li>
<li>子类上指定具体类型</li>
<li>静态成员不能使用泛型，因为静态比泛型确定具体类型的时机要早</li>
</ol>
</li>
<li>方法上定义的泛型，可以在方法形参和内部使用<ol>
<li>调用方法时指定具体类型</li>
<li>泛型方法可以是静态的，因为是调用时确定的类型</li>
<li>方法上的泛型与类或接口没有关系</li>
</ol>
</li>
</ol>
<h3 id="2-泛型类-接口的子类"><a href="#2-泛型类-接口的子类" class="headerlink" title="2 泛型类/接口的子类"></a>2 泛型类/接口的子类</h3><h4 id="1-明确数据类型"><a href="#1-明确数据类型" class="headerlink" title="1 明确数据类型"></a>1 明确数据类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 class 子类名 extends 父类&lt;具体类型&gt; &#123;&#125;</span><br><span class="line">修饰符 class 子类名 implements 接口&lt;具体类型&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-不明确数据类型"><a href="#2-不明确数据类型" class="headerlink" title="2 不明确数据类型"></a>2 不明确数据类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 class 子类名&lt;泛型形参列表&gt; extends 父类&lt;泛型形参列表&gt; &#123;&#125;</span><br><span class="line">修饰符 class 子类名&lt;泛型形参列表&gt; implements 接口&lt;泛型形参列表&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-泛型通配符"><a href="#4-3-泛型通配符" class="headerlink" title="4.3 泛型通配符"></a>4.3 泛型通配符</h2><table>
<thead>
<tr>
<th>通配符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;?&gt;</code></td>
<td>写入时只能添加 <code>null</code>，读取时读取的类型为 <code>Object</code></td>
</tr>
<tr>
<td><code>? extends E</code></td>
<td>设定上限，必须是 E 及其子类</td>
</tr>
<tr>
<td><code>? super E</code></td>
<td>设定下限，必须是 E 及其父类</td>
</tr>
</tbody></table>
<ul>
<li><p><code>A</code> 和 <code>B</code> 是子父类关系，<code>G&lt;A&gt;</code> 和 <code>G&lt;B&gt;</code> 没有关系，它们共同父类是 <code>G&lt;?&gt;</code></p>
</li>
<li><p>为什么使用 <code>?</code> 而不能用 <code>Object</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;&#125; <span class="comment">// 正确</span></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	因为使用时，ArrayList&lt;String&gt; 就意味着将通配符指定为 String</span></span><br><span class="line"><span class="comment">	则 ArrayList&lt;String&gt; = new ArrayList&lt;String&gt;(); 没问题</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Collection&lt;Object&gt; c)</span> </span>&#123;&#125; <span class="comment">// 错误</span></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	因为使用时， ArrayList&lt;String&gt; = new ArrayList&lt;Number&gt;(); </span></span><br><span class="line"><span class="comment">	由于接收的是 Object 所以理论上是没有问题的，但泛型前后必须一致，所以错误</span></span><br><span class="line"><span class="comment">	*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="五-java-util-Collections"><a href="#五-java-util-Collections" class="headerlink" title="五 java.util.Collections"></a>五 <code>java.util.Collections</code></h1><h2 id="1-1-增删改查"><a href="#1-1-增删改查" class="headerlink" title="1.1 增删改查"></a>1.1 增删改查</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static &lt;T&gt; boolean</code></td>
<td><code>addAll(Collection&lt;? super T&gt; c, T... elements)</code></td>
<td>添加多个元素到指定集合</td>
</tr>
<tr>
<td><code>static &lt;T&gt; void</code></td>
<td><code>copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</code></td>
<td>将 <code>List</code> 集合 <code>src</code> 中的元素拷贝到 <code>dest</code> 中</td>
</tr>
<tr>
<td><code>static &lt;T&gt; boolean</code></td>
<td><code>replaceAll(List&lt;T&gt; list, T oldVal, T newVal)</code></td>
<td>将 <code>List</code> 中所有的 <code>oldVal</code> 替换为 <code>newVal</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; int</code></td>
<td><code>binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)</code></td>
<td><code>List</code> 集合二分查找，要求 <code>List</code> 中的元素有比较性</td>
</tr>
<tr>
<td><code>static &lt;T&gt; int</code></td>
<td><code>binarySearch(List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c)</code></td>
<td><code>List</code> 集合二分查找，使用指定比较器</td>
</tr>
<tr>
<td><code>static int</code></td>
<td><code>frequency(Collection&lt;?&gt; c, Object o)</code></td>
<td>获取指定元素在集合中出现的次数</td>
</tr>
</tbody></table>
<h2 id="1-2-排序"><a href="#1-2-排序" class="headerlink" title="1.2 排序"></a>1.2 排序</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static &lt;T extends Comparable&lt;? super T&gt;&gt; void</code></td>
<td><code>sort(List&lt;T&gt; list)</code></td>
<td>按照元素自然顺序对 <code>List</code> 集合排序</td>
</tr>
<tr>
<td><code>static &lt;T&gt; void</code></td>
<td><code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code></td>
<td>使用指定比较器对 <code>List</code> 集合排序</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>reverse(List&lt;?&gt; list)</code></td>
<td>反转 <code>LIst</code> 集合</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>shuffle(List&lt;?&gt; list)</code></td>
<td>随机洗牌</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>swap(List&lt;?&gt; list, int i, int j)</code></td>
<td>交换 <code>LIst</code> 集合指定索引的元素</td>
</tr>
</tbody></table>
<h2 id="1-3-获取集合"><a href="#1-3-获取集合" class="headerlink" title="1.3 获取集合"></a>1.3 获取集合</h2><h3 id="1-immutable"><a href="#1-immutable" class="headerlink" title="1 immutable"></a>1 <code>immutable</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static &lt;T&gt; List&lt;T&gt;</code></td>
<td><code>singletonList(T o)</code></td>
<td>返回不可变的只包含一个元素的 <code>List</code> 集合</td>
</tr>
<tr>
<td><code>static &lt;T&gt; Set&lt;T&gt;</code></td>
<td><code>singleton(T o)</code></td>
<td>返回不可变的只包含一个元素的 <code>Set</code> 集合</td>
</tr>
<tr>
<td><code>static &lt;K, V&gt; Map&lt;K, V&gt;</code></td>
<td><code>singletonMap(K key, V value)</code></td>
<td>返回不可变的只包含一对键值的 <code>Map</code> 集合</td>
</tr>
</tbody></table>
<h3 id="2-synchronized"><a href="#2-synchronized" class="headerlink" title="2 synchronized"></a>2 <code>synchronized</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>static &lt;T&gt; Collection&lt;T&gt;</code></td>
<td><code>synchronizedCollection(Collection&lt;T&gt; c)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; List&lt;T&gt;</code></td>
<td><code>synchronizedList(List&lt;T&gt; list)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; Set&lt;T&gt;</code></td>
<td><code>synchronizedSet(Set&lt;T&gt; s)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; NavigableSet&lt;T&gt;</code></td>
<td><code>synchronizedNavigableSet(NavigableSet&lt;T&gt; s)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; SortedSet&lt;T&gt;</code></td>
<td><code>synchronizedSortedSet(SortedSet&lt;T&gt; s)</code></td>
</tr>
<tr>
<td><code>static &lt;K, V&gt; Map&lt;K, V&gt;</code></td>
<td><code>synchronizedMap(Map&lt;K, V&gt; m)</code></td>
</tr>
<tr>
<td><code>static &lt;K, V&gt; NavigableMap&lt;K, V&gt;</code></td>
<td><code>synchronizedNavigableMap(NavigableMap&lt;K, V&gt; m)</code></td>
</tr>
<tr>
<td><code>static &lt;K, V&gt; SortedMap&lt;K, V&gt;</code></td>
<td><code>synchronizedSortedMap(SortedMap&lt;K, V&gt; m)</code></td>
</tr>
</tbody></table>
<h3 id="3-Unmodifiable（只读）"><a href="#3-Unmodifiable（只读）" class="headerlink" title="3 Unmodifiable（只读）"></a>3 <code>Unmodifiable</code>（只读）</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>static &lt;T&gt; Collection&lt;T&gt;</code></td>
<td><code>unmodifiableCollection(Collection&lt;? extends T&gt; c)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; List&lt;T&gt;</code></td>
<td><code>unmodifiableList(List&lt;? extends T&gt; list)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; Set&lt;T&gt;</code></td>
<td><code>unmodifiableSet(Set&lt;? extends T&gt; s)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; NavigableSet&lt;T&gt;</code></td>
<td><code>unmodifiableNavigableSet(NavigableSet&lt;T&gt; s)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; SortedSet&lt;T&gt;</code></td>
<td><code>unmodifiableSortedSet(SortedSet&lt;T&gt; s)</code></td>
</tr>
<tr>
<td><code>static &lt;K, V&gt; Map&lt;K, V&gt;</code></td>
<td><code>unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></td>
</tr>
<tr>
<td><code>static &lt;K, V&gt; NavigableMap&lt;K, V&gt;</code></td>
<td><code>unmodifiableNavigableMap(NavigableMap&lt;K, ? extends V&gt; m)</code></td>
</tr>
<tr>
<td><code>static &lt;K, V&gt; SortedMap&lt;K, V&gt;</code></td>
<td><code>unmodifiableSortedMap(SortedMap&lt;K, ? extends V&gt; m)</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CS</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java-IO</title>
    <url>/anyeansan.github.io/2020/09/29/Java/Java-IO/</url>
    <content><![CDATA[<h1 id="一-File"><a href="#一-File" class="headerlink" title="一 File"></a>一 <code>File</code></h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ol>
<li>File 类代表了一个文件或一个目录</li>
<li>File 类中涉及到的关于文件或目录的创建、删除、修改等方法，并未涉及到写入或读取文件内容的操作。如需读写文件内容，必须通过 IO 流来完成</li>
</ol>
<h2 id="1-2-属性"><a href="#1-2-属性" class="headerlink" title="1.2 属性"></a>1.2 属性</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static char</code></td>
<td><code>separatorChar</code></td>
<td>路径分隔符；<code>unix &#39;/&#39;</code>，<code>windows &#39;\\&#39;</code></td>
</tr>
<tr>
<td><code>static String</code></td>
<td><code>separator</code></td>
<td><code>&quot;&quot; + separatorChar</code></td>
</tr>
<tr>
<td><code>static char</code></td>
<td><code>pathSeparatorChar</code></td>
<td>多个路径之间的分隔符；<code>unix :</code> ，<code>windows  ;</code></td>
</tr>
<tr>
<td><code>static String</code></td>
<td><code>pathSeparator</code></td>
<td><code>&quot;&quot; + pathSeparatorChar</code></td>
</tr>
</tbody></table>
<h2 id="1-3-构造"><a href="#1-3-构造" class="headerlink" title="1.3 构造"></a>1.3 构造</h2><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>File​(String pathname)</code></td>
<td>根据路径字符串构造 <code>File</code></td>
</tr>
<tr>
<td><code>File​(String parent, String child)</code></td>
<td>根据父路径字符串和子路径字符串构造 <code>File</code></td>
</tr>
<tr>
<td><code>File​(File parent, String child)</code></td>
<td>根据父 <code>File</code> 和 子路径字符串构造 <code>File</code></td>
</tr>
<tr>
<td><code>File(URI uri)</code></td>
<td>根据 <code>uri</code> 构造 <code>File</code></td>
</tr>
</tbody></table>
<h2 id="1-4-方法"><a href="#1-4-方法" class="headerlink" title="1.4 方法"></a>1.4 方法</h2><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1 创建"></a>1 创建</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>createNewFile()</code></td>
<td>创建文件，已存在则不创建</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>mkdir()</code></td>
<td>创建目录，已存在则不创建</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>mkdirs()</code></td>
<td>递归创建目录</td>
</tr>
</tbody></table>
<h3 id="2-删除"><a href="#2-删除" class="headerlink" title="2 删除"></a>2 删除</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>delete()</code></td>
<td>删除文件或空目录（不走回收站）</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>renameTo(File dest)</code></td>
<td>路径相同则重命名，路径不同则剪切</td>
</tr>
</tbody></table>
<h3 id="3-判断"><a href="#3-判断" class="headerlink" title="3 判断"></a>3 判断</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>exists()</code></td>
<td>是否存在</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isDirectory()</code></td>
<td>是否是目录</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isFile()</code></td>
<td>是否是文件</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>canRead()</code></td>
<td>是否可读</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>canWrite()</code></td>
<td>是否可写</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isHidden()</code></td>
<td>是否是隐藏</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isAbsolute()</code></td>
<td>是否是绝对路径</td>
</tr>
</tbody></table>
<h3 id="4-获取"><a href="#4-获取" class="headerlink" title="4 获取"></a>4 获取</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>getName()</code></td>
<td>获取文件名</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getPath()</code></td>
<td>获取构造 File 对象时指定的路径</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getAbsolutePath()</code></td>
<td>获取绝对路径</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getCanonicalPath()</code></td>
<td>获取规范路径（自动解析 <code>. ..</code>）</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>length()</code></td>
<td>获取文件大小</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>lastModified()</code></td>
<td>获取文件最后修改时间</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getParent()</code></td>
<td>获取父目录路径的字符串</td>
</tr>
<tr>
<td><code>File</code></td>
<td><code>getParentFile()</code></td>
<td>获取父目录路径的 File 对象</td>
</tr>
</tbody></table>
<h3 id="5-遍历目录"><a href="#5-遍历目录" class="headerlink" title="5 遍历目录"></a>5 遍历目录</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static File[]</code></td>
<td><code>listRoots()</code></td>
<td>获取系统可用盘符</td>
</tr>
<tr>
<td><code>String[]</code></td>
<td><code>list()</code></td>
<td>获取目录下所有文件和目录的字符串名称的数组</td>
</tr>
<tr>
<td><code>String[]</code></td>
<td><code>list(FilenameFilter filter)</code></td>
<td>文件名过滤器</td>
</tr>
<tr>
<td><code>File[]</code></td>
<td><code>listFiles()</code></td>
<td>获取目录下所有文件和目录的 File 对象的数组</td>
</tr>
<tr>
<td><code>File[]</code></td>
<td><code>listFiles(FileFilter filter)</code></td>
<td>文件过滤器</td>
</tr>
<tr>
<td><code>File[]</code></td>
<td><code>listFiles(FilenameFilter filter)</code></td>
<td>文件名过滤器</td>
</tr>
</tbody></table>
<h1 id="二-IO-流的异常处理"><a href="#二-IO-流的异常处理" class="headerlink" title="二 IO 流的异常处理"></a>二 IO 流的异常处理</h1><h2 id="2-1-JDK-7"><a href="#2-1-JDK-7" class="headerlink" title="2.1 JDK 7"></a>2.1 JDK 7</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream in = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	in = <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>);</span><br><span class="line">	业务代码;</span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">	异常处理;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(in!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			in.close();</span><br><span class="line">		&#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-JDK-8"><a href="#2-2-JDK-8" class="headerlink" title="2.2 JDK 8"></a>2.2 JDK 8</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (</span><br><span class="line">	需要关闭的资源;</span><br><span class="line">) &#123;</span><br><span class="line">	业务代码;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">	异常处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>实现了 <code>java.lang.AutoCloseble</code> 的资源可以使用此语法自动关闭（无论是否发生异常）</li>
<li>IO 流体系实现了此接口</li>
<li>JDK9 以后要关闭的资源可以在 <code>try</code> 外边初始化</li>
</ol>
<h1 id="三-基础流"><a href="#三-基础流" class="headerlink" title="三 基础流"></a>三 基础流</h1><h2 id="3-1-字节输入流"><a href="#3-1-字节输入流" class="headerlink" title="3.1 字节输入流"></a>3.1 字节输入流</h2><h3 id="1-体系"><a href="#1-体系" class="headerlink" title="1 体系"></a>1 体系</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81.png" alt=""></p>
<h3 id="2-InputStream"><a href="#2-InputStream" class="headerlink" title="2 InputStream"></a>2 <code>InputStream</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>abstract int</code></td>
<td><code>read()</code></td>
<td>读取单个字节，返回字节的 <code>int</code> 值，流末尾返回 <code>-1</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>read​(byte[] b)</code></td>
<td>读取字节并存储到数组中，返回读取的字节个数，流末尾返回 <code>-1</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>read​(byte[] b, int off, int len)</code></td>
<td>读取字节并存储到数组指定位置，返回读取的字节个数，流末尾返回 <code>-1</code></td>
</tr>
<tr>
<td><code>byte[]</code></td>
<td><code>readAllBytes()</code></td>
<td>读取流中所有字节</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>transferTo(OutputStream out)</code></td>
<td>将当前输入流中所有数据传递给输出流，并返回传递字节数</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>close()</code></td>
<td>关闭流</td>
</tr>
</tbody></table>
<ul>
<li>字节流读取中文<ol>
<li>使用 <code>read()</code> 读取一个字节肯定乱码</li>
<li>使用 <code>read(byte[] b)</code> 缓存数组读取有可能乱码，因为数组长度与数据的字节个数未必恰好吻合，有可能会出现一个字符多个字节但只读取到部分的情况</li>
</ol>
</li>
</ul>
<h2 id="3-2-字节输出流"><a href="#3-2-字节输出流" class="headerlink" title="3.2 字节输出流"></a>3.2 字节输出流</h2><h3 id="1-体系-1"><a href="#1-体系-1" class="headerlink" title="1 体系"></a>1 体系</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81.png" alt=""></p>
<h3 id="2-OutputStream"><a href="#2-OutputStream" class="headerlink" title="2 OutputStream"></a>2 <code>OutputStream</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>abstract void</code></td>
<td><code>write​(int b)</code></td>
<td>写单个字节</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>write(byte[] b)</code></td>
<td>写字节数组</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>write(byte[] b, int off, int len)</code></td>
<td>写字节数组的指定部分</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>flush()</code></td>
<td>刷新，即将缓冲区数据写到目的地，刷新后还可以继续写</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>close()</code></td>
<td>关闭前会自动刷新</td>
</tr>
</tbody></table>
<h2 id="3-3-字符输入流"><a href="#3-3-字符输入流" class="headerlink" title="3.3 字符输入流"></a>3.3 字符输入流</h2><h3 id="1-体系-2"><a href="#1-体系-2" class="headerlink" title="1 体系"></a>1 体系</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81.png" alt=""></p>
<h3 id="2-Reader"><a href="#2-Reader" class="headerlink" title="2 Reader"></a>2 <code>Reader</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>read()</code></td>
<td>读取单个字符，返回 Unicode 码元（<code>0~65535</code>），流末尾返回 <code>-1</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>read(char[] cbuf)</code></td>
<td>读取字符并存储到数组中，返回读取的字符个数，流末尾返回 <code>-1</code></td>
</tr>
<tr>
<td><code>abstract int</code></td>
<td><code>read​(char[] cbuf, int off, int len)</code></td>
<td>读取字符并存储到数组指定位置，返回读取的字符个数，流末尾返回 <code>-1</code></td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code>close()</code></td>
<td>关闭流</td>
</tr>
</tbody></table>
<ol>
<li>字符流一次读取一个字符，字符流怎么知道几个字节是一个字符呢？<ul>
<li>跟字符集有关，如GBK中中文都是1开头的</li>
</ul>
</li>
<li>字符流编码转换过程 <code>read()</code><ul>
<li>按照指定字符集读取 → 查询 <code>unicode</code> 中对应的码点（因为 java 为 <code>unicode</code>）</li>
<li>比如文件内容为一个字 “北”，假如使用的码表为GBK，字符流读取结果为 <code>十进制：21271</code>，转为十六进制为 <code>\u5317</code>，先读取文件根据GBK转成了 “北”，然后查“北”在 <code>Unicode</code> 中的码点</li>
</ul>
</li>
</ol>
<h2 id="3-4-字符输出流"><a href="#3-4-字符输出流" class="headerlink" title="3.4 字符输出流"></a>3.4 字符输出流</h2><h3 id="1-体系-3"><a href="#1-体系-3" class="headerlink" title="1 体系"></a>1 体系</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81.png" alt=""></p>
<h3 id="2-Writer"><a href="#2-Writer" class="headerlink" title="2 Writer"></a>2 <code>Writer</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>write(int c)</code></td>
<td>写单个字符</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>write(String str)</code></td>
<td>写字符串</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>write(String str, int off, int len)</code></td>
<td>写字符串的指定部分</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>write(char[] cbuf)</code></td>
<td>写字符数组</td>
</tr>
<tr>
<td><code>abstract  void</code></td>
<td><code>write(char[] cbuf, int off, int len)</code></td>
<td>写字符数组的指定部分</td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code>flush()</code></td>
<td>刷新</td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code>close()</code></td>
<td>关闭前会自动刷新</td>
</tr>
</tbody></table>
<h1 id="四-文件流"><a href="#四-文件流" class="headerlink" title="四 文件流"></a>四 文件流</h1><h2 id="4-1-FileInputStream"><a href="#4-1-FileInputStream" class="headerlink" title="4.1 FileInputStream"></a>4.1 <code>FileInputStream</code></h2><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>FileInputStream(File file)</code></td>
<td>根据 File 对象创建，文件必须存在</td>
</tr>
<tr>
<td><code>FileInputStream(String name)</code></td>
<td>根据文件路径创建，文件必须存在</td>
</tr>
</tbody></table>
<h2 id="4-2-FileOutputStream"><a href="#4-2-FileOutputStream" class="headerlink" title="4.2 FileOutputStream"></a>4.2 <code>FileOutputStream</code></h2><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>FileOutputStream(File file [, boolean append])</code></td>
<td>文件不存在会创建，文件存在会清空</td>
</tr>
<tr>
<td><code>FileOutputStream(String name [, boolean append])</code></td>
<td>文件不存在会创建，文件存在会清空</td>
</tr>
</tbody></table>
<h1 id="五-缓冲流"><a href="#五-缓冲流" class="headerlink" title="五 缓冲流"></a>五 缓冲流</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol>
<li>缓存流和定义数组哪个快？<ul>
<li>定义数组快，因为读写操作的都是同一个数组，而缓存流分输入和输出，操作的是两个数组</li>
</ul>
</li>
<li>关闭流时，先关外层，再关内层，而关外层流时内层流会自动关闭</li>
</ol>
<h2 id="5-2-字节缓冲流"><a href="#5-2-字节缓冲流" class="headerlink" title="5.2 字节缓冲流"></a>5.2 字节缓冲流</h2><h3 id="1-BufferedInputStream"><a href="#1-BufferedInputStream" class="headerlink" title="1 BufferedInputStream"></a>1 <code>BufferedInputStream</code></h3><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>BufferedInputStream​(InputStream in [, int size])</code></td>
<td>默认缓存区大小为 <code>8192</code> 字节</td>
</tr>
</tbody></table>
<h3 id="2-BufferedOutputStream"><a href="#2-BufferedOutputStream" class="headerlink" title="2 BufferedOutputStream"></a>2 <code>BufferedOutputStream</code></h3><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>BufferedOutputStream(OutputStream out, int size)</code></td>
<td>默认缓存区大小为 <code>8192</code> 字节</td>
</tr>
</tbody></table>
<h2 id="5-3-字符缓冲流"><a href="#5-3-字符缓冲流" class="headerlink" title="5.3 字符缓冲流"></a>5.3 字符缓冲流</h2><h3 id="1-BufferedReader"><a href="#1-BufferedReader" class="headerlink" title="1 BufferedReader"></a>1 <code>BufferedReader</code></h3><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>BufferedReader​(Reader in [, int sz])</code></td>
<td>默认缓存区大小 <code>8192</code> 字符</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>readLine()</code></td>
<td>读取一行并返回（不包括换行符），流末尾返回 <code>null</code></td>
</tr>
</tbody></table>
<h3 id="2-BufferedWriter"><a href="#2-BufferedWriter" class="headerlink" title="2 BufferedWriter"></a>2 <code>BufferedWriter</code></h3><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>BufferedWriter​(Writer out [, int sz])</code></td>
<td>默认缓存区大小 <code>8192</code> 字符</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>newLine()</code></td>
<td>写出换行符（可跨平台）</td>
</tr>
</tbody></table>
<h1 id="六-转换流"><a href="#六-转换流" class="headerlink" title="六 转换流"></a>六 转换流</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><ol>
<li><p>转换流属于字符流，提供了字节流和字符流之间的转换</p>
<ul>
<li><code>InputStreamReader</code>：<code>InputStream</code> → <code>Reader</code></li>
<li><code>OutputStreamWriter</code>：<code>Writer</code> → <code>OutputStream</code></li>
</ul>
</li>
<li><p>字符流原理就是转换流使用平台默认字符集将字节流转换成了字符流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"test.txt"</span>);</span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"test.txt"</span>),<span class="string">"utf-8"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>字符流 = 转换流(字节流 + 默认字符集)</p>
</li>
<li><p>如果默认字符集是 <code>utf-8</code> ，则上述两句是等价的</p>
</li>
</ul>
</li>
</ol>
<h2 id="6-2-InputStreamReader"><a href="#6-2-InputStreamReader" class="headerlink" title="6.2 InputStreamReader"></a>6.2 <code>InputStreamReader</code></h2><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>InputStreamReader​(InputStream in [, String charsetName)]</code></td>
<td>字节流到字符流的桥梁，使用指定字符集解码</td>
</tr>
</tbody></table>
<ol>
<li>使用字节流读取文本数据时，先读取字节数据，然后使用字符集解码</li>
<li><code>InputStreamReader</code>：读取字节数据并使用字符集解码</li>
</ol>
<h2 id="6-3-OutputStreamWriter"><a href="#6-3-OutputStreamWriter" class="headerlink" title="6.3 OutputStreamWriter"></a>6.3 <code>OutputStreamWriter</code></h2><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>OutputStreamWriter​(OutputStream out [, String charsetName])</code></td>
<td>字符流到字节流的桥梁，使用指定字符集编码</td>
</tr>
</tbody></table>
<ol>
<li>使用字节流写出文本数据时，先使用字符集编码，然后写出字节数据</li>
<li><code>OutputStreamWriter</code>：使用字符集编码并写出字节数据</li>
</ol>
<h2 id="6-4-两种方法实现键盘录入"><a href="#6-4-两种方法实现键盘录入" class="headerlink" title="6.4 两种方法实现键盘录入"></a>6.4 两种方法实现键盘录入</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in))</span><br><span class="line">BUfferedWriter bw=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out)) </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure>

<h1 id="七-打印流"><a href="#七-打印流" class="headerlink" title="七 打印流"></a>七 打印流</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ol>
<li>可以对多种数据类型进行打印，并<strong>保持数据的表示形式</strong><ol>
<li><code>write(int)</code> ：只会写出 1 个字节</li>
<li><code>print(int)</code> ：可以写出 4 个字节</li>
</ol>
</li>
<li>不抛出 <code>IOException</code></li>
<li>打印原理<ol>
<li>基本数据类型先变成字符串再打印</li>
<li>引用数据类型非 <code>null</code> 就调用对象的 <code>toString()</code>，<code>null</code> 就打印 <code>null</code></li>
</ol>
</li>
<li><code>PrintWriter &amp; printStream</code><ol>
<li><code>PrintStream</code> 能做的 <code>PrintWriter</code> 也都能实现且功能更强大，但 <code>PrintStream</code> 出现较早，<code>System.out</code> 使用的是 <code>PrintStream</code> 来实现的，所以为了兼容并没有废弃 <code>PrintStream</code></li>
<li>二者都提供了一系列重载的 <code>print println</code> 方法</li>
<li><code>PringtStream</code> 打印的所有字符都使用平台默认的字符集来编码为字节数据，打印字符时，建议使用 <code>PrintWriter</code></li>
<li><code>PrintWriter &amp; printStream</code> 都可以设置自动刷新<ul>
<li><code>printStream</code>：写入字节数组、任何重载版本的 <code>println()</code> 被调用、一个换行符（<code>char</code>）被写入、一个换行符的字节存储（<code>\n</code>）被写入</li>
<li><code>PrintWriter</code>： 自动刷新只对 <code>println() printf() format()</code> 这些方法有效</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="7-2-PrintStream"><a href="#7-2-PrintStream" class="headerlink" title="7.2 PrintStream"></a>7.2 <code>PrintStream</code></h2><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>PrintStream​(File file [, String charsetName])</code></td>
<td>接收 File 对象</td>
</tr>
<tr>
<td><code>PrintStream​(String fileName [, String charsetName])</code></td>
<td>接收字符串路径</td>
</tr>
<tr>
<td><code>PrintStream​(OutputStream out [, boolean autoFlush [, String encoding]])</code></td>
<td>接收字节输出流</td>
</tr>
</tbody></table>
<h2 id="7-3-PrintWriter"><a href="#7-3-PrintWriter" class="headerlink" title="7.3 PrintWriter"></a>7.3 <code>PrintWriter</code></h2><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>PrintWriter​(File file [, String charsetName])</code></td>
<td>接收 File 对象</td>
</tr>
<tr>
<td><code>PrintWriter​(String fileName [, String charsetName])</code></td>
<td>接收字符串路径</td>
</tr>
<tr>
<td><code>PrintWriter​(OutputStream out [, boolean autoFlush [, Charset charset]])</code></td>
<td>接收字节输出流</td>
</tr>
<tr>
<td><code>PrintWriter​(Writer out [, boolean autoFlush])</code></td>
<td>接收字符输出流</td>
</tr>
</tbody></table>
<h2 id="7-4-标准输入输出流"><a href="#7-4-标准输入输出流" class="headerlink" title="7.4 标准输入输出流"></a>7.4 标准输入输出流</h2><table>
<thead>
<tr>
<th>流</th>
<th>类型</th>
<th>说明</th>
<th>设备</th>
</tr>
</thead>
<tbody><tr>
<td><code>System.in</code></td>
<td><code>InputStream</code></td>
<td>标准输入</td>
<td>键盘</td>
</tr>
<tr>
<td><code>System.out</code></td>
<td><code>PrintStream</code></td>
<td>标准输出</td>
<td>显示器（控制台）</td>
</tr>
<tr>
<td><code>System.err</code></td>
<td><code>PrintStream</code></td>
<td>标准错误输出</td>
<td>显示器（控制台）</td>
</tr>
</tbody></table>
<h1 id="八-序列化流（对象流）"><a href="#八-序列化流（对象流）" class="headerlink" title="八 序列化流（对象流）"></a>八 序列化流（对象流）</h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><ol>
<li>序列化 &amp; 反序列化<ul>
<li>序列化：写出一个对象</li>
<li>反序列化：读取一个对象</li>
</ul>
</li>
<li>对象序列化机制：好处在于将对象转化为字节数据，使其在保存和传输时可被还原<ul>
<li>允许把内存中的 Java 对象转换成平台无关的二进制流，从而把这种二进制流持久的保存在磁盘上或通过网络进行传输</li>
<li>当其它程序获取这种二进制流，就可以恢复成原来的 Java 对象</li>
</ul>
</li>
<li>对象序列化的条件：<ol>
<li>对象必须实现序列化接口<ul>
<li><code>Serializable</code> ：序列化标记接口，对象序列化内容和顺序都是默认的</li>
<li><code>Externalizable</code> ：<code>Serializable</code> 的子接口，可定制序列号内容和顺序</li>
</ul>
</li>
<li>对象的所有属性也必须可序列化<ul>
<li>引用类型的属性也必须实现序列化接口</li>
<li>基本类型属性默认可序列化</li>
</ul>
</li>
<li>对象不会序列化的属性<ul>
<li><code>transient</code> 关键字修饰的属性</li>
<li><code>static</code> 关键字修饰的属性</li>
</ul>
</li>
</ol>
</li>
<li>序列化ID ：<code>serialVersionUID</code><ul>
<li>用于判断类和对象是否是同一个版本</li>
<li>建议实现序列化接口时就指定，否则每次重新编译类，序列化ID都会变化</li>
</ul>
</li>
</ol>
<h2 id="8-2-ObjectInputStream"><a href="#8-2-ObjectInputStream" class="headerlink" title="8.2 ObjectInputStream"></a>8.2 <code>ObjectInputStream</code></h2><h3 id="1-构造"><a href="#1-构造" class="headerlink" title="1 构造"></a>1 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ObjectInputStream​(InputStream in)</code></td>
<td>装饰字节输入流</td>
</tr>
</tbody></table>
<h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2 方法"></a>2 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object</code></td>
<td><code>readObject()</code></td>
<td>读取对象</td>
</tr>
</tbody></table>
<h2 id="8-3-ObjectOutputStream"><a href="#8-3-ObjectOutputStream" class="headerlink" title="8.3 ObjectOutputStream"></a>8.3 <code>ObjectOutputStream</code></h2><h3 id="1-构造-1"><a href="#1-构造-1" class="headerlink" title="1 构造"></a>1 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ObjectOutputStream(OutputStream out)</code></td>
<td>装饰字节输出流</td>
</tr>
</tbody></table>
<h3 id="2-方法-1"><a href="#2-方法-1" class="headerlink" title="2 方法"></a>2 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>writeObject(Object obj)</code></td>
<td>写出对象</td>
</tr>
</tbody></table>
<h1 id="九-数据流"><a href="#九-数据流" class="headerlink" title="九 数据流"></a>九 数据流</h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><ol>
<li>数据流主要用来操作基本类型和 <code>String</code> 类型的数据，这些数据如果使用其它流读写，可能会出问题</li>
<li>以二进制形式读写数组，字符，字符串，布尔…</li>
</ol>
<h2 id="9-2-DataInputStream"><a href="#9-2-DataInputStream" class="headerlink" title="9.2 DataInputStream"></a>9.2 <code>DataInputStream</code></h2><h3 id="1-构造-2"><a href="#1-构造-2" class="headerlink" title="1 构造"></a>1 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>DataInputStream​(InputStream in)</code></td>
<td>装饰字节输入流</td>
</tr>
</tbody></table>
<h3 id="2-方法-2"><a href="#2-方法-2" class="headerlink" title="2 方法"></a>2 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>readUTF()</code></td>
<td>读字符串</td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>readT()</code></td>
<td>读指定类型数据，<code>readInt() readDouble() ...</code></td>
</tr>
</tbody></table>
<h2 id="9-3-DataOutputStream"><a href="#9-3-DataOutputStream" class="headerlink" title="9.3 DataOutputStream"></a>9.3 <code>DataOutputStream</code></h2><h3 id="1-构造-3"><a href="#1-构造-3" class="headerlink" title="1 构造"></a>1 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>DataOutputStream​(OutputStream out)</code></td>
<td>装饰字节输出流</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>writeUTF​(String str)</code></td>
<td>写字符串</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>writeT(T t)</code></td>
<td>写指定类型数据，<code>writeInt(int i) writeDouble(double d) ...</code></td>
</tr>
</tbody></table>
<h1 id="十-内存流"><a href="#十-内存流" class="headerlink" title="十 内存流"></a>十 内存流</h1><h2 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h2><ol>
<li>操作字节数组</li>
<li>流关闭无效，不抛 <code>IOException</code></li>
<li>向内存中读写数组</li>
<li>字节流读取中文时，可能会乱码，可以使用内存输出流先写到内存中，然后一次性获取所有数据</li>
</ol>
<h2 id="10-2-ByteArrayInputStream"><a href="#10-2-ByteArrayInputStream" class="headerlink" title="10.2 ByteArrayInputStream"></a>10.2 <code>ByteArrayInputStream</code></h2><h3 id="1-构造-4"><a href="#1-构造-4" class="headerlink" title="1 构造"></a>1 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ByteArrayInputStream(byte[] buf [, int offset, int length])</code></td>
<td>把字节数组作为缓冲数组</td>
</tr>
</tbody></table>
<h3 id="2-方法-3"><a href="#2-方法-3" class="headerlink" title="2 方法"></a>2 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>read()</code></td>
<td>读取一个字节</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>read(byte[] b, int off, int len)</code></td>
<td>读取字节并存储在数组中</td>
</tr>
</tbody></table>
<h2 id="10-3-ByteArrayOutputStream"><a href="#10-3-ByteArrayOutputStream" class="headerlink" title="10.3 ByteArrayOutputStream"></a>10.3 <code>ByteArrayOutputStream</code></h2><h3 id="1-构造-5"><a href="#1-构造-5" class="headerlink" title="1 构造"></a>1 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ByteArrayOutputStream([int size])</code></td>
<td>可以指定缓冲区大小</td>
</tr>
</tbody></table>
<h3 id="2-方法-4"><a href="#2-方法-4" class="headerlink" title="2 方法"></a>2 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>write(int b)</code></td>
<td>写出一个字节</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>write(byte[] b, int off, int len)</code></td>
<td>写出数组指定数据</td>
</tr>
<tr>
<td><code>byte[]</code></td>
<td><code>toByteArray()</code></td>
<td>将缓冲区的数据全部取出，获取一个字节数组</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>toString()</code></td>
<td>将缓冲区的数据用平台默认编码转为字符串</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CS</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java-异常</title>
    <url>/anyeansan.github.io/2020/09/29/Java/Java-%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="一-异常体系"><a href="#一-异常体系" class="headerlink" title="一 异常体系"></a>一 异常体系</h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png" alt=""></p>
<ol>
<li>非受检异常： <code>Unchecked Exception</code><ol>
<li><code>Error</code><ul>
<li>在你的控制范围之外</li>
<li>一般指 JVM 系统内部错误或资源耗尽等严重问题，一般不编写针对性的代码进行处理</li>
</ul>
</li>
<li><code>RuntimeException</code><ul>
<li>一般是程序员所犯的错误，由于代码不够健壮引起的异常，<strong>如果出现 <code>RuntimeException</code> 那么一定是你的问题</strong></li>
<li>不应该处理，而是一开始就应该避免</li>
</ul>
</li>
</ol>
</li>
<li>受检异常：<code>Checked Exception</code><ul>
<li>非受检异常 <code>Error</code> 和 <code>RuntimeException</code> 外的所有异常都是受检异常，或叫编译时异常</li>
<li>编译时异常一般是由程序的运行环境导致的，程序可能被运行在各种未知的环境下，而程序员无法干预用户的使用环境</li>
<li>检查型异常需要处理：声明或捕获</li>
</ul>
</li>
</ol>
<h1 id="二-异常处理（抛抓模型）"><a href="#二-异常处理（抛抓模型）" class="headerlink" title="二 异常处理（抛抓模型）"></a>二 异常处理（抛抓模型）</h1><h2 id="2-1-“抛”-过程"><a href="#2-1-“抛”-过程" class="headerlink" title="2.1 “抛” 过程"></a>2.1 “抛” 过程</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><ol>
<li>程序出现异常时，会在异常代码处创建一个异常对象（包含内容，原因，位置 …），并将此对象抛出</li>
<li>一旦抛出异常对象后，其后的代码就不再执行</li>
<li>抛出异常有两种方式<ul>
<li>系统自动生成并抛出的异常</li>
<li>手动抛出异常 <code>throw</code></li>
</ul>
</li>
</ol>
<h3 id="2-throw"><a href="#2-throw" class="headerlink" title="2 throw"></a>2 <code>throw</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> 异常对象实例;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>throw</code> 用在在方法中，抛出异常<ul>
<li>非受检异常 <code>throw</code> 后可以不用处理</li>
<li>受检异常 <code>throw</code> 后必须处理：<code>try-catch</code> 或 <code>throws</code></li>
</ul>
</li>
<li><code>throw</code> 会终止程序，代替 <code>return</code></li>
</ol>
<h2 id="2-2-“抓”-过程"><a href="#2-2-“抓”-过程" class="headerlink" title="2.2 “抓” 过程"></a>2.2 “抓” 过程</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>可以理解为异常的处理方式</li>
<li>共有两种：<ul>
<li><code>try-catch-finally</code></li>
<li><code>throws</code></li>
</ul>
</li>
</ol>
<h3 id="2-try-catch"><a href="#2-try-catch" class="headerlink" title="2 try-catch"></a>2 <code>try-catch</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(</span><br><span class="line">	<span class="comment">// 可能出现异常的代码</span></span><br><span class="line">) <span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">// 异常处理;</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>) &#123;</span><br><span class="line">	<span class="comment">// 异常处理;</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>) &#123;</span><br><span class="line">	<span class="comment">// 异常处理;</span></span><br><span class="line">&#125;  </span><br><span class="line">...</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 可选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>try catch</code> 处理异常后，程序可以继续运行</li>
<li>多 <code>catch</code> 时，大的异常要放在后边，因为会依次匹配，匹配到就停止</li>
<li><code>try</code> 中的代码发生异常相当于创建了一个异常对象，然后赋值给 <code>catch</code> 后边括号中的变量</li>
</ol>
<h3 id="3-throws"><a href="#3-throws" class="headerlink" title="3 throws"></a>3 <code>throws</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> 异常1, 异常2, ... </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>throws</code> 用在方法上，声明此方法可能抛出的异常</li>
<li>可以声明多个，逗号分隔</li>
<li>一旦出现异常，把异常对象抛给此方法的调用者，若调用者也没有处理，则一直抛直到 <code>main</code> 函数，如果 <code>main</code> 函数也没有处理，则抛给 JVM 处理，JVM 默认异常处理机制：<code>printStackTrace()</code></li>
</ol>
<h1 id="三-java-lang-Throwable"><a href="#三-java-lang-Throwable" class="headerlink" title="三 java.lang.Throwable"></a>三 <code>java.lang.Throwable</code></h1><h2 id="3-1-构造"><a href="#3-1-构造" class="headerlink" title="3.1 构造"></a>3.1 构造</h2><table>
<thead>
<tr>
<th>构造</th>
</tr>
</thead>
<tbody><tr>
<td><code>Throwable()</code></td>
</tr>
<tr>
<td><code>Throwable(String message)</code></td>
</tr>
<tr>
<td><code>Throwable(Throwable cause)</code></td>
</tr>
<tr>
<td><code>Throwable(String message, Throwable cause)</code></td>
</tr>
</tbody></table>
<h2 id="3-2-方法"><a href="#3-2-方法" class="headerlink" title="3.2 方法"></a>3.2 方法</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>toString()</code></td>
<td>返回异常类名和异常信息的字符串</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getMessage()</code></td>
<td>获取异常信息</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>printStackTrace()</code></td>
<td>打印异常类名和异常信息，以及异常出现在程序中的位置</td>
</tr>
<tr>
<td><code>Throwable</code></td>
<td><code>getCause()</code></td>
<td>获取原因</td>
</tr>
<tr>
<td><code>Throwable</code></td>
<td><code>initCause(Throwable cause)</code></td>
<td>为异常对象设置原因，如果已有原因则抛出一个异常</td>
</tr>
<tr>
<td><code>StackTraceElement[]</code></td>
<td><code>getStackTrace()</code></td>
<td>获取构造异常对象时调用堆栈的轨迹</td>
</tr>
</tbody></table>
<h1 id="四-自定义异常"><a href="#四-自定义异常" class="headerlink" title="四 自定义异常"></a>四 自定义异常</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    statci <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = xxxxx;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>继承现有异常结构： <code>Exception</code> 或 <code>RuntimeException</code></li>
<li>提供重载构造器：建议保留无参构造和带 <code>message</code> 的有参构造</li>
<li>由于 <code>Throwable</code> 实现了 <code>Serializable</code> 接口，建议自定义异常时指定 <code>serialVersionUID</code></li>
</ol>
<h1 id="五-思考"><a href="#五-思考" class="headerlink" title="五 思考"></a>五 思考</h1><ul>
<li><code>return</code> 与 <code>finally</code> 混用<ol>
<li>执行到了 <code>return</code>，已经把要返回的结果准备好了。这时先去执行 <code>finally</code> 中的代码，然后再 <code>return</code></li>
<li>如果 <code>finally</code> 中改变了要 <code>return</code> 的值，最终返回结果也不会改变，因为 <code>return</code> 的值已经缓存好了，改变了也没用。</li>
<li>如果 <code>finally</code> 中也有 <code>return</code>，那么最后返回的是 <code>finally</code>中的返回值</li>
</ol>
</li>
</ul>
<h1 id="六-断言"><a href="#六-断言" class="headerlink" title="六 断言"></a>六 断言</h1><h2 id="6-1-语法"><a href="#6-1-语法" class="headerlink" title="6.1 语法"></a>6.1 语法</h2><ol>
<li><code>assert condition;</code><ul>
<li>如果 <code>condition</code> 为 <code>false</code> 则抛出 <code>AssertionError</code> 异常</li>
</ul>
</li>
<li><code>assert condition: expression;</code><ul>
<li>如果 <code>condition</code> 为 <code>false</code> 则抛出 <code>AssertionError</code> 异常，且 <code>expression</code> 会传入 <code>AssertionError</code> 构造器，并转为一个消息字符串</li>
</ul>
</li>
</ol>
<h2 id="6-2-启用-禁用断言"><a href="#6-2-启用-禁用断言" class="headerlink" title="6.2 启用/禁用断言"></a>6.2 启用/禁用断言</h2><ol>
<li><p>断言默认是禁用的</p>
</li>
<li><p>运行时使用 <code>-enableassertions</code> 或 <code>-ea</code> 启用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -ea Test 打开某个类的断言</span><br><span class="line">java -ea:xxx.xx.x Test 打开包下所有类的断言</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>-disableassertions</code> 或 <code>-da</code> 禁用断言</p>
</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java-面向对象</title>
    <url>/anyeansan.github.io/2020/09/29/Java/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-编程范式-programming-paradigm"><a href="#1-1-编程范式-programming-paradigm" class="headerlink" title="1.1 编程范式 programming paradigm"></a>1.1 编程范式 <code>programming paradigm</code></h2><table>
<thead>
<tr>
<th>术语</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Procedural programming</code></td>
<td>面向过程</td>
</tr>
<tr>
<td><code>Object-Oriented Programming</code></td>
<td>面向对象</td>
</tr>
<tr>
<td><code>Functional Programming</code></td>
<td>函数式</td>
</tr>
<tr>
<td><code>Event-driven Programming</code></td>
<td>事件驱动</td>
</tr>
<tr>
<td><code>Aspect-oriented Programming</code></td>
<td>面向切面</td>
</tr>
<tr>
<td><code>Logic Programming</code></td>
<td>逻辑</td>
</tr>
</tbody></table>
<h2 id="1-2-面向对象和面向过程"><a href="#1-2-面向对象和面向过程" class="headerlink" title="1.2 面向对象和面向过程"></a>1.2 面向对象和面向过程</h2><ol>
<li>把大象装进冰箱<ul>
<li>面向过程 POP（<code>Process Oriented Programming</code>）<ol>
<li>打开冰箱门</li>
<li>把大象放进去</li>
<li>关上冰箱门</li>
</ol>
</li>
<li>面向对象 OOP（<code>Object Oriented Programming</code>）<ol>
<li>冰箱（开门，关门）</li>
<li>大象（进冰箱）</li>
<li>人（指挥冰箱开门，指挥大象进去，指挥冰箱关门）</li>
</ol>
</li>
</ul>
</li>
<li>区别<ol>
<li>面向过程<ul>
<li>强调的是功能行为，以函数为最小单位，考虑怎么做</li>
<li>性能相对较好，但耦合性高，不易维护、复用和扩展</li>
</ul>
</li>
<li>面向对象<ul>
<li>强调具备了功能的对象，以类/对象为最小单位，考虑谁来做</li>
<li>耦合度低，易维护、易复用、易扩展</li>
</ul>
</li>
</ol>
</li>
</ol>
<h1 id="二-类"><a href="#二-类" class="headerlink" title="二 类"></a>二 类</h1><h2 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h2><table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>类 class</code></td>
<td>对一类事物的描述，模板</td>
</tr>
<tr>
<td><code>对象 object</code></td>
<td>某类事物的个体，也叫实例（<code>instance</code>）</td>
</tr>
<tr>
<td><code>属性 field</code></td>
<td>类的成员变量，也叫字段，域</td>
</tr>
<tr>
<td><code>方法 method</code></td>
<td>类的成员函数，也叫行为</td>
</tr>
</tbody></table>
<h2 id="2-2-类成员"><a href="#2-2-类成员" class="headerlink" title="2.2 类成员"></a>2.2 类成员</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">	属性列表</span><br><span class="line">	代码块</span><br><span class="line">	构造器列表</span><br><span class="line">	方法列表</span><br><span class="line">	内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-构造器"><a href="#1-构造器" class="headerlink" title="1 构造器"></a>1 构造器</h3><ol>
<li>构造函数的名称必须与类名相同</li>
<li>一个类可以有多个构造器，彼此构成重载</li>
<li>若类中没有显式定义构造函数，则会有一个默认空参构造函数（修饰符与类一致 <code>public</code> 或 <code>default</code>）</li>
<li>构造函数第一行一定直接或间接调用父类构造函数，即如果在构造器首行没有显式的使用 <code>this(形参列表)</code> 或 <code>super(形参列表)</code> ，则默认调用了 <code>super()</code></li>
</ol>
<h3 id="2-属性"><a href="#2-属性" class="headerlink" title="2 属性"></a>2 属性</h3><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 数据类型 属性名; // 默认初始值</span><br><span class="line">修饰符 数据类型 属性名 = 值; // 显式初始值</span><br></pre></td></tr></table></figure>

<h4 id="2-成员变量（实例变量-静态变量）和局部变量"><a href="#2-成员变量（实例变量-静态变量）和局部变量" class="headerlink" title="2 成员变量（实例变量/静态变量）和局部变量"></a>2 成员变量（实例变量/静态变量）和局部变量</h4><table>
<thead>
<tr>
<th>变量</th>
<th>声明位置</th>
<th>初始值</th>
<th>存储位置</th>
</tr>
</thead>
<tbody><tr>
<td>实例变量</td>
<td>类中</td>
<td>有</td>
<td>堆</td>
</tr>
<tr>
<td>静态变量</td>
<td>类中</td>
<td>有</td>
<td>方法区</td>
</tr>
<tr>
<td>局部变量</td>
<td>方法形参、方法内、代码块内、构造形参、构造内</td>
<td>无</td>
<td>栈</td>
</tr>
</tbody></table>
<h3 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h3><h4 id="1-语法-1"><a href="#1-语法-1" class="headerlink" title="1 语法"></a>1 语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 返回值 方法名(形参列表) &#123;</span><br><span class="line">	方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-形参列表"><a href="#2-形参列表" class="headerlink" title="2 形参列表"></a>2 形参列表</h4><ol>
<li><code>参数1, 参数2, ...</code></li>
<li><code>参数类型 ... 参数名</code> （可变参数）<ul>
<li>可以传递 0 到 多个参数</li>
<li>可变参数必须在形参的最后声明</li>
</ul>
</li>
</ol>
<h4 id="3-参数传递"><a href="#3-参数传递" class="headerlink" title="3 参数传递"></a>3 参数传递</h4><ol>
<li><p>Java 参数传递是<strong>值传递</strong></p>
<ul>
<li>基本数据类型实参赋值给形参的是实参真实存储的数据值</li>
<li>引用数据类型实参赋值给形参的是实参存储数据的地址值</li>
</ul>
</li>
<li><p><strong>java 在传递参数时，将实际参数的副本（拷贝一份）传入方法内，而参数本身不受影响</strong></p>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92.png" alt=""></p>
</li>
</ol>
<h4 id="4-方法的重载（Overload）"><a href="#4-方法的重载（Overload）" class="headerlink" title="4 方法的重载（Overload）"></a>4 方法的重载（Overload）</h4><ul>
<li>同一个类中，方法名相同，形参列表不同（个数、顺序或类型）即为重载</li>
</ul>
<h3 id="4-代码块"><a href="#4-代码块" class="headerlink" title="4 代码块"></a>4 代码块</h3><h4 id="1-构造代码块"><a href="#1-构造代码块" class="headerlink" title="1 构造代码块"></a>1 构造代码块</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	构造代码块：</span><br><span class="line">        <span class="number">1</span> 每次创建类实例都会在构造器之前执行</span><br><span class="line">        <span class="number">2</span> 如果有多个，按照声明顺序执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-静态代码块"><a href="#2-静态代码块" class="headerlink" title="2 静态代码块"></a>2 静态代码块</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	静态代码块：</span><br><span class="line">        <span class="number">1</span> 随着类的加载而执行，且仅在加载类字节码文件时执行一次</span><br><span class="line">        <span class="number">2</span> 如果有多个，按照声明顺序执行   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-内部类"><a href="#5-内部类" class="headerlink" title="5 内部类"></a>5 内部类</h3><h4 id="1-分类"><a href="#1-分类" class="headerlink" title="1 分类"></a>1 分类</h4><table>
<thead>
<tr>
<th>类型</th>
<th>分类</th>
<th>声明位置</th>
</tr>
</thead>
<tbody><tr>
<td>成员内部类</td>
<td>非静态成员内部类（成员内部类）<br>静态成员内部类（静态内部类）</td>
<td>类中</td>
</tr>
<tr>
<td>局部内部类</td>
<td>非匿名局部内部类（局部内部类）<br/>匿名局部内部类（匿名内部类）</td>
<td>方法中，代码块中，构造器中</td>
</tr>
</tbody></table>
<h4 id="2-成员内部类"><a href="#2-成员内部类" class="headerlink" title="2 成员内部类"></a>2 成员内部类</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h5><ol>
<li>当描述一个事物时，发现内部还有一个完整的结构需要一个类来描述，且此内部结构独立存在没有意义，必须依附外部类。就可以定义内部类。如身体和心脏。</li>
<li>内部类作为外部类的成员<ol>
<li>访问外部类<ul>
<li>内部类可以直接访问外部类的成员（包括私有），内部类持有一个外部类的引用 <code>外部类名.this</code></li>
<li>外部类要访问内部类的成员，必须创建对象</li>
</ul>
</li>
<li>可以被 4 种权限修饰符修饰</li>
<li>可以被 <code>static</code> 修饰：只要内部类不需要访问外部类对象，就应该使用静态内部类</li>
</ol>
</li>
<li>内部类作为一个类<ol>
<li>可以定义属性、方法、构造器等等</li>
<li>可以被 <code>abstract final</code> 修饰 </li>
</ol>
</li>
</ol>
<h5 id="2-非静态成员内部类（成员内部类）"><a href="#2-非静态成员内部类（成员内部类）" class="headerlink" title="2 非静态成员内部类（成员内部类）"></a>2 非静态成员内部类（成员内部类）</h5><ol>
<li><p>成员内部类中不能有任何 <code>static</code> 的定义</p>
</li>
<li><p>成员内部类的访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 首先要创建外部类对象</span></span><br><span class="line">Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line"><span class="comment">// 2 使用外部对象创建内部类对象</span></span><br><span class="line">Out.inner in = out.<span class="keyword">new</span> Inner()</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line">Outer.Inner in=<span class="keyword">new</span> Outer().<span class="keyword">new</span> Inner();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="3-静态成员内部类（静态内部类）"><a href="#3-静态成员内部类（静态内部类）" class="headerlink" title="3 静态成员内部类（静态内部类）"></a>3 静态成员内部类（静态内部类）</h5><ol>
<li><p>静态内部类可以定义所有普通类可以定义的内容</p>
</li>
<li><p>静态内部类不会随着外部类的加载而加载，只有使用时才会加载</p>
</li>
<li><p>静态内部类的访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建静态内部类对象</span></span><br><span class="line">Outer.Inner in=<span class="keyword">new</span> Outer.Inner()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="3-局部内部类"><a href="#3-局部内部类" class="headerlink" title="3 局部内部类"></a>3 局部内部类</h4><h5 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h5><ol>
<li>局部内部类修饰符只能有 <code>final</code> 和 <code>abstract</code></li>
<li>局部内部类访问其所在方法的局部变量时，要求此局部变量必须是 <code>final</code><ol>
<li>因为当调用这个方法时，如果方法中的局部变量不是 <code>final</code> 的，那么方法弹栈此局部变量也就消失了，而此时局部内部类对象可能还存在，就会访问不到此局部变量</li>
<li>JDK 8 可以不加 <code>final</code>，但实际还是 <code>final</code> 的</li>
</ol>
</li>
</ol>
<h5 id="2-非匿名局部内部类（局部内部类）"><a href="#2-非匿名局部内部类（局部内部类）" class="headerlink" title="2 非匿名局部内部类（局部内部类）"></a>2 非匿名局部内部类（局部内部类）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-匿名局部内部类（匿名内部类）"><a href="#3-匿名局部内部类（匿名内部类）" class="headerlink" title="3 匿名局部内部类（匿名内部类）"></a>3 匿名局部内部类（匿名内部类）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> 父类/父接口() &#123;</span><br><span class="line">        重写方法;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-对象实例化过程"><a href="#2-3-对象实例化过程" class="headerlink" title="2.3 对象实例化过程"></a>2.3 对象实例化过程</h2><ol>
<li>加载 class 文件（有父类先加载父类）</li>
<li>静态变量和静态代码块（谁在前谁先执行，只执行一次）</li>
<li>属性默认初始化</li>
<li>构造函数第一行（调用父类构造）</li>
<li>属性显式初始化和构造代码块（谁在前谁先执行，每次创建对象都会执行）</li>
<li>构造函数剩余行</li>
</ol>
<h1 id="三-面向对象特征"><a href="#三-面向对象特征" class="headerlink" title="三 面向对象特征"></a>三 面向对象特征</h1><h2 id="3-1-权限修饰符"><a href="#3-1-权限修饰符" class="headerlink" title="3.1 权限修饰符"></a>3.1 权限修饰符</h2><table>
<thead>
<tr>
<th>修饰符</th>
<th>本类</th>
<th>同一个包(子类+无关类)</th>
<th>不同包(子类)</th>
<th>不同包(无关类)</th>
</tr>
</thead>
<tbody><tr>
<td><code>private</code></td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td><code>default</code></td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td><code>protected</code></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td><code>public</code></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<ol>
<li><p>权限修饰符是用来限定该类实例对象对该类成员的访问权限</p>
</li>
<li><p>在不同包的类中严格来说我认为只能访问 <code>public</code> 修饰的成员，特殊情况是不同包的子类中能使用子类实例访问到父类 <code>protected</code> 修饰的成员（使用父类实例是访问不到的），是因为继承的关系，在自己类中访问自己继承的东西当然可以访问到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在子类 A 中</span></span><br><span class="line"><span class="keyword">this</span>.clone() <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">new</span> A().clone() <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">new</span> Object().clone() <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">new</span> B().clone() <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="3-2-封装（Encapsulation）"><a href="#3-2-封装（Encapsulation）" class="headerlink" title="3.2 封装（Encapsulation）"></a>3.2 封装（<code>Encapsulation</code>）</h2><ol>
<li>封装即隐藏该隐藏的，暴露该暴露的</li>
<li>隐藏对象内部的复杂性，之对外公开简单接口，便于外界调用，提高维护性和扩展性</li>
<li>封装性的体现<ol>
<li><code>private</code> 私有化属性而提供公共的 <code>getter/setter</code> 方法</li>
<li>不对外暴漏的私有方法</li>
<li>单例…</li>
</ol>
</li>
</ol>
<h2 id="3-3-继承（Inheritance）"><a href="#3-3-继承（Inheritance）" class="headerlink" title="3.3 继承（Inheritance）"></a>3.3 继承（<code>Inheritance</code>）</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h3><ul>
<li>好处<ul>
<li>提高代码的复用性</li>
<li>便于功能的扩展</li>
<li>让类与类产生关系，是多态的前提</li>
</ul>
</li>
<li>弊端<ul>
<li>类的耦合性增强了</li>
</ul>
</li>
<li>开发原则：高内聚，低耦合<ul>
<li>耦合：类与类的关系</li>
<li>内聚：自己完成某件事的能力    </li>
</ul>
</li>
</ul>
<h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2 特点"></a>2 特点</h3><ol>
<li>子类会继承父类所有的属性和方法，私有的也会继承，只是不能直接访问</li>
<li>Java 是单继承，一个类只能有一个父类</li>
</ol>
<h3 id="3-重写（Override）"><a href="#3-重写（Override）" class="headerlink" title="3 重写（Override）"></a>3 重写（<code>Override</code>）</h3><ol>
<li>方法名一致</li>
<li>形参列表一致</li>
<li>返回值<ol>
<li>基本数据类型和 <code>void</code>，必须完全一致</li>
<li>引用数据类型，一致或者其子类</li>
</ol>
</li>
<li>权限修饰符<ul>
<li>子类重写方法访问权限不能小于父类方法</li>
</ul>
</li>
<li>异常<ol>
<li>子类重写方法抛出的异常只能是父类方法抛出的异常或者其子类</li>
<li>子类重写方法不能抛出父类方法没有抛出的异常</li>
</ol>
</li>
<li>不能被重写的方法<ol>
<li><code>final</code> 修饰的方法</li>
<li><code>static</code> 修饰的方法</li>
<li>子类不能访问的方法<ol>
<li><code>private</code> 修饰的方法</li>
<li>跨包时默认修饰权限的方法</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="4-类型转换"><a href="#4-类型转换" class="headerlink" title="4 类型转换"></a>4 类型转换</h3><ol>
<li><p>只能在继承层次内进行类型转换</p>
<ol>
<li>向上转型（<code>upcasting</code>）：子类转父类，多态，自动转换</li>
<li>向下转型（<code>downcasting</code>）：父类转子类，强制类型转换</li>
</ol>
</li>
<li><p>强制类型转换前，应使用 <code>instanceof</code> 检查</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x <span class="keyword">instanceof</span> A</span><br><span class="line"><span class="comment">// 判断 x 对象所属类是否是 A 类或 A 类的子类</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="3-4-多态（Polymorphism）"><a href="#3-4-多态（Polymorphism）" class="headerlink" title="3.4 多态（Polymorphism）"></a>3.4 多态（<code>Polymorphism</code>）</h2><h3 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>一个对象变量可以指向多种实际类型的现象称为多态</li>
<li>编译时类型和运行时类型不一致，就出现了多态<ol>
<li>编译时类型由声明时的类型决定</li>
<li>运行时类型由实际对象类型决定</li>
</ol>
</li>
<li>虚拟方法调用：子类中定义了与父类同名同参的方法（重写），多态情况下，将父类方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法，这样的方法调用编译器是无法确定的</li>
<li>在运行时能自动的选择适当的方法称为动态绑定 <code>dynamic binding</code></li>
<li>如果是 <code>private static final</code> 方法或构造器，编译器可以准确的知道调用哪个方法，称为静态绑定 <code>static binding</code></li>
</ol>
<h3 id="2-多态前提"><a href="#2-多态前提" class="headerlink" title="2 多态前提"></a>2 多态前提</h3><ol>
<li>继承或实现</li>
<li>重写</li>
<li>父类引用指向了子类对象</li>
</ol>
<h3 id="3-多态性"><a href="#3-多态性" class="headerlink" title="3 多态性"></a>3 多态性</h3><table>
<thead>
<tr>
<th>成员</th>
<th>多态性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>成员变量（属性）</td>
<td>无</td>
<td>编译运行都看左边</td>
</tr>
<tr>
<td>非静态成员方法</td>
<td>有</td>
<td>编译看左边，运行看右边（动态绑定）</td>
</tr>
<tr>
<td>静态成员方法</td>
<td>无</td>
<td>编译运行都看左边</td>
</tr>
</tbody></table>
<ol>
<li><p>对象的多态性只适用于方法，不适用于属性</p>
</li>
<li><p>非静态成员方法：虚拟方法调用</p>
<ul>
<li>编译时：查看声明类型所属类（父类）是否有此方法，有则编译通过，没有则报错</li>
<li>运行时：查看对象实例所属类（子类）是否有父类中此方法对应的重写方法，有则执行，没有则向上查找</li>
</ul>
</li>
<li><p>例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eatFish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cat cat = <span class="keyword">new</span> SmallCat();</span><br><span class="line">        cat.eatFish(); <span class="comment">// 结果是 "猫吃鱼"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallCat</span> <span class="keyword">extends</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatFish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小猫吃奶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为父类是private，子类访问不到，所以并非是重写</span></span><br><span class="line"><span class="comment">// 成员方法运行时调用的是子类重写方法，没有则会调用父类方法，所以结果是调用的父类方法</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="四-关键字"><a href="#四-关键字" class="headerlink" title="四 关键字"></a>四 关键字</h1><h2 id="4-1-this"><a href="#4-1-this" class="headerlink" title="4.1 this"></a>4.1 this</h2><ol>
<li>方法中：代表调用该方法的对象</li>
<li>构造器中：代表正在初始化的对象</li>
<li>构造器中：调用本类其它构造器</li>
</ol>
<h2 id="4-2-super"><a href="#4-2-super" class="headerlink" title="4.2 super"></a>4.2 super</h2><ol>
<li>构造器或方法中：访问父类属性或方法</li>
<li>构造器中：调用父类构造</li>
</ol>
<h2 id="4-3-static"><a href="#4-3-static" class="headerlink" title="4.3 static"></a>4.3 static</h2><ol>
<li>随着类的加载而加载</li>
<li>优先于对象存在</li>
<li>被类的所有实例共享</li>
<li>直接使用类名调用</li>
<li>静态上下文只能访问静态，不能访问非静态，静态上下文中没有 <code>this super</code></li>
<li>非静态上下文可以访问静态和非静态</li>
</ol>
<h2 id="4-4-final"><a href="#4-4-final" class="headerlink" title="4.4 final"></a>4.4 final</h2><table>
<thead>
<tr>
<th>修饰对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>类</td>
<td>类不能被继承，一个类被声明为 <code>final</code> 则其方法自动变为 <code>final</code></td>
</tr>
<tr>
<td>变量</td>
<td>变量就变成了常量，必须初始化且只能被赋值一次，大写</td>
</tr>
<tr>
<td>方法</td>
<td>方法不能被重写</td>
</tr>
</tbody></table>
<h2 id="4-5-abstract"><a href="#4-5-abstract" class="headerlink" title="4.5 abstract"></a>4.5 abstract</h2><h4 id="1-只能修饰类和方法"><a href="#1-只能修饰类和方法" class="headerlink" title="1 只能修饰类和方法"></a>1 只能修饰类和方法</h4><ol>
<li>抽象类有构造方法，但不能实例化</li>
<li>抽象类可以有抽象方法也可以有一般方法（包括静态和非静态方法）</li>
<li>有抽象方法的一定是抽象类，抽象类不一定有抽象方法</li>
</ol>
<h4 id="2-abstract-不共存的关键字（抽象是为了重写）"><a href="#2-abstract-不共存的关键字（抽象是为了重写）" class="headerlink" title="2 abstract 不共存的关键字（抽象是为了重写）"></a>2 abstract 不共存的关键字（抽象是为了重写）</h4><ol>
<li><code>static</code><ul>
<li>类直接调用一个抽象方法没有意义</li>
</ul>
</li>
<li><code>private</code><ul>
<li><code>private</code> 修饰的方法子类无法访问，也就无法重写，一个不能被重写的抽象方法没有意义</li>
</ul>
</li>
<li><code>final</code><ul>
<li><code>final</code> 修饰的类无法继承，一个不能被继承的抽象类没有意义</li>
<li><code>final</code> 修饰方法无法重写，一个不能被重写的方法没有意义</li>
</ul>
</li>
<li><code>native</code><ul>
<li>因为 <code>native</code> 本身就没有方法体，不明确是什么情况</li>
</ul>
</li>
</ol>
<h2 id="4-6-native"><a href="#4-6-native" class="headerlink" title="4.6 native"></a>4.6 native</h2><ol>
<li><code>native</code> 修饰的方法，看不到方法体，不是 Java 语言实现的，而是调用了底层 C/C++ 的实现，存储在本地方法栈</li>
<li><code>native</code> 方法正常调用即可，且可以重写</li>
</ol>
<h2 id="4-7-包"><a href="#4-7-包" class="headerlink" title="4.7 包"></a>4.7 包</h2><h3 id="1-package"><a href="#1-package" class="headerlink" title="1 package"></a>1 package</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> x.x.x;</span><br></pre></td></tr></table></figure>

<ol>
<li>同一个包下类/接口不能重名</li>
<li>用于控制访问权限</li>
<li>用于划分项目的结构层次，通常将功能相近的类划分到同一个包中</li>
</ol>
<h3 id="2-import"><a href="#2-import" class="headerlink" title="2 import"></a>2 import</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*</span><br><span class="line">import static java.util.Math.*;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果在源文件中，使用了不同包下的同名的类，则只有一个可以导入，其它需要使用全类名的方式</li>
<li><code>xxx.*</code> 表示可以使用 <code>xxx</code> 包下的所有结构，但其子包下还需要导入</li>
</ol>
<h3 id="3-JDK-主要包说明"><a href="#3-JDK-主要包说明" class="headerlink" title="3 JDK 主要包说明"></a>3 JDK 主要包说明</h3><table>
<thead>
<tr>
<th>包</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>java.lang</code></td>
<td>Java语言的核心类/接口</td>
</tr>
<tr>
<td><code>java.io</code></td>
<td>IO 功能相关类/接口</td>
</tr>
<tr>
<td><code>java.net</code></td>
<td>网络相关类/接口</td>
</tr>
<tr>
<td><code>java.util</code></td>
<td>实用工具类</td>
</tr>
<tr>
<td><code>java.text</code></td>
<td>格式化相关的类</td>
</tr>
<tr>
<td><code>java.sql</code></td>
<td>JDBC数据库编程的相关类/接口</td>
</tr>
<tr>
<td><code>java.awt</code></td>
<td>GUI 相关</td>
</tr>
<tr>
<td><code>java.applet</code></td>
<td>applet 运行所需的类</td>
</tr>
</tbody></table>
<h1 id="五-main-方法说明"><a href="#五-main-方法说明" class="headerlink" title="五 main() 方法说明"></a>五 <code>main()</code> 方法说明</h1><ol>
<li>作为程序的入口</li>
<li>可以当作普通的静态方法</li>
<li><code>String[] args</code> 可以用来接收控制台参数（以空格隔开）</li>
</ol>
<h1 id="六-接口-Interface"><a href="#六-接口-Interface" class="headerlink" title="六 接口 Interface"></a>六 接口 <code>Interface</code></h1><h2 id="6-1-语法"><a href="#6-1-语法" class="headerlink" title="6.1 语法"></a>6.1 语法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">interface</span> 接口名 </span>&#123;</span><br><span class="line">	接口属性列表;</span><br><span class="line">	接口方法列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>接口没有构造器，不能创建对象</li>
<li>类可以多实现，接口可以继承接口</li>
<li>接口实现类必须实现所有的接口方法，否则仍是抽象类</li>
</ol>
<h2 id="6-2-成员"><a href="#6-2-成员" class="headerlink" title="6.2 成员"></a>6.2 成员</h2><table>
<thead>
<tr>
<th>接口成员</th>
<th>修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>全局常量</td>
<td><code>public static final</code></td>
<td>修饰符可以省略</td>
</tr>
<tr>
<td>抽象方法</td>
<td><code>public abstract</code></td>
<td>修饰符可以省略</td>
</tr>
<tr>
<td>静态方法</td>
<td><code>public static</code></td>
<td><code>public</code> 可以省略</td>
</tr>
<tr>
<td>默认方法</td>
<td><code>public default</code></td>
<td><code>public</code> 可以省略</td>
</tr>
<tr>
<td>私有方法</td>
<td><code>private</code></td>
<td>修饰符不能省略</td>
</tr>
</tbody></table>
<ol>
<li>JDK 8 以后接口为何新增静态方法?<ol>
<li>因为一般工具类中都是静态方法，而这些静态方法通常都是为某个接口服务的，如 <code>Collection Collections</code></li>
<li>把静态方法直接定义在接口中，可以避免增加额外的工具类</li>
</ol>
</li>
<li>JDK 8 以后接口为何新增默认方法?<ol>
<li>因为有时候，一个接口的多数实现类对接口的抽象方法的实现是一样的</li>
<li>把这样的抽象方法定义为默认方法，可以减少实现类的重复工作</li>
<li>如果实现类实现多个接口，出现了默认方法冲突（会报错）<ol>
<li>从其中选择一个，重写默认方法（去掉 <code>default</code>）</li>
<li>都不用，重写默认方法（去掉 <code>default</code>）</li>
</ol>
</li>
<li>如果实现类继承父类实现接口，出现了默认方法冲突（不会报错）<ol>
<li>默认使用父类</li>
<li>手动改选接口</li>
<li>完全重写</li>
</ol>
</li>
</ol>
</li>
<li>Java 9 中 接口中可以有 <code>private</code> 方法</li>
</ol>
<h1 id="七-枚举-Enum"><a href="#七-枚举-Enum" class="headerlink" title="七 枚举 Enum"></a>七 枚举 <code>Enum</code></h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ol>
<li>类的对象只有确定的有限个</li>
<li>枚举即将其所有可用对象直接在内部列出来</li>
<li>枚举不需要创建对象，构造函数默认即为私有的</li>
<li>当需要定义一组常量时，强烈建议使用枚举类</li>
<li>枚举也可以实现接口</li>
</ol>
<h2 id="7-2-自定义枚举"><a href="#7-2-自定义枚举" class="headerlink" title="7.2 自定义枚举"></a>7.2 自定义枚举</h2><h3 id="1-手动实现枚举（JDK5-之前）"><a href="#1-手动实现枚举（JDK5-之前）" class="headerlink" title="1 手动实现枚举（JDK5 之前）"></a>1 手动实现枚举（<code>JDK5</code> 之前）</h3><ol>
<li>私有化构造函数</li>
<li>在类中创建所有可用的实例对象，定义为公有静态常量 <code>public static final</code></li>
</ol>
<h3 id="2-enum-关键字"><a href="#2-enum-关键字" class="headerlink" title="2 enum 关键字"></a>2 <code>enum</code> 关键字</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">enum</span> 枚举类名 &#123;</span><br><span class="line">	枚举项列表;</span><br><span class="line">	其它成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>默认继承 <code>java.lang.Enum</code> </p>
</li>
<li><p>枚举项必须定义在首行，以逗号分隔，最后一个以分号结束</p>
</li>
<li><p>枚举项即为枚举类的实例</p>
<ol>
<li><p>构造函数有参数，枚举项也要有参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Week&#123;</span><br><span class="line">	MON(<span class="string">"星期一"</span>),TUS(<span class="string">"星期二"</span>),SUN(<span class="string">"星期日"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举类有抽象方法，枚举项也要实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Week &#123;</span><br><span class="line">	Mon(<span class="string">"星期一"</span>)&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h2 id="7-3-java-lang-Enum"><a href="#7-3-java-lang-Enum" class="headerlink" title="7.3 java.lang.Enum"></a>7.3 <code>java.lang.Enum</code></h2><h3 id="1-构造"><a href="#1-构造" class="headerlink" title="1 构造"></a>1 构造</h3><table>
<thead>
<tr>
<th>构造</th>
</tr>
</thead>
<tbody><tr>
<td><code>protected Enum(String name, int ordinal)</code></td>
</tr>
</tbody></table>
<ol>
<li>此构造方法不是程序员调用的，而是由编译器调用的</li>
<li>所以不能在枚举类中手动调用父类构造</li>
</ol>
<h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2 方法"></a>2 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>toString()</code></td>
<td>返回此枚举项的名称</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>ordinal()</code></td>
<td>返回枚举项的编号</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>name()</code></td>
<td>返回此枚举项的名称</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>compareTo(E o)</code></td>
<td>比较枚举项的编号</td>
</tr>
<tr>
<td><code>static &lt;T extends Enum&lt;T&gt;&gt;</code></td>
<td><code>valueOf(Class&lt;T&gt; enumType, String name)</code></td>
<td>返回指定类型中指定名称的枚举项</td>
</tr>
<tr>
<td><code>static T[]</code></td>
<td><code>values()</code></td>
<td><code>Enum</code> 没有，所有枚举类都有，获取所有枚举项</td>
</tr>
<tr>
<td><code>static T</code></td>
<td><code>valueOf(String name)</code></td>
<td><code>Enum</code> 没有，所有枚举类都有，返回指定名称的枚举项</td>
</tr>
</tbody></table>
<h1 id="八-注解-Annotation"><a href="#八-注解-Annotation" class="headerlink" title="八 注解 Annotation"></a>八 注解 <code>Annotation</code></h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><ol>
<li>注解是针对程序的注释，是给程序看的，用于描述程序如何运行及在什么阶段来运行。</li>
<li>注解在实际开发中，最大的功能是用于替换配置文件</li>
<li>一个完整的注解由三部分组成<ol>
<li>声明</li>
<li>使用</li>
<li>读取</li>
</ol>
</li>
<li>Java 把枚举看作类，把注解看作接口</li>
<li>所有注解都继承了 <code>java.lang.annotation.Annotation</code></li>
</ol>
<h2 id="8-2-JDK-中三个基本注解"><a href="#8-2-JDK-中三个基本注解" class="headerlink" title="8.2 JDK 中三个基本注解"></a>8.2 JDK 中三个基本注解</h2><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Override</code></td>
<td>检查重写方法是否合法</td>
</tr>
<tr>
<td><code>@Deprecated</code></td>
<td>表示已过时</td>
</tr>
<tr>
<td><code>@SuppressWarnings({警告类型列表/all})</code></td>
<td>抑制警告</td>
</tr>
</tbody></table>
<h2 id="8-3-文档注释相关注解"><a href="#8-3-文档注释相关注解" class="headerlink" title="8.3 文档注释相关注解"></a>8.3 文档注释相关注解</h2><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
<th>格式</th>
</tr>
</thead>
<tbody><tr>
<td><code>@author</code></td>
<td>作者</td>
<td><code>@author 作者名</code></td>
</tr>
<tr>
<td><code>@version</code></td>
<td>版本</td>
<td><code>@version 1.0</code></td>
</tr>
<tr>
<td><code>@see</code></td>
<td>另请参阅</td>
<td><code>@see 另请参阅信息</code></td>
</tr>
<tr>
<td><code>@since</code></td>
<td>从 xx 版本开始引入</td>
<td><code>@since xx</code></td>
</tr>
<tr>
<td><code>@param</code></td>
<td>参数信息，一对一</td>
<td><code>@param 形参名 形参类型 注释</code></td>
</tr>
<tr>
<td><code>@return</code></td>
<td>返回值信息</td>
<td><code>@return 返回值类型 注释</code></td>
</tr>
<tr>
<td><code>@throws</code></td>
<td>抛出异常信息</td>
<td><code>@throws 异常类型 注释</code></td>
</tr>
</tbody></table>
<h2 id="8-4-自定义注解"><a href="#8-4-自定义注解" class="headerlink" title="8.4 自定义注解"></a>8.4 自定义注解</h2><h3 id="1-声明"><a href="#1-声明" class="headerlink" title="1 声明"></a>1 声明</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">	数据类型 属性名(); <span class="comment">// 注解的属性类似方法</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>; </span><br><span class="line">	<span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "haha"</span>; <span class="comment">// 可以设置默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>注解数据类型<ol>
<li>八种基本数据类型</li>
<li><code>String</code> 类型</li>
<li><code>enum</code> 枚举类型</li>
<li><code>Annotation</code> 注解类型</li>
<li><code>Class</code> 类型</li>
<li>以上类型的一维数组类型</li>
</ol>
</li>
<li>如果注解没有成员，通常是标识作用</li>
<li>如果注解只有一个成员，建议属性名 <code>value</code></li>
</ol>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Xxx</span>(name=<span class="string">""</span>) <span class="comment">//非数组类型注解赋值</span></span><br><span class="line"><span class="meta">@Xxx</span>(name=&#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>&#125;) <span class="comment">// 数组类型注解赋值</span></span><br></pre></td></tr></table></figure>

<ol>
<li>使用注解时注解中的所有属性都要赋值，有默认值的可以省略使用默认值</li>
<li>如果使用注解时最终配置的属性只有一个 <code>value</code>，则可以省略属性名</li>
</ol>
<h3 id="3-读取"><a href="#3-读取" class="headerlink" title="3 读取"></a>3 读取</h3><ul>
<li>使用<strong>反射</strong>读取注解</li>
</ul>
<h2 id="8-5-元注解（用在注解上的注解）"><a href="#8-5-元注解（用在注解上的注解）" class="headerlink" title="8.5 元注解（用在注解上的注解）"></a>8.5 元注解（用在注解上的注解）</h2><table>
<thead>
<tr>
<th>元注解</th>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>@target</code></td>
<td><code>@target(ElementType.xxx)</code></td>
<td>标记此注解的使用位置</td>
</tr>
<tr>
<td><code>@Retention</code></td>
<td><code>@Retention(RetentionPolicy.xxx)</code></td>
<td>标记此注解的生命周期</td>
</tr>
<tr>
<td><code>@Documented</code></td>
<td><code>@Documented</code></td>
<td>标记此注解可以被 <code>javadoc.exe</code> 读取到 API</td>
</tr>
<tr>
<td><code>@Inherited</code></td>
<td><code>@Inherited</code></td>
<td>标记此注解可以被子类继承</td>
</tr>
</tbody></table>
<h3 id="1-ElementType"><a href="#1-ElementType" class="headerlink" title="1 ElementType"></a>1 <code>ElementType</code></h3><ul>
<li>是一个枚举类，用于枚举注解使用的位置</li>
</ul>
<table>
<thead>
<tr>
<th>枚举项</th>
<th>使用位置</th>
</tr>
</thead>
<tbody><tr>
<td><code>TYPE</code></td>
<td>类，接口（包括注解）或枚举</td>
</tr>
<tr>
<td><code>FIELD</code></td>
<td>属性</td>
</tr>
<tr>
<td><code>METHOD</code></td>
<td>方法</td>
</tr>
<tr>
<td><code>PARAMETER</code></td>
<td>形参</td>
</tr>
<tr>
<td><code>CONSTRUCTOR</code></td>
<td>构造函数</td>
</tr>
<tr>
<td><code>LOCAL_VARIABLE</code></td>
<td>局部变量</td>
</tr>
<tr>
<td><code>ANNOTATION_TYPE</code></td>
<td>注解</td>
</tr>
<tr>
<td><code>PACKAGE</code></td>
<td>包</td>
</tr>
<tr>
<td><code>TYPE_PARAMETER</code></td>
<td>类型变量的声明语句（如泛型声明）</td>
</tr>
<tr>
<td><code>TYPE_USE</code></td>
<td>使用类型的任何语句</td>
</tr>
</tbody></table>
<h3 id="2-RetentionPolicy"><a href="#2-RetentionPolicy" class="headerlink" title="2 RetentionPolicy"></a>2 <code>RetentionPolicy</code></h3><ul>
<li>是一个枚举类，用于枚举注解的存活阶段</li>
</ul>
<table>
<thead>
<tr>
<th>枚举项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>SOURCE</code></td>
<td>源代码阶段有效（即<code>.java</code>源文件保留），会被编译器舍弃，即编译后的字节码文件不保留</td>
</tr>
<tr>
<td><code>CLASS</code>（默认）</td>
<td>字节码阶段有效（即 <code>.class</code> 文件保留），运行时不会保留</td>
</tr>
<tr>
<td><code>RUNTIME</code></td>
<td>运行阶段有效（即运行时保留），可通过反射获取</td>
</tr>
</tbody></table>
<h2 id="8-6-JDK8-新特新"><a href="#8-6-JDK8-新特新" class="headerlink" title="8.6 JDK8 新特新"></a>8.6 JDK8 新特新</h2><ol>
<li>可重复注解 <code>@Repeatable</code></li>
<li>类型注解</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java-语法</title>
    <url>/anyeansan.github.io/2020/09/29/Java/Java-%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/java.png" alt=""></p>
<table>
<thead>
<tr>
<th>术语</th>
<th>缩写</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Java Development Kit</code></td>
<td><code>JDK</code></td>
<td>Java 开发工具包，编写 Java 程序的程序员使用的软件</td>
</tr>
<tr>
<td><code>Java Runtime Environment</code></td>
<td><code>JRE</code></td>
<td>Java 运行时环境，运行 Java 程序的用户使用的软件</td>
</tr>
<tr>
<td><code>Standard Edition</code></td>
<td><code>SE</code></td>
<td>标准版，用于桌面或简单服务器应用的 Java 平台</td>
</tr>
<tr>
<td><code>Enterprise Edition</code></td>
<td><code>EE</code></td>
<td>企业版，用于复杂服务器应用的 Java 平台</td>
</tr>
<tr>
<td><code>Micro Edition</code></td>
<td><code>ME</code></td>
<td>微型版，用于小型设备的 Java 平台</td>
</tr>
<tr>
<td><code>Java Virtual Machine</code></td>
<td><code>JVM</code></td>
<td>Java 虚拟机，Java 程序运行在虚拟机上而非操作系统上</td>
</tr>
<tr>
<td><code>Oracle JDK</code></td>
<td><code>-</code></td>
<td>官方 <code>Java SE</code></td>
</tr>
<tr>
<td><code>Open JDK</code></td>
<td><code>-</code></td>
<td><code>Java SE</code> 的一个免费开源实现</td>
</tr>
<tr>
<td><code>Software Development Kit</code></td>
<td><code>SDK</code></td>
<td>过时，用于描述 1998 ~ 2006 年之间的 JDK</td>
</tr>
<tr>
<td><code>NetBeans</code></td>
<td><code>-</code></td>
<td>Oracle 公司的集成开发环境</td>
</tr>
<tr>
<td><code>path</code></td>
<td><code>-</code></td>
<td>为了在任意地方使用所配置路径下的命令</td>
</tr>
<tr>
<td><code>classpath</code></td>
<td><code>-</code></td>
<td>寻找 <code>.class</code> 文件的路径</td>
</tr>
</tbody></table>
<h2 id="1-2-编译-amp-运行"><a href="#1-2-编译-amp-运行" class="headerlink" title="1.2 编译 &amp; 运行"></a>1.2 编译 &amp; 运行</h2><h3 id="1-编译"><a href="#1-编译" class="headerlink" title="1 编译"></a>1 编译</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac a/b/c/test.java</span><br></pre></td></tr></table></figure>

<ul>
<li>执行 <code>javac.exe</code> 命令所在的目录 + 输入的 <code>.java</code> 文件路径 = <code>.java</code> 文件绝对路径</li>
<li><code>.java</code> 文件可以有多个类，但只能有零或一个 <code>public</code> 类且必须与文件名相同</li>
</ul>
<h3 id="2-运行"><a href="#2-运行" class="headerlink" title="2 运行"></a>2 运行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java 字节码文件名</span><br></pre></td></tr></table></figure>

<ul>
<li>必须在类的全限定名所在的路径下执行 <code>java.exe</code> 命令，因为 <code>classpath</code> 不设置时，默认在当前路径寻找 <code>.class</code> 文件</li>
</ul>
<h1 id="二-注释"><a href="#二-注释" class="headerlink" title="二 注释"></a>二 注释</h1><h2 id="2-1-单行注释"><a href="#2-1-单行注释" class="headerlink" title="2.1 单行注释"></a>2.1 单行注释</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-多行注释"><a href="#2-2-多行注释" class="headerlink" title="2.2 多行注释"></a>2.2 多行注释</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 多行注释禁止嵌套</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-文档注释"><a href="#2-3-文档注释" class="headerlink" title="2.3 文档注释"></a>2.3 文档注释</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 作者</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> 另请参阅</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 从 xxx 版本开始引入</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> 参数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 返回值</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> 异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成文档</span></span><br><span class="line">javadoc -d 文件夹名称 -encoding UTF-<span class="number">8</span> -charset UTF-<span class="number">8</span> -author -version xxx.java</span><br></pre></td></tr></table></figure>

<h1 id="三-标识符"><a href="#三-标识符" class="headerlink" title="三 标识符"></a>三 标识符</h1><h2 id="3-1-定义规则"><a href="#3-1-定义规则" class="headerlink" title="3.1 定义规则"></a>3.1 定义规则</h2><ol>
<li>合法字符<ul>
<li><code>A~Za~z</code></li>
<li><code>0~9</code></li>
<li><code>_</code></li>
<li><code>$</code></li>
</ul>
</li>
<li>不能以数字开头，不能使用空格</li>
<li>不能使用关键字和保留字，但可以包含</li>
<li>严格区分大小写，长度无限制</li>
</ol>
<h2 id="3-2-命名规范"><a href="#3-2-命名规范" class="headerlink" title="3.2 命名规范"></a>3.2 命名规范</h2><table>
<thead>
<tr>
<th>对象</th>
<th>规范</th>
</tr>
</thead>
<tbody><tr>
<td><code>包名</code></td>
<td>所有单词小写</td>
</tr>
<tr>
<td><code>类名, 接口名</code></td>
<td>所有单词的首字母大写</td>
</tr>
<tr>
<td><code>变量名, 方法名</code></td>
<td>第一个单词首字母小写，后边首字母大写</td>
</tr>
<tr>
<td><code>常量名</code></td>
<td>所有单词大写，单词之间使用 <code>_</code> 连接</td>
</tr>
</tbody></table>
<h1 id="四-数据类型"><a href="#四-数据类型" class="headerlink" title="四 数据类型"></a>四 数据类型</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt=""></p>
<h2 id="4-2-基本数据类型"><a href="#4-2-基本数据类型" class="headerlink" title="4.2 基本数据类型"></a>4.2 基本数据类型</h2><h3 id="1-整型"><a href="#1-整型" class="headerlink" title="1 整型"></a>1 整型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>无符号范围</th>
<th>有符号范围</th>
<th>默认初始值</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte</code></td>
<td>1 字节</td>
<td><code>0 ~ 255</code></td>
<td><code>-128 ~ 127</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>short</code></td>
<td>2 字节</td>
<td><code>0 ~ 65535</code></td>
<td><code>-2<sup>15</sup> ~ 2<sup>15</sup>-1</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>int（默认）</code></td>
<td>4 字节</td>
<td><code>0 ~ 2<sup>32</sup>-1</code></td>
<td><code>-2<sup>31</sup> ~ 2<sup>31</sup>-1</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>long</code></td>
<td>8 字节</td>
<td><code>0 ~ 2<sup>64</sup>-1</code></td>
<td><code>-2<sup>63</sup> ~ 2<sup>63</sup>-1</code></td>
<td><code>0L</code></td>
</tr>
</tbody></table>
<ol>
<li><p>Java 都是有符号的，整形默认为 <code>int</code>，<code>long</code> 类型声明时需要加 <code>l</code> 或 <code>L</code></p>
</li>
<li><p>长度计算公式（n 为字节数）</p>
<ul>
<li><p>有符号：-2<sup>8n-1</sup>~ 2<sup>8n-1</sup>-1</p>
</li>
<li><p>无符号：0~2<sup>8n</sup>-1</p>
</li>
</ul>
</li>
<li><p>进制表示：</p>
<ul>
<li>二进制：<code>0b</code> 开头</li>
<li>八进制：<code>0</code> 开头</li>
<li>十进制：<code>0x</code> 开头</li>
</ul>
</li>
<li><p>数字字面量可添加下划线，为了可读性，编译器会自动去除</p>
<ul>
<li><code>10_000_000</code></li>
</ul>
</li>
<li><p>常量优化机制：Java 中整数默认为 <code>int</code> 型，当把整数值赋值给非 <code>int</code> 的整型时，<code>JVM</code> 会判断整数值是否超过此类型的范围</p>
<ol>
<li>没有超过，则自动进行隐式转换，如 <code>byte b = 127</code></li>
<li>超过，则报错，如 <code>byte b = 128</code></li>
</ol>
</li>
</ol>
<h3 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="2 浮点型"></a>2 浮点型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>默认初始值</th>
</tr>
</thead>
<tbody><tr>
<td><code>float</code></td>
<td>4 字节</td>
<td><code>0.0F</code></td>
</tr>
<tr>
<td><code>double（默认）</code></td>
<td>8 字节</td>
<td><code>0.0D</code></td>
</tr>
</tbody></table>
<ol>
<li>浮点型默认为 <code>double</code> ，<code>float</code> 类型声明时需要加 <code>f</code> 或 <code>F</code></li>
<li>浮点型常量有两种表示形式<ul>
<li>十进制数形式，如 <code>3.14 3.14F .314</code></li>
<li>科学计数法形式，如 <code>3.14e2 314E2 100E-2</code></li>
</ul>
</li>
</ol>
<h3 id="3-布尔型"><a href="#3-布尔型" class="headerlink" title="3 布尔型"></a>3 布尔型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>取值</th>
<th>默认初始值</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>true false</code></td>
<td><code>false</code></td>
</tr>
</tbody></table>
<h3 id="4-字符型"><a href="#4-字符型" class="headerlink" title="4 字符型"></a>4 字符型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>范围</th>
<th>默认初始值</th>
</tr>
</thead>
<tbody><tr>
<td><code>char</code></td>
<td>2 字节</td>
<td><code>\u0000 ~ \uffff</code>（ <code>0 ~ 65535</code> ）</td>
<td><code>\u0000</code>（空）</td>
</tr>
</tbody></table>
<ol>
<li>字符型：由单引号包裹的<strong>单个</strong>字符（汉字、字母、数字、符号）<ul>
<li><code>&#39;&#39;</code>：错误，不能是空单引号 </li>
<li><code>&#39; &#39;</code>：正确，空格字符</li>
</ul>
</li>
<li>字符型三种表现形式<ul>
<li>单引号包裹的单个字符</li>
<li>转义符转义的特殊字符，如 <code>&#39;\n&#39;</code></li>
<li>Unicode 值</li>
</ul>
</li>
<li>Java 中字符使用 <code>Unicode</code> 字符集，编码规则为 <code>UTF-16</code> ，表示形式为 <code>\u0000</code>：<ul>
<li><code>\u</code>：转义序列，表示是 <code>Unicode</code></li>
<li><code>0000</code>：字符在 <code>Unicode</code> 中的码点对应的十六进制数</li>
</ul>
</li>
</ol>
<h2 id="4-3-基本数据类型转换"><a href="#4-3-基本数据类型转换" class="headerlink" title="4.3 基本数据类型转换"></a>4.3 基本数据类型转换</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" alt=""></p>
<ol>
<li>自动类型转换（隐式转换）：<code>低容量类型 → 高容量类型</code></li>
<li>强制类型转换：<code>高容量类型 → 低容量类型</code>，可能损失精度</li>
<li><code>boolean</code> 类型与其他基本类型不能进行类型转换</li>
<li>运算时，会先将两个操作数转为同一类型<ol>
<li><code>byte short char</code> 都会先转为 <code>int</code></li>
<li><code>int → long → float → double</code>：碰到靠右的则先转为其类型</li>
</ol>
</li>
</ol>
<h2 id="4-4-大数"><a href="#4-4-大数" class="headerlink" title="4.4 大数"></a>4.4 大数</h2><ol>
<li><p>如果基本整数和浮点数精度不满足需求，可以使用 <code>java.math</code> 包下的类</p>
<ol>
<li><code>BigInteger</code>：可以实现任意精度的整数运算</li>
<li><code>BigDecimal</code>：可以实现任意精度的浮点数运算</li>
</ol>
</li>
<li><p>将数值转为大数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger.valueOf(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">new</span> BigInteger(String num)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="4-5-字符串"><a href="#4-5-字符串" class="headerlink" title="4.5 字符串"></a>4.5 字符串</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>Java 字符串即 <code>Unicode</code> 字符序列，如 <code>&quot;Java\u5B89&quot;</code> 由 5 个 <code>Unicode</code> 字符组成 <code>J a v a 安</code></li>
<li>字符串：由双引号包裹的 0 到 多个字符</li>
<li>每个字符串都是 <code>java.lang.String</code> 的一个实例</li>
</ol>
<h3 id="2-字符串常量池"><a href="#2-字符串常量池" class="headerlink" title="2 字符串常量池"></a>2 字符串常量池</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>字符串常量池中不会存储相同内容的字符串</li>
<li><code>String pool</code> 是一个固定大小的 <code>Hashtable</code>，可通过 <code>-XX:StringTableSize</code> 设置长度<ol>
<li><code>JDK6</code> 默认长度是 <code>1009</code>，设置无要求</li>
<li><code>JDK7</code> 默认长度是 <code>60013</code>，设置无要求</li>
<li><code>JDK8</code> 开始默认长度是 <code>60013</code>，<code>1009</code> 是可设置的最小长度</li>
</ol>
</li>
</ol>
<h4 id="2-创建字符串"><a href="#2-创建字符串" class="headerlink" title="2 创建字符串"></a>2 创建字符串</h4><ol>
<li>字面量<ul>
<li>字符串存储在常量池中</li>
</ul>
</li>
<li><code>new</code><ol>
<li><code>new String(&quot;a&quot;)</code><ul>
<li>对象1：<code>new String(&quot;a&quot;)</code></li>
<li>对象2：常量池中的 <code>&quot;a&quot;</code></li>
</ul>
</li>
<li><code>new String(&quot;a&quot;) + new String(&quot;b&quot;)</code><ul>
<li>对象1：<code>new StringBuilder()</code></li>
<li>对象2：<code>new String(&quot;a&quot;)</code></li>
<li>对象3：常量池中的 <code>&quot;a&quot;</code></li>
<li>对象4：<code>new String(&quot;b&quot;)</code></li>
<li>对象5：常量池中的 <code>&quot;b&quot;</code></li>
<li>对象6：<code>new String(&quot;ab&quot;)</code><ol>
<li><code>StringBuilder.toString()</code> 的底层实际是 <code>new</code> 了一个字符串</li>
<li>注意：<code>&quot;ab&quot;</code> 并不会存入常量池中</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><code>String</code> 类的 <code>intern()</code><ol>
<li>当调用的字符串在字符串常量池中已存在，则直接返回池中对象的地址引用</li>
<li>当调用的字符串在字符串常量池中不存在<ol>
<li><code>JDK6</code> 会复制一个新的字符串对象放入常量池中，并返回池中对象的地址引用</li>
<li><code>JDK7</code> 及以后，会将此字符串的地址放入常量池中，并返回池中对象的地址引用</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="3-拼接字符串"><a href="#3-拼接字符串" class="headerlink" title="3 拼接字符串"></a>3 拼接字符串</h4><ol>
<li>常量和常量拼接结果在常量池，原理是编译器优化</li>
<li>如果拼接中出现了变量，则相当于在堆中 <code>new String()</code>，结果就在堆中，原理是 <code>StringBuilder</code></li>
</ol>
<h3 id="3-java-lang-String"><a href="#3-java-lang-String" class="headerlink" title="3 java.lang.String"></a>3 <code>java.lang.String</code></h3><ol>
<li><p>不可变（immutable）的字符序列</p>
<ol>
<li><p>不可变性：指对字符串重新赋值，连接，替换等操作时，都不会改变原有字符串序列，就好比 3 永远是 3，”hello” 永远是 “hello”</p>
</li>
<li><p>对字符串的改变，其实是将变量指向了另一个字符串，而非改变原有字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s = &quot;hello&quot;;</span><br><span class="line">s = &quot;hehe&quot;;</span><br><span class="line">// 改变了 s 的指向，而非改变字符串 &quot;hello&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不可变的优点：可以共享</p>
</li>
</ol>
</li>
<li><p><code>String</code> 类在<code>JDK8</code> 及之前内部定义了 <code>char[]</code> 用来存储数据，从 <code>JDK9</code> 开始：</p>
<ol>
<li>字符串全为单字节字符则使用 <code>byte[]</code> 实现，否则使用 <code>char[]</code> 实现</li>
<li>因为字符串实际使用的大部分字符只占一个字节，使用字符数组就占用了两个字节，浪费空间</li>
</ol>
</li>
</ol>
<h2 id="4-6-数组"><a href="#4-6-数组" class="headerlink" title="4.6 数组"></a>4.6 数组</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>数组是多个相同类型数据按一定顺序排列的集合</li>
<li>数组既可以存基本数据类型，也可以存引用数据类型</li>
<li>数组长度一旦确定，就不能修改</li>
<li>数组相关概念<ul>
<li>数组名</li>
<li>元素 <code>element</code>：数组中的每个数据</li>
<li>索引（角标/下标）<code>index</code>：从 0 开始</li>
<li>长度 <code>lenght</code>：数组中元素个数称为数组的元素</li>
</ul>
</li>
<li>数组的存储<ol>
<li>数组会在内存中（堆）开辟一块连续的空间，数组名引用的是这块连续空间的首地址</li>
<li>下标表示此元素距离首地址的偏移量</li>
</ol>
</li>
</ol>
<h3 id="2-声明数组"><a href="#2-声明数组" class="headerlink" title="2 声明数组"></a>2 声明数组</h3><h4 id="1-一维数组"><a href="#1-一维数组" class="headerlink" title="1 一维数组"></a>1 一维数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 静态初始化：数组的初始化和元素赋值同时进行</span></span><br><span class="line"><span class="comment">// 1.1</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.2</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 动态初始化：数组的初始化和元素赋值分别进行</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-多维数组"><a href="#2-多维数组" class="headerlink" title="2 多维数组"></a>2 多维数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 静态初始化</span></span><br><span class="line"><span class="comment">// 1.1</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">3</span>, <span class="number">6</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.2</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = &#123;&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">3</span>, <span class="number">6</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 动态初始化</span></span><br><span class="line"><span class="comment">// 2.1 二维数组中有 3 个元素（每个元素都是一维数组），每个一维数组中有 4 个元素，这种方式一维数组元素个数都一样</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.2 二维数组中有 3 个元素，没有指定一维数组中元素的个数，可以分别指定，这种方式一维数组元素个数可以不一样</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][]</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]</span><br><span class="line">arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h3 id="3-数组默认值"><a href="#3-数组默认值" class="headerlink" title="3 数组默认值"></a>3 数组默认值</h3><h4 id="1-一维数组-1"><a href="#1-一维数组-1" class="headerlink" title="1 一维数组"></a>1 一维数组</h4><table>
<thead>
<tr>
<th>元素类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte short int long</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>char</code></td>
<td><code>0</code> 或 <code>\u0000</code>，并非是 <code>&#39;0&#39;</code></td>
</tr>
<tr>
<td><code>float double</code></td>
<td><code>0.0</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>false</code></td>
</tr>
<tr>
<td>引用类型</td>
<td><code>null</code></td>
</tr>
</tbody></table>
<h4 id="2-二维数组"><a href="#2-二维数组" class="headerlink" title="2 二维数组"></a>2 二维数组</h4><ul>
<li><code>int[][] arr = new int[3][4]</code><ul>
<li>外层初始值为内层数组元素的地址值</li>
<li>内层初始值为对应类型的初始值</li>
</ul>
</li>
<li><code>int[][] arr = new int[3][]</code><ul>
<li>外层初始值为 <code>null</code></li>
<li>内层还没有元素</li>
</ul>
</li>
</ul>
<h1 id="五-运算"><a href="#五-运算" class="headerlink" title="五 运算"></a>五 运算</h1><h2 id="5-1-运算符"><a href="#5-1-运算符" class="headerlink" title="5.1 运算符"></a>5.1 运算符</h2><h3 id="1-赋值运算符"><a href="#1-赋值运算符" class="headerlink" title="1 赋值运算符"></a>1 赋值运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
<th>等价于</th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td>赋值</td>
<td><code>x = y</code></td>
<td><code>x = y</code></td>
</tr>
<tr>
<td><code>+=</code></td>
<td>加赋值</td>
<td><code>x += y</code></td>
<td><code>x = x + y</code></td>
</tr>
<tr>
<td><code>-=</code></td>
<td>减赋值</td>
<td><code>x -= y</code></td>
<td><code>x = x - y</code></td>
</tr>
<tr>
<td><code>*=</code></td>
<td>乘赋值</td>
<td><code>x *= y</code></td>
<td><code>x = x * y</code></td>
</tr>
<tr>
<td><code>/=</code></td>
<td>除赋值</td>
<td><code>x /= y</code></td>
<td><code>x = x / y</code></td>
</tr>
<tr>
<td><code>%=</code></td>
<td>模赋值</td>
<td><code>x %= y</code></td>
<td><code>x = x % y</code></td>
</tr>
</tbody></table>
<ul>
<li><p>支持连续赋值</p>
</li>
<li><p>在使用扩展赋值运算符（非 <code>=</code>）时，不会改变变量的数据类型，即会把结果强制转换为变量的类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 ----------------------------------</span></span><br><span class="line"><span class="keyword">short</span> s = <span class="number">3</span>;</span><br><span class="line">s += <span class="number">1</span>;  <span class="comment">// 结果是 4</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">s = (<span class="keyword">short</span>)(s + <span class="number">1</span>); </span><br><span class="line"><span class="comment">// 2 ----------------------------------</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">i *= <span class="number">0.1</span>; <span class="comment">// 结果是 0</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">i = (<span class="keyword">int</span>)(i * <span class="number">0.1</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-算术运算符"><a href="#2-算术运算符" class="headerlink" title="2 算术运算符"></a>2 算术运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>加法</td>
<td><code>x + y</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td>减法</td>
<td><code>x - y</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘法</td>
<td><code>x * y</code></td>
</tr>
<tr>
<td><code>/</code></td>
<td>除法</td>
<td><code>x / y</code></td>
</tr>
<tr>
<td><code>%</code></td>
<td>取模</td>
<td><code>x % y</code></td>
</tr>
<tr>
<td><code>++</code></td>
<td>自增</td>
<td><code>x++</code> 或 <code>++x</code></td>
</tr>
<tr>
<td><code>--</code></td>
<td>自减</td>
<td><code>x--</code> 或 <code>--x</code></td>
</tr>
</tbody></table>
<ul>
<li>自增和自减不会改变变量数据类型</li>
<li>负数的取模运算：只有被除数（左边的数）的负号才有影响</li>
</ul>
<h3 id="3-比较运算符"><a href="#3-比较运算符" class="headerlink" title="3 比较运算符"></a>3 比较运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
</tr>
</thead>
<tbody><tr>
<td><code>==</code></td>
<td>等于</td>
<td><code>x == y</code></td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于</td>
<td><code>x != y</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
<td><code>x &gt; y</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
<td><code>x &lt; y</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
<td><code>x &gt;= y</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
<td><code>x &lt;= y</code></td>
</tr>
<tr>
<td><code>instanceof</code></td>
<td>是否是某类对象</td>
<td><code>obj instanceof Object</code></td>
</tr>
</tbody></table>
<h3 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4 逻辑运算符"></a>4 逻辑运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td>逻辑与</td>
<td><code>expr1 &amp; expr2</code></td>
<td>有 <code>false</code> 则 <code>false</code>，且两个表达式都会计算</td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>短路与</td>
<td><code>expr1 &amp;&amp; expr2</code></td>
<td>有 <code>false</code> 则 <code>false</code>，且若前边表达式为 <code>false</code>，则不再计算后边表达式</td>
</tr>
<tr>
<td><code>&#124;</code></td>
<td>逻辑或</td>
<td><code>expr1 &#124; expr2</code></td>
<td>有 <code>true</code> 则 <code>true</code>，且两个表达式都会计算</td>
</tr>
<tr>
<td><code>&#124;&#124;</code></td>
<td>短路或</td>
<td><code>expr1 &#124;&#124; expr2</code></td>
<td>有 <code>true</code> 则 <code>true</code>，且若前边表达式为 <code>true</code>，则不再计算后边表达式</td>
</tr>
<tr>
<td><code>!</code></td>
<td>逻辑非</td>
<td><code>!expr</code></td>
<td><code>true</code> 变 <code>false</code>，<code>false</code> 变 <code>true</code></td>
</tr>
<tr>
<td><code>^</code></td>
<td>逻辑异或</td>
<td><code>expr1 ^ expr2</code></td>
<td>相同则 <code>false</code>，不同则 <code>true</code></td>
</tr>
</tbody></table>
<h3 id="5-位运算符"><a href="#5-位运算符" class="headerlink" title="5 位运算符"></a>5 位运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td>按位与</td>
<td><code>x &amp; y</code></td>
<td>有 0 则 0</td>
</tr>
<tr>
<td><code>&#124;</code></td>
<td>按位或</td>
<td><code>x &#124; y</code></td>
<td>有 1 则 1</td>
</tr>
<tr>
<td><code>~</code></td>
<td>按位非</td>
<td><code>~x</code></td>
<td>1 变 0，0 变 1</td>
</tr>
<tr>
<td><code>^</code></td>
<td>按位异或</td>
<td><code>x ^ y</code></td>
<td>相同则 0，不同则 1</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移</td>
<td><code>x &lt;&lt; y</code></td>
<td>舍去高位，低位补0，相当于<code>x * 2<sup>y</sup></code></td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移</td>
<td><code>x &gt;&gt; y</code></td>
<td>舍去低位，正数高位补 0，负数高位补 1，相当于<code>x / 2<sup>y</sup></code></td>
</tr>
<tr>
<td><code>&gt;&gt;&gt;</code></td>
<td>无符号右移</td>
<td><code>x &gt;&gt;&gt; y</code></td>
<td>舍去低位，高位补 0，相当于<code>x / 2<sup>y</sup></code></td>
</tr>
</tbody></table>
<h3 id="6-三元运算符"><a href="#6-三元运算符" class="headerlink" title="6 三元运算符"></a>6 三元运算符</h3><table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>条件表达式 ? exprIfTrue : exprIfFalse</code></td>
<td>最终执行的表达式必须有返回值</td>
</tr>
</tbody></table>
<ul>
<li><p>三元运算符编译时要求两个表达式是同一个类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">true</span> ? <span class="keyword">new</span> Integer(<span class="number">1</span>) : <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(o);</span><br><span class="line"><span class="comment">// 结果是 1.0</span></span><br><span class="line"><span class="comment">// 因为要求两个表达式类型一样，所以暗含一个类型提升</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="5-2-运算符优先级"><a href="#5-2-运算符优先级" class="headerlink" title="5.2 运算符优先级"></a>5.2 运算符优先级</h2><table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody><tr>
<td><code>1</code></td>
<td><code>() [] {}</code></td>
<td>左 → 右</td>
</tr>
<tr>
<td><code>2</code></td>
<td><code>! +(正) -(负) ~ ++ --</code></td>
<td>右 → 左</td>
</tr>
<tr>
<td><code>3</code></td>
<td><code>* / %</code></td>
<td>左 → 右</td>
</tr>
<tr>
<td><code>4</code></td>
<td><code>+(加) -(减)</code></td>
<td>左 → 右</td>
</tr>
<tr>
<td><code>5</code></td>
<td><code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code></td>
<td>左 → 右</td>
</tr>
<tr>
<td><code>6</code></td>
<td><code>&lt; &lt;= &gt; &gt;= instanceof</code></td>
<td>左 → 右</td>
</tr>
<tr>
<td><code>7</code></td>
<td><code>== !=</code></td>
<td>左 → 右</td>
</tr>
<tr>
<td><code>8</code></td>
<td><code>&amp;</code></td>
<td>左 → 右</td>
</tr>
<tr>
<td><code>9</code></td>
<td><code>^</code></td>
<td>左 → 右</td>
</tr>
<tr>
<td><code>10</code></td>
<td><code>&#124;</code></td>
<td>左 → 右</td>
</tr>
<tr>
<td><code>11</code></td>
<td><code>&amp;&amp;</code></td>
<td>左 → 右</td>
</tr>
<tr>
<td><code>12</code></td>
<td><code>&#124;&#124;</code></td>
<td>左 → 右</td>
</tr>
<tr>
<td><code>13</code></td>
<td><code>?:(三元)</code></td>
<td>右 → 左</td>
</tr>
<tr>
<td><code>14</code></td>
<td><code>= += -= *= /= ...</code></td>
<td>右 → 左</td>
</tr>
</tbody></table>
<ul>
<li>结合性：在几个操作符具有相同的优先级时决定先执行哪一个<ul>
<li><code>+=</code> 是右结合，从右到左运算，所以 <code>a += b += c</code> 等价于 <code>a += (b += c)</code></li>
</ul>
</li>
</ul>
<h1 id="六-语句"><a href="#六-语句" class="headerlink" title="六 语句"></a>六 语句</h1><h2 id="6-1-条件语句"><a href="#6-1-条件语句" class="headerlink" title="6.1 条件语句"></a>6.1 条件语句</h2><h3 id="1-if-else"><a href="#1-if-else" class="headerlink" title="1 if else"></a>1 if else</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">	 statement;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">	 statement;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	 statement;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-switch"><a href="#2-switch" class="headerlink" title="2 switch"></a>2 switch</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式) &#123;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">		 code;</span><br><span class="line">	 	<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">		 code;</span><br><span class="line">	 	<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		 code;</span><br><span class="line">	 	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>表达式</code><ol>
<li>基本类型（可以自动提升为 <code>int</code> 的）<ul>
<li><code>byte short char int</code></li>
</ul>
</li>
<li>引用数据类型<ul>
<li>枚举（<code>jdk5</code>） </li>
<li>字符串字面量（<code>jdk7</code>）</li>
</ul>
</li>
</ol>
</li>
<li><code>case</code><ul>
<li>后边必须是常量且不能相同，不能是变量</li>
</ul>
</li>
<li><code>default</code><ul>
<li>可以放到任意位置，但是总是最后当所有 <code>case</code> 都不匹配时才执行</li>
</ul>
</li>
<li><code>break</code><ul>
<li>如果省略，会出现 <code>case</code> 穿透现象，下一个 <code>case</code> 不再判断，直接执行</li>
<li>最后一个可以省略</li>
</ul>
</li>
</ol>
<h2 id="6-2-循环语句"><a href="#6-2-循环语句" class="headerlink" title="6.2 循环语句"></a>6.2 循环语句</h2><h3 id="1-for"><a href="#1-for" class="headerlink" title="1 for"></a>1 for</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化条件【可以有多个】; 循环条件【<span class="keyword">boolean</span>类型】; 循环迭代条件) &#123;</span><br><span class="line">	循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-for-each"><a href="#2-for-each" class="headerlink" title="2 for each"></a>2 for each</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (variable: collection) &#123;</span><br><span class="line">	statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-while"><a href="#3-while" class="headerlink" title="3 while"></a>3 while</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">	statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-do-while"><a href="#4-do-while" class="headerlink" title="4 do while"></a>4 do while</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	statement;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (condition)</span><br></pre></td></tr></table></figure>

<h2 id="6-3-中断语句"><a href="#6-3-中断语句" class="headerlink" title="6.3 中断语句"></a>6.3 中断语句</h2><table>
<thead>
<tr>
<th>语句</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>continue</code></td>
<td>用于循环：跳出当次循环，继续下一次循环</td>
</tr>
<tr>
<td><code>break</code></td>
<td>用于 <code>switch ... case</code>：结束 <code>switch</code><br>用于循环：跳出当前循环，继续下边代码</td>
</tr>
<tr>
<td><code>return</code></td>
<td>任意位置：结束</td>
</tr>
</tbody></table>
<ul>
<li><code>cntinue</code> 和 <code>break</code> 可以使用标签标记位置：<code>label:</code></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>Java</category>
      </categories>
  </entry>
</search>
