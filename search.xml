<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Javascript 异步</title>
    <url>/anyeansan.github.io/2020/03/30/Javascript-%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-JavaScript是单线程的。"><a href="#1-1-JavaScript是单线程的。" class="headerlink" title="1.1 JavaScript是单线程的。"></a>1.1 JavaScript是单线程的。</h2><ul>
<li>注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合</li>
</ul>
<h2 id="1-2-同步任务和异步任务"><a href="#1-2-同步任务和异步任务" class="headerlink" title="1.2 同步任务和异步任务"></a>1.2 同步任务和异步任务</h2><ul>
<li>同步任务<ul>
<li>在主线程上排队执行的任务。</li>
<li>只有前一个任务执行完毕，才能执行后一个任务</li>
</ul>
</li>
<li>异步任务<ul>
<li>不进入主线程而进入任务队列的任务</li>
<li>只有引擎认为某个异步任务可以执行了，该任务才会进入主线程执行</li>
<li>异步任务不具有“堵塞”效应，即异步任务后的代码不用等待异步任务结束。</li>
</ul>
</li>
</ul>
<h2 id="1-3-任务队列和事件循环"><a href="#1-3-任务队列和事件循环" class="headerlink" title="1.3 任务队列和事件循环"></a>1.3 任务队列和事件循环</h2><ul>
<li>任务队列（task queue）<ul>
<li>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供任务队列，里面是各种需要当前程序处理的异步任务。（根据异步任务的类型，可以存在多个任务队列。）</li>
</ul>
</li>
<li>事件循环（Event Loop）<ul>
<li>同步任务执行完毕后，引擎会在任务队列循环检查，如果有可以执行的异步任务，则结束等待状态，进入主线程开始执行。</li>
</ul>
</li>
<li>执行步骤<ol>
<li>首先，主线程会去执行所有的同步任务，异步任务会进入任务队列。</li>
<li>同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。</li>
<li>直到任务队列清空，程序结束执行。</li>
</ol>
</li>
</ul>
<h2 id="1-4-异步操作模式"><a href="#1-4-异步操作模式" class="headerlink" title="1.4 异步操作模式"></a>1.4 异步操作模式</h2><ol>
<li>回调函数callback<ul>
<li>定时器，ajax……</li>
<li>缺点<ol>
<li>高耦合，维护困难，回调地狱，当多个异步任务多级依赖时，回调函数会形成多级嵌套</li>
<li>每个任务只能指定一个回调函数</li>
<li>如果多个异步操作没有顺序之分，同样需要等待上一个操作执行结束再进行下一个操作</li>
</ol>
</li>
</ul>
</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>promise</li>
<li>generators</li>
<li>async/await</li>
</ol>
<h1 id="二-promise"><a href="#二-promise" class="headerlink" title="二 promise"></a>二 promise</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol>
<li>Promise 对象本质上表示的是一系列操作的中间状态，或者说是未来某时刻一个操作完成或失败后返回的结果。</li>
<li>Promise 的回调函数不是正常的异步任务（宏任务），而是微任务（microtask）<ul>
<li>正常异步任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常异步任务</li>
</ul>
</li>
</ol>
<h2 id="2-2-promise-状态"><a href="#2-2-promise-状态" class="headerlink" title="2.2 promise 状态"></a>2.2 promise 状态</h2><h3 id="1-三种状态"><a href="#1-三种状态" class="headerlink" title="1 三种状态"></a>1 三种状态</h3><ol>
<li><code>pending</code> ：初始状态，初始化 promise 时的状态</li>
<li><code>fulfilled</code>：异步操作成功</li>
<li><code>rejected</code>：异步操作失败</li>
</ol>
<h3 id="2-说明"><a href="#2-说明" class="headerlink" title="2 说明"></a>2 说明</h3><ol>
<li><code>fulfilled</code> 和 <code>rejected</code> 统称 <code>settled</code> </li>
<li><code>resolved</code><ol>
<li>promise 已经 <code>settled</code></li>
<li>promise 已经使用另一个promise（B）来resolve <ul>
<li>此时promise的状态由B来决定，可能是<code>pending fulfilled rejected</code> 的任何一种</li>
</ul>
</li>
</ol>
</li>
<li><code>unresolved</code> &amp; <code>resolved</code><ul>
<li><code>unresolved</code> ：promise的状态只能是pending</li>
<li><code>resolved</code>：promise的状态可能是pending、fulfilled、rejected 的任何一种</li>
</ul>
</li>
</ol>
<h2 id="2-3-Promise-API"><a href="#2-3-Promise-API" class="headerlink" title="2.3 Promise API"></a>2.3 Promise API</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise(executor)</span><br><span class="line">// executor</span><br><span class="line">function(resolve, reject) &#123;&#125;</span><br><span class="line">// 或</span><br><span class="line">(resolve, reject) =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>executor</code><ol>
<li>指带有 resolve 和 reject 两个参数的函数</li>
<li>Promise构造函数执行时立即调用executor 函数</li>
<li>resolve 和 reject 是JavaScript 提供提供的两个函数<ol>
<li>resolve被调用时，将promise的状态改为<code>fulfilled</code></li>
<li>reject被调用时，将promise的状态改为<code>rejected</code></li>
</ol>
</li>
<li>如果executor内部出错，将promise的状态改为<code>rejected</code>，且忽略executor返回值</li>
</ol>
</li>
</ul>
<h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2 静态方法"></a>2 静态方法</h3><ol>
<li><p><code>Promise.resolve(value)</code></p>
<ul>
<li>返回一个以给定值解析后的Promise 对象。</li>
<li>value<ol>
<li>如果该value值为promise，返回这个promise；</li>
<li>如果该value值是thenable（即带有”then” 方法），会将thenable对象包装为promise并返回;</li>
<li>否则，返回的promise将以此value值完成，即此promise的成功值是value，也就是then方法中第一个函数的参数。</li>
</ol>
</li>
</ul>
</li>
<li><p><code>Promise.reject(reason)</code></p>
<ul>
<li>返回一个带有拒绝原因的Promise对象</li>
<li>reason<ul>
<li>拒绝的原因，通常是一个Error对象，也就是then方法中第二个函数的参数</li>
</ul>
</li>
</ul>
</li>
<li><p><code>Promise.all(iterable)</code><br> // TODO</p>
<ul>
<li>注：iterable中非promise元素会被转为promise</li>
</ul>
<ol>
<li>如果参数是一个空的可迭代对象<ol>
<li>返回一个已完成（already resolved）的 Promise。</li>
<li>此promise会调用成功回调函数，成功值是空数组<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promis.all([]).then(</span><br><span class="line">	value =&gt; console.log(value), // []</span><br><span class="line">	reason =&gt; console.log(reason)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>如果iterable参数不包含任何 promise<ol>
<li>返回一个异步完成（asynchronously resolved） Promise</li>
<li>此promise会调用成功回调函数，成功值是由参数的元素构成的数组<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promis.all(&quot;abc&quot;).then(</span><br><span class="line">	value =&gt; console.log(value), // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class="line">	reason =&gt; console.log(reason)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>其它情况下返回一个处理中（pending）的Promise<ol>
<li>如果iterable参数中包含的所有promise都成功，则此返回的promise调用成功函数，成功值为一个数组，数组元素为所有promise的成功值和非promise的值<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">	resolve(&apos;p1-success&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">Promis.all([p1, 3, 4, &apos;abc&apos;]).then(</span><br><span class="line">	value =&gt; console.log(value), // [&apos;p1-success&apos;,3,4,&apos;abc&apos;]</span><br><span class="line">	reason =&gt; console.log(reason)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>如果iterable参数中 包含的promise 有一个失败，则此返回的promise调用失败函数，失败原因是第一个失败的promise的原因<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">	reject(&apos;p1-fail&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">Promis.all([p1, 3, 4, &apos;abc&apos;]).then(</span><br><span class="line">	value =&gt; console.log(value), </span><br><span class="line">	reason =&gt; console.log(reason) // p1-fail</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p><code>Promise.allSettled(iterable)</code></p>
<ul>
<li>返回一个fulfilled状态的promise，成功值为一个对象数组，每个对象包含两个属性，表示对应的iterable元素的结果<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;status: &quot;fulfilled&quot;, value: ...&#125;</span><br><span class="line">&#123;status: &quot;rejected&quot;, reason: ...&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>Promise.race(iterable)</code></p>
<ul>
<li>返回一个promise，此返回promise的状态取决于iterable参数中promise 成功/失败的最快的那个。 </li>
</ul>
</li>
</ol>
<h3 id="3-原型方法"><a href="#3-原型方法" class="headerlink" title="3 原型方法"></a>3 原型方法</h3><h4 id="1-then"><a href="#1-then" class="headerlink" title="1 then"></a>1 then</h4><h5 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">then(onFulfilled[, onRejected])</span><br><span class="line"></span><br><span class="line">then(value =&gt; &#123;</span><br><span class="line">	// fulfillment</span><br><span class="line">&#125;, reason =&gt; &#123;</span><br><span class="line">	// rejection</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="2-参数"><a href="#2-参数" class="headerlink" title="2 参数"></a>2 参数</h5><ul>
<li>onFulfilled    ，可选<ul>
<li>当 Promise 变成fulfilled状态时调用的函数，参数为 <code>fulfillment  value</code>，表示成功的值</li>
<li>如果onFulfilled不是一个函数，会被忽略，内部变成<code>(value) =&gt; value</code>，即将<code>fulfillment  value</code>原样返回</li>
</ul>
</li>
<li>onRejected，可选<ul>
<li>当 Promise 变成rejected状态时调用的函数，参数为<code>rejection reason</code>，表示失败原因</li>
<li>如果onRejected不是函数，则会在内部被替换为一个 “Thrower” 函数，抛出失败原因</li>
</ul>
</li>
</ul>
<h5 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3 返回值"></a>3 返回值</h5><ol>
<li>如果then没有参数，或者要执行的回调函数对应的参数不是一个函数，则返回的promise与原promise状态相同，且成功值和失败原因也相同。</li>
<li>如果then没有返回值，则返回的promise，状态为fulfilled，成功值为undefined</li>
<li>如果then返回一个值，则返回的promise，状态为fulfilled，成功值为返回的值</li>
<li>如果then抛出错误，则返回的promise，状态为rejected，失败原因为抛出的错误</li>
<li>如果then返回一个promise（三种状态都有可能），则可以当作是最终返回的promise，即状态，成功值或者失败原因都是一样的</li>
</ol>
<table>
<thead>
<tr>
<th>内部返回值</th>
<th>最终返回promise状态</th>
<th>成功的值</th>
<th>失败原因</th>
</tr>
</thead>
<tbody><tr>
<td>错误</td>
<td>rejected</td>
<td>-</td>
<td>错误</td>
</tr>
<tr>
<td>无</td>
<td>fulfilled</td>
<td>undefined</td>
<td>-</td>
</tr>
<tr>
<td>非promise的值</td>
<td>fulfilled</td>
<td>非promise的值</td>
<td>-</td>
</tr>
<tr>
<td>promise值</td>
<td>同promise值</td>
<td>同promise值</td>
<td>同promise值</td>
</tr>
</tbody></table>
<h4 id="2-catch"><a href="#2-catch" class="headerlink" title="2 catch"></a>2 catch</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">catch(onRejected)</span><br><span class="line"></span><br><span class="line">catch(reason =&gt; &#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li>等同于 <code>then(undefined, onRejected)</code></li>
<li>catch之前任一promise状态变为rejected，如果此promise自己没有处理，则会被catch捕获 </li>
<li>catch返回一个promise，其状态取决于catch内部onRejected函数<ol>
<li>如果onRejected返回一个rejected状态的Promise或着抛出一个错误，则catch返回的promise状态为rejected</li>
<li>否则，catch返回的promise状态为fulfilled</li>
</ol>
</li>
</ol>
<h4 id="3-finally"><a href="#3-finally" class="headerlink" title="3 finally"></a>3 finally</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">finally(onFinally)</span><br><span class="line"></span><br><span class="line">finally(() =&gt; &#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>onFinally<ul>
<li>Promise 结束后，无论结果是fulfilled或者是rejected，都会执行onFinally回调函数</li>
</ul>
</li>
<li>返回一个设置了 finally 回调函数的Promise对象</li>
</ul>
<h1 id="三-async-await"><a href="#三-async-await" class="headerlink" title="三 async / await"></a>三 async / await</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol>
<li>async/await 是promise 的语法糖</li>
<li>async用来声明一个异步函数（async function），await操作符只能用在异步函数中</li>
</ol>
<h2 id="3-2-async"><a href="#3-2-async" class="headerlink" title="3.2 async"></a>3.2 async</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function show()&#123;&#125;</span><br><span class="line"></span><br><span class="line">let show = async function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">	async show()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class xxx&#123;</span><br><span class="line">	async show() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>异步函数返回一个promise<ol>
<li>如果异步函数正常执行，则返回的promise会调用成功函数，成功值为异步函数内部返回值。</li>
<li>如果异步函数抛出异常，则返回的promise会调用失败函数，失败原因是抛出异常</li>
</ol>
</li>
<li>错误处理<ul>
<li>async返回一个promise，可以调用catch来处理错误</li>
</ul>
</li>
</ol>
<h2 id="3-3-await"><a href="#3-3-await" class="headerlink" title="3.3 await"></a>3.3 await</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[return_value] = await expression;</span><br></pre></td></tr></table></figure>
<ol>
<li>await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成<ol>
<li>如果表达式是一个promise，则返回值为promise的处理结果</li>
<li>如果表达式不是一个promise，则返回该值本身</li>
</ol>
</li>
<li>错误处理<ol>
<li>await后边的promise出错，相当于async函数返回的promise为reject，所以可以在外部调用catch方法处理</li>
<li>可以在内部用try…catch…处理</li>
</ol>
</li>
<li>await的并行<ol>
<li>让promise先执行后再使用await处理结果</li>
<li>使用 Promise.all() 处理多个promise并行执行</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>UI</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript 模块化</title>
    <url>/anyeansan.github.io/2020/03/30/Javascript-%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="一-网上概述"><a href="#一-网上概述" class="headerlink" title="一 网上概述"></a>一 网上概述</h1><p><a href="https://segmentfault.com/a/1190000015302578" target="_blank" rel="noopener">网上概述</a></p>
<h1 id="二-概述"><a href="#二-概述" class="headerlink" title="二 概述"></a>二 概述</h1><ol>
<li>模块就是一个独立的文件，文件内部的变量，函数，类…外部无法获取</li>
<li>使用模块可以解决全局变量冲突</li>
<li>模块需要隐藏内部实现，只对外开发接口</li>
<li>模块可以避免滥用全局变量，造成代码不可控</li>
<li>模块可以被不同的应用使用，提高编码效率</li>
<li>模块默认运行在严格模式</li>
<li>模块都有独立的顶级作用域，不同模块间不能相互访问，类似函数作用域</li>
<li>模块在导入时只执行一次解析，之后的导入不会再执行模块代码，而使用第一次解析结果，并共享数据</li>
</ol>
<h1 id="三-加载"><a href="#三-加载" class="headerlink" title="三 加载"></a>三 加载</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>异步加载，即模块总是会在所有html解析后才执行</li>
</ul>
<h1 id="四-export"><a href="#四-export" class="headerlink" title="四 export"></a>四 export</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ul>
<li>模块中的功能默认外部无法使用，使用<code>export</code>命令规定模块的对面接口，即将指定功能导出供外部使用。</li>
</ul>
<h2 id="4-2-导出单个"><a href="#4-2-导出单个" class="headerlink" title="4.2 导出单个"></a>4.2 导出单个</h2><ul>
<li><code>export 声明语句</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export let name = &apos;xiaoqiang&apos;;</span><br><span class="line">export let obj = &#123;&#125;;</span><br><span class="line">export function show() &#123;&#125;;</span><br><span class="line">export class User &#123;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-3-导出列表"><a href="#4-3-导出列表" class="headerlink" title="4.3 导出列表"></a>4.3 导出列表</h2><ul>
<li><code>export { name1, name2, …, nameN };</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export let name = &apos;xiaoqiang&apos;;</span><br><span class="line">export let obj = &#123;&#125;;</span><br><span class="line">export function show() &#123;&#125;;</span><br><span class="line">export class User &#123;&#125;</span><br><span class="line">export &#123;name, obj, show, User&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-4-别名"><a href="#4-4-别名" class="headerlink" title="4.4 别名"></a>4.4 别名</h2><ul>
<li><code>export { variable1 as name1, variable2 as name2, …, nameN };</code></li>
</ul>
<h2 id="4-5-默认导出"><a href="#4-5-默认导出" class="headerlink" title="4.5 默认导出"></a>4.5 默认导出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default expression;</span><br><span class="line">export default function (…) &#123; … &#125; // also class, function*</span><br><span class="line">export default function name1(…) &#123; … &#125; // also class, function*</span><br><span class="line">export &#123; name1 as default, … &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>默认导出接口只能有一个，但默认导出可以与普通导出共存</li>
<li>本质上，<code>export default</code>就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字</li>
<li>默认导出时，函数和类可以具名也可以匿名，变量不能具名<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default let a = 1; // 错误</span><br><span class="line">let a = 1;</span><br><span class="line">export default a; // 正确，相当于把a的值赋予default</span><br><span class="line">export default 1; // 正确，相当于直接把值赋予default</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="五-import（静态导入）"><a href="#五-import（静态导入）" class="headerlink" title="五 import（静态导入）"></a>五 import（静态导入）</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol>
<li>import用于导入其它模块提供的功能。</li>
<li>import导入的变量名要与export导出的一致</li>
<li>import导入的变量是只读的</li>
<li>import命令具有提升效果，会提升到整个模块的头部，首先执行 </li>
<li>import是静态导入，不能使用表达式和变量</li>
<li>在浏览器中引用模块必须添加路径，但在打包工具如webpack中则不需要，因为他们有自己的存放方式。</li>
</ol>
<h2 id="5-2-导入所有导出接口"><a href="#5-2-导入所有导出接口" class="headerlink" title="5.2 导入所有导出接口"></a>5.2 导入所有导出接口</h2><ul>
<li><code>import * as name from &quot;module-name&quot;;</code><ul>
<li><code>name</code><ul>
<li>导入模块的命名空间</li>
</ul>
</li>
<li><code>module-name</code><ul>
<li>要导入的模块。通常是包含目标模块的.js文件的相对或绝对路径名，可以不包括.js扩展名。</li>
</ul>
</li>
<li>使用<code>default</code>获取默认导出</li>
</ul>
</li>
</ul>
<h2 id="5-3-导入指定导出接口"><a href="#5-3-导入指定导出接口" class="headerlink" title="5.3 导入指定导出接口"></a>5.3 导入指定导出接口</h2><ul>
<li><code>import { export1, export2, ..., exportN } from &quot;module-name&quot;;</code></li>
</ul>
<h2 id="5-4-别名"><a href="#5-4-别名" class="headerlink" title="5.4 别名"></a>5.4 别名</h2><ul>
<li><code>import { export1 as alias1, export2, ..., exportN } from &quot;module-name&quot;;</code></li>
</ul>
<h2 id="5-5-导入默认导出"><a href="#5-5-导入默认导出" class="headerlink" title="5.5 导入默认导出"></a>5.5 导入默认导出</h2><ul>
<li><code>import defaultExport from &quot;module-name&quot;;</code><ol>
<li>导入默认导出时名称任意</li>
<li>由于默认导出只有一个，所以不需要<code>{}</code></li>
</ol>
</li>
</ul>
<h2 id="5-6-混合导入"><a href="#5-6-混合导入" class="headerlink" title="5.6 混合导入"></a>5.6 混合导入</h2><ul>
<li><code>import defaultExport, { export1, export2, ..., exportN} from &quot;module-name&quot;;</code></li>
</ul>
<h1 id="六-export-default"><a href="#六-export-default" class="headerlink" title="六 export default"></a>六 export default</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><ol>
<li>使用<code>import</code>命令时，需要知道<code>export</code>导出的变量名。</li>
<li><code>export default</code> 本质是导出一个名为<code>defualt</code>的变量，使用<code>import</code>导入时可以以任意名称导入。</li>
<li>一个模块只能有一个默认输出，可以与普通导出共存</li>
</ol>
<h2 id="6-2-语法"><a href="#6-2-语法" class="headerlink" title="6.2 语法"></a>6.2 语法</h2><ol>
<li><code>export default expression</code><ul>
<li>将<code>expression</code>表达式的值赋给<code>default</code>导出<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a = 1;</span><br><span class="line">export default a; // 将a的值1赋给default</span><br><span class="line">export default 1; // 将1赋给default</span><br><span class="line">export default let a = 1; // 错误 因为let a = 1不能计算出一个值</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>export default function(){}  // also class, function*</code><ul>
<li>导出匿名函数/类，名称为<code>default</code></li>
</ul>
</li>
<li><code>export default function name(…) { … } // also class, function*</code><ul>
<li>导出具名函数/类，名称为<code>default</code>，原有名称会被忽略</li>
</ul>
</li>
<li><code>export { name1 as default, … };</code><ul>
<li>由于 <code>export default</code> 本质是导出一个名为<code>default</code>的变量</li>
<li>可以使用<code>export</code>导出一个别名为<code>default</code>的变量</li>
</ul>
</li>
</ol>
<h1 id="七-export-import"><a href="#七-export-import" class="headerlink" title="七 export + import"></a>七 export + import</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ol>
<li>可以将导入的模块再次导出</li>
<li>如果<code>export</code>和<code>import</code>结合在一起，其实就相当于一个转发，并没有导入到当前模块，即当前模块不能使用导入导出的功能。</li>
</ol>
<h2 id="7-2-语法"><a href="#7-2-语法" class="headerlink" title="7.2 语法"></a>7.2 语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export * from …;</span><br><span class="line">export &#123; name1, name2, …, nameN &#125; from …;</span><br><span class="line">export &#123; import1 as name1, import2 as name2, …, nameN &#125; from …;</span><br><span class="line">export &#123; default &#125; from …;</span><br></pre></td></tr></table></figure>

<h1 id="八-import-（动态导入）"><a href="#八-import-（动态导入）" class="headerlink" title="八 import()（动态导入）"></a>八 import()（动态导入）</h1><ol>
<li>接收参数与静态导入一致 </li>
<li>使用<code>import()</code> 函数可以动态导入模块，它返回一个 promise 对象，可以按需加载</li>
<li><code>import()</code> 函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块</li>
</ol>
<h1 id="九-打包工具-webpack"><a href="#九-打包工具-webpack" class="headerlink" title="九 打包工具 webpack"></a>九 打包工具 webpack</h1>]]></content>
      <categories>
        <category>UI</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript Class</title>
    <url>/anyeansan.github.io/2020/03/30/Javascript-Class/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>JavaScript 中，生成实例对象的传统方法是通过构造函数</li>
<li>为了和其他语言继承形态一致，JS提供了class 关键词用于模拟传统的class ，但底层实现机制依然是原型继承</li>
<li>class 只是语法糖，为了让类的声明与继承更加简洁清晰</li>
<li>class 其实就是函数，<code>typeof 类</code>返回<code>function</code></li>
<li>class 内部代码始终以严格模式执行</li>
<li>class 不存在变量提升</li>
<li>class 中的属性名可以采用表达式<code>[]</code></li>
<li>class 中定义的属性都是实例属性，定义的方法都是原型方法且不可枚举</li>
</ol>
<h1 id="二-语法"><a href="#二-语法" class="headerlink" title="二 语法"></a>二 语法</h1><ol>
<li>类声明<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class 类名 &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>类表达式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let 类名= class&#123;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="三-构造函数-constructor"><a href="#三-构造函数-constructor" class="headerlink" title="三 构造函数 constructor"></a>三 构造函数 constructor</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 基类默认构造函数</span><br><span class="line">constructor() &#123;&#125;</span><br><span class="line">// 派生类默认构造函数</span><br><span class="line">constructor(...args) &#123;</span><br><span class="line">	super(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用类new一个对象时会自动调用构造函数</li>
<li>如果省略，则会有默认构造函数</li>
<li><code>constructor</code> 默认返回实例对象（即this），可以改为返回另一个对象</li>
<li>类的原型的constructor属性指向类本身<ul>
<li><code>类.prototype.constructor = 类</code></li>
</ul>
</li>
</ol>
<h1 id="四-属性-amp-方法"><a href="#四-属性-amp-方法" class="headerlink" title="四 属性 &amp; 方法"></a>四 属性 &amp; 方法</h1><h2 id="4-1-实例属性"><a href="#4-1-实例属性" class="headerlink" title="4.1 实例属性"></a>4.1 实例属性</h2><ol>
<li>旧：使用<code>this.</code> 定义在<code>constructor</code>中</li>
<li>新：在类中直接定义的属性就是实例属性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">	name = &apos;haha&apos;; </span><br><span class="line">	constructor(age) &#123;</span><br><span class="line">		this.age = age; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-原型方法"><a href="#4-2-原型方法" class="headerlink" title="4.2 原型方法"></a>4.2 原型方法</h2><ol>
<li>旧：在类的原型上定义方法，是可以枚举的</li>
<li>新：在类中直接定义的方法就是原型方法，且不可枚举（non-enumerable）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">	show()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">User.prototype.show = function()&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-静态属性-方法"><a href="#4-3-静态属性-方法" class="headerlink" title="4.3 静态属性/方法"></a>4.3 静态属性/方法</h2><ol>
<li>定义在类上</li>
<li>在类中定义的属性/方法前加<code>static</code>关键字</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">	static age = 10;</span><br><span class="line">	static show() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">User.age = 10;</span><br><span class="line">User.show() = function()&#123;&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：如果静态方法包含this关键字，这个this指的是类本身，而不是实例对象</li>
</ul>
<h2 id="4-4-私有属性-方法"><a href="#4-4-私有属性-方法" class="headerlink" title="4.4 私有属性 / 方法"></a>4.4 私有属性 / 方法</h2><ul>
<li>私有属性：在属性名前加 <code>#</code></li>
<li>私有方法：以表达式形式定义方法并在方法前加<code>#</code> ，可以理解为就是定义私有属性，不过属性的值是一个函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">	#phone = &apos;13800000000&apos;; // 私有属性</span><br><span class="line">	#say = function() &#123;&#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-5-受保护属性-方法"><a href="#4-5-受保护属性-方法" class="headerlink" title="4.5 受保护属性 / 方法"></a>4.5 受保护属性 / 方法</h2><ul>
<li>在属性/方法名前加 <code>_</code>，这只是约定不是语法，不是规范</li>
<li>可以通过<code>symbol weakmap ...</code> 人为实现保护</li>
</ul>
<h1 id="五-访问器-getter-setter"><a href="#五-访问器-getter-setter" class="headerlink" title="五 访问器 getter/setter"></a>五 访问器 getter/setter</h1><ul>
<li>类中同样可以使用访问器，且访问器也是定义在属性的属性描述符上</li>
</ul>
<h1 id="六-class的继承"><a href="#六-class的继承" class="headerlink" title="六 class的继承"></a>六 class的继承</h1><h2 id="6-1-extends"><a href="#6-1-extends" class="headerlink" title="6.1 extends"></a>6.1 extends</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Fu &#123;</span><br><span class="line">	constructor() &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Zi extends Fu &#123;</span><br><span class="line">	constructor() &#123;</span><br><span class="line">		super();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>子类构造函数第一行必须先调用父类构造函数</li>
<li>class的继承做了两件事<ol>
<li>与ES5的 继承一样<ol>
<li>在子类构造函数中调用父类构造</li>
<li>子类的原型对象的原型指向父类的原型对象</li>
</ol>
</li>
<li><code>子类.__proto__ = 父类</code><ul>
<li>用于继承静态属性/方法</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="6-2-super"><a href="#6-2-super" class="headerlink" title="6.2 super"></a>6.2 super</h2><h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1 问题"></a>1 问题</h3><ol>
<li><code>子 父</code>：在子类中调用父类方法<ul>
<li>子：<code>this.__proto__.__proto__</code><ul>
<li>this代表子类实例，<code>this.__proto__.__proto__</code>就代表父类原型，就可以调用到父类的方法。</li>
</ul>
</li>
</ul>
</li>
<li><code>子 父 爷</code>：在子类中调用父类方法，父类方法中又调用了父类的父类的方法<ul>
<li>子：<code>this.__proto__.__proto__</code></li>
<li>父：<code>this.__proto__</code><ul>
<li>因为子类中调用父类方法的是父类原型对象，所以父类中的this代表的是父类原型，所以用<code>this.__proto__</code>获取爷爷的原型，就可以调用爷爷的方法</li>
</ul>
</li>
</ul>
</li>
<li><code>父 爷</code><ul>
<li>父：<code>this.__proto__.__proto__</code><ul>
<li>如果直接使用父类调用爷爷的方法，此时父类就是子，爷爷就是父类，就跟1<code>子 父</code>是一样的。</li>
<li>父类扮演不同角色时，代码是矛盾的。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>如果只有双层继承，使用<code>this</code>是可以的，如果有多重继承，是行不通的。</li>
<li>使用call/apply指定this，在多重继承中也是行不通的。</li>
</ul>
<h3 id="2-用法"><a href="#2-用法" class="headerlink" title="2 用法"></a>2 用法</h3><ol>
<li>super 只能在类或对象的方法中使用，而不能在函数中使用</li>
<li>使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。<ul>
<li><code>console.log(super)</code> 无法看出是函数还是对象，错误</li>
</ul>
</li>
</ol>
<h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">super([arguments]);</span><br></pre></td></tr></table></figure>
<ol>
<li>调用 父对象/父类 的构造函数</li>
<li>此时super代表父对象/父类的构造函数</li>
</ol>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">super.functionOnParent([arguments]);</span><br></pre></td></tr></table></figure>
<ol>
<li>调用 父对象/父类 上的方法</li>
<li>此时super代表父类原型对象</li>
<li>如果是静态方法则super代表父类本身</li>
</ol>
<h3 id="3-原生构造函数的继承"><a href="#3-原生构造函数的继承" class="headerlink" title="3 原生构造函数的继承"></a>3 原生构造函数的继承</h3><ol>
<li>之前，这些内置的构造函数如<code>Object() Array() ...</code> 是无法继承的</li>
<li>ES6 允许继承</li>
</ol>
<h3 id="4-mixin"><a href="#4-mixin" class="headerlink" title="4 mixin"></a>4 mixin</h3><ol>
<li>创建一个mixin类，包含许多供其它类使用的方法</li>
<li>将mixin类 合并到要使用功能的类的原型上</li>
</ol>
]]></content>
      <categories>
        <category>UI</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript 继承和原型</title>
    <url>/anyeansan.github.io/2020/03/30/Javascript-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="一-原型"><a href="#一-原型" class="headerlink" title="一 原型"></a>一 原型</h1><p><img src="https://gitee.com/3noanswer/npics/raw/master/UI/JavaScript/js%E5%8E%9F%E5%9E%8B.png" alt=""></p>
<h2 id="1-1-原型链"><a href="#1-1-原型链" class="headerlink" title="1.1 原型链"></a>1.1 原型链</h2><p><img src="https://gitee.com/3noanswer/npics/raw/master/UI/JavaScript/js%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt=""></p>
<ul>
<li>对象有自己的原型对象，而原型对象也是对象，所以原型对象也有自己的原型对象，就会形成一个“原型链”（prototype chain）</li>
<li>对象有自己的原型对象，而对象又可以充当其他对象的原型；</li>
</ul>
<h2 id="1-2-proto"><a href="#1-2-proto" class="headerlink" title="1.2 __proto__"></a>1.2 <code>__proto__</code></h2><ol>
<li>是浏览器实现的非JavaScript标准的属性，在ES6写入了附录，用于获取或设置对象的原型</li>
<li><code>obj.__proto__</code><ol>
<li>并非是普通的属性访问方式，而是通过getter/setter访问器</li>
<li><code>__proto__</code>理解为<code>prototype</code> 属性的 getter/setter 实现</li>
</ol>
</li>
<li>每个对象都有<code>__proto__</code>属性，指向它的构造函数的原型对象，即如果A对象是由B函数构造的，则 <code>A.__proto__ === B.prototype</code><ol>
<li>普通对象的构造函数是其对应的构造函数，则<code>对象.__proto__ === 构造函数.prototype</code></li>
<li>函数（包括Function自身）的构造函数是Function，则 <code>函数.__proto__ === Function.prototype</code></li>
<li>原型对象默认的构造函数是Object，则<code>原型对象.__proto__ === Object.prototype</code></li>
<li>原型对象中<code>Object.prototype</code>比较特殊，它是原型链的顶端，<code>Object.prototype.__proto__ === null</code></li>
</ol>
</li>
<li>由于非标准，浏览器有这个属性，其它环境未必有。建议使用Object中的方法 替代<code>__proto__</code><ul>
<li><code>Object.getPrototypeOf(obj)</code></li>
<li><code>Object.setPrototypeOf(obj, prototype)</code></li>
<li><code>Object.create(proto[, propertiesObject])</code></li>
</ul>
</li>
</ol>
<h2 id="1-3-prototype"><a href="#1-3-prototype" class="headerlink" title="1.3 prototype"></a>1.3 prototype</h2><ol>
<li>函数作为对象有<code>__proto__</code>，又可以作为构造函数有<code>prototype</code></li>
<li>每个函数都有一个<code>prototype</code>属性，指向函数的原型对象，且函数的原型对象是普通对象。<ul>
<li><code>Function.prototype</code>是个例外<ol>
<li>它是Function函数的原型对象但它是个函数对象</li>
<li>它是函数对象但是没有<code>prototype</code>属性</li>
</ol>
</li>
</ul>
</li>
<li>实例对象的<code>__proto__</code>和其构造函数的<code>prototype</code>都指向构造函数的原型对象</li>
<li><code>prototype</code>的作用是让该函数所实例化的对象们都可以找到公用的属性和方法，即js的继承是通过<code>prototype</code>实现的</li>
</ol>
<h3 id="4-constructor"><a href="#4-constructor" class="headerlink" title="4 constructor"></a>4 constructor</h3><ol>
<li>只有原型对象才有<code>constructor</code>属性，此属性指向函数本身，即<ol>
<li><code>函数.prototype.constructor = 函数</code></li>
<li><code>实例对象.__proto__.constructor = 函数</code></li>
</ol>
</li>
</ol>
<h1 id="二-new"><a href="#二-new" class="headerlink" title="二 new"></a>二 new</h1><h2 id="2-1-new的执行过程"><a href="#2-1-new的执行过程" class="headerlink" title="2.1 new的执行过程"></a>2.1 new的执行过程</h2><ol>
<li>创建一个空对象 <code>let obj = {};</code></li>
<li>将新建对象的<code>__proto__</code>指向构造函数的原型对象，<code>obj.__proto__ = 构造函数.prototype</code></li>
<li>将新建对象作为构造函数执行的上下文，即将构造函数内部的this指向新建对象</li>
<li>执行构造函数，如果构造函数没有返回引用类型的值，则返回新建对象</li>
</ol>
<h2 id="2-2-自定义new"><a href="#2-2-自定义new" class="headerlink" title="2.2 自定义new"></a>2.2 自定义new</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let myNew = function(cons, args) &#123;</span><br><span class="line">	let obj = &#123;&#125;; // 步骤1</span><br><span class="line">	obj.__proto__ = cons.prototype; // 步骤2</span><br><span class="line">	// let obj = Object.create(cons.prototype); 步骤1，2合在一起</span><br><span class="line">	let result = cons.apply(obj, args); // 步骤3</span><br><span class="line">	return result instanceof Object ? result : obj; // 步骤4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-new-target-属性"><a href="#2-3-new-target-属性" class="headerlink" title="2.3 new.target 属性"></a>2.3 new.target 属性</h2><ul>
<li>用来检测函数是否通过<code>new</code>或者<code>Reflect.construct()</code>调用的<ol>
<li>如果在普通函数中使用，返回undefined</li>
<li>在构造函数中使用指向被new调用的构造函数</li>
<li>在class的constructor函数中使用指向被new调用的class</li>
</ol>
</li>
</ul>
<h1 id="三-构造函数中的属性和方法"><a href="#三-构造函数中的属性和方法" class="headerlink" title="三 构造函数中的属性和方法"></a>三 构造函数中的属性和方法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function User(name) &#123;</span><br><span class="line">	let age = 18; // 私有属性</span><br><span class="line">	let test = function()&#123;&#125;; // 私有方法</span><br><span class="line">	this.name = name; // 实例属性</span><br><span class="line">	this.show = function()&#123;&#125;// 实例方法</span><br><span class="line">&#125;</span><br><span class="line">User.country = &apos;中国&apos;; // 静态属性</span><br><span class="line">User.sayHello = function()&#123;&#125;; // 静态方法</span><br><span class="line">User.prototype.gender = &apos;男&apos;; // 原型属性</span><br><span class="line">User.prototype.change = function()&#123;&#125;; // 原型方法</span><br></pre></td></tr></table></figure>
<ol>
<li>私有实例属性 / 方法（private）<ul>
<li>在构造函数内部使用<code>var/let/const</code>声明的属性/方法</li>
</ul>
</li>
<li>公有实例属性 / 方法（public）<ul>
<li>在构造函数内部使用<code>this.</code>声明的属性/方法</li>
</ul>
</li>
<li>静态属性 / 方法（static）<ul>
<li>定义在构造函数上的属性/方法</li>
</ul>
</li>
<li>原型属性 / 方法（prototype）<ul>
<li>定义在构造函数原型上的属性/方法 ，<strong>原型方法默认可枚举</strong></li>
</ul>
</li>
</ol>
<h1 id="四-继承"><a href="#四-继承" class="headerlink" title="四 继承"></a>四 继承</h1><h2 id="4-1-设置原型方式"><a href="#4-1-设置原型方式" class="headerlink" title="4.1 设置原型方式"></a>4.1 设置原型方式</h2><ol>
<li>设置构造函数原型，使用函数的<code>prototype</code>属性</li>
<li>设置对象的原型<ol>
<li><code>Object.create(proto[, propertiesObject])</code> <ul>
<li>创建对象时指定原型（只是定义无法获取）</li>
</ul>
</li>
<li>使用对象的属性<code>__proto__</code> 获取或设置原型，在浏览器之外的环境可能不行。</li>
<li>Object的方法，与<code>__proto__</code>效果一样，但是是js标准<ul>
<li><code>Object.getPrototypeOf(obj)</code><ul>
<li>获取对象的原型，即<code>__proto__</code></li>
</ul>
</li>
<li><code>Object.setPrototypeOf(obj, prototype)</code><ul>
<li>设置对象的原型</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="4-2-继承原理"><a href="#4-2-继承原理" class="headerlink" title="4.2 继承原理"></a>4.2 继承原理</h2><p><img src="https://gitee.com/3noanswer/npics/raw/master/UI/JavaScript/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF.png" alt=""></p>
<ul>
<li>将子类构造函数的原型对象的原型指向父类构造函数的原型对象</li>
</ul>
<h2 id="4-3-实现继承的方式"><a href="#4-3-实现继承的方式" class="headerlink" title="4.3 实现继承的方式"></a>4.3 实现继承的方式</h2><h3 id="1-原型链-1"><a href="#1-原型链-1" class="headerlink" title="1 原型链-1"></a>1 原型链-1</h3><p><img src="https://gitee.com/3noanswer/npics/raw/master/UI/JavaScript/%E7%BB%A7%E6%89%BF1.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A.prototype.__proto__ = B.prototype;</span><br></pre></td></tr></table></figure>
<ul>
<li>将子类构造函数的原型对象的原型直接指向父类构造函数的原型</li>
<li>好处<ul>
<li>父类原型在子类原型链上，则子类可以继承父类的原型属性/方法</li>
</ul>
</li>
<li>弊端<ul>
<li>创建子类时不会调用父类构造函数，无法继承父类的实例属性/方法</li>
</ul>
</li>
</ul>
<h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2 构造函数"></a>2 构造函数</h3><ul>
<li>在子类构造函数中通过<code>call/apply</code>调用父类构造函数，并指定this为子类对象<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Fu(name, age) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.age = age;</span><br><span class="line">	this.show = function()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">function Zi(name, age) &#123;</span><br><span class="line">	Fu(name,age); // 不行，因为直接调用时，父类构造函数this是指向window的</span><br><span class="line">	Fu.call(this, name, age); </span><br><span class="line">	Fu.apply(this, [name, age])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>好处<ul>
<li>创建的子类实例具备父类实例属性/方法</li>
</ul>
</li>
<li>弊端<ol>
<li>只是子类的实例，不是父类的实例（只是通过调用父类构造函数模拟继承）</li>
<li>无法继承父类原型属性/方法</li>
</ol>
</li>
</ul>
<h3 id="3-原型链-2"><a href="#3-原型链-2" class="headerlink" title="3 原型链-2"></a>3 原型链-2</h3><p><img src="https://gitee.com/3noanswer/npics/raw/master/UI/JavaScript/%E7%BB%A7%E6%89%BF2.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A.prototype = new B();</span><br></pre></td></tr></table></figure>
<ul>
<li>将子类构造函数的原型对象修改为一个父类实例（舍弃原有原型对象）</li>
<li>好处<ul>
<li>父类实例对象具有父类的实例属性/方法，父类实例对象的原型又指向父类构造函数原型，所以父类的实例属性/方法 和 原型属性/方法，子类都可以继承</li>
</ul>
</li>
<li>弊端<ol>
<li>父类的实例属性/方法是在子类原型对象上，这就导致父类的实例属性/方法实际上变成了子类的原型属性/方法。</li>
<li>需要手动为新的子类原型对象添加 <code>constructor</code>属性</li>
</ol>
</li>
</ul>
<h4 id="1-对新增对象的影响"><a href="#1-对新增对象的影响" class="headerlink" title="1 对新增对象的影响"></a>1 对新增对象的影响</h4><ul>
<li>如果新增对象在修改原型操作之前，那就意味着，新增对象指向的原型还是原来被舍弃的原型，所以这种方式只对修改原型操作之后新增的对象有效 </li>
</ul>
<h4 id="2-对constructor的影响"><a href="#2-对constructor的影响" class="headerlink" title="2 对constructor的影响"></a>2 对constructor的影响</h4><ul>
<li>由于这种方式是将子类原型修改成了一个新的对象，而这个新对象中是没有<code>constructor</code>属性的，所以需要手动为新对象添加<code>constructor</code>属性，并指向子类构造函数</li>
</ul>
<ol>
<li>直接添加<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A.prototype.constructor = A;</span><br></pre></td></tr></table></figure>
<ul>
<li>直接添加的方式有一个弊端，就是<code>constructor</code>属性默认可遍历</li>
</ul>
</li>
<li>使用Object的<code>defineProperty()</code> 添加<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.defineProperty(A.prototype, &quot;constructor&quot;, &#123;</span><br><span class="line">	value: A,</span><br><span class="line">	enumerable: false</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="4-组合继承1（构造函数-原型链2）"><a href="#4-组合继承1（构造函数-原型链2）" class="headerlink" title="4 组合继承1（构造函数+原型链2）"></a>4 组合继承1（构造函数+原型链2）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function B(name) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.gender = &apos;nan&apos;;</span><br><span class="line">B.prototype.eat = function() &#123;&#125;;</span><br><span class="line">function A(age) &#123;</span><br><span class="line">	B.call(this, &apos;小猫&apos;); // 第一次调用</span><br><span class="line">	this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype = new B(&apos;小狗&apos;); // 第二次调用</span><br><span class="line">A.prototype.constructor = A;</span><br></pre></td></tr></table></figure>
<ul>
<li>好处<ul>
<li>通过构造函数方式可以继承到父类的实例属性/方法</li>
<li>通过原型链方式可以继承到父类的原型属性/方法</li>
</ul>
</li>
<li>弊端<ol>
<li>父类的实例属性会在子类实例和子类原型上都定义一份，不过不影响，因为会先使用实例自己的属性</li>
<li>会调用两次父类构造函数</li>
<li>需要手动为新的子类原型对象添加 <code>constructor</code>属性</li>
</ol>
</li>
</ul>
<h3 id="5-组合继承2（构造函数-原型链1）"><a href="#5-组合继承2（构造函数-原型链1）" class="headerlink" title="5 组合继承2（构造函数+原型链1）"></a>5 组合继承2（构造函数+原型链1）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function B(name) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.gender = &apos;nan&apos;;</span><br><span class="line">B.prototype.eat = function() &#123;&#125;;</span><br><span class="line">function A(age) &#123;</span><br><span class="line">	B.call(this, &apos;小猫&apos;); </span><br><span class="line">	this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.__proto__ = B.prototype</span><br></pre></td></tr></table></figure>
<ul>
<li>好处<ul>
<li>通过构造函数方式可以继承到父类的实例属性/方法</li>
<li>通过原型链方式可以继承到父类的原型属性/方法</li>
</ul>
</li>
<li>弊端<ul>
<li><code>__proto__</code> 在浏览器之外的环境可能不行。</li>
</ul>
</li>
</ul>
<h3 id="6-最终方式"><a href="#6-最终方式" class="headerlink" title="6 最终方式"></a>6 最终方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function B(name) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.gender = &apos;nan&apos;;</span><br><span class="line">B.prototype.eat = function() &#123;&#125;;</span><br><span class="line">function A(age) &#123;</span><br><span class="line">	B.call(this, &apos;小猫&apos;); </span><br><span class="line">	this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype = Object.create(B.prototype);</span><br><span class="line">Object.defineProperty(A.prototype, &quot;constructor&quot;, &#123;</span><br><span class="line">	value: A,</span><br><span class="line">	enumerable: false</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>将<code>__proto__</code> 方式改为<code>Object.create()</code></li>
<li><code>A.prototype = Object.create(B.prototype);</code><ul>
<li>以父类的原型创建一个对象作为子类原型对象，此新建对象没有调用父类构造函数，没有父类实例属性/方法</li>
</ul>
</li>
</ul>
<h2 id="4-4-对象工厂"><a href="#4-4-对象工厂" class="headerlink" title="4.4 对象工厂"></a>4.4 对象工厂</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Fu(name)&#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">function createObj(...args) &#123;</span><br><span class="line">	const obj = Object.create(Fu.prototype);</span><br><span class="line">	Fu.call(obj, ...args); //通过调用父类</span><br><span class="line">	return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>与继承方式类似，只是通过对象工厂创建子类对象，不需要子类构造函数<ol>
<li>创建一个以父类原型为原型的对象，相当于继承了父类原型属性/方法</li>
<li>调用父类构造函数，并设置this为新建对象，即相当于继承了父类实例属性</li>
<li>返回新建对象</li>
</ol>
</li>
</ul>
<h2 id="4-5-静态属性-方法的继承"><a href="#4-5-静态属性-方法的继承" class="headerlink" title="4.5 静态属性/方法的继承"></a>4.5 静态属性/方法的继承</h2><ul>
<li>静态属性/方法即在构造函数上定义的属性/方法，继承原理都是一样的，函数也是对象，把子类构造函数看作对象，设置其原型为父类构造函数，即可继承静态属性/方法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Fu() &#123;&#125;</span><br><span class="line">Fu.haha = &quot;wangcai&quot;;</span><br><span class="line">Fu.show = function() &#123;</span><br><span class="line">	console.log(&apos;fu static show&apos;)</span><br><span class="line">&#125;</span><br><span class="line">function Zi() &#123;&#125;</span><br><span class="line">Zi.__proto__ = Fu;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-6-多继承"><a href="#4-6-多继承" class="headerlink" title="4.6 多继承"></a>4.6 多继承</h2><ul>
<li>js不支持多继承，也没有接口实现，如果要使用多个类的方法时可以使用mixin混合模式来完成</li>
</ul>
<h3 id="Mixin模式"><a href="#Mixin模式" class="headerlink" title="Mixin模式"></a>Mixin模式</h3><ol>
<li>Mixin模式 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口</li>
<li>mixin 可以看作是一个包含许多功能的对象，使用时将这些功能合并到要使用功能的对象原型上即可</li>
</ol>
<ul>
<li>例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let myMix = &#123;</span><br><span class="line">	sayHi() &#123;&#125;,</span><br><span class="line">	sayBye() &#123;&#125;,</span><br><span class="line">	eat()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">function User() &#123;&#125;</span><br><span class="line">// 合并之后，User的实例就有了myMix的功能了</span><br><span class="line">Object.assign(User.prototype, myMix);</span><br><span class="line">// 手动添加某个功能</span><br><span class="line">User.prototype.eat = myHix.eat;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>父</category>
        <category>子</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript 闭包</title>
    <url>/anyeansan.github.io/2020/03/30/Javascript-%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>通常情况下，函数执行时（入栈）创建一个单独的作用域，函数执行完毕（弹栈），此作用域销毁，函数内部的变量也就销毁了，无法再访问。</li>
<li>闭包则会添加一个对函数的引用，使得函数作用域一直保存到闭包不存在为止。</li>
</ol>
<h1 id="二-概念及现象"><a href="#二-概念及现象" class="headerlink" title="二 概念及现象"></a>二 概念及现象</h1><ul>
<li>闭包是由函数以及创建该函数的词法环境组合而成。在此词法环境外调用函数时，可以访问到词法环境中的变量。</li>
<li>通俗来说就是：<ol>
<li>有一个单独的作用域，此作用域中定义一个函数，则这个函数与它能在此作用域中所有能访问的变量构成了闭包。</li>
<li>在此作用域外调用函数时，函数能够使用作用域中的变量。</li>
</ol>
</li>
</ul>
<h1 id="三-如何形成闭包"><a href="#三-如何形成闭包" class="headerlink" title="三 如何形成闭包"></a>三 如何形成闭包</h1><h2 id="3-1-条件"><a href="#3-1-条件" class="headerlink" title="3.1 条件"></a>3.1 条件</h2><ol>
<li>单独的作用域：为了创建局部变量</li>
<li>内部定义一个函数：形成闭包</li>
<li>将函数暴漏给外部：为了能在外部访问到函数</li>
</ol>
<h2 id="3-2-方式"><a href="#3-2-方式" class="headerlink" title="3.2 方式"></a>3.2 方式</h2><ol>
<li>函数嵌套<ol>
<li>外部函数是一个单独的函数作用域</li>
<li>定义一个内部函数，此内部函数与外部函数中的变量构成了闭包</li>
<li>把内部函数return, 或者添加到window对象上，暴漏给外部。</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function outer() &#123;</span><br><span class="line">	let i = 0;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		console.log(i++);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let inner = outer(); </span><br><span class="line">inner(); // 外部函数执行完毕后，依然可以访问到外部函数中的变量</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UI</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript 引用数据类型</title>
    <url>/anyeansan.github.io/2020/03/30/Javascript-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="一-属性描述符"><a href="#一-属性描述符" class="headerlink" title="一 属性描述符"></a>一 属性描述符</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ol>
<li>JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为属性描述符（property descriptor），或者叫属性描述对象</li>
<li>属性描述符有两种主要形式，且只能取其一<ol>
<li>数据描述符可以具有的属性<ul>
<li><code>configurable enumerable value writable</code></li>
</ul>
</li>
<li>存取描述符可以具有的属性<ul>
<li><code>configurable enumerable get set</code></li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="1-2-元属性（属性描述对象中用来描述属性元信息的属性）"><a href="#1-2-元属性（属性描述对象中用来描述属性元信息的属性）" class="headerlink" title="1.2 元属性（属性描述对象中用来描述属性元信息的属性）"></a>1.2 元属性（属性描述对象中用来描述属性元信息的属性）</h2><table>
<thead>
<tr>
<th>元属性</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>value</code></td>
<td>表示该属性的值</td>
<td><code>undefined</code></td>
</tr>
<tr>
<td><code>writable</code></td>
<td>表示该属性是否可写</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>enumerable</code></td>
<td>表示该属性是否可遍历</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>configurable</code></td>
<td>1 该属性是否可删除<br>2 该属性的属性描述符是否可修改</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>get</code></td>
<td>表示该属性的取值函数getter</td>
<td><code>undefined</code></td>
</tr>
<tr>
<td><code>set</code></td>
<td>表示该属性的存值函数setter</td>
<td><code>undefined</code></td>
</tr>
</tbody></table>
<h1 id="二-对象"><a href="#二-对象" class="headerlink" title="二 对象"></a>二 对象</h1><h2 id="2-1-Object"><a href="#2-1-Object" class="headerlink" title="2.1 Object"></a>2.1 Object</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><ol>
<li><code>Object([value])</code><ol>
<li>普通函数，作用是类型转换，将value转成一个对象</li>
<li>用法与构造函数相同，只是语义上的区别</li>
</ol>
</li>
<li><code>new Object([value])</code><ol>
<li>构造函数，创建一个对象，值为value转成的对象</li>
<li>如果参数value<ol>
<li>为空或者是<code>undefined null</code>，返回一个空对象</li>
<li>是基本类型的值则返回其包装对象</li>
<li>是引用类型则直接返回</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2 静态方法"></a>2 静态方法</h3><h4 id="1-获取"><a href="#1-获取" class="headerlink" title="1 获取"></a>1 获取</h4><ol>
<li><code>Object.keys(obj)</code><ul>
<li>返回对象自身可枚举属性键的数组</li>
</ul>
</li>
<li><code>Object.values(obj)</code><ul>
<li>返回对象自身可枚举属性值的数组</li>
</ul>
</li>
<li><code>Object.entries(obj)</code><ul>
<li>返回对象自身可枚举属性键值对的数组</li>
<li>以上三个方法与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）</li>
</ul>
</li>
<li><code>Object.getOwnPropertyNames(obj)</code><ul>
<li>返回对象自身的所有属性（包含可枚举和不可枚举属性，不包含Symbol属性）键的数组</li>
</ul>
</li>
<li><code>Object.getOwnPropertySymbols(obj)</code><ul>
<li>返回对象自身的所有 Symbol 属性的数组</li>
</ul>
</li>
</ol>
<h4 id="2-属性描述符"><a href="#2-属性描述符" class="headerlink" title="2 属性描述符"></a>2 属性描述符</h4><ol>
<li><code>Object.getOwnPropertyDescriptor(obj, prop)</code><ul>
<li>获取对象自身某个属性的属性描述对象</li>
</ul>
</li>
<li><code>Object.getOwnPropertyDescriptors(obj)</code><ul>
<li>获取对象自身所有属性的属性描述对像</li>
</ul>
</li>
<li><code>Object.defineProperty(obj, prop, descriptor)</code><ul>
<li>如果对象自身存在指定属性，则修改它的属性描述对象，否则为对象添加指定属性并定义属性描述对象。返回该对象</li>
<li>通过这种方式定义属性描述法时的默认值<ul>
<li><code>configurable enumerable writable</code> 均为false</li>
<li><code>value get set</code> 均为undefined</li>
</ul>
</li>
</ul>
</li>
<li><code>Object.defineProperties(obj, props)</code><ul>
<li>修改或添加对象多个属性的属性描述对象，返回该对象</li>
</ul>
</li>
</ol>
<h4 id="3-创建对象"><a href="#3-创建对象" class="headerlink" title="3 创建对象"></a>3 创建对象</h4><ol>
<li><code>Object.create(proto[, propertiesObject])</code><ul>
<li>指定原型对象和属性（使用属性描述符定义），返回一个新的对象</li>
<li><code>propertiesObject</code> 同 <code>Object.defineProperties(obj, props)</code> 的<code>props</code></li>
</ul>
</li>
<li><code>Object.assign(target, ...sources)</code><ul>
<li>将一个或多个源对象的所有可枚举属性复制到目标对象。并返回目标对象<ol>
<li>如果目标对象与源对象有同名属性，或多个源对象有同名属性，后边覆盖前边</li>
<li><code>Object.assign</code> 方法实行的是浅拷贝</li>
<li>数组会被当作对象，即相同索引会覆盖</li>
<li>如果属性值是取值函数，会计算后再复制</li>
</ol>
</li>
</ul>
</li>
<li><code>Object.fromEntries(iterable)</code><ul>
<li>把键值对列表转换为一个对象</li>
<li>是 <code>Object.entries()</code> 的反转</li>
</ul>
</li>
</ol>
<h4 id="4-原型"><a href="#4-原型" class="headerlink" title="4 原型"></a>4 原型</h4><ol>
<li><code>Object.getPrototypeOf(obj)</code><ul>
<li>获取对象的Prototype对象，即<code>__proto__</code></li>
</ul>
</li>
<li><code>Object.setPrototypeOf(obj, prototype)</code><ul>
<li>修改对象的prototype对象</li>
</ul>
</li>
</ol>
<h4 id="5-状态"><a href="#5-状态" class="headerlink" title="5 状态"></a>5 状态</h4><ol>
<li><code>Object.preventExtensions(obj)</code><ul>
<li>让一个对象变的不可扩展，也就是永远不能再添加新的属性</li>
</ul>
</li>
<li><code>Object.isExtensible(obj)</code><ul>
<li>判断一个对象是否可扩展</li>
</ul>
</li>
<li><code>Object.seal(obj)</code><ul>
<li>封闭一个对象，此对象不可扩展且对象所有自身属性<code>configurable</code>标记为false </li>
<li>不能添加、删除属性，属性修饰符不可配置</li>
</ul>
</li>
<li><code>Object.isSealed(obj)</code><ul>
<li>判断一个对象是否被封闭</li>
</ul>
</li>
<li><code>Object.freeze(obj)</code><ul>
<li>冻结一个对象，此对象不可扩展且对象所有自身属性 <code>writable configurable</code> 标记为false</li>
<li>不能添加、修改和删除属性，属性修饰符不可配置</li>
</ul>
</li>
<li><code>Object.isFrozen(obj)</code><ul>
<li>判断一个对象是否被冻结</li>
</ul>
</li>
</ol>
<h4 id="6-判断"><a href="#6-判断" class="headerlink" title="6 判断"></a>6 判断</h4><ol>
<li><code>Object.is(value1, value2)</code><ul>
<li>判断两个值是否相等，不会作类型转换</li>
<li>与<code>===</code>的区别<ol>
<li><code>===</code> 认为<code>-0</code>和<code>+0</code>相等，此方法认为不相等</li>
<li><code>===</code> 认为<code>NaN</code>和<code>NaN</code>不相等，此方法认为相等</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="3-原型方法"><a href="#3-原型方法" class="headerlink" title="3 原型方法"></a>3 原型方法</h3><ol>
<li><code>valueOf()</code><ul>
<li>返回对象原始值，若没有原始值，返回对象本身，通常会覆盖</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>对象</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td><code>Number</code></td>
<td>数值</td>
</tr>
<tr>
<td><code>Boolean</code></td>
<td>布尔值</td>
</tr>
<tr>
<td><code>String</code></td>
<td>字符串值</td>
</tr>
<tr>
<td><code>Object</code></td>
<td>对象本身</td>
</tr>
<tr>
<td><code>Array</code></td>
<td>数组本身</td>
</tr>
<tr>
<td><code>Function</code></td>
<td>函数本身</td>
</tr>
<tr>
<td><code>Date</code></td>
<td>距离1970-01-01 00:00:00 的毫秒数</td>
</tr>
</tbody></table>
<ol start="2">
<li><code>toString()</code><ul>
<li>默认返回 <code>[object type]</code>，通常会覆盖</li>
</ul>
</li>
<li><code>toLocaleString()</code><ul>
<li>默认返回调用 <code>toString()</code> 的结果，可以覆盖</li>
</ul>
</li>
<li><code>hasOwnProperty(prop)</code><ul>
<li>判断对象自身是否含有某个属性</li>
</ul>
</li>
<li><code>propertyIsEnumerable(prop)</code><ul>
<li>判断某个属性是否可枚举</li>
</ul>
</li>
<li><code>isPrototypeOf(object)</code><ul>
<li>判断调用对象是否在另一个对象的原型链上</li>
<li>和 <code>instanceof</code> 的区别<ul>
<li><code>A instanceof B</code> ：判断 <code>B.prototype</code>是否在A的原型链上</li>
<li><code>B.isPrototypeOf(A)</code>：判断B是否在A的原型链上</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="2-2-创建对象方式"><a href="#2-2-创建对象方式" class="headerlink" title="2.2 创建对象方式"></a>2.2 创建对象方式</h2><ol>
<li>Object构造函数</li>
<li>对象字面量<ul>
<li>对象字面量内部调用了Object的构造函数</li>
</ul>
</li>
<li><code>Object.create(proto, [propertiesObject])</code><ul>
<li>这种方式可以指定原型</li>
</ul>
</li>
</ol>
<h2 id="2-3-对象字面量"><a href="#2-3-对象字面量" class="headerlink" title="2.3 对象字面量"></a>2.3 对象字面量</h2><ol>
<li>标准形式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj =&#123;</span><br><span class="line">	key:value,</span><br><span class="line">	key:function()&#123;&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>如果属性值是方法，可以简写<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key:function()&#123;&#125; </span><br><span class="line"> //简写</span><br><span class="line">key()&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果属性名是一个表达式，使用<code>[]</code>包裹，意思是取表达式的值<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a = &apos;haha&apos;;</span><br><span class="line">let obj = &#123; [a]:a &#125;; </span><br><span class="line">console.log(obj); // &#123;haha:&apos;haha&apos;&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果属性值是外部变量的值，属性名与变量名相同时可以简写（其实就是将变量作为对象属性）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a = &apos;haha&apos;；</span><br><span class="line">let obj = &#123; a:a &#125;;</span><br><span class="line">// 简写</span><br><span class="line">let obj = &#123;a&#125;; </span><br><span class="line">console.log(obj); // &#123;a:&apos;haha&apos;&#125;</span><br></pre></td></tr></table></figure></li>
<li>与json的区别<ol>
<li>json只允许<code>&quot;property&quot;:value</code>，属性名必须用双引号括起来</li>
<li>json值仅允许字符串，数字，数组，true，false，null或其他（JSON）对象，值不能是函数</li>
</ol>
</li>
</ol>
<h2 id="2-4-自定义构造函数"><a href="#2-4-自定义构造函数" class="headerlink" title="2.4 自定义构造函数"></a>2.4 自定义构造函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 可以空参</span><br><span class="line">function Person(name,age)&#123;</span><br><span class="line">		this.name=name;</span><br><span class="line">		this.age=age;</span><br><span class="line">		this.show=function()&#123;code...&#125;</span><br><span class="line">&#125;</span><br><span class="line">let person=new Person(&quot;xq&quot;,8);</span><br></pre></td></tr></table></figure>
<h2 id="2-5-工厂函数"><a href="#2-5-工厂函数" class="headerlink" title="2.5 工厂函数"></a>2.5 工厂函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function userFactory(name) &#123;</span><br><span class="line">	let obj = &#123;&#125;;</span><br><span class="line">	obj.name = name;</span><br><span class="line">	obj.show = function()&#123;&#125;;</span><br><span class="line">	return obj;</span><br><span class="line">	// 或者简写</span><br><span class="line">	return &#123;</span><br><span class="line">		name,</span><br><span class="line">		show()&#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在函数内部根据传入的参数创建一个对象（可以使用字面量或Object构造等等方式），然后将对象返回，为了复用</li>
<li>与自定义构造函数方式的区别<ul>
<li>工厂函数是函数调用，自定义构造是new</li>
<li>工厂函数是函数名称小写，自定义构造名称大写</li>
<li>工厂函数内部需要显式创建一个对象，然后根据参数赋值后再显式返回</li>
<li>自定义构造根据参数自动创建一个对象并返回</li>
</ul>
</li>
</ul>
<h2 id="2-6-属性管理"><a href="#2-6-属性管理" class="headerlink" title="2.6 属性管理"></a>2.6 属性管理</h2><h3 id="1-属性的访问"><a href="#1-属性的访问" class="headerlink" title="1 属性的访问"></a>1 属性的访问</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 obj.property</span><br><span class="line">2 obj[&apos;property&apos;]</span><br></pre></td></tr></table></figure>
<ol>
<li>点后边只能是属性名，中括号中可以是一个表达式</li>
<li>当属性名称比较特殊时，如数字,空格…，只能用中括号</li>
<li>当属性名称是变量时，如遍历时，只能用中括号</li>
</ol>
<h3 id="2-属性的删除"><a href="#2-属性的删除" class="headerlink" title="2 属性的删除"></a>2 属性的删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 delete object.property </span><br><span class="line">2 delete object[&apos;property&apos;]</span><br></pre></td></tr></table></figure>
<ol>
<li>删除自身属性，返回布尔值</li>
<li>如果要删除的属性不存在，返回true</li>
</ol>
<h2 id="2-7-访问器（get-set）"><a href="#2-7-访问器（get-set）" class="headerlink" title="2.7 访问器（get/set）"></a>2.7 访问器（get/set）</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// getter</span><br><span class="line">1 get prop() &#123; ... &#125;</span><br><span class="line">2 get [expression]() &#123; ... &#125;</span><br><span class="line">// setter</span><br><span class="line">1 set prop(val) &#123; . . . &#125;</span><br><span class="line">2 set [expression](val) &#123; . . . &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>函数名可以是一个表达式</li>
<li>访问器函数调用方式与访问对象属性一样，其实是调用访问器函数<ol>
<li><code>obj.访问器名</code></li>
<li><code>obj[&#39;访问器名&#39;]</code></li>
</ol>
</li>
<li>访问器跟属性同名时，如果访问器方法内部访问属性会造成无限循环。</li>
</ol>
<h3 id="2-定义方式"><a href="#2-定义方式" class="headerlink" title="2 定义方式"></a>2 定义方式</h3><ol>
<li>通过配置属性描述符对象定义访问器<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">	name : &apos;小明&apos;;</span><br><span class="line">&#125;</span><br><span class="line">Object.defineProperty(obj, &apos;name&apos;, &#123;</span><br><span class="line">	get() &#123;</span><br><span class="line">		return obj.name; // 跟取值方式一样，也会调用get，会无限循环</span><br><span class="line">	&#125;,</span><br><span class="line">	set(value) &#123;</span><br><span class="line">		obj.name = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.name; // 调用get取值</span><br><span class="line">obj.name = &apos;旺财&apos;; // 调用set设置值</span><br></pre></td></tr></table></figure></li>
<li>对象字面量中直接定义<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">	_name: &apos;小明&apos;,</span><br><span class="line">	get name() &#123;</span><br><span class="line">		return this._name;</span><br><span class="line">	&#125;,</span><br><span class="line">	set name(value) &#123;</span><br><span class="line">		this._name = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="2-8-对象拷贝"><a href="#2-8-对象拷贝" class="headerlink" title="2.8 对象拷贝"></a>2.8 对象拷贝</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h3><ul>
<li>浅拷贝<ul>
<li>如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 </li>
<li>一个对象修改可能会影响到另一个对象</li>
</ul>
</li>
<li>深拷贝<ul>
<li>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象</li>
<li>一个对象修改不会影响到另一个对象</li>
</ul>
</li>
</ul>
<h3 id="2-浅拷贝方式"><a href="#2-浅拷贝方式" class="headerlink" title="2 浅拷贝方式"></a>2 浅拷贝方式</h3><ol>
<li>创建新对象，然后使用<code>for...in</code>遍历原对象属性并一个一个连值一起添加到新对象上<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let source = &#123;name:&apos;an3&apos;, age:18&#125;;</span><br><span class="line">let cp = &#123;&#125;;</span><br><span class="line">for (const key in source)&#123;</span><br><span class="line">	if(source.hasOwnProperty(key)&#123;</span><br><span class="line">		cp[key] = source[key];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用<code>Object.assign(目标对象, 原对象列表)</code>，并将目标对象设为空对象，就相当于返回了对原对象的浅拷贝<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let source = &#123;name:&apos;an3&apos;, age:18&#125;;</span><br><span class="line">let cp = Object.assign(&#123;&#125;, source);</span><br></pre></td></tr></table></figure></li>
<li>展开语法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let source = &#123;name:&apos;an3&apos;, age:18&#125;;</span><br><span class="line">let cp = &#123;...source&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="3-深拷贝方式"><a href="#3-深拷贝方式" class="headerlink" title="3 深拷贝方式"></a>3 深拷贝方式</h3><ol>
<li>使用JSON<ol>
<li>步骤<ol>
<li><code>JSON.stringify()</code>：将一个对象序列成一个字符串</li>
<li><code>JSON.parse()</code>：将字符串反序列化生成深拷贝对象</li>
</ol>
</li>
<li>注意<ol>
<li>拷贝的对象的值中如果有函数,undefined,symbol则经过JSON.stringify()序列化后的JSON字符串中这个键值对会消失</li>
<li>无法拷贝不可枚举的属性，无法拷贝对象的原型链</li>
<li>拷贝Date引用类型会变成字符串</li>
<li>拷贝RegExp引用类型会变成空对象</li>
<li>对象中含有NaN、Infinity和-Infinity，则序列化的结果会变成null</li>
<li>无法拷贝对象的循环应用(即obj[key] = obj)</li>
</ol>
</li>
</ol>
</li>
<li>递归<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function deepCopy(obj) &#123;</span><br><span class="line">	// 对象的属性值有可能是数组，判断一下防止递归时把数组变成了对象</span><br><span class="line">	let cpObj = obj instanceof Array ? [] : &#123;&#125;;</span><br><span class="line">	// 我用for in 也可以，但for in 不推荐用来遍历数组，Object.entries()方法对于对象和数组返回结果形式是一样的</span><br><span class="line">	for(const [k, v] of Object.entries(obj)) &#123;</span><br><span class="line">		// 判断对象属性如果是引用类型就递归拷贝，最终就是深拷贝</span><br><span class="line">		cpObj[k] = typeof v == &apos;object&apos; ? deepCopy(v) : v;</span><br><span class="line">	&#125;  </span><br><span class="line">	return cpObj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>原理就是浅拷贝只拷贝一层，那我们就递归，如果这一层属性的值是引用类型，就再拷贝一层……</li>
</ul>
</li>
</ol>
<h2 id="2-9-代理"><a href="#2-9-代理" class="headerlink" title="2.9 代理"></a>2.9 代理</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>代理（拦截器）是对象的访问控制，setter/getter 访问器是对对象单个属性的控制</li>
</ol>
<h3 id="2-Proxy"><a href="#2-Proxy" class="headerlink" title="2 Proxy"></a>2 Proxy</h3><h4 id="1-构造函数-1"><a href="#1-构造函数-1" class="headerlink" title="1 构造函数"></a>1 构造函数</h4><ul>
<li><code>new Proxy(target, handler)</code><ul>
<li>返回一个Proxy实例</li>
<li><code>target</code><ul>
<li>用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）</li>
</ul>
</li>
<li><code>handler</code><ul>
<li>处理器对象，有许多拦截相应操作的函数，如果没有配置，则执行默认操作</li>
<li>注意：处理操作都是针对代理对象的，目标对象无效。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-handler"><a href="#2-handler" class="headerlink" title="2 handler"></a>2 handler</h4><ol>
<li><code>get(target, property, receiver)</code><ul>
<li>参数<ul>
<li><code>target</code><ul>
<li>目标对象</li>
</ul>
</li>
<li><code>property</code><ul>
<li>获取的属性名</li>
</ul>
</li>
<li><code>reveiver</code><ul>
<li>Proxy或者继承Proxy的对象</li>
</ul>
</li>
</ul>
</li>
<li>说明<ul>
<li>get 方法拦截属性的获取，可以返回任何值</li>
</ul>
</li>
</ul>
</li>
<li><code>set(target, property, value, receiver)</code><ul>
<li>参数<ul>
<li><code>value</code><ul>
<li>被设置的新值</li>
</ul>
</li>
</ul>
</li>
<li>说明<ul>
<li>set 方法拦截属性的设置</li>
<li>严格模式下 set 必须返回布尔值，且如果返回false会报错</li>
</ul>
</li>
</ul>
</li>
<li><code>apply(target, thisArg, argumentsList)</code><ul>
<li>参数<ul>
<li><code>target</code><ul>
<li>目标函数</li>
</ul>
</li>
<li><code>thisArg</code><ul>
<li>被调用时的上下文对象</li>
</ul>
</li>
<li><code>argumentsList</code><ul>
<li>被调用时的参数数组</li>
</ul>
</li>
</ul>
</li>
<li>说明<ul>
<li>apply 方法拦截函数调用，可以返回任何值<ol>
<li>直接调用</li>
<li><code>Function.prototype.call()</code> 方式调用</li>
<li><code>Function.prototype.apply()</code> 方式调用</li>
<li><code>Reflet.apply()</code> 方式调用</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><code>has(target, prop)</code><ul>
<li>参数<ul>
<li><code>target</code><ul>
<li>目标对象</li>
</ul>
</li>
<li><code>prop</code><ul>
<li>需要检查是否存在的属性.</li>
</ul>
</li>
</ul>
</li>
<li>说明<ul>
<li>拦截 <code>prop in object</code> 语句，返回布尔值</li>
</ul>
</li>
</ul>
</li>
<li><code>construct(target, argumentsList, newTarget)</code><ul>
<li>参数<ul>
<li><code>target</code><ul>
<li>目标构造函数</li>
</ul>
</li>
<li><code>argumentsList</code><ul>
<li>constructor的参数列表</li>
</ul>
</li>
<li><code>newTarget</code><ul>
<li>生成的代理对象（即代理构造函数）</li>
</ul>
</li>
</ul>
</li>
<li>说明<ul>
<li>拦截new操作，必须返回一个对象</li>
</ul>
</li>
</ul>
</li>
<li><code>deleteProperty(target, prop)</code><ul>
<li>拦截<code>delete</code> 操作，必须返回布尔值</li>
</ul>
</li>
<li><code>defineProperty(target, property, descriptor)</code><ul>
<li>拦截<code>Object.defineProperty()</code>，必须返回布尔值</li>
</ul>
</li>
<li><code>getOwnPropertyDescriptor(target, prop)</code><ul>
<li>拦截 <code>Object.getOwnPropertyDescriptor()</code>，必须返回一个对象或undefined</li>
</ul>
</li>
<li><code>getPrototypeOf(target)</code><ul>
<li>拦截获取原型操作</li>
</ul>
</li>
<li><code>setPrototypeOf(target, prototype)</code><ul>
<li>拦截设置原型操作，返回布尔值</li>
</ul>
</li>
<li><code>preventExtensions(target)</code><ul>
<li>拦截<code>Object.preventExtensions()</code>，返回一个布尔值</li>
</ul>
</li>
<li><code>isExtensible(target)</code><ul>
<li>拦截<code>Object.isExtensible()</code>，必须返回布尔值</li>
</ul>
</li>
<li><code>ownKeys(target)</code><ul>
<li>拦截对象获取自身属性的操作</li>
</ul>
</li>
</ol>
<h2 id="2-10-Reflect"><a href="#2-10-Reflect" class="headerlink" title="2.10 Reflect"></a>2.10 Reflect</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>Reflect不是一个构造函数，不能new，Reflect的所有属性和方法都是静态的（就像Math对象）。</li>
<li>将Object对象的一些明显属于语言内部的方法（如Object.defineProperty），放到Reflect对象上</li>
<li>修改某些Object方法的返回结果，让其变得更合理<ul>
<li>如Object.defineProperty无法定义属性时，会抛出错误，而Reflect.defineProperty会返回false</li>
</ul>
</li>
<li>让Object操作都变成函数行为<ul>
<li>如 <code>prop in object</code> ，对应<code>Reflect.has(obj, prop)</code></li>
<li><code>delete obj.prop</code>，对应<code>Reflect.deleteProperty(obj, prop)</code></li>
</ul>
</li>
<li>Reflect对象与Proxy的handler 方法完全一致，在使用代理拦截某些操作时，使用Reflect的方法可以保证原生行为能正常执行。</li>
</ol>
<h3 id="2-静态方法-1"><a href="#2-静态方法-1" class="headerlink" title="2 静态方法"></a>2 静态方法</h3><ul>
<li>见Proxy handler</li>
</ul>
<h2 id="2-11-this-amp-super"><a href="#2-11-this-amp-super" class="headerlink" title="2.11 this &amp; super"></a>2.11 this &amp; super</h2><h3 id="1-this"><a href="#1-this" class="headerlink" title="1 this"></a>1 this</h3><ol>
<li>在全局环境中 或者 在函数中<ol>
<li>非严格模式：this指向顶层对象window</li>
<li>严格模式：this为undefined</li>
</ol>
</li>
<li>在对象中，this代表当前对象的引用</li>
<li>在对象方法（对象的属性是函数则称为方法）中，this指向调用该方法的对象</li>
<li>在箭头函数中，this与定义箭头函数时所在的环境指向同一个this</li>
<li>在构造函数中，this指向正在构造的新对象</li>
<li>在DOM事件处理函数中，this指向触发事件的元素</li>
<li>在内联事件处理函数中，this指向监听器所在的DOM元素</li>
</ol>
<h3 id="2-super"><a href="#2-super" class="headerlink" title="2 super"></a>2 super</h3><ul>
<li>super指向当前对象的原型对象</li>
</ul>
<h1 id="三-数组"><a href="#三-数组" class="headerlink" title="三 数组"></a>三 数组</h1><h2 id="3-1-Array"><a href="#3-1-Array" class="headerlink" title="3.1 Array"></a>3.1 Array</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>数组都是Array对象的实例</li>
<li>数组可以存任意类型的数据</li>
<li>数组长度可变</li>
<li>ES6 明确数组中空位值为undefined</li>
<li>数组字面量<ul>
<li><code>[ele0, ele1, ..., eleN]</code></li>
</ul>
</li>
</ol>
<h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2 构造函数"></a>2 构造函数</h3><ol>
<li><code>Array()</code> 和 <code>new Array()</code> 是等同的</li>
<li><code>new Array(arrayLength)</code><ul>
<li>如果参数只有一个且是 0-2<sup>32</sup>-1 之间的整数，则创建一个指定长度的数组</li>
</ul>
</li>
<li><code>new Array(element0, element1[, ...[, elementN]])</code><ul>
<li>创建一个指定元素的数组</li>
</ul>
</li>
</ol>
<h3 id="3-静态属性"><a href="#3-静态属性" class="headerlink" title="3 静态属性"></a>3 静态属性</h3><ul>
<li><code>length</code></li>
</ul>
<h3 id="4-静态方法"><a href="#4-静态方法" class="headerlink" title="4  静态方法"></a>4  静态方法</h3><ol>
<li><code>Array.isArray(obj)</code><ul>
<li>如果值是 Array，则返回true，否则返回false</li>
<li>用来弥补<code>typeof</code>，因为<code>typeof 数组</code> 返回的是<code>object</code></li>
</ul>
</li>
<li><code>Array.of(element0[, element1[, ...[, elementN]]])</code><ul>
<li>将一组值转换为数组</li>
<li>用来弥补构造函数，构造函数参数个数不同会导致结果不同。</li>
</ul>
</li>
<li><code>Array.from(arrayLike[, mapFn[, thisArg]])</code><ul>
<li>从一个类数组对象或可迭代对象创建一个新的浅拷贝的数组实例并返回</li>
<li><code>mapFn</code><ul>
<li>如果指定了该参数，新数组中的每个元素都会执行该回调函数</li>
</ul>
</li>
<li><code>thisArg</code><ul>
<li>执行回调函数 mapFn 时的 this 对象</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="5-原型方法"><a href="#5-原型方法" class="headerlink" title="5 原型方法"></a>5 原型方法</h3><h4 id="1-获取-1"><a href="#1-获取-1" class="headerlink" title="1 获取"></a>1 获取</h4><ol>
<li><code>valueOf()</code><ul>
<li>返回数组本身</li>
</ul>
</li>
<li><code>toString()</code><ul>
<li>返回数组的字符串形式</li>
</ul>
</li>
<li><code>join([separator])</code><ul>
<li>以指定分隔符（默认为逗号）将所有数组成员连接为一个字符串返回</li>
</ul>
</li>
</ol>
<h4 id="2-增删改"><a href="#2-增删改" class="headerlink" title="2 增删改"></a>2 增删改</h4><ol>
<li><code>push(element1, ..., elementN)</code><ul>
<li>将一个或多个元素添加到数组的末尾，并返回该数组的新长度，改变原数组</li>
<li>如果参数为数组，把数组作为元素添加到数组中。(二维数组)</li>
</ul>
</li>
<li><code>pop()</code><ul>
<li>删除并返回最后一个元素，改变原数组</li>
</ul>
</li>
<li><code>unshift(element1, ..., elementN)</code><ul>
<li>将一个或多个元素添加到数组的开头，并返回该数组的新长度，改变原数组</li>
<li>参数可以是数组（二维数组）</li>
</ul>
</li>
<li><code>shift()</code><ul>
<li>删除并返回第一个元素，改变原数组</li>
</ul>
</li>
<li><code>fill(value[, start[, end]])</code><ul>
<li>使用指定值填充数组，可指定开始结束索引，返回修改后的数组</li>
</ul>
</li>
<li><code>slice([begin[, end]])</code><ul>
<li>提取目标数组的一部分，返回一个浅拷贝新数组，原数组不变</li>
</ul>
</li>
<li><code>splice(start[, deleteCount[, item1[, item2[, ...]]]])</code><ul>
<li>删除目标数组的一部分成员，并可以在删除的位置添加新的数组成员，返回被删除的元素组成的数组，改变原数组</li>
</ul>
</li>
<li><code>concat(value1, value2, ..., valueN)</code><ul>
<li>将一个或多个值合并到数组中，返回新数组，不改变原数组</li>
</ul>
</li>
<li><code>copyWithin(target[, start[, end]])</code><ul>
<li>复制数组的一部分到数组指定位置（覆盖原有成员），并返回数组，改变原数组但不改变数组长度（因为会覆盖原有成员）</li>
<li><code>target</code><ul>
<li>目标位置</li>
</ul>
</li>
<li><code>start</code><ul>
<li>复制的起始索引，默认为0</li>
</ul>
</li>
<li><code>end</code><ul>
<li>复制的终止索引（不含），默认为尾部</li>
</ul>
</li>
</ul>
</li>
<li><code>flat([depth])</code><ul>
<li>将数组降维，返回新数组，不改变原数组</li>
<li><code>depth</code><ul>
<li>指定结构深度，默认值为 1，即只可以将二维数组合并成一维数组</li>
</ul>
</li>
</ul>
</li>
<li><code>flatMap(callback[, thisArg])</code><ul>
<li>对数组中每一个元素执行回调函数，然后对返回值组成的数组执行flat()方法，结构深度 depth 值为1，返回新数组</li>
<li><code>callback(currentValue[, index[, array]])</code><ul>
<li><code>currentValue</code>：当前遍历的元素</li>
<li><code>index</code>：当前遍历到的索引</li>
<li><code>array</code>：当前数组</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="3-查"><a href="#3-查" class="headerlink" title="3 查"></a>3 查</h4><ol>
<li><code>indexOf(searchElement[, fromIndex])</code><ul>
<li>返回第一个匹配索引，如果不存在，则返回-1</li>
</ul>
</li>
<li><code>lastIndexOf(searchElement[, fromIndex])</code><ul>
<li>返回从后往前的第一个匹配索引，如果不存在，则返回-1</li>
</ul>
</li>
<li><code>includes(valueToFind[, fromIndex])</code><ul>
<li>判断数组是否包含指定元素</li>
</ul>
</li>
<li><code>find(callback[, thisArg])</code><ul>
<li>返回数组中第一个满足所提供测试函数（返回true）的元素的值，否则返回 undefined</li>
<li><code>callback(element[, index[, array]])</code><ul>
<li><code>element</code>：当前遍历的元素</li>
<li><code>index</code>：当前遍历到的索引</li>
<li><code>array</code>：当前数组</li>
</ul>
</li>
<li><code>thisArg</code><ul>
<li>执行回调时函数时this 指向的对象。</li>
</ul>
</li>
</ul>
</li>
<li><code>findIndex(callback[, thisArg])</code><ul>
<li>返回数组中第一个满足所提供测试函数（返回true）的元素的索引，否则返回 -1</li>
</ul>
</li>
</ol>
<h4 id="4-排序"><a href="#4-排序" class="headerlink" title="4 排序"></a>4 排序</h4><ol>
<li><code>reverse()</code><ul>
<li>反转数组并返回，改变原数组</li>
</ul>
</li>
<li><code>sort([compareFunction])</code><ul>
<li>默认是按照字典顺序排序，返回排序后的数组，改变原数组</li>
<li><code>compareFunction(value1, value2)</code><ul>
<li>返回一个数字，如果小于0则value1排在value2之前</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="5-循环遍历"><a href="#5-循环遍历" class="headerlink" title="5 循环遍历"></a>5 循环遍历</h4><ol>
<li><code>forEach(callback[, thisArg])</code><ul>
<li><code>callback(currentValue[, index[, array]])</code><ul>
<li><code>currentValue</code>：当前遍历的元素</li>
<li><code>index</code>：当前遍历到的索引</li>
<li><code>array</code>：当前数组</li>
</ul>
</li>
</ul>
</li>
<li><code>keys()</code><ul>
<li>返回数组元素键的迭代器对象</li>
</ul>
</li>
<li><code>values()</code><ul>
<li>返回数组元素值的迭代器对象</li>
</ul>
</li>
<li><code>entries()</code><ul>
<li>返回数组元素键值对的迭代器对象</li>
</ul>
</li>
</ol>
<h4 id="6-扩展方法"><a href="#6-扩展方法" class="headerlink" title="6 扩展方法"></a>6 扩展方法</h4><ol>
<li><code>every(callback[, thisArg])</code><ul>
<li>判断数组元素是否全部能通过指定测试函数，返回布尔值，碰到一个元素返回false，则every立即返回false</li>
<li><code>callback(element[, index[, array]])</code><ul>
<li><code>element</code>：当前遍历的元素</li>
<li><code>index</code>：当前遍历到的索引</li>
<li><code>array</code>：当前数组</li>
</ul>
</li>
</ul>
</li>
<li><code>some(callback[, thisArg])</code><ul>
<li>数组中有至少一个元素通过回调函数的测试就会返回true；</li>
</ul>
</li>
<li><code>filter(callback[, thisArg])</code><ul>
<li>返回一个新的由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组</li>
</ul>
</li>
<li><code>map(callback[, thisArg])</code><ul>
<li>对数组中每一个元素执行回调函数，返回每一个回调函数结果组成的新数组</li>
</ul>
</li>
<li><code>reduce(callback[, initialValue])</code><ul>
<li>返回回调函数累计处理的结果</li>
<li><code>callback(accumulator, currentValue[, index[, array]])</code><ul>
<li><code>accumulator</code><ul>
<li>第一次循环<ol>
<li>有<code>initialValue</code>，则为<code>initialValue</code></li>
<li>无<code>initialValue</code>，则为数组第一个元素</li>
</ol>
</li>
<li>从第二次循环往后为回调函数返回值</li>
</ul>
</li>
<li><code>currentValue</code><ul>
<li>数组中当前循环的元素</li>
<li>第一次循环时，如果没有<code>initialValue</code>，由于<code>accumulator</code>是数组第一个元素，则<code>currentValue</code>会从第二个元素开始循环</li>
</ul>
</li>
<li><code>index</code><ul>
<li>数组中当前循环的元素的索引</li>
</ul>
</li>
<li><code>array</code><ul>
<li>当前数组</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>reduceRight(callback[, initialValue])</code><ul>
<li>与<code>reduce()</code>相似，只是从右向左遍历数组</li>
</ul>
</li>
</ol>
<h1 id="四-函数"><a href="#四-函数" class="headerlink" title="四 函数"></a>四 函数</h1><h2 id="4-1-Function"><a href="#4-1-Function" class="headerlink" title="4.1 Function"></a>4.1 Function</h2><h3 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1 概述"></a>1 概述</h3><ul>
<li>每个 JavaScript 函数都是一个 Function 对象</li>
</ul>
<h3 id="2-构造函数-1"><a href="#2-构造函数-1" class="headerlink" title="2 构造函数"></a>2 构造函数</h3><ul>
<li><code>new Function ([arg1[, arg2[, ...argN]],] functionBody)</code><ul>
<li><code>arg1, arg2, ... argN</code><ul>
<li>字符串，字符串中多个参数用逗号分隔</li>
</ul>
</li>
<li><code>functionBody</code><ul>
<li>函数体的字符串</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-静态属性-1"><a href="#3-静态属性-1" class="headerlink" title="3 静态属性"></a>3 静态属性</h3><ol>
<li><code>Function.length</code><ul>
<li>函数的形参个数</li>
</ul>
</li>
<li><code>Function.name</code><ul>
<li>函数的名称</li>
</ul>
</li>
</ol>
<h3 id="4-原型方法"><a href="#4-原型方法" class="headerlink" title="4 原型方法"></a>4 原型方法</h3><ol>
<li><code>call(thisArg, arg1, arg2, ...)</code><ul>
<li>使用指定的 this 值和参数列表来调用此函数</li>
<li><code>thisArg</code><ul>
<li>函数运行时this的值</li>
</ul>
</li>
<li>与 bind 不同 call/apply 会立即执行函数</li>
</ul>
</li>
<li><code>apply(thisArg, [argsArray])</code><ul>
<li>同<code>call()</code>，不同的是接受的是一个参数数组</li>
</ul>
</li>
<li><code>bind(thisArg[, arg1[, arg2[, ...]]])</code><ul>
<li>使用指定的this和参数列表创建一个原函数的拷贝并返回</li>
<li>call() 和 apply() 用来执行函数，bind()用来创建函数，即不会立即执行</li>
<li>bind设置的参数优先级高（即调用时设置的相应参数无效）</li>
</ul>
</li>
<li><code>toString()</code><ul>
<li>返回表示函数源代码的字符串</li>
</ul>
</li>
</ol>
<h2 id="4-2-立即执行函数（IIFE-Imdiately-Invoked-Function-Expression）"><a href="#4-2-立即执行函数（IIFE-Imdiately-Invoked-Function-Expression）" class="headerlink" title="4.2 立即执行函数（IIFE Imdiately Invoked Function Expression）"></a>4.2 立即执行函数（IIFE Imdiately Invoked Function Expression）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 (function()&#123;...&#125;())</span><br><span class="line">2 (function()&#123;...&#125;)()</span><br></pre></td></tr></table></figure>
<ol>
<li>不必为函数命名</li>
<li>形成单独的作用域，封装遍历，避免重名…</li>
</ol>
<h2 id="4-3-定义函数"><a href="#4-3-定义函数" class="headerlink" title="4.3 定义函数"></a>4.3 定义函数</h2><h3 id="1-函数声明"><a href="#1-函数声明" class="headerlink" title="1 函数声明"></a>1 函数声明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function 函数名(参数列表) &#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>函数提升，提升优先级高于var变量提升</li>
<li>函数会添加到window对象中</li>
<li>优先级高于函数表达式</li>
</ol>
<h3 id="2-函数表达式"><a href="#2-函数表达式" class="headerlink" title="2 函数表达式"></a>2 函数表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var/let/const 函数名 = function (参数列表) &#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>函数不会提升</li>
<li>var声明的函数会添加到window对象中，但let/const则不会</li>
</ol>
<h3 id="3-Function构造函数"><a href="#3-Function构造函数" class="headerlink" title="3 Function构造函数"></a>3 Function构造函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var/let/const 函数名 = new Function(&quot;参数列表&quot;,&quot;函数体&quot;);</span><br></pre></td></tr></table></figure>
<ol>
<li>函数不会提升</li>
<li>var声明的函数会添加到window对象中，但let/const则不会</li>
</ol>
<h2 id="4-4-参数"><a href="#4-4-参数" class="headerlink" title="4.4 参数"></a>4.4 参数</h2><h3 id="1-形参-amp-实参"><a href="#1-形参-amp-实参" class="headerlink" title="1 形参 &amp; 实参"></a>1 形参 &amp; 实参</h3><ul>
<li>形参是默认声明的，不用var/let/const修饰</li>
<li>实参数量小于形参时，没有传递的形参值为 undefined</li>
<li>实参数量大于形参时，多余的实参将忽略并不会报错</li>
</ul>
<h3 id="2-参数默认值"><a href="#2-参数默认值" class="headerlink" title="2 参数默认值"></a>2 参数默认值</h3><ul>
<li>在形参上可以直接定义参数默认值，如果传递对应参数则使用传递值，否则使用默认值</li>
</ul>
<h3 id="3-arguments"><a href="#3-arguments" class="headerlink" title="3 arguments"></a>3 arguments</h3><ul>
<li>arguments 对象是所有（非箭头）函数中都可用的局部变量，是一个类数组对象，存储了传递的实参</li>
</ul>
<h2 id="4-5-箭头函数"><a href="#4-5-箭头函数" class="headerlink" title="4.5 箭头函数"></a>4.5 箭头函数</h2><h3 id="1-概述-4"><a href="#1-概述-4" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>箭头函数内部的<code>this</code> 是固定的，指向定义时所在的环境的this</li>
<li>箭头函数不可以当作构造函数，也就是说，不可以使用new命令</li>
<li>箭头函数内部不存在<code>arguments</code> 对象</li>
<li>箭头函数不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数</li>
</ol>
<h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2 语法"></a>2 语法</h3><ol>
<li>基础语法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(param1, param2, …, paramN) =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure></li>
<li>没有参数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">() =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure></li>
<li>只有一个参数，小括号可以省略<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">singleParam =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure></li>
<li>函数体只有一句，return、分号和大括号都可以省略<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(param1, param2, …, paramN) =&gt; expression</span><br><span class="line">//相当于</span><br><span class="line">(param1, param2, …, paramN) =&gt;&#123; return expression; &#125;</span><br><span class="line">// 返回对象</span><br><span class="line">(param1, param2, …, paramN) =&gt; (&#123;name: &apos;xiaoming&apos;&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：如果返回的是一个对象，要用<code>()</code>包括，因为<code>{}</code>会被认为是一个代码块</li>
</ul>
</li>
</ol>
<h1 id="五-集合"><a href="#五-集合" class="headerlink" title="五 集合"></a>五 集合</h1><h2 id="5-1-Set"><a href="#5-1-Set" class="headerlink" title="5.1 Set"></a>5.1 Set</h2><h3 id="1-概述-5"><a href="#1-概述-5" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>Set中的元素有序（存取顺序一致） 唯一</li>
<li>基本数据类型和引用数据类型都可以存储（包括NaN，undefined和null）</li>
<li>元素相等 基于 <code>sameValueZero</code> 算法<ul>
<li>类似<code>===</code>，除了NaN不同，<code>NaN === NaN</code>返回false，但是在Set中看作相等</li>
</ul>
</li>
</ol>
<h3 id="2-构造函数-2"><a href="#2-构造函数-2" class="headerlink" title="2 构造函数"></a>2 构造函数</h3><ul>
<li><code>new Set([iterable])</code><ul>
<li><code>iterable</code><ul>
<li>可迭代对象，它的所有元素将不重复地被添加到 Set中。</li>
<li>如果省略或其值为null，则新的 Set为空</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-原型属性"><a href="#3-原型属性" class="headerlink" title="3 原型属性"></a>3 原型属性</h3><ol>
<li><code>size</code><ul>
<li>返回Set对象中元素的个数</li>
</ul>
</li>
</ol>
<h3 id="4-原型方法-1"><a href="#4-原型方法-1" class="headerlink" title="4 原型方法"></a>4 原型方法</h3><ol>
<li><code>add(value)</code><ul>
<li>向Set末尾添加元素，返回Set</li>
</ul>
</li>
<li><code>delete(value)</code><ul>
<li>从Set 中删除指定元素，成功删除返回 true，否则返回 false</li>
</ul>
</li>
<li><code>has(value)</code><ul>
<li>判断Set中是否有指定的元素</li>
</ul>
</li>
<li><code>clear()</code><ul>
<li>清空Set</li>
</ul>
</li>
<li><code>keys()</code><ul>
<li>由于 Set 结构没有键，只有值，keys() 与 values() 完全一样</li>
</ul>
</li>
<li><code>values()</code><ul>
<li>返回值的迭代器对象</li>
</ul>
</li>
<li><code>entries()</code><ul>
<li>返回键值对的迭代器对象</li>
<li>键值对形式为<code>[value, value]</code>，即Set中的元素即是键也是值</li>
</ul>
</li>
<li><code>forEach(callback[, thisArg])</code> <ul>
<li>根据集合中元素的插入顺序，依次执行提供的回调函数</li>
<li><code>callback([currentValue[, currentKey[, set]]])</code><ul>
<li><code>currentValue</code><ul>
<li>当前元素</li>
</ul>
</li>
<li><code>currentKey</code><ul>
<li>由于Set没有键，currentKey与currentValue永远都一样，即也是当前元素</li>
</ul>
</li>
<li><code>set</code><ul>
<li>当前Set</li>
</ul>
</li>
</ul>
</li>
<li><code>thisArg</code><ul>
<li>回调函数执行过程中的 this 值</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="6-Set转数组"><a href="#6-Set转数组" class="headerlink" title="6 Set转数组"></a>6 Set转数组</h3><ol>
<li>展开语法<ul>
<li><code>...set</code></li>
</ul>
</li>
<li><code>Array.from(set)</code></li>
</ol>
<h2 id="5-2-WeakSet"><a href="#5-2-WeakSet" class="headerlink" title="5.2 WeakSet"></a>5.2 WeakSet</h2><ol>
<li>用法同Set大致相同</li>
<li>与Set的区别<ol>
<li>WeakSet只能存引用数据类型</li>
<li>WeakSet是弱引用<ul>
<li>当对象引用数量为0时，会被垃圾回收掉，弱引用的意思就是不会增加对象的引用数量。</li>
</ul>
</li>
<li>WeakSet 不可遍历<ul>
<li>因为WeakSet弱引用，其中的对象随时有可能别垃圾回收掉</li>
</ul>
</li>
<li>没有<code>size</code> 属性</li>
<li>原型方法只有 <code>add() delete() has()</code></li>
</ol>
</li>
</ol>
<h2 id="5-3-Map"><a href="#5-3-Map" class="headerlink" title="5.3 Map"></a>5.3 Map</h2><h3 id="1-概述-6"><a href="#1-概述-6" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>Map是键值对的集合，且键有序（存取一致）</li>
<li>对象的键只能是字符串，Map的键可以是任何值</li>
<li>如果键相等，后边的值回覆盖前边，键相等 基于 <code>sameValueZero</code> 算法<ul>
<li>类似<code>===</code>，除了NaN不同，<code>NaN === NaN</code>返回false，但是在Map中看作相等</li>
</ul>
</li>
</ol>
<h3 id="2-构造函数-3"><a href="#2-构造函数-3" class="headerlink" title="2 构造函数"></a>2 构造函数</h3><ul>
<li><code>new Map([iterable])</code><ul>
<li><code>iterable</code><ul>
<li>可迭代对象，其元素为键值对。</li>
<li>如数组为 <code>[[&#39;name&#39;,&#39;xiaoming&#39;],[&#39;age&#39;,18]]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-原型属性-1"><a href="#3-原型属性-1" class="headerlink" title="3 原型属性"></a>3 原型属性</h3><ol>
<li><code>size</code><ul>
<li>返回Map中键值对的个数</li>
</ul>
</li>
</ol>
<h3 id="4-原型方法-2"><a href="#4-原型方法-2" class="headerlink" title="4 原型方法"></a>4 原型方法</h3><ol>
<li><code>set(key, value)</code><ul>
<li>向Map添加元素，返回Map</li>
</ul>
</li>
<li><code>get(key)</code><ul>
<li>根据key获取value，没有返回undefined</li>
</ul>
</li>
<li><code>delete(key)</code><ul>
<li>根据key删除元素，删除成功返回true，否则返回false</li>
</ul>
</li>
<li><code>clear()</code><ul>
<li>清空Map</li>
</ul>
</li>
<li><code>has(key)</code><ul>
<li>判断指定key的元素是否存在</li>
</ul>
</li>
<li><code>keys()</code><ul>
<li>返回键的迭代器对象</li>
</ul>
</li>
<li><code>values()</code><ul>
<li>返回值的迭代器对象</li>
</ul>
</li>
<li><code>entries()</code><ul>
<li>返回键值对<code>[key, value]</code>的迭代器对象</li>
</ul>
</li>
<li><code>forEach(callback[, thisArg])</code><ul>
<li>根据集合中元素的插入顺序，依次执行提供的回调函数</li>
<li><code>callback([value[, key[, map]]])</code></li>
</ul>
</li>
</ol>
<h3 id="5-Map转数组"><a href="#5-Map转数组" class="headerlink" title="5 Map转数组"></a>5 Map转数组</h3><ul>
<li>展开语法<ul>
<li><code>...map</code></li>
</ul>
</li>
</ul>
<h2 id="5-4-WeakMap"><a href="#5-4-WeakMap" class="headerlink" title="5.4 WeakMap"></a>5.4 WeakMap</h2><ol>
<li>用法同Map大致相同</li>
<li>与Map的区别<ol>
<li>WeakMap的键只能是引用数据类型（不能为null）</li>
<li>WeakMap的键是弱引用</li>
<li>WeakMap不能遍历</li>
<li>WeakMap没有<code>size</code>属性</li>
<li>WeakMap原型方法只有 <code>set() get() delete() has()</code></li>
</ol>
</li>
</ol>
<h1 id="六-Date"><a href="#六-Date" class="headerlink" title="六 Date"></a>六 Date</h1><h2 id="6-1-构造函数"><a href="#6-1-构造函数" class="headerlink" title="6.1 构造函数"></a>6.1 构造函数</h2><ol>
<li><code>Date([value])</code><ul>
<li>普通函数，无论有没有参数，都返回当前日期和时间的字符串</li>
</ul>
</li>
<li><code>new Date()</code><ol>
<li><code>new Date()</code><ul>
<li>创建一个当前日期和时间的Date对象</li>
</ul>
</li>
<li><code>new Date(value)</code><ul>
<li><code>value</code><ul>
<li>Unix 时间戳，是一个整数值，表示自1970年1月1日00:00:00 UTC（the Unix epoch）以来的毫秒数</li>
</ul>
</li>
</ul>
</li>
<li><code>new Date(dateString)</code><ul>
<li><code>dateString</code><ul>
<li>表示日期的字符串。该字符串能被 <code>Date.parse()</code>正确识别</li>
</ul>
</li>
</ul>
</li>
<li><code>new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]])</code><ul>
<li>分别指定年月日时分秒毫秒</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="6-2-静态方法"><a href="#6-2-静态方法" class="headerlink" title="6.2 静态方法"></a>6.2 静态方法</h2><ol>
<li><code>Date.now()</code><ul>
<li>返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数</li>
</ul>
</li>
<li><code>Date.parse(dateString)</code><ul>
<li>解析日期字符串，返回该时间距离时间零点的毫秒数。</li>
</ul>
</li>
<li><code>Date.UTC(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]])</code><ul>
<li>返回该时间距离时间零点的毫秒数</li>
</ul>
</li>
</ol>
<h2 id="6-3-原型方法"><a href="#6-3-原型方法" class="headerlink" title="6.3 原型方法"></a>6.3 原型方法</h2><h3 id="1-to"><a href="#1-to" class="headerlink" title="1 to"></a>1 to</h3><ol>
<li><code>valueOf()</code><ul>
<li>返回实例对象距离时间零点对应的毫秒数，同<code>getTime()</code></li>
</ul>
</li>
<li><code>toString()</code> / <code>toDateString()</code> / <code>toTimeString()</code><ul>
<li>返回一个日期时间字符串 / 日期字符串 / 时间字符串</li>
</ul>
</li>
<li><code>toLocaleString()</code> / <code>toLocaleDateString()</code> / <code>toLocaleTimeString()</code><ul>
<li>返回一个本地日期时间字符串 / 本地日期字符串 / 本地时间字符串</li>
</ul>
</li>
<li><code>toUTCString()</code><ul>
<li>返回使用UTC时区表示给定日期的字符串，比北京时间晚8个小时</li>
</ul>
</li>
<li><code>toISOString()</code><ul>
<li>返回对应时间的 ISO8601 写法的字符串</li>
</ul>
</li>
<li><code>toJSON()</code><ul>
<li>返回一个符合 JSON 格式的 ISO 日期字符串，与<code>toISOString()</code>方法的返回结果完全相同</li>
</ul>
</li>
</ol>
<h3 id="2-get"><a href="#2-get" class="headerlink" title="2 get"></a>2 get</h3><ol>
<li><code>getTime()</code><ul>
<li>返回Date实例距离事件元点的毫秒数</li>
</ul>
</li>
<li><code>getFullYear</code><ul>
<li>四位数的年份</li>
</ul>
</li>
<li><code>getMonth()</code><ul>
<li>月 0-11</li>
</ul>
</li>
<li><code>getDate()</code><ul>
<li>日 1-31</li>
</ul>
</li>
<li><code>getDay()</code><ul>
<li>星期 0-6</li>
</ul>
</li>
<li><code>getHours()</code><ul>
<li>时 0-23</li>
</ul>
</li>
<li><code>getMinutes()</code><ul>
<li>分 0-59</li>
</ul>
</li>
<li><code>getSeconds()</code><ul>
<li>秒 0-59</li>
</ul>
</li>
<li><code>getMilliseconds</code><ul>
<li>毫秒 0-999</li>
</ul>
</li>
</ol>
<h3 id="3-set"><a href="#3-set" class="headerlink" title="3 set"></a>3 set</h3><ul>
<li>set 与 get 一一相对应，除了没有 <code>setDay()</code>，因为星期是算的</li>
</ul>
<h1 id="七-RegExp"><a href="#七-RegExp" class="headerlink" title="七 RegExp"></a>七 RegExp</h1><h2 id="7-1-构造函数"><a href="#7-1-构造函数" class="headerlink" title="7.1 构造函数"></a>7.1 构造函数</h2><ol>
<li><code>RegExp()</code> 和 <code>new RegExp()</code> 一样，返回正则对象</li>
<li><code>new RegExp(pattern [, flags])</code> <ul>
<li><code>pattern</code><ul>
<li>正则表达式的文本</li>
</ul>
</li>
<li><code>flags</code><ul>
<li>修饰符，可以是<code>g i m u y s</code>的任意组合</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="7-2-字面量"><a href="#7-2-字面量" class="headerlink" title="7.2 字面量"></a>7.2 字面量</h2><ul>
<li><code>/pattern/flags</code><ul>
<li><code>/</code> 斜杠表示开始和结束</li>
</ul>
</li>
</ul>
<h2 id="7-3-原型属性"><a href="#7-3-原型属性" class="headerlink" title="7.3 原型属性"></a>7.3 原型属性</h2><ol>
<li><code>global</code><ul>
<li>只读，返回一个布尔值，判断是否设置了修饰符<code>g</code></li>
</ul>
</li>
<li><code>ignoreCase</code><ul>
<li>只读，返回一个布尔值，判断是否设置了修饰符<code>i</code></li>
</ul>
</li>
<li><code>multiline</code><ul>
<li>只读，返回一个布尔值，判断是否设置了修饰符<code>m</code></li>
</ul>
</li>
<li><code>unicode</code><ul>
<li>只读，返回一个布尔值，判断是否设置了修饰符<code>u</code></li>
</ul>
</li>
<li><code>sticky</code><ul>
<li>只读，返回一个布尔值，判断是否设置了修饰符<code>y</code></li>
</ul>
</li>
<li><code>dotAll</code><ul>
<li>只读，返回一个布尔值，判断是否设置了修饰符<code>s</code></li>
</ul>
</li>
<li><code>flags</code><ul>
<li>只读，返回一个字符串，包含已经设置的所有修饰符，按字母排序</li>
</ul>
</li>
<li><code>source</code><ul>
<li>只读，返回正则表达式文本字符串，该字符串不包含正则字面量两边的斜杠以及任何的标志字符    </li>
</ul>
</li>
<li><code>lastIndex</code><ul>
<li>可读写，用来指定下一次匹配的起始索引。只有正则表达式使用了表示全局检索的 “g” 标志时，该属性才会起作用</li>
</ul>
</li>
</ol>
<h2 id="7-4-原型方法"><a href="#7-4-原型方法" class="headerlink" title="7.4 原型方法"></a>7.4 原型方法</h2><ol>
<li><code>test(str)</code><ul>
<li>如果正则表达式与指定的字符串匹配 ，返回true；否则false</li>
<li>更新正则对象的<code>lastIndex</code>属性</li>
</ul>
</li>
<li><code>exec(str)</code><ul>
<li>如果匹配成功，返回一个数组且具有详细信息，并更新正则表达式对象的 lastIndex 属性。<ul>
<li>当正则有g标志时，可以多次执行 exec 方法来查找同一个字符串中的成功匹配，且查找将从正则表达式的 lastIndex 属性指定的位置开始</li>
</ul>
</li>
<li>如果匹配失败，返回 null，并将 lastIndex 重置为 0 </li>
</ul>
</li>
</ol>
<h1 id="八-JSON"><a href="#八-JSON" class="headerlink" title="八 JSON"></a>八 JSON</h1><h2 id="8-1-语法"><a href="#8-1-语法" class="headerlink" title="8.1 语法"></a>8.1 语法</h2><ol>
<li>属性名称必须是双引号括起来的字符串；最后一个属性后不能有逗号</li>
<li>基本类型的值<ol>
<li>字符串</li>
<li>数值（必须十进制，NaN不行）</li>
<li>布尔值</li>
<li>null（undefined不行）</li>
</ol>
</li>
<li>引用类型的值<ol>
<li>数组</li>
<li>对象</li>
</ol>
</li>
</ol>
<h2 id="8-2-静态方法"><a href="#8-2-静态方法" class="headerlink" title="8.2 静态方法"></a>8.2 静态方法</h2><ol>
<li><code>JSON.stringify(value[, replacer [, space]])</code><ul>
<li>将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被<code>parse()</code>方法还原。</li>
<li><code>value</code><ul>
<li>要被序列化的对象</li>
<li>如果对象有自定义的<code>toJSON()</code>方法，那么<code>JSON.stringify()</code>会使用<code>toJSON()</code>方法的返回值作为参数</li>
</ul>
</li>
<li><code>replacer</code><ol>
<li>如果是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的处理</li>
<li>如果是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中</li>
</ol>
</li>
<li><code>space</code>：<ul>
<li>指定缩进用的空白字符串，用于美化输出（pretty-print）增加可读性。<ol>
<li>如果是数字，表示每个属性前面添加的空格（不超过10个）</li>
<li>如果是字符串（不超过10个字符），则该字符串会添加在每行前面</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><code>JSON.parse(text[, reviver])</code><ul>
<li>将 JSON 字符串转换成对应的对象</li>
<li><code>reviver(currentKey, currentValue)</code><ul>
<li>转换器，此函数调用时机在parse 函数返回之前，用于在返回之前对所得到的对象执行操作  </li>
<li>转成的对象的所有属性都会调用reviver 函数，并且会将reviver返回值作为新的属性值，如果reviver返回undefined，会删除当前属性</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="九-Error"><a href="#九-Error" class="headerlink" title="九 Error"></a>九 Error</h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><ul>
<li>当代码运行时的发生错误，会创建新的Error 对象，并将其抛出</li>
</ul>
<h2 id="9-2-构造函数"><a href="#9-2-构造函数" class="headerlink" title="9.2 构造函数"></a>9.2 构造函数</h2><ul>
<li><code>new Error([message])</code></li>
</ul>
<h2 id="9-3-原型属性"><a href="#9-3-原型属性" class="headerlink" title="9.3 原型属性"></a>9.3 原型属性</h2><ol>
<li><code>message</code><ul>
<li>错误信息</li>
</ul>
</li>
<li><code>name</code><ul>
<li>error类型的名称.初始值为<code>Error</code></li>
</ul>
</li>
</ol>
<h2 id="9-4-其它类型的错误构造函数"><a href="#9-4-其它类型的错误构造函数" class="headerlink" title="9.4 其它类型的错误构造函数"></a>9.4 其它类型的错误构造函数</h2><ol>
<li><code>EvalError</code><ul>
<li>错误原因：与 eval() 有关</li>
</ul>
</li>
<li><code>RangeError</code><ul>
<li>错误原因：数值变量或参数超出其有效范围</li>
</ul>
</li>
<li><code>ReferenceError</code><ul>
<li>错误原因：无效引用</li>
</ul>
</li>
<li><code>SyntaxError</code><ul>
<li>错误原因：语法错误</li>
</ul>
</li>
<li><code>TypeError</code><ul>
<li>错误原因：变量或参数不属于有效类型</li>
</ul>
</li>
<li><code>URIError</code><ul>
<li>错误原因：给 encodeURI()或  decodeURl()传递的参数无效</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>UI</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript 基本数据类型</title>
    <url>/anyeansan.github.io/2020/03/30/Javascript-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="一-number"><a href="#一-number" class="headerlink" title="一 number"></a>一 number</h1><h2 id="1-1-数值"><a href="#1-1-数值" class="headerlink" title="1.1 数值"></a>1.1 数值</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>任意数字</code></td>
<td>整数或者浮点数</td>
</tr>
<tr>
<td><code>+Infinity</code></td>
<td>正无穷</td>
</tr>
<tr>
<td><code>-Infinity</code></td>
<td>负无穷</td>
</tr>
<tr>
<td><code>NaN</code></td>
<td>not a number 一个不是数字的数字类型</td>
</tr>
<tr>
<td>1. JavaScript的number类型为双精度IEEE 754 64位浮点类型。范围（-2<sup>53</sup>- 2<sup>53</sup>）</td>
<td></td>
</tr>
<tr>
<td>2. JavaScript 内部，整数和浮点数采用的是同样的储存方法。所以<code>1===1.0</code> 为true</td>
<td></td>
</tr>
<tr>
<td>3. 进制</td>
<td></td>
</tr>
<tr>
<td>* 十进制</td>
<td></td>
</tr>
<tr>
<td>* 二进制：以<code>0b</code>开头</td>
<td></td>
</tr>
<tr>
<td>* 八进制：以<code>0o</code>开头</td>
<td></td>
</tr>
<tr>
<td>* 十六进制：以<code>0x</code>开头</td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-2-Number（包装类）"><a href="#1-2-Number（包装类）" class="headerlink" title="1.2 Number（包装类）"></a>1.2 Number（包装类）</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><ol>
<li><code>Number([value])</code><ul>
<li>普通函数，作用是类型转换，将value转成一个数值number<ol>
<li>如果参数为空，返回<code>0</code></li>
<li>如果参数无法被转换为数字，则返回 <code>NaN</code></li>
</ol>
</li>
</ul>
</li>
<li><code>new Number([value])</code><ul>
<li>构造函数，创建一个Number对象，值为value转换成的数值</li>
</ul>
</li>
</ol>
<h3 id="2-静态属性"><a href="#2-静态属性" class="headerlink" title="2 静态属性"></a>2 静态属性</h3><ol>
<li><code>Number.POSITIVE_INFINITY</code><ul>
<li>正的无限，指向 <code>+Infinity</code></li>
</ul>
</li>
<li><code>Number.NEGATIVE_INFINITY</code><ul>
<li>负的无限，指向 <code>-Infinity</code></li>
</ul>
</li>
<li><code>Number.NaN</code><ul>
<li>表示<code>NaN</code></li>
</ul>
</li>
<li><code>Number.MIN_VALUE</code><ul>
<li>表示在 JavaScript 中所能表示的最小的正值</li>
</ul>
</li>
<li><code>Number.MAX_VALUE</code><ul>
<li>表示在 JavaScript 里所能表示的最大数值</li>
</ul>
</li>
<li><code>Number.MIN_SAFE_INTEGER</code><ul>
<li>表示在 JavaScript 中能够准确表示的整数范围下限（-(2<sup>53</sup> - 1)）</li>
</ul>
</li>
<li><code>Number.MAX_SAFE_INTEGER</code><ul>
<li>表示在 JavaScript 中能够准确表示的整数范围上限（2<sup>53</sup> - 1）</li>
</ul>
</li>
<li><code>Number.EPSILON</code><ul>
<li>表示 1 与大于 1 的最小的浮点数之间的差值</li>
<li>实际上是 JavaScript 能够表示的最小精度</li>
</ul>
</li>
</ol>
<h3 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="3 静态方法"></a>3 静态方法</h3><ol>
<li><code>Number.isNaN(value)</code><ul>
<li>判断给定的值是否是 NaN。</li>
<li>和全局函数<code>isNaN()</code> 的区别<ul>
<li>全局函数 <code>isNaN()</code> 会先将非数值转换为数值，再进行判断</li>
<li><code>Number.isNaN()</code> 只对数值有效，非数值直接返回false</li>
</ul>
</li>
</ul>
</li>
<li><code>Number.isFinite(value)</code><ul>
<li>判断给定的值是否是有穷数</li>
<li>和全局函数<code>isFinite()</code> 函数的区别<ul>
<li>全局函数 <code>isFinite()</code> 会先将非数值转换为数值，再进行判断</li>
<li><code>Number.isFinite()</code> 只对数值有效，非数值直接返回false</li>
</ul>
</li>
</ul>
</li>
<li><code>Number.isInteger(value)</code><ul>
<li>判断给定值是否是整数</li>
</ul>
</li>
<li><code>Number.parseInt(string[, radix])</code><ul>
<li>将一个字符串转换成指定进制的整数</li>
<li><code>radix</code><ul>
<li>指定进制（2-36），默认10</li>
</ul>
</li>
<li>同 全局函数 <code>parseInt()</code>，移植到Number上，目的是逐步减少全局性方法，使得语言逐步模块化</li>
</ul>
</li>
<li><code>Number.parseFloat(string)</code><ul>
<li>把一个字符串解析成浮点数</li>
<li>同 全局函数<code>parseFloat()</code>，移植到Number上，目的是逐步减少全局性方法，使得语言逐步模块化</li>
</ul>
</li>
</ol>
<h3 id="4-原型方法"><a href="#4-原型方法" class="headerlink" title="4 原型方法"></a>4 原型方法</h3><ol>
<li><code>valueOf()</code><ul>
<li>返回基本类型的值</li>
</ul>
</li>
<li><code>toString([radix])</code><ul>
<li>返回字符串形式</li>
</ul>
</li>
<li><code>toFixed([digits])</code><ul>
<li>返回保留指定位数浮点数的字符串</li>
<li><code>digits</code><ul>
<li>小数点后数字的个数，默认为0</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="1-3-Math"><a href="#1-3-Math" class="headerlink" title="1.3 Math"></a>1.3 Math</h2><h3 id="1-静态属性"><a href="#1-静态属性" class="headerlink" title="1 静态属性"></a>1 静态属性</h3><ol>
<li><code>Math.E</code><ul>
<li>欧拉常数 <code>e</code></li>
</ul>
</li>
<li><code>Math.PI</code><ul>
<li>常数 <code>π</code></li>
</ul>
</li>
</ol>
<h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2 静态方法"></a>2 静态方法</h3><ol>
<li><code>Math.abs(x)</code><ul>
<li>绝对值</li>
</ul>
</li>
<li><code>Math.ceil(x)</code><ul>
<li>向上取整</li>
</ul>
</li>
<li><code>Math.floor(x)</code><ul>
<li>向下取整</li>
</ul>
</li>
<li><code>Math.pow(x, y)</code><ul>
<li>返回 x 的 y 次幂</li>
</ul>
</li>
<li><code>Math.random()</code><ul>
<li>返回0-1之间的伪随机数(含0不含1)</li>
</ul>
</li>
<li><code>Math.round(x)</code><ul>
<li>四舍五入</li>
</ul>
</li>
<li><code>Math.sqrt(x)</code><ul>
<li>平方</li>
</ul>
</li>
<li><code>Math.log(x)</code><ul>
<li>对数</li>
</ul>
</li>
<li><code>Math.exp(x)</code><ul>
<li><code>e</code> 的指数（e的x次方）</li>
</ul>
</li>
<li><code>Math.min([value1[,value2, ...]])</code><ul>
<li>返回给定的一组数字中的最小值。如果任一参数不能转换为数值，则返回NaN。</li>
</ul>
</li>
<li><code>Math.max(value1[,value2, ...])</code><ul>
<li>返回给定的一组数字中的最大值。如果任一参数不能转换为数值，则返回NaN。</li>
</ul>
</li>
<li><code>Math.sin(x)</code><ul>
<li>正弦</li>
</ul>
</li>
<li><code>Math.cos(x)</code><ul>
<li>余弦</li>
</ul>
</li>
<li><code>Math.tan(x)</code><ul>
<li>正切    </li>
</ul>
</li>
</ol>
<h1 id="二-boolean"><a href="#二-boolean" class="headerlink" title="二 boolean"></a>二 boolean</h1><h2 id="2-1-布尔值"><a href="#2-1-布尔值" class="headerlink" title="2.1 布尔值"></a>2.1 布尔值</h2><ul>
<li><code>true</code></li>
<li><code>false</code></li>
</ul>
<h2 id="2-2-类型转换"><a href="#2-2-类型转换" class="headerlink" title="2.2 类型转换"></a>2.2 类型转换</h2><h3 id="1-类型转换规则"><a href="#1-类型转换规则" class="headerlink" title="1 类型转换规则"></a>1 类型转换规则</h3><table>
<thead>
<tr>
<th>值</th>
<th>转换结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>0</code></td>
<td>false</td>
</tr>
<tr>
<td><code>NaN</code></td>
<td>false</td>
</tr>
<tr>
<td><code>&quot;&quot;</code></td>
<td>false</td>
</tr>
<tr>
<td><code>false</code></td>
<td>false</td>
</tr>
<tr>
<td><code>null</code></td>
<td>false</td>
</tr>
<tr>
<td><code>undefined</code></td>
<td>false</td>
</tr>
<tr>
<td>其它</td>
<td>true</td>
</tr>
</tbody></table>
<ol>
<li>隐式转换<ul>
<li>基本上所有类型都可以隐式转换为 boolean类型。</li>
<li>注意：值和布尔值是不同的概念</li>
</ul>
</li>
<li>显式转换<ol>
<li><code>Boolean()</code></li>
<li><code>!!</code></li>
<li><code>new Boolean()</code><ul>
<li>不太好，因为返回一个对象，而将对象转换成布尔值必为true</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="2-3-Boolean（包装类）"><a href="#2-3-Boolean（包装类）" class="headerlink" title="2.3 Boolean（包装类）"></a>2.3 Boolean（包装类）</h2><h3 id="1-构造函数-1"><a href="#1-构造函数-1" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><ol>
<li><code>Boolean([value])</code><ul>
<li>普通函数，作用是类型转换，将value转成一个布尔值boolean</li>
</ul>
</li>
<li><code>new Boolean([value])</code><ul>
<li>构造函数，创建一个Boolean对象<ol>
<li>如果省略参数，则Boolean对象值为false</li>
<li>如果value不是布尔值，则先转成布尔值</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="2-原型方法"><a href="#2-原型方法" class="headerlink" title="2 原型方法"></a>2 原型方法</h3><ol>
<li><code>valueOf()</code><ul>
<li>返回基本类型的值<code>true/false</code></li>
</ul>
</li>
<li><code>toString()</code><ul>
<li>返回字符串形式 <code>&#39;true&#39;/&#39;false&#39;</code></li>
</ul>
</li>
</ol>
<h1 id="三-string"><a href="#三-string" class="headerlink" title="三 string"></a>三 string</h1><h2 id="3-1-字符串字面量"><a href="#3-1-字符串字面量" class="headerlink" title="3.1 字符串字面量"></a>3.1 字符串字面量</h2><ol>
<li>单/双引号（特殊字符使用<code>\</code>转义）</li>
<li>反引号（模板字面量，特殊字符直接使用，反引号需要使用<code>\</code>转义）</li>
</ol>
<h2 id="3-2-字符的-Unicode表示法"><a href="#3-2-字符的-Unicode表示法" class="headerlink" title="3.2 字符的 Unicode表示法"></a>3.2 字符的 Unicode表示法</h2><ol>
<li><code>\uxxxx</code><ul>
<li>只限于Unicode编码在<code>\u0000~\uFFFF</code>（0-65535）之间的字符</li>
</ul>
</li>
<li><code>\u{}</code><ul>
<li>使用<code>{}</code>，大于<code>\uFFFF</code>的字符也能正确表示</li>
</ul>
</li>
</ol>
<h2 id="3-3-字符串换行"><a href="#3-3-字符串换行" class="headerlink" title="3.3 字符串换行"></a>3.3 字符串换行</h2><ol>
<li>末尾加<code>\</code></li>
<li>加号连接</li>
<li>反引号</li>
</ol>
<h2 id="3-4-模板字面量"><a href="#3-4-模板字面量" class="headerlink" title="3.4 模板字面量"></a>3.4 模板字面量</h2><ol>
<li>模板字面量是增强版的字符串，它用反引号标识</li>
<li>空格换行等都会原样输出</li>
<li><code>${表达式}</code> <ul>
<li>占位符就如同一个普通字符串一样，可以插入到字符串中的任意位置</li>
<li>作用是取表达式的值</li>
</ul>
</li>
<li>反引号可以嵌套</li>
</ol>
<h2 id="3-5-模板字面量标签"><a href="#3-5-模板字面量标签" class="headerlink" title="3.5 模板字面量标签"></a>3.5 模板字面量标签</h2><ol>
<li>模板字面量标签通常是一个函数</li>
<li>调用标签函数，将它放在模板字面量前即可<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert`hello`;</span><br><span class="line">function myTag (strings, ...values)&#123;&#125;</span><br><span class="line">myTag`hello`</span><br></pre></td></tr></table></figure></li>
<li>调用标签函数时，会将模板字面量处理成参数，传递给函数<ol>
<li>第一个参数是数组，存储模板字面量中占位符<code>${}</code>两侧的字符串</li>
<li>第二个参数是可变参数，存储占位符<code>${}</code>的返回值<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let name = &apos;xiaoming&apos;, age = 18;</span><br><span class="line">alert`hello$&#123;name&#125;,ni$&#123;18&#125;了吗`; </span><br><span class="line">// 相当于</span><br><span class="line">alert ([&apos;hello&apos;, &apos;,ni&apos;, &apos;了吗&apos;], &apos;xiaoming&apos;, 18);</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h2 id="3-6-String（包装类）"><a href="#3-6-String（包装类）" class="headerlink" title="3.6 String（包装类）"></a>3.6 String（包装类）</h2><h3 id="1-构造函数-2"><a href="#1-构造函数-2" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><ol>
<li><code>String([value])</code><ul>
<li>普通函数，作用是类型转换，将value转成一个字符串string<ol>
<li>如果参数为空，则返回空字符串<code>&#39;&#39;</code></li>
<li>如果参数是基本类型，则返回基本类型的字符串形式</li>
<li>如果参数是引用类型，相当于调用其<code>toString()</code></li>
</ol>
</li>
</ul>
</li>
<li><code>new String([value])</code><ul>
<li>构造函数，创建一个String对象，值为value转成的字符串</li>
</ul>
</li>
</ol>
<h3 id="2-实例属性"><a href="#2-实例属性" class="headerlink" title="2 实例属性"></a>2 实例属性</h3><ul>
<li><code>length</code></li>
</ul>
<h3 id="3-静态方法-1"><a href="#3-静态方法-1" class="headerlink" title="3 静态方法"></a>3 静态方法</h3><ol>
<li><code>String.fromCharCode(num1, ..., numN)</code><ul>
<li>返回使用指定的 Unicode 编码创建的字符串（不能识别大于<code>0xFFFF</code>的字符）</li>
<li><code>num1, ..., numN</code><ul>
<li>一串 Unicode 编码</li>
</ul>
</li>
</ul>
</li>
<li><code>String.fromCodePoint(num1[, ...[, numN]])</code><ul>
<li>返回使用指定的 Unicode 编码创建的字符串（可以识别大于<code>0xFFFF</code>的字符）</li>
</ul>
</li>
<li><code>String.raw&#96;templateString&#96;</code><ul>
<li>返回模板字符串的原始字符串</li>
<li>是唯一一个内置的模板字符串标签函数</li>
</ul>
</li>
</ol>
<h3 id="4-原型方法-1"><a href="#4-原型方法-1" class="headerlink" title="4 原型方法"></a>4 原型方法</h3><h4 id="1-获取"><a href="#1-获取" class="headerlink" title="1 获取"></a>1 获取</h4><ol>
<li><code>valueOf()</code><ul>
<li>返回字符串对象的原始字符串</li>
</ul>
</li>
<li><code>repeat(count)</code><ul>
<li>当前字符串重复count次组成新字符串并返回</li>
</ul>
</li>
<li><code>concat(str1, str2[, ..., strN])</code><ul>
<li>将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回，不改变原字符串</li>
</ul>
</li>
<li><code>slice(beginIndex[, endIndex])</code><ul>
<li>提取从开始索引到结束索引之间（含头不含尾）的字符串并返回，不改变原字符串</li>
<li>索引可以为负，则索引为负时表示从后开始（-1, -2 …）</li>
<li>索引超过字符串长度时，会被当作末尾</li>
</ul>
</li>
<li><code>substring(beginIndex[, endIndex])</code><ul>
<li>提取从开始索引到结束索引之间（含头不含尾）的字符串并返回，不改变原字符串</li>
<li>索引为负时或为 NaN，则被当作 0</li>
<li>索引超过字符串长度时，会被当作末尾</li>
</ul>
</li>
<li><code>substr(beginIndex, length)</code>（    已过时）<ul>
<li>提取从起始索引号指定数目的字符串并返回，不改变原字符串</li>
</ul>
</li>
</ol>
<h4 id="2-改"><a href="#2-改" class="headerlink" title="2 改"></a>2 改</h4><ol>
<li><code>toLowerCase() / toUpperCase()</code><ul>
<li>将一个字符串转小/大写，返回一个新字符串，不改变原字符串</li>
</ul>
</li>
<li><code>trim()</code><ul>
<li>去除字符串两端的空格，返回一个新字符串，不改变原字符串</li>
</ul>
</li>
<li><code>trimStart() / trimEnd()</code><ul>
<li><code>trimLeft()</code>是 <code>trimStart()</code> 的别名，<code>trimRight()</code> 是<code>trimEnd()</code>的别名</li>
</ul>
</li>
<li><code>padStart(targetLength [, padString])</code><ul>
<li>以指定字符串<code>padString</code>在原字符串开头补充，以达到目标长度<code>targetLength</code></li>
<li><code>targetLength</code><ul>
<li>当前字符串需要填充到的目标长度，如果小于等于当前字符串长度，则返回当前字符串</li>
</ul>
</li>
<li><code>padString</code><ul>
<li>填充字符串，如果省略则使用空格</li>
</ul>
</li>
</ul>
</li>
<li><code>padEnd(targetLength [, padString])</code></li>
</ol>
<h4 id="3-查"><a href="#3-查" class="headerlink" title="3 查"></a>3 查</h4><ol>
<li><code>charAt(index)</code><ul>
<li>返回指定位置的字符</li>
</ul>
</li>
<li><code>charCodeAt(index)</code><ul>
<li>返回指定位置的字符Unicode 值（十进制）</li>
<li>只能获取2个字节表示的字符，对于4个字节表示的字符会认为是两个字符</li>
</ul>
</li>
<li><code>codePointAt(index)</code><ul>
<li>返回指定位置的字符Unicode 值（十进制）</li>
<li>可以正确获取4个字节表示的字符</li>
<li>javaScript内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。（<code>0-65535</code> 或 <code>0x0000-0xFFFF</code>）</li>
</ul>
</li>
<li><code>indexOf(searchValue[, fromIndex])</code><ul>
<li>返回一个字符串在另一个字符串中第一次出现的索引，未找到返回-1</li>
<li>默认从0索引开始往后找</li>
</ul>
</li>
<li><code>lastIndexOf(searchValue[, fromIndex])</code><ul>
<li>返回一个字符串在另一个字符串中从后往前第一次出现的索引，未找到返回-1</li>
</ul>
</li>
</ol>
<h4 id="4-判断"><a href="#4-判断" class="headerlink" title="4 判断"></a>4 判断</h4><ol>
<li><code>includes(searchString[, fromIndex])</code><ul>
<li>判断是否包含指定字符串</li>
</ul>
</li>
<li><code>startsWith(searchString[, fromIndex])</code><ul>
<li>判断是否以指定字符串开头</li>
</ul>
</li>
<li><code>endsWith(searchString[, length])</code><ul>
<li>判断是否以指定字符串结尾</li>
<li><code>length</code><ul>
<li>表示只判断当前字符串指定长度的子串，如3，则表示只判断前三个字符是否以指定字符串结尾</li>
<li>默认为当前字符串的length大小</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="5-正则"><a href="#5-正则" class="headerlink" title="5 正则"></a>5 正则</h4><ol>
<li><code>split([separator[, limit]])</code><ul>
<li>按照给定规则分割字符串，返回一个由分割出来的子字符串以指定分隔符组成的数组</li>
<li><code>separator</code><ul>
<li>可以是一个字符串或正则表达式</li>
</ul>
</li>
<li><code>limit</code><ul>
<li>限定返回的分割片段数量</li>
</ul>
</li>
</ul>
</li>
<li><code>search(regexp)</code><ul>
<li>返回正则表达式在字符串中首次匹配项的索引;否则，返回 -1</li>
<li><code>regexp</code><ul>
<li>正则对象，如果传入一个非正则对象，则会先转成正则对象</li>
</ul>
</li>
</ul>
</li>
<li><code>match(regexp)</code><ul>
<li>如果正则没有g标志，则返回包含第一个匹配结果的数组，且有附加属性（index, input, groups,…）</li>
<li>如果正则有g标志，则返回包含所有匹配结果的数组，没有附加属性</li>
<li>如果没有匹配，返回null</li>
</ul>
</li>
<li><code>matchAll(regexp)</code><ul>
<li>返回一个包含所有匹配正则表达式的结果（包含附加属性）的迭代器</li>
<li>没有<code>matchAll</code>之前，使用while循环加exec方式（且正则表达式需使用g标志），来获取所有匹配项</li>
</ul>
</li>
<li><code>replace(regexp|substr, newSubStr|function)</code><ul>
<li><code>regexp|substr</code><ul>
<li>正则匹配的内容或者指定的内容</li>
</ul>
</li>
<li><code>newSubStr</code><ul>
<li>使用新的字符串替换，替换时可以插入特殊变量</li>
</ul>
</li>
<li><code>function</code><ul>
<li>使用函数返回的字符串替换</li>
</ul>
</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">特殊变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>$$</code></td>
<td>插入一个 “$”</td>
</tr>
<tr>
<td align="center"><code>$&amp;</code></td>
<td>插入匹配的子串</td>
</tr>
<tr>
<td align="center">$`</td>
<td>插入当前匹配的子串左边的内容</td>
</tr>
<tr>
<td align="center"><code>$&#39;</code></td>
<td>插入当前匹配的子串右边的内容</td>
</tr>
<tr>
<td align="center"><code>$n</code></td>
<td>如果第一个参数是RegExp对象，表示插入第n组的内容</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">函数参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>match</code></td>
<td>匹配的子串。（对应<code>$&amp;</code>。）</td>
</tr>
<tr>
<td align="center"><code>p1,p2,...</code></td>
<td>如果第一个参数是RegExp对象，表示第n组的内容（对应<code>$n</code>）</td>
</tr>
<tr>
<td align="center"><code>offset</code></td>
<td>匹配到的子字符串在原字符串中起始索引</td>
</tr>
<tr>
<td align="center"><code>string</code></td>
<td>被匹配的原字符串</td>
</tr>
<tr>
<td align="center"><code>NamedCaptureGroup</code></td>
<td>命名捕获组匹配的对象</td>
</tr>
</tbody></table>
<h1 id="四-null-amp-undefined"><a href="#四-null-amp-undefined" class="headerlink" title="四 null &amp; undefined"></a>四 null &amp; undefined</h1><ol>
<li>一个没有赋值的变量默认值为undefined<ul>
<li>基本类型：初始化推荐undefined（惯例，其实默认就是undefined，null也可以）</li>
<li>引用类型：初始化推荐null（惯例，undefined也可以）</li>
</ul>
</li>
<li>值为undefined的情况<ol>
<li>变量或者对象属性没有赋值，则默认值undefined</li>
<li>调用函数时，没有传值的参数则默认为undefined</li>
<li>函数没有返回值时，默认返回 undefined </li>
</ol>
</li>
</ol>
<h1 id="五-symbol"><a href="#五-symbol" class="headerlink" title="五 symbol"></a>五 symbol</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol>
<li>symbol 的值是唯一的，独一无二的不会重复的</li>
<li>symbol 值作为对象属性名时，不能用点运算符，只能使用<code>[]</code><ol>
<li>不会被<code>for...in for... of</code>遍历到</li>
<li>不会被<code>Object.keys() Object.getOwnPropertyNames() JSON.stringify()</code>返回</li>
<li>使用<code>Object.getOwnPropertySymbols()</code>可以获取</li>
</ol>
</li>
<li>symbol 值不能与其他类型的值进行运算，可以转为字符串和布尔值</li>
</ol>
<h2 id="5-2-Symbol（包装类）"><a href="#5-2-Symbol（包装类）" class="headerlink" title="5.2 Symbol（包装类）"></a>5.2 Symbol（包装类）</h2><h3 id="1-构造函数-3"><a href="#1-构造函数-3" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><ol>
<li><code>Symbol([description])</code><ol>
<li>返回一个symbole类型的值，且是唯一的</li>
<li>不会放入全局symbol注册表</li>
<li><code>description</code><ul>
<li>字符串类型。仅仅是对symbol的描述，为了控制台显示时或者转为字符串时比较容易区分，不会影响symbol的值（即使用相同描述创建的symbol也不同）</li>
<li>如果传入的不是字符串，会先转成字符串</li>
</ul>
</li>
</ol>
</li>
<li><code>new Symbol()</code><ul>
<li>不支持此语法</li>
</ul>
</li>
</ol>
<h3 id="2-静态属性-1"><a href="#2-静态属性-1" class="headerlink" title="2 静态属性"></a>2 静态属性</h3><ul>
<li>ES6 提供了 11 个内置的 Symbol 值，指向语言内部使用的方法</li>
</ul>
<ol>
<li><code>Symbol.hasInstance</code><ul>
<li><code>A instanceof B</code> 实际调用的是 <code>B[Symbol.hasInstance](A)</code></li>
</ul>
</li>
<li><code>Symbol.iterator</code><ul>
<li><code>for(let a of A)</code> 会调用 <code>A[Symbol.iterator]()</code> 返回对象的迭代器</li>
</ul>
</li>
</ol>
<h3 id="3-实例属性"><a href="#3-实例属性" class="headerlink" title="3 实例属性"></a>3 实例属性</h3><ol>
<li><code>description</code><ul>
<li>只读属性，返回 Symbol 对象的可选的描述字符串</li>
</ul>
</li>
</ol>
<h3 id="4-静态方法"><a href="#4-静态方法" class="headerlink" title="4 静态方法"></a>4 静态方法</h3><ol>
<li><code>Symbol.for(key)</code><ul>
<li>根据键 key 从全局symbol注册表中查询，如果找到则返回，否则创建一个与key关联的symbol，放入全局 symbol 注册表中，并返回</li>
<li><code>key</code><ul>
<li>一个字符串，作为 symbol 注册表中与某 symbol 关联的键（同时也会作为该 symbol 的描述）</li>
</ul>
</li>
</ul>
</li>
<li><code>Symbol.keyFor(sym)</code><ul>
<li>获取全局symbol 注册表中与某个 symbol 关联的键，若存在则返回字符串key，否则返回undefined</li>
</ul>
</li>
</ol>
<h1 id="六-bigInt"><a href="#六-bigInt" class="headerlink" title="六 bigInt"></a>六 bigInt</h1><ul>
<li>用任意精度表示整数</li>
</ul>
]]></content>
      <categories>
        <category>UI</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript 数据类型概述</title>
    <url>/anyeansan.github.io/2020/03/30/Javascript-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="一-数据类型判断"><a href="#一-数据类型判断" class="headerlink" title="一 数据类型判断"></a>一 数据类型判断</h1><h2 id="1-1-typeof"><a href="#1-1-typeof" class="headerlink" title="1.1 typeof"></a>1.1 typeof</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof operand  // operand：表示对象或基本值的表达式</span><br><span class="line">typeof(operand)</span><br></pre></td></tr></table></figure>
<ul>
<li>判断数据类型并返回字符串形式</li>
</ul>
<h3 id="2-返回值"><a href="#2-返回值" class="headerlink" title="2 返回值"></a>2 返回值</h3><table>
<thead>
<tr>
<th>type</th>
<th>typeof Result</th>
</tr>
</thead>
<tbody><tr>
<td>number</td>
<td>“number”</td>
</tr>
<tr>
<td>bigint</td>
<td>“bigint”</td>
</tr>
<tr>
<td>string</td>
<td>“string”</td>
</tr>
<tr>
<td>boolean</td>
<td>“boolean”</td>
</tr>
<tr>
<td>undefined</td>
<td>“undefined”</td>
</tr>
<tr>
<td>null</td>
<td>“object”</td>
</tr>
<tr>
<td>symbol</td>
<td>“symbol”</td>
</tr>
<tr>
<td>function object (implements [[Call]])</td>
<td>“function”</td>
</tr>
<tr>
<td>any other object</td>
<td>“object”</td>
</tr>
<tr>
<td>* <code>typeof null</code>返回<code>object</code>是历史原因</td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-2-instanseof"><a href="#1-2-instanseof" class="headerlink" title="1.2 instanseof"></a>1.2 instanseof</h2><ul>
<li><code>object instanceof constructor</code><ul>
<li>用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</li>
</ul>
</li>
</ul>
<h1 id="二-数据类型分类"><a href="#二-数据类型分类" class="headerlink" title="二 数据类型分类"></a>二 数据类型分类</h1><h2 id="2-1-基本数据类型"><a href="#2-1-基本数据类型" class="headerlink" title="2.1 基本数据类型"></a>2.1 基本数据类型</h2><ol>
<li>number</li>
<li>boolean</li>
<li>string</li>
<li>null</li>
<li>undefined</li>
<li>symbol</li>
<li>bigInt</li>
</ol>
<h2 id="2-2-引用数据类型"><a href="#2-2-引用数据类型" class="headerlink" title="2.2 引用数据类型"></a>2.2 引用数据类型</h2><ul>
<li>object<ol>
<li>内置对象<ol>
<li>对象 （Object）</li>
<li>数组 （Array）</li>
<li>集合 （Map Set WeakMap WeakSet）</li>
<li>函数（Function）</li>
<li>基本类型包装对象（Number Boolean String Symbol BigInt）</li>
<li>数学（Math）</li>
<li>日期（Date）</li>
<li>Json（JSON）</li>
<li>正则（RegExp）</li>
<li>错误（Error）</li>
<li>……</li>
</ol>
</li>
<li>自定义对象</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>UI</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript 语法</title>
    <url>/anyeansan.github.io/2020/03/30/Javascript-%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一-严格模式"><a href="#一-严格模式" class="headerlink" title="一 严格模式"></a>一 严格模式</h1><h2 id="1-1-启用"><a href="#1-1-启用" class="headerlink" title="1.1 启用"></a>1.1 启用</h2><ul>
<li><code>&quot;use strict;&quot;</code><ol>
<li>放在脚本文件的第一行，整个脚本都将以严格模式运行。</li>
<li>放在函数体的第一行，则整个函数以严格模式运行。</li>
</ol>
</li>
</ul>
<h2 id="1-2-严格模式中的变化"><a href="#1-2-严格模式中的变化" class="headerlink" title="1.2 严格模式中的变化"></a>1.2 严格模式中的变化</h2><h3 id="1-显式报错"><a href="#1-显式报错" class="headerlink" title="1 显式报错"></a>1 显式报错</h3><ol>
<li>严格模式会使引起静默失败(silently fail，不报错也没有任何效果)的赋值操作抛出异常<ul>
<li>只读属性的写操作，不可扩展对象扩展操作，</li>
</ul>
</li>
<li>严格模式下，试图删除不可删除的属性时会抛出异常</li>
<li>严格模式下禁止对象属性重名</li>
<li>严格模式下禁止函数参数重名</li>
<li>严格模式禁止八进制数字语法</li>
</ol>
<h3 id="2-安全措施"><a href="#2-安全措施" class="headerlink" title="2 安全措施"></a>2 安全措施</h3><ol>
<li>严格模式下，变量必须先声明，然后再使用</li>
<li>禁止 this 关键字指向全局对象window</li>
<li>严格模式禁止删除声明变量</li>
</ol>
<h3 id="3-静态绑定"><a href="#3-静态绑定" class="headerlink" title="3 静态绑定"></a>3 静态绑定</h3><ul>
<li>js允许动态绑定，即属性或方法属于哪个对象不是编译时确定的，而是在运行时确定</li>
<li>严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定，即编译时就确定属性或方法属于哪个对象。</li>
</ul>
<ol>
<li>严格模式禁用 <code>with</code>语句</li>
<li>创设 eval 作用域<ul>
<li>正常模式下，eval语句的作用域，取决于它处于全局作用域，还是函数作用域。</li>
<li>严格模式下，eval语句本身就是一个作用域，即eval所生成的变量只能用于eval内部</li>
</ul>
</li>
<li>arguments 不再追踪参数的变化<ul>
<li>变量arguments代表函数的参数。</li>
<li>严格模式下，函数内部改变参数与arguments的联系被切断了，两者不再存在联动关系</li>
</ul>
</li>
</ol>
<h1 id="二-顶层对象"><a href="#二-顶层对象" class="headerlink" title="二 顶层对象"></a>二 顶层对象</h1><ol>
<li>JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。</li>
<li>顶层对象在各种实现里面是不统一的</li>
<li>ES2020标准中，引入<code>globalThis</code>作为顶层对象。也就是说，任何环境下，<code>globalThis</code>都是存在的</li>
</ol>
<table>
<thead>
<tr>
<th>环境</th>
<th>顶层对象</th>
<th>ES2020</th>
</tr>
</thead>
<tbody><tr>
<td>浏览器</td>
<td>window，self</td>
<td>globalThis</td>
</tr>
<tr>
<td>Web Worker</td>
<td>self</td>
<td>globalThis</td>
</tr>
<tr>
<td>Node</td>
<td>global</td>
<td>globalThis</td>
</tr>
</tbody></table>
<h1 id="三-注释"><a href="#三-注释" class="headerlink" title="三 注释"></a>三 注释</h1><ol>
<li><code>//</code></li>
<li><code>/* */</code><ul>
<li>不能嵌套</li>
</ul>
</li>
</ol>
<h1 id="四-作用域"><a href="#四-作用域" class="headerlink" title="四 作用域"></a>四 作用域</h1><ol>
<li>全局作用域</li>
<li>块作用域</li>
<li>函数作用域</li>
</ol>
<h1 id="五-声明关键字"><a href="#五-声明关键字" class="headerlink" title="五 声明关键字"></a>五 声明关键字</h1><p>关键字|初始化|变量提升|块作用域|window|同一作用域重复声明<br>:-:|-|-|-|-<br><code>var</code>|可选|有|无|全局变量会成为window对象属性|可以，后者覆盖前者<br><code>let</code>|可选|无|有|全局变量不属于window属性|不能<br><code>const</code>|必须|无|有|全局变量不属于window属性|不能</p>
<ol>
<li>变量提升<ul>
<li>变量的声明语句，被提升到代码的头部</li>
</ul>
</li>
<li>暂时性死区（temporal dead zone，简称 TDZ<ul>
<li>let和const没有变量提升，所以必须先声明后使用</li>
<li>从作用域开始到声明语句的区域，如果使用声明的变量就会会导致 ReferenceError，这块区域称为暂时性死区。</li>
</ul>
</li>
<li>const 常量指向的内存地址不能改变<ol>
<li>基本类型值不能改变</li>
<li>引用类型地址值不能修改</li>
</ol>
</li>
</ol>
<h1 id="六-变量"><a href="#六-变量" class="headerlink" title="六 变量"></a>六 变量</h1><ol>
<li>变量的声明和赋值，是分开的两个步骤<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a = 1;  // 其实是下边两步</span><br><span class="line">let a;</span><br><span class="line">a = 1;</span><br></pre></td></tr></table></figure></li>
<li>同一条声明语句中可以声明多个变量</li>
<li>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</li>
<li>变量标识符命名规则<ol>
<li>不能用数字开头</li>
<li>可以用中文</li>
<li>不能使用js保留字</li>
</ol>
</li>
</ol>
<h1 id="七-运算符"><a href="#七-运算符" class="headerlink" title="七 运算符"></a>七 运算符</h1><h2 id="7-1-赋值运算符"><a href="#7-1-赋值运算符" class="headerlink" title="7.1 赋值运算符"></a>7.1 赋值运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
<th>等价于</th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td>赋值</td>
<td><code>x = y</code></td>
<td><code>x = y</code></td>
</tr>
<tr>
<td><code>+=</code></td>
<td>加赋值</td>
<td><code>x += y</code></td>
<td><code>x = x + y</code></td>
</tr>
<tr>
<td><code>-=</code></td>
<td>减赋值</td>
<td><code>x -= y</code></td>
<td><code>x = x - y</code></td>
</tr>
<tr>
<td><code>*=</code></td>
<td>乘赋值</td>
<td><code>x *= y</code></td>
<td><code>x = x * y</code></td>
</tr>
<tr>
<td><code>/=</code></td>
<td>除赋值</td>
<td><code>x /= y</code></td>
<td><code>x = x / y</code></td>
</tr>
<tr>
<td><code>%=</code></td>
<td>模赋值</td>
<td><code>x %= y</code></td>
<td><code>x = x % y</code></td>
</tr>
<tr>
<td><code>**=</code></td>
<td>指数赋值</td>
<td><code>x **= y</code></td>
<td><code>x = x ** y</code></td>
</tr>
<tr>
<td><code>&lt;&lt;=</code></td>
<td>左移赋值</td>
<td><code>x &lt;&lt;= y</code></td>
<td><code>x = x &lt;&lt; y</code></td>
</tr>
<tr>
<td><code>&gt;&gt;=</code></td>
<td>右移赋值</td>
<td><code>x &gt;&gt;= y</code></td>
<td><code>x = x &gt;&gt; y</code></td>
</tr>
<tr>
<td><code>&gt;&gt;&gt;=</code></td>
<td>无符号右移赋值</td>
<td><code>x &gt;&gt;&gt;= y</code></td>
<td><code>x = x &gt;&gt;&gt; y</code></td>
</tr>
<tr>
<td><code>&amp;=</code></td>
<td>按位与赋值</td>
<td><code>x &amp;= y</code></td>
<td><code>x = x &amp; y</code></td>
</tr>
<tr>
<td><code>&#124;=</code></td>
<td>按位或赋值</td>
<td><code>x &#124;= y</code></td>
<td><code>x = x &#124; y</code></td>
</tr>
<tr>
<td><code>^=</code></td>
<td>按位异或赋值</td>
<td><code>x ^= y</code></td>
<td><code>x = x ^ y</code></td>
</tr>
</tbody></table>
<h2 id="7-2-算术运算符"><a href="#7-2-算术运算符" class="headerlink" title="7.2 算术运算符"></a>7.2 算术运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>加法</td>
<td><code>x + y</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td>减法</td>
<td><code>x - y</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘法</td>
<td><code>x * y</code></td>
</tr>
<tr>
<td><code>/</code></td>
<td>除法</td>
<td><code>x / y</code></td>
</tr>
<tr>
<td><code>%</code></td>
<td>求余</td>
<td><code>x % y</code></td>
</tr>
<tr>
<td><code>**</code></td>
<td>幂</td>
<td><code>x ** y</code></td>
</tr>
<tr>
<td><code>++</code></td>
<td>自增</td>
<td><code>x++</code> 或 <code>++x</code></td>
</tr>
<tr>
<td><code>--</code></td>
<td>自减</td>
<td><code>x--</code> 或 <code>--x</code></td>
</tr>
<tr>
<td><code>+</code></td>
<td>一元正号</td>
<td><code>+x</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td>一元负号</td>
<td><code>-x</code></td>
</tr>
</tbody></table>
<h3 id="1-加法"><a href="#1-加法" class="headerlink" title="1 加法"></a>1 加法</h3><ol>
<li>允许非数值的相加<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true + true = 2</span><br><span class="line">1 + true = 2</span><br></pre></td></tr></table></figure></li>
<li>遇到字符串会变成连接</li>
<li>对象相加，必须先转成原始类型的值<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj = &#123; p: 1 &#125;;</span><br><span class="line">obj + 2 // &quot;[object Object]2&quot;</span><br><span class="line">// obj.valueOf() 结果为&#123;p:1&#125;</span><br><span class="line">// obj.valueOf().toString() 结果为&quot;[object object]&quot;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 2 一元加号/减号</span><br><span class="line">* 一元加号/减号运算符的作用在于可以将任何值转为数值</span><br></pre></td></tr></table></figure></li>
</ol>
<p>+true // 1<br>+[] // 0<br>+{} // NaN</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 3 幂运算符</span><br><span class="line">1. 前一个运算子是底数，后一个运算子是指数</span><br><span class="line">2. 幂运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算。</span><br></pre></td></tr></table></figure>
<p>2 ** 4 // 16 即2的4次方<br>2 ** 3 ** 2// 512 相当于2** (3 ** 2) 即先求3的2次方=9 再求2的9次方</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 7.3 比较运算符</span><br><span class="line">### 1 非相等比较</span><br><span class="line">运算符|名称|运算式</span><br><span class="line">-|-|-</span><br><span class="line">`&gt;`|大于|`x &gt; y`</span><br><span class="line">`&lt;`|小于|`x &lt; y`</span><br><span class="line">`&gt;=`|大于等于|`x &gt;= y`</span><br><span class="line">`&lt;=`|小于等于|`x &lt;= y`</span><br><span class="line">1. 基本类型</span><br><span class="line">	1. 非字符串：先转成数值再比较</span><br><span class="line">	2. 字符串：按照字典顺序比较（实际上是比较 Unicode 码点）</span><br><span class="line">2. 引用类型</span><br><span class="line">	* 先转为基本类型的值，再进行比较</span><br><span class="line"></span><br><span class="line">### 2 相等比较</span><br><span class="line">运算符|名称|运算式</span><br><span class="line">-|-|-</span><br><span class="line">`==`|相等|` x == y`</span><br><span class="line">`===`|严格相等|`x === y`</span><br><span class="line">`!=`|不相等|`x != y`</span><br><span class="line">`!==`|严格不相等|`x !== y`</span><br><span class="line">1. `===`</span><br><span class="line">	1. 先比较类型，类型相同再比较值</span><br><span class="line">	2. 引用类型比较地址值</span><br><span class="line">	3. `NaN`与任何值都不严格相等（包括自己）</span><br><span class="line">	4. `undefined`和`null`与自身严格相等</span><br><span class="line">	5. `+0` 与 `-0` 严格相等 </span><br><span class="line">	6. `!==`</span><br><span class="line">		* 先求`===`的结果，然后返回相反值。</span><br><span class="line">2. `==`</span><br><span class="line">	1. 比较不同类型的数据时，会先将数据进行类型转换，然后再用`===`比较。</span><br><span class="line">	2.  `NaN`与任何值都不相等（包括自己）</span><br><span class="line">	3. `undefined`和`null`与其他类型的值比较时，结果都为false， 它们之间比较为true</span><br><span class="line">	4. `!=`</span><br><span class="line">		* 先求`==`的结果，然后返回相反值。</span><br><span class="line"></span><br><span class="line">## 7.4 逻辑运算符</span><br><span class="line">运算符|名称|运算式|说明</span><br><span class="line">-|-|-|-</span><br><span class="line">`&amp;&amp;`|逻辑与|`expr1 &amp;&amp; expr2`|若`expr1`为true，则返回`expr2`的值，否则，返回`expr1`的值，且不再计算`expr2`</span><br><span class="line">&lt;code&gt;&amp;#124;&amp;#124;&lt;/code&gt;|逻辑或|&lt;code&gt;expr1 &amp;#124;&amp;#124; expr2&lt;/code&gt;|若`expr1`为false，则返回`expr2`的值，否则，返回`expr1`的值，且不再计算`expr2`</span><br><span class="line">`!`|逻辑非|`!expr`|若`expr` 为 true，则返回 `false`，否则，返回`true`</span><br><span class="line">`!!`|双重非|`!!expr`|显式地将任意值强制转换为其对应的布尔值</span><br><span class="line">1. 表达式的布尔值与值不是一个概念，如`1 - 1` 返回的值是0，返回的布尔值是false</span><br><span class="line">2. 逻辑与和逻辑或存在短路计算，即整个表达式的值在第一个表达式计算后已经确定了，就不再计算第二个。</span><br><span class="line">3. 逻辑与的优先级高于逻辑或</span><br><span class="line"></span><br><span class="line">## 7.5 按位运算符</span><br><span class="line">运算符|名称|运算式|说明</span><br><span class="line">-|-|-|-</span><br><span class="line">`&amp;`|按位与|`x &amp; y`|有0则0</span><br><span class="line">&lt;code&gt;&amp;#124;&lt;/code&gt;|按位或|&lt;code&gt;x &amp;#124; y&lt;/code&gt;|有1则1</span><br><span class="line">`~`|按位非|`~x`|1变0，0变1</span><br><span class="line">`^`|按位异或|`x ^ y`|相同则0，不同则1</span><br><span class="line">`&lt;&lt;`|左移|`x &lt;&lt; y`|低位补0，相当于&lt;code&gt;x * 2&lt;sup&gt;y&lt;/sup&gt;&lt;/code&gt;</span><br><span class="line">`&gt;&gt;`|右移|`x &gt;&gt; y`|舍去低位，正数高位补0，负数高位补1，相当于&lt;code&gt;x / 2&lt;sup&gt;y&lt;/sup&gt;&lt;/code&gt;</span><br><span class="line">`&gt;&gt;&gt;`|无符号右移|`x &gt;&gt;&gt; y`|舍去低位，高位补0，相当于&lt;code&gt;x / 2&lt;sup&gt;y&lt;/sup&gt;&lt;/code&gt;</span><br><span class="line"></span><br><span class="line">## 7.6 三元运算符</span><br><span class="line">* `condition ? exprIfTrue : exprIfFalse`</span><br><span class="line">	1. 若`condition` 为true，返回`exprIfTrue`的值，否则，返回`exprIfFalse`的值</span><br><span class="line">	2. 和 `if else` 的区别：if...else是语句，没有返回值；三元运算符是表达式，具有返回值。</span><br><span class="line"></span><br><span class="line">## 7.7 void运算符</span><br><span class="line">* `void expression`</span><br><span class="line">	* 对给定的表达式进行求值，然后返回 undefined</span><br><span class="line">	* void 运算符通常只用于获取 undefined的原始值，一般使用`void(0)`（等同于`void 0`）</span><br><span class="line">* 应用</span><br><span class="line">	1. JavaScript URIs</span><br><span class="line">		* 当url使用`javascript:`协议，点击时，会执行URI中的代码，然后用返回的值替换页面内容，除非返回的值是undefined。</span><br><span class="line">		* void运算符可用于返回undefined。</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0);" target="_blank" rel="noopener">xxx</a> // 不会跳转。<br><a href="#">xxx</a> // 会跳转只是跳向本页面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. 在箭头函数中避免泄漏</span><br><span class="line">	* 箭头函数标准中，允许在函数体不使用括号来直接返回值。 如果右侧调用了一个原本没有返回值的函数，其返回值改变后，则会导致非预期的副作用</span><br><span class="line">	* 应该使用 void 运算符，来确保返回 undefined</span><br></pre></td></tr></table></figure>
<p>() =&gt; void doSomething();</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 7.8 逗号运算符</span><br><span class="line">* `expr1, expr2, expr3...`</span><br><span class="line">	* 从左到右依次计算每个表达式，并返回最后一个表达式的值</span><br></pre></td></tr></table></figure>
<p>‘a’, ‘b’ // “b”<br>var x = 0;<br>var y = (x++, 10);  // x=1 y=10</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 八 展开语法(Spread syntax)</span><br><span class="line">## 8.1 概述</span><br><span class="line">1. 展开语法用  `...` 进行表示</span><br><span class="line">2. 展开语法在函数调用或构造字面量数组时, 将**可迭代对象**（如数组, string, ...）在语法层面展开；</span><br><span class="line">3. 展开语法在构造字面量对象时, 将对象表达式按key-value的方式展开</span><br><span class="line"> </span><br><span class="line">## 8.2 应用</span><br><span class="line">### 1 函数调用</span><br></pre></td></tr></table></figure>
<p>function show(x, y, z) { }<br>let args = [0, 1, 2];<br>show(…args); // &lt;=&gt; show(0, 1, 2)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 2 字面量数组</span><br></pre></td></tr></table></figure>
<p>let arr1 = [0, 1, 2];<br>let arr2 = [3, 4, 5];<br>let arr3 = […arr1, …arr2]; // [0,1,2,3,4,5]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 3 字面量对象</span><br></pre></td></tr></table></figure>
<p>let obj1 = { foo: ‘bar’, x: 42 };<br>let obj2 = { foo: ‘baz’, y: 13 };<br>let clonedObj = { …obj1 };<br>// 克隆后的对象: { foo: “bar”, x: 42 }<br>let mergedObj = { …obj1, …obj2 };<br>// 合并后的对象: { foo: “baz”, x: 42, y: 13 }</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 九 剩余参数</span><br><span class="line">## 9.1 概述</span><br><span class="line">1. 剩余参数是一个数组，用于接收形参外的所有参数</span><br><span class="line">2. 剩余参数必须是最后一个参数</span><br><span class="line"></span><br><span class="line">## 9.2 语法</span><br></pre></td></tr></table></figure>
<p>function(a, b, …theArgs) {<br>    // …<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 9.3 剩余参数和 arguments对象的区别</span><br><span class="line">1. 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。</span><br><span class="line">2. arguments对象不是一个真正的数组，而剩余参数是真正的 Array实例，即剩余参数可以使用所有的数组方法</span><br><span class="line"></span><br><span class="line"># 十 解构赋值</span><br><span class="line">## 10.1 概述</span><br><span class="line">1. 解构赋值：从数组和对象中提取值，对变量进行赋值</span><br><span class="line">2. 解构对象时会查找原型链（如果属性不在对象自身，将从原型链中查找）</span><br><span class="line"></span><br><span class="line">## 10.2 解构数组</span><br><span class="line">1. 先声明后赋值的解构</span><br></pre></td></tr></table></figure>
<p>let a, b;<br>[a, b] = [10, 20]; // a=10 b=20</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. 声明并赋值的解构</span><br></pre></td></tr></table></figure>
<p>let [a,b] = [10, 20]; // a=10 b=20</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3. 默认值</span><br></pre></td></tr></table></figure>
<p>let [a = 3, b = 4] = [1]; // a=1 b=4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4. 变量数量小于值数量时，忽略多余值</span><br></pre></td></tr></table></figure>
<p>let [a, b] = [1, 2, 3, 4]; // a =1 b = 2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5. 可用于交换变量</span><br></pre></td></tr></table></figure>
<p>let a =1;<br>let b = 2;<br>[a, b] = [b, a]; // a=2 b=1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6. 剩余参数</span><br></pre></td></tr></table></figure>
<p>let [a, …b] = [1, 2, 3]; // a=1 b=[2,3]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 10.3 解构对象</span><br><span class="line">1. 基本语法</span><br></pre></td></tr></table></figure>
<p>let {key:变量} = {key:value};</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	* `&#123;key:变量&#125;`</span><br><span class="line">		* 将对象中属性key的值赋值给变量</span><br><span class="line">2. 变量名与属性名相同可以简写</span><br></pre></td></tr></table></figure>
<p>let {key:key} = {key:value};<br>let {key} = {key:value}; // 简写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3. 先声明后赋值的解构</span><br></pre></td></tr></table></figure>
<p>let name, age;<br>{name,age} =  {name:’an3’, age:18}); // 错误<br>({name, age} = {name:’an3’, age:18}); // name=’an3’ age=18</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	* 赋值时必须使用()包括，因为左边`&#123;name, age&#125;`会被认为是块而不是对象字面量</span><br><span class="line">4. 默认值</span><br></pre></td></tr></table></figure>
<p>let {name=’haha’, age=10} = {name:’an3’}; // name=’an3’ age=10<br>let {name:n=’haha’ age:a=10} = {name:’an3’}; // n=’an3’ a=10</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5. 变量数量小于值数量时，忽略多余值</span><br></pre></td></tr></table></figure>
<p>let {name=’haha’, age=10} = {name:’an3’,age:10,sex:1}; // name=’an3’ age=18</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6. 解构嵌套</span><br></pre></td></tr></table></figure>
<p>let user = {<br>    name:’xiaoming’,<br>    lesson:{<br>        title:’js’,<br>        score:90<br>    }<br>};<br>let {name,lesson:{title,score}} = user;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 十一 语句</span><br><span class="line">## 11.1 &#123;&#125;</span><br><span class="line">* `&#123; StatementList &#125;`</span><br><span class="line">	* 声明块作用域</span><br><span class="line"></span><br><span class="line">## 11.2 if...else</span><br><span class="line">## 11.3 switch</span><br></pre></td></tr></table></figure>
<p>switch (expression) {<br>    case value1:<br>    // 当 expression 的结果与 value1 匹配时，执行此处语句<br>    [break;]<br>    case value2:<br>    // 当 expression 的结果与 value2 匹配时，执行此处语句<br>    [break;]<br>    …<br>    case valueN:<br>    // 当 expression 的结果与 valueN 匹配时，执行此处语句<br>    [break;]<br>    [default:<br>    // 如果 expression 与上面的 value 值都不匹配，执行此处语句<br>    [break;]]<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* switch内部采用严格相等</span><br><span class="line">* 省略break：会继续运行下一个case语句无论值是否匹配</span><br><span class="line"></span><br><span class="line">## 11.4 for</span><br></pre></td></tr></table></figure>
<p>for ([initialization]; [condition]; [final-expression]){<br>    statement<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* for循环每次循环都是一个单独的函数作用域</span><br><span class="line">	1. 在 for 循环中使用let/const 会在每一次循环重新生成不同的变量</span><br><span class="line">	2. 在 for 循环中使用var声明的变量是全局共享的</span><br><span class="line"></span><br><span class="line">## 11.5 while / do...while</span><br><span class="line">## 11.6 label</span><br></pre></td></tr></table></figure>
<p>label :<br>    statement</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 相当于定位符，用于跳转到程序的任意位置，通常与break语句和continue语句配合使用，break 可用于任何标记语句，而 continue 用于循环标记语句</span><br><span class="line">	* `break [label]` 或 `continue [label]`</span><br><span class="line">* label ：任何不属于保留关键字的 JavaScript 标识符</span><br><span class="line"></span><br><span class="line">## 11.7 in</span><br><span class="line">* `prop in object`</span><br><span class="line">	* 判断对象自身或其原型链上是否包含某个属性</span><br><span class="line"></span><br><span class="line">## 11.8 for...in</span><br></pre></td></tr></table></figure>
<p>for (let/const key in object){<br>    // statements<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 遍历对象</span><br><span class="line">	1. 遍历对象的所有可枚举属性（包括它的原型链上的可枚举属性），属性是否可枚举由属性描述符的`enumerable`决定</span><br><span class="line">	2. 每次循环获取的是属性名</span><br><span class="line">2. 遍历数组（不推荐）</span><br><span class="line">	1. 数组键名是数字，但每次循环获取的是索引的字符串</span><br><span class="line">	2. 除了遍历数组元素外，数组本身以及原型链上的可枚举属性也会被遍历到</span><br><span class="line">	3. 某些情况下，不能保证按顺序返回索引</span><br><span class="line"></span><br><span class="line">## 11.9 for...of</span><br></pre></td></tr></table></figure>
<p>for (let/const value of iterable) {<br>    //statements<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 用来遍历可迭代对象（Array，Map，Set，String，TypedArray，arguments对象，DOM NodeList对象，Generator对象...）</span><br><span class="line">2. 每次循环取出的是值</span><br><span class="line"></span><br><span class="line"># 十二 概念</span><br><span class="line">1. 可枚举属性：属性描述符 `enumerable: true` 的属性</span><br><span class="line">2. 普通对象：没有数字键和length属性的对象</span><br><span class="line">3. 类数组对象：存在数值键名和length属性的对象</span><br><span class="line"></span><br><span class="line">## 十三 Iterator</span><br><span class="line">## 13.1 迭代器</span><br><span class="line">* 迭代器就是具有`next()`方法的对象</span><br><span class="line">* `next()` </span><br><span class="line">	* 返回一个对象，返回对象拥有两个属性</span><br><span class="line">		1. `value`：当前迭代的值</span><br><span class="line">		1. `done`：布尔值，迭代是否结束。</span><br><span class="line">			* false表示没结束，`done:false` 可以省略</span><br><span class="line">			* true表示结束，此时value为undefined，`value:undefined` 可以省略</span><br><span class="line"></span><br><span class="line">## 13.2 Iterator 接口</span><br><span class="line">1. 一个数据结构只要具有 `Symbol.iterator` 属性，就认为是实现了Iterator接口</span><br><span class="line">2. 对象（或者其原型链）上拥有 `Symbol.iterator` 属性，就是可迭代对象</span><br><span class="line"></span><br><span class="line">## 13.3 Symbol.iterator</span><br><span class="line">1. `Symbol.iterator` 本身是一个函数，就是当前数据结构默认的迭代器生成函数。执行这个函数，就会返回一个迭代器</span><br><span class="line">2. `Symbol.iterator` 要放在方括号中，因为它作为属性名是一个表达式，返回Symbole对象的iterator属性。</span><br><span class="line"></span><br><span class="line">## 13.4 for... of</span><br><span class="line">1. for... of 内部就是调用了可迭代对象的 `Symbol.iterator` 生成了迭代器</span><br><span class="line">2. 自定义for... of</span><br></pre></td></tr></table></figure>
<p>function myForOf(arr) {<br>    let it = arr<a href="">Symbol.iterator</a>;<br>    let res = it.next();<br>    while(!res.done) {<br>        console.log(res.value);<br>        res = it.next();<br>    }<br>}</p>
<p>```</p>
<h1 id="十四-全局函数"><a href="#十四-全局函数" class="headerlink" title="十四 全局函数"></a>十四 全局函数</h1><ol>
<li><code>encodeURI(URI)</code><ul>
<li>使用UTF-8进行URL编码，编码后的格式为UTF-8编码的每个字节前加<code>%</code></li>
<li>不会编码的字符<ol>
<li><code>; , / ? : @ &amp; = + $</code></li>
<li><code>字母 数字 - _ . ! ~ * &#39; ( )</code></li>
<li><code>#</code></li>
</ol>
</li>
</ul>
</li>
<li><code>decodeURI(encodedURI)</code><ul>
<li><code>encodeURI()</code>对应的解码函数</li>
</ul>
</li>
<li><code>encodeURIComponent(str)</code><ul>
<li>类似<code>encodeURI()</code>，区别在于不会编码的字符。</li>
<li>不会编码的字符<ul>
<li><code>字母 数字 - _ . ! ~ * &#39; ( )</code></li>
</ul>
</li>
</ul>
</li>
<li><code>decodeURIComponent(encodedURI)</code><ul>
<li><code>encodeURIComponent()</code>对应的解码函数</li>
</ul>
</li>
<li><code>isFinite(value)</code><ul>
<li>见 <code>Number.isFinite(value)</code></li>
</ul>
</li>
<li><code>isNaN(value)</code><ul>
<li>见 <code>Number.isNaN(value)</code></li>
</ul>
</li>
<li><code>parseInt(string[, radix])</code><ul>
<li>见 <code>Number.parseInt(string[, radix])</code></li>
</ul>
</li>
<li><code>parseFloat(string)</code><ul>
<li>见 <code>Number.parseFloat(string)</code></li>
</ul>
</li>
<li><code>eval(string)</code>（永远不要使用!）<ul>
<li>将传入的字符串当做 JavaScript 代码进行执行</li>
<li><code>string</code><ol>
<li>如果是表达式，则对表达式进行求值</li>
<li>如果是一个或多个 JavaScript 语句，则执行这些语句</li>
</ol>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>UI</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript 概述</title>
    <url>/anyeansan.github.io/2020/03/30/Javascript-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ol>
<li>跨平台的解释性脚本语言 </li>
<li>ECMAScript是规范，JavaScript是实现</li>
</ol>
<h2 id="1-2-组成"><a href="#1-2-组成" class="headerlink" title="1.2 组成"></a>1.2 组成</h2><ol>
<li>ECMAScript<ul>
<li>根据MCMA-262标准，实现的通用脚本语言规范</li>
</ul>
</li>
<li>DOM<ul>
<li><code>document object model</code></li>
<li>文档对象模型</li>
</ul>
</li>
<li>BOM<ul>
<li><code>browser object moel</code></li>
<li>浏览器对象模型</li>
</ul>
</li>
</ol>
<h2 id="1-3-JavaScript处理引擎"><a href="#1-3-JavaScript处理引擎" class="headerlink" title="1.3 JavaScript处理引擎"></a>1.3 JavaScript处理引擎</h2><ul>
<li>专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器之中</li>
<li>主要浏览器引擎<ol>
<li><code>chrome v8</code></li>
<li><code>firefox SpiderMonkey</code></li>
<li><code>edge chakra</code></li>
<li><code>Opera Carakan</code></li>
<li>……</li>
</ol>
</li>
</ul>
<h2 id="1-4-网页加载流程-前端"><a href="#1-4-网页加载流程-前端" class="headerlink" title="1.4 网页加载流程 - 前端"></a>1.4 网页加载流程 - 前端</h2><ol>
<li>浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。</li>
<li>css 和 html 是并行加载的，过程中如果遇到css 或者 img，则会向浏览器返回一个请求，待资源返回后，将其添加到dom的相应位置中</li>
<li>解析过程中，浏览器发现<code>&lt;script&gt;</code>元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎（原因是 JavaScript 代码可以修改 DOM，所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题。）</li>
<li>如果<code>&lt;script&gt;</code>元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</li>
<li>JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页</li>
</ol>
<h1 id="二-引入JavaScript脚本"><a href="#二-引入JavaScript脚本" class="headerlink" title="二  引入JavaScript脚本"></a>二  引入JavaScript脚本</h1><h2 id="2-1-JavaScript脚本位置"><a href="#2-1-JavaScript脚本位置" class="headerlink" title="2.1 JavaScript脚本位置"></a>2.1 JavaScript脚本位置</h2><ol>
<li>浏览器加载 JavaScript 脚本，主要通过<code>&lt;script&gt;</code>元素完成</li>
<li>如果外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。所以<code>&lt;script&gt;</code> 最好放在页面底部<ol>
<li>即使遇到脚本失去响应，网页主体的渲染也已经完成了，用户至少可以看到内容</li>
<li>在 DOM 结构生成之前就调用 DOM 节点，JavaScript 会报错，如果脚本都在网页尾部加载，就不存在这个问题，因为这时 DOM 肯定已经生成了。</li>
</ol>
</li>
</ol>
<h2 id="2-2-javascript-协议"><a href="#2-2-javascript-协议" class="headerlink" title="2.2 javascript: 协议"></a>2.2 <code>javascript:</code> 协议</h2><ul>
<li>URL 支持<code>javascript:</code>协议，即在 URL 的位置写入代码，使用这个 URL 的时候就会执行 JavaScript 代码。</li>
</ul>
<h2 id="2-3-JavaScript-脚本引入方式"><a href="#2-3-JavaScript-脚本引入方式" class="headerlink" title="2.3 JavaScript 脚本引入方式"></a>2.3 JavaScript 脚本引入方式</h2><h3 id="1-内联脚本"><a href="#1-内联脚本" class="headerlink" title="1 内联脚本"></a>1 内联脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=&quot;alert(&apos;xxx&apos;)&quot;&gt;第一种直接写方法体&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;button onclick=&quot;fn()&quot;&gt;第二种传递方法&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	function fn() &#123;</span><br><span class="line">		alert(&apos;xxx&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-内部脚本"><a href="#2-内部脚本" class="headerlink" title="2 内部脚本"></a>2 内部脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;点我&lt;/button&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">	document.querySelector(&apos;button&apos;).addEventListener(&apos;click&apos;,() =&gt; alert(&apos;xxx&apos;));</span><br><span class="line">&lt;script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>type可以省略 默认<code>text/javascript</code>，新的浏览器可以写<code>application/javascript</code></li>
</ul>
<h3 id="3-外部脚本"><a href="#3-外部脚本" class="headerlink" title="3 外部脚本"></a>3 外部脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;xxx.js&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>标签体不能有内容，<code>&lt;/script&gt;</code>不能省略</li>
<li><code>src</code> 默认是http协议</li>
<li>外部的js文件中不能包含<code>&lt;script&gt;</code>标签。</li>
</ol>
]]></content>
      <categories>
        <category>UI</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>MongoDB</title>
    <url>/anyeansan.github.io/2020/03/30/MongoDB/</url>
    <content><![CDATA[<h1 id="一-安装"><a href="#一-安装" class="headerlink" title="一 安装"></a>一 安装</h1><ol>
<li>下载解压，并修改属主属组</li>
<li>关闭 Linux 大页内存 THP（transparent huge pages）<ul>
<li><code>https://docs.mongodb.com/v3.6/tutorial/transparent-huge-pages/</code></li>
</ul>
</li>
<li>创建所需用户和用户组</li>
<li>创建存储目录并修改属主属组<ol>
<li><code>data directory</code></li>
<li><code>log file</code></li>
<li><code>conf directory</code></li>
</ol>
</li>
<li>设置用户环境变量<ol>
<li>切换到创建用户</li>
<li>修改用户目录下 <code>.bash_profile</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH=basedir/bin:$PATH</span><br></pre></td></tr></table></figure></li>
<li><code>source .bash_profile</code></li>
</ol>
</li>
</ol>
<h1 id="二-配置"><a href="#二-配置" class="headerlink" title="二 配置"></a>二 配置</h1><ul>
<li>在指定的 <code>conf directory</code> 下创建配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># YAML 模式配置 模板</span><br><span class="line">systemLog:</span><br><span class="line">   destination: file</span><br><span class="line">   path: /var/log/mongodb/mongod.log</span><br><span class="line">   logAppend: true</span><br><span class="line">storage:</span><br><span class="line">   journal:</span><br><span class="line">      enabled: true</span><br><span class="line">      dbPath: </span><br><span class="line">processManagement:</span><br><span class="line">   fork: true # 后台守护进程</span><br><span class="line">   pidFilePath: # pid文件位置，建议不配置，直接生成到data下</span><br><span class="line">net:</span><br><span class="line">   bindIp: 127.0.0.1 # 监听地址，默认 0.0.0.0</span><br><span class="line">   port: 27017</span><br><span class="line">security:</span><br><span class="line">    authorization: enabled # 用户验证</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="三-启动与关闭-mongod"><a href="#三-启动与关闭-mongod" class="headerlink" title="三 启动与关闭 mongod"></a>三 启动与关闭 mongod</h1><h2 id="3-1-启动"><a href="#3-1-启动" class="headerlink" title="3.1 启动"></a>3.1 启动</h2><ol>
<li><code>mongod -f 配置文件</code><ul>
<li>启动</li>
</ul>
</li>
</ol>
<h2 id="3-2-关闭"><a href="#3-2-关闭" class="headerlink" title="3.2 关闭"></a>3.2 关闭</h2><ol>
<li><code>mongod -f 配置文件 --shutdown</code><ul>
<li>关闭</li>
</ul>
</li>
<li><code>db.shutdownServer()</code></li>
<li><code>kill -2 &lt;mongod process ID&gt;</code></li>
</ol>
<h1 id="四-登录与退出"><a href="#四-登录与退出" class="headerlink" title="四 登录与退出"></a>四 登录与退出</h1><ol>
<li><code>mongo -u -p ip/验证库</code></li>
<li><code>exit</code></li>
</ol>
<h1 id="五-概述"><a href="#五-概述" class="headerlink" title="五 概述"></a>五 概述</h1><h2 id="5-1-逻辑结构"><a href="#5-1-逻辑结构" class="headerlink" title="5.1 逻辑结构"></a>5.1 逻辑结构</h2><table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>database</code></td>
<td>库</td>
</tr>
<tr>
<td><code>collection</code></td>
<td>表（集合）</td>
</tr>
<tr>
<td><code>document</code></td>
<td>文档（数据行）</td>
</tr>
<tr>
<td><code>field</code></td>
<td>字段</td>
</tr>
<tr>
<td><code>index</code></td>
<td>索引</td>
</tr>
<tr>
<td><code>primary key</code></td>
<td>主键，MongoDB自动将 <code>_id</code> 字段设置为主键</td>
</tr>
<tr>
<td>* 文档数据都是 BSON 格式。</td>
<td></td>
</tr>
<tr>
<td>* BSON 是一种类似 JSON 的二进制形式的存储格式，是 Binary JSON 的简称</td>
<td></td>
</tr>
</tbody></table>
<h2 id="5-2-默认库"><a href="#5-2-默认库" class="headerlink" title="5.2 默认库"></a>5.2 默认库</h2><ol>
<li><code>test</code><ul>
<li>登录时默认所在库</li>
</ul>
</li>
<li><code>admin</code><ul>
<li>系统预留库，MongoDB系统管理库</li>
</ul>
</li>
<li><code>local</code><ul>
<li>本地预留库，存储关键日</li>
</ul>
</li>
<li><code>config</code><ul>
<li>MongoDB配置信息库</li>
</ul>
</li>
</ol>
<h1 id="六-操作"><a href="#六-操作" class="headerlink" title="六 操作"></a>六 操作</h1><h2 id="6-1-库操作"><a href="#6-1-库操作" class="headerlink" title="6.1 库操作"></a>6.1 库操作</h2><h3 id="1-帮助"><a href="#1-帮助" class="headerlink" title="1 帮助"></a>1 帮助</h3><ol>
<li><code>db.help()</code><ul>
<li>帮助</li>
</ul>
</li>
<li><code>db.[tab][tab]</code><ul>
<li>两次 tab</li>
</ul>
</li>
</ol>
<h3 id="2-查"><a href="#2-查" class="headerlink" title="2 查"></a>2 查</h3><ol>
<li><code>show dbs / show databases</code></li>
<li><code>db</code><ul>
<li>相当于 <code>select database()</code></li>
</ul>
</li>
<li><code>db.status()</code></li>
</ol>
<h3 id="3-增"><a href="#3-增" class="headerlink" title="3 增"></a>3 增</h3><ul>
<li><code>use db_name</code><ul>
<li>若存在，切换到数据库，</li>
<li>若不存在，则创建并切换（注意库中存有数据才会显示在数据库列表中）</li>
</ul>
</li>
</ul>
<h3 id="4-删"><a href="#4-删" class="headerlink" title="4 删"></a>4 删</h3><ul>
<li><code>db.dropDatabase()</code></li>
</ul>
<h2 id="6-2-集合操作"><a href="#6-2-集合操作" class="headerlink" title="6.2 集合操作"></a>6.2 集合操作</h2><h3 id="1-查"><a href="#1-查" class="headerlink" title="1 查"></a>1 查</h3><ul>
<li><code>show collections / show tables</code></li>
</ul>
<h3 id="2-增"><a href="#2-增" class="headerlink" title="2 增"></a>2 增</h3><ul>
<li><code>db.createCollection(name, options)</code><ul>
<li><code>name</code><ul>
<li>集合名称</li>
</ul>
</li>
<li><code>options</code><ol>
<li><code>capped</code><ol>
<li><code>false</code> ：默认</li>
<li><code>true</code> ：创建固定大小的集合，当达到最大值时，它会自动覆盖最早的文档，必须指定 <code>size</code> 参数</li>
</ol>
</li>
<li><code>size</code><ul>
<li>为固定集合指定一个最大值（KB）</li>
</ul>
</li>
<li><code>max</code><ul>
<li>指定固定集合中包含文档的最大数量</li>
</ul>
</li>
<li><code>autoIndexId</code><ol>
<li><code>false</code> ：默认</li>
<li><code>true</code> ：自动在 _id 字段创建索引</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="3-删"><a href="#3-删" class="headerlink" title="3 删"></a>3 删</h3><ul>
<li><code>db.collection.drop()</code></li>
</ul>
<h2 id="6-3-文档操作"><a href="#6-3-文档操作" class="headerlink" title="6.3 文档操作"></a>6.3 文档操作</h2><h3 id="1-增"><a href="#1-增" class="headerlink" title="1 增"></a>1 增</h3><ol>
<li><code>db.collection_name.insertOne()</code><ul>
<li>如果指定 collection 不存在，则会创建</li>
</ul>
</li>
<li><code>db.collection_name.insertMany()</code></li>
</ol>
<h3 id="2-删"><a href="#2-删" class="headerlink" title="2 删"></a>2 删</h3><ol>
<li><code>db.collection_name.deleteOne()</code></li>
<li><code>db.collection_name.deleteMany()</code></li>
</ol>
<h3 id="4-改"><a href="#4-改" class="headerlink" title="4 改"></a>4 改</h3><ol>
<li><code>db.collection_name.updateOne()</code></li>
<li><code>db.collection_name.updateMany()</code></li>
<li><code>db.collection_name.replaceOne()</code></li>
</ol>
<h3 id="4-查"><a href="#4-查" class="headerlink" title="4 查"></a>4 查</h3><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h4><ul>
<li><code>db.collection_name.find()[.limit()][.pretty()]</code><ul>
<li>查询所有</li>
<li><code>.pretty()</code><ul>
<li>以 json 格式显示结果</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-比较"><a href="#2-比较" class="headerlink" title="2 比较"></a>2 比较</h4><table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>{key:value}</code></td>
<td>等于</td>
</tr>
<tr>
<td><code>{key:{$ne:value}}</code></td>
<td>不等于</td>
</tr>
<tr>
<td><code>{key:{$lt:value}}</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>{key:{$lte:value}}</code></td>
<td>小于等于</td>
</tr>
<tr>
<td><code>{key:{$gt:value}}</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>{key:{$gte:value}}</code></td>
<td>大于等于</td>
</tr>
</tbody></table>
<h4 id="3-and"><a href="#3-and" class="headerlink" title="3 and"></a>3 and</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	key:value,</span><br><span class="line">	key:value,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-or"><a href="#4-or" class="headerlink" title="4 or"></a>4 or</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	$or: [</span><br><span class="line">		&#123;key:value&#125;,</span><br><span class="line">		&#123;key:value&#125;,</span><br><span class="line">		...</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七-用户管理"><a href="#七-用户管理" class="headerlink" title="七 用户管理"></a>七 用户管理</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ol>
<li>验证库<ul>
<li>登陆时要指定验证库才能登录，验证库即创建用户时 user 到的库</li>
</ul>
</li>
<li>管理员验证库为 <code>admin</code>，即管理员必须在 <code>admin</code> 库下创建</li>
<li>普通用户在所管理的库下创建</li>
</ol>
<h2 id="7-2-创建用户"><a href="#7-2-创建用户" class="headerlink" title="7.2 创建用户"></a>7.2 创建用户</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user db_name # 指定验证库</span><br><span class="line">db.createUser(</span><br><span class="line">&#123;</span><br><span class="line">	user: &quot;用户名&quot;,</span><br><span class="line">	pwd: &quot;密码&quot;,</span><br><span class="line">	roles: [</span><br><span class="line">		&#123;role: &quot;root&quot;, db: &quot;admin&quot;&#125;, # 用来创建管理员</span><br><span class="line">		&#123;role: &quot;read&quot;, db: &quot;数据库&quot;&#125;,</span><br><span class="line">		&#123;role: &quot;readWrite&quot;, db: &quot;数据库&quot;&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">db.auth(&apos;username&apos;,&apos;password&apos;) # 验证用户</span><br></pre></td></tr></table></figure>

<h2 id="7-3-查看用户"><a href="#7-3-查看用户" class="headerlink" title="7.3 查看用户"></a>7.3 查看用户</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.system.users.find().pretty()</span><br></pre></td></tr></table></figure>

<h2 id="7-4-删除用户（管理员登录）"><a href="#7-4-删除用户（管理员登录）" class="headerlink" title="7.4 删除用户（管理员登录）"></a>7.4 删除用户（管理员登录）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user db_name </span><br><span class="line">db.dropUser(&quot;username&quot;)</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>DB</category>
        <category>MongoDB</category>
      </categories>
  </entry>
  <entry>
    <title>MySql 数据库设计</title>
    <url>/anyeansan.github.io/2020/03/30/MySql-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="一-范式概述"><a href="#一-范式概述" class="headerlink" title="一 范式概述"></a>一 范式概述</h1><ul>
<li><code>Normal Format</code><ul>
<li>是一种离散数学中的知识, 是为了解决一种数据的存储与优化的问题: 保存数据的存储之后, 凡是能够通过关系寻找出来的数据,坚决不再重复存储: 终极目标是为了减少数据的冗余.</li>
</ul>
</li>
<li>范式是一种分层结构的规范, 分为六层: 每一次层都比上一层更加严格: 若要满足下一层范式,前提是满足上一层范式.<ul>
<li>1NF,2NF,3NF…6NF</li>
<li>1NF是最底层,要求最低;6NF最高层,最严格</li>
</ul>
</li>
</ul>
<h1 id="二-1NF"><a href="#二-1NF" class="headerlink" title="二 1NF"></a>二 1NF</h1><ul>
<li>第一范式: 在设计表存储数据的时候, 如果表中设计的字段存储的数据,在取出来使用之前还需要额外的处理(拆分),那么说表的设计不满足第一范式</li>
<li>第一范式要求字段的数据具有原子性: 不可再分</li>
<li>解决<ul>
<li>拆分字段</li>
</ul>
</li>
</ul>
<h1 id="二-2NF"><a href="#二-2NF" class="headerlink" title="二 2NF"></a>二 2NF</h1><ul>
<li>第二范式: 在数据表设计的过程中,如果有复合主键(多字段主键), 且表中有字段并不是由整个主键来确定, 而是依赖主键中的某个字段(主键的部分): 存在字段依赖主键的部分的问题, 称之为部分依赖:</li>
<li>第二范式就是要解决表设计不允许出现部分依赖</li>
<li>解决<ol>
<li>可以将复合主键字段单独成表</li>
<li>取消复合主键，使用逻辑主键 </li>
</ol>
</li>
</ul>
<h1 id="三-3NF"><a href="#三-3NF" class="headerlink" title="三 3NF"></a>三 3NF</h1><ul>
<li>第三范式: 理论上讲,应该一张表中的所有字段都应该直接依赖主键(逻辑主键: 代表的是业务主键), 如果表设计中存在一个字段, 并不直接依赖主键,而是通过某个非主键字段依赖,最终实现依赖主键: 把这种不是直接依赖主键,而是依赖非主键字段的依赖关系称之为传递依赖</li>
<li>第三范式就是要解决传递依赖的问题.</li>
<li>解决<ul>
<li>将存在传递依赖的字段,以及依赖的字段本身单独取出,形成一个单独的表, 然后在需要对应的信息的时候, 使用对应的实体表的主键加进来.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>DB</category>
        <category>MySql</category>
      </categories>
  </entry>
  <entry>
    <title>MySql 触发器</title>
    <url>/anyeansan.github.io/2020/03/30/MySql-%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>事先为某张表绑定好一段代码 ,当表中的某些内容发生改变的时候(增删改)系统会自动触发代码,执行</li>
<li>一张表中只能拥有一种触发时间的一种类型的触发器<ul>
<li>一张表最多能有6个触发器<ul>
<li>增删改/前后 6种组合</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="二-事件类型"><a href="#二-事件类型" class="headerlink" title="二 事件类型"></a>二 事件类型</h1><ul>
<li>增(insert)</li>
<li>删(delete)</li>
<li>改(update)</li>
</ul>
<h1 id="三-触发时间"><a href="#三-触发时间" class="headerlink" title="三 触发时间"></a>三 触发时间</h1><ul>
<li>前(before)</li>
<li>后(after)</li>
</ul>
<h1 id="四-触发对象"><a href="#四-触发对象" class="headerlink" title="四 触发对象"></a>四 触发对象</h1><ul>
<li>表中的每一条记录(行)</li>
</ul>
<h1 id="五-创建触发器"><a href="#五-创建触发器" class="headerlink" title="五 创建触发器"></a>五 创建触发器</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 临时修改语句结束符</span><br><span class="line">Delimiter 自定义符号: 后续代码中只有碰到自定义符号才算结束</span><br><span class="line"></span><br><span class="line">Create trigger 触发器名字 触发时间 事件类型 on 表名 for each row</span><br><span class="line"></span><br><span class="line">Begin		-- 代表左大括号: 开始</span><br><span class="line">-- 里面就是触发器的内容: 每行内容都必须使用语句结束符: 分号</span><br><span class="line">End			-- 代表右带括号: 结束</span><br><span class="line"></span><br><span class="line">-- 语句结束符</span><br><span class="line">自定义符号</span><br><span class="line"></span><br><span class="line">-- 将临时修改修正过来</span><br><span class="line">Delimiter  ;</span><br></pre></td></tr></table></figure>

<h1 id="六-查看触发器"><a href="#六-查看触发器" class="headerlink" title="六 查看触发器"></a>六 查看触发器</h1><ul>
<li><code>Information_schema.triggers</code><ul>
<li>所有的触发器都会保存这一张表中</li>
</ul>
</li>
<li><code>Show triggers [like ‘pattern’]</code><ul>
<li>查看所有或者模糊匹配</li>
</ul>
</li>
<li><code>Show create trigger 触发器名</code><ul>
<li>查看触发器创建语句</li>
</ul>
</li>
</ul>
<h1 id="七-使用触发器"><a href="#七-使用触发器" class="headerlink" title="七 使用触发器"></a>七 使用触发器</h1><ul>
<li>不需要手动调用, 而是当某种情况发生时会自动触发.</li>
</ul>
<h1 id="八-修改-amp-删除触发器"><a href="#八-修改-amp-删除触发器" class="headerlink" title="八 修改&amp;删除触发器"></a>八 修改&amp;删除触发器</h1><ul>
<li>触发器不能修改</li>
<li><code>Drop trigger 触发器名</code><ul>
<li>删除</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>DB</category>
        <category>MySql</category>
      </categories>
  </entry>
  <entry>
    <title>MySql 存储过程</title>
    <url>/anyeansan.github.io/2020/03/30/MySql-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>SQL 的执行过程<ul>
<li><code>sql语句 → mysql引擎 → 检查语法 → 编译 → 执行 → 返回结果</code></li>
</ul>
</li>
<li>存储过程是一组为了完成特定功能的sql语句和流程控制语句的预编译集合，存储在数据库内，可以由应用程序调用。</li>
<li>存储过程的好处<ol>
<li>可复用</li>
<li>预编译：只在创建时编译一次，以后调用时不再编译，速度快</li>
<li>减少网络流量：存储过程存储在数据库服务器上，都在数据库服务器上运行，调用存储过程时只需要传递名称和参数即可。</li>
<li>安全：可防止sql注入。</li>
</ol>
</li>
</ol>
<h1 id="二-语法"><a href="#二-语法" class="headerlink" title="二 语法"></a>二 语法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE</span><br><span class="line">	[DEFINER = user]</span><br><span class="line">	PROCEDURE sp_name ([proc_parameter[,...]])</span><br><span class="line">	[characteristic ...]</span><br><span class="line">	routine_body</span><br><span class="line"></span><br><span class="line">proc_parameter:</span><br><span class="line">    [ IN | OUT | INOUT ] param_name type</span><br></pre></td></tr></table></figure>

<h1 id="三-创建"><a href="#三-创建" class="headerlink" title="三 创建"></a>三 创建</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE IF EXISTS 存储过程名;</span><br><span class="line">DELIMITER [结束标记]</span><br><span class="line">CREATE PROCEDURE 存储过程名([参数列表])</span><br><span class="line">BEGIN</span><br><span class="line">        [存储过程体(一组合法的SQL语句)]</span><br><span class="line">END [结束标记]</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<ul>
<li>形参<ul>
<li><code>in</code><ul>
<li>输入参数，调用存储过程时传入的值</li>
</ul>
</li>
<li><code>out</code><ul>
<li>输出参数，可在存储过程内部被改变并返回。</li>
<li><code>into</code><ul>
<li>使用 <code>into</code> 为out参数赋值</li>
</ul>
</li>
</ul>
</li>
<li><code>inout</code><ul>
<li>输入输出参数，调用存储过程时传入值，在存储过程内部可以改变并返回。</li>
</ul>
</li>
</ul>
</li>
<li>返回值<ul>
<li>存储过程可以有返回值也可以没有返回值。</li>
</ul>
</li>
</ul>
<h1 id="四-查看"><a href="#四-查看" class="headerlink" title="四 查看"></a>四 查看</h1><ol>
<li><code>show procedure status [like ‘pattern’]</code><ul>
<li>查看所有存储过程或模糊匹配</li>
</ul>
</li>
<li><code>show create procedure 过程名</code><ul>
<li>查看过程创建语句:</li>
</ul>
</li>
</ol>
<h1 id="五-调用"><a href="#五-调用" class="headerlink" title="五 调用"></a>五 调用</h1><ul>
<li><code>call 存储过程名(in参数, @out参数, @inout参数)</code><ol>
<li>存储过程没有返回值（通过out返回），不能用select调用。</li>
<li>实参<ol>
<li>in参数：直接传递即可</li>
<li>out参数：定义一个变量接收返回值<code>@变量名</code></li>
<li>inout参数：在外部定义一个变量，并设置值</li>
</ol>
</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// in</span><br><span class="line">call inpr(3);</span><br><span class="line">// out</span><br><span class="line">call outpr(@name);</span><br><span class="line">select @name;</span><br><span class="line">// inout</span><br><span class="line">set @age = 10;</span><br><span class="line">call inoutpr(@age);</span><br><span class="line">select @age;</span><br></pre></td></tr></table></figure>

<h1 id="六-修改-amp-删除"><a href="#六-修改-amp-删除" class="headerlink" title="六 修改&amp;删除"></a>六 修改&amp;删除</h1><ol>
<li>存储过程不可修改</li>
<li>删除<ul>
<li><code>drop procedoure [if exists] 存储过程名</code></li>
</ul>
</li>
</ol>
<h1 id="七-存储过程和自定义函数的区别"><a href="#七-存储过程和自定义函数的区别" class="headerlink" title="七 存储过程和自定义函数的区别"></a>七 存储过程和自定义函数的区别</h1><ol>
<li>存储过程实现的功能更复杂，函数的针对性更强</li>
<li>存储过程可以返回多个值，函数只能返回一个值</li>
<li>存储过程一般单独执行，函数可以作为其它sql语句的组成部分。</li>
</ol>
]]></content>
      <categories>
        <category>DB</category>
        <category>MySql</category>
      </categories>
  </entry>
  <entry>
    <title>MySql 视图</title>
    <url>/anyeansan.github.io/2020/03/30/MySql-%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>view可以看作是一张虚拟表，是表通过某种运算得到的一个投影。</li>
<li>视图中并没有真正存储数据。</li>
<li>表的改变会影响视图(视图就好像表的影子一样)</li>
<li>视图的改变也能影响表。(如果可以改变的话)</li>
<li>可以跟基本表一样，进行增删改查操作</li>
</ol>
<h1 id="二-数据操作"><a href="#二-数据操作" class="headerlink" title="二 数据操作"></a>二 数据操作</h1><ol>
<li>主要是用来查询</li>
<li>增删改操作有条件限制<ul>
<li>如果视图的数据与表的数据是一一对应出来的，改变不会影响其它数据，就可以增删改。</li>
<li>如果视图的数据是通过计算得来的，改变则会影响表中的其它数据，不可以增删改。</li>
</ul>
</li>
</ol>
<h1 id="三-视图作用"><a href="#三-视图作用" class="headerlink" title="三 视图作用"></a>三 视图作用</h1><ol>
<li>方便操作，特别是查询操作，减少复杂的SQL语句<ul>
<li>将一条复杂的查询语句使用视图进行保存: 以后可以直接对视图进行操作</li>
</ul>
</li>
<li>数据安全<ul>
<li>视图操作是主要针对查询的, 如果对视图结构进行处理(删除), 不会影响基表数据(相对安全).</li>
<li>可以对外提供有用的数据, 但是隐藏关键(无用)的数据</li>
<li>数据库授权命令不能限定到特定行和特定列，但是通过合理创建视图，可以把权限限定到行列级别</li>
</ul>
</li>
<li>权限控制<ul>
<li>不希望用户访问表中某些含敏感信息的列,可以通过view开放某几个列</li>
</ul>
</li>
<li>数据过多时，分表用</li>
</ol>
<h1 id="四-视图操作"><a href="#四-视图操作" class="headerlink" title="四 视图操作"></a>四 视图操作</h1><h2 id="4-1-创建视图"><a href="#4-1-创建视图" class="headerlink" title="4.1 创建视图"></a>4.1 创建视图</h2><ul>
<li><code>create view 视图名 as select语句</code></li>
</ul>
<h2 id="4-2-查看视图"><a href="#4-2-查看视图" class="headerlink" title="4.2 查看视图"></a>4.2 查看视图</h2><ul>
<li><code>show create table/view 视图名</code></li>
<li><code>show tables [like]/desc 视图名</code><ul>
<li>视图是一张虚拟表，表的所有查看方式，视图都能用，且视图比表多一个关键字view</li>
</ul>
</li>
</ul>
<h2 id="4-3-修改视图"><a href="#4-3-修改视图" class="headerlink" title="4.3 修改视图"></a>4.3 修改视图</h2><ul>
<li><code>alter view 视图名 as 新的select语句</code><ul>
<li>视图本身不可修改，但视图来源可以修改</li>
</ul>
</li>
</ul>
<h2 id="4-4-删除视图"><a href="#4-4-删除视图" class="headerlink" title="4.4 删除视图"></a>4.4 删除视图</h2><ul>
<li><code>drop view 视图名</code></li>
</ul>
<h1 id="五-视图算法-algorithm"><a href="#五-视图算法-algorithm" class="headerlink" title="五 视图算法(algorithm)"></a>五 视图算法(algorithm)</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ul>
<li>系统对视图以及外部查询视图的Select语句的一种解析方式</li>
<li><code>create algorithm=xxx view 视图名 as select 语句</code><ul>
<li>是对标准sql的mysql的扩展</li>
</ul>
</li>
</ul>
<h2 id="5-2-分类"><a href="#5-2-分类" class="headerlink" title="5.2 分类"></a>5.2 分类</h2><ul>
<li><code>undefined</code><ul>
<li>未定义(默认的), 这不是一种实际使用算法, 是一种推卸责任的算法: 告诉系统,视图没有定义算法, 系统自己看着办<ul>
<li>未定义由系统定义，它倾向于MERGE而不是TEMPTABLE</li>
<li>因为MERGE通常更有效，而且如果使用了临时表，视图是不可更新的。</li>
</ul>
</li>
</ul>
</li>
<li><code>temptable</code><ul>
<li>临时表算法: 系统应该先执行视图的select语句,后执行外部查询语句<ul>
<li>视图的结果将被置于临时表中，然后使用它执行语句</li>
<li>适合复杂查询形成的view</li>
</ul>
</li>
</ul>
</li>
<li><code>merge</code><ul>
<li>合并算法: 系统应该先将视图对应的select语句与外部查询视图的select语句进行合并,然后执行(效率高: 常态)<ul>
<li>将查询视图的语句与视图定义语句合并起来<ul>
<li>查询视图的语句+视图定义语句=查询物理表的语句</li>
</ul>
</li>
<li>合并查询语句，不会创建临时表</li>
<li>适合简单查询形成的view</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-3-算法选择"><a href="#5-3-算法选择" class="headerlink" title="5.3 算法选择"></a>5.3 算法选择</h2><ul>
<li>如果视图的select语句中会包含一个查询子句(五子句), 而且很有可能顺序比外部的查询语句要靠后, 一定要使用算法temptable,其他情况可以不用指定(默认即可)</li>
</ul>
]]></content>
      <categories>
        <category>DB</category>
        <category>MySql</category>
      </categories>
  </entry>
  <entry>
    <title>MySql 日志</title>
    <url>/anyeansan.github.io/2020/03/30/MySql-%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="一-日志分类"><a href="#一-日志分类" class="headerlink" title="一 日志分类"></a>一 日志分类</h1><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Error log</code></td>
<td>错误日志</td>
</tr>
<tr>
<td><code>Binary log</code></td>
<td>二进制日志</td>
</tr>
<tr>
<td><code>Slow query log</code></td>
<td>慢查询日志</td>
</tr>
<tr>
<td><code>General query log</code></td>
<td>常规日志</td>
</tr>
</tbody></table>
<h1 id="二-错误日志"><a href="#二-错误日志" class="headerlink" title="二 错误日志"></a>二 错误日志</h1><ol>
<li>默认开启</li>
<li>默认存储位置 <code>datadir/hostname.err</code></li>
<li><code>select @@log_error</code><ul>
<li>查看错误日志位置</li>
</ul>
</li>
<li>手动配置 <code>/etc/my.cnf</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log_error=路径</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="三-二进制日志"><a href="#三-二进制日志" class="headerlink" title="三 二进制日志"></a>三 二进制日志</h1><h2 id="3-1-作用"><a href="#3-1-作用" class="headerlink" title="3.1 作用"></a>3.1 作用</h2><ol>
<li>主从环境必须依赖二进制日志</li>
<li>备份恢复必须依赖二进制日志</li>
</ol>
<h2 id="3-2-配置"><a href="#3-2-配置" class="headerlink" title="3.2 配置"></a>3.2 配置</h2><ol>
<li>默认没有开启</li>
<li>手动配置 <code>/etc/my.cnf</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">1 server_id= </span><br><span class="line">	# 服务ID号 0 ~ 65535</span><br><span class="line">2 log_bin=1</span><br><span class="line">	# 开启二进制日志</span><br><span class="line">3 log_bin_basename=/目录/二进制日志文件名前缀</span><br><span class="line">	# 设置存储目录及文件前缀</span><br><span class="line">4 log_bin=/目录/二进制日志文件名前缀</span><br><span class="line">	# 等同于 2,3两步</span><br><span class="line">5 binlog_format=row</span><br><span class="line">	# 二进制日志格式，5.7 默认配置，可以省略</span><br><span class="line">6 sync_binlog=1</span><br><span class="line">	# 每次提交都立即刷写binlog到磁盘</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="3-3-二进制日志记录内容"><a href="#3-3-二进制日志记录内容" class="headerlink" title="3.3 二进制日志记录内容"></a>3.3 二进制日志记录内容</h2><h3 id="1-内容"><a href="#1-内容" class="headerlink" title="1 内容"></a>1 内容</h3><ul>
<li>记录了数据库所有变更类的操作日志<ol>
<li>DDL：原封不动的记录当前 DDL（statement 语句方式），即原样记录语句</li>
<li>DCL：原封不动的记录当前 DCL（statement 语句方式）</li>
<li>DML：只记录已经提交的事务 DML</li>
</ol>
</li>
</ul>
<h3 id="2-DML-记录模式"><a href="#2-DML-记录模式" class="headerlink" title="2 DML 记录模式"></a>2 DML 记录模式</h3><ol>
<li><code>statment</code><ul>
<li>SBR（statement based replication）模式</li>
<li>语句模式，原封不动的记录当前DML</li>
<li>可读性较高，日志量少，但是不够严谨</li>
</ul>
</li>
<li><code>row</code><ul>
<li>RBR（ROW based replication）模式</li>
<li>记录数据行的变化（用户看不懂，需要工具分析）</li>
<li>可读性很低，日志量大，足够严谨</li>
</ul>
</li>
<li><code>mixed</code><ul>
<li>MBR（mixed based replication）模式 </li>
<li>以上两种模式的混合</li>
</ul>
</li>
</ol>
<h2 id="3-4-二进制日记记录单元-event"><a href="#3-4-二进制日记记录单元-event" class="headerlink" title="3.4 二进制日记记录单元 event"></a>3.4 二进制日记记录单元 event</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>event 是二进制日志的最小记录单元</li>
<li>DDL DCL<ul>
<li>一个语句就是一个 event</li>
</ul>
</li>
<li>DML ：只记录已提交的事务<ol>
<li>begin 是一个 event</li>
<li>DML 语句的 event</li>
<li>commit 是一个 event</li>
</ol>
</li>
</ol>
<h3 id="2-event-组成"><a href="#2-event-组成" class="headerlink" title="2 event 组成"></a>2 event 组成</h3><ol>
<li>事件的开始标识：<code>position</code> 号</li>
<li>事件内容</li>
<li>事件的结束标识：<code>end_log_position</code> 号</li>
</ol>
<h2 id="3-5-二进制日志-操作"><a href="#3-5-二进制日志-操作" class="headerlink" title="3.5 二进制日志 操作"></a>3.5 二进制日志 操作</h2><h3 id="1-查看信息"><a href="#1-查看信息" class="headerlink" title="1 查看信息"></a>1 查看信息</h3><ol>
<li><code>show variables like &#39;%log_bin%&#39;</code><ul>
<li>查看二进制日志路径</li>
</ul>
</li>
<li><code>show binary logs</code><ul>
<li>查看所有二进制日志</li>
</ul>
</li>
<li><code>show master status</code><ul>
<li>查看当前使用的二进制日志</li>
</ul>
</li>
<li><code>show binlog events in &#39;log_name&#39; [from pos] [limit]</code><ul>
<li>查看二进制日志 event 信息</li>
</ul>
</li>
</ol>
<h3 id="2-查看内容-mysqlbinlog"><a href="#2-查看内容-mysqlbinlog" class="headerlink" title="2 查看内容 mysqlbinlog"></a>2 查看内容 mysqlbinlog</h3><ul>
<li><code>mysqlbinlog [OPTION] 日志路径</code><ul>
<li><code>--base64-output=decode-rows</code><ul>
<li>以指定格式输出</li>
</ul>
</li>
<li><code>-vvv</code><ul>
<li>更详细</li>
</ul>
</li>
<li><code>--start-position</code><ul>
<li>开始位置</li>
</ul>
</li>
<li><code>--stop-position</code><ul>
<li>结束位置</li>
</ul>
</li>
<li><code>-d db_name</code><ul>
<li>只查看指定库的日志</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-恢复"><a href="#3-恢复" class="headerlink" title="3 恢复"></a>3 恢复</h3><ol>
<li><code>mysqlbinlog --start-position= --stop--position= &gt;/tmp/log.sql</code><ul>
<li>将指定位置的二进制日志内容截取出来输出到一个文件，其实就是sql脚本，执行即可</li>
</ul>
</li>
<li><code>set sql_log_bin=0</code><ul>
<li>临时关闭二进制日志，因为恢复时也会产生二进制日志，没有必要</li>
</ul>
</li>
<li><code>source /tmp/log.sql</code></li>
<li><code>set sql_log_bin=1</code></li>
</ol>
<h2 id="3-6-GTID-模式管理二进制日志"><a href="#3-6-GTID-模式管理二进制日志" class="headerlink" title="3.6 GTID 模式管理二进制日志"></a>3.6 GTID 模式管理二进制日志</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>GTID <code>Global Transaction ID</code></li>
<li>对二进制日志中每一个事务，自动生成一个 GTID 号<ol>
<li>DDL DCL<ul>
<li>一个 event 就是一个事务，就有一个 GTID</li>
</ul>
</li>
<li>DML<ul>
<li>一个事务（从 begin 到 commit）一个 GTID</li>
</ul>
</li>
</ol>
</li>
<li>GTID 幂等性<ul>
<li>使用有 GTID 的二进制日志做恢复时，会检查当前系统是否有相同的 GTID，若有则跳过不再执行。</li>
<li>会影响恢复和主从复制</li>
</ul>
</li>
</ol>
<h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2 配置"></a>2 配置</h3><ol>
<li>默认未开启</li>
<li><code>/etc/my.cnf</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">gtid-mode=on</span><br><span class="line">enforce-gtid-consistency=true</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="3-GTID-组成"><a href="#3-GTID-组成" class="headerlink" title="3 GTID 组成"></a>3 GTID 组成</h3><ul>
<li><code>server_uuid:transaction_id</code><ul>
<li><code>server_uuid</code><ul>
<li>启动 mysql 自动生成，存储在 <code>datadir/auto.cnf</code></li>
</ul>
</li>
<li><code>transaction_id</code><ul>
<li>从 1 开始，自增长</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-查看有-GTID-的日志内容"><a href="#4-查看有-GTID-的日志内容" class="headerlink" title="4 查看有 GTID 的日志内容"></a>4 查看有 GTID 的日志内容</h3><ul>
<li><code>mysqlbinlog [OPTION] 日志路径</code><ul>
<li><code>OPTION</code><ul>
<li><code>--incude-gtids</code><ul>
<li>包含指定 gtid，多个逗号隔开，连续可以 <code>server_uuid:1-8</code></li>
</ul>
</li>
<li><code>--exclude-gtids</code><ul>
<li>排除指定 gtid</li>
</ul>
</li>
<li><code>--skip-gtids</code><ul>
<li>由于 gtid 的幂等性，导出的 sql 执行时会报错，因为已经存在相同 gtid</li>
<li>此选项表示：导出时，忽略原有的 GTID 信息，恢复时当作新事务对待</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-基于-GTID-的恢复"><a href="#5-基于-GTID-的恢复" class="headerlink" title="5  基于 GTID 的恢复"></a>5  基于 GTID 的恢复</h3><ol>
<li><code>mysqlbinlog --skip-gtids --include-gtids= 日志路径&gt;/tmp/log.sql</code></li>
<li><code>set sql_log_bin=0</code></li>
<li><code>source /tmp/log.sql</code></li>
<li><code>set sql_log_bin=1</code></li>
</ol>
<h2 id="3-7-二进制日志清理"><a href="#3-7-二进制日志清理" class="headerlink" title="3.7 二进制日志清理"></a>3.7 二进制日志清理</h2><h3 id="1-自动清理"><a href="#1-自动清理" class="headerlink" title="1 自动清理"></a>1 自动清理</h3><ul>
<li><code>expire_logs_days</code><ul>
<li>二进制日志过期天数，<code>0</code> 表示永不过期</li>
<li>建议至少保留两个全备周期 +1</li>
</ul>
</li>
</ul>
<h3 id="2-手动清理"><a href="#2-手动清理" class="headerlink" title="2 手动清理"></a>2 手动清理</h3><ol>
<li><code>purge binary logs to &#39;log_name&#39;</code><ul>
<li>删除指定日志之前的日志</li>
</ul>
</li>
<li><code>purge binary logs before &#39;time&#39;</code><ul>
<li>删除指定日期之前的日志</li>
</ul>
</li>
</ol>
<h2 id="3-8-日志滚动"><a href="#3-8-日志滚动" class="headerlink" title="3.8 日志滚动"></a>3.8 日志滚动</h2><ol>
<li><code>flush logs</code></li>
<li>重启 mysql 会自动滚动一个新的</li>
<li>日志文件达到 <code>max_binlog_size</code></li>
</ol>
<h1 id="四-慢查询日志"><a href="#四-慢查询日志" class="headerlink" title="四 慢查询日志"></a>四 慢查询日志</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ul>
<li>记录运行较慢的 SQL语句，优化常用</li>
</ul>
<h2 id="4-2-配置"><a href="#4-2-配置" class="headerlink" title="4.2 配置"></a>4.2 配置</h2><ol>
<li>默认未开启</li>
<li><code>/etc/my.cnf</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">1 slow_query_log=1 </span><br><span class="line">	# 开启 </span><br><span class="line">2 slow_query_log_file=/目录/文件</span><br><span class="line">	# 日志文件路径</span><br><span class="line">3 long_query_time=0.1</span><br><span class="line">	# 设置慢查询时间，超过此时间就算慢，默认 10.000000 10秒，小数位表示粒度</span><br><span class="line">4 log_queries_not_using_indexes</span><br><span class="line">	# 没走索引的语句也记录</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="4-3-分析"><a href="#4-3-分析" class="headerlink" title="4.3 分析"></a>4.3 分析</h2><ul>
<li><code>mysqldumpslow -s c -t N 日志路径</code><ul>
<li><code>-s c</code><ul>
<li>sort，按次数排序</li>
</ul>
</li>
<li><code>-t N</code><ul>
<li>top，取前多少个</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-4-相关参数"><a href="#4-4-相关参数" class="headerlink" title="4.4 相关参数"></a>4.4 相关参数</h2><ol>
<li><code>slow_query_log</code></li>
<li><code>long_query_time</code></li>
<li><code>log_throttle_queries_not_using_indexes</code></li>
</ol>
]]></content>
      <categories>
        <category>DB</category>
        <category>MySql</category>
      </categories>
  </entry>
  <entry>
    <title>MySql 事务</title>
    <url>/anyeansan.github.io/2020/03/30/MySql-%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="一-ACID-特性"><a href="#一-ACID-特性" class="headerlink" title="一 ACID 特性"></a>一 ACID 特性</h1><p>特性||说明<br>-|-<br><code>原子性 Atomicity</code>|一个事务是一个不可分割的单元，事务中的操作要么都成功，要么都取消<br><code>一致性 Consistency</code>|事务的执行不能破坏数据库数据的完整性和一致性<br><code>隔离性 Isolation</code>|事务之间是互不干扰的<br><code>持久性 Durability</code>|一个事务一旦被提交，它对数据库中数据的改变就是永久性的</p>
<h1 id="二-事务的生命周期"><a href="#二-事务的生命周期" class="headerlink" title="二 事务的生命周期"></a>二 事务的生命周期</h1><h2 id="2-1-标准生命周期"><a href="#2-1-标准生命周期" class="headerlink" title="2.1 标准生命周期"></a>2.1 标准生命周期</h2><ol>
<li><code>begin</code></li>
<li><code>DML（insert update delete）</code></li>
<li><code>commit | rollback</code></li>
</ol>
<h2 id="2-2-autocommit"><a href="#2-2-autocommit" class="headerlink" title="2.2 autocommit"></a>2.2 autocommit</h2><ol>
<li>默认 <code>atutocommit = 1</code> 即开启自动提交</li>
<li>执行 <code>DML</code> 时会自动开启事务并提交</li>
<li>关闭自动提交<ol>
<li><code>set autocommit = 0</code><ul>
<li>会话级别</li>
</ul>
</li>
<li><code>set global autocommit = 0</code><ul>
<li>全局级别，影响所有会话，重启失效</li>
</ul>
</li>
<li><code>vim /etc/my.cnf</code> 中添加 <code>autocommit=0</code><ul>
<li>永久生效</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="2-3-隐式提交"><a href="#2-3-隐式提交" class="headerlink" title="2.3 隐式提交"></a>2.3 隐式提交</h2><ul>
<li>开启事务后，在事务中执行一些语句会触发隐式提交（应避免）<ol>
<li>DDL（<code>alte</code> <code>create</code> <code>drop</code> <code>truncate</code>）</li>
<li>DCL（<code>grant</code> <code>revoke</code> <code>set password</code>）</li>
<li>锁（<code>lock tables</code> <code>unlock tables</code>）</li>
<li>…</li>
</ol>
</li>
</ul>
<h1 id="三-事务原理"><a href="#三-事务原理" class="headerlink" title="三 事务原理"></a>三 事务原理</h1><h2 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h2><ol>
<li><code>redo log</code><ul>
<li>保存在 <code>ib_logfile0~1</code> 默认50M，轮询使用</li>
<li><code>redo log buffer</code><ul>
<li>redo log 缓冲区</li>
</ul>
</li>
</ul>
</li>
<li><code>ibd</code><ul>
<li>存储数据行和索引</li>
<li><code>data bufer pool</code><ul>
<li>数据和索引的缓冲区</li>
</ul>
</li>
</ul>
</li>
<li><code>LSN</code><ul>
<li>日志序列号（<code>redo log</code> 及其缓冲区， <code>ibd</code> 及其缓冲区 都有LSN）</li>
<li>MySQL 每次启动都会比较 <code>ibd</code> 和 <code>redo log</code> 的 LSN，两者必须一致数据库才能正常启动</li>
</ul>
</li>
<li><code>WAL</code>（write ahead log）<ul>
<li>持久化的实现机制（日志优先于数据写入磁盘）</li>
</ul>
</li>
<li><code>脏页</code><ul>
<li>内存中发生了修改，没写入到磁盘之前，把内存页称之为脏页</li>
</ul>
</li>
<li><code>CKPT</code>（checkpoint）<ul>
<li>检查点,就是将脏页刷写到磁盘的动作</li>
</ul>
</li>
<li><code>TXID</code><ul>
<li>事务号，InnoDB会为每一个事务生成一个事务号，伴随着整个事务</li>
</ul>
</li>
</ol>
<h2 id="3-2-原理"><a href="#3-2-原理" class="headerlink" title="3.2 原理"></a>3.2 原理</h2><ol>
<li>开启事务后，DML 将 <code>ibd</code> 按照数据页（16kb）为单位读取到内存 <code>data bufer pool</code> 进行操作。</li>
<li><code>undo log</code> 会记录数据的原始状态以及事务 ID</li>
<li><code>redo log buff</code> 会记录内存数据页的变化、LSN 号以及事务ID</li>
<li>操作正常 <code>commit</code><ol>
<li>优先将 <code>redo log buff</code> 写入 <code>redo log</code>（WAL）</li>
<li>将内存数据的改变写入磁盘</li>
<li>如果 commit 之后出现意外（如断电，断开连接 …），再次重启时可以根据 <code>redo log</code> 进行同步（因为都有 LSN，类似于版本号，所以知道哪个是新版本）</li>
</ol>
</li>
<li>操作未正常完成（如断电，断开连接 rollback …）<ul>
<li>不写入 <code>redo log</code>，也不写入数据</li>
</ul>
</li>
</ol>
<h1 id="四-锁"><a href="#四-锁" class="headerlink" title="四 锁"></a>四 锁</h1><h2 id="4-1-悲观锁"><a href="#4-1-悲观锁" class="headerlink" title="4.1 悲观锁"></a>4.1 悲观锁</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>数据库提供实现</li>
<li>悲观的认为别人一定会修改我使用的数据，我就未为我使用的数据加锁，防止别人修改</li>
</ol>
<h3 id="2-锁粒度划分"><a href="#2-锁粒度划分" class="headerlink" title="2 锁粒度划分"></a>2 锁粒度划分</h3><ol>
<li>表锁<ul>
<li>开销小，加锁快；不会出现死锁；但锁粒度大，锁冲突概率高，并发度低</li>
</ul>
</li>
<li>行锁<ul>
<li>开销大，加锁慢；会出现死锁；锁定粒度小，锁冲突概率低，并发度高。</li>
</ul>
</li>
</ol>
<h3 id="3-锁机制划分"><a href="#3-锁机制划分" class="headerlink" title="3 锁机制划分"></a>3 锁机制划分</h3><ol>
<li>读锁/共享锁<ul>
<li>其他事务可以读，但不能写</li>
</ul>
</li>
<li>写锁/排他锁<ul>
<li>其他事务不能读取，也不能写</li>
</ul>
</li>
</ol>
<h2 id="4-2-乐观锁"><a href="#4-2-乐观锁" class="headerlink" title="4.2 乐观锁"></a>4.2 乐观锁</h2><ol>
<li>需要自己实现</li>
<li>乐观的认为数据一般是不会造成冲突的。只有在提交数据的时候，才会对数据的冲突进行检测</li>
<li>类似与 版本控制（git / svn），会有一个版本号，在提交时会对比版本号，如果冲突则不能提交。</li>
<li>例：<ul>
<li><code>id=1 money=100 version=1</code>甲乙同时操作money-10</li>
<li>甲先提交<code>id=1 money=90 version=2</code>提交成功。</li>
<li>乙后提交<code>id=1 money=90 version=2</code>提交失败</li>
<li>乙需要从新查询，然后修改提交<code>id=1 money=80 version=3</code></li>
</ul>
</li>
</ol>
<h1 id="五-隔离级别"><a href="#五-隔离级别" class="headerlink" title="五 隔离级别"></a>五 隔离级别</h1><h2 id="5-1-问题"><a href="#5-1-问题" class="headerlink" title="5.1 问题"></a>5.1 问题</h2><h3 id="1-脏读"><a href="#1-脏读" class="headerlink" title="1 脏读"></a>1 脏读</h3><ul>
<li>在一个事务中读取到了另一个事务未提交的数据。</li>
<li><strong>例</strong><ol>
<li>我开启事务查看工资，老板开启事务发工资</li>
<li>本来是 1 万，老板多按了个 0 发了 10 万，老板没有提交事务，但我却看到发了 10 万，高兴坏了。</li>
<li>然后老板发现错了，回滚了，最后实际还是发了 1 万，我白高兴了，这肯定不合适。</li>
<li>在这个过程中我读到了老板未提交的数据，就是 脏读</li>
</ol>
</li>
</ul>
<h3 id="2-不可重复读"><a href="#2-不可重复读" class="headerlink" title="2 不可重复读"></a>2 不可重复读</h3><ul>
<li>在一个事务中读取到了另一个事务已提交的数据（update），导致在一个事务中多次读取结果不一样</li>
<li><strong>例</strong><ol>
<li>我开启事务查看卡里有多少钱，发现还有 1 万</li>
<li>此时我媳妇开启事务从卡里转走了 1 万并提交了。</li>
<li>然后我想确认一下，又查了一遍，发现没钱了，我懵逼了。</li>
<li>如果此时媳妇又转回来 5000，我再查一遍，发现余额是 5000，那我一定觉得自己疯了</li>
<li>在这个过程中我读到了媳妇提交的更新数据，就是 不可重复读</li>
</ol>
</li>
</ul>
<h3 id="3-幻读"><a href="#3-幻读" class="headerlink" title="3 幻读"></a>3 幻读</h3><ul>
<li>在一个事务中读取到了另一个事务已提交的数据（insert），导致在一个事务中多次读取结果不一样</li>
<li><strong>例</strong><ol>
<li>我开启事务查看班级里多少人的成绩已经录入，发现录入了 24 条数据</li>
<li>此时老师开启事务又录入了一条</li>
<li>然后我打印出来发现有 25 条数据</li>
<li>在这个过程中我读到了 老师提交的插入数据，就是 幻读</li>
</ol>
</li>
</ul>
<h2 id="5-2-隔离级别分类"><a href="#5-2-隔离级别分类" class="headerlink" title="5.2 隔离级别分类"></a>5.2 隔离级别分类</h2><table>
<thead>
<tr>
<th>隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td><code>read uncommitted</code></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td><code>read committed</code></td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td><code>repeatable read</code></td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td><code>serializable</code></td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td>* <code>repeatable read</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>* 是MySQl 默认 隔离级别</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>* 有可能出现幻读，可通过 <code>gap + next lock</code> 来防止幻读</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="5-3-设置隔离级别"><a href="#5-3-设置隔离级别" class="headerlink" title="5.3 设置隔离级别"></a>5.3 设置隔离级别</h2><ol>
<li><code>select @@tx_isolation</code><ul>
<li>查看隔离级别</li>
<li><code>repeatable read</code></li>
</ul>
</li>
<li><code>set transaction isolation lever 隔离级别</code><ul>
<li>设置隔离级别（会话级别）</li>
<li>必须在开启事务之前</li>
</ul>
</li>
<li><code>vim /etc/my.cnf</code> 添加 <code>transaction_isolation=隔离级别</code><ul>
<li>永久设置</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>DB</category>
        <category>MySql</category>
      </categories>
  </entry>
  <entry>
    <title>MySql 索引</title>
    <url>/anyeansan.github.io/2020/03/30/MySql-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>系统根据某种算法，将已有的数据（或未来可能新增的数据）单独建立一个文件，此文件能够实现快速的匹配数据，并且能够快速的找到对应表中的记录</li>
<li>几乎所有的索引都是建立在字段之上</li>
<li>索引本身会产生索引文件(有时候有可能比数据文件还大)，会占用磁盘空间.</li>
<li>索引类似书或字典前边的目录，提升查询速度，但是增删改时，索引也要动态的维护，降低了效率。</li>
</ol>
<h1 id="二-作用"><a href="#二-作用" class="headerlink" title="二 作用"></a>二 作用</h1><ol>
<li>优化查询<ul>
<li>如果某个字段需要作为查询的条件经常使用，那么可以使用索引</li>
</ul>
</li>
<li>约束数据的有效性<ul>
<li>如果某个字段需要进行数据的有效性约束, 也可能使用索引（主键,唯一键 …）</li>
</ul>
</li>
</ol>
<h1 id="三-索引分类（算法）"><a href="#三-索引分类（算法）" class="headerlink" title="三 索引分类（算法）"></a>三 索引分类（算法）</h1><table>
<thead>
<tr>
<th>算法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>B-tree</code></td>
<td>B 树索引</td>
</tr>
<tr>
<td><code>FullText</code></td>
<td>全文索引</td>
</tr>
<tr>
<td><code>Hash</code></td>
<td>哈希索引</td>
</tr>
<tr>
<td><code>GIS</code></td>
<td>地理位置索引</td>
</tr>
<tr>
<td><code>R-tree</code></td>
<td>R 树索引</td>
</tr>
</tbody></table>
<ul>
<li><code>B-tree</code><ol>
<li><code>B-tree</code></li>
<li><code>B+tree</code></li>
<li><code>B*tree</code><ul>
<li>Mysql 默认</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="四-索引分类（物理-功能）"><a href="#四-索引分类（物理-功能）" class="headerlink" title="四 索引分类（物理/功能）"></a>四 索引分类（物理/功能）</h1><h2 id="4-1-辅助索引-普通索引（secondary-index）"><a href="#4-1-辅助索引-普通索引（secondary-index）" class="headerlink" title="4.1 辅助索引 / 普通索引（secondary index）"></a>4.1 辅助索引 / 普通索引（secondary index）</h2><ol>
<li>辅助索引手动生成，基于表中的列（索引键）生成B树结构</li>
<li>提取列的所有索引键，进行排序</li>
<li>将排序后的索引键均匀的分布在叶节点中，且叶节点中生成索引键对应表数据的指针</li>
<li>根据叶节点生成枝节点和根节点，生成树结构。</li>
</ol>
<h2 id="4-2-聚集索引"><a href="#4-2-聚集索引" class="headerlink" title="4.2 聚集索引"></a>4.2 聚集索引</h2><ol>
<li>聚集索引由数据库自动生成</li>
<li>Mysql 自动选择主键列作为聚集索引列，没有主键则选择唯一键（如果都没有，会生成隐藏的）</li>
<li>Mysql 存储数据时，会按照聚集索引列值的顺序存储数据行（又称之为聚集索引组织表）</li>
<li>将排好序的数据行作为叶节点，进而生成树结构。</li>
<li>查询时<ol>
<li>根据辅助索引的B树，查找到辅助索引键</li>
<li>进而找到辅助索引键对应表数据的指针（即聚集索引键，通常为主键 ID）</li>
<li>根据聚集索引的B树，查找到聚集索引键</li>
<li>而聚集索引的叶节点其实就是表数据，所以就查找到了聚集索引键对应的表数据</li>
</ol>
</li>
</ol>
<h2 id="4-3-区别"><a href="#4-3-区别" class="headerlink" title="4.3 区别"></a>4.3 区别</h2><ol>
<li>表中任何一列都可以创建辅助索引，且可以有多个（不重名即可）</li>
<li>一张表聚集索引只能有一个，通常是主键列</li>
<li>辅助索引叶节点存储<ol>
<li>索引列的值（索引键）</li>
<li>聚集索引列的值（聚集索引键）</li>
</ol>
</li>
<li>聚集索引叶节点存储<ol>
<li>有序的整行数据</li>
</ol>
</li>
<li>mysql 的表数据存储的是聚集索引组织表</li>
</ol>
<h1 id="五-索引分类（逻辑）"><a href="#五-索引分类（逻辑）" class="headerlink" title="五 索引分类（逻辑）"></a>五 索引分类（逻辑）</h1><ol>
<li>主键索引 <code>primary key</code></li>
<li>唯一索引 <code>unique key</code></li>
<li>普通索引 <code>index / key</code><ol>
<li>单列索引</li>
<li>多列索引（联合索引）</li>
<li>前缀索引<ul>
<li>建索引时，可以只索引列的一部分内容</li>
</ul>
</li>
</ol>
</li>
<li>全文索引 <code>full text</code></li>
</ol>
<h1 id="六-索引操作"><a href="#六-索引操作" class="headerlink" title="六 索引操作"></a>六 索引操作</h1><h2 id="6-1-查"><a href="#6-1-查" class="headerlink" title="6.1 查"></a>6.1 查</h2><ol>
<li><code>desc 表名</code><ul>
<li><code>key</code> 列显示索引信息<ol>
<li><code>PRI</code> ：主键索引</li>
<li><code>UNI</code> ：唯一索引</li>
<li><code>MUL</code> ：普通索引</li>
</ol>
</li>
</ul>
</li>
<li><code>show index from 表名</code><ul>
<li>显示索引详细信息</li>
</ul>
</li>
</ol>
<h2 id="6-2-增"><a href="#6-2-增" class="headerlink" title="6.2 增"></a>6.2 增</h2><h3 id="1-普通索引"><a href="#1-普通索引" class="headerlink" title="1 普通索引"></a>1 普通索引</h3><ol>
<li><code>alter table 表名 add index 索引名(列1[(lenght)][,列2, ...])</code><ul>
<li>创建单列/双列/前缀 普通索引</li>
</ul>
</li>
<li><code>create index 索引名 on 表名(列1(lenght)][,列2, ...])</code></li>
</ol>
<h3 id="2-唯一索引"><a href="#2-唯一索引" class="headerlink" title="2 唯一索引"></a>2 唯一索引</h3><ol>
<li><code>alter table 表名 add unique index 索引名(列名)</code></li>
<li><code>create unique index 索引名 on 表名(列名)</code></li>
</ol>
<h2 id="6-3-删"><a href="#6-3-删" class="headerlink" title="6.3 删"></a>6.3 删</h2><ol>
<li><code>alter table 表名 drop index 索引名</code></li>
<li><code>drop index 索引名 on 表名</code></li>
</ol>
<h1 id="七-执行计划"><a href="#七-执行计划" class="headerlink" title="七 执行计划"></a>七 执行计划</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ol>
<li>SQL 层解析器会生成多个执行计划，优化器会选择最优的执行计划</li>
<li>执行计划分析<ul>
<li>就是在执行前获取这个最优执行计划，查看其计划信息，可以有效的防止性能较差的语句带来的性能问题</li>
</ul>
</li>
</ol>
<h2 id="7-2-获取执行计划"><a href="#7-2-获取执行计划" class="headerlink" title="7.2 获取执行计划"></a>7.2 获取执行计划</h2><ol>
<li><code>desc sql语句</code></li>
<li><code>explain sql语句</code></li>
</ol>
<h2 id="7-3-执行计划分析"><a href="#7-3-执行计划分析" class="headerlink" title="7.3 执行计划分析"></a>7.3 执行计划分析</h2><ol>
<li><code>table</code><ul>
<li>查询所操作的表</li>
</ul>
</li>
<li><code>type</code><ol>
<li>全表扫描：<code>all</code><ul>
<li>不走索引<ol>
<li>没有查询条件，或者查询条件列无索引</li>
<li>查询结构集是原表中的大部分数据，一般25%以上</li>
<li><code>! not</code><ul>
<li>普通索引列</li>
</ul>
</li>
<li><code>like %xxx</code></li>
<li>联合索引有时只走部分索引</li>
</ol>
</li>
</ul>
</li>
<li>索引扫描（性能依次变好）<ol>
<li><code>index</code><ul>
<li>全索引扫描<ul>
<li>无条件查询索引列 <code>select id from t</code></li>
</ul>
</li>
</ul>
</li>
<li><code>range</code><ul>
<li>索引范围扫描<ol>
<li><code>&gt; &gt;= &lt; &lt;= between and or in()</code></li>
<li><code>like xxx%</code></li>
<li><code>! not</code><ul>
<li>主键索引或唯一索引列</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><code>ref</code><ul>
<li>普通索引列的等值查询</li>
</ul>
</li>
<li><code>eq_ref</code><ul>
<li>在多表连接时，子表（被连接表）使用主键列或者唯一列作为连接条件</li>
</ul>
</li>
<li><code>consist(system)</code><ul>
<li>主键索引或唯一索引列的等值查询</li>
</ul>
</li>
<li><code>null</code></li>
</ol>
</li>
</ol>
</li>
<li><code>possible_key</code><ul>
<li>可能会用到的索引</li>
</ul>
</li>
<li><code>key</code><ul>
<li>真正使用的索引</li>
</ul>
</li>
<li><code>key_len</code><ul>
<li>索引最大预留长度</li>
</ul>
</li>
<li><code>extra</code><ul>
<li><code>using filesort</code><ul>
<li>说明查询中有关排序的条件列没有合理的应用索引，因为索引本身已经是有序的</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="7-4-联合索引"><a href="#7-4-联合索引" class="headerlink" title="7.4 联合索引"></a>7.4 联合索引</h2><h3 id="1-联合索引说明"><a href="#1-联合索引说明" class="headerlink" title="1 联合索引说明"></a>1 联合索引说明</h3><ul>
<li>优化器会自动对查询条件按照索引创建时的顺序排序<ol>
<li>最终使用的索引列是排序后连续的等值比较查询</li>
<li>也就是说碰到不连续的或者非等值比较查询（&gt; &gt;= &lt; &lt;= like …）就会停止</li>
</ol>
</li>
<li>例：创建联合索引 <code>inx_haha(a,b,c,d)</code><ol>
<li>查询条件是 <code>b= c= a= d=</code>，排序后 <code>a= b= c= d=</code>，最终使用的索引列 <code>abcd</code></li>
<li>查询条件是 <code>b= a= d=</code>，排序后 <code>a= b= d=</code>，最终使用的索引列 <code>ab</code></li>
<li>查询条件是 <code>c= a= d=</code>，排序后 <code>a= c= d=</code>，最终使用的索引列 <code>a</code></li>
<li>查询条件是 <code>b&gt; a= c= d=</code>，排序后 <code>a= b&gt; c= d=</code>，最终使用的索引列 <code>ab</code></li>
</ol>
</li>
</ul>
<h3 id="2-联合索引优化"><a href="#2-联合索引优化" class="headerlink" title="2 联合索引优化"></a>2 联合索引优化</h3><ol>
<li>创建联合索引时唯一键多的列放在最左侧</li>
<li>创建联合索引时等值比较的列放在最左侧</li>
<li>如果查询中出现多种子句（where group by …），要按照子句的执行顺序建立索引</li>
</ol>
<h2 id="7-5-索引应用规范"><a href="#7-5-索引应用规范" class="headerlink" title="7.5 索引应用规范"></a>7.5 索引应用规范</h2><ol>
<li>建表必须有主键，一般是个无关列，自增值</li>
<li>经常需要where 、ORDER BY、GROUP BY,join on等操作的列建立索引，</li>
<li>值长度较长的列，建议使用前缀索引</li>
<li>索引不是越多越好，不要创建无用索引，不常使用的索引要清理</li>
<li>索引维护避开业务繁忙期</li>
<li>小表不建索引</li>
<li>联合索引优化</li>
</ol>
]]></content>
      <categories>
        <category>DB</category>
        <category>MySql</category>
      </categories>
  </entry>
  <entry>
    <title>MySql 元数据和语法</title>
    <url>/anyeansan.github.io/2020/03/30/MySql-%E5%85%83%E6%95%B0%E6%8D%AE%E5%92%8C%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>元数据可以简单理解为描述数据的数据，除了存储在数据库中的数据外，大多可以理解为元数据</li>
<li>元数据存储在“基表”中，不能直接访问<ol>
<li><code>infomation_schema</code> 表中保存了大量元数据查询的视图</li>
<li><code>show</code> 命令是封装好的，提供元数据查询的基础功能</li>
</ol>
</li>
</ol>
<h1 id="二-information-schema"><a href="#二-information-schema" class="headerlink" title="二 information_schema"></a>二 information_schema</h1><h2 id="2-1-schemata"><a href="#2-1-schemata" class="headerlink" title="2.1 schemata"></a>2.1 schemata</h2><ol>
<li>存储当前 mysql 实例中所有数据库的信息。</li>
<li><code>show databases</code> 命令从这个表获取数据</li>
</ol>
<h2 id="2-2-tables"><a href="#2-2-tables" class="headerlink" title="2.2 tables"></a>2.2 tables</h2><ol>
<li>存储数据库中的表信息（包括视图），包括表属于哪个数据库，表的类型、存储引擎、创建时间等信息。</li>
<li><code>show tables [from db_name]</code> 命令从这个表获取结果</li>
</ol>
<table>
<thead>
<tr>
<th>列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>table_schema</code></td>
<td>表所在库名</td>
</tr>
<tr>
<td><code>table_name</code></td>
<td>表名</td>
</tr>
<tr>
<td><code>engine</code></td>
<td>存储引擎</td>
</tr>
<tr>
<td><code>table_rows</code></td>
<td>总行数</td>
</tr>
<tr>
<td><code>avg_row_length</code></td>
<td>行平均长度</td>
</tr>
<tr>
<td><code>index_length</code></td>
<td>索引长度</td>
</tr>
</tbody></table>
<ul>
<li><code>表大小 = avg_row_length * table_rows + index_length</code></li>
</ul>
<h2 id="2-3-columns"><a href="#2-3-columns" class="headerlink" title="2.3 columns"></a>2.3 columns</h2><ul>
<li>存储数据库中每张表的列信息，会记录这列是属于哪张表( <code>TABLE_NAME</code> )、以及哪个库( <code>TABLE_SCHEMA</code> )、这列的数据类型是什么、列的注释( <code>COLUMN_COMMENT</code> )等信息</li>
</ul>
<h2 id="2-4-statistics"><a href="#2-4-statistics" class="headerlink" title="2.4 statistics"></a>2.4 statistics</h2><ul>
<li>存储表索引信息</li>
</ul>
<h2 id="2-5-collations"><a href="#2-5-collations" class="headerlink" title="2.5 collations"></a>2.5 collations</h2><ul>
<li>存储了字符集和校对集对照信息</li>
</ul>
<h1 id="三-show"><a href="#三-show" class="headerlink" title="三 show"></a>三 show</h1><ol>
<li><code>show databases</code><ul>
<li>查看所有库名</li>
</ul>
</li>
<li><code>show tables [from db_name]</code><ul>
<li>查看库中所有表名</li>
</ul>
</li>
<li><code>show create database db_name</code><ul>
<li>查看建库语句</li>
</ul>
</li>
<li><code>show create table t_name</code><ul>
<li>查看建表语句</li>
</ul>
</li>
<li><code>show processlist</code><ul>
<li>查看数据库连接情况</li>
</ul>
</li>
<li><code>show charset</code><ul>
<li>查看支持的字符集</li>
</ul>
</li>
<li><code>show collation</code><ul>
<li>查看支持的校对集</li>
</ul>
</li>
<li><code>show engines</code><ul>
<li>查看支持的存储引擎</li>
</ul>
</li>
<li><code>show grants for user_name</code><ul>
<li>查看用户权限</li>
</ul>
</li>
<li><code>shwo variables [like pattern]</code><ul>
<li>查看变量信息</li>
</ul>
</li>
<li><code>show index from t_name</code><ul>
<li>查看表的索引信息</li>
</ul>
</li>
<li><code>show engine innodb statsu\G</code><ul>
<li>查看 innodb 引擎详细状态信息（横向）</li>
</ul>
</li>
<li><code>show status [like pattern]</code><ul>
<li>查看数据库状态信息</li>
</ul>
</li>
<li><code>show binary logs</code><ul>
<li>查看二进制日志的列表信息</li>
</ul>
</li>
<li><code>show binlog events in log_name</code><ul>
<li>查看二进制日志的事件信息</li>
</ul>
</li>
<li><code>show master status</code><ul>
<li>查看 mysql 当前使用的二进制日志信息</li>
</ul>
</li>
<li><code>show relaylog events in log_name</code><ul>
<li>查看中继日志的事件信息</li>
</ul>
</li>
</ol>
<h1 id="四-语法"><a href="#四-语法" class="headerlink" title="四 语法"></a>四 语法</h1><h2 id="4-1-运算符"><a href="#4-1-运算符" class="headerlink" title="4.1 运算符"></a>4.1 运算符</h2><h3 id="1-数学运算符"><a href="#1-数学运算符" class="headerlink" title="1 数学运算符"></a>1 数学运算符</h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>+</code></td>
<td>加</td>
</tr>
<tr>
<td align="center"><code>-</code></td>
<td>减</td>
</tr>
<tr>
<td align="center"><code>*</code></td>
<td>乘</td>
</tr>
<tr>
<td align="center"><code>/</code></td>
<td>除</td>
</tr>
<tr>
<td align="center"><code>DIV</code></td>
<td>整除</td>
</tr>
<tr>
<td align="center"><code>% MOD</code></td>
<td>模</td>
</tr>
</tbody></table>
<h3 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2 比较运算符"></a>2 比较运算符</h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td align="center"><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td align="center"><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td align="center"><code>&lt;=</code></td>
<td>小于等于</td>
</tr>
<tr>
<td align="center"><code>=</code></td>
<td>等于，<code>null = null</code> 返回 null</td>
</tr>
<tr>
<td align="center"><code>&lt;=&gt;</code></td>
<td>等于，<code>null = null</code> 返回 1</td>
</tr>
<tr>
<td align="center"><code>&lt;&gt; !=</code></td>
<td>不等于</td>
</tr>
</tbody></table>
<h3 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3 逻辑运算符"></a>3 逻辑运算符</h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>and &amp;&amp;</code></td>
<td>逻辑与</td>
</tr>
<tr>
<td align="center"><code>or &#124;&#124;</code></td>
<td>逻辑或</td>
</tr>
<tr>
<td align="center"><code>not !</code></td>
<td>逻辑非</td>
</tr>
<tr>
<td align="center"><code>xor</code></td>
<td>逻辑异或</td>
</tr>
</tbody></table>
<h2 id="4-2-变量"><a href="#4-2-变量" class="headerlink" title="4.2 变量"></a>4.2 变量</h2><h3 id="1-系统变量"><a href="#1-系统变量" class="headerlink" title="1 系统变量"></a>1 系统变量</h3><h4 id="1-查看系统变量"><a href="#1-查看系统变量" class="headerlink" title="1 查看系统变量"></a>1 查看系统变量</h4><ol>
<li><code>show [session | global] variables [like pattern]</code><ul>
<li>查看变量信息</li>
</ul>
</li>
<li><code>select @@变量名</code><ul>
<li>查看具体变量</li>
</ul>
</li>
</ol>
<h4 id="2-修改系统变量"><a href="#2-修改系统变量" class="headerlink" title="2 修改系统变量"></a>2 修改系统变量</h4><ol>
<li><code>Set @@session.变量名 = 值</code><ul>
<li>会话级别</li>
</ul>
</li>
<li><code>Set @@global.变量名 = 值</code><ul>
<li>全局级别（仅影响新会话，重启失效）</li>
</ul>
</li>
</ol>
<h3 id="2-自定义变量"><a href="#2-自定义变量" class="headerlink" title="2 自定义变量"></a>2 自定义变量</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>为了区分系统变量, 规定用户自定义变量必须使用一个 <code>@</code> 符号</li>
<li>所有自定义的变量都是会话级别</li>
<li>所有自定义变量不区分数据库(用户级别)</li>
</ol>
<h4 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2 作用域"></a>2 作用域</h4><ol>
<li>全局变量<ol>
<li><code>set @变量名 = 值</code><ul>
<li>声明并赋值</li>
</ul>
</li>
<li><code>select @变量名 :=</code> <ul>
<li>使用 select 赋值，但必须使用 <code>:=</code></li>
</ul>
</li>
<li><code>select @变量名</code><ul>
<li>查看变量值</li>
</ul>
</li>
</ol>
</li>
<li>局部变量<ol>
<li><code>declare 变量名 类型 [default 默认值]</code><ul>
<li>局部变量需要先声明</li>
<li>赋值与查看与全局变量一致</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="4-3-函数"><a href="#4-3-函数" class="headerlink" title="4.3 函数"></a>4.3 函数</h2><h3 id="1-信息函数"><a href="#1-信息函数" class="headerlink" title="1 信息函数"></a>1 信息函数</h3><ol>
<li><code>user()</code><ul>
<li>返回当前用户及所在主机</li>
</ul>
</li>
<li><code>database()</code><ul>
<li>返回当前数据库名</li>
</ul>
</li>
<li><code>version()</code><ul>
<li>返回数据库的版本号</li>
</ul>
</li>
<li><code>connection_id()</code><ul>
<li>连接id</li>
</ul>
</li>
<li><code>last_insert_id()</code><ul>
<li>最后插入记录的id</li>
</ul>
</li>
</ol>
<h3 id="2-数字函数"><a href="#2-数字函数" class="headerlink" title="2 数字函数"></a>2 数字函数</h3><ol>
<li><code>abs(X)</code><ul>
<li>绝对值</li>
</ul>
</li>
<li><code>ceil(X)</code><ul>
<li>向上取整</li>
</ul>
</li>
<li><code>floor(X)</code><ul>
<li>向下取整</li>
</ul>
</li>
<li><code>round(X[, D])</code><ul>
<li>四舍五入</li>
<li><code>D</code><ul>
<li>小数位数</li>
</ul>
</li>
</ul>
</li>
<li><code>truncate(X, D)</code><ul>
<li>数字截取</li>
<li><code>D</code><ul>
<li>小数位数</li>
</ul>
</li>
</ul>
</li>
<li><code>conv(X, from_base, to_base)</code><ul>
<li>将x从进制from_base转为进制to_base的字符串。</li>
<li><code>X</code><ul>
<li>可以数字或数字的字符串</li>
</ul>
</li>
</ul>
</li>
<li><code>mod(N, M)</code><ul>
<li>等价于 <code>N % M</code> 或者 <code>N MOD M</code></li>
</ul>
</li>
</ol>
<h3 id="3-字符串函数"><a href="#3-字符串函数" class="headerlink" title="3 字符串函数"></a>3 字符串函数</h3><ol>
<li><code>concat(str1, str2, ...)</code><ol>
<li>将一个或多个参数连接为字符串</li>
<li>参数为数字会被转成字符串</li>
<li>如果有一个参数为null，则返回null</li>
</ol>
</li>
<li><code>concat_ws(separator, str1, str2, ...)</code><ul>
<li>使用指定分隔符将一个或多个参数连接为字符串</li>
</ul>
</li>
<li><code>format(X, D)</code><ul>
<li>将一个数字X格式化为类似<code>#,###,###.##</code>形式的字符串，小数位数由D指定</li>
</ul>
</li>
<li><code>length(str)</code><ul>
<li>返回字符串长度</li>
</ul>
</li>
<li><code>lower(str)</code><ul>
<li>转小写</li>
</ul>
</li>
<li><code>upper(str)</code><ul>
<li>转大写</li>
</ul>
</li>
<li><code>trim([{both | leading | trailing}] [remstr from] str)</code><ul>
<li>去除str两端空格</li>
<li><code>both|leading|trailing</code><ul>
<li>默认为both，可指定左右</li>
</ul>
</li>
<li><code>remstr</code><ul>
<li>默认空格，可以指定去除字符</li>
</ul>
</li>
</ul>
</li>
<li><code>ltrim(str)</code><ul>
<li>去除str左端空格</li>
</ul>
</li>
<li><code>rtrim(str)</code><ul>
<li>去除str右端空格</li>
</ul>
</li>
<li><code>reverse(str)</code><ul>
<li>反转str</li>
</ul>
</li>
<li><code>left(str, len)</code><ul>
<li>返回str从左开始len个字符的字符串。</li>
</ul>
</li>
<li><code>right(str, len)</code><ul>
<li>返回str从右开始len个字符的字符串。</li>
</ul>
</li>
<li><code>substring(str, [from] pos, [[for] len])</code><ul>
<li>返回从str位置pos开始的len个字符的字符串</li>
<li><code>pos</code><ul>
<li>从1开始，可以为负</li>
</ul>
</li>
<li><code>len</code><ul>
<li>若省略，则默认到字符串结尾</li>
<li>若len &lt; 1 则返回空字符串。</li>
</ul>
</li>
<li><code>substr()</code> 等价于 <code>substring()</code></li>
</ul>
</li>
<li><code>locate(substr, str[, pos])</code><ul>
<li>返回子串substr在str中第一次出现的位置，没有则返回 0</li>
<li><code>pos</code><ul>
<li>指定开始匹配位置</li>
<li>默认从1开始，及字符串开头</li>
</ul>
</li>
</ul>
</li>
<li><code>instr(str, substr)</code><ul>
<li>返回子串substr在str中第一次出现的位置，没有则返回0</li>
<li>等价于 <code>locate(substr, str)</code></li>
</ul>
</li>
<li><code>insert(str, pos, len, newstr)</code><ul>
<li>将str中从位置pos开始的len个字符替换为newstr</li>
</ul>
</li>
<li><code>replace(str, from_str, to_str)</code><ul>
<li>将str中的from_str替换为to_str</li>
</ul>
</li>
<li><code>strcmp(expr1,expr2)</code><ul>
<li>比较两个字符串<ol>
<li><code>expr1 = expr2</code>，返回 0</li>
<li><code>expr1 &lt; expr2</code>，返回 -1</li>
<li><code>expr1 &gt; expr2</code> ，返回 1</li>
</ol>
</li>
</ul>
</li>
<li><code>repeat(str, count)</code><ul>
<li>返回str重复count次组成的字符串</li>
</ul>
</li>
<li><code>isnull(expr)</code><ul>
<li>判断表达式是否为空</li>
</ul>
</li>
</ol>
<h3 id="4-日期函数"><a href="#4-日期函数" class="headerlink" title="4 日期函数"></a>4 日期函数</h3><ol>
<li><code>now()</code><ul>
<li>返回当前日期和时间。<code>yyyy-MM--dd HH:mm:ss</code></li>
</ul>
</li>
<li><code>curdate()</code><ul>
<li>返回当前日期 <code>yyyy-MM-dd</code></li>
</ul>
</li>
<li><code>curtime()</code><ul>
<li>返回当前时间 <code>HH:mm:ss</code></li>
</ul>
</li>
<li><code>dayofyear(date)</code><ul>
<li>返回指定日期是当年的第几天</li>
<li><code>date</code> 格式为 <code>yyyy-mm-dd</code></li>
</ul>
</li>
<li><code>dayofmonth(date)</code><ul>
<li>返回指定日期是当月的第几天</li>
</ul>
</li>
<li><code>dayofweek(date)</code><ul>
<li>返回指定日期是当周的第几天（周日是第一天）</li>
</ul>
</li>
<li><code>datediff(expr1, expr2)</code><ul>
<li>返回<code>expr1 - expr2</code> 的日期差值</li>
</ul>
</li>
<li><code>date_format(date, format)</code><ul>
<li>日期格式化</li>
</ul>
</li>
<li><code>date_add(date, INTERVAL expr unit)</code><ul>
<li>给日期加上指定值</li>
<li><code>unit</code><ul>
<li>指定日期项，如<code>day year day_hour day_second ...</code></li>
</ul>
</li>
</ul>
</li>
<li><code>date_sub(date, INTERVAL expr unit)</code><ul>
<li>给日期减去指定值</li>
</ul>
</li>
</ol>
<h3 id="5-加密函数"><a href="#5-加密函数" class="headerlink" title="5 加密函数"></a>5 加密函数</h3><ol>
<li><code>md5(str)</code><ul>
<li>md5加密</li>
</ul>
</li>
</ol>
<h3 id="6-JSON-函数"><a href="#6-JSON-函数" class="headerlink" title="6 JSON 函数"></a>6 JSON 函数</h3><ol>
<li><code>json_array([val[, val ...]])</code><ul>
<li>返回由参数组成json数组</li>
</ul>
</li>
<li><code>json_object([key, val[, key, val ...]])</code><ul>
<li>返回由参数组成的json对象，奇数参数是key，偶数参数是value</li>
</ul>
</li>
<li><code>json_pretty(json_val)</code><ul>
<li>漂亮的打印json</li>
</ul>
</li>
<li><code>json_array_append(json_doc, path, val[, path, val ...])</code><ul>
<li>在json_doc指定位置上的值后追加值<ul>
<li>假如数组或对象指定位置上是一个数组，则在数组尾部追加<ul>
<li><code>[a, b]</code> append c <code>[a, b, c]</code></li>
</ul>
</li>
<li>假如数组或对象指定位置上是一个值，则变成一个数组并在尾部追加<ul>
<li><code>a</code> append b <code>[a, b]</code></li>
</ul>
</li>
</ul>
</li>
<li><code>json_doc</code><ul>
<li>可以是json对象也可以是json数组</li>
</ul>
</li>
<li><code>path</code><ul>
<li><code>$[索引]</code></li>
<li><code>$.key</code></li>
</ul>
</li>
</ul>
</li>
<li><code>json_array_insert(json_doc, path, val[, path, val ...])</code><ul>
<li>向json数组指定位置插入值，返回新数组，不改变原有数组</li>
<li><code>json_doc</code><ul>
<li>要插入值的json数组</li>
</ul>
</li>
<li><code>path</code><ul>
<li>格式为 <code>$[索引值]</code>，数组索引从0开始</li>
</ul>
</li>
</ul>
</li>
<li><code>json_insert(json_doc, path, val[, path, val ...])</code><ul>
<li>向json对象添加新的键值对，返回新对象，不改变原对象</li>
<li><code>json_doc</code><ul>
<li>要插入值的json对象</li>
</ul>
</li>
<li><code>path</code><ul>
<li>格式为 <code>$.key</code></li>
<li>如果key在原对象中存在，不会添加也不改变原有值。</li>
</ul>
</li>
</ul>
</li>
<li><code>json_set(json_doc, path, val[, path, val ...])</code><ul>
<li>替换json_doc指定位置现有的值，如果不存在则添加</li>
</ul>
</li>
<li><code>json_replace(json_doc, path, val[, path, val ...])</code><ul>
<li>仅替换现有的值</li>
</ul>
</li>
<li><code>json_remove(json_doc, path[, path...])</code><ul>
<li>删除json_doc指定位置的值</li>
</ul>
</li>
<li><code>json_extract(json_doc, path[, path...])</code><ul>
<li>返回json_doc指定位置的值</li>
</ul>
</li>
<li><code>json_contains_path(json_doc, one_or_all, path[, path...])</code><ul>
<li>判断是否包含指定路径（索引或者key）</li>
<li><code>one</code><ul>
<li>只要有一个包含就返回1</li>
</ul>
</li>
<li><code>all</code><ul>
<li>只要有一个不包含就返回0</li>
</ul>
</li>
</ul>
</li>
<li><code>json_contains(target, candidate[, path])</code><ul>
<li>判断是否包含指定值</li>
<li><code>candidate</code><ul>
<li>要查找的值</li>
</ul>
</li>
<li><code>path</code><ul>
<li>如果设置则代表查找开始位置</li>
</ul>
</li>
</ul>
</li>
<li><code>json_length(json_doc[, path])</code><ul>
<li>返回json_doc的长度</li>
</ul>
</li>
</ol>
<h3 id="7-自定义函数"><a href="#7-自定义函数" class="headerlink" title="7 自定义函数"></a>7 自定义函数</h3><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE</span><br><span class="line">	[DEFINER = user]</span><br><span class="line">	FUNCTION sp_name ([func_parameter[,...]])</span><br><span class="line">	RETURNS type</span><br><span class="line">	[characteristic ...] </span><br><span class="line">	routine_body</span><br><span class="line"></span><br><span class="line">func_parameter: </span><br><span class="line">	param_name type</span><br><span class="line">type:</span><br><span class="line">	Any valid MySQL data type</span><br><span class="line">characteristic:</span><br><span class="line">	  COMMENT &apos;string&apos;</span><br><span class="line">	| LANGUAGE SQL</span><br><span class="line">	| [NOT] DETERMINISTIC</span><br><span class="line">	| &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;</span><br><span class="line">	| SQL SECURITY &#123; DEFINER | INVOKER &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-创建"><a href="#2-创建" class="headerlink" title="2 创建"></a>2 创建</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP FUNCTION IF EXISTS 函数名;</span><br><span class="line">DELIMITER 结束标记</span><br><span class="line">CREATE FUNCTION 函数名 ([参数列表]) RETURNS 返回值类型</span><br><span class="line">BEGIN </span><br><span class="line">    函数体</span><br><span class="line">    RETURN 返回值;</span><br><span class="line">END 结束标记</span><br><span class="line">DELIMITER ; -- 将结束标记改回默认分号</span><br></pre></td></tr></table></figure>
<ul>
<li>形参<ul>
<li><code>形参名 形参类型</code></li>
</ul>
</li>
<li>返回值<ul>
<li><code>{STRING|INTEGER|REAL|DECIMAL}</code></li>
<li>必须有返回值且只有一个</li>
</ul>
</li>
</ul>
<h4 id="3-查看"><a href="#3-查看" class="headerlink" title="3 查看"></a>3 查看</h4><ol>
<li><code>show function status [like ‘pattern’]</code><ul>
<li>查看所有函数或模糊匹配</li>
</ul>
</li>
<li><code>show create function 函数名</code><ul>
<li>查看函数的创建语句</li>
</ul>
</li>
</ol>
<h4 id="4-修改-删除-函数"><a href="#4-修改-删除-函数" class="headerlink" title="4 修改/删除 函数"></a>4 修改/删除 函数</h4><ol>
<li>函数不能修改</li>
<li>删除<ul>
<li><code>drop function [if exists] 函数名</code></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>DB</category>
        <category>MySql</category>
      </categories>
  </entry>
  <entry>
    <title>MySql SQL语句</title>
    <url>/anyeansan.github.io/2020/03/30/MySql-SQL%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="一-SQL（Structure-Query-Language）"><a href="#一-SQL（Structure-Query-Language）" class="headerlink" title="一 SQL（Structure Query Language）"></a>一 SQL（Structure Query Language）</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ol>
<li>结构化查询语言，关系型数据库通用命令</li>
<li>遵循SQL92标准</li>
</ol>
<h2 id="1-2-严格模式（SQL-MODE）"><a href="#1-2-严格模式（SQL-MODE）" class="headerlink" title="1.2 严格模式（SQL_MODE）"></a>1.2 严格模式（SQL_MODE）</h2><ol>
<li><code>set sql_mode = &#39;traditional&#39;</code><ul>
<li>设置严格模式，默认</li>
</ul>
</li>
<li><code>set sql_mode = &#39;&#39;</code><ul>
<li>关闭严格模式</li>
</ul>
</li>
</ol>
<h2 id="1-3-SQL-规范"><a href="#1-3-SQL-规范" class="headerlink" title="1.3 SQL 规范"></a>1.3 SQL 规范</h2><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1 注释"></a>1 注释</h3><ul>
<li><code>--</code><ul>
<li>单行</li>
</ul>
</li>
<li><code>/* */</code><ul>
<li>多行</li>
</ul>
</li>
<li><code>#</code><ul>
<li>mysql 特有</li>
</ul>
</li>
</ul>
<h3 id="2-编码规范"><a href="#2-编码规范" class="headerlink" title="2 编码规范"></a>2 编码规范</h3><h4 id="1-库"><a href="#1-库" class="headerlink" title="1 库"></a>1 库</h4><ol>
<li>关键字 和 函数名 大写</li>
<li>库名 小写，不能以数字开头，不能使用关键字和保留字</li>
<li>必须设置字符集</li>
</ol>
<h4 id="2-表"><a href="#2-表" class="headerlink" title="2 表"></a>2 表</h4><ol>
<li>关键字 和 函数名 大写</li>
<li>表名 小写，不能以数字开头，不能使用关键字和保留字</li>
<li>选择合适的数据类型及长度</li>
<li>每个列设置 <code>NOT NULL + DEFAULT</code><ol>
<li>数值默认为 <code>0</code> 或其它有效数字</li>
<li>字符串默认为空格字符串 <code>&#39; &#39;</code> 或其它有效字符串</li>
</ol>
</li>
<li>enum 类型不要用于数值，只能用于字符串</li>
<li>每个列设置注释</li>
<li>表必须设置存储引擎和字符集</li>
<li>主键列最好是无关数值列，且自增长</li>
</ol>
<h2 id="1-4-SQL-常用分类"><a href="#1-4-SQL-常用分类" class="headerlink" title="1.4 SQL 常用分类"></a>1.4 SQL 常用分类</h2><ol>
<li>DQL（Data Query Language）<ul>
<li>数据查询语言，如 <code>select show</code></li>
</ul>
</li>
<li>DDL（Data Definition Language）<ul>
<li>数据定义语言，如 <code>create alter drop truncate</code></li>
</ul>
</li>
<li>DML（Data Manipulation Language）<ul>
<li>数据操作语言，如 <code>insert update delete</code></li>
</ul>
</li>
<li>DCL（Data Control Language）<ul>
<li>数据控制语言，如 <code>grant revoke</code></li>
</ul>
</li>
</ol>
<h1 id="二-库-操作"><a href="#二-库-操作" class="headerlink" title="二 库 操作"></a>二 库 操作</h1><h2 id="2-1-查"><a href="#2-1-查" class="headerlink" title="2.1 查"></a>2.1 查</h2><ol>
<li><code>show databases</code><ul>
<li>查看所有库</li>
</ul>
</li>
<li><code>show create database db_name</code><ul>
<li>查看建库语句</li>
</ul>
</li>
<li><code>show variables like &#39;character_set_database&#39;</code><ul>
<li>查看当前数据库字符集</li>
</ul>
</li>
<li><code>show variables like &#39;collation_database&#39;</code><ul>
<li>查看当前数据库校对集</li>
</ul>
</li>
</ol>
<h2 id="2-2-增"><a href="#2-2-增" class="headerlink" title="2.2 增"></a>2.2 增</h2><ul>
<li><code>create database [if not exists] 库名 [charset 字符集 collate 校对集]</code></li>
</ul>
<h2 id="2-3-删"><a href="#2-3-删" class="headerlink" title="2.3 删"></a>2.3 删</h2><ul>
<li><code>drop database [if exists] 库名</code></li>
</ul>
<h2 id="2-4-改"><a href="#2-4-改" class="headerlink" title="2.4 改"></a>2.4 改</h2><ul>
<li><code>alter database 库名 [charset 字符集 collate 校对集]</code><ol>
<li>库名不可修改</li>
<li>字符集和校对集可修改</li>
</ol>
</li>
</ul>
<h1 id="三-表-操作"><a href="#三-表-操作" class="headerlink" title="三 表 操作"></a>三 表 操作</h1><h2 id="3-1-指定库"><a href="#3-1-指定库" class="headerlink" title="3.1 指定库"></a>3.1 指定库</h2><ol>
<li><code>use 库名</code><ol>
<li>指定当前使用的数据库</li>
<li>表依赖于库，任何一个表都必须指定数据库<ul>
<li><code>库名.表名</code><ul>
<li>在 sql 语句中显式的指定</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><code>select database()</code><ul>
<li>查看正在使用的数据库</li>
</ul>
</li>
</ol>
<h2 id="3-2-查"><a href="#3-2-查" class="headerlink" title="3.2 查"></a>3.2 查</h2><ol>
<li><code>show tables [from 库名]</code><ul>
<li>查看库（默认为当前库）中的所有表</li>
</ul>
</li>
<li><code>show create table 表名</code><ul>
<li>查看当前库中指定的表</li>
</ul>
</li>
<li><code>desc 表名</code><ul>
<li>查看表结构</li>
</ul>
</li>
<li><code>show columns from 表名</code><ul>
<li>查看表结构</li>
</ul>
</li>
</ol>
<h2 id="3-3-增"><a href="#3-3-增" class="headerlink" title="3.3 增"></a>3.3 增</h2><ol>
<li>.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table [if not exists] 表名(</span><br><span class="line">	列名 列属性,</span><br><span class="line">	......</span><br><span class="line">	列名 列属性</span><br><span class="line">)[表属性]</span><br></pre></td></tr></table></figure>
<ul>
<li>表属性<ol>
<li><code>charset 字符集</code></li>
<li><code>collate 校对集</code></li>
<li><code>engine 存储引擎</code></li>
</ol>
</li>
</ul>
</li>
<li><code>create table 新表名 like 旧表名</code><ul>
<li>根据已有表结构创建新表</li>
</ul>
</li>
</ol>
<h2 id="3-4-删"><a href="#3-4-删" class="headerlink" title="3.4 删"></a>3.4 删</h2><ul>
<li><code>drop table [if exists] 表名</code></li>
</ul>
<h2 id="3-5-改"><a href="#3-5-改" class="headerlink" title="3.5 改"></a>3.5 改</h2><h3 id="1-表名"><a href="#1-表名" class="headerlink" title="1 表名"></a>1 表名</h3><ol>
<li><code>rename table 表名 to 新表名</code></li>
<li><code>alter table 表名 rename 新表名</code></li>
</ol>
<h3 id="2-表属性"><a href="#2-表属性" class="headerlink" title="2 表属性"></a>2 表属性</h3><ol>
<li><code>alter table 表名 表属性</code></li>
</ol>
<h3 id="3-表结构"><a href="#3-表结构" class="headerlink" title="3 表结构"></a>3 表结构</h3><ol>
<li><code>alter table 表名 add [column] 列名 列属性 [位置]</code><ul>
<li>默认在最后新增一列</li>
<li>位置<ul>
<li><code>first</code></li>
<li><code>after 列名</code></li>
</ul>
</li>
</ul>
</li>
<li><code>alter table 表名 add [column] (列名 列属性, ...)</code><ul>
<li>新增多列</li>
</ul>
</li>
<li><code>alter table 表名 drop [column] 列名</code><ul>
<li>删除列</li>
</ul>
</li>
<li><code>alter table 表名 modify 列名 列属性</code><ul>
<li>修改列属性</li>
</ul>
</li>
<li><code>alter table 表名 change 列名 新列名 列属性</code><ul>
<li>修改列名和列属性</li>
</ul>
</li>
</ol>
<h1 id="四-数据操作-DML"><a href="#四-数据操作-DML" class="headerlink" title="四 数据操作 DML"></a>四 数据操作 DML</h1><h2 id="4-1-insert"><a href="#4-1-insert" class="headerlink" title="4.1 insert"></a>4.1 insert</h2><ol>
<li><code>insert [into] 表名(列1,列2,列3,...) values(值1,值2,值3,...)[,(值1,值2,值3,...),...]</code><ol>
<li>列与值一一对应</li>
<li>非数字值，要加引号（建议单引号）</li>
<li>自增列可以用 <code>null / default</code> 占位，默认列可以用 <code>default</code> 占位</li>
<li>如果为表的所有列插入数据，可以省略 <code>(列1,列2,列3,...)</code></li>
</ol>
</li>
<li><code>insert [into] 表名 set 列=值,...</code><ul>
<li>一次插入一条记录，值可以使用子查询</li>
</ul>
</li>
</ol>
<h2 id="4-2-update"><a href="#4-2-update" class="headerlink" title="4.2 update"></a>4.2 update</h2><ul>
<li><code>update 表名 set 列 = 值 [where条件]</code><ul>
<li>不加条件会更新所有行</li>
</ul>
</li>
</ul>
<h2 id="4-3-delete"><a href="#4-3-delete" class="headerlink" title="4.3 delete"></a>4.3 delete</h2><ol>
<li><code>delete from 表名 [where条件]</code><ul>
<li>若没有条件，表示删除所有行</li>
</ul>
</li>
<li><code>truncate [table] 表名;</code><ul>
<li>清空表</li>
</ul>
</li>
</ol>
<ul>
<li>truncate 和 delete 区别<ul>
<li>DELETE <ol>
<li>DML 操作，是逻辑性质删除，逐行删除速度慢</li>
<li>删除表中的数据，表结构还在，删除后的数据可以找回</li>
<li>自增长主键不会重置</li>
</ol>
</li>
<li>TRUNCATE <ol>
<li>DDL 操作，对表段中的数据页进行清空，速度快</li>
<li>相当于把表扔了又创建一个同样表结构的新表</li>
<li>自增长主键会重置</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="五-数据操作-DQL"><a href="#五-数据操作-DQL" class="headerlink" title="五 数据操作 DQL"></a>五 数据操作 DQL</h1><h2 id="5-1-语法"><a href="#5-1-语法" class="headerlink" title="5.1 语法"></a>5.1 语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select [选项] 表达式[, [选项] 表达式, ...]</span><br><span class="line">[</span><br><span class="line">	from 数据源 </span><br><span class="line">	[where 子句]</span><br><span class="line">	[group by 子句]</span><br><span class="line">	[having 子句]</span><br><span class="line">	[order by 子句]</span><br><span class="line">	[limit 子句]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="5-2-select-子句"><a href="#5-2-select-子句" class="headerlink" title="5.2 select 子句"></a>5.2 select 子句</h2><h3 id="1-选项"><a href="#1-选项" class="headerlink" title="1  选项"></a>1  选项</h3><ol>
<li><code>all</code><ul>
<li>保留所有结果（默认）</li>
</ul>
</li>
<li><code>distinct</code><ul>
<li>去除重复</li>
</ul>
</li>
<li><code>distinct row</code></li>
<li><code>top</code></li>
</ol>
<h3 id="2-表达式"><a href="#2-表达式" class="headerlink" title="2 表达式"></a>2 表达式</h3><ol>
<li>每一个表达式代表一列，可以是列名，变量，函数 …</li>
<li><code>*</code><ul>
<li>代表所有列</li>
</ul>
</li>
</ol>
<h3 id="3-别名"><a href="#3-别名" class="headerlink" title="3 别名"></a>3 别名</h3><ul>
<li><code>[as] 别名</code> <ol>
<li>表别名<ul>
<li>可用于全局</li>
</ul>
</li>
<li>列别名<ul>
<li>别名可用于 <code>having</code>，<code>order by</code>  </li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="5-2-from-子句"><a href="#5-2-from-子句" class="headerlink" title="5.2 from 子句"></a>5.2 from 子句</h2><ul>
<li>本质上只要数据类似二维表，都可以作为数据源<ol>
<li>单表数据源</li>
<li>多表数据源</li>
<li>查询语句</li>
</ol>
</li>
</ul>
<h2 id="5-4-where-子句"><a href="#5-4-where-子句" class="headerlink" title="5.4 where 子句"></a>5.4 where 子句</h2><h3 id="1-比较运算符"><a href="#1-比较运算符" class="headerlink" title="1 比较运算符"></a>1 比较运算符</h3><ul>
<li><code>&gt; &gt;= &lt; &lt;= = != ...</code></li>
</ul>
<h3 id="2-逻辑运算符"><a href="#2-逻辑运算符" class="headerlink" title="2 逻辑运算符"></a>2 逻辑运算符</h3><ul>
<li><code>and or not</code></li>
</ul>
<h3 id="3-语句"><a href="#3-语句" class="headerlink" title="3 语句"></a>3 语句</h3><ol>
<li><code>like pattern</code><ul>
<li>模糊查询</li>
<li><code>pattern</code><ul>
<li><code>%</code>：匹配任意个任意字符</li>
<li><code>_</code>：匹配一个任意字符</li>
</ul>
</li>
</ul>
</li>
<li><code>between ... and ...</code></li>
<li><code>is null</code></li>
<li><code>is not null</code></li>
<li><code>is boolean_value</code><ul>
<li>判断一个值的布尔值是否为 <code>boolean_value</code></li>
<li><code>boolean_value</code><ul>
<li><code>true</code></li>
<li><code>false</code></li>
<li><code>unknown</code></li>
</ul>
</li>
</ul>
</li>
<li><code>in()</code><ul>
<li>匹配其中任意一个值，则为 true，类似逻辑或</li>
</ul>
</li>
<li><code>any()</code><ul>
<li>必须配合比较运算符使用，代表（大于, 小于, …）其中任意一个值，则为 true</li>
</ul>
</li>
<li><code>some()</code><ul>
<li>是 <code>any()</code> 的别名</li>
</ul>
</li>
<li><code>all()</code><ul>
<li>必须配合比较运算符使用，代表（大于, 小于, …）其中所有值，则为 true</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">any()</th>
<th align="center">all()</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&gt; &gt;=</code></td>
<td align="center">最小值</td>
<td align="center">最大值</td>
</tr>
<tr>
<td align="center"><code>&lt; &lt;=</code></td>
<td align="center">最大值</td>
<td align="center">最小值</td>
</tr>
<tr>
<td align="center"><code>=</code></td>
<td align="center">任意值</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center"><code>&lt;&gt; !=</code></td>
<td align="center">-</td>
<td align="center">任意值</td>
</tr>
</tbody></table>
<h2 id="5-5-group-by-子句"><a href="#5-5-group-by-子句" class="headerlink" title="5.5 group by 子句"></a>5.5 group by 子句</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>通常配合聚合函数使用</li>
<li>可以有多个分组列，以逗号分隔</li>
<li>select 中查询的列只能有三种<ol>
<li>分组的列</li>
<li>聚合函数的列</li>
<li>与分组列一对一的列</li>
</ol>
</li>
</ol>
<h3 id="2-group-by-原理"><a href="#2-group-by-原理" class="headerlink" title="2 group by 原理"></a>2 group by 原理</h3><ol>
<li>先按照分组列 排序、去重，形成一张虚拟表</li>
<li>虚拟表的结构：分组列与其它列的对应关系<ol>
<li>分组列一对一的列可以直接查询（即与分组列对应的列只有一行记录）</li>
<li>分组列一对多的列不能直接查询（即与分组列对应的列有多行记录）<ol>
<li>使用聚合函数将多行记录统计为一行记录</li>
<li>使用 <code>group_concat()</code> 将多行记录合并连接为一行记录</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="3-聚合函数"><a href="#3-聚合函数" class="headerlink" title="3 聚合函数"></a>3 聚合函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>max()</code></td>
<td>列最大值</td>
</tr>
<tr>
<td><code>min()</code></td>
<td>列最小值</td>
</tr>
<tr>
<td><code>count()</code></td>
<td>列记录总数</td>
</tr>
<tr>
<td><code>sum()</code></td>
<td>列和</td>
</tr>
<tr>
<td><code>avg()</code></td>
<td>列平均值</td>
</tr>
<tr>
<td><code>group_concat()</code></td>
<td>将group by产生的同一个分组中的其它列的所有值连接成一个字符串（多行记录变一行）</td>
</tr>
<tr>
<td>* <code>count()</code></td>
<td></td>
</tr>
<tr>
<td>1. <code>count(1) count(*) count(&#39;abc&#39;) ...</code></td>
<td></td>
</tr>
<tr>
<td>* 此类参数表示数数，有一行记录总数就+1，也就是说总数与记录内容无关</td>
<td></td>
</tr>
<tr>
<td>* 记录总数（包含空行）</td>
<td></td>
</tr>
<tr>
<td>2. <code>count(列名)</code></td>
<td></td>
</tr>
<tr>
<td>* 记录总数（不包含空行）</td>
<td></td>
</tr>
</tbody></table>
<h2 id="5-6-having-子句"><a href="#5-6-having-子句" class="headerlink" title="5.6 having 子句"></a>5.6 having 子句</h2><ul>
<li>having 是对其之前子句筛选出的数据进行条件过滤</li>
</ul>
<h2 id="5-7-order-by子句"><a href="#5-7-order-by子句" class="headerlink" title="5.7 order by子句"></a>5.7 order by子句</h2><table>
<thead>
<tr>
<th>语句</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>asc</code></td>
<td>升序（默认）</td>
</tr>
<tr>
<td><code>desc</code></td>
<td>降序</td>
</tr>
<tr>
<td>1. 排序依赖校对集</td>
<td></td>
</tr>
<tr>
<td>2. <code>order by 列1 asc,列2 desc...</code></td>
<td></td>
</tr>
<tr>
<td>* 多个排序条件时，前一个排序结果相同才会按照下一个条件排序</td>
<td></td>
</tr>
</tbody></table>
<h2 id="5-8-limit-子句"><a href="#5-8-limit-子句" class="headerlink" title="5.8 limit 子句"></a>5.8 limit 子句</h2><ol>
<li><code>limit [startIndex] length</code><ul>
<li>从 <code>startIndex</code> 开始，取 <code>length</code> 条数据。</li>
<li><code>startIndex</code><ul>
<li>起始索引，若省略相当于 0。</li>
<li>数据库索引从 0 开始</li>
</ul>
</li>
</ul>
</li>
<li><code>limit length offset startIndex</code></li>
</ol>
<h2 id="5-9-union-amp-union-all"><a href="#5-9-union-amp-union-all" class="headerlink" title="5.9 union &amp; union all"></a>5.9 union &amp; union all</h2><ul>
<li>合并多个查询结果集</li>
<li>一般情况下,会将 <code>in()</code> 或者 <code>OR</code> 语句 改写成 <code>UNION ALL</code> ,来提高性能</li>
</ul>
<ol>
<li><code>union</code><ul>
<li>去除重复</li>
</ul>
</li>
<li><code>union all</code><ul>
<li>保留所有</li>
</ul>
</li>
</ol>
<h2 id="5-10-查询过程"><a href="#5-10-查询过程" class="headerlink" title="5.10 查询过程"></a>5.10 查询过程</h2><ol>
<li>from<ul>
<li>确定数据源</li>
</ul>
</li>
<li>where<ol>
<li>where 是直接对表中数据进行判断，所以只能使用表中的列，且不能使用别名</li>
<li>where 从表中查询出符合条件的数据形成一个概念中的临时结果集，存入内存</li>
<li>where 保证进入内存的数据都是有效的</li>
</ol>
</li>
<li>group by<ul>
<li>按照指定列进行分组</li>
</ul>
</li>
<li>select<ul>
<li>处理表达式（函数, 别名, 运算 …），形成结果集</li>
</ul>
</li>
<li>having<ul>
<li>对结果集进行过滤</li>
</ul>
</li>
<li>order by<ul>
<li>对过滤后的结果集进行排序</li>
</ul>
</li>
<li>limit<ul>
<li>对排序后的结果集进行条目限制，形成最终结果集</li>
</ul>
</li>
</ol>
<h1 id="六-多表连接"><a href="#六-多表连接" class="headerlink" title="六 多表连接"></a>六 多表连接</h1><h2 id="6-1-语法"><a href="#6-1-语法" class="headerlink" title="6.1 语法"></a>6.1 语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表1 </span><br><span class="line">&#123;[inner | cross] | &#123;left | right&#125; [outer]&#125;  join</span><br><span class="line">表2</span><br><span class="line">on 条件表达式</span><br><span class="line">[</span><br><span class="line">	&#123;[inner | cross] | &#123;left | right&#125; [outer]&#125;  join</span><br><span class="line">	表3</span><br><span class="line">	on 条件表达式</span><br><span class="line">	......</span><br><span class="line">]</span><br><span class="line">[where 子句]</span><br><span class="line">[group by 子句]</span><br><span class="line">[having 子句]</span><br><span class="line">[order by 子句]</span><br><span class="line">[limit 子句]</span><br></pre></td></tr></table></figure>
<ol>
<li>多表连接可以用在<ol>
<li>多表查询</li>
<li>多表更新</li>
<li>多表删除</li>
</ol>
</li>
<li><strong>自连接</strong><ul>
<li>连接的表是同一张表。</li>
</ul>
</li>
</ol>
<h2 id="6-2-内连接"><a href="#6-2-内连接" class="headerlink" title="6.2 内连接"></a>6.2 内连接</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 表1 [inner | cross] join 表2 on 条件</span><br><span class="line">2 from 表1,表2 where 条件</span><br></pre></td></tr></table></figure>
<ol>
<li>查出多表中符合条件的数据，即交集</li>
<li>内连接为左外连接与右外连接的交集。</li>
<li>内连接如果没有条件，结果会形成笛卡儿积</li>
</ol>
<h3 id="2-笛卡尔积"><a href="#2-笛卡尔积" class="headerlink" title="2 笛卡尔积"></a>2 笛卡尔积</h3><ol>
<li>笛卡儿积是元素相组合，不是数学相乘</li>
<li>数学中的笛卡儿积<ul>
<li>集合A有m个元素，集合B有n个元素，则笛卡尔积共 <code>m * n</code>个元素</li>
<li>例<ul>
<li>集合 A = {a, b}，集合 B = {0, 1, 2}</li>
<li>两个集合的笛卡尔积 = {(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}</li>
</ul>
</li>
</ul>
</li>
<li>数据库中的笛卡儿积<ul>
<li>表 A 有 m 条数据，表 B 中有 n 条数据，则笛卡尔积结果：<ol>
<li>行（记录数）= <code>m * n</code></li>
<li>列 = <code>表A的列数 + 表B的列数</code></li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="6-3-外连接"><a href="#6-3-外连接" class="headerlink" title="6.3 外连接"></a>6.3 外连接</h2><h3 id="1-左外连接"><a href="#1-左外连接" class="headerlink" title="1 左外连接"></a>1 左外连接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表1 left [outer] join 表2 on 条件</span><br></pre></td></tr></table></figure>
<ul>
<li>以左表为主，查出左表的全部记录和右表符合条件的记录，不符合条件的字段置为 <code>null</code></li>
</ul>
<h3 id="2-右外连接"><a href="#2-右外连接" class="headerlink" title="2 右外连接"></a>2 右外连接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表1 right [outer] join 表2 on 条件</span><br></pre></td></tr></table></figure>
<ul>
<li>以右表为主，查出右表的全部记录和左表符合条件的记录，不符合条件的字段置为 <code>null</code></li>
</ul>
<h2 id="6-4-例"><a href="#6-4-例" class="headerlink" title="6.4 例"></a>6.4 例</h2><h3 id="1-原始表-t1-amp-t2"><a href="#1-原始表-t1-amp-t2" class="headerlink" title="1 原始表 t1 &amp; t2"></a>1 原始表 t1 &amp; t2</h3><table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>D</td>
</tr>
<tr>
<td>3</td>
<td>E</td>
</tr>
<tr>
<td>4</td>
<td>F</td>
</tr>
</tbody></table>
<h3 id="2-内连接"><a href="#2-内连接" class="headerlink" title="2 内连接"></a>2 内连接</h3><ul>
<li><code>select * from t1 inner join t2 on t1.id=t2.id;</code></li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>a</td>
<td>2</td>
<td>D</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
<td>3</td>
<td>E</td>
</tr>
</tbody></table>
<h3 id="3-左外连接"><a href="#3-左外连接" class="headerlink" title="3 左外连接"></a>3 左外连接</h3><ul>
<li><code>select * from t1 left join t2 on t1.id=t2.id;</code></li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>a</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
<td>2</td>
<td>D</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
<td>3</td>
<td>E</td>
</tr>
</tbody></table>
<h3 id="4-右外连接"><a href="#4-右外连接" class="headerlink" title="4 右外连接"></a>4 右外连接</h3><ul>
<li><code>select * from t1 right join t2 on t1.id=t2.id;</code></li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>b</td>
<td>2</td>
<td>D</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
<td>3</td>
<td>E</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>4</td>
<td>F</td>
</tr>
</tbody></table>
<h3 id="5-全连接（-full-join-mysql不支持）"><a href="#5-全连接（-full-join-mysql不支持）" class="headerlink" title="5 全连接（(full join) mysql不支持）"></a>5 全连接（(full join) mysql不支持）</h3><ul>
<li><code>select * from t1 full join t2 on t1.id=t2.id;</code></li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>id</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>a</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
<td>2</td>
<td>D</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
<td>3</td>
<td>E</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>4</td>
<td>F</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>DB</category>
        <category>MySql</category>
      </categories>
  </entry>
  <entry>
    <title>MySql 属性</title>
    <url>/anyeansan.github.io/2020/03/30/MySql-%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h1 id="一-字符集-charset"><a href="#一-字符集-charset" class="headerlink" title="一 字符集 charset"></a>一 字符集 charset</h1><h2 id="1-1-MySQL-的-UTF-8"><a href="#1-1-MySQL-的-UTF-8" class="headerlink" title="1.1 MySQL 的 UTF-8"></a>1.1 MySQL 的 UTF-8</h2><ol>
<li>MySQL 中的 <code>utf8mb4</code> 才是真正的 <code>UTF-8</code>，而 <code>utf8</code> 是 <code>utf8mb3</code> 的别名，是 MySQL 脑残的产物</li>
<li>MySQL 表示未来会删除 <code>utf8mb3</code>，然后 <code>utf8</code> 指代 <code>utf8mb4</code>（真是个小机灵鬼）</li>
</ol>
<h2 id="1-2-字符集说明"><a href="#1-2-字符集说明" class="headerlink" title="1.2 字符集说明"></a>1.2 字符集说明</h2><ol>
<li><code>show charset</code><ul>
<li>查看数据库支持的字符集</li>
</ul>
</li>
<li><code>show variables like &#39;character%&#39;</code><ul>
<li>查看数据库默认字符集设置</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>配置</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>character_set_database</code></td>
<td>数据库默认字符集，若没设置则使用 <code>character_set_server</code></td>
</tr>
<tr>
<td><code>character_set_client</code></td>
<td>客户端字符集</td>
</tr>
<tr>
<td><code>character_set_connection</code></td>
<td>客户端连接数据库使用的字符集</td>
</tr>
<tr>
<td><code>character_set_results</code></td>
<td>数据库给客户端返回数据使用的字符集，若没设置则使用 <code>character_set_server</code></td>
</tr>
<tr>
<td><code>character_set_server</code></td>
<td>服务器字符集，建议由系统自己管理，不要人为定义</td>
</tr>
<tr>
<td><code>character_set_filesystem</code></td>
<td>用于将系统文件名转化成此字符集，默认 <code>binary</code> 不做转换（建议不改动）</td>
</tr>
<tr>
<td><code>character_set_system</code></td>
<td>数据库系统用来存储元数据的编码，通常是 <code>utf8</code>（不要改动）</td>
</tr>
<tr>
<td><code>character_sets_dir</code></td>
<td>字符集安装目录</td>
</tr>
</tbody></table>
<h2 id="1-3-乱码问题"><a href="#1-3-乱码问题" class="headerlink" title="1.3 乱码问题"></a>1.3 乱码问题</h2><h3 id="1-涉及的字符集"><a href="#1-涉及的字符集" class="headerlink" title="1 涉及的字符集"></a>1 涉及的字符集</h3><ol>
<li>数据本身字符集</li>
<li>客户端字符集 <code>character_set_client</code></li>
<li>连接字符集 <code>character_set_connection</code></li>
<li>数据库字符集 <code>character_set_database</code></li>
<li>结果字符集 <code>character_set_results</code></li>
</ol>
<h3 id="2-存"><a href="#2-存" class="headerlink" title="2 存"></a>2 存</h3><ul>
<li><code>数据字符集</code> → <code>客户端字符集</code> → <code>连接字符集</code> → <code>数据库字符集</code><ol>
<li><code>数据本身字符集 = 客户端字符集</code>，若不一致则会乱码</li>
<li>将数据从 <code>客户端字符集</code> 转为 <code>连接字符集</code>，若一致则不转换</li>
<li>将数据从 <code>连接字符集</code> 转为 <code>数据库字符集</code>，若一致则不转换</li>
<li>存数据最终是按照 <code>数据库字符集</code> 存储</li>
</ol>
</li>
<li>结论<ol>
<li>保证 <code>数据本身字符集 = 客户端字符集</code></li>
<li>连接字符集不要太小导致转换损失数据</li>
</ol>
</li>
</ul>
<h3 id="3-取"><a href="#3-取" class="headerlink" title="3 取"></a>3 取</h3><ul>
<li><code>数据库字符集</code> → <code>连接字符集</code> → <code>结果字符集</code> → <code>客户端字符集</code><ol>
<li>将数据从 <code>数据库字符集</code> 转为 <code>连接字符集</code> ，若一致则不转换</li>
<li>将数据从 <code>连接字符集</code> 转为 <code>结果字符集</code>，若一致则不转换</li>
<li>取数据最终是按照结果字符集返回给客户端</li>
<li>比较 <code>结果字符集</code> 与 <code>客户端字符集</code> 是否一致</li>
</ol>
</li>
<li>结论<ol>
<li>保证 <code>结果字符集 = 客户端字符集</code></li>
<li>连接字符集不要太小导致转换损失数据</li>
</ol>
</li>
</ul>
<h1 id="二-校对集-collation"><a href="#二-校对集-collation" class="headerlink" title="二 校对集 collation"></a>二 校对集 collation</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol>
<li>校对集，就是数据的比较方式，或者排序规则</li>
<li>只有当数据产生比较的时候，校对集才会生效</li>
<li>必须在没有数据之前声明好校对集，如果有了数据再进行校对集修改，修改无效</li>
<li>校对集依赖字符集，每个字符集都对应 1 或 多个校对集<ul>
<li><code>utf8mb4</code> 默认校对集 <code>utf8mb4_general_ci</code></li>
</ul>
</li>
</ol>
<h2 id="2-2-校对集格式"><a href="#2-2-校对集格式" class="headerlink" title="2.2 校对集格式"></a>2.2 校对集格式</h2><ol>
<li><code>show collation</code><ul>
<li>查看数据库支持的校对集</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>_bin</code></td>
<td><code>binary</code>，二进制比较, 大小写敏感（适用比较特殊的数据，如拼音，日文…）</td>
</tr>
<tr>
<td><code>_ci</code></td>
<td><code>case insensitive</code>，大小写不敏感</td>
</tr>
<tr>
<td><code>_cs</code></td>
<td><code>case sensitive</code>，大小写敏感</td>
</tr>
</tbody></table>
<h1 id="三-存储引擎-engine"><a href="#三-存储引擎-engine" class="headerlink" title="三 存储引擎 engine"></a>三 存储引擎 engine</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol>
<li>MySQL进行存储数据的方式。</li>
<li>每一种存储引擎使用不同的存储机制，索引技巧，锁定水平，最终提供广泛且不同的功能。</li>
</ol>
<h2 id="3-2-分类"><a href="#3-2-分类" class="headerlink" title="3.2 分类"></a>3.2 分类</h2><ol>
<li><code>InnoDB</code><ul>
<li>新版 MySQL 默认存储引擎</li>
</ul>
</li>
<li><code>Myisam</code><ul>
<li>速度快，不支持事务，安全性不够</li>
</ul>
</li>
<li><code>Memory</code><ul>
<li>数据存在内存中，不存在磁盘，一关闭服务器就消失。适合临时数据</li>
</ul>
</li>
<li><code>CSV</code></li>
<li><code>Archive</code></li>
<li><code>XtraDB</code><ul>
<li><code>PerconaDB</code> 默认存储引擎</li>
</ul>
</li>
<li><code>TokuDB RocksDB MyRocks</code><ul>
<li>第三方存储引擎：共同点是压缩比较高,数据插入性能极高</li>
</ul>
</li>
</ol>
<h2 id="3-3-存储引擎操作"><a href="#3-3-存储引擎操作" class="headerlink" title="3.3 存储引擎操作"></a>3.3 存储引擎操作</h2><h3 id="1-查"><a href="#1-查" class="headerlink" title="1 查"></a>1 查</h3><ol>
<li><code>show engines</code><ul>
<li>查看支持的存储引擎</li>
</ul>
</li>
<li><code>select @@default_storage_engine</code><ul>
<li>查看默认的存储引擎</li>
</ul>
</li>
</ol>
<h3 id="2-改"><a href="#2-改" class="headerlink" title="2 改"></a>2 改</h3><ol>
<li><code>alter table 表名 engine=存储引擎</code><ul>
<li>除了修改存储引擎外，还会做碎片整理</li>
</ul>
</li>
</ol>
<h2 id="3-4-InnoDB"><a href="#3-4-InnoDB" class="headerlink" title="3.4 InnoDB"></a>3.4 InnoDB</h2><h3 id="1-特性"><a href="#1-特性" class="headerlink" title="1 特性"></a>1 特性</h3><ol>
<li>事务（Transaction）</li>
<li>行级锁（Row-level Lock）</li>
<li>多版本并发控制 MVCC（Multi-Version Concurrency Control）</li>
<li>自动故障安全恢复 ACSR（Auto Crash Safey Recovery）</li>
<li>热备份（Hot Backup）</li>
<li>外键</li>
<li>复制 Replication<ol>
<li>Group Commit</li>
<li>GTID (Global Transaction ID)</li>
<li>多线程（Multi-Threads-SQL）</li>
</ol>
</li>
</ol>
<h3 id="2-物理存储结构"><a href="#2-物理存储结构" class="headerlink" title="2 物理存储结构"></a>2 物理存储结构</h3><h4 id="1-共享表空间"><a href="#1-共享表空间" class="headerlink" title="1 共享表空间"></a>1 共享表空间</h4><ol>
<li><code>idbdata1</code><ul>
<li>系统数据字典信息（统计信息），Undo 回滚日志等数据</li>
</ul>
</li>
<li><code>ib_logfile0~ib_logfile1</code><ul>
<li>Redo 重做日志文件，事务日志文件</li>
</ul>
</li>
<li><code>ibtmp1</code><ul>
<li>临时表空间，存储临时表（如 join union 等操作）</li>
</ul>
</li>
</ol>
<h4 id="2-独立表空间"><a href="#2-独立表空间" class="headerlink" title="2 独立表空间"></a>2 独立表空间</h4><ol>
<li><code>frm</code><ul>
<li>存储表列信息（列名，列属性）</li>
</ul>
</li>
<li><code>ibd</code><ul>
<li>存储表数据行和索引</li>
</ul>
</li>
<li><code>opt</code><ul>
<li>存储库属性</li>
</ul>
</li>
</ol>
<ul>
<li>一张 InnoDB 表 = <code>ibdata1 + frm + ibd（段、区、页）</code></li>
</ul>
<h4 id="3-表空间-Tablespace"><a href="#3-表空间-Tablespace" class="headerlink" title="3 表空间 Tablespace"></a>3 表空间 Tablespace</h4><ol>
<li>共享表空间：将所有数据存储到同一个表空间中 ，管理比较混乱</li>
<li>独立表空间：一张表一个 <code>frm</code> 存储列信息，一个 <code>ibd</code> 存储数据行和索引</li>
<li>说明<ol>
<li>共享表空间是 5.5 版本出现的管理模式</li>
<li>5.6 版本开始默认使用独立表空间，保留共享表空间，只用来存储：数据字典信息，undo，临时表</li>
<li>5.7 版本临时表被独立出去，共享表空间只存储：数据字典信息，undo</li>
<li>8.0 版本undo也被独立出去，共享表空间只存储：数据字典信息</li>
</ol>
</li>
</ol>
<h4 id="4-核心参数"><a href="#4-核心参数" class="headerlink" title="4 核心参数"></a>4 核心参数</h4><h5 id="1-存储引擎"><a href="#1-存储引擎" class="headerlink" title="1 存储引擎"></a>1 存储引擎</h5><ol>
<li><code>default_storage_engine=innodb</code><ul>
<li>默认存储引擎</li>
</ul>
</li>
</ol>
<h5 id="2-表空间"><a href="#2-表空间" class="headerlink" title="2 表空间"></a>2 表空间</h5><ol>
<li><code>innobd_file_pre_table=1</code><ul>
<li>表空间模式，1 独立表空间</li>
</ul>
</li>
<li><code>innodb_data_file_path=ibdata1:512M:ibdata2:512M:autoextend</code><ul>
<li>共享表空间文件个数和大小</li>
</ul>
</li>
</ol>
<h5 id="3-缓冲区"><a href="#3-缓冲区" class="headerlink" title="3 缓冲区"></a>3 缓冲区</h5><ol>
<li><code>innodb_flush_log_at_trx_commit=1</code><ul>
<li>双一标准之一</li>
<li>控制了 innodb 将 <code>log buffer</code> 中的数据写入日志文件并 flush 磁盘的时间点，取值分别为 0、1、2 三个</li>
</ul>
</li>
<li><code>Innodb_flush_method=(O_DIRECT, fdatasync)</code><ul>
<li>双一标准之一</li>
<li>控制 <code>log buffer</code> 和 <code>data buffer</code> 刷写磁盘的时候是否经过文件系统缓存 <code>OS buffer</code></li>
</ul>
</li>
<li><code>innodb_max_dirty_pages_pct=75</code><ul>
<li>脏页刷写策略</li>
</ul>
</li>
</ol>
<h5 id="4-redo-日志"><a href="#4-redo-日志" class="headerlink" title="4 redo 日志"></a>4 redo 日志</h5><ol>
<li><code>innodb_log_buffer_size</code></li>
<li><code>innodb_log_file_size</code></li>
<li><code>innodb_log_files_in_group</code></li>
</ol>
<h1 id="四-列属性"><a href="#四-列属性" class="headerlink" title="四 列属性"></a>四 列属性</h1><h2 id="4-1-数据类型"><a href="#4-1-数据类型" class="headerlink" title="4.1 数据类型"></a>4.1 数据类型</h2><h3 id="1-数值类型"><a href="#1-数值类型" class="headerlink" title="1 数值类型"></a>1 数值类型</h3><h4 id="1-整型"><a href="#1-整型" class="headerlink" title="1 整型"></a>1 整型</h4><p>类型|大小|无符号范围|有符号范围<br>-|-|-|-|-<br><strong>tinyint</strong> |1 Byte|<code>0 ~ 255</code>|<code>-128 ~ 127</code><br><code>smallint</code>|2 Byte|<code>0 ~ 65535</code>|<code>-2<sup>15</sup> ~ 2<sup>15</sup>-1</code><br><code>mediumint</code>|3 Byte|<code>0 ~ 2<sup>24</sup>-1</code><code>|&lt;code&gt;-2&lt;sup&gt;23&lt;/sup&gt; ~ 2&lt;sup&gt;23&lt;/sup&gt;-1&lt;/code&gt;
**int**|4 Byte|&lt;code&gt;0 ~ 2&lt;sup&gt;32&lt;/sup&gt;-1&lt;/code&gt;</code>|<code>-2<sup>31</sup> ~ 2<sup>31</sup>-1</code><br><code>bigint</code>|8 Byte|<code>0 ~ 2<sup>64</sup>-1</code>`|<code>-2<sup>63</sup> ~ 2<sup>63</sup>-1</code></p>
<ul>
<li><code>int(M)</code><ul>
<li><code>M</code> 与存储长度无关，只是标识显示长度，且要配合 <code>zerofill</code> 才有意义</li>
</ul>
</li>
</ul>
<h4 id="2-浮点型-amp-定点型"><a href="#2-浮点型-amp-定点型" class="headerlink" title="2 浮点型 &amp; 定点型"></a>2 浮点型 &amp; 定点型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>float</code></td>
<td>单精度 4 Byte</td>
</tr>
<tr>
<td><code>double</code></td>
<td>双精度 8 Byte</td>
</tr>
<tr>
<td><code>decimal</code></td>
<td>精确数值</td>
</tr>
<tr>
<td>1. <code>float(M,D)</code></td>
<td></td>
</tr>
<tr>
<td>* <code>M</code></td>
<td></td>
</tr>
<tr>
<td>* 精度，即总位数</td>
<td></td>
</tr>
<tr>
<td>* <code>D</code></td>
<td></td>
</tr>
<tr>
<td>* 标度，即小数点后的位数</td>
<td></td>
</tr>
<tr>
<td>* 不足用0补，超过则四舍五入</td>
<td></td>
</tr>
<tr>
<td>2. <code>decimal(M,D)</code></td>
<td></td>
</tr>
<tr>
<td>* <code>0&lt;M&lt;65</code>，<code>D&lt;M &amp;&amp; 0&lt;D&lt;30</code></td>
<td></td>
</tr>
<tr>
<td>* 默认为 <code>decimal(10, 0)</code></td>
<td></td>
</tr>
</tbody></table>
<h3 id="2-字符串类型"><a href="#2-字符串类型" class="headerlink" title="2 字符串类型"></a>2 字符串类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>char</strong></td>
<td>定长字符串</td>
</tr>
<tr>
<td><strong>varchar</strong></td>
<td>变长字符串</td>
</tr>
<tr>
<td><code>tinytext</code></td>
<td>短文本</td>
</tr>
<tr>
<td><code>text</code></td>
<td>文本</td>
</tr>
<tr>
<td><code>mediumtext</code></td>
<td>中长文本</td>
</tr>
<tr>
<td><code>longtext</code></td>
<td>长文本</td>
</tr>
</tbody></table>
<h4 id="1-char"><a href="#1-char" class="headerlink" title="1 char"></a>1 char</h4><ol>
<li>非空 char 的最大长度是 255【字节】</li>
<li>可空 char 的最大长度是 254【字节】，因为非空标记需要占用 1 个字节<ul>
<li>当允许为空时，系统会自动从整个记录中保留一个字节来存储 NULL</li>
</ul>
</li>
<li><code>char(M)</code><ol>
<li>M 为字符数，<code>0~255</code></li>
<li>char 存储时会立即分配 M 个字符长度的存储空间，未占满的空间使用<strong>空格</strong>填充</li>
</ol>
</li>
</ol>
<h4 id="2-varchar"><a href="#2-varchar" class="headerlink" title="2 varchar"></a>2 varchar</h4><ol>
<li>非空 varchar 的最大长度是 65532【字节】<ol>
<li>如果存储值小于 255 字节，则使用 1 个字节标记长度</li>
<li>如果存储值超过 255 字节，则使用 2 个字节标记长度</li>
<li>varchar是从第二个字节开始存储的</li>
</ol>
</li>
<li>可空 varchar 的最大长度是 65531【字节】</li>
<li><code>varchar(M)</code><ol>
<li>M 为字符数，<code>0 ~ 65535</code>，但由于 varcahr 最大长度是 65532 字节，所以 M 实际范围跟字符集有关，比如 utf8 一个字符占用 3 个字节，则 M 最大长度是 <code>65532 / 3</code></li>
<li>varchar 存储前会先判断长度，按需分配空间</li>
</ol>
</li>
</ol>
<h4 id="3-以-utf8-为例比较"><a href="#3-以-utf8-为例比较" class="headerlink" title="3 以 utf8 为例比较"></a>3 以 utf8 为例比较</h4><table>
<thead>
<tr>
<th>类型</th>
<th>可存字符</th>
<th>实存字符</th>
<th>实占字节</th>
<th>利用率</th>
</tr>
</thead>
<tbody><tr>
<td><code>char(M)</code></td>
<td>M</td>
<td>n</td>
<td><code>M * 3</code></td>
<td><code>n / M</code></td>
</tr>
<tr>
<td><code>varchar(M)</code></td>
<td>M</td>
<td>n</td>
<td><code>n * 3 + (1~2)</code></td>
<td><code>n * 3 / （n * 3 + (1~2)）</code></td>
</tr>
</tbody></table>
<h3 id="3-枚举-enum"><a href="#3-枚举-enum" class="headerlink" title="3 枚举 enum"></a>3 枚举 enum</h3><ul>
<li><code>enum(value1, value2, value3, ...)</code><ol>
<li>建表时在字段上定义枚举列表，按照定义顺序索引值从 1 开始编号<ul>
<li>空字符串 <code>&quot;&quot;</code> 索引为 0，<code>null</code> 索引为 <code>null</code></li>
</ul>
</li>
<li>插入数据时（单选），可以使用索引值或者枚举值</li>
<li>数据库存储时存储索引，读取时再根据枚举列表将索引转为枚举值</li>
</ol>
</li>
</ul>
<h3 id="4-集合-set"><a href="#4-集合-set" class="headerlink" title="4 集合 set"></a>4 集合 set</h3><ul>
<li><code>set(value1, value2, value3, ...)</code><ol>
<li>建表时在字段上定义集合列表，集合中每个值对应一个二进制位<ul>
<li>第一个值对应 <code>1 = 1</code></li>
<li>第二个值对应 <code>10 = 2</code></li>
<li>第三个值对应 <code>100 = 4</code></li>
<li>第四个值对应 <code>1000 = 8</code></li>
<li>…</li>
<li>也就是说一个二进制数，从低位向高位依次对应集合从 1 开始的值</li>
</ul>
</li>
<li>插入数据时（多选），可以使用二进制对应的十进制数字，插入数字对应的二进制，相应位置为 1 代表插入该值，例如<ul>
<li>插入 <code>6</code>，转为二进制 <code>110</code>，即插入第二和第三个值</li>
<li>插入 <code>7</code>，转为二进制 <code>111</code>，即插入前三个值</li>
<li>插入 <code>8</code>，转为二进制 <code>1000</code>，即插入第四个值</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="5-日期类型"><a href="#5-日期类型" class="headerlink" title="5 日期类型"></a>5 日期类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>格式</th>
<th>大小</th>
<th>最小值</th>
<th>最大值</th>
<th>零值</th>
</tr>
</thead>
<tbody><tr>
<td><strong>datetime</strong></td>
<td><code>yyyy-mm-dd hh:mm:ss</code></td>
<td>8 Byte</td>
<td><code>1000-01-01 00:00:00</code></td>
<td><code>9999-12-31 23:59:59</code></td>
<td><code>0000-00-00 00:00:00</code></td>
</tr>
<tr>
<td><strong>timestamp</strong></td>
<td><code>yyyy-mm-dd hh:mm:ss</code></td>
<td>4 Byte</td>
<td><code>1970-01-01 00:00:00</code></td>
<td><code>2038-01-19 03:14:07</code></td>
<td><code>0000-00-00 00:00:00</code></td>
</tr>
<tr>
<td><code>date</code></td>
<td><code>yyyy-mm-dd</code></td>
<td>3 Byte</td>
<td><code>1000-01-01</code></td>
<td><code>9999-12-31</code></td>
<td><code>0000-00-00</code></td>
</tr>
<tr>
<td><code>time</code></td>
<td><code>hh:mm:ss</code></td>
<td>3 Byte</td>
<td><code>-838:59:59</code></td>
<td><code>838:59:59</code></td>
<td><code>00:00:00</code></td>
</tr>
<tr>
<td>1. Mysql保存日期格式使用 <code>YYYY-MM-DD HH:MM:SS</code> 的ISO 8601标准</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2. 向数据表储存日期与时间必须使用ISO格式</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3. <code>timestamp</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1. <code>yyyy-mm-dd hh:mm:ss</code> 格式的时间戳（从 <code>1970-01-01 00:00:00</code> 到指定时间的毫秒值）</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2. 插入和更新时如果未指定则会插入当前时间</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3. 根据时区自动变化显示</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="6-二进制类型"><a href="#6-二进制类型" class="headerlink" title="6 二进制类型"></a>6 二进制类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>tinyblob</code></td>
<td>最大长度为255B</td>
</tr>
<tr>
<td><code>blob</code></td>
<td>最大长度为64KB</td>
</tr>
<tr>
<td><code>mediumblob</code></td>
<td>最大长度为16MB</td>
</tr>
<tr>
<td><code>longblob</code></td>
<td>最大长度为4GB</td>
</tr>
<tr>
<td>* 二进制数据类型可存储任何数据（甚至包括二进制信息），如图像、多媒体、字处理文档等</td>
<td></td>
</tr>
</tbody></table>
<h2 id="4-2-注释"><a href="#4-2-注释" class="headerlink" title="4.2 注释"></a>4.2 注释</h2><ul>
<li><code>comment &#39;注释&#39;</code><ul>
<li>用于描述字段信息</li>
</ul>
</li>
</ul>
<h2 id="4-3-unsigned"><a href="#4-3-unsigned" class="headerlink" title="4.3 unsigned"></a>4.3 unsigned</h2><ul>
<li><code>unsigned</code><ol>
<li>将数值类型声明为无符号</li>
<li>MySQL 中的数值默认都是有符号的。</li>
</ol>
</li>
</ul>
<h2 id="4-4-zerofill"><a href="#4-4-zerofill" class="headerlink" title="4.4 zerofill"></a>4.4 zerofill</h2><ul>
<li><code>zerofill</code><ol>
<li>数值类型的列位数不足时用 0 补填充</li>
<li>如果声明 <code>zerofill</code>，则会自动声明为 <code>unsigned</code></li>
</ol>
</li>
</ul>
<h2 id="4-5-自增长"><a href="#4-5-自增长" class="headerlink" title="4.5 自增长"></a>4.5 自增长</h2><h3 id="1-增"><a href="#1-增" class="headerlink" title="1 增"></a>1 增</h3><ul>
<li><code>auto_increment</code><ol>
<li>自增长需要搭配主键使用</li>
<li>自增长字段必须是数字(整型)</li>
<li>一张表最多只能有一个自增长</li>
<li>如果插入数据时字段指定为0、null或未指定值，那么插入自增长的值</li>
<li>如果插入数据时字段指定了具体值<ol>
<li>如果插入值&lt;自增值，则表的自增值不变</li>
<li>如果插入值&gt;自增值，则表的自增值会变成插入值</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="2-查"><a href="#2-查" class="headerlink" title="2 查"></a>2 查</h3><ol>
<li><code>show variables like &#39;auto_increment%&#39;</code><ul>
<li><code>auto_increment_increment</code><ul>
<li>初始值</li>
</ul>
</li>
<li><code>auto_increment_offset</code> <ul>
<li>种子</li>
</ul>
</li>
</ul>
</li>
<li><code>select last_insert_id()</code><ul>
<li>获取自增的最后一个值</li>
</ul>
</li>
<li><code>show create database 库名</code><ul>
<li>可以通过查看表创建语句查看下一次自增长的值</li>
</ul>
</li>
</ol>
<h3 id="3-修改自增长的值"><a href="#3-修改自增长的值" class="headerlink" title="3 修改自增长的值"></a>3 修改自增长的值</h3><ul>
<li><code>alter table 表名 auto_increment = 值</code><ul>
<li>只能比当前自增长的最大值大，不能小(小不生效)</li>
</ul>
</li>
</ul>
<h3 id="4-删除自增长"><a href="#4-删除自增长" class="headerlink" title="4 删除自增长"></a>4 删除自增长</h3><ul>
<li>修改列属性为没有 <code>auto_increment</code> 即删除。</li>
</ul>
<h2 id="4-6-约束"><a href="#4-6-约束" class="headerlink" title="4.6 约束"></a>4.6 约束</h2><h3 id="1-主键约束-primary-key"><a href="#1-主键约束-primary-key" class="headerlink" title="1 主键约束 primary key"></a>1 主键约束 <code>primary key</code></h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>主键约束列唯一，非null</li>
<li>一张表只能有一个主键</li>
</ol>
<h4 id="2-增"><a href="#2-增" class="headerlink" title="2 增"></a>2 增</h4><ol>
<li><code>列名 primaray key</code><ul>
<li>建表时为当前列添加主键</li>
</ul>
</li>
<li><code>primary key(列1,列2,...)</code><ul>
<li>建表时，单独一行，添加单一主键或复合主键</li>
</ul>
</li>
<li><code>alter table 表名 add [constraint 主键约束名] primary key(列1,列2,...)</code><ul>
<li>建表后，添加单一主键或复合主键</li>
</ul>
</li>
</ol>
<h4 id="3-改-删"><a href="#3-改-删" class="headerlink" title="3 改 / 删"></a>3 改 / 删</h4><ol>
<li>主键无法修改</li>
<li>删除<ol>
<li>有自增先要删除自增</li>
<li>删除主键<ol>
<li><code>alter table 表名 drop primary key</code></li>
<li><code>alter table 表名 drop constraint 主键约束名</code></li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="4-主键冲突-（主键值已存在-Duplicate-key）"><a href="#4-主键冲突-（主键值已存在-Duplicate-key）" class="headerlink" title="4 主键冲突 （主键值已存在 Duplicate key）"></a>4 主键冲突 （主键值已存在 <code>Duplicate key</code>）</h4><ol>
<li>更新<ul>
<li><code>Insert into 表名[字段列表(包含主键)] values(值列表) on duplicate key update 字段 = 新值</code></li>
</ul>
</li>
<li>替换<ul>
<li><code>Replace into 表名 [字段列表(包含主键)] values(值列表)</code></li>
</ul>
</li>
</ol>
<h3 id="2-外键约束-foreign-key"><a href="#2-外键约束-foreign-key" class="headerlink" title="2 外键约束 foreign key"></a>2 外键约束 <code>foreign key</code></h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>父表和子表必须使用相同的存储引擎 <code>InnoDB</code>，且禁止使用临时表</li>
<li>外键列和参照列必须具有一样的数据类型，数字的长度和是否有符号必须一致，字符长度可以不同</li>
<li>外键列和参照列必须创建索引，如果外键列不存在索引，mysql会自动创建索引。</li>
</ol>
<h4 id="2-外键约束模式"><a href="#2-外键约束模式" class="headerlink" title="2 外键约束模式"></a>2 外键约束模式</h4><h5 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h5><ol>
<li><code>on update 模式</code></li>
<li><code>on delete 模式</code></li>
</ol>
<h5 id="2-模式"><a href="#2-模式" class="headerlink" title="2 模式"></a>2 模式</h5><ol>
<li><code>restrict</code><ul>
<li>严格模式（默认）</li>
<li>如果子表中有关联的记录，则父表不能 <code>update/delete</code></li>
</ul>
</li>
<li><code>no action</code><ul>
<li>标准SQL的关键字，在 MySQL 中同 <code>restrict</code></li>
</ul>
</li>
<li><code>cascade</code><ul>
<li>级联模式</li>
<li>对父表 <code>update/delete</code> 时，子表相关联的记录同步 <code>update/delete</code></li>
</ul>
</li>
<li><code>set null</code><ul>
<li>置空模式</li>
<li>对父表 <code>update/delete</code> 时，将子表外键列设为 <code>null</code>（子表的外键列不能为 <code>not null</code>）</li>
</ul>
</li>
</ol>
<h4 id="3-增"><a href="#3-增" class="headerlink" title="3 增"></a>3 增</h4><ol>
<li><code>[constraint 外键约束名] foreign key(外键字段) references 父表(主键字段) [on delete 模式 on update 模式]</code><ul>
<li>建表时添加，在所有字段后</li>
</ul>
</li>
<li><code>Alter table 表名 add [constraint 外键约束名] foreign key(外键字段) references 父表(主键字段) [on delete 模式 on update 模式]</code><ul>
<li>建表后添加</li>
</ul>
</li>
</ol>
<h4 id="4-改-删"><a href="#4-改-删" class="headerlink" title="4 改 / 删"></a>4 改 / 删</h4><ol>
<li>外键不能修改</li>
<li>删除<ul>
<li><code>Alter table 表名 drop foreign key 外键约束名</code></li>
</ul>
</li>
</ol>
<h3 id="3-非空约束-not-null"><a href="#3-非空约束-not-null" class="headerlink" title="3 非空约束 not null"></a>3 非空约束 <code>not null</code></h3><ol>
<li><code>null</code><ul>
<li>列允许为空（默认）</li>
</ul>
</li>
<li><code>not null</code><ul>
<li>列不能为空，必须插入值，通常配合 <code>default</code> 使用</li>
<li><code>null</code> 没有意义且所有运算一律返回 <code>null</code>，效率不高，影响索引结果</li>
</ul>
</li>
</ol>
<h3 id="4-默认约束-default"><a href="#4-默认约束-default" class="headerlink" title="4 默认约束 default"></a>4 默认约束 <code>default</code></h3><h4 id="1-增-1"><a href="#1-增-1" class="headerlink" title="1 增"></a>1 增</h4><ol>
<li><code>列名 default 值</code><ul>
<li>建表时，给当前列添加默认值</li>
</ul>
</li>
<li><code>alter table 表名 alter [column] 列 set default 值</code><ul>
<li>建表后，给指定列添加默认值</li>
</ul>
</li>
</ol>
<h4 id="2-删"><a href="#2-删" class="headerlink" title="2 删"></a>2 删</h4><ul>
<li><code>alter table 表名 alter [column] 列 drop default</code></li>
</ul>
<h4 id="3-使用"><a href="#3-使用" class="headerlink" title="3 使用"></a>3 使用</h4><ol>
<li>对应字段没有插入值，则使用默认值。</li>
<li>显式的插入 <code>default</code> 关键字，表示使用默认值</li>
</ol>
<h3 id="5-唯一约束-unique-key"><a href="#5-唯一约束-unique-key" class="headerlink" title="5 唯一约束 unique key"></a>5 唯一约束 <code>unique key</code></h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>唯一约束列唯一，可以为 <code>null</code>，且可以有多个 <code>null</code>，因为 <code>null = null</code> 返回 false</li>
<li>一张表可以有多个唯一约束 </li>
</ol>
<h4 id="2-增-1"><a href="#2-增-1" class="headerlink" title="2 增"></a>2 增</h4><ol>
<li><code>列 unique key</code><ul>
<li>建表时，为当前列添加唯一约束</li>
</ul>
</li>
<li><code>unique key(列1,列2,...)</code><ul>
<li>建表时，单独一行，为指定列添加唯一约束</li>
</ul>
</li>
<li><code>alter table 表名 add [constraint 唯一约束名] unique key(列1,列2,...)</code><ul>
<li>建表后，为指定列添加唯一约束</li>
</ul>
</li>
</ol>
<h4 id="3-删"><a href="#3-删" class="headerlink" title="3 删"></a>3 删</h4><ol>
<li><code>alter table 表名 drop [index/key] 唯一约束名</code></li>
</ol>
]]></content>
      <categories>
        <category>DB</category>
        <category>MySql</category>
      </categories>
  </entry>
  <entry>
    <title>MySql 安装和配置</title>
    <url>/anyeansan.github.io/2020/03/30/MySql-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><ol>
<li>DBMS（Database Management System）<ul>
<li>数据库管理系统</li>
</ul>
</li>
<li>DBA（Database Administrator）<ul>
<li>数据库管理员</li>
</ul>
</li>
</ol>
<h2 id="1-2-DBMS-分类"><a href="#1-2-DBMS-分类" class="headerlink" title="1.2 DBMS 分类"></a>1.2 DBMS 分类</h2><h3 id="1-RDBMS（Relational-Database-Management-System）"><a href="#1-RDBMS（Relational-Database-Management-System）" class="headerlink" title="1 RDBMS（Relational Database Management System）"></a>1 RDBMS（Relational Database Management System）</h3><ol>
<li><code>Oracle DB2</code></li>
<li><code>Sql-Server Mysql</code></li>
<li><code>access</code></li>
<li><code>PG MSSQL</code></li>
</ol>
<h3 id="2-NoSQL（Not-Only-SQL）"><a href="#2-NoSQL（Not-Only-SQL）" class="headerlink" title="2 NoSQL（Not Only SQL）"></a>2 NoSQL（Not Only SQL）</h3><ol>
<li><code>MongoDB</code></li>
<li><code>Redis</code></li>
<li><code>ES（Elasticsearch）</code></li>
<li><code>memcached</code></li>
</ol>
<h3 id="3-NewSQL（分布式）"><a href="#3-NewSQL（分布式）" class="headerlink" title="3 NewSQL（分布式）"></a>3 NewSQL（分布式）</h3><ul>
<li><code>TiDB Spanner AliSQL OB PolarDB</code></li>
</ul>
<h2 id="1-3-Mysql-GA版本"><a href="#1-3-Mysql-GA版本" class="headerlink" title="1.3 Mysql GA版本"></a>1.3 Mysql GA版本</h2><ol>
<li><code>5.6</code><ul>
<li><code>5.6.38</code>（2017-09-13）</li>
</ul>
</li>
<li><code>5.7</code><ul>
<li><code>5.7.20</code>（2017-09-13）</li>
</ul>
</li>
</ol>
<h1 id="二-Mysql-安装与配置"><a href="#二-Mysql-安装与配置" class="headerlink" title="二 Mysql 安装与配置"></a>二 Mysql 安装与配置</h1><h2 id="2-1-Linux"><a href="#2-1-Linux" class="headerlink" title="2.1 Linux"></a>2.1 Linux</h2><h3 id="1-下载解压"><a href="#1-下载解压" class="headerlink" title="1 下载解压"></a>1 下载解压</h3><ol>
<li>下载 <code>linux-generic</code> 通用二进制包（类似绿色版）</li>
<li>上传到 linux 并解压</li>
</ol>
<h3 id="2-卸载-mariadb"><a href="#2-卸载-mariadb" class="headerlink" title="2 卸载 mariadb"></a>2 卸载 <code>mariadb</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 rpm -qa | grep mariadb</span><br><span class="line">2 yum remove -y xxx</span><br></pre></td></tr></table></figure>
<h3 id="3-创建用户并授权，用于管理mysql"><a href="#3-创建用户并授权，用于管理mysql" class="headerlink" title="3 创建用户并授权，用于管理mysql"></a>3 创建用户并授权，用于管理mysql</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 useradd -s /sbin/nologin mysql</span><br><span class="line">2 chown -R mysql.mysql basedir</span><br><span class="line">3 chown -R mysql.mysql datadir</span><br></pre></td></tr></table></figure>

<h3 id="4-设置环境变量"><a href="#4-设置环境变量" class="headerlink" title="4 设置环境变量"></a>4 设置环境变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 vim /etc/profile</span><br><span class="line">2 export PATH=basedir/bin:$PATH</span><br><span class="line">3 source /etc/profile</span><br><span class="line">4 mysql -V</span><br></pre></td></tr></table></figure>

<h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5 初始化"></a>5 初始化</h3><h4 id="1-无密码"><a href="#1-无密码" class="headerlink" title="1 无密码"></a>1 无密码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqld --initialize-insecure --user=mysql --basedir=xxx --datadir=xxx</span><br></pre></td></tr></table></figure>

<h4 id="2-有密码"><a href="#2-有密码" class="headerlink" title="2 有密码"></a>2 有密码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqld --initialize --user=mysql --basedir=xxx --datadir=xxx</span><br></pre></td></tr></table></figure>
<ol>
<li>可能会因为缺少 <code>libaio-devel</code> 依赖而报错</li>
<li><code>--initialize</code><ol>
<li>对密码复杂度进行定制：12位，4种</li>
<li>密码过期时间：180天</li>
<li>给root@localhost 用户设置临时密码</li>
</ol>
</li>
</ol>
<h3 id="6-配置文件"><a href="#6-配置文件" class="headerlink" title="6 配置文件"></a>6 配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt;/etc/my.cnf &lt;&lt;EOF</span><br><span class="line">[mysqld] </span><br><span class="line">user=mysql</span><br><span class="line">basedir=</span><br><span class="line">datadir=</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">port=3306</span><br><span class="line">server_id=6</span><br><span class="line">[mysql]</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h3 id="7-MySQL-服务"><a href="#7-MySQL-服务" class="headerlink" title="7 MySQL 服务"></a>7 MySQL 服务</h3><h4 id="1-启动方式"><a href="#1-启动方式" class="headerlink" title="1 启动方式"></a>1 启动方式</h4><h5 id="1-init"><a href="#1-init" class="headerlink" title="1 init"></a>1 <code>init</code></h5><ol>
<li>配置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp basedir/support-files/mysql.server /etc/init.d/mysqld</span><br></pre></td></tr></table></figure></li>
<li>启动<ul>
<li><code>service mysqld start</code> 或 <code>/etc/init.d/mysqld start</code><ol>
<li>其实是调用了 <code>basedir/support-files/mysql.server</code> 脚本</li>
<li><code>mysql.server</code> 脚本<ol>
<li>读取 <code>/etc/my.cnf</code> 配置文件</li>
<li>调用 <code>basedir/bin/mysqld_safe</code> 来启动 <code>mysqld</code></li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h5 id="2-systemd"><a href="#2-systemd" class="headerlink" title="2 systemd"></a>2 <code>systemd</code></h5><ol>
<li>配置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt;/etc/systemd/system/mysqld.service &lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=MySQL Server</span><br><span class="line">Documentation=man:mysqld(8)</span><br><span class="line">Documentation=http://dev.mysql.com/doc/refman/en/using-systemd.html</span><br><span class="line">After=network.target</span><br><span class="line">After=syslog.target</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">[Service]</span><br><span class="line">User=mysql</span><br><span class="line">Group=mysql</span><br><span class="line">ExecStart=basedir/bin/mysqld --defaults-file=/etc/my.cnf</span><br><span class="line">LimitNOFILE = 5000</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li>
<li>启动<ul>
<li><code>systemctl start mysqld</code><ol>
<li>其实是加载了 <code>/etc/systemd/system/mysqld.service</code></li>
<li><code>mysqd.service</code> 中 <code>ExecStart</code><ol>
<li>读取 <code>/etc/my.cnf</code> 配置文件</li>
<li>启动 <code>mysqld</code></li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h5 id="3-手动"><a href="#3-手动" class="headerlink" title="3 手动"></a>3 手动</h5><ol>
<li><code>mysqld_safe --skip-grant-tables --skip-networking &amp;</code><ul>
<li>维护模式启动</li>
</ul>
</li>
</ol>
<h4 id="2-初始化配置"><a href="#2-初始化配置" class="headerlink" title="2 初始化配置"></a>2 初始化配置</h4><h5 id="1-作用"><a href="#1-作用" class="headerlink" title="1 作用"></a>1 作用</h5><ol>
<li>影响数据库的启动</li>
<li>影响客户端的功能</li>
</ol>
<h5 id="2-初始化配置方式"><a href="#2-初始化配置方式" class="headerlink" title="2 初始化配置方式"></a>2 初始化配置方式</h5><ol>
<li>初始化配置文件（如 <code>etc/my.cnf</code> ）</li>
<li>命令行启动参数<ul>
<li>如果参数冲突，命令行参数会优先级高于配置文件</li>
</ul>
</li>
<li>编译安装时配置</li>
</ol>
<h5 id="3-初始化配置文件"><a href="#3-初始化配置文件" class="headerlink" title="3 初始化配置文件"></a>3 初始化配置文件</h5><h6 id="1-加载顺序"><a href="#1-加载顺序" class="headerlink" title="1 加载顺序"></a>1 加载顺序</h6><ol>
<li><code>mysqld --help --verbose | grep my.cnf</code><ol>
<li>查看配置文件加载顺序</li>
<li>默认情况下，MySQL启动时，会依序读取配置文件，如果有重复选项，会以最后一个文件设置的为准</li>
</ol>
</li>
<li><code>--defaults-file=</code><ul>
<li>如果启动时手动配置了配置文件，则默认配置文件都不读取。</li>
</ul>
</li>
</ol>
<h6 id="2-格式"><a href="#2-格式" class="headerlink" title="2 格式"></a>2 格式</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[module]</span><br><span class="line">key=value</span><br></pre></td></tr></table></figure>
<ul>
<li>module<ol>
<li>服务端<ol>
<li><code>[mysqld]</code></li>
<li><code>[mysqld_safe]</code></li>
<li><code>[server]</code><ul>
<li>包括服务端所有</li>
</ul>
</li>
</ol>
</li>
<li>客户端<ol>
<li><code>[mysql]</code></li>
<li><code>[mysqladmin]</code></li>
<li><code>[mysqldump]</code></li>
<li><code>[client]</code><ul>
<li>包括客户端所有</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h6 id="3-样板"><a href="#3-样板" class="headerlink" title="3 样板"></a>3 样板</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -----------------服务端配置-------------------------</span><br><span class="line">[mysqld]</span><br><span class="line"># 管理用户</span><br><span class="line">user=mysql</span><br><span class="line"># 软件安装目录</span><br><span class="line">basedir=/app/mysql</span><br><span class="line"># 数据目录</span><br><span class="line">datadir=/data/mysql/data</span><br><span class="line"># 服务端保存 socket 文件路径</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line"># 端口号</span><br><span class="line">port=3306</span><br><span class="line"># 服务器id号 1~65535</span><br><span class="line">server_id=6</span><br><span class="line"># -----------------客户端配置-------------------------</span><br><span class="line">[mysql]</span><br><span class="line"># 客户端登录时寻找 socket 文件路径 </span><br><span class="line">socket=/tmp/mysql.sock</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Windows"><a href="#2-2-Windows" class="headerlink" title="2.2 Windows"></a>2.2 Windows</h2><h3 id="1-配置环境变量"><a href="#1-配置环境变量" class="headerlink" title="1 配置环境变量"></a>1 配置环境变量</h3><h3 id="2-在MySql目录下创建-ini-配置文件"><a href="#2-在MySql目录下创建-ini-配置文件" class="headerlink" title="2 在MySql目录下创建 .ini 配置文件"></a>2 在MySql目录下创建 <code>.ini</code> 配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 服务端配置</span><br><span class="line">[mysqld] </span><br><span class="line">basedir =</span><br><span class="line">datadir =</span><br><span class="line">port = 3306</span><br><span class="line">character-set-server=utf8mb4 // 1</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8mb4 // 2</span><br></pre></td></tr></table></figure>
<ul>
<li>配置1 与 配置12的结果对比<br><img src="https://gitee.com/3noanswer/npics/raw/master/SQL/%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE1.png" alt=""><br><img src="https://gitee.com/3noanswer/npics/raw/master/SQL/%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE2.png" alt=""></li>
</ul>
<h3 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3 初始化"></a>3 初始化</h3><ol>
<li><code>mysqld --initialize --console</code><ul>
<li>随机密码，并在控制台显示密码</li>
</ul>
</li>
<li><code>mysqld --initialize-insecure</code><ul>
<li>无密码</li>
</ul>
</li>
</ol>
<h3 id="4-mysql-服务"><a href="#4-mysql-服务" class="headerlink" title="4 mysql 服务"></a>4 mysql 服务</h3><ol>
<li><code>mysqld --install</code><ul>
<li>安装服务</li>
</ul>
</li>
<li><code>net start mysql</code><ul>
<li>启动服务</li>
</ul>
</li>
<li><code>net stop mysql</code><ul>
<li>停止服务</li>
</ul>
</li>
<li><code>mysqld remove</code> / <code>sc delete mysql</code><ul>
<li>删除服务</li>
</ul>
</li>
</ol>
<h2 id="2-3-修改用户密码"><a href="#2-3-修改用户密码" class="headerlink" title="2.3 修改用户密码"></a>2.3 修改用户密码</h2><ol>
<li><code>mysqladmin -u用户名 -p[旧密码] password 新密码</code><ul>
<li>不需登录</li>
<li>旧密码可以写在命令中，也可以回车后输入</li>
</ul>
</li>
<li><code>alter user &#39;用户名&#39; @&#39;localhost&#39; identified by &#39;新密码&#39;</code><ul>
<li>需要登录</li>
</ul>
</li>
<li>忘记 root 密码<ol>
<li>关闭数据库</li>
<li>维护模式启动数据库<ul>
<li><code>mysqld_safe --skip-grant-tables --skip-networking &amp;</code></li>
</ul>
</li>
<li>登录并修改密码<ol>
<li><code>alter user &#39;root&#39; @&#39;localhost&#39; identified by &#39;新密码&#39;</code></li>
<li><code>flush privileges</code><ul>
<li>如果修改密码报错，则刷新权限</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="三-MySQL-的连接"><a href="#三-MySQL-的连接" class="headerlink" title="三 MySQL 的连接"></a>三 MySQL 的连接</h1><h2 id="3-1-C-S-模型（客户端-amp-服务端）"><a href="#3-1-C-S-模型（客户端-amp-服务端）" class="headerlink" title="3.1 C/S 模型（客户端 &amp; 服务端）"></a>3.1 C/S 模型（客户端 &amp; 服务端）</h2><ol>
<li>使用mysql，需要安装服务端</li>
<li>连接访问服务器，需要通过客户端</li>
</ol>
<h2 id="3-2-客户端"><a href="#3-2-客户端" class="headerlink" title="3.2 客户端"></a>3.2 客户端</h2><h3 id="1-MySQL自带的命令行工具-mysql-exe"><a href="#1-MySQL自带的命令行工具-mysql-exe" class="headerlink" title="1 MySQL自带的命令行工具 mysql.exe"></a>1 MySQL自带的命令行工具 <code>mysql.exe</code></h3><h4 id="1-连接方式"><a href="#1-连接方式" class="headerlink" title="1 连接方式"></a>1 连接方式</h4><ol>
<li>TCP/IP 方式（远程 本地）<ul>
<li><code>mysql -uuser -p[password] [-h Host] [-Pport]</code></li>
</ul>
</li>
<li>Socket 方式（本地）<ul>
<li><code>mysql -uuser -p[password] [-S /tmp/mysql.sock]</code></li>
</ul>
</li>
</ol>
<h4 id="2-myql-命令"><a href="#2-myql-命令" class="headerlink" title="2 myql 命令"></a>2 myql 命令</h4><ul>
<li><code>mysql [OPTION]</code><ul>
<li><code>OPTION</code><ul>
<li><code>-u</code></li>
<li><code>-p</code></li>
<li><code>-h</code></li>
<li><code>-P</code></li>
<li><code>-S</code></li>
<li><code>-e &quot;sql&quot;</code><ul>
<li>免交互执行命令（即不连接数据库）</li>
</ul>
</li>
<li><code>&lt; 脚本路径</code><ul>
<li>导入 sql 脚本</li>
</ul>
</li>
<li><code>-prompt 提示符</code><ul>
<li>定义 mysql 提示符，默认为 <code>mysql&gt;</code></li>
<li><code>\D</code>：完整日期</li>
<li><code>\d</code>：当前数据库</li>
<li><code>\h</code>：服务器名</li>
<li><code>\u</code>：当前用户</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-图形化工具（GUI）"><a href="#2-图形化工具（GUI）" class="headerlink" title="2 图形化工具（GUI）"></a>2 图形化工具（GUI）</h3><table>
<thead>
<tr>
<th align="center">软件</th>
<th align="center">windows</th>
<th align="center">mac</th>
<th align="center">linux</th>
<th align="center">功能</th>
<th align="center">免费版</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>sequelpro</code></td>
<td align="center">&nbsp;</td>
<td align="center">√</td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center"><code>dbeaver</code></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">&nbsp;</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center"><code>navicat</code></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">强</td>
<td align="center">&nbsp;</td>
</tr>
<tr>
<td align="center"><code>SQLyog</code></td>
<td align="center">√</td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center">强</td>
<td align="center">&nbsp;</td>
</tr>
<tr>
<td align="center"><code>dbForge</code></td>
<td align="center">√</td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center">强</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center"><code>heidisql</code></td>
<td align="center">√</td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center">&nbsp;</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center">* 免费选择跨平台的 dbeaver ，不差钱选择 navicat</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h1 id="四-MySQL-体系结构"><a href="#四-MySQL-体系结构" class="headerlink" title="四 MySQL 体系结构"></a>四 MySQL 体系结构</h1><h2 id="4-1-mysql-实例"><a href="#4-1-mysql-实例" class="headerlink" title="4.1 mysql 实例"></a>4.1 mysql 实例</h2><ol>
<li><code>mysqld</code>（老板）</li>
<li><code>master thread</code>（经理）</li>
<li><code>other thread</code>（员工）</li>
<li><code>预分配内存</code>（办公区）</li>
</ol>
<h2 id="4-2-mysqld-程序结构"><a href="#4-2-mysqld-程序结构" class="headerlink" title="4.2 mysqld 程序结构"></a>4.2 mysqld 程序结构</h2><h3 id="1-连接层"><a href="#1-连接层" class="headerlink" title="1 连接层"></a>1 连接层</h3><ol>
<li>提供连接协议：TCP/IP 、SOCKET</li>
<li>提供验证：用户、密码、IP、Port、SOCKET …</li>
<li>提供专用连接线程：接收用户SQL，返回结果<ul>
<li><code>show processlist</code><ul>
<li>查看连接线程</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="2-SQL-层"><a href="#2-SQL-层" class="headerlink" title="2 SQL 层"></a>2 SQL 层</h3><ol>
<li>接收上层传送的SQL语句</li>
<li>语法验证模块：验证语句语法,是否满足SQL_MODE</li>
<li>语义检查：判断SQL语句的类型（DQL、DML …）</li>
<li>权限检查：用户对库表有没有权限</li>
<li>解析器：语句执行前进行预处理，生成解析树(执行计划)，说白了就是生成多种执行方案</li>
<li>优化器：根据解析器得出的多种执行计划，进行判断，选择最优的执行计划<ul>
<li>代价模型：资源（CPU IO MEM）的耗损评估性能好坏</li>
</ul>
</li>
<li>执行器：根据最优执行计划，执行SQL语句，产生执行结果（在磁盘上）</li>
<li>提供查询缓存（默认没开启）：会使用redis tair替代查询缓存功能</li>
<li>提供日志记录（默认没开启）：二进制日志 <code>binlog</code> 、审计日志、通用日志 …</li>
</ol>
<h3 id="3-存储引擎层"><a href="#3-存储引擎层" class="headerlink" title="3 存储引擎层"></a>3 存储引擎层</h3><ol>
<li>根据SQL层执行的结果，从磁盘上拿数据</li>
<li>将16进制的磁盘数据，返回给 SQL 层结构化成表</li>
<li>由连接层的专用线程返回给用户</li>
</ol>
<h2 id="4-3-MySQL-逻辑存储结构"><a href="#4-3-MySQL-逻辑存储结构" class="headerlink" title="4.3 MySQL 逻辑存储结构"></a>4.3 MySQL 逻辑存储结构</h2><ol>
<li>库（database）<ol>
<li>库名</li>
<li>库属性（字符集，校对集(排序规则)）</li>
</ol>
</li>
<li>表（table）<ol>
<li>表名</li>
<li>表属性（存储引擎，字符集，校对集(排序规则)）</li>
</ol>
</li>
<li>列（column）/ 字段（field） <ol>
<li>列名</li>
<li>列属性（数据类型，约束，…）</li>
</ol>
</li>
<li>行（row）/ 记录（record）</li>
</ol>
<h2 id="4-4-MySQL-物理存储结构"><a href="#4-4-MySQL-物理存储结构" class="headerlink" title="4.4 MySQL 物理存储结构"></a>4.4 MySQL 物理存储结构</h2><ol>
<li>库（目录）</li>
<li>表<ol>
<li><code>MyISAM</code><ul>
<li><code>.frm</code> ：存储表结构（列名，列属性）</li>
<li><code>.MYD</code> ：存储数据记录</li>
<li><code>.MYI</code> ：存储索引</li>
</ul>
</li>
<li><code>InnoDB</code><ul>
<li><code>.frm</code> ：存储表结构（列名，列属性）</li>
<li><code>.ibd</code> ：存储数据记录和索引</li>
<li><code>.opt</code> ：存储库属性</li>
<li><code>ibdata1</code> ：数据字段信息</li>
</ul>
</li>
</ol>
</li>
<li>InnoDB，一般情况下（非分区表）<ol>
<li>段：一个表就是一个段，一个段由多个区构成</li>
<li>区：一个区由64个连续的页构造，1M 大小（ <code>64*16=1024</code> ）</li>
<li>页：一个页大小为 16 kb</li>
</ol>
</li>
</ol>
<h1 id="五-用户-amp-权限"><a href="#五-用户-amp-权限" class="headerlink" title="五 用户 &amp; 权限"></a>五 用户 &amp; 权限</h1><h2 id="5-1-用户"><a href="#5-1-用户" class="headerlink" title="5.1 用户"></a>5.1 用户</h2><h3 id="1-用户定义"><a href="#1-用户定义" class="headerlink" title="1 用户定义"></a>1 用户定义</h3><ul>
<li><code>user@&#39;Host&#39;</code><ul>
<li><code>Host</code>（白名单）<ul>
<li><code>localhost</code></li>
<li><code>127.0.0.1</code></li>
<li><code>%</code><ul>
<li>任意网段</li>
</ul>
</li>
<li><code>10.0.0.%</code><ul>
<li><code>10.0.0.0~10.0.0.255</code></li>
</ul>
</li>
<li><code>10.0.0.5%</code><ul>
<li><code>10.0.0.50~10.0.0.59</code></li>
</ul>
</li>
<li><code>10.0.0.0/255.255.255.0</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-用户管理"><a href="#2-用户管理" class="headerlink" title="2 用户管理"></a>2 用户管理</h3><h4 id="1-查询用户"><a href="#1-查询用户" class="headerlink" title="1 查询用户"></a>1 查询用户</h4><ul>
<li><code>select user,host,authentication_string from mysql.user</code><ul>
<li>查询用户名，主机，密码</li>
<li>用户信息存储在数据库 <code>mysql</code> 中 的 <code>user</code> 表</li>
</ul>
</li>
</ul>
<h4 id="2-创建用户"><a href="#2-创建用户" class="headerlink" title="2 创建用户"></a>2 创建用户</h4><ul>
<li><code>create user user@&#39;Host&#39; [identified by &#39;password&#39;]</code></li>
</ul>
<h4 id="3-删除用户"><a href="#3-删除用户" class="headerlink" title="3 删除用户"></a>3 删除用户</h4><ul>
<li><code>drop user user@&#39;Host&#39;</code> </li>
</ul>
<h2 id="5-2-权限"><a href="#5-2-权限" class="headerlink" title="5.2 权限"></a>5.2 权限</h2><h3 id="1-权限列表"><a href="#1-权限列表" class="headerlink" title="1 权限列表"></a>1 权限列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT，INSERT，UPDATE，DELETE，CREATE，DROP，ALTER，SHOW DATABASES，CREATE USER，CREATE TEMPORARY TABLES，</span><br><span class="line">RELOAD，SHUTDOWN，PROCESS，FILE，REFERENCE，INDEX，SUPER，EXECUTE，REPLICATION，SLAVE，REPLICATION，CLIENT，</span><br><span class="line">EVENT，TRIGGER，LOCK TABLES，CREATE VIEW，SHOW VIEW，CREATE ROUTINE，ALTER ROUTINE，CREATE TABLESPACE，</span><br></pre></td></tr></table></figure>
<ol>
<li><code>ALL privileges</code><ul>
<li>所有权限</li>
</ul>
</li>
<li><code>with grant option</code><ul>
<li>可以给别的用户授权，超级管理员才具备</li>
</ul>
</li>
</ol>
<h3 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2 权限管理"></a>2 权限管理</h3><h4 id="1-查看权限"><a href="#1-查看权限" class="headerlink" title="1 查看权限"></a>1 查看权限</h4><ul>
<li><code>show grants for user@&#39;Host&#39;</code></li>
</ul>
<h4 id="2-授权"><a href="#2-授权" class="headerlink" title="2 授权"></a>2 授权</h4><ul>
<li><code>grant 权限 on 目标 to 用户 [identified by &#39;password&#39;] [with grant option]</code><ul>
<li>权限<ol>
<li><code>ALL privileges</code></li>
<li>权限列表，以逗号分隔</li>
</ol>
</li>
<li>目标<ol>
<li><code>*.*</code><ul>
<li>所有数据库的所有表</li>
</ul>
</li>
<li><code>database.*</code><ul>
<li>指定数据库的所有表</li>
</ul>
</li>
<li><code>database.table</code><ul>
<li>指定数据库的指定表</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="3-回收权限"><a href="#3-回收权限" class="headerlink" title="3 回收权限"></a>3 回收权限</h4><ul>
<li><code>revoke 权限 on 目标 from user@&#39;Host&#39;</code></li>
</ul>
<h1 id="六-MySQL-内置命令"><a href="#六-MySQL-内置命令" class="headerlink" title="六 MySQL 内置命令"></a>六 MySQL 内置命令</h1><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>help</code></td>
<td>打印帮助</td>
</tr>
<tr>
<td><code>\c</code></td>
<td>放弃本条语句，类似 <code>ctrl + c</code></td>
</tr>
<tr>
<td><code>quit</code> <code>exit</code> <code>ctrl+d</code> <code>\q</code></td>
<td>退出</td>
</tr>
<tr>
<td><code>\G</code></td>
<td>竖形显示数据</td>
</tr>
<tr>
<td><code>source 脚本路径</code></td>
<td>导入SQL脚本</td>
</tr>
<tr>
<td><code>tee 路径</code></td>
<td>将输入的sql语句存储到本地</td>
</tr>
<tr>
<td><code>prompt 提示符</code></td>
<td>定义 mysql 提示符，默认为 <code>mysql&gt;</code></td>
</tr>
<tr>
<td><code>delimiter 符号</code></td>
<td>定义结束符，默认为<code>;</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>DB</category>
        <category>MySql</category>
      </categories>
  </entry>
  <entry>
    <title>Git</title>
    <url>/anyeansan.github.io/2020/03/30/Git/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一  概述"></a>一  概述</h1><ul>
<li>开源的分布式版本控制系统</li>
</ul>
<h1 id="二-配置"><a href="#二-配置" class="headerlink" title="二 配置"></a>二 配置</h1><h2 id="2-1-作用域"><a href="#2-1-作用域" class="headerlink" title="2.1 作用域"></a>2.1 作用域</h2><ol>
<li><code>git config --local</code><ul>
<li>对当前仓库有效（默认）</li>
</ul>
</li>
<li><code>git config --global</code><ul>
<li>对当前用户所有仓库有效</li>
</ul>
</li>
<li><code>git config --system</code><ul>
<li>对系统所有登录用户有效</li>
</ul>
</li>
</ol>
<h2 id="2-2-增删改查"><a href="#2-2-增删改查" class="headerlink" title="2.2 增删改查"></a>2.2 增删改查</h2><ol>
<li><code>git config --list</code><ul>
<li>查看所有配置信息</li>
</ul>
</li>
<li><code>git config --global key value</code><ul>
<li>增加配置</li>
</ul>
</li>
<li><code>git config   --global --unset  key</code><ul>
<li>删除配置</li>
</ul>
</li>
<li><code>git config --global --replace-all key value</code><ul>
<li>修改所有匹配 key 的 value</li>
</ul>
</li>
</ol>
<h2 id="2-3-配置用户和邮箱"><a href="#2-3-配置用户和邮箱" class="headerlink" title="2.3 配置用户和邮箱"></a>2.3 配置用户和邮箱</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;Your Email@example.com&quot;</span><br><span class="line">git config --global color.ui true # 语法高亮</span><br></pre></td></tr></table></figure>

<h1 id="三-初始化仓库"><a href="#三-初始化仓库" class="headerlink" title="三 初始化仓库"></a>三 初始化仓库</h1><h2 id="3-1-初始化"><a href="#3-1-初始化" class="headerlink" title="3.1 初始化"></a>3.1 初始化</h2><ol>
<li><code>git init</code><ul>
<li>将所在目录变成 Git 管理的仓库</li>
<li>Git 仓库中会有一个隐藏的 <code>.git</code> 目录</li>
</ul>
</li>
<li><code>git init project_name</code><ul>
<li>在所在目录下创建一个指定名称的 Git 管理的仓库目录</li>
</ul>
</li>
</ol>
<h2 id="3-2-git-目录结构"><a href="#3-2-git-目录结构" class="headerlink" title="3.2 .git 目录结构"></a>3.2 <code>.git</code> 目录结构</h2><ol>
<li><code>branchs</code><ul>
<li>分支目录</li>
</ul>
</li>
<li><code>config</code><ul>
<li>本仓库的配置文件</li>
</ul>
</li>
<li><code>HEAD</code><ul>
<li>指向当前分支</li>
</ul>
</li>
<li><code>description</code><ul>
<li>仓库的描述信息，仅供 GitWeb 程序使用</li>
</ul>
</li>
<li><code>hooks</code><ul>
<li>包含客户端或服务端的钩子脚本（hook scripts）</li>
</ul>
</li>
<li><code>info</code><ul>
<li>包含一个全局性排除（global exclude）文件， 用以放置那些不希望被记录在 <code>.gitignore</code> 文件中的忽略模式（ignored patterns）</li>
</ul>
</li>
<li><code>refs</code><ol>
<li><code>heads</code><ul>
<li>目录下每个文件代表一个本地分支，用来保存该分支最新 <code>commit_id</code></li>
</ul>
</li>
<li><code>remotes</code><ul>
<li>目录下每个目录代表一个远程仓库，远程仓库目录下每一个文件代表一个远程分支，保存远程仓库该分支的最新 <code>commit_id</code></li>
</ul>
</li>
<li><code>tags</code></li>
</ol>
</li>
<li><code>objects</code><ul>
<li>存储所有数据内容，<code>commit_id</code> 哈希值共 40 位，前 2 位作为目录名，后 38 为作为文件名</li>
</ul>
</li>
<li><code>index</code><ul>
<li>暂存区（stage）</li>
</ul>
</li>
</ol>
<h1 id="四-Git-原理"><a href="#四-Git-原理" class="headerlink" title="四 Git 原理"></a>四 Git 原理</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ol>
<li>Git 的核心部分是一个简单的键值对数据库（key-value data store）</li>
<li>可以向 Git 仓库中插入任意类型的内容，它会返回一个唯一的键，通过该键可以在任意时刻再次取回该内容</li>
</ol>
<h2 id="4-2-存取数据"><a href="#4-2-存取数据" class="headerlink" title="4.2 存取数据"></a>4.2 存取数据</h2><h3 id="1-存"><a href="#1-存" class="headerlink" title="1 存"></a>1 存</h3><ul>
<li><code>git bash-object</code><ol>
<li>可将任意数据保存于 <code>.git/objects</code> 目录（即 对象数据库），并返回指向该数据对象的唯一的键</li>
<li>键<ul>
<li>长度为 40 个字符的校验和，这是一个 SHA-1 哈希值（将待存储的数据外加一个头部信息（header）一起做 SHA-1 校验运算而得的校验和）</li>
</ul>
</li>
<li>校验和的前 2 个字符作为<code>./git/objects/子目录名</code>，余下的 38 个字符则用作文件名</li>
</ol>
</li>
</ul>
<ol>
<li><code>git hash-object -w FILE</code><ul>
<li>存储文件数据</li>
<li><code>-w</code><ul>
<li>指示该命令不要只返回键，还要将该对象写入数据库中</li>
</ul>
</li>
</ul>
</li>
<li><code>git hash-object -w --stdin</code><ul>
<li>读取标准输入中的数据并存储</li>
</ul>
</li>
</ol>
<h3 id="2-取"><a href="#2-取" class="headerlink" title="2 取"></a>2 取</h3><ul>
<li><code>git cat-file [OPTION] commit_id</code><ul>
<li><code>OPTION</code><ul>
<li><code>-p</code><ul>
<li>查看文件内容</li>
</ul>
</li>
<li><code>-t</code><ul>
<li>查看文件类型</li>
</ul>
</li>
<li><code>-s</code><ul>
<li>查看文件大小</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-3-Git-对象"><a href="#4-3-Git-对象" class="headerlink" title="4.3 Git 对象"></a>4.3 Git 对象</h2><h3 id="1-数据对象（block-object）"><a href="#1-数据对象（block-object）" class="headerlink" title="1 数据对象（block object）"></a>1 数据对象（block object）</h3><ol>
<li>数据对象类似 Linux 中的 inode 或文件内容</li>
<li>只存储文件内容，不存储文件名</li>
</ol>
<h3 id="2-树对象（tree-object）"><a href="#2-树对象（tree-object）" class="headerlink" title="2 树对象（tree object）"></a>2 树对象（tree object）</h3><ol>
<li>树对象类似 Linux 中的目录项</li>
<li>一个树对象包含了一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息</li>
</ol>
<h3 id="3-提交对象（commit-object）"><a href="#3-提交对象（commit-object）" class="headerlink" title="3 提交对象（commit object）"></a>3 提交对象（commit object）</h3><ol>
<li>一个顶层树对象，代表当前项目快照</li>
<li>可能存在的父提交对象</li>
<li>作者/提交者信息（依据你的 user.name 和 user.email 配置来设定，外加一个时间戳）</li>
<li>留空一行，最后是提交注释</li>
</ol>
<h3 id="4-标签对象（tag-object）"><a href="#4-标签对象（tag-object）" class="headerlink" title="4 标签对象（tag object）"></a>4 标签对象（tag object）</h3><ol>
<li>非常类似于提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针</li>
<li>区别在于，标签对象通常指向一个提交对象，而不是一个树对象。 它像是一个永不移动的分支引用——永远指向同一个提交对象，只不过给这个提交对象加上一个更友好的名字罢了。</li>
</ol>
<h2 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4 总结"></a>4.4 总结</h2><ol>
<li>每次我们运行 <code>git add</code> 和 <code>git commit</code> 命令时，Git 所做的工作实质就是将被改写的文件保存为数据对象， 更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象</li>
<li>这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 <code>.git/objects</code> 目录下</li>
</ol>
<h2 id="4-5"><a href="#4-5" class="headerlink" title="4.5 ?"></a>4.5 ?</h2><ul>
<li>工作区的文件分为两种<ol>
<li>未暂存（新增文件）<ol>
<li>删、改、重命名<ul>
<li>随意操作无影响，之后 <code>git add</code> 变成已暂存</li>
</ul>
</li>
</ol>
</li>
<li>已暂存<ol>
<li>改<ul>
<li>需要重新 <code>git add</code>，之后 <code>git commit</code></li>
</ul>
</li>
<li>删除<ul>
<li>需要将工作区和暂存区的都删除 <code>git rm</code>，之后 <code>git commit</code></li>
</ul>
</li>
<li>重命名<ol>
<li><code>git mv</code> 直接 <code>git commit</code></li>
<li><code>mv</code> 相当于删除和新增文件（未暂存）<ol>
<li><code>git rm</code></li>
<li><code>git add</code></li>
<li><code>git commit</code></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h1 id="五-Git-工作流程"><a href="#五-Git-工作流程" class="headerlink" title="五 Git 工作流程"></a>五 Git 工作流程</h1><h2 id="5-1-相关概念"><a href="#5-1-相关概念" class="headerlink" title="5.1 相关概念"></a>5.1 相关概念</h2><ol>
<li><code>Workspace</code><ul>
<li>工作区，仓库中除了 <code>.git</code> 目录的其它区域</li>
</ul>
</li>
<li><code>Index / Stage</code><ul>
<li>暂存区，即 <code>.git/index</code> 文件</li>
</ul>
</li>
<li><code>Repository</code><ul>
<li>本地仓库，即 <code>.git/objects</code> 目录，HEAD指向最新放入仓库的版本</li>
</ul>
</li>
<li><code>Remote</code><ul>
<li>远程仓库</li>
</ul>
</li>
</ol>
<h2 id="5-2-文件状态"><a href="#5-2-文件状态" class="headerlink" title="5.2 文件状态"></a>5.2 文件状态</h2><ol>
<li><code>Untracked</code><ul>
<li>未追踪状态，工作区中未被 git 仓库管理的文件，没有添加到暂存区</li>
</ul>
</li>
<li><code>Staged</code><ul>
<li>暂存状态，工作区中未被 git 仓库管理的文件，添加到了暂存区</li>
</ul>
</li>
<li><code>Unmodify</code><ul>
<li>未修改状态，工作区中已被 git 仓库管理的文件，没有任何修改与 git 仓库中一致</li>
</ul>
</li>
<li><code>Modified</code><ul>
<li>已修改状态，工作区中已被 git 仓库管理的文件，有改动与 git 仓库中不一致</li>
</ul>
</li>
</ol>
<h2 id="5-3-命令"><a href="#5-3-命令" class="headerlink" title="5.3 命令"></a>5.3 命令</h2><h3 id="1-git-status"><a href="#1-git-status" class="headerlink" title="1 git status"></a>1 git status</h3><ol>
<li><code>git status</code><ul>
<li>查看仓库状态</li>
</ul>
</li>
</ol>
<h3 id="2-git-add"><a href="#2-git-add" class="headerlink" title="2 git add"></a>2 git add</h3><ol>
<li><code>git add FILE</code><ul>
<li>把文件添加到暂存区，可添加多个，用空格隔开</li>
</ul>
</li>
<li><code>git add -u</code><ul>
<li>把有改动的已经被 git 仓库管理的文件添加到暂存区</li>
</ul>
</li>
<li><code>git add .|*</code><ul>
<li>把当前目录所有有改动的文件添加到暂存区（包括新增的）</li>
</ul>
</li>
</ol>
<h3 id="3-git-rm"><a href="#3-git-rm" class="headerlink" title="3 git rm"></a>3 git rm</h3><ol>
<li><code>git rm --cache FILE</code><ul>
<li>从暂存区删除文件，即从暂存区撤回</li>
</ul>
</li>
<li><code>git rm FILE</code><ul>
<li>从暂存区和工作区同时删除文件</li>
</ul>
</li>
</ol>
<h3 id="4-git-commit"><a href="#4-git-commit" class="headerlink" title="4 git commit"></a>4 git commit</h3><ul>
<li><code>git commit [OPTION]</code><ul>
<li>将暂存区文件提交到本地仓库当前分支</li>
<li><code>OPTION</code><ul>
<li><code>-m &quot;message&quot;</code><ul>
<li>提交说明</li>
</ul>
</li>
<li><code>-a</code><ul>
<li>已经被 git 仓库管理的文件，会自动暂存并提交，即相当于 <code>git add</code></li>
</ul>
</li>
<li><code>--amend</code><ul>
<li>将暂存区中的文件提交。 </li>
<li>如果自上次提交以来还未做任何修改，即暂存区和本地仓库一致，那么快照会保持不变，所修改的只是提交信息</li>
<li>可以用来修改上一次提交信息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-git-mv"><a href="#5-git-mv" class="headerlink" title="5 git mv"></a>5 git mv</h3><ol>
<li><code>git mv oldName newName</code><ul>
<li>将工作区和暂存区的文件同时重命名</li>
</ul>
</li>
<li><code>mv</code> 和 <code>git mv</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git mv a a.txt</span><br><span class="line">相当于</span><br><span class="line">mv a a.txt</span><br><span class="line">git rm a</span><br><span class="line">git add a.txt</span><br></pre></td></tr></table></figure>
<ol>
<li>使用 <code>mv</code> 时，相当于删除了原名称文件，创建了新名称文件</li>
<li>此时需要删除暂存区中的原名称文件，然后把新名称文件添加到暂存区</li>
</ol>
</li>
</ol>
<h3 id="6-git-diff"><a href="#6-git-diff" class="headerlink" title="6 git diff"></a>6 git diff</h3><ol>
<li><code>git diff</code><ul>
<li>比较工作区和暂存区的差异</li>
</ul>
</li>
<li><code>git diff --cached</code><ul>
<li>比较暂存区和本地仓库（最新版本HEAD）的差异</li>
</ul>
</li>
<li><code>git diff HEAD</code><ul>
<li>比较工作区和本地仓库（最新版本HEAD）的差异</li>
</ul>
</li>
<li><code>git diff commit_id</code><ul>
<li>比较工作区和本地仓库（指定 <code>commit_id</code> 的版本）的差异</li>
</ul>
</li>
<li><code>git diff --cached commit_id</code><ul>
<li>比较暂存区和本地仓库（指定 <code>commit_id</code> 的版本）的差异</li>
</ul>
</li>
<li><code>git diff commit_id commit_id</code><ul>
<li>比较本地仓库中两个 <code>commit-id</code> 版本间的差异</li>
</ul>
</li>
</ol>
<h3 id="7-git-log"><a href="#7-git-log" class="headerlink" title="7 git log"></a>7 git log</h3><ol>
<li><code>git log [OPTION]</code><ul>
<li>查看所有历史提交信息</li>
<li><code>OPTION</code><ul>
<li><code>-n</code><ul>
<li>显示最近 n 条</li>
</ul>
</li>
<li><code>-p</code><ul>
<li>显示每次提交详细的变化</li>
</ul>
</li>
<li><code>--oneline</code><ul>
<li>一行显示（显示8位哈希值和提交message）</li>
</ul>
</li>
<li><code>--decorate</code><ul>
<li>显示分支指针当前指向 </li>
</ul>
</li>
<li><code>--pretty=</code><ul>
<li>使用其他格式显示</li>
<li><code>oneline</code><ul>
<li>一行显示（显示完整哈希值和提交message）</li>
</ul>
</li>
<li><code>short</code></li>
<li><code>full</code></li>
<li><code>fuller</code></li>
<li><code>format</code></li>
<li><code>......</code></li>
</ul>
</li>
<li><code>--graph</code><ul>
<li>显示分支合并图形</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>gitk</code><ul>
<li>图形界面</li>
<li>相当于 <code>git log</code> 命令的可视化版本</li>
</ul>
</li>
</ol>
<h3 id="8-git-reflog"><a href="#8-git-reflog" class="headerlink" title="8 git reflog"></a>8 git reflog</h3><ol>
<li><code>git reflog</code><ul>
<li>记录着每一次命令及其对应id</li>
<li><code>git log</code> 只会显示 HEAD 及其之前的 <code>commit_id</code>，回溯之后，可以用此命令查询 HEAD 之后的 <code>commit_id</code></li>
</ul>
</li>
</ol>
<h3 id="9-git-reset"><a href="#9-git-reset" class="headerlink" title="9 git reset"></a>9 git reset</h3><ol>
<li><code>git reset  [OPTION] commit_id</code><ul>
<li>回溯到指定 <code>commit_id</code> 的版本</li>
<li><code>OPTION</code><ul>
<li><code>--mixed</code>（默认）<ul>
<li>保留工作区，重置暂存区和本地仓库</li>
</ul>
</li>
<li><code>--soft</code><ul>
<li>保留工作区和暂存区，重置本地仓库</li>
</ul>
</li>
<li><code>--hard</code><ul>
<li>重置工作区、暂存区和本地仓库</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>版本说明<ul>
<li><code>HEAD</code><ul>
<li>当前版本</li>
</ul>
</li>
<li><code>HEAD^</code><ul>
<li>上个版本</li>
</ul>
</li>
<li><code>HEAD^^</code><ul>
<li>上上个版本</li>
</ul>
</li>
<li><code>HEAD-100</code><ul>
<li>上100个版本</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="10-git-checkout"><a href="#10-git-checkout" class="headerlink" title="10 git checkout"></a>10 git checkout</h3><ol>
<li><code>git checkout branch_name</code><ul>
<li>切换分支</li>
</ul>
</li>
<li><code>git checkout -- FILE</code><ul>
<li>从暂存区检出文件覆盖工作区</li>
</ul>
</li>
</ol>
<h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4><ol>
<li>工作区没有 <code>git add</code> 到暂存区，即暂存区没有改变<ol>
<li><code>git checkout -- FILE</code><ul>
<li>直接从暂存区检出覆盖即可</li>
</ul>
</li>
</ol>
</li>
<li>工作区 <code>git add</code> 到暂存区，修改了暂存区<ol>
<li><code>git reset HEAD FILE</code><ul>
<li>默认 <code>mixed</code> 会重置暂存区和本地仓库</li>
<li>即恢复暂存区</li>
</ul>
</li>
<li><code>git checkout -- FILE</code><ul>
<li>从暂存区检出覆盖</li>
</ul>
</li>
</ol>
</li>
</ol>
<h1 id="六-分支"><a href="#六-分支" class="headerlink" title="六 分支"></a>六 分支</h1><h2 id="6-1-分支操作"><a href="#6-1-分支操作" class="headerlink" title="6.1 分支操作"></a>6.1 分支操作</h2><h3 id="1-查看分支"><a href="#1-查看分支" class="headerlink" title="1 查看分支"></a>1 查看分支</h3><ul>
<li><code>git branch [OPTION]</code><ul>
<li>显示本地所有分支，当前分支前有 <code>*</code> 号</li>
<li><code>OPTION</code><ul>
<li><code>-r</code><ul>
<li>显示远程所有分支</li>
</ul>
</li>
<li><code>-a</code><ul>
<li>显示本地和远程所有分支</li>
</ul>
</li>
<li><code>-v</code><ul>
<li>显示本地分支及其最后一次提交</li>
</ul>
</li>
<li><code>-vv</code><ul>
<li>显示本地分支及其跟踪的远程分支</li>
</ul>
</li>
<li><code>--merged</code><ul>
<li>显示分支列表中已经合并到当前分支的分支</li>
</ul>
</li>
<li><code>--no-merged</code><ul>
<li>显示分支列表中尚未合并到当前分支的分支</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-创建分支"><a href="#2-创建分支" class="headerlink" title="2 创建分支"></a>2 创建分支</h3><ul>
<li><code>git branch branch_name</code></li>
</ul>
<h3 id="3-切换分支"><a href="#3-切换分支" class="headerlink" title="3 切换分支"></a>3 切换分支</h3><ol>
<li><code>git checkout branch_name</code> 或 <code>git switch branch_name</code>（新）<ul>
<li>切换到指定分支</li>
</ul>
</li>
<li><code>git checkout -b branch_name</code> 或 <code>git switch -c branch_name</code>（新）<ul>
<li>创建并切换到指定分支</li>
</ul>
</li>
</ol>
<h3 id="4-删除分支"><a href="#4-删除分支" class="headerlink" title="4 删除分支"></a>4 删除分支</h3><ol>
<li><code>git branch -d branch_name</code><ul>
<li>删除本地分支</li>
</ul>
</li>
<li><code>git push remote_name --delete branch_name</code><ul>
<li>删除远程分支</li>
</ul>
</li>
</ol>
<h3 id="5-合并分支"><a href="#5-合并分支" class="headerlink" title="5 合并分支"></a>5 合并分支</h3><ul>
<li><code>git merge [--no-ff] branch_name</code><ul>
<li>把指定分支合并到当前分支</li>
<li><code>--no-ff</code>（no fast forward）<ol>
<li>默认使用 <code>fast forward</code> 合并策略，其实就是将当前分支的指针指向了 <code>branch_name</code></li>
<li><code>--no-ff</code> 每次合并都会产生一个新的提交</li>
</ol>
</li>
<li>解决合并冲突<ol>
<li><code>git status</code> 查看冲突信息</li>
<li><code>vim</code> 手动修改冲突文件</li>
<li><code>git add</code></li>
<li><code>git commit</code></li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="6-2-变基（rebase）"><a href="#6-2-变基（rebase）" class="headerlink" title="6.2 变基（rebase）"></a>6.2 变基（rebase）</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code> 以及 <code>rebase</code></li>
<li>将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样，这种操作就叫做 变基</li>
<li>变基可以使提交历史更为线形，简洁，而合并则是保留每一个提交历史</li>
<li><strong>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基</strong></li>
<li><strong>只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作</strong></li>
</ol>
<h3 id="2-变基原理"><a href="#2-变基原理" class="headerlink" title="2 变基原理"></a>2 变基原理</h3><ol>
<li>首先找到两个分支（要变基的分支 <code>dev</code> 和目标基底分支 <code>master</code>）的最近共同祖先</li>
<li>然后对比 <code>dev</code> 分支相对于该祖先的历次提交，提取相应的修改并存为临时文件</li>
<li>将 <code>dev</code> 分支指向 <code>master</code> 分支的最后一次提交</li>
<li>在 <code>master</code> 的最后一次提交，依序应用之前的临时文件，最后生成一个新的提交</li>
<li>之后将 <code>dev</code> 分支快速合并到 <code>master</code></li>
</ol>
<h3 id="3-命令"><a href="#3-命令" class="headerlink" title="3 命令"></a>3 命令</h3><h4 id="1-变基命令"><a href="#1-变基命令" class="headerlink" title="1 变基命令"></a>1 变基命令</h4><ol>
<li><code>git rebase base_branch [re_branch]</code><ul>
<li>将 <code>re_branch</code> 分支变基到 <code>base_branch</code> 分支</li>
<li><code>base_branch</code><ul>
<li>目标基底分支</li>
</ul>
</li>
<li><code>re_branch</code><ul>
<li>要变基的分支，省略则表示当前分支</li>
</ul>
</li>
</ul>
</li>
<li><code>git rebase --onto base_branch branch re_branch</code><ol>
<li>首先找出 <code>re_branch</code> 分支与 <code>branch</code> 分支的分歧之后的提交</li>
<li>然后将这些提交变基到 <code>base_branch</code> 上</li>
</ol>
</li>
</ol>
<h4 id="2-变基过程中的命令"><a href="#2-变基过程中的命令" class="headerlink" title="2 变基过程中的命令"></a>2 变基过程中的命令</h4><ol>
<li><code>git rebase --skip</code><ul>
<li>跳过当前冲突</li>
</ul>
</li>
<li><code>git rebase --abort</code><ul>
<li>退出rebase模式</li>
</ul>
</li>
<li><code>git add</code><ul>
<li>解决冲突后使用 <code>git add</code> 表示冲突已经解决</li>
</ul>
</li>
<li><code>git rebase --continue</code><ul>
<li>解决冲突并 <code>git add</code> 之后，表示继续接下来的操作</li>
</ul>
</li>
</ol>
<h3 id="4-修改提交"><a href="#4-修改提交" class="headerlink" title="4 修改提交"></a>4 修改提交</h3><h4 id="1-合并多个连续提交"><a href="#1-合并多个连续提交" class="headerlink" title="1 合并多个连续提交"></a>1 合并多个连续提交</h4><ol>
<li><code>git rebase -i commit_id</code><ul>
<li><code>commit-id</code>为所有要合的commit的前一个commit-id</li>
<li>会进入交互界面</li>
</ul>
</li>
<li>要合成的commit第一个<code>pick</code>不变（要合成到这个提交上），剩下的改为<code>s</code>，<code>pick s s s ...</code></li>
<li>进入提交信息修改界面</li>
</ol>
<h4 id="2-合并多个间隔提交"><a href="#2-合并多个间隔提交" class="headerlink" title="2 合并多个间隔提交"></a>2 合并多个间隔提交</h4><ol>
<li><code>git rebase -i commit_id</code></li>
<li>手动调整commit位置，<code>pick s s s ...</code></li>
<li><code>git rebase --continue</code><ul>
<li>进入commit信息修改页面</li>
</ul>
</li>
</ol>
<h4 id="3-修改旧提交的-message"><a href="#3-修改旧提交的-message" class="headerlink" title="3 修改旧提交的 message"></a>3 修改旧提交的 message</h4><ul>
<li><code>git rebase -i commit_id</code><ul>
<li>进入交互界面，使用相应命令</li>
<li><code>commit_id</code><ul>
<li>要修改的提交的父提交的 <code>commit_id</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-3-贮藏（stash）"><a href="#6-3-贮藏（stash）" class="headerlink" title="6.3 贮藏（stash）"></a>6.3 贮藏（stash）</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>当需要切换分支而又不想现在提交时，可以贮藏，然后恢复</li>
<li>只能贮藏已追踪和非 <code>.gitignore</code> 的文件 </li>
</ol>
<h3 id="2-添加贮藏"><a href="#2-添加贮藏" class="headerlink" title="2 添加贮藏"></a>2 添加贮藏</h3><ul>
<li><code>git stash [push] [OPTION] [FILE]</code><ul>
<li>将工作区和暂存区的状态存储起来以备将来使用，之后将工作区和暂存区内容重置为最近一次提交后的内容</li>
<li><code>push</code><ul>
<li><code>git stash</code> 是 <code>git stash push</code> 的简写</li>
</ul>
</li>
<li><code>OPTION</code><ul>
<li><code>-m &quot;message&quot;</code><ul>
<li>添加暂存信息</li>
</ul>
</li>
<li><code>-u, --include-untracked</code><ul>
<li>将未追踪文件也贮藏</li>
</ul>
</li>
<li><code>-a, --all</code><ul>
<li>将忽略文件也贮藏</li>
</ul>
</li>
<li><code>-k, --keep-index</code><ul>
<li>表示只重置工作区，不重置暂存区</li>
<li>默认值是 <code>--no-keep-index</code></li>
</ul>
</li>
</ul>
</li>
<li><code>FILE</code><ul>
<li>只贮藏指定文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-查看贮藏"><a href="#3-查看贮藏" class="headerlink" title="3 查看贮藏"></a>3 查看贮藏</h3><ul>
<li><code>git stash list</code></li>
</ul>
<h3 id="4-应用贮藏（恢复）"><a href="#4-应用贮藏（恢复）" class="headerlink" title="4 应用贮藏（恢复）"></a>4 应用贮藏（恢复）</h3><ol>
<li><code>git stash apply [stash_name] [--index]</code><ul>
<li><code>stash_name</code><ul>
<li>省略表示应用最新一个贮藏，可以使用名称指定一个贮藏，如 <code>stash@{2}</code></li>
</ul>
</li>
<li><code>--index</code><ul>
<li>默认应用贮藏时，不会恢复暂存区，<code>--index</code> 表示恢复暂存区</li>
</ul>
</li>
</ul>
</li>
<li><code>git stash pop</code><ol>
<li>用法同 <code>git stash apply</code></li>
<li>区别<ol>
<li><code>git stash apply</code> 应用并保留贮藏</li>
<li><code>git stash pop</code> 应用并删除贮藏</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="5-删除贮藏"><a href="#5-删除贮藏" class="headerlink" title="5 删除贮藏"></a>5 删除贮藏</h3><ol>
<li><code>git stash drop stash_name</code><ul>
<li>删除指定储藏</li>
</ul>
</li>
<li><code>git stash clear</code><ul>
<li>删除所有储藏</li>
</ul>
</li>
</ol>
<h2 id="6-4-追踪分支"><a href="#6-4-追踪分支" class="headerlink" title="6.4 追踪分支"></a>6.4 追踪分支</h2><ol>
<li><code>git checkout -b &lt;本地分支名&gt; &lt;远程主机&gt;/&lt;远程分支名&gt;</code><ul>
<li>创建一个本地分支追踪远程主机的远程分支</li>
</ul>
</li>
<li><code>git checkout --track &lt;远程主机&gt;/&lt;远程分支名&gt;</code><ul>
<li>创建一个与远程分支同名的本地分支来追踪远程主机的远程分支</li>
</ul>
</li>
<li><code>git branch -u &lt;远程主机&gt;/&lt;远程分支名&gt;</code><ul>
<li>设置当前本地分支追踪远程主机的远程分支</li>
<li>当设置好追踪分支后，可以通过 <code>@{upstream}</code> 或 <code>@{u}</code> 快捷方式来引用它</li>
</ul>
</li>
</ol>
<h1 id="七-标签"><a href="#七-标签" class="headerlink" title="七 标签"></a>七 标签</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ol>
<li>类似于别名，因为 <code>commit_id</code> 看不出提交的信息，通过打标签可以更方便识别。</li>
</ol>
<h2 id="7-2-标签分类"><a href="#7-2-标签分类" class="headerlink" title="7.2 标签分类"></a>7.2 标签分类</h2><h3 id="1-轻量标签（lightweight）"><a href="#1-轻量标签（lightweight）" class="headerlink" title="1 轻量标签（lightweight）"></a>1 轻量标签（lightweight）</h3><ol>
<li>轻量标签就是个指向特定提交对象的引用</li>
</ol>
<h3 id="2-附注标签（annotated）"><a href="#2-附注标签（annotated）" class="headerlink" title="2 附注标签（annotated）"></a>2 附注标签（annotated）</h3><ol>
<li>附注标签是存储在 Git 数据库中的一个完整对象</li>
<li>它有自身的校验和信息，包含着打标签者的名字，电子邮件地址、日期以及标签说明</li>
<li>标签允许使用 GNU Privacy Guard (GPG) 签名和验证</li>
</ol>
<h2 id="7-3-查看标签"><a href="#7-3-查看标签" class="headerlink" title="7.3 查看标签"></a>7.3 查看标签</h2><ol>
<li><code>git tag [-l Pattern]</code><ul>
<li>查看所有标签，默认按字母排序</li>
<li><code>-l Pattern</code><ul>
<li>只显示匹配的标签</li>
</ul>
</li>
</ul>
</li>
<li><code>git show tag_name</code><ul>
<li>查看指定标签信息及其对应的提交信息</li>
</ul>
</li>
</ol>
<h2 id="7-4-创建标签"><a href="#7-4-创建标签" class="headerlink" title="7.4 创建标签"></a>7.4 创建标签</h2><ol>
<li><code>git tag tag_name [commit_id]</code><ul>
<li>创建轻量标签</li>
<li>默认为当前分支 HEAD 打标签，可以指定 <code>commit_id</code></li>
</ul>
</li>
<li><code>git tag -a tag_name -m &quot;message&quot; [commit_id]</code><ul>
<li>创建附注标签，并添加标签信息</li>
</ul>
</li>
<li><code>git tag -s tag_name -m &quot;message&quot; [commit_id]</code><ul>
<li>采用GPG签名创建附注标签，必须首先安装 GPG</li>
</ul>
</li>
</ol>
<h2 id="7-5-推送标签"><a href="#7-5-推送标签" class="headerlink" title="7.5 推送标签"></a>7.5 推送标签</h2><ol>
<li><code>git push origin tag_name</code><ul>
<li>推送一个本地标签到远程仓库</li>
<li>默认情况下，<code>git push</code> 命令并不会把标签推送到远端服务器上</li>
</ul>
</li>
<li><code>git push origin --tags</code><ul>
<li>推送全部不在远程仓库的本地标签</li>
</ul>
</li>
</ol>
<h2 id="7-6-删除标签"><a href="#7-6-删除标签" class="headerlink" title="7.6 删除标签"></a>7.6 删除标签</h2><ol>
<li><code>git tag -d tag_name</code><ul>
<li>删除本地标签</li>
<li>并不会从远程仓库中移除这个标签</li>
</ul>
</li>
<li><code>git push remote_name :refs/tags/tag_name</code><ul>
<li>删除远程标签</li>
<li>将冒号前面的空值推送到远程标签名，从而高效地删除它</li>
</ul>
</li>
<li><code>git push remote_name --delete tag_name</code><ul>
<li>删除远程标签，更直观</li>
</ul>
</li>
</ol>
<h1 id="八-远程仓库"><a href="#八-远程仓库" class="headerlink" title="八 远程仓库"></a>八 远程仓库</h1><h2 id="8-1-远程仓库配置"><a href="#8-1-远程仓库配置" class="headerlink" title="8.1 远程仓库配置"></a>8.1 远程仓库配置</h2><h3 id="1-HTTPS"><a href="#1-HTTPS" class="headerlink" title="1 HTTPS"></a>1 HTTPS</h3><ul>
<li>本地与远程通讯时需要邮箱和密码验证</li>
</ul>
<h3 id="2-SSH"><a href="#2-SSH" class="headerlink" title="2 SSH"></a>2 SSH</h3><ol>
<li>查看本地 <code>~/.ssh</code> 目录下是否有公钥和私钥，若没有则创建<ol>
<li><code>id_rsa</code></li>
<li><code>id_rsa.pub</code></li>
</ol>
</li>
<li><code>ssh-keygen -t rsa -b 4096 -C &quot;comment&quot;</code><ul>
<li><code>-t</code><ul>
<li>密钥类型，默认 rsa</li>
</ul>
</li>
<li><code>-b</code><ul>
<li>密钥长度，rsa 密钥，最小要求768位，默认是2048位</li>
</ul>
</li>
<li><code>-C</code><ul>
<li>注释信息</li>
</ul>
</li>
</ul>
</li>
<li>配置 GitHub<ul>
<li><code>Title</code><ul>
<li>任意</li>
</ul>
</li>
<li><code>Key</code><ul>
<li><code>id_rsa.pub</code> 文件的内容</li>
<li>可以添加多个</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="8-2-远程仓库操作"><a href="#8-2-远程仓库操作" class="headerlink" title="8.2 远程仓库操作"></a>8.2 远程仓库操作</h2><h3 id="1-查看远程仓库"><a href="#1-查看远程仓库" class="headerlink" title="1 查看远程仓库"></a>1 查看远程仓库</h3><ol>
<li><code>git remote</code><ul>
<li>查看已经配置的远程仓库</li>
</ul>
</li>
<li><code>git remote -v</code><ul>
<li>查看已经配置的远程仓库及URL信息</li>
</ul>
</li>
<li><code>git remote show remote_name</code><ul>
<li>查看某个远程仓库的信息</li>
</ul>
</li>
</ol>
<h3 id="2-添加远程仓库"><a href="#2-添加远程仓库" class="headerlink" title="2 添加远程仓库"></a>2 添加远程仓库</h3><ul>
<li><code>git remote add ShortName URL</code><ul>
<li><code>ShortName</code><ul>
<li>远程仓库别名，通常为 <code>origin</code></li>
</ul>
</li>
<li><code>URL</code><ol>
<li><code>HTTPS</code><ul>
<li><code>https://github.com/username/repository.git</code></li>
</ul>
</li>
<li><code>SSH</code><ul>
<li><code>git@github.com:username/repository.git</code></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="3-重命名远程仓库"><a href="#3-重命名远程仓库" class="headerlink" title="3 重命名远程仓库"></a>3 重命名远程仓库</h3><ul>
<li><code>git remote rename old_name new_name</code></li>
</ul>
<h3 id="4-删除远程仓库"><a href="#4-删除远程仓库" class="headerlink" title="4 删除远程仓库"></a>4 删除远程仓库</h3><ul>
<li><code>git remote remove remote_name</code></li>
</ul>
<h2 id="8-3-git-push"><a href="#8-3-git-push" class="headerlink" title="8.3 git push"></a>8.3 git push</h2><ul>
<li><code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code><ul>
<li>将本地分支推送到远程仓库的指定分支</li>
</ul>
<ol>
<li><code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;</code><ul>
<li>省略远程分支</li>
<li>表示将本地分支推送到远程同名分支，如果不存在，则创建</li>
</ul>
</li>
<li><code>git push &lt;远程主机名&gt; :&lt;远程分支名&gt;</code><ul>
<li>省略本地分支</li>
<li>相当于推送了一个空的本地分支，即删除指定的远程分支，等价于 <code>git push &lt;远程主机名&gt; --delete &lt;远程分支名&gt;</code></li>
</ul>
</li>
<li><code>git push &lt;远程主机名&gt;</code><ul>
<li>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略</li>
<li>表示将当前分支推送到远程对应分支</li>
</ul>
</li>
<li><code>git push</code><ul>
<li>如果当前分支只与一个远程主机的存在追踪关系，则主机名可以省略</li>
</ul>
</li>
<li><code>git push -u &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code><ul>
<li><code>-u</code><ul>
<li>如果当前分支与多个远程主机的存在追踪关系，第一次推送使用 <code>-u</code> 指定一个默认的远程主机</li>
<li>以后就可以省略</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>推送模式<ol>
<li><code>simple</code> <ul>
<li>默认，只推送当前分支</li>
</ul>
</li>
<li><code>matching</code><ul>
<li>推送所有有对应的远程分支的本地分支</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="8-4-git-clone"><a href="#8-4-git-clone" class="headerlink" title="8.4 git clone"></a>8.4 git clone</h2><ul>
<li><code>git clone URL</code><ul>
<li>克隆到当前目录，通常会自动地创建一个跟踪 <code>origin/master</code> 的 <code>master</code> 分支</li>
<li><code>URL</code><ol>
<li><code>HTTPS</code><ul>
<li><code>https://github.com/username/repository.git</code></li>
</ul>
</li>
<li><code>SSH</code><ul>
<li><code>git@github.com:username/repository.git</code></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="8-5-git-fetch"><a href="#8-5-git-fetch" class="headerlink" title="8.5 git fetch"></a>8.5 git fetch</h2><ol>
<li><code>git fetch &lt;远程主机名&gt;</code><ul>
<li>将远程仓库所有分支的更新取回到本地</li>
</ul>
</li>
<li><code>git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;</code><ul>
<li>将远程仓库指定分支的更新取回到本地</li>
</ul>
</li>
<li><code>FETCH_HEAD</code><ul>
<li>指向使用 <code>git fetch</code> 从远程仓库取下来的指定分支的最新版本</li>
</ul>
</li>
</ol>
<h2 id="8-6-git-pull"><a href="#8-6-git-pull" class="headerlink" title="8.6 git pull"></a>8.6 git pull</h2><ol>
<li><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code><ul>
<li>取回远程主机某个分支的更新，并与本地的指定分支合并</li>
</ul>
</li>
</ol>
<h2 id="8-7-git-fetch-amp-git-pull"><a href="#8-7-git-fetch-amp-git-pull" class="headerlink" title="8.7 git fetch &amp; git pull"></a>8.7 git fetch &amp; git pull</h2><ol>
<li>三个概念<ol>
<li>本地仓库</li>
<li>远程仓库（本地的）<code>.git/refs/remotes</code></li>
<li>远程仓库（远程的）</li>
</ol>
</li>
<li><code>git fetch</code><ol>
<li>将本地的远程仓库更新到与远程的远程仓库一致</li>
<li>不会更新本地仓库 </li>
</ol>
</li>
<li><code>git pull</code><ol>
<li>将本地仓库和本地的远程仓库都更新到与远程的远程仓库一致</li>
<li>如果工作区有一些修改尚未提交到本地仓库，即工作区与本地仓库不一致，则此时禁止 <code>git pull</code></li>
</ol>
</li>
<li><code>git pull orgin master</code> = <code>git fetch orign master; git merge orgin/master</code></li>
</ol>
<h1 id="九-技"><a href="#九-技" class="headerlink" title="九 技"></a>九 技</h1><h2 id="9-1-忽略文件"><a href="#9-1-忽略文件" class="headerlink" title="9.1 忽略文件"></a>9.1 忽略文件</h2><ol>
<li>在工作区创建 <code>.gitignore</code> 文件（可以从网上查询），然后把要忽略的文件名填进去</li>
<li>忽略文件的原则：<ol>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的 <code>.class</code> 文件；</li>
<li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件</li>
</ol>
</li>
</ol>
<h2 id="9-2-git-clone-速度"><a href="#9-2-git-clone-速度" class="headerlink" title="9.2 git clone 速度"></a>9.2 git clone 速度</h2><ol>
<li>查询域名 <code>global-ssl.fastly.Net</code> 和 <code>github.com</code> 公网IP地址</li>
<li>将域名与IP映射添加到本地 hosts 文件<ul>
<li><code>/etc/hosts</code><ul>
<li>linux</li>
</ul>
</li>
<li><code>c:/windows/system32/driver/etc/hosts</code><ul>
<li>windows</li>
</ul>
</li>
</ul>
</li>
<li>刷新DNS缓存<ul>
<li><code>sudo /etc/init.d/networking restart</code><ul>
<li>linux</li>
</ul>
</li>
<li><code>ipconfig /flushdns</code><ul>
<li>windows</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="9-3-分离头指针（detached-HEAD）"><a href="#9-3-分离头指针（detached-HEAD）" class="headerlink" title="9.3 分离头指针（detached HEAD）"></a>9.3 分离头指针（detached HEAD）</h2><ol>
<li>通常，我们工作在某一个分支上，比如 master 分支。这个时候 master 指针和 HEAD 指针是一起前进的，每做一次提交，这两个指针就会一起向前挪一步。但是在某种情况下（例如 checkout 了某个具体的 commit），master 指针 和 HEAD 指针这种「绑定」的状态就被打破了，变成了分离头指针状态</li>
<li>即工作在没有分支的状态下，commit没有和任何分支相关联，此时如果切换分支，则分离头指针状态下的变更都会丢失。</li>
<li>如果想要保留分离头指针变更，就将其与某个分支绑定<ul>
<li><code>git branch 分支名 分离头指针commit_id</code></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>技</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>CSS 响应式布局</title>
    <url>/anyeansan.github.io/2020/03/30/CSS-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="一-媒体查询-Media-Querie"><a href="#一-媒体查询-Media-Querie" class="headerlink" title="一 媒体查询 Media Querie"></a>一 媒体查询 <code>Media Querie</code></h1><ul>
<li>Media Queries能在不同的条件下使用不同的样式，使页面在不同在终端设备下达到不同的渲染效果</li>
</ul>
<h1 id="二-媒体类型-media"><a href="#二-媒体类型-media" class="headerlink" title="二 媒体类型 media"></a>二 媒体类型 <code>media</code></h1><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>all（默认）</td>
<td>所有媒体类型</td>
</tr>
<tr>
<td>screen</td>
<td>用于电脑屏幕，平板电脑，智能手机等</td>
</tr>
<tr>
<td>print</td>
<td>打印设备</td>
</tr>
<tr>
<td>speech</td>
<td>应用于屏幕阅读器等发声设备</td>
</tr>
</tbody></table>
<ul>
<li>多媒体支持<ul>
<li>可以用逗号分隔同时支持多个媒体设备 如 <code>screen, print</code></li>
</ul>
</li>
</ul>
<h1 id="三-使用"><a href="#三-使用" class="headerlink" title="三 使用"></a>三 使用</h1><h2 id="3-1-lt-style-gt"><a href="#3-1-lt-style-gt" class="headerlink" title="3.1  &lt;style&gt;"></a>3.1  <code>&lt;style&gt;</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style media=&quot;&quot;&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-lt-link-gt"><a href="#3-2-lt-link-gt" class="headerlink" title="3.2 &lt;link&gt;"></a>3.2 <code>&lt;link&gt;</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;&quot; href=&quot;&quot; media=&quot;&quot;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-import"><a href="#3-3-import" class="headerlink" title="3.3 @import"></a>3.3 <code>@import</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// test.html</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;</span><br><span class="line">// style.css</span><br><span class="line">@import url(1.css) all;</span><br><span class="line">@import url(2.css) screen;</span><br><span class="line">@import url(3.css) print;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<ul>
<li>通过<code>&lt;link&gt;</code>指定媒体类型需要导入不同的css文件，导致<code>&lt;link&gt;</code>语句过多</li>
<li>可以导入一个css文件，然后在此css文件中通过<code>@import</code> 引入其它css文件并指定媒体类型</li>
</ul>
<h2 id="3-4-media"><a href="#3-4-media" class="headerlink" title="3.4 @media"></a>3.4 <code>@media</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">	@media screen &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	@media print &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用 <code>@media</code> 做到更细的控制，即在一个样式表中为多个媒体设备定义样式</li>
</ul>
<h1 id="四-查询条件"><a href="#四-查询条件" class="headerlink" title="四 查询条件"></a>四 查询条件</h1><ul>
<li>条件表达式需要放在括号中</li>
</ul>
<h2 id="4-1-逻辑与"><a href="#4-1-逻辑与" class="headerlink" title="4.1 逻辑与"></a>4.1 逻辑与</h2><ul>
<li><code>and</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@media screen and (max-width: 769px) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-2-逻辑或"><a href="#4-2-逻辑或" class="headerlink" title="4.2 逻辑或"></a>4.2 逻辑或</h2><ul>
<li><code>,</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@media screen and (orientation: landscape), screen and (max-width: 600px) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-3-逻辑非"><a href="#4-3-逻辑非" class="headerlink" title="4.3 逻辑非"></a>4.3 逻辑非</h2><ul>
<li><code>not</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@media not screen and (max-width: 769px) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>必须将not写在查询的最前面，表示对整个条件取反</li>
</ul>
<h2 id="4-4-only"><a href="#4-4-only" class="headerlink" title="4.4 only"></a>4.4 only</h2><ul>
<li>用来排除不支持媒体查询的浏览器<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@media only screen and (max-width: 769px) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>必须将only写在查询的最前面，表示如果浏览器支持媒体查询，就根据条件响应样式，如果不支持，就忽略</li>
</ul>
<h1 id="五-查询特性"><a href="#五-查询特性" class="headerlink" title="五 查询特性"></a>五 查询特性</h1><ul>
<li>根据查询特性筛选出使用样式的设备。</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>orientation: landscape/portrait</td>
<td>横屏/竖屏</td>
</tr>
<tr>
<td>width</td>
<td>设备宽度</td>
</tr>
<tr>
<td>height</td>
<td>设备高度</td>
</tr>
<tr>
<td>min-width</td>
<td>最小宽度</td>
</tr>
<tr>
<td>max-width</td>
<td>最大宽度</td>
</tr>
<tr>
<td>min-height</td>
<td>最小高度</td>
</tr>
<tr>
<td>max-height</td>
<td>最大高度</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>UI</category>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>CSS 帧动画</title>
    <url>/anyeansan.github.io/2020/03/30/CSS-%E5%B8%A7%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>通过定义一段动画中的关键点、关键状态来创建动画</li>
<li>过渡动画是两个状态间的变化，帧动画可以理解为帧之间的过渡动画</li>
</ol>
<h1 id="二-关键帧-keyframes"><a href="#二-关键帧-keyframes" class="headerlink" title="二 关键帧 @keyframes"></a>二 关键帧 <code>@keyframes</code></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@keyframes &lt;keyframes-name&gt; &#123;</span><br><span class="line">	from &#123;</span><br><span class="line">		margin-left: 100%;</span><br><span class="line">		width: 300%;</span><br><span class="line">	&#125;</span><br><span class="line">	to &#123;</span><br><span class="line">		margin-left: 0%;</span><br><span class="line">		width: 100%;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用<code>@keyframes</code> 规则定义动画名（<code>animation-name</code>）及其关键帧列表，每个<code>@keyframes</code> 规则包含多个关键帧</li>
<li>每个关键帧有一个百分比值作为名称，代表在动画进行中，在哪个阶段触发这个帧所包含的样式（顺序任意）</li>
<li><code>from</code> 相当于 <code>0%</code>，<code>to</code> 相当于 <code>100%</code></li>
<li>未设置<code>from/0%</code>与<code>to/100%</code> 时将使用元素现有样式作为起始/结束状态，可以用来从初始状态开始元素动画，最终返回初始状态。</li>
<li>动画名称或关键帧名称重复时，后者覆盖前者</li>
<li>关键帧中出现的 <code>!important</code> 关键词将会被忽略</li>
</ol>
<h1 id="三-animation"><a href="#三-animation" class="headerlink" title="三 animation"></a>三 animation</h1><h2 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">animation-name</span><br><span class="line">animation-duration</span><br><span class="line">animation-timing-function</span><br><span class="line">animation-delay</span><br><span class="line">animation-iteration-count</span><br><span class="line">animation-direction</span><br><span class="line">animation-fill-mode</span><br><span class="line">animation-play-state</span><br></pre></td></tr></table></figure>
<ol>
<li>必须存在 <code>animation-duration</code> 属性，否则过渡时间为0没有动画效果</li>
<li>延迟时间在过渡时间之后</li>
</ol>
<h2 id="3-2-animation-name"><a href="#3-2-animation-name" class="headerlink" title="3.2 animation-name"></a>3.2 animation-name</h2><ul>
<li>指定使用的动画，可以多个用逗号隔开</li>
<li>多个动画有相同属性时，后面动画的属性优先使用</li>
</ul>
<h2 id="3-3-animation-duration"><a href="#3-3-animation-duration" class="headerlink" title="3.3 animation-duration"></a>3.3 animation-duration</h2><ul>
<li>声明动画播放的时间，即把所有帧执行一遍所需要的时间，默认为 <code>0s</code></li>
<li>使用秒和毫秒为单位</li>
<li>可以为不同动画分别设置执行视角</li>
<li>如果动画数量大于时间数量，则超出的动画从第一个时间重新循环</li>
</ul>
<h2 id="3-4-animation-timing-function"><a href="#3-4-animation-timing-function" class="headerlink" title="3.4 animation-timing-function"></a>3.4 animation-timing-function</h2><ul>
<li>定义动画速率</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ease（默认）</td>
<td>开始慢，然后快，慢下来，结束时非常慢（等于 <code>cubic-bezier(0.25,0.1,0.25,1)</code>）</td>
</tr>
<tr>
<td>linear</td>
<td>规定以相同速度开始至结束的过渡效果（等于 <code>cubic-bezier(0,0,1,1)</code>）。</td>
</tr>
<tr>
<td>ease-in</td>
<td>开始慢，结束快（等于<code>cubic-bezier(0.42,0,1,1)</code>）</td>
</tr>
<tr>
<td>ease-out</td>
<td>开始快，结束慢（等于 <code>cubic-bezier(0,0,0.58,1)</code>）</td>
</tr>
<tr>
<td>ease-in-out</td>
<td>中间快，两边慢（等于 <code>cubic-bezier(0.42,0,0.58,1)</code>）</td>
</tr>
<tr>
<td><code>cubic-bezier(n,n,n,n)</code></td>
<td>三次贝塞尔曲线，在 cubic-bezier 函数中定义自己的值</td>
</tr>
<tr>
<td>step-start</td>
<td>同 <code>steps(1, start)</code></td>
</tr>
<tr>
<td>step-end</td>
<td>同<code>steps(1,end)</code></td>
</tr>
<tr>
<td><code>steps(n, start)</code></td>
<td>设置n个时间点，第一时间点变化状态</td>
</tr>
<tr>
<td><code>steps(n, end)</code></td>
<td>设置n个时间点，第一时间点初始状态</td>
</tr>
<tr>
<td>* <code>&lt;timing-function&gt;</code> （此属性接收的值） 作用于每两个关键帧之间，而不是整个动画</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><code>steps(n, start/end)</code><ul>
<li><code>n</code><ul>
<li>正整数，将间隔动画等分成指定数目的小间隔动画，然后根据第二个参数来决定显示效果</li>
</ul>
</li>
<li><code>start/end</code><ul>
<li>在分成的小间隔动画中判断显示效果，意思是每一阶段动画的改变时机</li>
<li>start表示从开始改变，即这一段动画的初始状态，显示的就是结束时的效果，可以理解为从下一步开始</li>
<li>end表示从结束改变，即这一段动画的初始状态，显示的是开始时的效果，可以理解为从当前步开始</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-5-animation-delay"><a href="#3-5-animation-delay" class="headerlink" title="3.5 animation-delay"></a>3.5 animation-delay</h2><ul>
<li>定义动画等待多长时间后执行</li>
</ul>
<h2 id="3-6-animation-iteration-count"><a href="#3-6-animation-iteration-count" class="headerlink" title="3.6 animation-iteration-count"></a>3.6 animation-iteration-count</h2><ul>
<li>设置动画重复执行次数</li>
<li>设置值为 <code>infinite</code> 表示无限循环</li>
<li>可同时设置元素的多个动画重复，使用逗号分隔</li>
<li>如果动画数量大于重复数量，超出动画从第一个重复次数重新循环</li>
</ul>
<h2 id="3-7-animation-direction"><a href="#3-7-animation-direction" class="headerlink" title="3.7 animation-direction"></a>3.7 animation-direction</h2><ul>
<li>控制动画运行的方向</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>normal（默认）</td>
<td>从0%到100%运行动画</td>
</tr>
<tr>
<td>reverse</td>
<td>从100%到0%运行动画</td>
</tr>
<tr>
<td>alternate</td>
<td>先从0%到100%，然后从100%到0%</td>
</tr>
<tr>
<td>alternate-reverse</td>
<td>先从100%到0%，然后从0%到100%</td>
</tr>
</tbody></table>
<h2 id="3-8-animation-play-state"><a href="#3-8-animation-play-state" class="headerlink" title="3.8 animation-play-state"></a>3.8 animation-play-state</h2><ul>
<li>可以控制动画的暂停与运行</li>
<li>恢复一个已暂停的动画，将从它暂停的地方开始，而不是从动画序列的起点开始</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>running（默认）</td>
<td>运行</td>
</tr>
<tr>
<td>paused</td>
<td>暂停</td>
</tr>
</tbody></table>
<h2 id="3-9-animation-fill-mode"><a href="#3-9-animation-fill-mode" class="headerlink" title="3.9 animation-fill-mode"></a>3.9 animation-fill-mode</h2><ul>
<li>设置CSS动画在执行之前和之后如何将样式应用于其目标</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>none（默认）</td>
<td>动画执行之前效果在初始状态，等延迟结束，起始帧才应用，动画执行之后会回到初始状态</td>
</tr>
<tr>
<td>backwards</td>
<td>动画执行之前效果就在起始帧，不会等延迟结束</td>
</tr>
<tr>
<td>forwards</td>
<td>动画执行之后停留动画的最后一帧</td>
</tr>
<tr>
<td>both</td>
<td>包含backwards与forwards规则，即动画执行之前在起始帧，不等延迟结束，动画执行之后停止在最后一帧</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>UI</category>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>CSS 过渡 延迟</title>
    <url>/anyeansan.github.io/2020/03/30/CSS-%E8%BF%87%E6%B8%A1-%E5%BB%B6%E8%BF%9F/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>默认情况下CSS属性的变化是瞬间完成的（其实也有时间只是毫秒级的，人眼很难感知到）</li>
<li>不是所有css属性都有过渡效果，一般来讲有中间值的属性都可以设置动画如宽度、透明度等。</li>
</ol>
<h1 id="二-transitionend"><a href="#二-transitionend" class="headerlink" title="二  transitionend"></a>二  transitionend</h1><ul>
<li>用于控制过渡结束后执行的JS<strong>事件</strong>（即过度结束触发此事件）</li>
<li>简写属性会触发多次</li>
</ul>
<h1 id="三-transition"><a href="#三-transition" class="headerlink" title="三 transition"></a>三 transition</h1><h2 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transition-property</span><br><span class="line">transition-timing-function</span><br><span class="line">transition-duration</span><br><span class="line">transition-delay</span><br></pre></td></tr></table></figure>
<ol>
<li>必须设置过渡时间 <code>transition-duration</code></li>
<li>延迟时间<code>transition-delay</code>在过渡时间之后</li>
</ol>
<h2 id="3-2-transition-property"><a href="#3-2-transition-property" class="headerlink" title="3.2 transition-property"></a>3.2 transition-property</h2><ul>
<li>指定应用过渡属性的名称</li>
<li>如果指定简写属性（比如 background），那么其完整版中所有可以动画的属性都会被应用过渡。</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>all（默认）</td>
<td>所有可被动画的属性都表现出过渡动画</td>
</tr>
<tr>
<td>none</td>
<td>没有过渡动画。</td>
</tr>
<tr>
<td>ident</td>
<td>属性名称，多个用逗号隔开</td>
</tr>
</tbody></table>
<h2 id="3-3-transition-duration"><a href="#3-3-transition-duration" class="headerlink" title="3.3 transition-duration"></a>3.3 transition-duration</h2><ul>
<li>以秒或毫秒为单位指定过渡动画所需的时间，默认 <code>0</code> 秒（即不出现过渡动画），不能为负</li>
</ul>
<ol>
<li>一个值时，所有属性使用同样的时间</li>
<li>多个值时，如果属性数量大于值数量，超出的属性再从第一个时间开始重复使用</li>
<li>可以为初始与变化状态设置不同的时间</li>
</ol>
<h2 id="3-4-transition-timing-function"><a href="#3-4-transition-timing-function" class="headerlink" title="3.4 transition-timing-function"></a>3.4 transition-timing-function</h2><ul>
<li>用于设置过渡效果的速度</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ease（默认）</td>
<td>开始慢，然后快，慢下来，结束时非常慢（等于 <code>cubic-bezier(0.25,0.1,0.25,1)</code>）</td>
</tr>
<tr>
<td>linear</td>
<td>规定以相同速度开始至结束的过渡效果（等于 <code>cubic-bezier(0,0,1,1)</code>）。</td>
</tr>
<tr>
<td>ease-in</td>
<td>开始慢，结束快（等于<code>cubic-bezier(0.42,0,1,1)</code>）</td>
</tr>
<tr>
<td>ease-out</td>
<td>开始快，结束慢（等于 <code>cubic-bezier(0,0,0.58,1)</code>）</td>
</tr>
<tr>
<td>ease-in-out</td>
<td>中间快，两边慢（等于 <code>cubic-bezier(0.42,0,0.58,1)</code>）</td>
</tr>
<tr>
<td><code>cubic-bezier(n,n,n,n)</code></td>
<td>三次贝塞尔曲线，在 cubic-bezier 函数中定义自己的值</td>
</tr>
<tr>
<td>step-start</td>
<td>同 <code>steps(1, start)</code></td>
</tr>
<tr>
<td>step-end</td>
<td>同<code>steps(1,end)</code></td>
</tr>
<tr>
<td><code>steps(n, start/end)</code></td>
<td>类似帧</td>
</tr>
</tbody></table>
<h2 id="3-5-transition-delay"><a href="#3-5-transition-delay" class="headerlink" title="3.5 transition-delay"></a>3.5 transition-delay</h2><ul>
<li>用于设置延迟过渡的时间（即在过渡效果开始作用之前需要等待的时间）</li>
</ul>
<ol>
<li>默认为0s即立刻开始过渡</li>
<li>值可以为负数，如<code>-3s</code>，表示直接显示在3s时的效果</li>
<li>变化属性数量大于时间数量时，后面的属性再从第一个时间开始重复使用</li>
</ol>
]]></content>
      <categories>
        <category>UI</category>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>CSS 变形</title>
    <url>/anyeansan.github.io/2020/03/30/CSS-%E5%8F%98%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="一-坐标轴"><a href="#一-坐标轴" class="headerlink" title="一 坐标轴"></a>一 坐标轴</h1><p><img src="https://gitee.com/3noanswer/npics/raw/master/UI/CSS/3d%E5%9D%90%E6%A0%87.png" alt=""></p>
<h1 id="二-变形操作-transform"><a href="#二-变形操作-transform" class="headerlink" title="二 变形操作 transform"></a>二 变形操作 <code>transform</code></h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol>
<li>使用 transform 规则控制元素的变形操作，包括控制移动、缩放、旋转、倾斜、3D转换等</li>
<li>变形叠加<ul>
<li>重复设置变形操作时只在原形态上操作，即第二次设置值时不是在第一次值上变化（就类似后边设置的字体大小会覆盖前边的而不是在前边设置的基础上再变化）</li>
</ul>
</li>
<li>行级元素不产生变形效果</li>
<li>可同时设置多个值，解析器会从左向右依次执行，顺序不同效果也不同</li>
</ol>
<h2 id="2-2-移动"><a href="#2-2-移动" class="headerlink" title="2.2 移动"></a>2.2 移动</h2><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>translateX(x)</td>
<td>定义x轴偏移量</td>
</tr>
<tr>
<td>translateY(y)</td>
<td>定义y轴偏移量</td>
</tr>
<tr>
<td>translateZ(z)</td>
<td>定义z轴偏移量</td>
</tr>
<tr>
<td>translate(x,y)</td>
<td>定义x，y轴偏移量</td>
</tr>
<tr>
<td>translate3d(x,y,z)</td>
<td>定义x，y，z轴偏移量</td>
</tr>
</tbody></table>
<ol>
<li>偏移量正负来决定移动方向<ul>
<li>X轴：整数向右，负数向左</li>
<li>Y轴：整数向下，负数向上</li>
<li>Z轴：正数向外、负数向里</li>
</ul>
</li>
<li>xy轴因为有宽高可以使用百分比（即偏移量为元素的百分比），z轴则不可以用百分比。</li>
</ol>
<h2 id="2-3-缩放"><a href="#2-3-缩放" class="headerlink" title="2.3 缩放"></a>2.3 缩放</h2><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>scaleX(x)</td>
<td>定义x轴的缩放</td>
</tr>
<tr>
<td>scaleY(y)</td>
<td>定义y轴的缩放</td>
</tr>
<tr>
<td>scaleZ(z)</td>
<td>定义z轴的缩放</td>
</tr>
<tr>
<td>scale(x,y)</td>
<td>定义x，y轴的缩放</td>
</tr>
<tr>
<td>scale3d(x,y,z)</td>
<td>定义x，y，z轴的缩放</td>
</tr>
</tbody></table>
<ul>
<li>缩放的值为原尺寸的倍数</li>
</ul>
<h2 id="2-4-旋转"><a href="#2-4-旋转" class="headerlink" title="2.4 旋转"></a>2.4 旋转</h2><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>rotateX(angle)</td>
<td>定义沿着 X 轴的 3D 旋转，angle：角度</td>
</tr>
<tr>
<td>rotateY(angle)</td>
<td>定义沿着 Y 轴的 3D 旋转</td>
</tr>
<tr>
<td>rotateZ(angle)</td>
<td>定义沿着 Z 轴的 3D 旋转</td>
</tr>
<tr>
<td>rotate(angle)</td>
<td>定义 2D 旋转（即沿着xy平面旋转也就是z轴，效果同rotateZ(angle)）</td>
</tr>
<tr>
<td>rotate3d(x,y,z,angle)</td>
<td>定义 3D 旋转，（x,y,z）定义一个向量</td>
</tr>
</tbody></table>
<h2 id="2-5-倾斜"><a href="#2-5-倾斜" class="headerlink" title="2.5 倾斜"></a>2.5 倾斜</h2><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>skewX(angle)</td>
<td>定义沿着 X 轴的 2D 倾斜。</td>
</tr>
<tr>
<td>skewY(angle)</td>
<td>定义沿着 Y 轴的 2D 倾斜。</td>
</tr>
<tr>
<td>skew(x-angle,y-angle)</td>
<td>定义沿着 X 和 Y 轴的 2D 倾斜。</td>
</tr>
</tbody></table>
<h1 id="三-变形基点-transform-origin"><a href="#三-变形基点-transform-origin" class="headerlink" title="三 变形基点 transform-origin"></a>三 变形基点 <code>transform-origin</code></h1><ol>
<li>使用 transform-origin 设置元素的X/Y/Z操作的基点，用于控制缩放，旋转、倾斜等操作</li>
<li>默认以元素中心为基点</li>
<li>移动不受变形基点影响</li>
</ol>
<h1 id="四-透视景深-perspective"><a href="#四-透视景深-perspective" class="headerlink" title="四 透视景深 perspective"></a>四 透视景深 <code>perspective</code></h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ol>
<li>perspective属性用于规定观察点距离元素的距离</li>
<li>我们观察物体时，远小近大，如果足够长，尽头会在视觉上相交</li>
<li>在二维屏幕上通过物体的大小来实现3效果</li>
</ol>
<h2 id="4-2-舞台透视"><a href="#4-2-舞台透视" class="headerlink" title="4.2 舞台透视"></a>4.2 舞台透视</h2><ul>
<li><code>perspective: 100px</code></li>
<li>“perspective 规则” 用于将父级整个做为透视元素，会造成里面的每个子元素的透视是不一样的<ul>
<li>例如摆一排杯子，是使用统一透视的，每个杯子的透视不一样，造成有大有小</li>
</ul>
</li>
</ul>
<h2 id="4-3-单独透视"><a href="#4-3-单独透视" class="headerlink" title="4.3 单独透视"></a>4.3 单独透视</h2><ul>
<li><code>transform: perspective(100px)</code></li>
<li>“perspective 函数” 用于为元素设置单独透视，每个元素的透视效果是一样的。</li>
</ul>
<h1 id="五-3D透视-transform-style"><a href="#五-3D透视-transform-style" class="headerlink" title="五 3D透视 transform-style"></a>五 3D透视 <code>transform-style</code></h1><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>flat</td>
<td>2D平面舞台</td>
</tr>
<tr>
<td>preserve-3d</td>
<td>3D透视舞台</td>
</tr>
</tbody></table>
<ol>
<li>使用 transform-style 用于控制3d透视</li>
<li>应用于舞台即变形元素的父级元素</li>
<li>设置 <code>overflow:visible</code> 时 <code>preserve-3d</code> 才无效</li>
</ol>
<h1 id="六-观看视角-perspective-origin"><a href="#六-观看视角-perspective-origin" class="headerlink" title="六 观看视角 perspective-origin"></a>六 观看视角 <code>perspective-origin</code></h1><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>x-axis</td>
<td>定义该视图在 x 轴上的位置。默认值：50%。可能的值：left、center、right、length、%</td>
</tr>
<tr>
<td>y-axis</td>
<td>定义该视图在 y 轴上的位置。默认值：50%。可能的值：top、center、bottom、length、%</td>
</tr>
</tbody></table>
<ol>
<li>perspective-origin用于控制视线的落点。就好像我们看车展，可以让车转，也可以我们自己转(perspective-origin)</li>
<li>需要设置 perspective 透视后才可以看到效果</li>
<li>一般设置在舞台元素上来控制子元素</li>
</ol>
<h1 id="七-隐藏背面-backface-visibility"><a href="#七-隐藏背面-backface-visibility" class="headerlink" title="七 隐藏背面 backface-visibility"></a>七 隐藏背面 <code>backface-visibility</code></h1><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>visible</td>
<td>背面可见</td>
</tr>
<tr>
<td>hidden</td>
<td>背面隐藏</td>
</tr>
</tbody></table>
<ol>
<li>使用 backface-visibility 用于控制是否可以看到元素的背面</li>
<li>一般设置在元素上而不是舞台元素上</li>
<li>如果设置在舞台元素（父级元素）需要设置 <code>transform-style: preserve-3d</code></li>
</ol>
]]></content>
      <categories>
        <category>UI</category>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>CSS 栅格布局</title>
    <url>/anyeansan.github.io/2020/03/30/CSS-%E6%A0%85%E6%A0%BC%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局</li>
<li>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是二维布局</li>
<li>设为网格布局以后，容器子元素（项目）的float、vertical-align等设置都将失效</li>
</ol>
<h1 id="二-基本概念"><a href="#二-基本概念" class="headerlink" title="二 基本概念"></a>二 基本概念</h1><ol>
<li>栅格容器（Grid Container）：采用 grid 布局的元素</li>
<li>栅格项目（Grid Item）：栅格容器中采用网格定位的子元素</li>
<li>栅格线（Grid Line）：划分网格的线</li>
<li>栅格轨道（Grid Track）：两条相邻网格线之间的空间，即行（row）或者列（column）</li>
<li>栅格单元格（Grid Cell）：行和列的交叉区域</li>
<li>栅格区域（Grid Area）：由任意数量单元格组成的区域（必须为矩形）</li>
</ol>
<h2 id="三-声明容器"><a href="#三-声明容器" class="headerlink" title="三 声明容器"></a>三 声明容器</h2><ol>
<li><code>display: grid</code><ul>
<li>块级栅格容器</li>
</ul>
</li>
<li><code>display: inline-grid</code><ul>
<li>内联栅格容器</li>
</ul>
</li>
</ol>
<h1 id="四-容器属性"><a href="#四-容器属性" class="headerlink" title="四 容器属性"></a>四 容器属性</h1><h2 id="4-1-grid-template-rows-amp-grid-template-columns"><a href="#4-1-grid-template-rows-amp-grid-template-columns" class="headerlink" title="4.1 grid-template-rows &amp; grid-template-columns"></a>4.1 grid-template-rows &amp; grid-template-columns</h2><ol>
<li>grid-template-rows：定义每一行的高度</li>
<li>grid-template-columns：定义每一列的宽度</li>
</ol>
<h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ &lt;line-names&gt;? [ &lt;track-size&gt; | &lt;track-repeat&gt; ] ]+ &lt;line-names&gt;?</span><br></pre></td></tr></table></figure>

<h3 id="2-lt-line-names-gt"><a href="#2-lt-line-names-gt" class="headerlink" title="2 &lt;line-names&gt;"></a>2 <code>&lt;line-names&gt;</code></h3><ol>
<li>相应位置上的删格线名称</li>
<li>可以省略，则名称按顺序分配为 <code>1 2 3 ...</code> </li>
<li>格式：<code>[name1 name2 ...]</code><ul>
<li>可以指定1或多个名称</li>
</ul>
</li>
</ol>
<h3 id="3-lt-track-size-gt"><a href="#3-lt-track-size-gt" class="headerlink" title="3 &lt;track-size&gt;"></a>3 <code>&lt;track-size&gt;</code></h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code></td>
<td>表示由浏览器自己决定长度</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>长度单位</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>栅格容器宽/高的百分比</td>
</tr>
<tr>
<td><code>fr</code></td>
<td>网格剩余空间比例单位（fraction 的缩写，意为”片段”）</td>
</tr>
<tr>
<td><code>minmax(min, max)</code></td>
<td>尺寸在min和max之间，若min&gt;max，则max的值会被忽略</td>
</tr>
</tbody></table>
<h3 id="4-lt-track-repeat-gt"><a href="#4-lt-track-repeat-gt" class="headerlink" title="4 &lt;track-repeat&gt;"></a>4 <code>&lt;track-repeat&gt;</code></h3><ul>
<li><code>repeat( count, [ &lt;line-names&gt;? &lt;track-size&gt; ]+ &lt;line-names&gt;? )</code><ul>
<li>count：重复次数<ul>
<li>如果重复次数不确定可以使用<ol>
<li>auto-fill 关键字</li>
<li>auto-fit 关键字</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-2-grid-template-areas"><a href="#4-2-grid-template-areas" class="headerlink" title="4.2 grid-template-areas"></a>4.2 grid-template-areas</h2><ul>
<li>区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code></li>
</ul>
<h3 id="1-为每个单元格设置区域（假如三行三列9个单元格）"><a href="#1-为每个单元格设置区域（假如三行三列9个单元格）" class="headerlink" title="1 为每个单元格设置区域（假如三行三列9个单元格）"></a>1 为每个单元格设置区域（假如三行三列9个单元格）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-template-areas: &quot;a b c&quot;</span><br><span class="line">					&quot;d e f&quot;</span><br><span class="line">					&quot;g h i&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="2-多个单元格合并成一个区域：区域名相同即可"><a href="#2-多个单元格合并成一个区域：区域名相同即可" class="headerlink" title="2 多个单元格合并成一个区域：区域名相同即可"></a>2 多个单元格合并成一个区域：区域名相同即可</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-template-areas: &quot;a a a&quot;</span><br><span class="line">					&quot;b b b&quot;</span><br><span class="line">					&quot;c c c&quot;;</span><br><span class="line">grid-template-areas: &quot;header header header&quot;</span><br><span class="line">					&quot;main main sidebar&quot;</span><br><span class="line">					&quot;footer footer footer&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="3-区域占位符（点）：表示没有用到该单元格，或者该单元格不属于任何区域"><a href="#3-区域占位符（点）：表示没有用到该单元格，或者该单元格不属于任何区域" class="headerlink" title="3 区域占位符（点）：表示没有用到该单元格，或者该单元格不属于任何区域"></a>3 区域占位符（点）：表示没有用到该单元格，或者该单元格不属于任何区域</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-template-areas: &quot;a . c&quot;</span><br><span class="line">					&quot;. . f&quot;</span><br><span class="line">					&quot;g h .&quot;;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-grid-template"><a href="#4-3-grid-template" class="headerlink" title="4.3 grid-template"></a>4.3 grid-template</h2><ul>
<li>grid-template是grid-template-rows，grid-template-columns和grid-template-areas属性的缩写</li>
<li>推荐使用 grid 代替grid-template</li>
</ul>
<h2 id="4-4-row-gap-amp-column-gap-amp-grap"><a href="#4-4-row-gap-amp-column-gap-amp-grap" class="headerlink" title="4.4 row-gap &amp; column-gap &amp; grap"></a>4.4 row-gap &amp; column-gap &amp; grap</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>row-gap</code></td>
<td>设置行与行的间隔（行间距）</td>
</tr>
<tr>
<td><code>column-gap</code></td>
<td>设置列与列的间隔（列间距）</td>
</tr>
<tr>
<td><code>grap</code></td>
<td><code>row-gap column-gap</code></td>
</tr>
</tbody></table>
<ul>
<li>如果<code>grap</code>省略了第二个值，浏览器认为第二个值等于第一个值</li>
</ul>
<h2 id="4-5-grid-auto-flow"><a href="#4-5-grid-auto-flow" class="headerlink" title="4.5 grid-auto-flow"></a>4.5 grid-auto-flow</h2><ul>
<li>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。</li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>row</code>（默认）</td>
<td>先行后列</td>
</tr>
<tr>
<td><code>column</code></td>
<td>先列后行</td>
</tr>
<tr>
<td><code>row dense</code></td>
<td>先行后列，并且尽量填满空格</td>
</tr>
<tr>
<td><code>column dense</code></td>
<td>先列后行，并且尽量填满空格</td>
</tr>
</tbody></table>
<ul>
<li>尽量填满的意思是比如第2个元素太宽第一行放不下，可以先放第3,4…个</li>
</ul>
<h2 id="4-6-justify-items-amp-align-items-amp-place-items"><a href="#4-6-justify-items-amp-align-items-amp-place-items" class="headerlink" title="4.6 justify-items &amp; align-items &amp; place-items"></a>4.6 justify-items &amp; align-items &amp; place-items</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>justify-items</td>
<td>单元格中的元素在单元格中的水平对齐方式（针对所有单元格）</td>
</tr>
<tr>
<td>align-items</td>
<td>单元格中的元素的在单元格中垂直对齐方式（针对所有单元格）</td>
</tr>
<tr>
<td>place-items</td>
<td><code>align-items justify-items</code> 简写</td>
</tr>
</tbody></table>
<ul>
<li><code>place-items</code><ul>
<li>如果省略第二个值，则浏览器认为第二个值等于第一个值</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>stretch</code>（默认）</td>
<td>拉伸，占满单元格的整个宽度</td>
</tr>
<tr>
<td><code>start</code></td>
<td>对齐单元格的起始边缘</td>
</tr>
<tr>
<td><code>end</code></td>
<td>对齐单元格的结束边缘</td>
</tr>
<tr>
<td><code>center</code></td>
<td>单元格内部居中</td>
</tr>
</tbody></table>
<h2 id="4-7-justify-content-amp-align-content-amp-place-content"><a href="#4-7-justify-content-amp-align-content-amp-place-content" class="headerlink" title="4.7 justify-content &amp; align-content &amp; place-content"></a>4.7 justify-content &amp; align-content &amp; place-content</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>justify-content</td>
<td>所有单元格（整个内容区域）在容器中的水平对齐方式</td>
</tr>
<tr>
<td>align-content</td>
<td>所有单元格（整个内容区域）在容器中的垂直对齐方式</td>
</tr>
<tr>
<td>place-content</td>
<td><code>align-content justify-content</code> 简写</td>
</tr>
</tbody></table>
<ul>
<li><code>place-content</code> <ul>
<li>如果省略第二个值，则浏览器认为第二个值等于第一个值</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>stretch（默认）</td>
<td>拉伸，占满单元格的整个宽度</td>
</tr>
<tr>
<td>start</td>
<td>对齐单元格的起始边缘</td>
</tr>
<tr>
<td>end</td>
<td>对齐单元格的结束边缘</td>
</tr>
<tr>
<td>center</td>
<td>单元格内部居中</td>
</tr>
<tr>
<td>space-between</td>
<td>两端对齐，两端紧挨边框中间平均分配</td>
</tr>
<tr>
<td>space-around</td>
<td>每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍</td>
</tr>
<tr>
<td>space-evenly</td>
<td>项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔</td>
</tr>
</tbody></table>
<h2 id="4-8-grid-auto-columns-amp-grid-auto-rows"><a href="#4-8-grid-auto-columns-amp-grid-auto-rows" class="headerlink" title="4.8 grid-auto-columns &amp; grid-auto-rows"></a>4.8 grid-auto-columns &amp; grid-auto-rows</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>grid-auto-columns</td>
<td>浏览器自动创建的多余网格的列宽</td>
</tr>
<tr>
<td>grid-auto-rows</td>
<td>浏览器自动创建的多余网格的行高</td>
</tr>
</tbody></table>
<ul>
<li>有时，一些项目的指定位置，在现有网格的外部，比如网格只有三行，但是有一个项目在第五行，这时，浏览器会自动生成多余的网格，以便放置项目。</li>
<li>如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高</li>
</ul>
<h2 id="4-9-grid"><a href="#4-9-grid" class="headerlink" title="4.9 grid"></a>4.9 grid</h2><ul>
<li><code>grid-template-rows grid-template-columns grid-template-areas  grid-auto-rows grid-auto-columns grid-auto-flow</code> 六个属性的缩写</li>
</ul>
<h1 id="五-项目属性"><a href="#五-项目属性" class="headerlink" title="五 项目属性"></a>五 项目属性</h1><h2 id="5-1-grid-column-start-amp-grid-column-end-amp-grid-row-start-amp-grid-row-end"><a href="#5-1-grid-column-start-amp-grid-column-end-amp-grid-row-start-amp-grid-row-end" class="headerlink" title="5.1 grid-column-start &amp; grid-column-end &amp; grid-row-start &amp; grid-row-end"></a>5.1 grid-column-start &amp; grid-column-end &amp; grid-row-start &amp; grid-row-end</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>grid-row-start</td>
<td>行开始栅格线（上边框）</td>
</tr>
<tr>
<td>grid-row-end</td>
<td>行结束栅格线（下边框）</td>
</tr>
<tr>
<td>grid-column-start</td>
<td>列开始栅格线（左边框）</td>
</tr>
<tr>
<td>grid-column-end</td>
<td>列结束栅格线（右边框）</td>
</tr>
</tbody></table>
<h3 id="项目定位"><a href="#项目定位" class="headerlink" title="项目定位"></a>项目定位</h3><h4 id="1-根据栅格线"><a href="#1-根据栅格线" class="headerlink" title="1 根据栅格线"></a>1 根据栅格线</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-column-start: 1;</span><br><span class="line">grid-column-end: 3;</span><br><span class="line">grid-row-start: 2;</span><br><span class="line">grid-row-end: 4;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置栅格线来定位，设置的数值可以是正数和负数</li>
</ul>
<h4 id="2-根据栅格命名"><a href="#2-根据栅格命名" class="headerlink" title="2 根据栅格命名"></a>2 根据栅格命名</h4><ol>
<li>固定命名<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-column-start: header-start;</span><br><span class="line">grid-column-end: header-end;</span><br></pre></td></tr></table></figure></li>
<li>自动命名<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 后边数字表示第几个</span><br><span class="line">grid-column-start: c-start 1;</span><br><span class="line">grid-column-end: c-end 3;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="3-根据偏移量"><a href="#3-根据偏移量" class="headerlink" title="3 根据偏移量"></a>3 根据偏移量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-row-end: span 1;</span><br><span class="line">grid-column-end: span 1;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>span</code> 可以设置移动单元格数量（即开始栅格线和结束栅格线之间有几个单元格），数值只能为正数</li>
</ul>
<h2 id="5-2-grid-column-amp-grid-row"><a href="#5-2-grid-column-amp-grid-row" class="headerlink" title="5.2 grid-column &amp; grid-row"></a>5.2 grid-column &amp; grid-row</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>grid-row</td>
<td><code>grid-row-start / grid-row-end</code></td>
</tr>
<tr>
<td>grid-column</td>
<td><code>grid-column-start / grid-column-end</code></td>
</tr>
</tbody></table>
<ol>
<li>设置起始栅格线<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-column: 1 / 3;</span><br><span class="line">grid-row: 1 / 2;</span><br></pre></td></tr></table></figure></li>
<li>使用span<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-column: 1 / span 3;</span><br><span class="line">grid-row: 1 / span 2;</span><br><span class="line">// 如果省略斜杠及后面部分，表示span值为1</span><br><span class="line">grid-row: 1;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="5-3-grid-area"><a href="#5-3-grid-area" class="headerlink" title="5.3 grid-area"></a>5.3 grid-area</h2><ol>
<li>指定项目放在哪一个区域<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-area: 区域名;</span><br></pre></td></tr></table></figure></li>
<li><code>grid-row-start/grid-column-start/grid-row-end/grid-column-end</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-area: 2/2/3/4;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="5-4-justify-self-amp-align-self-amp-place-self"><a href="#5-4-justify-self-amp-align-self-amp-place-self" class="headerlink" title="5.4 justify-self &amp; align-self &amp; place-self"></a>5.4 justify-self &amp; align-self &amp; place-self</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>justify-self</td>
<td>单元格中的元素在单元格中的水平对齐方式（针对单个单元格）</td>
</tr>
<tr>
<td>align-self</td>
<td>单元格中的元素在单元格中的垂直对齐方式（针对单个单元格）</td>
</tr>
<tr>
<td>place-self</td>
<td><code>align-self justify-self</code> 简写</td>
</tr>
</tbody></table>
<ul>
<li><code>justify-self</code> 用法同<code>justify-items</code></li>
<li><code>align-self</code> 用法同<code>align-items</code></li>
<li><code>place-selef</code> <ul>
<li>如果省略第二个值，则浏览器认为第二个值等于第一个值</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>UI</category>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>CSS 继承和层叠</title>
    <url>/anyeansan.github.io/2020/03/30/CSS-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%B1%82%E5%8F%A0/</url>
    <content><![CDATA[<h1 id="一-继承"><a href="#一-继承" class="headerlink" title="一 继承"></a>一 继承</h1><h2 id="1-1-控制继承"><a href="#1-1-控制继承" class="headerlink" title="1.1 控制继承"></a>1.1 控制继承</h2><ul>
<li>CSS 为控制继承提供了四个特殊的通用属性值。每个css属性都接收这些值</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>inherit</td>
<td>设置该值会使子元素属性和父元素相同。实际上，就是 “开启继承”.</td>
</tr>
<tr>
<td>initial</td>
<td>设置 CSS 属性为它的默认值</td>
</tr>
<tr>
<td>unset</td>
<td>如果该属性默认可继承，该值等同于 <code>inherit</code>，如果该属性是非继承属性，该值等同于 <code>initial</code></td>
</tr>
<tr>
<td>revert</td>
<td>只有很少的浏览器支持</td>
</tr>
</tbody></table>
<h2 id="1-2-元素可继承属性"><a href="#1-2-元素可继承属性" class="headerlink" title="1.2 元素可继承属性"></a>1.2 元素可继承属性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">azimuth border-collapse border-spacing caption-side color cursor</span><br><span class="line">direction elevation empty-cells font-family font-size font-style </span><br><span class="line">font-variant font-weight font letter-spacing line-height </span><br><span class="line">list-style-image list-style-position list-style-type list-style</span><br><span class="line">orphans pitch-range pitch quotes richness speak-header</span><br><span class="line">speak-numeral speak-punctuation speak speech-rate stress</span><br><span class="line">text-align text-indent text-transform visibility voice-family volume</span><br><span class="line">white-space widows word-spacing</span><br></pre></td></tr></table></figure>

<h3 id="1-文本相关属性"><a href="#1-文本相关属性" class="headerlink" title="1 文本相关属性"></a>1 文本相关属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">font-family font-size font-style </span><br><span class="line">font-variant font-weight font letter-spacing line-height</span><br><span class="line">text-align text-indent text-transform word-spacing color</span><br></pre></td></tr></table></figure>

<h3 id="2-列表相关属性"><a href="#2-列表相关属性" class="headerlink" title="2 列表相关属性"></a>2 列表相关属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list-style-image list-style-position list-style-type list-style</span><br></pre></td></tr></table></figure>

<h3 id="3-表格相关属性"><a href="#3-表格相关属性" class="headerlink" title="3 表格相关属性"></a>3 表格相关属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">border-collapse  border-spacing empty-cells</span><br></pre></td></tr></table></figure>

<h3 id="4-可见性相关属性"><a href="#4-可见性相关属性" class="headerlink" title="4 可见性相关属性"></a>4 可见性相关属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">visibility</span><br></pre></td></tr></table></figure>

<h1 id="二-层叠"><a href="#二-层叠" class="headerlink" title="二 层叠"></a>二 层叠</h1><h2 id="2-1-层叠上下文-stacking-context"><a href="#2-1-层叠上下文-stacking-context" class="headerlink" title="2.1 层叠上下文 stacking context"></a>2.1 层叠上下文 <code>stacking context</code></h2><ul>
<li>层叠上下文是一个概念，跟“块状格式化上下文”（BFC）类似，可以想象成z轴上的一个层叠结界</li>
</ul>
<h3 id="1-层叠上下文特性"><a href="#1-层叠上下文特性" class="headerlink" title="1 层叠上下文特性"></a>1 层叠上下文特性</h3><ol>
<li>层叠上下文的层叠水平要比普通元素高。</li>
<li>层叠上下文可以阻断元素的混合模式</li>
<li>层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。</li>
<li>每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。</li>
<li>每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中</li>
</ol>
<h3 id="2-创建层叠上下文"><a href="#2-创建层叠上下文" class="headerlink" title="2 创建层叠上下文"></a>2 创建层叠上下文</h3><ol>
<li>页面根元素<code>&lt;html&gt;</code>天生具有层叠上下文，称为根层叠上下文。</li>
<li>定位元素（position非static）的z-index不是auto，会创建层叠上下文</li>
<li>其它css3属性创建层叠上下文<ol>
<li>元素为 flex 布局元素（即父元素 display:flex / inline-flex），同时 z-index值不是 auto。</li>
<li>元素的 opacity 值不是 1。</li>
<li>元素的 transform 值不是 none。</li>
<li>元素 mix-blend-mode 值不是 normal。</li>
<li>元素的 filter 值不是 none。</li>
<li>元素的 isolation 值是 isolate。</li>
<li>元素的 will-change 属性值为上面 2～6 的任意一个（如willchange:opacity、will-chang:transform 等）。</li>
<li>元素的-webkit-overflow-scrolling 设为 touch。</li>
</ol>
</li>
</ol>
<h2 id="2-2-层叠水平-stacking-level"><a href="#2-2-层叠水平-stacking-level" class="headerlink" title="2.2 层叠水平 stacking level"></a>2.2 层叠水平 <code>stacking level</code></h2><ul>
<li>决定了同一个层叠上下文中元素在 z 轴上的显示顺序</li>
<li>所有元素都有层叠水平，普通元素的层叠水平在其层叠上下文中有意义</li>
</ul>
<h2 id="2-3-层叠顺序-stacking-order"><a href="#2-3-层叠顺序-stacking-order" class="headerlink" title="2.3 层叠顺序 stacking order"></a>2.3 层叠顺序 <code>stacking order</code></h2><ul>
<li>就是根据层叠水平规定在z轴显示顺序的规则</li>
<li>每一个层叠顺序规则仅适用于当前层叠上下文元素的小世界</li>
</ul>
<p>![](<a href="https://gitee.com/3noanswer/npics/raw/master/UI/CSS/stacking" target="_blank" rel="noopener">https://gitee.com/3noanswer/npics/raw/master/UI/CSS/stacking</a> order.png)</p>
<ul>
<li>在同一个层叠上下文中的七层<ol>
<li>层叠上下文的背景和边框</li>
<li>层叠上下文中z-index值为负的层叠上下文元素</li>
<li>层叠上下文中块级普通元素</li>
<li>层叠上下文中浮动元素</li>
<li>层级上下文中内联普通元素</li>
<li>此层包含三种<ol>
<li>层叠上下文中不依赖z-index 的层叠上下文元素（即元素创建层叠上下文时不是用的z-index）</li>
<li>层叠上下文中z-index值为 0 的层叠上下文元素</li>
<li>层叠上下文中z-index值为 auto 的普通定位元素<ol>
<li>元素一旦成为定位元素，其z-index就会自动生效，默认为auto</li>
<li>定位元素的z-index值为数值时才是层叠上下文，所以此时是普通定位元素，并非层叠上下文</li>
</ol>
</li>
</ol>
</li>
<li>层叠上下文中z-index值为负的层叠上下文元素</li>
</ol>
</li>
</ul>
<h3 id="比较步骤"><a href="#比较步骤" class="headerlink" title="比较步骤"></a>比较步骤</h3><ol>
<li>首先查看两个元素是否在同一个层叠上下文<ol>
<li>否，则查看它们所在的层叠上下文是否在同一个层叠上下文，如果还不是，继续往上…直到两个层叠上下文在同一个层叠上下文中，最终肯定在同一个层叠上下文，因为有根层叠上下文。</li>
<li>是，则根据它们的层叠水平，在层叠顺序中找到位置。</li>
</ol>
</li>
<li>如果在层叠顺序中位置相同<ol>
<li>如果明显的层叠水平标识的，如生效的z-index，则谁大谁在上</li>
<li>如果没有明显的层叠水平标识的，则后来居上（即在 DOM 流中处于后面的元素会覆盖前面的元素）</li>
</ol>
</li>
</ol>
<h2 id="2-4-z-index"><a href="#2-4-z-index" class="headerlink" title="2.4 z-index"></a>2.4 z-index</h2><ul>
<li>设定了一个定位元素及其后代元素或 flex 项目的 z-order</li>
<li>即只能用在<ol>
<li>定位元素</li>
<li>flex 布局中的项目</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code>（默认）</td>
<td>不会创建一个新的本地堆叠上下文</td>
</tr>
<tr>
<td><code>&lt;integer&gt;</code></td>
<td>创建层叠上下文，可以为负</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>UI</category>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>CSS 弹性布局</title>
    <url>/anyeansan.github.io/2020/03/30/CSS-%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>Flex 是 Flexible Box 的缩写，意为”弹性布局”，可以轻松的控制元素排列、对齐和顺序的控制</li>
<li>任何一个容器都可以指定为 Flex 布局</li>
<li>设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效</li>
<li>弹性元素均为块元素</li>
<li>绝对定位的弹性元素不参与弹性布局</li>
<li>文本节点也在弹性布局操作范围内</li>
<li>在弹性布局中对元素使用<code>margin-right:auto</code> 等形式可以自动撑满空间</li>
</ol>
<h1 id="二-基本概念"><a href="#二-基本概念" class="headerlink" title="二 基本概念"></a>二 基本概念</h1><p><img src="https://gitee.com/3noanswer/npics/raw/master/UI/CSS/Flex%E6%A6%82%E5%BF%B5.png" alt=""></p>
<ol>
<li>Flex 容器（flex container）：采用 Flex 布局的元素</li>
<li>Flex 项目（flex item）： Flex 容器中的子元素</li>
<li>主轴（main axis）：默认是水平轴<ul>
<li>主轴的开始位置（与边框的交叉点）叫做 main start</li>
<li>主轴的结束位置叫做 main end</li>
<li>单个项目占据的主轴空间叫做 main size</li>
</ul>
</li>
<li>交叉轴（cross axis）：默认是垂直轴<ul>
<li>交叉轴的开始位置叫做 cross start</li>
<li>交叉轴的结束位置叫做 cross end</li>
<li>单个项目占据的交叉轴空间叫做 cross size</li>
</ul>
</li>
</ol>
<h1 id="三-声明容器"><a href="#三-声明容器" class="headerlink" title="三 声明容器"></a>三 声明容器</h1><ol>
<li><code>display:flex</code><ul>
<li>块级弹性盒子</li>
</ul>
</li>
<li><code>display:inline-flex</code> <ul>
<li>内联级弹性盒子</li>
</ul>
</li>
</ol>
<h1 id="四-容器属性"><a href="#四-容器属性" class="headerlink" title="四 容器属性"></a>四 容器属性</h1><h2 id="4-1-flex-direction"><a href="#4-1-flex-direction" class="headerlink" title="4.1 flex-direction"></a>4.1 flex-direction</h2><ul>
<li>决定主轴的方向</li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>row</code>（默认）</td>
<td>主轴为水平方向，起点在左端（从左到右）</td>
</tr>
<tr>
<td><code>row-reverse</code></td>
<td>主轴为水平方向，起点在右端（从右到左）</td>
</tr>
<tr>
<td><code>column</code></td>
<td>主轴为垂直方向，起点在上沿（从上到下）</td>
</tr>
<tr>
<td><code>column-reverse</code></td>
<td>主轴为垂直方向，起点在下沿（从下到上）</td>
</tr>
</tbody></table>
<h2 id="4-2-flex-wrap"><a href="#4-2-flex-wrap" class="headerlink" title="4.2 flex-wrap"></a>4.2 flex-wrap</h2><ul>
<li>默认情况下，项目都排在一条线（又称”轴线”）上</li>
<li>flex-wrap属性定义，如果一条轴线排不下，如何换行</li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>nowrap</code>（默认）</td>
<td>不换行/列</td>
</tr>
<tr>
<td><code>wrap</code></td>
<td>换行/列，新行在下 / 新列在右</td>
</tr>
<tr>
<td><code>wrap-reverse</code></td>
<td>换行/列，新行在上 / 新列在左</td>
</tr>
</tbody></table>
<h2 id="4-3-flex-flow"><a href="#4-3-flex-flow" class="headerlink" title="4.3 flex-flow"></a>4.3 flex-flow</h2><ul>
<li><code>flex-direction || flex-wrap</code><ul>
<li><code>flex-flow</code> 是 <code>flex-direction</code> 与 <code>flex-wrap</code> 的组合简写模式，默认 <code>row nowrap</code></li>
</ul>
</li>
</ul>
<h2 id="4-4-justify-content"><a href="#4-4-justify-content" class="headerlink" title="4.4 justify-content"></a>4.4 justify-content</h2><ul>
<li>定义了项目在主轴上的对齐方式</li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>flex-start</code>（默认）</td>
<td>元素紧靠主轴起点，左对齐</td>
</tr>
<tr>
<td><code>flex-end</code></td>
<td>元素紧靠主轴终点，右对齐</td>
</tr>
<tr>
<td><code>center</code></td>
<td>元素从弹性容器中心开始，居中</td>
</tr>
<tr>
<td><code>space-between</code></td>
<td>第一个元素靠起点，最后一个元素靠终点，余下元素平均分配剩余空间，两端对齐</td>
</tr>
<tr>
<td><code>space-around</code></td>
<td>每个元素两侧的间隔相等。所以，项目之间的间隔是项目与边框的间隔的2倍</td>
</tr>
<tr>
<td><code>space-evenly</code></td>
<td>元素间距离平均分配，所有间距都相等</td>
</tr>
</tbody></table>
<h2 id="4-5-align-items"><a href="#4-5-align-items" class="headerlink" title="4.5 align-items"></a>4.5 align-items</h2><ul>
<li>交叉轴上所有项目的对齐方式</li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>stretch</code>（默认）</td>
<td>如果项目未设置高度或设为auto，将占满整个容器的高度</td>
</tr>
<tr>
<td><code>center</code></td>
<td>交叉轴的中点对齐</td>
</tr>
<tr>
<td><code>flex-start</code></td>
<td>交叉轴的起点对齐</td>
</tr>
<tr>
<td><code>flex-end</code></td>
<td>交叉轴的终点对齐</td>
</tr>
<tr>
<td><code>baseline</code></td>
<td>项目的第一行文字的基线对齐</td>
</tr>
</tbody></table>
<h2 id="4-6-align-content"><a href="#4-6-align-content" class="headerlink" title="4.6 align-content"></a>4.6 align-content</h2><ul>
<li>定义多行在交叉轴的对齐方式，如果只有一行则无效</li>
</ul>
<table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>stretch</code>（默认）</td>
<td>轴线占满整个交叉轴</td>
</tr>
<tr>
<td><code>flex-start</code></td>
<td>与交叉轴的起点对齐</td>
</tr>
<tr>
<td><code>flex-end</code></td>
<td>与交叉轴的终点对齐</td>
</tr>
<tr>
<td><code>center</code></td>
<td>与交叉轴的中点对齐</td>
</tr>
<tr>
<td><code>space-between</code></td>
<td>与交叉轴两端对齐，轴线之间的间隔平均分布</td>
</tr>
<tr>
<td><code>space-around</code></td>
<td>每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍</td>
</tr>
<tr>
<td><code>space-evenly</code></td>
<td>轴线间距离相等</td>
</tr>
</tbody></table>
<h1 id="五-项目属性"><a href="#五-项目属性" class="headerlink" title="五 项目属性"></a>五 项目属性</h1><h2 id="5-1-order"><a href="#5-1-order" class="headerlink" title="5.1 order"></a>5.1 order</h2><ul>
<li>定义项目的排列顺序。数值越小，排列越靠前</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;integer&gt;</code></td>
<td>默认为 0，可以为负</td>
</tr>
</tbody></table>
<h2 id="5-2-flex-grow"><a href="#5-2-flex-grow" class="headerlink" title="5.2 flex-grow"></a>5.2 flex-grow</h2><ul>
<li>指定容器有剩余空间时（即项目宽度之和小于容器宽度）项目的分配规则<ul>
<li><code>剩余空间 = 容器宽度 - 项目宽度之和</code></li>
</ul>
</li>
<li>默认值是0，不分配多余空间</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;number&gt;</code></td>
<td>默认为 0，数字为放大比例，不能为负</td>
</tr>
<tr>
<td>* 计算规则</td>
<td></td>
</tr>
<tr>
<td><img src="https://gitee.com/3noanswer/npics/raw/master/UI/CSS/flex-grow%E8%AE%A1%E7%AE%97%E8%A7%84%E5%88%99.jpg" alt=""></td>
<td></td>
</tr>
</tbody></table>
<h2 id="5-3-flex-shrink"><a href="#5-3-flex-shrink" class="headerlink" title="5.3 flex-shrink"></a>5.3 flex-shrink</h2><ul>
<li>指定容器有溢出空间时（即项目宽度之和大于容器宽度）项目的分配规则<ul>
<li><code>溢出空间 = 项目宽度之和 - 容器宽度</code></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;number&gt;</code></td>
<td>默认为 1，数字为缩小比例，不能为负</td>
</tr>
<tr>
<td>* 计算规则</td>
<td></td>
</tr>
<tr>
<td><img src="https://gitee.com/3noanswer/npics/raw/master/UI/CSS/flex-shrink%E8%AE%A1%E7%AE%97%E8%A7%84%E5%88%99.jpg" alt=""></td>
<td></td>
</tr>
<tr>
<td>* 其实还要算padding border magin..总之很复杂</td>
<td></td>
</tr>
</tbody></table>
<h2 id="5-4-flex-basis"><a href="#5-4-flex-basis" class="headerlink" title="5.4 flex-basis"></a>5.4 flex-basis</h2><ul>
<li>指定了 项目在主轴方向上的初始大小。如果不使用  box-sizing 改变盒模型的话，则flex-basis是作用在 content-box 上的</li>
<li>flex-basis的优先级高于width / height属性，低于min-width max width / min-height max-height</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code>（默认）</td>
<td>项目的本来大小（参照width和height属性）</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>长度单位</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>相对于弹性容器主轴尺寸的百分比</td>
</tr>
<tr>
<td><code>content</code></td>
<td>基于项目的内容自动调整大小</td>
</tr>
</tbody></table>
<h2 id="5-5-flex"><a href="#5-5-flex" class="headerlink" title="5.5 flex"></a>5.5 flex</h2><ul>
<li><code>&lt;flex-grow&gt; &lt;flex-shrink&gt;? || &lt;flex-basis&gt;</code><ul>
<li>是flex-grow, flex-shrink 和 flex-basis的简写</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>0 1 auto</code>（默认）</td>
<td>即三个属性分别的默认值</td>
</tr>
<tr>
<td><code>auto</code></td>
<td>相当于 <code>1 1 auto</code></td>
</tr>
<tr>
<td><code>none</code></td>
<td>相当于 <code>0 0 auto</code></td>
</tr>
</tbody></table>
<h2 id="5-6-align-self"><a href="#5-6-align-self" class="headerlink" title="5.6 align-self"></a>5.6 align-self</h2><ul>
<li>交叉轴上单个项目对齐方式</li>
<li>覆盖已有的 <code>align-items</code> 的值. 如果项目的交叉轴方向 margin 值设置为 auto，则会忽略<code>align-self</code></li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code>（默认）</td>
<td>设置为父元素的 <code>align-items</code> 值，如果该元素没有父元素的话，就设置为 <code>stretch</code></td>
</tr>
<tr>
<td><code>strech</code></td>
<td>如果项目未设置高度或设为auto，将占满整个容器的高度</td>
</tr>
<tr>
<td><code>flex-start</code></td>
<td>交叉轴的起点对齐</td>
</tr>
<tr>
<td><code>flex-end</code></td>
<td>交叉轴的终点对齐</td>
</tr>
<tr>
<td><code>center</code></td>
<td>交叉轴的中点对齐</td>
</tr>
<tr>
<td><code>baseline</code></td>
<td>项目的第一行文字的基线对齐</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>UI</category>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>CSS 浮动和定位</title>
    <url>/anyeansan.github.io/2020/03/30/CSS-%E6%B5%AE%E5%8A%A8%E5%92%8C%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="一-浮动"><a href="#一-浮动" class="headerlink" title="一 浮动"></a>一 浮动</h1><h2 id="1-1-float"><a href="#1-1-float" class="headerlink" title="1.1 float"></a>1.1 float</h2><table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>left</code></td>
<td>左浮动</td>
</tr>
<tr>
<td><code>right</code></td>
<td>右浮动</td>
</tr>
<tr>
<td><code>none</code></td>
<td>无浮动</td>
</tr>
</tbody></table>
<h2 id="1-2-浮动的特性"><a href="#1-2-浮动的特性" class="headerlink" title="1.2 浮动的特性"></a>1.2 浮动的特性</h2><h3 id="1-包裹性"><a href="#1-包裹性" class="headerlink" title="1 包裹性"></a>1 包裹性</h3><ul>
<li>包裹和自适应（类似<code>width: fit-content</code>）</li>
</ul>
<h3 id="2-块状化并格式化上下文"><a href="#2-块状化并格式化上下文" class="headerlink" title="2 块状化并格式化上下文"></a>2 块状化并格式化上下文</h3><ul>
<li>元素display值<ul>
<li><code>inline-table</code>会变成<code>table</code>，</li>
<li>其它都会变成<code>block</code></li>
</ul>
</li>
</ul>
<h3 id="3-破坏文档流"><a href="#3-破坏文档流" class="headerlink" title="3 破坏文档流"></a>3 破坏文档流</h3><ol>
<li>元素浮动会脱离文档路，尽量向左上或右上浮动，直到遇到父元素的边框或者其它浮动元素</li>
<li>假如元素A浮动，如果A元素上一个元素<ul>
<li>也是浮动的，那么A会跟在上一个元素后边（一行放不下则A会被挤到下一行）</li>
<li>是标准文档流中的元素，那么A的相对垂直位置不变，即元素A的顶部与上一个元素底部对齐。</li>
</ul>
</li>
</ol>
<h3 id="4-没有任何-margin-合并"><a href="#4-没有任何-margin-合并" class="headerlink" title="4 没有任何 margin 合并"></a>4 没有任何 margin 合并</h3><h2 id="1-3-文字环绕的机制"><a href="#1-3-文字环绕的机制" class="headerlink" title="1.3 文字环绕的机制"></a>1.3 文字环绕的机制</h2><ul>
<li>浮动的本质就是为了实现文字环绕效果</li>
</ul>
<h3 id="1-父元素的高度塌陷"><a href="#1-父元素的高度塌陷" class="headerlink" title="1 父元素的高度塌陷"></a>1 父元素的高度塌陷</h3><ul>
<li>为了让文字内容可以和浮动元素在一个水平线上</li>
</ul>
<h3 id="2-行框盒子和浮动元素的不可重叠性"><a href="#2-行框盒子和浮动元素的不可重叠性" class="headerlink" title="2 行框盒子和浮动元素的不可重叠性"></a>2 行框盒子和浮动元素的不可重叠性</h3><ul>
<li>行框盒子如果和浮动元素的垂直高度有重叠，则行框盒子在正常定位状态下只会跟随浮动元素，而不会发生重叠</li>
</ul>
<h2 id="1-4-clear"><a href="#1-4-clear" class="headerlink" title="1.4 clear"></a>1.4 clear</h2><table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code>（默认）</td>
<td>允许浮动元素出现在两侧。</td>
</tr>
<tr>
<td><code>left</code></td>
<td>在左侧不允许浮动元素。</td>
</tr>
<tr>
<td><code>right</code></td>
<td>在右侧不允许浮动元素。</td>
</tr>
<tr>
<td><code>both</code></td>
<td>在左右两侧均不允许浮动元素。</td>
</tr>
<tr>
<td>1. 清除浮动原因</td>
<td></td>
</tr>
<tr>
<td>* 浮动脱离文档流，只含有浮动元素的父容器，在显示时不考虑浮动子元素的位置，父元素高度会塌陷</td>
<td></td>
</tr>
<tr>
<td>2. <strong>css的清除浮动只能影响清除浮动的元素本身，无法影响其它元素</strong>。</td>
<td></td>
</tr>
<tr>
<td>3. clear 属性只有块级元素才有效的，而::after 等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置 display 属性值的原因</td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-5-清除浮动的方式"><a href="#1-5-清除浮动的方式" class="headerlink" title="1.5 清除浮动的方式"></a>1.5 清除浮动的方式</h2><h3 id="1-clear"><a href="#1-clear" class="headerlink" title="1 clear"></a>1 clear</h3><h4 id="1-父元素定义height（不推荐）"><a href="#1-父元素定义height（不推荐）" class="headerlink" title="1 父元素定义height（不推荐）"></a>1 父元素定义height（不推荐）</h4><ul>
<li>父级元素显式定义高度，就解决了无法自动获取到高度的问题</li>
<li>缺点<ul>
<li>只适合高度固定时使用</li>
</ul>
</li>
</ul>
<h4 id="2-父元素末尾添加一个空标签用来清除浮动（不推荐）"><a href="#2-父元素末尾添加一个空标签用来清除浮动（不推荐）" class="headerlink" title="2 父元素末尾添加一个空标签用来清除浮动（不推荐）"></a>2 父元素末尾添加一个空标签用来清除浮动（不推荐）</h4><ul>
<li>空标签清除两侧浮动，不受浮动元素影响，所在高度不会变，父元素就能获取高度</li>
<li>缺点<ul>
<li>会添加不必要的标签</li>
</ul>
</li>
</ul>
<h4 id="3-使用父元素的伪元素来清除浮动（推荐）"><a href="#3-使用父元素的伪元素来清除浮动（推荐）" class="headerlink" title="3 使用父元素的伪元素来清除浮动（推荐）"></a>3 使用父元素的伪元素来清除浮动（推荐）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">父元素::after &#123;</span><br><span class="line">	content: &apos;&apos;;</span><br><span class="line">	display: block; // clear只对块级元素有效，伪元素默认为内联元素</span><br><span class="line">	clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-触发BFC"><a href="#2-触发BFC" class="headerlink" title="2 触发BFC"></a>2 触发BFC</h3><ol>
<li><code>display: flow-root</code></li>
<li><code>overflow: hidden</code></li>
</ol>
<h4 id="1-BFC概念"><a href="#1-BFC概念" class="headerlink" title="1 BFC概念"></a>1 BFC概念</h4><ul>
<li><code>Block Formatting Context</code>  块级格式化上下文</li>
<li>所谓的BFC就是css布局的一个概念，是一块区域，一个环境。另外还有IFC（inline formattion context），GFC（grid formattion context）</li>
<li>BFC会形成一个隔离的独立容器，容器里面的子元素不会影响到外面的元素；外面的元素也不会影响到容器里面的子元素</li>
</ul>
<h4 id="2-BFC触发条件"><a href="#2-BFC触发条件" class="headerlink" title="2 BFC触发条件"></a>2 BFC触发条件</h4><ol>
<li>根元素 <code>&lt;html&gt;</code> </li>
<li>浮动元素（元素的 float 不是 none）</li>
<li>绝对定位元素（元素的 position 为 absolute 或 fixed）</li>
<li>内联块元素（display: inline-block）</li>
<li>表格单元格或标题（display: table-cell / table-caption）</li>
<li>具有overflow 且值不是 visible 的块元素</li>
<li>display: flow-root</li>
</ol>
<h4 id="3-BFC功能"><a href="#3-BFC功能" class="headerlink" title="3 BFC功能"></a>3 BFC功能</h4><h5 id="1-两列自适应布局"><a href="#1-两列自适应布局" class="headerlink" title="1 两列自适应布局"></a>1 两列自适应布局</h5><ul>
<li>图文排列时，图片左浮动，就形成文字环绕</li>
<li>此时如果文字容器触发BFC，则在垂直方向上，文字不会越过图片右边，形成左边宽度固定，右边宽度自适应的布局</li>
</ul>
<h5 id="2-清除浮动影响"><a href="#2-清除浮动影响" class="headerlink" title="2 清除浮动影响"></a>2 清除浮动影响</h5><ul>
<li>正常情况下，浮动元素会脱离文档流，BFC会阻止浮动超出BFC区域</li>
</ul>
<h5 id="3-解决相邻元素margin合并"><a href="#3-解决相邻元素margin合并" class="headerlink" title="3 解决相邻元素margin合并"></a>3 解决相邻元素margin合并</h5><ul>
<li>两个相邻的块级元素在垂直方向存在margin合并的问题</li>
<li>如果这两个相邻的块级元素不属于同一个BFC就不会合并！</li>
</ul>
<h1 id="二-定位"><a href="#二-定位" class="headerlink" title="二 定位"></a>二 定位</h1><h2 id="2-1-position"><a href="#2-1-position" class="headerlink" title="2.1 position"></a>2.1 position</h2><table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static</code>（默认）</td>
<td>静态定位</td>
</tr>
<tr>
<td><code>relative</code></td>
<td>相对定位</td>
</tr>
<tr>
<td><code>absolute</code></td>
<td>绝对定位</td>
</tr>
<tr>
<td><code>fixed</code></td>
<td>固定定位</td>
</tr>
<tr>
<td><code>sticky</code></td>
<td>粘性定位</td>
</tr>
</tbody></table>
<h3 id="1-static"><a href="#1-static" class="headerlink" title="1 static"></a>1 static</h3><ul>
<li>元素出现在正常的流中（忽略 top, bottom, left, right 和 z-index ）。</li>
</ul>
<h3 id="2-relative-amp-absolute-amp-fixed"><a href="#2-relative-amp-absolute-amp-fixed" class="headerlink" title="2 relative &amp; absolute &amp; fixed"></a>2 relative &amp; absolute &amp; fixed</h3><ol>
<li>这三种定位有一个共同点，都是相对于某个基点的定位，不同之处仅仅在于基点不同</li>
<li>这三种定位都不会对其他元素的位置产生影响，因此元素之间可能产生重叠 （z-index）</li>
<li>必须搭配top、bottom、left、right这四个属性一起使用，用来指定偏移的方向和距离。如果不设置偏移，元素在默认位置（static时的位置）</li>
</ol>
<h2 id="2-2-relative"><a href="#2-2-relative" class="headerlink" title="2.2 relative"></a>2.2 relative</h2><ol>
<li>相对于默认位置（static时的位置）进行偏移，即定位基点是元素的默认位置，也可以认为是相对于自身定位</li>
<li>相对定位的元素先放置在未添加定位时的位置（不会脱离文档流），然后在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白，即还会占据原文档流位置）</li>
</ol>
<h2 id="2-3-absolute"><a href="#2-3-absolute" class="headerlink" title="2.3 absolute"></a>2.3 absolute</h2><ol>
<li>相对于离它最近的非static定位的祖先元素（一般是父元素）进行偏移，即定位基点是最近的非static定位的祖先元素<ol>
<li>元素会向上级依次寻找直到找到非static定位的祖先元素</li>
<li>如果所有上级元素都没有开启定位，则相对于根元素html定位（并非浏览器窗口）</li>
</ol>
</li>
<li>绝对定位元素会被移出正常文档流，并不为元素预留空间</li>
<li>绝对定位会随着滚动条滚动</li>
</ol>
<h2 id="2-4-fixed"><a href="#2-4-fixed" class="headerlink" title="2.4 fixed"></a>2.4 fixed</h2><ol>
<li>相对于视口（viewport，浏览器窗口）进行偏移，即定位基点是浏览器窗口</li>
<li>固定定位元素会被移出正常文档流，并不为元素预留空间</li>
<li>固定定位元素的位置不随页面滚动而变化，好像固定在网页上一样</li>
<li>固定定位可以看作绝对定位的一种</li>
</ol>
<h2 id="2-5-sticky"><a href="#2-5-sticky" class="headerlink" title="2.5 sticky"></a>2.5 sticky</h2><ol>
<li>sticky会产生动态效果，很像relative和fixed的结合：一些时候是relative定位（定位基点是自身默认位置），另一些时候自动变成fixed定位（定位基点是视口）</li>
<li>sticky生效的前提是，必须搭配top、bottom、left、right这四个属性中的一个或多个一起使用（看滚动方向），不能省略，否则等同于relative定位，不产生”动态固定”的效果</li>
<li>不能有任何祖先元素设置overflow:hidden，否则没有粘滞效果。因为改变了滚动容器（即使没有出现滚动条）</li>
<li>父元素的高度不能低于sticky元素的高度</li>
<li>sticky元素仅在其父元素内生效，不会超出父元素，滚动时会随着父元素一起消失</li>
<li>当页面滚动，父元素开始脱离视口时（即部分不可见），只要与sticky元素的距离达到生效门槛（设置的top/bottom/left/right），relative定位自动切换为fixed定位，等到父元素完全脱离视口时，fixed定位恢复成relative定位</li>
<li>同一个父容器中的sticky元素，如果定位值相等，则会重叠；如果属于不同父元素，则会随着父元素不再完整占据sticky元素的固定区域以后，再由其他父元素的sticky子元素占据固定位置</li>
<li>我的理解就是设置了粘性定位的元素，没到达所设置的偏移量时，为相对定位，到达后就变为固定定位，但只局限在父元素在视口内，如果父元素都滚走了，也会一同滚走（当然此时为相对定位）</li>
</ol>
]]></content>
      <categories>
        <category>UI</category>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>CSS 内联盒模型</title>
    <url>/anyeansan.github.io/2020/03/30/CSS-%E5%86%85%E8%81%94%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="一-基本组成"><a href="#一-基本组成" class="headerlink" title="一 基本组成"></a>一 基本组成</h1><h2 id="1-1-内容区域-content-area"><a href="#1-1-内容区域-content-area" class="headerlink" title="1.1 内容区域 content area"></a>1.1 内容区域 <code>content area</code></h2><ul>
<li>文字，内容区域可以理解为选中文字时的区域<ul>
<li>content area 高度由font-size和font-family决定。font-family为simsun(宋体)时，content area高度 = font-size</li>
</ul>
</li>
<li>图片这样的替换元素，内容区域可以看成元素自身</li>
</ul>
<h2 id="1-2-内联盒子-inline-box"><a href="#1-2-内联盒子-inline-box" class="headerlink" title="1.2 内联盒子 inline box"></a>1.2 内联盒子 <code>inline box</code></h2><ul>
<li>内联盒子<ul>
<li>内联元素</li>
</ul>
</li>
<li>匿名内联盒子<ul>
<li>纯文本</li>
<li>注意：并不是所有光秃秃的文字都是“匿名内联盒子”，其还有可能是“匿名块级盒子”，关键要看前后的标签是内联还是块级</li>
</ul>
</li>
</ul>
<h2 id="1-3-行框盒子-line-box"><a href="#1-3-行框盒子-line-box" class="headerlink" title="1.3 行框盒子 line box"></a>1.3 行框盒子 <code>line box</code></h2><ul>
<li>由一个一个“内联盒子”组成的一行就是行框盒子</li>
<li>行框盒子的高度是由高度最高的那个“内联盒子”决定</li>
</ul>
<h2 id="1-4-空白幽灵节点-strut"><a href="#1-4-空白幽灵节点-strut" class="headerlink" title="1.4 空白幽灵节点 strut"></a>1.4 空白幽灵节点 <code>strut</code></h2><ul>
<li>每个 line-box 起始位置都有一个具有该元素的字体和行高属性的 0 宽度的内联盒，此内联盒叫做<code>strut</code>（支柱）。 </li>
<li>永远透明，无法获取，表现如同文本节点一样</li>
<li>看不见的字符，看得见的影响</li>
</ul>
<h1 id="二-相关概念"><a href="#二-相关概念" class="headerlink" title="二 相关概念"></a>二 相关概念</h1><p><img src="https://gitee.com/3noanswer/npics/raw/master/UI/CSS/x.svg" alt=""></p>
<h2 id="2-1-基线"><a href="#2-1-基线" class="headerlink" title="2.1 基线"></a>2.1 基线</h2><ol>
<li>文本内联元素的基线就是小写x的下边缘</li>
<li>类似图片这样的元素的基线就是其下边缘</li>
<li><code>inline-block</code> 元素<ol>
<li>如果该元素里面没有inline内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘</li>
<li>如果该元素中有内联元素，则该元素的基线就是最后一行内联元素的基线</li>
</ol>
</li>
</ol>
<h2 id="2-2-x-height"><a href="#2-2-x-height" class="headerlink" title="2.2 x-height"></a>2.2 x-height</h2><ul>
<li>x-height 指的就是小写字母 x 的高度，术语描述就是基线和等分线（mean line）（也称作中线，midline）之间的距离</li>
<li>ex 是 CSS 中的一个相对单位，指的是小写字母 x 的高度，即 x-height</li>
</ul>
<h2 id="2-3-高度相关"><a href="#2-3-高度相关" class="headerlink" title="2.3 高度相关"></a>2.3 高度相关</h2><ol>
<li>line-height：两行文字基线之间的距离</li>
<li>文字本身的高度（即文字上下边缘的高度）+ 一些高度 = content area 的高度（即上行线<code>ascent</code>与下行线<code>descent</code>的高度）<ul>
<li>即文字距离content area 上下是有距离的（你选中文字时，文字上下跟背景上下是有距离的）</li>
<li>也能看出content area 是跟字体大小和字体类型有关的</li>
<li>font-family 为 simsun（宋体）时，content area的高度等于font-size（font-size跟文字本身的高度不是一个概念）</li>
</ul>
</li>
<li>content area 的高度 + 行距（上下等分）= 行高</li>
<li>可以近似认为 <code>font-size + 行距 = line-height</code></li>
<li><code>行距 = line-height - font size</code><ul>
<li>当行高和字体大小相等时，行距为0，此时是两行的content area挨在了一起（并不是文字下边缘与下一行文字上边缘挨在了一起）</li>
</ul>
</li>
</ol>
<h2 id="2-4-line-height"><a href="#2-4-line-height" class="headerlink" title="2.4 line-height"></a>2.4 line-height</h2><ol>
<li>对于非替换内联元素，其可视高度完全由 line-height 决定。padding、border 属性对可视高度是没有任何影响的<ul>
<li>对非替换内联元素设置line-height，只是它自己的line-height，最终高度还要看行框盒子内其它内联盒子的line-height</li>
</ul>
</li>
<li>对于替换元素，line-height无影响</li>
<li>对于块级元素，line-height 对其本身是没有任何作用的，块级元素的高度跟着变化实际上是通过改变块级元素里面内联级别元素占据的高度实现的</li>
</ol>
<h2 id="2-5-vertical-align"><a href="#2-5-vertical-align" class="headerlink" title="2.5 vertical-align"></a>2.5 vertical-align</h2><ol>
<li>用来指定内联元素（inline/inline-block/inline-table）或表格单元格（table-cell）元素的垂直对齐方式</li>
<li>内联元素默认都会受到line-height和vertical-align的影响</li>
<li><code>vertical-align:middle</code><ul>
<li>middle 与中线 midline不同，指的是基线往上 1/2 x-height 高度，可以近似理解为字母 x 交叉点那个位置</li>
</ul>
</li>
</ol>
<h3 id="相对其父元素垂直对齐"><a href="#相对其父元素垂直对齐" class="headerlink" title="相对其父元素垂直对齐"></a>相对其父元素垂直对齐</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>baseline</code>（默认）</td>
<td>使元素的基线与父元素的基线对齐</td>
</tr>
<tr>
<td><code>sub</code></td>
<td>使元素的基线与父元素的下标基线对齐</td>
</tr>
<tr>
<td><code>super</code></td>
<td>使元素的基线与父元素的上标基线对齐</td>
</tr>
<tr>
<td><code>text-top</code></td>
<td>使元素的顶部与父元素的字体顶部对齐</td>
</tr>
<tr>
<td><code>text-bottom</code></td>
<td>使元素的底部与父元素的字体底部对齐</td>
</tr>
<tr>
<td><code>middle</code></td>
<td>使元素的中部与父元素的基线加上父元素x-height的一半对齐</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>使元素的基线对齐到父元素的基线之上的给定长度。可以是负数</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>使元素的基线对齐到父元素的基线之上的给定百分比，该百分比是line-height属性的百分比。可以是负数</td>
</tr>
</tbody></table>
<h3 id="相对整行垂直对齐"><a href="#相对整行垂直对齐" class="headerlink" title="相对整行垂直对齐"></a>相对整行垂直对齐</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>top</code></td>
<td>使元素及其后代元素的顶部与整行的顶部对齐</td>
</tr>
<tr>
<td><code>bottom</code></td>
<td>使元素及其后代元素的底部与整行的底部对齐</td>
</tr>
</tbody></table>
<h1 id="三-对几个现象的理解"><a href="#三-对几个现象的理解" class="headerlink" title="三 对几个现象的理解"></a>三 对几个现象的理解</h1><h2 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;span&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/3noanswer/npics/raw/master/UI/CSS/lh_va1-1.png" alt=""></p>
<ul>
<li>div的高度为0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;span style=&quot;display: inline-block;&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/3noanswer/npics/raw/master/UI/CSS/lh_va1-2.png" alt=""></p>
<ul>
<li>div的高度不为0<ul>
<li>因为div内部span形成了行框盒子，行框盒子起始位置有幽灵节点strut，行高默认值为normal，是有行高的，行高作用在strut上，就撑起了div的高度</li>
</ul>
</li>
</ul>
<h3 id="我的结论"><a href="#我的结论" class="headerlink" title="我的结论"></a>我的结论</h3><ol>
<li>inline 内联元素形成行框盒子的是内部的文字，如果内部为空，就形不成行框盒子</li>
<li>inline-block 内联元素形成行框盒子的是元素本身，内部为空也能形成行框盒子</li>
</ol>
<h2 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">	div &#123;</span><br><span class="line">		background: #ddd;</span><br><span class="line">		border: 1px solid #000;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;img src=&quot;mm.jpg&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/3noanswer/npics/raw/master/UI/CSS/lh_va2-1.png" alt=""></p>
<ul>
<li>底部有空隙的原因<ol>
<li>img形成了行框盒子，所以出现了strut</li>
<li>vertical-align默认为base-line对齐，strut的base-line为x的下边缘，img的base-line为底部</li>
<li>文本占的空间是<code>content area的高度 + 行距 = 行高</code>，并不是文字的上下边缘。所以图片下边才会有空隙</li>
</ol>
</li>
<li>在图片前边添加文本效果是一样的<br><img src="https://gitee.com/3noanswer/npics/raw/master/UI/CSS/lh_va2-2.png" alt=""></li>
</ul>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><ol>
<li>img块级化，vertical-align对块级元素无效（且没有了行框盒子）</li>
<li>修改vertical-align为其他值比如<code>bottom top middle ...</code><ul>
<li>比如bottom，此时，是文字占据的空间的下边缘与图片下边缘对齐</li>
</ul>
</li>
<li>减小line-height的值<ul>
<li>减小line-height 也就是在减小行距，当line-height与font-size相等时，行距为0</li>
<li>行距为0时，文本占据的空间就是content area，此时文字本身距离content area的上下边缘还有一些距离，也就是图片距离底部的空隙<br><img src="https://gitee.com/3noanswer/npics/raw/master/UI/CSS/lh_va2-3.png" alt=""></li>
<li>继续减小line-height直到文字base-line到达底部</li>
</ul>
</li>
</ol>
<h2 id="3-3-单行文本垂直居中"><a href="#3-3-单行文本垂直居中" class="headerlink" title="3.3 单行文本垂直居中"></a>3.3 单行文本垂直居中</h2><ul>
<li>设置<code>line-height</code> 的值与 <code>height</code>值相等即可<ul>
<li>因为行距上下等分原则，所以行高与高度相等时，文本自然在中间</li>
</ul>
</li>
</ul>
<h2 id="3-4-多行文本垂直居中"><a href="#3-4-多行文本垂直居中" class="headerlink" title="3.4 多行文本垂直居中"></a>3.4 多行文本垂直居中</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">	div &#123;</span><br><span class="line">		width: 300px;</span><br><span class="line">		height: 300px;</span><br><span class="line">		line-height: 300px;</span><br><span class="line">	&#125;</span><br><span class="line">	span &#123;</span><br><span class="line">		display: inline-block;</span><br><span class="line">		vertical-align: middle;</span><br><span class="line">		line-height: 20px;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;span&gt;很多文字...&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>设置div的<code>line-height</code>与<code>height</code>值相等<ul>
<li>把行高区域和高度区域都想象成一个盒子，两个区域高度相等重合了，那么在行高里边的元素设置居中在高度区域自然也是居中的</li>
</ul>
</li>
<li>span设置<code>display: inline-block</code> 和 <code>vertical-align: middle</code>，并且设置一个合适的 <code>line-height</code></li>
</ol>
<h3 id="为何span要设置display-inline-block"><a href="#为何span要设置display-inline-block" class="headerlink" title="为何span要设置display: inline-block ?"></a>为何span要设置<code>display: inline-block</code> ?</h3><ul>
<li>span的display为默认的inline时，形成行框盒子的是span的内容，由于div的line-height会作用于行框盒子的strut，且div的line-height大于span的line-height，所以行框应用的是div的line-height，也就是说span的内容应用的是div的line-height，就会导致文字行距很大</li>
<li>span的display设置为line-block时，形成行框盒子的是span本身，span的内部还会形成一个行框盒子，这时span设置的line-height就会对内部的行框盒子起作用，即span应用的是div的line-height，sanp的内容应用的是span自身的line-height，所以文字就能正常显示</li>
</ul>
]]></content>
      <categories>
        <category>UI</category>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>CSS 盒子模型</title>
    <url>/anyeansan.github.io/2020/03/30/CSS-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="一-组成"><a href="#一-组成" class="headerlink" title="一 组成"></a>一 组成</h1><p><img src="https://gitee.com/3noanswer/npics/raw/master/UI/CSS/css%E7%9B%92%E6%A8%A1%E5%9E%8B.gif" alt=""></p>
<ul>
<li>指内部盒子（容器盒子）的模型</li>
</ul>
<h2 id="1-1-content-box"><a href="#1-1-content-box" class="headerlink" title="1.1 content box"></a>1.1 content box</h2><h3 id="1-content"><a href="#1-content" class="headerlink" title="1 content"></a>1 content</h3><ul>
<li>content 属性插入的内容都是匿名替换元素</li>
<li>content 属性通常用在<code>::before / ::after</code> 这两个伪元素中</li>
<li>content 属性生成的内容特点<ol>
<li>content 生成的文本是无法选中、无法复制的</li>
<li>content 无法影响<code>:empty</code> 选择器（即有content还是适配<code>:empty</code>）</li>
<li>content 动态生成值无法获取<ul>
<li>如计数器</li>
</ul>
</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code></td>
<td>不会产生伪元素</td>
</tr>
<tr>
<td><code>normal</code></td>
<td><code>::before</code>和<code>::after</code> 中会被当作none</td>
</tr>
<tr>
<td><code>&lt;string&gt;</code></td>
<td>字符串（数字，字符，unicode码）</td>
</tr>
<tr>
<td><code>&lt;url&gt;</code></td>
<td>图片可以是png、jpg、ico、svg文件以及 base64URL，但不支持 CSS3 渐变背景图</td>
</tr>
<tr>
<td><code>attr()</code></td>
<td>获取原生html属性或者自定义属性的值，属性不要加引号</td>
</tr>
<tr>
<td><code>&lt;counter&gt;</code></td>
<td>计数器</td>
</tr>
<tr>
<td><code>open-quote / close-quote</code></td>
<td>开闭引号</td>
</tr>
<tr>
<td><code>no-open-quote / no-close-quote</code></td>
<td>不要开闭引号</td>
</tr>
</tbody></table>
<h4 id="1-content-辅助元素生成"><a href="#1-content-辅助元素生成" class="headerlink" title="1 content 辅助元素生成"></a>1 content 辅助元素生成</h4><ul>
<li>核心点不在于 content 生成的内容，而是伪元素本身，如 最常用的清除浮动</li>
<li>注：content生成的是匿名替换元素，替换元素都是内联元素，clear只能用在块级元素上，所以要改变dislay</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.clear::after &#123;</span><br><span class="line">	content: &apos;&apos;;</span><br><span class="line">	display: block; </span><br><span class="line">	clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-计数器"><a href="#2-计数器" class="headerlink" title="2 计数器"></a>2 计数器</h4><ol>
<li>counter-reset<ul>
<li><code>[ &lt;custom-ident&gt; &lt;integer&gt;? ]+ | none</code><ul>
<li><code>&lt;cutom-ident&gt;</code> 自定义计数器名称</li>
<li><code>&lt;integer&gt;</code> 每次出现元素时将计数器重置为的值（可以理解为初始值），默认为0</li>
</ul>
</li>
</ul>
</li>
<li>counter-increment<ul>
<li><code>[ &lt;custom-ident&gt; &lt;integer&gt;? ]+ | none</code><ul>
<li><code>&lt;cutom-ident&gt;</code> 指定使用递增规则的计数器名称</li>
<li><code>&lt;integer&gt;</code> 定义递增的值，默认为1</li>
</ul>
</li>
</ul>
</li>
<li>counter()<ul>
<li><code>counter(counterName, style)</code><ul>
<li>用来显示计数，显示的是序号如<code>1 2 3 ...</code></li>
<li>style即 list-style-type 支持的值，默认是数字</li>
</ul>
</li>
<li><code>counter()</code>，<code>counters()</code></li>
</ul>
</li>
<li>counters()<ul>
<li><code>counters(counterName, string, style)</code><ul>
<li>用来显示计数，显示的是子序号如 <code>1.1 1.2 2.1 2.2 2.2.1 ...</code></li>
<li>string用来指定序号和子序号之间的符号，如<code>.</code>或<code>-</code> 生成的 <code>1.1</code>或<code>1-1</code></li>
<li>注意如果想要嵌套成功，每一层的序号都要有定义<code>counter-reset</code>的容器包裹</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="3-content-开启闭合符号生成"><a href="#3-content-开启闭合符号生成" class="headerlink" title="3  content 开启闭合符号生成"></a>3  content 开启闭合符号生成</h4><ul>
<li><code>open-quote close-quote</code> 关键字意思为开引号，闭引号，即默认为引号。可以通过 <code>quotes</code> 指定开闭符号内容</li>
<li>quotes<ul>
<li><code>none | auto | [ &lt;string&gt; &lt;string&gt; ]+</code></li>
</ul>
</li>
</ul>
<h6 id="4-content-混合内容"><a href="#4-content-混合内容" class="headerlink" title="4 content 混合内容"></a>4 content 混合内容</h6><ul>
<li>即各种值可以混合使用，用空格隔开</li>
</ul>
<h3 id="2-width"><a href="#2-width" class="headerlink" title="2 width"></a>2 width</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code>（默认）</td>
<td>浏览器将会为指定的元素计算并选择一个宽度.</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>指定值</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>指定为包含块宽度的百分比</td>
</tr>
<tr>
<td><code>fill-available</code></td>
<td>元素宽度自动填满可用空间</td>
</tr>
<tr>
<td><code>fit-content</code></td>
<td>元素宽度包裹内容，文本内容正常换行。如浮动、绝对定位、inline-block 元素或 table 元素</td>
</tr>
<tr>
<td><code>min-content</code></td>
<td>元素宽度为内部元素”首选最小宽度”最大的那一行的宽度</td>
</tr>
<tr>
<td><code>max-content</code></td>
<td>元素宽度为内部元素宽度值最大的那个元素的宽度</td>
</tr>
</tbody></table>
<h4 id="1-min-content-首选最小宽度"><a href="#1-min-content-首选最小宽度" class="headerlink" title="1 min-content 首选最小宽度"></a>1 min-content 首选最小宽度</h4><ul>
<li>指的是元素最适合的最小宽度</li>
<li>类似图片这样的替换元素的最小宽度就是该元素内容本身的宽度</li>
<li>文本<ul>
<li>CJK（中日韩）可以任意断行，最小宽度就是每个字符的宽度</li>
<li>non-CJK一般在空格、短横线、问号以及其他非英文字符等断行，最小宽度由连续的英文字符单元决定</li>
</ul>
</li>
</ul>
<h4 id="2-fit-content-和-max-content-区别"><a href="#2-fit-content-和-max-content-区别" class="headerlink" title="2 fit-content 和 max-content 区别"></a>2 fit-content 和 max-content 区别</h4><ul>
<li>两者的元素宽度其实都是内部元素最大的那个宽度</li>
<li>区别在于fit-content内部元素文字可以正常换行，而max-content内部元素文字不换行</li>
</ul>
<h4 id="3-CSS-流体布局下的宽度分离原则"><a href="#3-CSS-流体布局下的宽度分离原则" class="headerlink" title="3 CSS 流体布局下的宽度分离原则"></a>3 CSS 流体布局下的宽度分离原则</h4><ul>
<li>宽度分离原则即CSS 中的 width 属性不与影响宽度的 padding/border（有时候包括 margin）属性共存</li>
<li>应该width 独立占用一层标签，而padding、border、margin 利用流动性在内部自适应呈现</li>
</ul>
<h3 id="3-height"><a href="#3-height" class="headerlink" title="3 height"></a>3 height</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code>（默认）</td>
<td>浏览器将会为指定的元素计算并选择一个高度.</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>指定值</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>指定为包含块高度的百分比</td>
</tr>
<tr>
<td><code>fill-available</code></td>
<td>充分利用可用空间</td>
</tr>
<tr>
<td><code>fit-content</code></td>
<td>收缩到包裹内容</td>
</tr>
<tr>
<td><code>min-content</code></td>
<td>收缩到最小</td>
</tr>
<tr>
<td><code>max-content</code></td>
<td>最大内容高度</td>
</tr>
</tbody></table>
<h4 id="height-百分比"><a href="#height-百分比" class="headerlink" title="height: 百分比"></a>height: 百分比</h4><ul>
<li>对于普通文档流中的元素，百分比高度值要想起作用，其祖先级元素中必须有一个可以生效的高度值<ol>
<li>设定显式的高度值<ul>
<li>普通文档流中宽高百分比是相对于父元素也就是 content box的</li>
</ul>
</li>
<li>使用绝对定位<ul>
<li>绝对定位的宽高百分比计算是相对于 padding box 的</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="4-min-width-max-width-和-min-height-max-height"><a href="#4-min-width-max-width-和-min-height-max-height" class="headerlink" title="4 min-width / max-width 和 min-height / max-height"></a>4 min-width / max-width 和 min-height / max-height</h3><h4 id="1-与众不同的初始值"><a href="#1-与众不同的初始值" class="headerlink" title="1 与众不同的初始值"></a>1 与众不同的初始值</h4><ul>
<li>width / height 的默认值是 auto</li>
<li>min-width / min-height 的默认值是auto（w3c/mdn上是0）</li>
<li>max-width / max-height的默认值是none</li>
</ul>
<h4 id="2-权重（width-height-规则相同）"><a href="#2-权重（width-height-规则相同）" class="headerlink" title="2 权重（width / height 规则相同）"></a>2 权重（width / height 规则相同）</h4><ol>
<li>width，min-width，max-width只有其中一个，则最终宽度为其值</li>
<li>有width 和 max-width，则最终宽度不能大于max-width<ul>
<li><code>width &lt; max-width</code> 时，最终宽度为width的值</li>
<li><code>width &gt; max-widht</code> 时，最终宽度为max-width的值</li>
</ul>
</li>
</ol>
<ul>
<li>有width 和 min-width，则最终宽度不能小于min-width<ul>
<li><code>width &gt; min-width</code> 时，最终宽度为width的值</li>
<li><code>width &lt; min-widht</code> 时，最终宽度为min-width的值</li>
</ul>
</li>
<li>有min-width和max-width，则最终宽度为二者中较大的那个值<ul>
<li><code>min-width &lt; max-width</code> 时，则最终宽度为max-width的值</li>
<li><code>min-width &gt; max-width</code> 时，则最终宽度为min-width的值</li>
</ul>
</li>
<li>有width，min-width，max-width<ul>
<li><code>min-width &gt; max-width</code>，无论width值如何，最终宽度都是min-width的值</li>
<li><code>min-width &lt; max-width</code>，根据width取值，最终宽度在最小和最大宽度之间<ul>
<li><code>width &lt; min-width &lt; max-width</code>，则最终宽度为min-width的值</li>
<li><code>min-width &lt; width &lt; max-width</code>，则最终宽度为width的值</li>
<li><code>min-width &lt; max-width &lt; width</code>，则最终宽度为max-width的值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-2-padding-box"><a href="#1-2-padding-box" class="headerlink" title="1.2 padding box"></a>1.2 padding box</h2><h3 id="1-padding"><a href="#1-padding" class="headerlink" title="1 padding"></a>1 padding</h3><ul>
<li>padding 对于块级元素有影响</li>
<li>padding 对于替换元素有影响</li>
<li>padding 对于非替换内联元素，水平方向有影响，垂直方向不改变元素高度，但是改变背景高度</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;length&gt;</code></td>
<td>指定值</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>相对于宽度的百分比</td>
</tr>
<tr>
<td>* 一个值：同时设置四个边内边距</td>
<td></td>
</tr>
<tr>
<td>* 二个值：<code>上下 左右</code></td>
<td></td>
</tr>
<tr>
<td>* 三个值：<code>上 左右 下</code></td>
<td></td>
</tr>
<tr>
<td>* 四个值：<code>上 右 下 左</code></td>
<td></td>
</tr>
</tbody></table>
<h3 id="2-每个边的padding属性"><a href="#2-每个边的padding属性" class="headerlink" title="2 每个边的padding属性"></a>2 每个边的padding属性</h3><ol>
<li><code>padding-top</code></li>
<li><code>padding-right</code></li>
<li><code>padding-bottom</code></li>
<li><code>padding-left</code></li>
</ol>
<h2 id="1-3-border-box"><a href="#1-3-border-box" class="headerlink" title="1.3 border box"></a>1.3 border box</h2><h3 id="1-border"><a href="#1-border" class="headerlink" title="1 border"></a>1 border</h3><ul>
<li><code>boder-color || boder-style || border-width</code></li>
</ul>
<h4 id="1-border-width"><a href="#1-border-width" class="headerlink" title="1 border-width"></a>1 border-width</h4><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;legnth&gt;</code></td>
<td>指定值</td>
</tr>
<tr>
<td><code>thin</code></td>
<td>薄，等同于 1px</td>
</tr>
<tr>
<td><code>medium</code>（默认）</td>
<td>薄厚均匀，等同于 3px</td>
</tr>
<tr>
<td><code>thick</code></td>
<td>厚，等同于 4px</td>
</tr>
<tr>
<td>* 不支持百分比，不合常理，没有说边框跟着内容宽度变化的</td>
<td></td>
</tr>
</tbody></table>
<h4 id="2-border-style"><a href="#2-border-style" class="headerlink" title="2 border-style"></a>2 border-style</h4><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code>（默认）</td>
<td>不显示边框，none 值优先级最低，如果存在其他的重叠边框，则会显示为那个边框</td>
</tr>
<tr>
<td><code>hidden</code></td>
<td>不显示边框，hidden 值优先级最高，如果存在其他的重叠边框，边框也不会显示。</td>
</tr>
<tr>
<td><code>solid</code></td>
<td>单实线</td>
</tr>
<tr>
<td><code>double</code></td>
<td>双实线，边框宽最少3px才有效果</td>
</tr>
<tr>
<td><code>dotted</code></td>
<td>点画线</td>
</tr>
<tr>
<td><code>dashed</code></td>
<td>虚线</td>
</tr>
<tr>
<td><code>groove</code></td>
<td>雕刻效果，与ridge相反</td>
</tr>
<tr>
<td><code>ridge</code></td>
<td>浮雕效果，与groove相反</td>
</tr>
<tr>
<td><code>inset</code></td>
<td>陷入效果</td>
</tr>
<tr>
<td><code>outset</code></td>
<td>突出效果</td>
</tr>
</tbody></table>
<h4 id="3-border-color"><a href="#3-border-color" class="headerlink" title="3 border-color"></a>3 border-color</h4><ul>
<li>取值 <code>&lt;color&gt;</code></li>
<li>border-color 默认颜色为 color 色值（即边框颜色默认为字体颜色）</li>
</ul>
<h3 id="2-每个边的border属性"><a href="#2-每个边的border属性" class="headerlink" title="2 每个边的border属性"></a>2 每个边的border属性</h3><ol>
<li><code>border-top</code><ul>
<li><code>border-top-color</code></li>
<li><code>border-top-style</code></li>
<li><code>border-top-width</code></li>
</ul>
</li>
<li><code>border-right</code><ul>
<li><code>border-right-color</code></li>
<li><code>border-right-style</code></li>
<li><code>border-right-width</code></li>
</ul>
</li>
<li><code>border-bottom</code><ul>
<li><code>border-bottom-color</code></li>
<li><code>border-bottom-style</code></li>
<li><code>border-bottom-width</code></li>
</ul>
</li>
<li><code>border-left</code><ul>
<li><code>border-left-color</code></li>
<li><code>border-left-style</code></li>
<li><code>border-left-width</code></li>
</ul>
</li>
</ol>
<h3 id="3-border-radius"><a href="#3-border-radius" class="headerlink" title="3 border-radius"></a>3 border-radius</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;percentage&gt;</code></td>
<td>相对于border box的百分比</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>长度</td>
</tr>
</tbody></table>
<h4 id="1-最大尺寸-amp-等比缩放"><a href="#1-最大尺寸-amp-等比缩放" class="headerlink" title="1 最大尺寸 &amp; 等比缩放"></a>1 最大尺寸 &amp; 等比缩放</h4><ul>
<li>图形尺寸是有限的，所以圆角半径设置过大时，也只会按照最大尺寸来算，且值会根据设置时的比例变化</li>
<li>例如<ul>
<li>border box 宽200px，高300px，此时设置 <code>border-radius: 300px;</code></li>
<li>水平半径最大只能到200px，所以按200px算，垂直半径虽然能到300px，但是设置时<code>300:300</code>水平与垂直比例是<code>1:1</code>，垂直半径也要跟着变化，结果水平和垂直半径都是200px</li>
</ul>
</li>
</ul>
<h4 id="2-值语法"><a href="#2-值语法" class="headerlink" title="2 值语法"></a>2 值语法</h4><ul>
<li><code>第一组值（水平半径）/ 第二组值（垂直半径）</code><ul>
<li>如省略第二组值，则表示垂直半径=水平半径</li>
</ul>
</li>
</ul>
<h6 id="每组值的数量"><a href="#每组值的数量" class="headerlink" title="每组值的数量"></a>每组值的数量</h6><ul>
<li>一个值：<code>四个角</code></li>
<li>二个值：<code>左上角右下角 右上角左下角</code></li>
<li>三个值：<code>左上角 右上角左下角 右下角</code></li>
<li>四个值：<code>左上角 右上角 右下角 左下角</code> </li>
</ul>
<h4 id="3-每个角单独设置"><a href="#3-每个角单独设置" class="headerlink" title="3 每个角单独设置"></a>3 每个角单独设置</h4><ul>
<li><code>border-垂直-水平-radius: 水平半径 垂直半径（可省略）</code><ul>
<li><code>border-top-left-radius</code></li>
<li><code>border-top-right-radius</code></li>
<li><code>border-bottom-right-radius</code></li>
<li><code>border-bottom-left-radius</code></li>
</ul>
</li>
</ul>
<h2 id="1-4-margin-box"><a href="#1-4-margin-box" class="headerlink" title="1.4 margin box"></a>1.4 margin box</h2><h3 id="1-margin"><a href="#1-margin" class="headerlink" title="1 margin"></a>1 margin</h3><ul>
<li>margin对于块级元素有影响，且垂直方向有margin合并</li>
<li>margin对于替换元素有影响，且垂直方向无margin合并</li>
<li>margin对于非替换内联元素水平方向有影响，垂直方向无影响</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code></td>
<td>浏览器会自动选择一个合适的margin来应用</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>指定值</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>相对于宽度的百分比</td>
</tr>
<tr>
<td>* 一个值：同时设置四个边外边距</td>
<td></td>
</tr>
<tr>
<td>* 二个值：<code>上下 左右</code></td>
<td></td>
</tr>
<tr>
<td>* 三个值：<code>上 左右 下</code></td>
<td></td>
</tr>
<tr>
<td>* 四个值：<code>上 右 下 左</code></td>
<td></td>
</tr>
</tbody></table>
<h4 id="1-margin-atuo"><a href="#1-margin-atuo" class="headerlink" title="1 margin: atuo"></a>1 margin: atuo</h4><ul>
<li>计算规则<ol>
<li>如果一侧定值，一侧 auto，则 auto 为剩余空间大小。</li>
<li>如果两侧均是 auto，则平分剩余空间</li>
</ol>
</li>
<li>触发 margin:auto 计算的前提条件：width 或 height 为 auto 时，元素是具有对应方向的自动填充特性<ol>
<li>块级元素width为auto时，水平方向会自动填充</li>
<li>绝对定位元素<ol>
<li>如果设置left和right为0，则水平方向填充特性</li>
<li>如果设置top和bottom为0，则垂直方向有填充特性</li>
</ol>
</li>
</ol>
</li>
</ul>
<h5 id="绝对定位元素居中的两种方式"><a href="#绝对定位元素居中的两种方式" class="headerlink" title="绝对定位元素居中的两种方式"></a>绝对定位元素居中的两种方式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1 </span><br><span class="line">position: absolute;</span><br><span class="line">// 1.1 首先向右向下移动父元素宽高的一半</span><br><span class="line">left: 50%; top: 50%;</span><br><span class="line">// 1.2 由于参照点是子元素的左上角，所以要向左向上分别移动子元素宽高的一半（margin或者transform:translate）</span><br><span class="line">margin-left: -50%; margin-top: -50%;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 2</span><br><span class="line">position: absolute;</span><br><span class="line">// 2.1 使水平和垂直方向具有填充特性</span><br><span class="line">left: 0; right: 0; top:0; bottom:0;</span><br><span class="line">// 2.2 margin:auto 触发计算，自动平分</span><br><span class="line">margin: auto;</span><br></pre></td></tr></table></figure>

<h4 id="2-margin-合并"><a href="#2-margin-合并" class="headerlink" title="2 margin 合并"></a>2 margin 合并</h4><ul>
<li>块级元素的上外边距（margin-top）与下外边距（margin-bottom）有时会合并为单个外边距<ul>
<li>块级元素，但不包括浮动和绝对定位元素，尽管浮动和绝对定位可以让元素块状化</li>
</ul>
</li>
</ul>
<h5 id="1-场景"><a href="#1-场景" class="headerlink" title="1 场景"></a>1 场景</h5><ol>
<li>相邻兄弟元素 margin 合并</li>
<li>父级和第一个/最后一个子元素 margin 合并<ul>
<li>解决margin-top 合并<ol>
<li>父元素设置为块状格式化上下文元素</li>
<li>父元素设置 border-top 值</li>
<li>父元素设置 padding-top 值</li>
<li>父元素和第一个子元素之间添加内联元素进行分隔</li>
</ol>
</li>
<li>解决margin-bottom 合并<ol>
<li>父元素设置为块状格式化上下文元素</li>
<li>父元素设置 border-bottom 值</li>
<li>父元素设置 padding-bottom 值</li>
<li>父元素和最后一个子元素之间添加内联元素进行分隔</li>
<li>父元素设置 height、min-height 或 max-height</li>
</ol>
</li>
</ul>
</li>
<li>空块级元素的 margin 合并<ul>
<li>解决<ol>
<li>设置垂直方向的 border；</li>
<li>设置垂直方向的 padding；</li>
<li>里面添加内联元素（直接 Space 键空格是没用的）；</li>
<li>设置 height 或者 min-height。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h5 id="2-计算规则"><a href="#2-计算规则" class="headerlink" title="2 计算规则"></a>2 计算规则</h5><ol>
<li>如果合并外边距皆为正，取最大值</li>
<li>如果合并外边距皆为负，取最小值（即绝对值最大值）</li>
<li>如果合并外边距有正有负，取最大正外边距与最小负外边距之和</li>
</ol>
<h4 id="3-margin-无效的场景"><a href="#3-margin-无效的场景" class="headerlink" title="3 margin 无效的场景"></a>3 margin 无效的场景</h4><ol>
<li>非替换内联元素的垂直方向</li>
<li><code>&lt;tr&gt;&lt;td&gt;</code>标签或者 display为<code>table-row table-cell</code>的元素</li>
<li>绝对定位元素非定位方位的 margin 值表面“无效”</li>
</ol>
<h3 id="2-每个边的margin属性"><a href="#2-每个边的margin属性" class="headerlink" title="2 每个边的margin属性"></a>2 每个边的margin属性</h3><ol>
<li><code>margin-top</code></li>
<li><code>margin-right</code></li>
<li><code>margin-bottom</code></li>
<li><code>margin-left</code></li>
</ol>
<h1 id="二-box-sizing"><a href="#二-box-sizing" class="headerlink" title="二 box-sizing"></a>二 box-sizing</h1><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>content-box</code>（默认）</td>
<td>盒子大小是content box（即width/height是对内容盒子的宽和高）</td>
</tr>
<tr>
<td><code>border-box</code></td>
<td>盒子大小是border box（即width/height是内容的宽高+内边距+边框）</td>
</tr>
</tbody></table>
<h1 id="三-box-shadow"><a href="#三-box-shadow" class="headerlink" title="三 box-shadow"></a>三 box-shadow</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ inset? [&lt;offset-x&gt; &lt;offset-y&gt;] &lt;blur-radius&gt;? &lt;spred-radius&gt;? &lt;color&gt;? ]#</span><br></pre></td></tr></table></figure>
<ul>
<li><code>inset</code><ul>
<li>默认阴影在边框外即向外扩散，inset关键字会使得阴影落在盒子内部即向内扩散</li>
</ul>
</li>
<li><code>&lt;blur-radius&gt;</code><ul>
<li>阴影模糊半径，值越大，模糊面积越大，阴影就越大越淡，不能为负</li>
</ul>
</li>
<li><code>&lt;spred-radius&gt;</code><ul>
<li>阴影扩散半径，默认为0，取正值时，阴影扩大；取负值时，阴影收缩。</li>
</ul>
</li>
</ul>
<h1 id="四-visibility"><a href="#四-visibility" class="headerlink" title="四 visibility"></a>四 visibility</h1><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>visible</code>（默认）</td>
<td>元素正常显示</td>
</tr>
<tr>
<td><code>hidden</code></td>
<td>隐藏元素，但是其他元素的布局不改变，相当于此元素变成透明。若其子元素设为visible，则子元素依然可见</td>
</tr>
<tr>
<td><code>collapse</code></td>
<td>用于 <code>&lt;table&gt;</code> 行、列、列组和行组，隐藏表格的行或列，并且不占用任何空间，就好像折叠了单元格一般（效果同display:none）</td>
</tr>
</tbody></table>
<h2 id="visibility-hidden-amp-display-none"><a href="#visibility-hidden-amp-display-none" class="headerlink" title="visibility: hidden &amp; display: none"></a><code>visibility: hidden</code> &amp; <code>display: none</code></h2><ul>
<li><code>display: none</code><ul>
<li>表示该元素以及它的所有后代元素都会隐藏</li>
<li>元素无法点击，无法使用屏幕阅读器等辅助设备访问</li>
<li>不占用空间，就好像抹去了一般</li>
<li>不会影响计数器的值</li>
</ul>
</li>
<li><code>visibility: hidden</code><ul>
<li>如果元素的后代元素将visibility设为visible，则后代元素依然可见</li>
<li>占用空间，就好像隐形了一般</li>
<li>会影响计数器的值</li>
</ul>
</li>
</ul>
<h1 id="五-outline"><a href="#五-outline" class="headerlink" title="五 outline"></a>五 outline</h1><h2 id="5-1-语法"><a href="#5-1-语法" class="headerlink" title="5.1 语法"></a>5.1 语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">outline-style ||</span><br><span class="line">outline-width ||</span><br><span class="line">outline-color</span><br></pre></td></tr></table></figure>
<ul>
<li>轮廓线不占据空间</li>
</ul>
<h3 id="1-outline-width"><a href="#1-outline-width" class="headerlink" title="1 outline-width"></a>1 outline-width</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;legnth&gt;</code></td>
<td>指定值</td>
</tr>
<tr>
<td><code>thin</code></td>
<td>薄</td>
</tr>
<tr>
<td><code>medium</code></td>
<td>中等</td>
</tr>
<tr>
<td><code>thick</code></td>
<td>厚</td>
</tr>
</tbody></table>
<h3 id="2-outline-style"><a href="#2-outline-style" class="headerlink" title="2 outline-style"></a>2 outline-style</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code></td>
<td>无轮廓线</td>
</tr>
<tr>
<td><code>solid</code></td>
<td>单实线</td>
</tr>
<tr>
<td><code>double</code></td>
<td>双实线</td>
</tr>
<tr>
<td><code>dotted</code></td>
<td>点画线</td>
</tr>
<tr>
<td><code>dashed</code></td>
<td>虚线</td>
</tr>
<tr>
<td><code>groove</code></td>
<td>雕刻效果，与ridge相反</td>
</tr>
<tr>
<td><code>ridge</code></td>
<td>浮雕效果，与groove相反</td>
</tr>
<tr>
<td><code>inset</code></td>
<td>陷入效果</td>
</tr>
<tr>
<td><code>outset</code></td>
<td>突出效果</td>
</tr>
</tbody></table>
<h3 id="3-outline-color"><a href="#3-outline-color" class="headerlink" title="3 outline-color"></a>3 outline-color</h3><ul>
<li>取值 <code>&lt;color&gt;</code></li>
</ul>
<h1 id="六-cursor"><a href="#六-cursor" class="headerlink" title="六 cursor"></a>六 cursor</h1><ul>
<li>定义鼠标悬浮在元素上方时的样式</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code>（默认）</td>
<td>浏览器根据内容类别自动选择光标形状</td>
</tr>
<tr>
<td><code>default</code></td>
<td>箭头</td>
</tr>
<tr>
<td><code>none</code></td>
<td>隐藏光标，比如看视频时</td>
</tr>
<tr>
<td><code>pointer</code></td>
<td>手</td>
</tr>
<tr>
<td><code>help</code></td>
<td>帮助样式</td>
</tr>
<tr>
<td><code>...</code></td>
<td>还有很多样式</td>
</tr>
</tbody></table>
<h1 id="七-元素尺寸相关的几个属性"><a href="#七-元素尺寸相关的几个属性" class="headerlink" title="七 元素尺寸相关的几个属性"></a>七 元素尺寸相关的几个属性</h1><ol>
<li><code>clientWidth clientHeight</code><ul>
<li>指元素可视区域的padding box</li>
</ul>
</li>
<li><code>scrollWidth scrollHeight</code><ul>
<li>指元素实际区域的padding box<br>3 <code>offsetWidth offsetHeight</code></li>
<li>指元素可视区域的大小（包含边框，滚动条）</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>UI</category>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>CSS 元素和流</title>
    <url>/anyeansan.github.io/2020/03/30/CSS-%E5%85%83%E7%B4%A0%E5%92%8C%E6%B5%81/</url>
    <content><![CDATA[<h1 id="一-正常文档流（normal-flow）"><a href="#一-正常文档流（normal-flow）" class="headerlink" title="一 正常文档流（normal flow）"></a>一 正常文档流（normal flow）</h1><ol>
<li>元素默认都在文档流中</li>
<li>自上而下，自左向右排列 </li>
</ol>
<h1 id="二-元素的盒子"><a href="#二-元素的盒子" class="headerlink" title="二 元素的盒子"></a>二 元素的盒子</h1><h2 id="2-1-外部盒子"><a href="#2-1-外部盒子" class="headerlink" title="2.1 外部盒子"></a>2.1 外部盒子</h2><ul>
<li>决定了元素类型（块级元素 / 内联元素）</li>
</ul>
<h2 id="2-2-内部盒子（容器盒子）"><a href="#2-2-内部盒子（容器盒子）" class="headerlink" title="2.2 内部盒子（容器盒子）"></a>2.2 内部盒子（容器盒子）</h2><ul>
<li>决定了子元素布局<ol>
<li>content box （名称为 <code>content-box</code>）</li>
<li>padding box（名称为 <code>padding-box</code>）</li>
<li>border box（名称为 <code>border-box</code>）</li>
<li>margin box（没有名称）</li>
</ol>
</li>
</ul>
<h1 id="三-块级元素-amp-内联元素"><a href="#三-块级元素-amp-内联元素" class="headerlink" title="三 块级元素 &amp; 内联元素"></a>三 块级元素 &amp; 内联元素</h1><h2 id="3-1-块级元素"><a href="#3-1-块级元素" class="headerlink" title="3.1 块级元素"></a>3.1 块级元素</h2><ol>
<li>独占一行，自上而下排列</li>
<li>宽度：默认为父元素宽度的100%</li>
<li>高度：默认为0，高度与其内容高度一致</li>
<li>可以直接设置宽高（<code>width height</code>）</li>
</ol>
<table>
<thead>
<tr>
<th>默认块级元素</th>
<th>display</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;div&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;header&gt; &lt;main&gt; &lt;footer&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;article&gt; &lt;aside&gt; &lt;section&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;h1&gt;~&lt;h6&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;p&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;ul&gt; &lt;ol&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;li&gt;</code></td>
<td>list-item</td>
</tr>
<tr>
<td><code>&lt;dl&gt; &lt;dt&gt; &lt;dd&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;hr&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;table&gt;</code></td>
<td>table</td>
</tr>
<tr>
<td><code>&lt;form&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;option&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;address&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;blockquote&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;pre&gt;</code></td>
<td>block</td>
</tr>
<tr>
<td><code>&lt;menu&gt;</code></td>
<td>block</td>
</tr>
</tbody></table>
<h2 id="3-2-内联元素"><a href="#3-2-内联元素" class="headerlink" title="3.2 内联元素"></a>3.2 内联元素</h2><ol>
<li>只占自身大小，从左向右排列，如果一行不足以容纳，会换行</li>
<li>内联元素宽高与内容一致，<code>width height</code> 属性无效</li>
</ol>
<table>
<thead>
<tr>
<th>默认内联元素</th>
<th>display</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;span&gt;</code></td>
<td>inline</td>
</tr>
<tr>
<td><code>&lt;a&gt;</code></td>
<td>inline</td>
</tr>
<tr>
<td><code>&lt;img&gt;</code></td>
<td>inline</td>
</tr>
<tr>
<td><code>&lt;br&gt;</code></td>
<td>inline</td>
</tr>
<tr>
<td><code>&lt;label&gt;</code></td>
<td>inline</td>
</tr>
<tr>
<td><code>&lt;input&gt;</code></td>
<td>inline-block（type为hidden时是none）</td>
</tr>
<tr>
<td><code>&lt;button&gt;</code></td>
<td>inline-block</td>
</tr>
<tr>
<td><code>&lt;select&gt;</code></td>
<td>inline-block</td>
</tr>
<tr>
<td><code>&lt;textarea&gt;</code></td>
<td>inline-block</td>
</tr>
<tr>
<td><code>&lt;abbr&gt; &lt;em&gt; &lt;i&gt; ...</code></td>
<td>inline</td>
</tr>
</tbody></table>
<h2 id="3-3-display"><a href="#3-3-display" class="headerlink" title="3.3 display"></a>3.3 display</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ &lt;display-outside&gt; || &lt;display-inside&gt; ] &lt;display-listitem&gt; | </span><br><span class="line">&lt;display-internal&gt; |</span><br><span class="line">&lt;display-box&gt; |</span><br><span class="line">&lt;display-legacy&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-lt-display-outside-gt"><a href="#2-lt-display-outside-gt" class="headerlink" title="2 &lt;display-outside&gt;"></a>2 <code>&lt;display-outside&gt;</code></h3><ul>
<li>外部盒子显示类型：决定了元素类型 块级 or 内联</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>block</code></td>
<td>块级元素</td>
</tr>
<tr>
<td><code>inline</code></td>
<td>内联元素</td>
</tr>
<tr>
<td><code>run-in</code></td>
<td>了解</td>
</tr>
</tbody></table>
<h3 id="3-lt-display-inside-gt"><a href="#3-lt-display-inside-gt" class="headerlink" title="3 &lt;display-inside&gt;"></a>3 <code>&lt;display-inside&gt;</code></h3><ul>
<li>内部盒子显示类型：决定子元素布局</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>flow</code></td>
<td>了解</td>
</tr>
<tr>
<td><code>flow-root</code></td>
<td>触发BFC</td>
</tr>
<tr>
<td><code>table</code></td>
<td>同 <code>&lt;table&gt;</code></td>
</tr>
<tr>
<td><code>flex</code></td>
<td>弹性布局</td>
</tr>
<tr>
<td><code>grid</code></td>
<td>栅格布局</td>
</tr>
<tr>
<td><code>ruby</code></td>
<td>了解，可以加旁注标记，如中文的拼音</td>
</tr>
</tbody></table>
<h3 id="4-lt-display-listitem-gt"><a href="#4-lt-display-listitem-gt" class="headerlink" title="4 &lt;display-listitem&gt;"></a>4 <code>&lt;display-listitem&gt;</code></h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>list-item</code></td>
<td>同 <code>&lt;li&gt;</code>，可以搭配 <code>list-style-type</code> 和 <code>list-style-position</code> 使用</td>
</tr>
</tbody></table>
<h4 id="list-item"><a href="#list-item" class="headerlink" title="list-item"></a>list-item</h4><ul>
<li>元素设置<code>display: list-item</code> 和 <code>display: block</code> 时<ul>
<li><code>&lt;display-outside&gt;</code> 默认都是 <code>block</code></li>
<li><code>&lt;display-inside&gt;</code> 默认都是 <code>flow</code></li>
</ul>
</li>
<li>唯一区别是前边有项目符号</li>
<li>为什么 list-item 元素会出现项目符号？<ul>
<li>因为生成了一个附加的盒子，学名“标记盒子”（marker box），专门用来放圆点、数字这些项目符号</li>
</ul>
</li>
</ul>
<h3 id="5-lt-display-internal-gt"><a href="#5-lt-display-internal-gt" class="headerlink" title="5 &lt;display-internal&gt;"></a>5 <code>&lt;display-internal&gt;</code></h3><ul>
<li>内部属性值</li>
<li>类似table和ruby等有复杂内部结构的布局模块，它们的子孙有不同的填充方式</li>
<li>内部属性值附属于它的布局模块</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>table-header-group</code></td>
<td>同 <code>&lt;thead&gt;</code></td>
</tr>
<tr>
<td><code>table-row-group</code></td>
<td>同 <code>&lt;tbody&gt;</code></td>
</tr>
<tr>
<td><code>table-footer-group</code></td>
<td>同 <code>&lt;tfoot&gt;</code></td>
</tr>
<tr>
<td><code>table-caption</code></td>
<td>同 <code>&lt;caption&gt;</code></td>
</tr>
<tr>
<td><code>table-row</code></td>
<td>同 <code>&lt;tr&gt;</code></td>
</tr>
<tr>
<td><code>table-cell</code></td>
<td>同 <code>&lt;td&gt;</code></td>
</tr>
<tr>
<td><code>table-column-group</code></td>
<td>同 <code>&lt;colgroup&gt;</code></td>
</tr>
<tr>
<td><code>table-column</code></td>
<td>同 <code>&lt;col&gt;</code></td>
</tr>
<tr>
<td><code>ruby-base</code></td>
<td>同 <code>&lt;rb&gt;</code></td>
</tr>
<tr>
<td><code>ruby-text</code></td>
<td>同 <code>&lt;rt&gt;</code></td>
</tr>
<tr>
<td><code>ruby-base-container</code></td>
<td>同 <code>&lt;rbc&gt;</code></td>
</tr>
<tr>
<td><code>ruby-text-container</code></td>
<td>同 <code>&lt;rtc&gt;</code></td>
</tr>
</tbody></table>
<h3 id="6-lt-display-box-gt"><a href="#6-lt-display-box-gt" class="headerlink" title="6 &lt;display-box&gt;"></a>6 <code>&lt;display-box&gt;</code></h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code></td>
<td>不显示，就好像不存在一样，不占空间</td>
</tr>
<tr>
<td><code>contents</code></td>
<td>我的理解就是只保留内容</td>
</tr>
</tbody></table>
<h4 id="contents"><a href="#contents" class="headerlink" title="contents"></a>contents</h4><ul>
<li>元素本身不产生任何边界框（英文是boxes，自己体会），而元素的子元素和伪元素（<code>::befor</code>和<code>::after</code>）仍然生成边界框，元素文字正常显示</li>
<li>元素不产生任何边界框，因此元素的背景、边框和填充部分都不会渲染（即background border padding width height 等属性会失效）。而继承的属性如颜色(color)和字体(font)却能照常影响子元素</li>
</ul>
<h3 id="7-lt-display-legacy-gt"><a href="#7-lt-display-legacy-gt" class="headerlink" title="7 &lt;display-legacy&gt;"></a>7 <code>&lt;display-legacy&gt;</code></h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>inline-block</code></td>
<td>行块</td>
</tr>
<tr>
<td><code>inline-table</code></td>
<td>行表格</td>
</tr>
<tr>
<td><code>inline-flex</code></td>
<td>行弹性</td>
</tr>
<tr>
<td><code>inline-grid</code></td>
<td>行栅格</td>
</tr>
</tbody></table>
<h3 id="8-单值语法-amp-双值语法"><a href="#8-单值语法-amp-双值语法" class="headerlink" title="8 单值语法 &amp; 双值语法"></a>8 单值语法 &amp; 双值语法</h3><table>
<thead>
<tr>
<th>single value</th>
<th>two value</th>
</tr>
</thead>
<tbody><tr>
<td><code>block</code></td>
<td><code>block flow</code></td>
</tr>
<tr>
<td><code>flow-root</code></td>
<td><code>block flow-root</code></td>
</tr>
<tr>
<td><code>inline</code></td>
<td><code>inline flow</code></td>
</tr>
<tr>
<td><code>inline-block</code></td>
<td><code>inline flow-root</code></td>
</tr>
<tr>
<td><code>flex</code></td>
<td><code>block flex</code></td>
</tr>
<tr>
<td><code>inline-flex</code></td>
<td><code>inline flex</code></td>
</tr>
<tr>
<td><code>grid</code></td>
<td><code>block grid</code></td>
</tr>
<tr>
<td><code>inline-grid</code></td>
<td><code>inline grid</code></td>
</tr>
<tr>
<td><code>table</code></td>
<td><code>block table</code></td>
</tr>
<tr>
<td><code>inline-table</code></td>
<td><code>inline table</code></td>
</tr>
</tbody></table>
<ul>
<li>双值语法未广泛支持，但可以帮助理解单值语法时 <code>&lt;display-outside&gt;</code> 和 <code>&lt;display-inside&gt;</code> 的默认值</li>
</ul>
<h2 id="3-4-非替换元素-amp-替换元素"><a href="#3-4-非替换元素-amp-替换元素" class="headerlink" title="3.4 非替换元素 &amp; 替换元素"></a>3.4 非替换元素 &amp; 替换元素</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ul>
<li>根据 “外在盒子” 把元素分为内联元素和块级元素</li>
<li>根据是否具有可替换内容，把元素分为替换元素和非替换元素</li>
</ul>
<h3 id="2-非替换元素"><a href="#2-非替换元素" class="headerlink" title="2 非替换元素"></a>2 非替换元素</h3><ul>
<li>如果元素的内容包含在文档中，则称之为非替换元素</li>
<li>html 的大多数元素是不可替换元素，即其内容直接表现给浏览器<ul>
<li>如 <code>&lt;p&gt;</code> 文档内容是什么，显示结果就是什么</li>
</ul>
</li>
</ul>
<h3 id="3-替换元素"><a href="#3-替换元素" class="headerlink" title="3 替换元素"></a>3 替换元素</h3><ul>
<li>浏览器根据元素的标签和属性，来决定元素的具体显示内容（即content box内容可替换，对应的 CSS 属性是 content）<ul>
<li>如 <code>&lt;img&gt; &lt;object&gt; &lt;video&gt; &lt;iframe&gt; &lt;textarea&gt; &lt;input&gt;</code></li>
<li><code>&lt;img&gt;</code>，修改src属性就会改变显示结果</li>
</ul>
</li>
<li>匿名可替换元素<ul>
<li>通过 CSS content 属性来插入的对象 被称作 匿名可替换元素</li>
</ul>
</li>
<li>所有的替换元素都是内联元素</li>
</ul>
<h4 id="4-替换元素的特性"><a href="#4-替换元素的特性" class="headerlink" title="4 替换元素的特性"></a>4 替换元素的特性</h4><h5 id="1-内容的外观不受页面上的-CSS-的影响"><a href="#1-内容的外观不受页面上的-CSS-的影响" class="headerlink" title="1 内容的外观不受页面上的 CSS 的影响"></a>1 内容的外观不受页面上的 CSS 的影响</h5><ul>
<li>替换元素是一种外部对象，它们外观的渲染，是独立于 CSS 的</li>
<li>样式表现在css作用域之外，如果要替换元素本身的外观，需要类似appearance的属性。或者是浏览器本身暴露的接口。但是直接<code>input[type=&#39;checkbox&#39;]{}</code>没办法改变内间距背景色等特性</li>
</ul>
<h5 id="2-有自己的尺寸"><a href="#2-有自己的尺寸" class="headerlink" title="2 有自己的尺寸"></a>2 有自己的尺寸</h5><ul>
<li>在 Web 中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是 300 像素×150 像素<ul>
<li>如 <code>&lt;video&gt; &lt;iframe&gt; &lt;canvas&gt;</code></li>
</ul>
</li>
<li>少部分替换元素为 0 像素，如<code>&lt;img&gt;</code></li>
<li>表单元素的替换元素的尺寸则和浏览器有关，没有明显的规律</li>
</ul>
<h5 id="3-在很多-CSS-属性上有自己的一套表现规则"><a href="#3-在很多-CSS-属性上有自己的一套表现规则" class="headerlink" title="3 在很多 CSS 属性上有自己的一套表现规则"></a>3 在很多 CSS 属性上有自己的一套表现规则</h5><ul>
<li>如 <code>vertical-align</code> 默认值的 baseline ，但对于替换元素，默认为元素的下边缘</li>
</ul>
<h4 id="5-替换元素的尺寸计算规则"><a href="#5-替换元素的尺寸计算规则" class="headerlink" title="5 替换元素的尺寸计算规则"></a>5 替换元素的尺寸计算规则</h4><h5 id="1-尺寸类型"><a href="#1-尺寸类型" class="headerlink" title="1 尺寸类型"></a>1 尺寸类型</h5><ol>
<li>固有尺寸<ul>
<li>指的是替换内容原本的尺寸</li>
<li>如图片，视频都有自身的尺寸</li>
</ul>
</li>
<li>HTML 尺寸<ul>
<li>HTML 尺寸只能通过HTML 原生属性改变</li>
<li>HTML 原生属性，如<code>&lt;img&gt;</code>的 width 和 height 属性、<code>&lt;input&gt;</code>的 size 属性、<code>&lt;textarea&gt;</code>的 cols 和 rows 属性等</li>
</ul>
</li>
<li>CSS 尺寸<ul>
<li>可以通过 CSS 的 width 和 height 或者 max-width/min-width 和max-height/min-height 设置的尺寸</li>
<li>对应盒尺寸中的 content box</li>
</ul>
</li>
</ol>
<h5 id="2-计算规则"><a href="#2-计算规则" class="headerlink" title="2 计算规则"></a>2 计算规则</h5><ol>
<li>没有 CSS 尺寸和 HTML 尺寸，则使用固有尺寸作为最终的宽高</li>
<li>没有 CSS 尺寸，则使用 HTML尺寸作为最终的宽高</li>
<li>有 CSS 尺寸，则最终尺寸由 CSS 属性决定</li>
<li>如果固有尺寸含有固有的宽高比，css尺寸和html尺寸如果只设置了宽高中的一个，则另一个值根据固有尺寸宽高比变化</li>
<li>如果以上都不符合，则最终宽度表现为 300 像素，高度为 150 像素<ul>
<li><code>&lt;img&gt;</code> 较为特殊<ul>
<li>chrome下默认为0*0</li>
<li>firefox下默认为0*22，且firfox下如果省略src属性，则<code>&lt;img&gt;</code>不是替换元素，而是一个普通的内联元素</li>
</ul>
</li>
</ul>
</li>
<li>内联替换元素和块级替换元素使用上面同一套尺寸计算规则<ul>
<li>即内联替换元素块级化，计算规则不变</li>
</ul>
</li>
<li>无法改变替换元素内容的固有尺寸<ul>
<li>我们为<code>&lt;img&gt;</code>设置宽高，好像是覆盖了固有尺寸，其实改变的是content box的宽高，而<code>&lt;img&gt;</code>的content box替换内容默认适配方式是填充（fill）</li>
<li>css3替换元素的替换内容的适配方式可以通过<code>object-fit</code> 属性修改</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>UI</category>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>CSS 列表 表格</title>
    <url>/anyeansan.github.io/2020/03/30/CSS-%E5%88%97%E8%A1%A8-%E8%A1%A8%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="一-列表"><a href="#一-列表" class="headerlink" title="一 列表"></a>一 列表</h1><h2 id="1-1-list-style"><a href="#1-1-list-style" class="headerlink" title="1.1 list-style"></a>1.1 list-style</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list-style-type ||</span><br><span class="line">list-style-image ||</span><br><span class="line">list-style-position</span><br></pre></td></tr></table></figure>
<ol>
<li>无序</li>
<li>仅有任意一个即可</li>
</ol>
<h3 id="2-list-style-type"><a href="#2-list-style-type" class="headerlink" title="2 list-style-type"></a>2 list-style-type</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>disc</code>（默认）</td>
<td>实心圆点</td>
</tr>
<tr>
<td><code>none</code></td>
<td>无样式</td>
</tr>
<tr>
<td><code>circle</code></td>
<td>空心圆点</td>
</tr>
<tr>
<td><code>square</code></td>
<td>实心方块</td>
</tr>
<tr>
<td><code>decimal</code></td>
<td>从1开始的数字</td>
</tr>
<tr>
<td><code>......</code></td>
<td>还有许多样式</td>
</tr>
</tbody></table>
<h3 id="3-list-style-image"><a href="#3-list-style-image" class="headerlink" title="3 list-style-image"></a>3 list-style-image</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code>（默认）</td>
<td>会使用<code>list-style-type</code></td>
</tr>
<tr>
<td><code>&lt;url&gt;</code></td>
<td>指定图片</td>
</tr>
</tbody></table>
<h3 id="4-list-style-position"><a href="#4-list-style-position" class="headerlink" title="4 list-style-position"></a>4 list-style-position</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>outside</code>（默认）</td>
<td>标记盒 <code>::marker</code> 在主块盒之外</td>
</tr>
<tr>
<td><code>inside</code></td>
<td>标记盒 <code>::marker</code> 在主块盒之内，是主块盒中的第一个行内盒</td>
</tr>
</tbody></table>
<h1 id="二-表格"><a href="#二-表格" class="headerlink" title="二 表格"></a>二 表格</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol>
<li>单元格没有外边距，有边框和内边距</li>
<li>标题是放在表格边框的外面的</li>
</ol>
<h2 id="2-2-border-collapse"><a href="#2-2-border-collapse" class="headerlink" title="2.2 border-collapse"></a>2.2 border-collapse</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>separate</code>（默认）</td>
<td>分离，HTML 表格的传统模式。相邻单元格都拥有独立的边框</td>
</tr>
<tr>
<td><code>collapse</code></td>
<td>合并，表格中相邻单元格共享边框</td>
</tr>
</tbody></table>
<h2 id="2-3-border-spacing"><a href="#2-3-border-spacing" class="headerlink" title="2.3 border-spacing"></a>2.3 border-spacing</h2><ul>
<li><code>&lt;length&gt; &lt;length&gt;?</code><ul>
<li><code>水平 垂直</code> 如果省略垂直则与水平间距相等</li>
<li>只有 <code>border-collapse: separate</code> 时才有效</li>
</ul>
</li>
</ul>
<h2 id="2-4-empty-cells"><a href="#2-4-empty-cells" class="headerlink" title="2.4 empty-cells"></a>2.4 empty-cells</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>show</code>（默认）</td>
<td>空单元格的背景和边框正常显示</td>
</tr>
<tr>
<td><code>hide</code></td>
<td>空单元格的背景和边框隐藏</td>
</tr>
</tbody></table>
<h2 id="2-5-caption-side"><a href="#2-5-caption-side" class="headerlink" title="2.5 caption-side"></a>2.5 caption-side</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>top</code>（默认）</td>
<td><code>&lt;caption&gt;</code>盒子在表格顶部</td>
</tr>
<tr>
<td><code>bottom</code></td>
<td><code>&lt;caption&gt;</code>盒子在表格底部</td>
</tr>
</tbody></table>
<h2 id="2-6-table-layout"><a href="#2-6-table-layout" class="headerlink" title="2.6 table-layout"></a>2.6 table-layout</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code>（默认）</td>
<td>表格及单元格的宽度取决于其包含的内容</td>
</tr>
<tr>
<td><code>fixed</code></td>
<td>表格和列的宽度通过表格的宽度来设置，某一列的宽度仅由该列首行的单元格决定</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>UI</category>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>CSS 文字排版和修饰</title>
    <url>/anyeansan.github.io/2020/03/30/CSS-%E6%96%87%E5%AD%97%E6%8E%92%E7%89%88%E5%92%8C%E4%BF%AE%E9%A5%B0/</url>
    <content><![CDATA[<h1 id="一-文本排版"><a href="#一-文本排版" class="headerlink" title="一 文本排版"></a>一 文本排版</h1><h2 id="1-1-text-transform"><a href="#1-1-text-transform" class="headerlink" title="1.1 text-transform"></a>1.1 text-transform</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code>（默认）</td>
<td>无影响</td>
</tr>
<tr>
<td><code>capitalize</code></td>
<td>每个单词首字母大写</td>
</tr>
<tr>
<td><code>uppercase</code></td>
<td>所有字母大写</td>
</tr>
<tr>
<td><code>lowercase</code></td>
<td>所有字母小写</td>
</tr>
</tbody></table>
<h2 id="1-2-空白-amp-拆分-amp-换行"><a href="#1-2-空白-amp-拆分-amp-换行" class="headerlink" title="1.2 空白 &amp; 拆分 &amp; 换行"></a>1.2 空白 &amp; 拆分 &amp; 换行</h2><h3 id="1-white-space"><a href="#1-white-space" class="headerlink" title="1 white-space"></a>1 white-space</h3><ul>
<li>设置如何处理元素中的 空白（空格space，制表符tab，换行符enter）</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>normal</code>（默认）</td>
<td>所有空格、制表符、换行符都合并成一个空格，文本自动换行</td>
</tr>
<tr>
<td><code>nowrap</code></td>
<td>所有空格、制表符、换行符都合并成一个空格，文本不换行</td>
</tr>
<tr>
<td><code>pre</code></td>
<td>所有东西原样输出，文本不换行</td>
</tr>
<tr>
<td><code>pre-wrap</code></td>
<td>所有东西原样输出，文本换行</td>
</tr>
<tr>
<td><code>pre-line</code></td>
<td>所有空格、制表符合并成一个空格，换行符不变，文本换行</td>
</tr>
<tr>
<td><code>break-spaces</code></td>
<td>同<code>pre-wrap</code>，但有一些区别</td>
</tr>
</tbody></table>
<h3 id="2-word-break"><a href="#2-word-break" class="headerlink" title="2 word-break"></a>2 word-break</h3><ul>
<li>控制单词如何被拆分换行</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>normal</code>（默认）</td>
<td>CJK（中/日/韩）可以在任意2个字符间断行，non-CJK只能再空白符处断行</td>
</tr>
<tr>
<td><code>keep-all</code></td>
<td>CJK和non-CJK都能只能在空白符处断行</td>
</tr>
<tr>
<td><code>break-all</code></td>
<td>CJK和non-CJK都可以在任意位置断行</td>
</tr>
</tbody></table>
<h3 id="3-overflow-wrap"><a href="#3-overflow-wrap" class="headerlink" title="3 overflow-wrap"></a>3 overflow-wrap</h3><ul>
<li>原<code>word-wrap</code>改名为 <code>overflow-wrap</code></li>
<li>指定一个不可分割的字符串过长，超过容器盒的宽时应该如何处理</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>normal</code>（默认）</td>
<td>在正常的单词结束处换行（CJK从单个字符之间换行，non-CJK保留完整性，可能会溢出容器）</td>
</tr>
<tr>
<td><code>break-word</code></td>
<td>内容将在边界内换行。如果需要，non-CJK单词内部允许断行</td>
</tr>
</tbody></table>
<h2 id="1-3-间距"><a href="#1-3-间距" class="headerlink" title="1.3 间距"></a>1.3 间距</h2><h3 id="1-word-spacing"><a href="#1-word-spacing" class="headerlink" title="1 word-spacing"></a>1 word-spacing</h3><ul>
<li>设置单词之间的距离，中文无效</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>normal</code>（默认）</td>
<td>常规</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>长度</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>百分比</td>
</tr>
</tbody></table>
<h3 id="2-letter-spacing"><a href="#2-letter-spacing" class="headerlink" title="2 letter-spacing"></a>2 letter-spacing</h3><ul>
<li>设置字符之间的距离，中文有效</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>normal</code>（默认）</td>
<td>常规</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>长度</td>
</tr>
</tbody></table>
<h2 id="1-4-缩进-对齐"><a href="#1-4-缩进-对齐" class="headerlink" title="1.4 缩进 对齐"></a>1.4 缩进 对齐</h2><h3 id="1-text-indent"><a href="#1-text-indent" class="headerlink" title="1 text-indent"></a>1 text-indent</h3><ul>
<li>定义首行缩进量</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;length&gt;</code></td>
<td>长度，允许为负</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>使用包含块宽度的百分比作为缩进</td>
</tr>
</tbody></table>
<h3 id="2-text-align"><a href="#2-text-align" class="headerlink" title="2 text-align"></a>2 text-align</h3><ul>
<li>定义行内内容如何相对它的块父元素水平对齐</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>left</code></td>
<td>左对齐</td>
</tr>
<tr>
<td><code>right</code></td>
<td>右对齐</td>
</tr>
<tr>
<td><code>center</code></td>
<td>居中对齐</td>
</tr>
<tr>
<td><code>justify</code></td>
<td>两端对齐，对最后一行无效</td>
</tr>
</tbody></table>
<h3 id="3-text-justify"><a href="#3-text-justify" class="headerlink" title="3 text-justify"></a>3 text-justify</h3><ul>
<li>定义当文本 <code>text-align: justify</code>  时的齐行方法</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code>（默认）</td>
<td>浏览器根据显示的效果和质量来确定最佳对齐方式</td>
</tr>
<tr>
<td><code>none</code></td>
<td>表现的效果和没有设置 text-align 一样</td>
</tr>
<tr>
<td><code>inter-word</code></td>
<td>增加单词间的间隔来实现对齐（会改变 word-spacing 的值）</td>
</tr>
<tr>
<td><code>inter-character</code></td>
<td>增加减少字符间的间隔来实现对齐（会改变 letter-spacing 的值）</td>
</tr>
</tbody></table>
<h2 id="1-5-文本溢出"><a href="#1-5-文本溢出" class="headerlink" title="1.5 文本溢出"></a>1.5 文本溢出</h2><h3 id="1-overflow"><a href="#1-overflow" class="headerlink" title="1 overflow"></a>1 overflow</h3><ul>
<li>当一个元素的内容太大而无法适应 块级格式化上下文 时候该做什么。它是 overflow-x 和overflow-y的 简写属性</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>visible</code>（默认）</td>
<td>内容不会被修剪，可以呈现在元素框之外</td>
</tr>
<tr>
<td><code>hidden</code></td>
<td>内容会被修剪，并且超出内容不可见</td>
</tr>
<tr>
<td><code>scroll</code></td>
<td>内容会被修剪，浏览器会显示滚动条以便查看超出内容</td>
</tr>
<tr>
<td><code>auto</code></td>
<td>由浏览器定夺，如果内容被修剪，就会显示滚动条</td>
</tr>
</tbody></table>
<h3 id="2-text-overflow"><a href="#2-text-overflow" class="headerlink" title="2 text-overflow"></a>2 text-overflow</h3><ul>
<li>规定了当文本溢出其包含元素时以何种方式显示</li>
<li>只是规定了文本溢出后的显示样式，但它不会强制文本溢出</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>clip</code>（默认）</td>
<td>将溢出的文本裁减掉</td>
</tr>
<tr>
<td><code>ellipsis</code></td>
<td>将溢出的文本用省略号<code>...</code>来表示</td>
</tr>
</tbody></table>
<h1 id="二-文本装饰"><a href="#二-文本装饰" class="headerlink" title="二 文本装饰"></a>二 文本装饰</h1><h2 id="2-1-text-docoration"><a href="#2-1-text-docoration" class="headerlink" title="2.1 text-docoration"></a>2.1 text-docoration</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">text-decoration-line ||</span><br><span class="line">text-decoration-style ||</span><br><span class="line">text-decoration-color ||</span><br><span class="line">text-decoration-thickness</span><br></pre></td></tr></table></figure>
<ol>
<li>无序</li>
<li>有任意一个即可</li>
</ol>
<h3 id="2-text-decoration-line"><a href="#2-text-decoration-line" class="headerlink" title="2 text-decoration-line"></a>2 text-decoration-line</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code>（默认）</td>
<td>无线</td>
</tr>
<tr>
<td><code>underline</code></td>
<td>下划线</td>
</tr>
<tr>
<td><code>overline</code></td>
<td>上划线</td>
</tr>
<tr>
<td><code>line-through</code></td>
<td>删除线</td>
</tr>
</tbody></table>
<h3 id="3-text-decoration-style"><a href="#3-text-decoration-style" class="headerlink" title="3 text-decoration-style"></a>3 text-decoration-style</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>solid</code>（默认）</td>
<td>单实线</td>
</tr>
<tr>
<td><code>double</code></td>
<td>双实线</td>
</tr>
<tr>
<td><code>dotted</code></td>
<td>点划线</td>
</tr>
<tr>
<td><code>dashed</code></td>
<td>虚线</td>
</tr>
<tr>
<td><code>wavy</code></td>
<td>波浪线</td>
</tr>
</tbody></table>
<h3 id="4-text-decoration-color"><a href="#4-text-decoration-color" class="headerlink" title="4 text-decoration-color"></a>4 text-decoration-color</h3><ul>
<li><code>&lt;color&gt;</code></li>
</ul>
<h3 id="5-text-decoration-thickness"><a href="#5-text-decoration-thickness" class="headerlink" title="5 text-decoration-thickness"></a>5 text-decoration-thickness</h3><ul>
<li>设置元素中文本所使用的装饰线的厚度或者宽度</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code></td>
<td>浏览器为文本装饰线选择合适的宽度</td>
</tr>
<tr>
<td><code>from-font</code></td>
<td>如果字体文件中包含了首选的厚度值，则使用此字体文件的厚度值，否则同auto</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>指定装饰线厚度</td>
</tr>
</tbody></table>
<h2 id="2-2-text-shadow"><a href="#2-2-text-shadow" class="headerlink" title="2.2 text-shadow"></a>2.2 text-shadow</h2><h3 id="1-语法-1"><a href="#1-语法-1" class="headerlink" title="1 语法"></a>1 语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[offset-x offset-y] blur-radius? ||</span><br><span class="line">color?</span><br></pre></td></tr></table></figure>

<h3 id="2-blur-radius"><a href="#2-blur-radius" class="headerlink" title="2 blur-radius"></a>2 <code>blur-radius</code></h3><ul>
<li>默认为0，值越大，模糊半径越大，阴影也就越大越淡</li>
</ul>
]]></content>
      <categories>
        <category>UI</category>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>CSS 颜色 背景 字体</title>
    <url>/anyeansan.github.io/2020/03/30/CSS-%E9%A2%9C%E8%89%B2-%E8%83%8C%E6%99%AF-%E5%AD%97%E4%BD%93/</url>
    <content><![CDATA[<h1 id="一-颜色"><a href="#一-颜色" class="headerlink" title="一 颜色"></a>一 颜色</h1><h2 id="1-1-color"><a href="#1-1-color" class="headerlink" title="1.1 color"></a>1.1 color</h2><ul>
<li>取值 <code>&lt;color&gt;</code></li>
</ul>
<h2 id="1-2-opacity"><a href="#1-2-opacity" class="headerlink" title="1.2 opacity"></a>1.2 opacity</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>1</code>（默认）</td>
<td>元素完全不透明</td>
</tr>
<tr>
<td><code>0.0~1.0</code></td>
<td>元素半透明</td>
</tr>
<tr>
<td><code>0</code></td>
<td>元素完全透明</td>
</tr>
</tbody></table>
<h1 id="二-背景（background）"><a href="#二-背景（background）" class="headerlink" title="二 背景（background）"></a>二 背景（background）</h1><h2 id="2-1-语法"><a href="#2-1-语法" class="headerlink" title="2.1 语法"></a>2.1 语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">background-color ||</span><br><span class="line">background-image ||</span><br><span class="line">background-position [ / background-size]? || </span><br><span class="line">background-repeat ||</span><br><span class="line">background-attachment ||</span><br><span class="line">background-origin ||</span><br><span class="line">background-clip</span><br></pre></td></tr></table></figure>
<ol>
<li>无序，但是<code>background-origin background-clip</code>有前后顺序，如果只给一个值，则为它俩的共同值</li>
<li><code>background-position / background-size</code> 通过斜杠连接</li>
</ol>
<h2 id="2-2-background-color"><a href="#2-2-background-color" class="headerlink" title="2.2 background-color"></a>2.2 background-color</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>transparent</code>（默认）</td>
<td>透明</td>
</tr>
<tr>
<td><code>&lt;color&gt;</code></td>
<td>取值 <code>&lt;color&gt;</code></td>
</tr>
</tbody></table>
<h2 id="2-3-background-image"><a href="#2-3-background-image" class="headerlink" title="2.3 background-image"></a>2.3 background-image</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code>（默认）</td>
<td>无背景图</td>
</tr>
<tr>
<td><code>&lt;image&gt;</code></td>
<td>取值<code>&lt;image&gt;</code></td>
</tr>
</tbody></table>
<h2 id="2-4-background-repeat"><a href="#2-4-background-repeat" class="headerlink" title="2.4 background-repeat"></a>2.4 background-repeat</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
<th>双值</th>
</tr>
</thead>
<tbody><tr>
<td><code>repeat</code>（默认）</td>
<td>背景图从左上角沿着x轴，y轴重复平铺</td>
<td><code>repeat repeat</code></td>
</tr>
<tr>
<td><code>repeat-x</code></td>
<td>x轴重复</td>
<td><code>repeat no-repeat</code></td>
</tr>
<tr>
<td><code>repeat-y</code></td>
<td>y轴重复</td>
<td><code>no-repeat repeat</code></td>
</tr>
<tr>
<td><code>no-repeat</code></td>
<td>不重复</td>
<td><code>no-repeat no-repeat</code></td>
</tr>
<tr>
<td><code>space</code></td>
<td>两端对齐平铺，多出来的空间用空白代替</td>
<td><code>space space</code></td>
</tr>
<tr>
<td><code>round</code></td>
<td>两端对齐平铺，多出来空间通过自身的拉伸来填充</td>
<td><code>round round</code></td>
</tr>
</tbody></table>
<ul>
<li><code>水平轴 垂直轴</code><ul>
<li>css3 定义时使用两个值，如果只设置一个，也会被解析成两个</li>
</ul>
</li>
</ul>
<h2 id="2-5-background-position"><a href="#2-5-background-position" class="headerlink" title="2.5 background-position"></a>2.5 background-position</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;position&gt;</code></td>
<td>见<code>&lt;position&gt;</code></td>
</tr>
</tbody></table>
<h2 id="2-6-background-attachment"><a href="#2-6-background-attachment" class="headerlink" title="2.6 background-attachment"></a>2.6 background-attachment</h2><ul>
<li>决定背景图像的位置是在视口内固定，还是随着包含它的区块滚动。</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
<th>滚动条</th>
</tr>
</thead>
<tbody><tr>
<td><code>scroll</code>（默认）</td>
<td>背景相对于元素本身固定，会随着元素动，不会随着元素的内容滚动</td>
<td>元素上的滚动条（元素本身是不动的），背景不会动。页面上的滚动条（元素也会动），背景会动</td>
</tr>
<tr>
<td><code>fixed</code></td>
<td>背景相对于视口固定，不会随着元素或元素的内容滚动</td>
<td>不管元素上的滚动条还是页面的滚动条 背景都不动</td>
</tr>
<tr>
<td><code>local</code></td>
<td>背景相对于元素的内容固定，会随着元素或元素的内容滚动</td>
<td>不管元素上的滚动条还是页面的滚动条 背景都会动</td>
</tr>
</tbody></table>
<h2 id="2-7-background-clip"><a href="#2-7-background-clip" class="headerlink" title="2.7 background-clip"></a>2.7 background-clip</h2><ul>
<li>设置元素的背景（背景图片或颜色）切割范围（位置不动，直接裁剪，就好像拿剪刀剪一幅画一样）</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>border-box</code>（默认）</td>
<td>背景延伸至边框外沿（但是在边框下层）</td>
</tr>
<tr>
<td><code>content-box</code></td>
<td>背景被裁剪至内容区外沿</td>
</tr>
<tr>
<td><code>padding-box</code></td>
<td>背景延伸至内边距外沿</td>
</tr>
</tbody></table>
<h2 id="2-8-background-origin"><a href="#2-8-background-origin" class="headerlink" title="2.8 background-origin"></a>2.8 background-origin</h2><ul>
<li>用来决定背景图片定位在哪个盒子中（即改变位置）</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>padding-box</code>（默认）</td>
<td>相对于padding-box定位</td>
</tr>
<tr>
<td><code>content-box</code></td>
<td>相对于content-box定位</td>
</tr>
<tr>
<td><code>border-box</code></td>
<td>相对于border-box定位</td>
</tr>
</tbody></table>
<h2 id="2-9-background-size"><a href="#2-9-background-size" class="headerlink" title="2.9 background-size"></a>2.9 background-size</h2><p>设置背景图片大小</p>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code>（默认）</td>
<td>以背景图片的比例缩放背景图片</td>
</tr>
<tr>
<td><code>cover</code></td>
<td>缩放背景图片以完全覆盖背景区，可能背景图片部分看不见</td>
</tr>
<tr>
<td><code>contain</code></td>
<td>缩放背景图片以完全装入背景区，可能背景区部分空白</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>长度</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>背景图片相对背景区的百分比</td>
</tr>
<tr>
<td>* <code>宽 高</code></td>
<td></td>
</tr>
<tr>
<td>* 默认值 <code>auto auto</code></td>
<td></td>
</tr>
<tr>
<td>* 如果只设置一个值，则第二个值为 <code>auto</code></td>
<td></td>
</tr>
</tbody></table>
<h1 id="三-字体"><a href="#三-字体" class="headerlink" title="三 字体"></a>三 字体</h1><h2 id="3-1-font-face"><a href="#3-1-font-face" class="headerlink" title="3.1 @font face"></a>3.1 <code>@font face</code></h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ul>
<li>自定义字体或字体集</li>
<li>它允许网页开发者为其网页指定在线字体。 通过这种作者自备字体的方式，可以消除对用户电脑字体的依赖</li>
</ul>
<h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2 语法"></a>2 语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">	[ font-family: &lt;family-name&gt;; ] ||</span><br><span class="line">	[ src: &lt;src&gt;; ] ||</span><br><span class="line">	[ unicode-range: &lt;unicode-range&gt;; ] ||</span><br><span class="line">	[ font-variant: &lt;font-variant&gt;; ] ||</span><br><span class="line">	[ font-feature-settings: &lt;font-feature-settings&gt;; ] ||</span><br><span class="line">	[ font-variation-settings: &lt;font-variation-settings&gt;; ] ||</span><br><span class="line">	[ font-stretch: &lt;font-stretch&gt;; ] ||</span><br><span class="line">	[ font-weight: &lt;font-weight&gt;; ] ||</span><br><span class="line">	[ font-style: &lt;font-style&gt;; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-font-family"><a href="#1-font-family" class="headerlink" title="1 font-family"></a>1 font-family</h4><ul>
<li>自定义字体的名称，特殊符号必须使用引号</li>
</ul>
<h4 id="2-src"><a href="#2-src" class="headerlink" title="2 src"></a>2 src</h4><ul>
<li><code>[ &lt;url&gt; [ format( &lt;string&gt;# ) ]? | local( &lt;family-name&gt; ) ]#</code><ol>
<li>可以是在线字体，也可以是本地字体（多个使用逗号隔开）</li>
<li>format用于转换字体格式，用于浏览器识别<ul>
<li><code>fromat(&#39;woff2&#39;)</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th>字体格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>TrueType（.ttf）</code></td>
<td>Windows和Mac上常见的字体格式，是一种原始格式，因此它并没有为网页进行优化处理</td>
</tr>
<tr>
<td><code>OpenType（.otf）</code></td>
<td>以TrueType为基础，也是一种原始格式，但提供更多的功能</td>
</tr>
<tr>
<td><code>Web Open Font（.woff）</code></td>
<td>针对网页进行特殊优化，因此是Web字体中最佳格式</td>
</tr>
<tr>
<td><code>SVG（.svg）</code></td>
<td>基于SVG字体渲染的格式</td>
</tr>
<tr>
<td><code>Embedded Open Type（.eot）</code></td>
<td>IE专用字体格式，可以从TrueType格式创建此格式字体</td>
</tr>
</tbody></table>
<h4 id="3-font-style-amp-font-weight"><a href="#3-font-style-amp-font-weight" class="headerlink" title="3 font-style &amp; font-weight"></a>3 font-style &amp; font-weight</h4><ul>
<li>用来设置对应字体样式或字重下该使用什么字体，font-family相同，可以通过样式和字重设置不同的字体<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">	font-family: &apos;myFont&apos;;</span><br><span class="line">	font-style: normal;</span><br><span class="line">	src: local(&apos;FZYaoti&apos;);</span><br><span class="line">&#125;</span><br><span class="line">@font-face &#123;</span><br><span class="line">	font-family: &apos;myFont&apos;;</span><br><span class="line">	font-style: italic;</span><br><span class="line">	src: local(&apos;FZShuTi&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="4-unicode-range"><a href="#4-unicode-range" class="headerlink" title="4 unicode-range"></a>4 unicode-range</h4><ul>
<li>可以让特定的字符或者字符片段使用特定的字体</li>
<li>语法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 支持的值 */</span><br><span class="line">unicode-range: U+26;               /* 单个字符编码 */</span><br><span class="line">unicode-range: U+0-7F;</span><br><span class="line">unicode-range: U+0025-00FF;        /* 字符编码区间 */</span><br><span class="line">unicode-range: U+4??;              /* 通配符区间 ?表示占位符，U+4??即U+400-U+4FF*/</span><br><span class="line">unicode-range: U+0025-00FF, U+4??; /* 多个值 */</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-2-font"><a href="#3-2-font" class="headerlink" title="3.2 font"></a>3.2 font</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ font-style || font-variant || font-weight || font-stretch ]? font-size [ / line-height ]? font-family |</span><br><span class="line">caption |</span><br><span class="line">icon |</span><br><span class="line">menu |</span><br><span class="line">message-box |</span><br><span class="line">small-caption |</span><br><span class="line">status-bar</span><br></pre></td></tr></table></figure>
<ol>
<li><code>font-size/line-height</code>只能通过斜杠/组成一个值，不能分开写，如<code>12px/1.5</code></li>
<li>font-size和font-family必须有</li>
<li>关键字指字体使用系统相应部位的字体</li>
</ol>
<h3 id="2-font-style"><a href="#2-font-style" class="headerlink" title="2 font-style"></a>2 font-style</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>normal</code>（默认）</td>
<td>常规</td>
</tr>
<tr>
<td><code>italic</code></td>
<td>斜体</td>
</tr>
<tr>
<td><code>oblique &lt;angle&gt;?</code></td>
<td>倾斜体 可以附加角度</td>
</tr>
</tbody></table>
<h3 id="3-font-weight"><a href="#3-font-weight" class="headerlink" title="3 font-weight"></a>3 font-weight</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>normal</code>（默认）</td>
<td>常规</td>
</tr>
<tr>
<td><code>bold</code></td>
<td>加粗</td>
</tr>
<tr>
<td><code>lighter</code></td>
<td>较细</td>
</tr>
<tr>
<td><code>bolder</code></td>
<td>较粗</td>
</tr>
<tr>
<td><code>&lt;number&gt;</code></td>
<td>介于 1 和 1000 (包含) 之间</td>
</tr>
</tbody></table>
<h3 id="4-font-size"><a href="#4-font-size" class="headerlink" title="4 font-size"></a>4 font-size</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>关键字</code></td>
<td><code>xx-small, x-small, small, medium, large, x-large, xx-large, xxx-large, larger, smaller</code></td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>长度，如 <code>px em ex rem</code></td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>相对父元素字体大小的百分比</td>
</tr>
</tbody></table>
<h3 id="5-line-height"><a href="#5-line-height" class="headerlink" title="5 line-height"></a>5 line-height</h3><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>normal</code>（默认）</td>
<td>与font-family 有关，不同浏览器和系统字体不同，默认值就不同，所以通常需要重新设置</td>
</tr>
<tr>
<td><code>&lt;number&gt;</code></td>
<td>推荐，字体大小的倍数。</td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>长度值（如px，em）</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>字体大小的百分比</td>
</tr>
</tbody></table>
<h4 id="数字-长度-百分比的区别"><a href="#数字-长度-百分比的区别" class="headerlink" title="数字 长度 百分比的区别"></a>数字 长度 百分比的区别</h4><ul>
<li><code>line-height:1.5</code>、<code>line-height:150%</code> 和 <code>line-height:1.5em</code> 最终计算结果都是 <code>line-height = font-size * 1.5</code>，但是继承上是有差异的<ul>
<li>数字继承的就是数字本身（所以计算子元素line-height时使用的是子元素的font-size乘以倍数）</li>
<li>长度和百分比继承的是计算值</li>
</ul>
</li>
</ul>
<h3 id="6-font-family"><a href="#6-font-family" class="headerlink" title="6 font-family"></a>6 font-family</h3><ol>
<li>属性值用逗号隔开</li>
<li>浏览器会选择列表中第一个该计算机上有安装的字体，或者是通过 <code>@font-face</code> 指定的可以直接下载的字体</li>
<li>应当至少在使用的 <code>font-family</code> 列表中添加一个通用的字体系列，因为无法保证用户的计算机内已经安装了指定的字体，也不能保证使用 <code>@font-face</code> 提供的字体移动能够正确地下载</li>
</ol>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;family-name&gt;</code></td>
<td>字体名称，有空格时要加引号</td>
</tr>
<tr>
<td><code>&lt;generic-name&gt;</code></td>
<td>字体系列，完全取决于用户机器上该字体系列是否可用，这个属性没有指示任何字体下载</td>
</tr>
</tbody></table>
<ul>
<li>css定义了五种通用字体系列<ol>
<li><code>serif</code><ul>
<li>带衬线字体，笔画结尾有特殊的装饰线或衬线</li>
</ul>
</li>
<li><code>sans-serif</code><ul>
<li>无衬线字体，即笔画结尾是平滑的字体</li>
</ul>
</li>
<li><code>monospace</code><ul>
<li>等宽字体，即字体中每个字宽度相同</li>
</ul>
</li>
<li><code>cursive</code><ul>
<li>草书字体，这种字体有的有连笔，有的还有特殊的斜体效果</li>
</ul>
</li>
<li><code>fantasy</code><ul>
<li>艺术字体</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="7-font-variant-font-stretch"><a href="#7-font-variant-font-stretch" class="headerlink" title="7 font-variant font-stretch"></a>7 font-variant font-stretch</h3><ul>
<li>更像是专为英文设计的，默认即可</li>
</ul>
]]></content>
      <categories>
        <category>UI</category>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>CSS 值类型和单位</title>
    <url>/anyeansan.github.io/2020/03/30/CSS-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8D%95%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="一-文本类型"><a href="#一-文本类型" class="headerlink" title="一 文本类型"></a>一 文本类型</h1><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;ident&gt;</code></td>
<td>预定义标识符</td>
</tr>
<tr>
<td><code>&lt;custom-ident&gt;</code></td>
<td>自定义标识符</td>
</tr>
<tr>
<td><code>&lt;string&gt;</code></td>
<td><code>&#39;&#39;, &quot;&quot;</code></td>
</tr>
<tr>
<td><code>&lt;url&gt;</code></td>
<td><code>url(绝对/相对地址)</code></td>
</tr>
</tbody></table>
<h1 id="二-数值类型"><a href="#二-数值类型" class="headerlink" title="二 数值类型"></a>二 数值类型</h1><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;integer&gt;</code></td>
<td>整数，可以有正负 <code>+ -</code></td>
</tr>
<tr>
<td><code>&lt;number&gt;</code></td>
<td>数字，可以是整数也可以是小数，可以有正负 <code>+ -</code></td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td><code>%</code></td>
</tr>
<tr>
<td><code>&lt;dimension&gt;</code></td>
<td>尺寸，由数字和单位构成，即 <code>&lt;number&gt; + unit = &lt;dimension&gt;</code></td>
</tr>
</tbody></table>
<h1 id="三-单位"><a href="#三-单位" class="headerlink" title="三 单位"></a>三 单位</h1><h2 id="3-1-lt-length-gt"><a href="#3-1-lt-length-gt" class="headerlink" title="3.1 &lt;length&gt;"></a>3.1 <code>&lt;length&gt;</code></h2><table>
<thead>
<tr>
<th>单位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>px</td>
<td>像素</td>
</tr>
<tr>
<td>rem</td>
<td>相对于根元素的字体大小</td>
</tr>
<tr>
<td>r1h</td>
<td>相对于根元素的行高大小</td>
</tr>
<tr>
<td>em</td>
<td>相对于父元素的字体大小</td>
</tr>
<tr>
<td>ex</td>
<td>相对于小写字母”x”的高度即 <code>x-height</code></td>
</tr>
<tr>
<td>ch</td>
<td>相对于字符数字”0”的宽度</td>
</tr>
<tr>
<td>vw</td>
<td>相对于视窗的宽度：视窗宽度是100vw</td>
</tr>
<tr>
<td>vh</td>
<td>相对于视窗的高度：视窗高度是100vh</td>
</tr>
<tr>
<td>vmin</td>
<td>等于<code>vh</code>和<code>vw</code> 中较小的值</td>
</tr>
<tr>
<td>vmax</td>
<td>等于<code>vh</code>和<code>vw</code> 中较大的值</td>
</tr>
</tbody></table>
<h2 id="3-2-lt-angle-gt"><a href="#3-2-lt-angle-gt" class="headerlink" title="3.2 &lt;angle&gt;"></a>3.2 <code>&lt;angle&gt;</code></h2><table>
<thead>
<tr>
<th>单位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>deg</td>
<td>角度，一个完整圆角度是 <code>360deg</code></td>
</tr>
<tr>
<td>rad</td>
<td>弧度，一个完整圆弧度是 <code>2π</code></td>
</tr>
<tr>
<td>grad</td>
<td>百分度，百分度是角的测量单位，常用于建筑或土木工程的角度测量，非相关专业人士用的不多。一个完整圆百分度是 <code>400grad</code></td>
</tr>
<tr>
<td>turn</td>
<td>圈数，一个完整圆圈数是 <code>1turn</code></td>
</tr>
</tbody></table>
<h2 id="3-3-lt-time-gt"><a href="#3-3-lt-time-gt" class="headerlink" title="3.3 &lt;time&gt;"></a>3.3 <code>&lt;time&gt;</code></h2><table>
<thead>
<tr>
<th>单位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>s</td>
<td>秒</td>
</tr>
<tr>
<td>ms</td>
<td>毫秒</td>
</tr>
</tbody></table>
<h2 id="3-4-lt-frequency-gt-（频率）"><a href="#3-4-lt-frequency-gt-（频率）" class="headerlink" title="3.4 &lt;frequency&gt; （频率）"></a>3.4 <code>&lt;frequency&gt;</code> （频率）</h2><table>
<thead>
<tr>
<th>单位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Hz</td>
<td>赫兹</td>
</tr>
<tr>
<td>kHz</td>
<td>千赫兹</td>
</tr>
</tbody></table>
<h2 id="3-5-lt-resolution-gt-（分辨率）"><a href="#3-5-lt-resolution-gt-（分辨率）" class="headerlink" title="3.5 &lt;resolution&gt; （分辨率）"></a>3.5 <code>&lt;resolution&gt;</code> （分辨率）</h2><table>
<thead>
<tr>
<th>单位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>dpi</td>
<td>表示每英寸点数</td>
</tr>
<tr>
<td>dpcm</td>
<td>表示每厘米点数</td>
</tr>
<tr>
<td>dppx</td>
<td>表示每像素点数</td>
</tr>
<tr>
<td>x</td>
<td>dppx的别名</td>
</tr>
</tbody></table>
<h1 id="四-lt-color-gt"><a href="#四-lt-color-gt" class="headerlink" title="四 &lt;color&gt;"></a>四 <code>&lt;color&gt;</code></h1><h2 id="4-1-颜色关键字"><a href="#4-1-颜色关键字" class="headerlink" title="4.1 颜色关键字"></a>4.1 颜色关键字</h2><table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
<th>关键字</th>
<th>说明</th>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>black</td>
<td>黑色</td>
<td>gray</td>
<td>灰色</td>
<td>lime</td>
<td>石灰色</td>
</tr>
<tr>
<td>red</td>
<td>红色</td>
<td>silver</td>
<td>银色</td>
<td>navy</td>
<td>海蓝色</td>
</tr>
<tr>
<td>green</td>
<td>绿色</td>
<td>purple</td>
<td>紫色</td>
<td>teal</td>
<td>蓝绿色</td>
</tr>
<tr>
<td>blue</td>
<td>蓝色</td>
<td>orange</td>
<td>橙色</td>
<td>aqua</td>
<td>浅绿色</td>
</tr>
<tr>
<td>white</td>
<td>白色</td>
<td>maroon</td>
<td>褐色</td>
<td>fuchsia</td>
<td>紫红色</td>
</tr>
<tr>
<td>yellow</td>
<td>黄色</td>
<td>olive</td>
<td>橄榄色</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="4-2-十六进制"><a href="#4-2-十六进制" class="headerlink" title="4.2 十六进制"></a>4.2 十六进制</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>#000000</code></td>
<td>黑色</td>
</tr>
<tr>
<td><code>#ff0000</code></td>
<td>红色</td>
</tr>
<tr>
<td><code>#00ff00</code></td>
<td>绿色</td>
</tr>
<tr>
<td><code>#0000ff</code></td>
<td>蓝色</td>
</tr>
<tr>
<td><code>#ffffff</code></td>
<td>白色</td>
</tr>
<tr>
<td>* 十六进制也属于RGB颜色，<code>#RGB</code></td>
<td></td>
</tr>
<tr>
<td>* 数字范围0~255，十进制 <code>255</code> 转成十六进制即 <code>ff</code></td>
<td></td>
</tr>
</tbody></table>
<h2 id="4-3-RGB"><a href="#4-3-RGB" class="headerlink" title="4.3 RGB"></a>4.3 RGB</h2><ul>
<li><code>rgb(r, g, b)</code><ol>
<li>使用数值 0~255 如<code>rgb(255, 0, 100)</code></li>
<li>使用百分比 如 <code>rgb(100%, 0%, 50%)</code></li>
</ol>
</li>
<li><code>rgba(r, g, b, a)</code><ul>
<li>a即alpha，透明度（0~1）</li>
<li>0表示透明，1表示不透明</li>
</ul>
</li>
</ul>
<h2 id="4-4-hsl"><a href="#4-4-hsl" class="headerlink" title="4.4 hsl"></a>4.4 hsl</h2><ul>
<li><code>hsl(h, s, l)</code><ul>
<li>h即hue，色调（0~360）</li>
<li>s即saturation，饱和度（0%~100%）</li>
<li>l即lightness，亮度（0%~100%）</li>
</ul>
</li>
<li><code>hsla(h, s, l, a)</code></li>
</ul>
<h2 id="4-5-其它关键字"><a href="#4-5-其它关键字" class="headerlink" title="4.5 其它关键字"></a>4.5 其它关键字</h2><table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>transparent</code></td>
<td>透明，可以近似认为是 <code>rgba(0,0,0,0)</code>的缩写</td>
</tr>
<tr>
<td><code>currentColor</code></td>
<td>当前元素的字体颜色，即 `currentColor = color的值</td>
</tr>
</tbody></table>
<h1 id="五-lt-color-stop-gt"><a href="#五-lt-color-stop-gt" class="headerlink" title="五 &lt;color-stop&gt;"></a>五 <code>&lt;color-stop&gt;</code></h1><ul>
<li><code>&lt;color&gt; [ &lt;length&gt; | &lt;percentage&gt; ]?</code><ul>
<li>使用长度或百分比指定颜色起止位置，如果省略，默认 <code>50%</code></li>
</ul>
</li>
</ul>
<h1 id="六-lt-image-gt"><a href="#六-lt-image-gt" class="headerlink" title="六 &lt;image&gt;"></a>六 <code>&lt;image&gt;</code></h1><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;url&gt;</code></td>
<td>使用url引入图片</td>
</tr>
<tr>
<td><code>&lt;gradient&gt;</code></td>
<td>使用渐变</td>
</tr>
<tr>
<td><code>element()</code></td>
<td>可以把页面元素当作背景图片</td>
</tr>
</tbody></table>
<h1 id="七-lt-position-gt"><a href="#七-lt-position-gt" class="headerlink" title="七 &lt;position&gt;"></a>七 <code>&lt;position&gt;</code></h1><ul>
<li>通过距离上下左右的距离指定二维坐标<code>x, y</code>，顺序任意，可以为负，如果省略则默认为 <code>center</code> </li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>关键字</code></td>
<td><code>left right top bottom center</code></td>
</tr>
<tr>
<td><code>&lt;length&gt;</code></td>
<td>指定长度</td>
</tr>
<tr>
<td><code>&lt;percentage&gt;</code></td>
<td>指定百分比</td>
</tr>
</tbody></table>
<ul>
<li>一个值<ul>
<li><code>keyword</code><ul>
<li>指定水平或垂直中的一个，另一个默认为 <code>center</code></li>
</ul>
</li>
<li><code>value</code><ul>
<li>指定水平，垂直默认 <code>50%</code></li>
</ul>
</li>
</ul>
</li>
<li>两个值<ul>
<li>一个指定水平，一个指定垂直</li>
</ul>
</li>
<li>四个值<ul>
<li><code>keyword value keyword value</code><ul>
<li>keyword来表示水平或着垂直，value为值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="八-lt-gradient-gt"><a href="#八-lt-gradient-gt" class="headerlink" title="八 &lt;gradient&gt;"></a>八 <code>&lt;gradient&gt;</code></h1><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>linear-gradient()</code></td>
<td>线性渐变，颜色值沿着一条隐式的直线逐渐过渡</td>
</tr>
<tr>
<td><code>radial-gradient()</code></td>
<td>径向渐变，颜色值由一个中心点（原点）向外扩散并逐渐过渡到其他颜色值</td>
</tr>
<tr>
<td><code>repeating-linear-gradient()</code></td>
<td>重复渐变，重复多次渐变图案直到足够填满指定元素</td>
</tr>
<tr>
<td><code>repeating-radial-gradient()</code></td>
<td>重复渐变</td>
</tr>
<tr>
<td><code>conic-gradient()</code></td>
<td>锥形渐变，颜色值围绕圆逐渐过渡</td>
</tr>
</tbody></table>
<h2 id="8-1-线性渐变语法"><a href="#8-1-线性渐变语法" class="headerlink" title="8.1 线性渐变语法"></a>8.1 线性渐变语法</h2><ul>
<li><code>[ [ [ &lt;angle&gt; | to [top | bottom] || [left | right] ],]? &lt;color-stop&gt; [, &lt;color-stop&gt;]+</code><ol>
<li>第一个参数代表渐变的方向（默认 <code>180deg</code>）<ol>
<li>角度<ul>
<li><code>180deg</code> 代表垂直向下，也就是<code>to bottom</code></li>
<li><code>90deg</code> 代表水平向右，也就是 <code>to right</code></li>
</ul>
</li>
<li>方向<ul>
<li><code>to left</code></li>
<li><code>to top right</code></li>
</ul>
</li>
</ol>
</li>
<li>第二个参数是颜色起止位置，见<code>&lt;color-stop&gt;</code></li>
</ol>
</li>
</ul>
<h2 id="8-2-径向渐变语法"><a href="#8-2-径向渐变语法" class="headerlink" title="8.2 径向渐变语法"></a>8.2 径向渐变语法</h2><ul>
<li><code>[ &lt;ending-shape&gt; || &lt;size&gt; ]? [ at &lt;position&gt; ]? , &lt;color-stop&gt; [, &lt;color-stop&gt;]+</code><ol>
<li>第一个参数表示渐变的形状和大小<ol>
<li><code>&lt;ending-shape&gt;</code><ul>
<li>circle 圆形（默认）</li>
<li>ellipse 椭圆</li>
</ul>
</li>
<li><code>&lt;size&gt;</code><ul>
<li><code>closest-side</code> 近边</li>
<li><code>farthest-side</code> 远边</li>
<li><code>closest-corner</code> 近角</li>
<li><code>farthest-corner</code> 远角</li>
</ul>
</li>
</ol>
</li>
<li>第二个参数表示渐变的位置，见 <code>&lt;position&gt;</code></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>UI</category>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>CSS 选择器</title>
    <url>/anyeansan.github.io/2020/03/30/CSS-%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="一-选择器"><a href="#一-选择器" class="headerlink" title="一 选择器"></a>一 选择器</h1><h2 id="1-1-说明"><a href="#1-1-说明" class="headerlink" title="1.1 说明"></a>1.1 说明</h2><ul>
<li>最初定义时，所选元素必须有一个parent。而从选择器 Level 4 开始，parent不再是必须的<ul>
<li><code>p :first-child</code><ul>
<li>表示祖先元素p下的第一个子元素</li>
</ul>
</li>
<li><code>p:first-child</code><ul>
<li>表示同一个父元素下的第一个为p的子元素，如果第一个子元素不是p，会没有结果</li>
<li>我原来的理解是错误的（我理解的是p是父元素，寻找p的第一个子元素）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-2-权重"><a href="#1-2-权重" class="headerlink" title="1.2 权重"></a>1.2 权重</h2><p>规则|粒度<br>—|—|—<br><code>!important</code>|10000<br>行内|1000<br>id|0100<br>class，伪类，属性|0010<br>标签，伪元素|0001<br>*|0000<br>A&gt;B|null（继承没有权重，比0小）</p>
<ul>
<li>比较样式的优先级，即算出所有选择器权重之和，然后比较大小</li>
</ul>
<h2 id="1-3-基础选择器"><a href="#1-3-基础选择器" class="headerlink" title="1.3 基础选择器"></a>1.3 基础选择器</h2><table>
<thead>
<tr>
<th>选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>html {}</code></td>
<td>元素选择器</td>
</tr>
<tr>
<td><code>#id {}</code></td>
<td>id 选择器</td>
</tr>
<tr>
<td><code>.class {}</code></td>
<td>class 选择器</td>
</tr>
<tr>
<td><code>* {}</code></td>
<td>通配选择器</td>
</tr>
<tr>
<td><code>s1, s2, s3, ... {}</code></td>
<td>组合选择器（并集）</td>
</tr>
</tbody></table>
<h2 id="1-4-关系选择器"><a href="#1-4-关系选择器" class="headerlink" title="1.4 关系选择器"></a>1.4 关系选择器</h2><table>
<thead>
<tr>
<th>关系选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>A E</code></td>
<td>元素E为元素A的后代元素 <code>祖先元素 后代元素</code></td>
</tr>
<tr>
<td><code>A &gt; E</code></td>
<td>元素E为元素A的子元素  <code>父元素 &gt; 子元素</code></td>
</tr>
<tr>
<td><code>B ~ E</code></td>
<td>元素E为元素B的兄弟元素 <code>老n ~ 老m</code></td>
</tr>
<tr>
<td><code>B + E</code></td>
<td>元素E为元素B的下一个兄弟元素 <code>老n + 老n+1</code></td>
</tr>
</tbody></table>
<h2 id="1-5-属性选择器"><a href="#1-5-属性选择器" class="headerlink" title="1.5 属性选择器"></a>1.5 属性选择器</h2><table>
<thead>
<tr>
<th>属性选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>[attr]</code></td>
<td>带有attr属性的元素</td>
</tr>
<tr>
<td><code>[attr=value]</code></td>
<td>attr属性值为value的元素</td>
</tr>
<tr>
<td><code>[attr^=value]</code></td>
<td>attr属性值以value开头的元素</td>
</tr>
<tr>
<td><code>[attr$=value]</code></td>
<td>attr属性值以value结尾的元素</td>
</tr>
<tr>
<td><code>[attr*=value]</code></td>
<td>attr属性值包含value的元素</td>
</tr>
</tbody></table>
<h2 id="1-6-伪类选择器"><a href="#1-6-伪类选择器" class="headerlink" title="1.6 伪类选择器"></a>1.6 伪类选择器</h2><table>
<thead>
<tr>
<th>伪类选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>:link</code></td>
<td>未访问</td>
</tr>
<tr>
<td><code>:visited</code></td>
<td>已访问</td>
</tr>
<tr>
<td><code>:active</code></td>
<td>点击</td>
</tr>
<tr>
<td><code>:hover</code></td>
<td>悬停</td>
</tr>
<tr>
<td><code>:focus</code></td>
<td>获取焦点</td>
</tr>
<tr>
<td><code>:not()</code></td>
<td>非（权重由括号内决定，自身0，不支持复杂选择器）</td>
</tr>
<tr>
<td><code>:first-child</code></td>
<td>第一个子元素</td>
</tr>
<tr>
<td><code>:last-child</code></td>
<td>最后一个子元素</td>
</tr>
<tr>
<td><code>:noly-child</code></td>
<td>唯一的子元素</td>
</tr>
<tr>
<td><code>:nth-child(表达式)</code></td>
<td>匹配符合表达式结果的子元素（子元素从1开始)</td>
</tr>
<tr>
<td><code>:nth-last-child(表达式)</code></td>
<td>从后匹配符合表达式结果的子元素</td>
</tr>
<tr>
<td><code>:fitst-of-type</code></td>
<td>第一个与父元素相同类型的子元素</td>
</tr>
<tr>
<td><code>:last-of-type</code></td>
<td>最后一个与父元素相同类型的子元素</td>
</tr>
<tr>
<td><code>:noly-of-type</code></td>
<td>唯一与父元素相同类型的子元素</td>
</tr>
<tr>
<td><code>:nth-of-type(表达式)</code></td>
<td>匹配符合表达式结果的与父元素相同类型的子元素</td>
</tr>
<tr>
<td><code>:nth-last-of-type(表达式)</code></td>
<td>从后匹配符合表达式结果的与父元素相同类型的子元素</td>
</tr>
<tr>
<td><code>:empty</code></td>
<td>没有子元素的元素</td>
</tr>
<tr>
<td><code>:checked</code></td>
<td>匹配选中的radio，checkbox，option</td>
</tr>
<tr>
<td><code>:default</code></td>
<td>匹配默认选中的元素</td>
</tr>
<tr>
<td><code>:enabled</code></td>
<td>匹配启用的元素（可选择，点击，文本输入，获取焦点…）</td>
</tr>
<tr>
<td><code>:disabled</code></td>
<td>匹配禁用的元素</td>
</tr>
<tr>
<td><code>:target</code></td>
<td>代表一个唯一的页面元素(目标元素)，其id 与当前URL片段匹配</td>
</tr>
<tr>
<td><code>:valid</code></td>
<td>匹配条件验证正确的表单元素</td>
</tr>
<tr>
<td><code>:invalid</code></td>
<td>匹配条件验证失败的表单元素</td>
</tr>
<tr>
<td><code>:required</code></td>
<td>匹配必须的表单元素</td>
</tr>
<tr>
<td><code>:optional</code></td>
<td>匹配可选的表单元素</td>
</tr>
<tr>
<td><code>:root</code></td>
<td>根元素即html</td>
</tr>
<tr>
<td>* 表达式</td>
<td></td>
</tr>
<tr>
<td>* <code>an+b</code></td>
<td></td>
</tr>
<tr>
<td>* a和b为整数，（n=0，1，2，3…）</td>
<td></td>
</tr>
<tr>
<td>* 元素从1开始</td>
<td></td>
</tr>
<tr>
<td>* 例如</td>
<td></td>
</tr>
<tr>
<td>* <code>0n+3/3</code>，匹配第三个</td>
<td></td>
</tr>
<tr>
<td>* <code>1n+0/n</code>，匹配每一个</td>
<td></td>
</tr>
<tr>
<td>* <code>-n+3</code>，匹配前三个</td>
<td></td>
</tr>
<tr>
<td>* <code>2n+0/2n</code> 匹配偶数位置，或<code>even</code></td>
<td></td>
</tr>
<tr>
<td>* <code>2n+1</code>，匹配奇数位置，或<code>odd</code></td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-7-伪元素选择器"><a href="#1-7-伪元素选择器" class="headerlink" title="1.7 伪元素选择器"></a>1.7 伪元素选择器</h2><table>
<thead>
<tr>
<th>伪元素选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>::before</code></td>
<td>在元素内容的最前面添加新内容</td>
</tr>
<tr>
<td><code>::after</code></td>
<td>在元素内容的最后面添加新内容</td>
</tr>
<tr>
<td><code>::first-letter</code></td>
<td>匹配元素文本的第一个字（母）</td>
</tr>
<tr>
<td><code>::first-line</code></td>
<td>匹配元素文本的第一行</td>
</tr>
<tr>
<td><code>::selection</code></td>
<td>匹配被用户选中或者处于高亮状态的部分</td>
</tr>
<tr>
<td><code>::placeholder</code></td>
<td>匹配占位符的文本</td>
</tr>
<tr>
<td>* 注：</td>
<td></td>
</tr>
<tr>
<td>* 伪元素默认都是内联水平</td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-8-伪类-amp-伪元素"><a href="#1-8-伪类-amp-伪元素" class="headerlink" title="1.8 伪类 &amp; 伪元素"></a>1.8 伪类 &amp; 伪元素</h2><h3 id="1-伪类"><a href="#1-伪类" class="headerlink" title="1 伪类"></a>1 伪类</h3><ul>
<li>为了通过选择器，格式化DOM树以外的信息以及不能被常规CSS选择器获取到的信息<ol>
<li>格式化DOM树以外的信息。如<code>&lt;a&gt;</code>的<code>:link，:visited</code>，这些不在dom树中</li>
<li>不能被常规CSS选择器获取到的信息。如第一个子元素，常规css选择器无法获取，可以通过<code>:first-child</code> 获取</li>
</ol>
</li>
</ul>
<h3 id="2-伪元素"><a href="#2-伪元素" class="headerlink" title="2 伪元素"></a>2 伪元素</h3><ul>
<li>伪元素可以创建一些文档语言无法创建的虚拟元素。<ul>
<li>比如：<ul>
<li>文档语言没有一种机制可以描述元素内容的第一个字母或第一行，但伪元素可以做到(<code>::first-letter、::first-line</code>)。</li>
<li>伪元素还可以创建源文档不存在的内容，比如使用 <code>::before 或 ::after</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3 区别"></a>3 区别</h3><ul>
<li>伪类其实是弥补了CSS选择器的不足，用来更方便地获取信息。即补充css选择器</li>
<li>伪元素本质上是创建了一个虚拟容器(元素)，我们可以在其中添加内容或样式</li>
<li>css3中伪类使用<code>:</code> 伪元素使用<code>::</code></li>
</ul>
]]></content>
      <categories>
        <category>UI</category>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>CSS 概述</title>
    <url>/anyeansan.github.io/2020/03/30/CSS-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-CSS"><a href="#1-1-CSS" class="headerlink" title="1.1 CSS"></a>1.1 CSS</h2><ul>
<li><code>Cascading Style Sheets</code> 层叠样式表</li>
</ul>
<h2 id="1-2-规范"><a href="#1-2-规范" class="headerlink" title="1.2 规范"></a>1.2 规范</h2><ul>
<li>CSS1 &amp; CSS2<ul>
<li>都是单一的规范</li>
</ul>
</li>
<li>CSS3<ul>
<li>CSS3 由于css内容日益增多，被划分成了多个模块，每个模块都有自己的规范</li>
</ul>
</li>
</ul>
<h2 id="1-3-周边"><a href="#1-3-周边" class="headerlink" title="1.3 周边"></a>1.3 周边</h2><ul>
<li><code>less css</code><ul>
<li>一种简化的功能更多的css语言</li>
</ul>
</li>
<li><code>sass</code><ul>
<li>一种简化的功能更多的css语言</li>
</ul>
</li>
<li><code>postcss</code><ul>
<li>一种css处理程序</li>
</ul>
</li>
</ul>
<h1 id="二-语法"><a href="#二-语法" class="headerlink" title="二 语法"></a>二 语法</h1><h2 id="2-1-注释"><a href="#2-1-注释" class="headerlink" title="2.1 注释"></a>2.1 注释</h2><ul>
<li><code>/* */</code></li>
</ul>
<h2 id="2-2-CSS属性值定义语法中的符号说明"><a href="#2-2-CSS属性值定义语法中的符号说明" class="headerlink" title="2.2 CSS属性值定义语法中的符号说明"></a>2.2 CSS属性值定义语法中的符号说明</h2><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>[]</td>
<td>表示组</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>空格前后的各部分必须出现且按顺序出现</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>各部分必须出现，但可以不按顺序</td>
</tr>
<tr>
<td>&#124;&#124;</td>
<td>各部分至少出现一个，可以不按顺序</td>
</tr>
<tr>
<td>&#124;</td>
<td>各部分只能出现一个</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>值类型</td>
</tr>
<tr>
<td>?</td>
<td>零次或一次</td>
</tr>
<tr>
<td>*</td>
<td>零次、一次或多次</td>
</tr>
<tr>
<td>+</td>
<td>一次或多次</td>
</tr>
<tr>
<td>#</td>
<td>一次或多次，但多次出现必须以逗号分隔</td>
</tr>
<tr>
<td>{m,n}</td>
<td>至少m次，至多n次</td>
</tr>
<tr>
<td>!</td>
<td>组后面的叹号表示该组是必需的，并且至少产生一个值；即使组内项目的语法允许省略全部的值，也至少要保留一个值</td>
</tr>
</tbody></table>
<h2 id="2-3-样式语法"><a href="#2-3-样式语法" class="headerlink" title="2.3 样式语法"></a>2.3 样式语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择器 &#123;</span><br><span class="line">	属性:值;</span><br><span class="line">	属性:值 值;</span><br><span class="line">	属性:值 值 值;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>属性:值;</code> 即声明，声明可以有多个，声明之间用<strong>分号</strong>隔开，表示结束</li>
<li>属性与值之间用<strong>冒号</strong>隔开</li>
<li>一个属性有多个值用<strong>空格</strong>隔开</li>
</ul>
<h1 id="三-HTML引入CSS样式"><a href="#三-HTML引入CSS样式" class="headerlink" title="三 HTML引入CSS样式"></a>三 HTML引入CSS样式</h1><h2 id="3-1-内联样式（行内样式）"><a href="#3-1-内联样式（行内样式）" class="headerlink" title="3.1 内联样式（行内样式）"></a>3.1 内联样式（行内样式）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;属性:值;属性:值;&quot;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>每个html标签都有一个<strong>style属性</strong>，该属性的值就是css样式</li>
</ul>
<h2 id="3-2-内部样式"><a href="#3-2-内部样式" class="headerlink" title="3.2 内部样式"></a>3.2 内部样式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">	css样式</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>在当前页面使用<code>&lt;style&gt;</code>标签书写css样式</li>
</ul>
<h2 id="3-3-外部样式"><a href="#3-3-外部样式" class="headerlink" title="3.3 外部样式"></a>3.3 外部样式</h2><ul>
<li>将css样式抽取成一个单独css文件,使用时导入页面。</li>
</ul>
<h3 id="导入方式"><a href="#导入方式" class="headerlink" title="导入方式"></a>导入方式</h3><ol>
<li><code>&lt;link&gt;</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure></li>
<li><code>@import</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1 在html导入css文件</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">	@import url(&quot;&quot;); </span><br><span class="line">&lt;/style&gt;</span><br><span class="line">// 2 在css文件中引入其它css文件（需在文件头部）</span><br><span class="line">@import url(&apos;&apos;)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><code>link</code> 和 <code>@import</code>方式的区别<ol>
<li><code>link</code> 属于 HTML 标签，而 <code>@import</code> 是 CSS 提供的</li>
<li><code>@import</code> 只在 IE 5 以上才能识别，而 <code>link</code> 是 HTML 标签，无兼容问题</li>
<li>页面被加载时，<code>link</code> 会同时被加载，而 <code>@import</code> 引用的 CSS 会等到页面被加载完再加载</li>
<li><code>link</code> 方式的样式的权重高于 <code>@import</code> 权重</li>
<li><code>@import</code> 不支持js的动态修改</li>
<li>一般推荐<code>link</code>，<code>@import</code> 补充使用</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>UI</category>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>HTML</title>
    <url>/anyeansan.github.io/2020/03/30/HTML/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-HTML"><a href="#1-1-HTML" class="headerlink" title="1.1 HTML"></a>1.1 HTML</h2><ul>
<li><code>Hyper Text Markup Language</code></li>
<li>超文本标记语言 <ul>
<li>超文本<ul>
<li>指页面可以包含非文字内容。</li>
</ul>
</li>
<li>标记<ul>
<li>使用标签将需要的内容包括起来</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-2-XHTML"><a href="#1-2-XHTML" class="headerlink" title="1.2 XHTML"></a>1.2 XHTML</h2><ul>
<li><code>Extensible Hyper Text Markup Language</code></li>
<li>可扩展的超文本标记语言<ul>
<li>可以理解为升级版HTML</li>
</ul>
</li>
</ul>
<h1 id="二-实体"><a href="#二-实体" class="headerlink" title="二 实体"></a>二 实体</h1><p>字符|描述|实体代码|实体编号<br>—|—<br>&nbsp;|空格|<code>&amp;nbsp;</code>|<code>&amp;#160;</code></p>
<blockquote>
<p>| 大于号|<code>&amp;gt;</code>|<code>&amp;#62;</code><br>&lt;|小于号|<code>&amp;lt;</code>|<code>&amp;#60;</code><br>&amp;|与|<code>&amp;amp;</code>|<code>&amp;#38;</code><br>“|双引号|<code>&amp;quot;</code>|<code>&amp;#34;</code><br>‘|单引号|&nbsp;|<code>&amp;#39;</code><br>&#96;|反引号|&nbsp;|<code>&amp;#96;</code><br>&#124;|竖线|&nbsp;|<code>&amp;#124</code><br>©|版权|<code>&amp;copy;</code>|<code>&amp;#169;</code><br>®|注册|<code>&amp;reg;</code>|<code>&amp;#174;</code><br>™|商标|<code>&amp;trade;</code>|<code>&amp;#8482;</code></p>
</blockquote>
<h2 id="前端字符表示方式"><a href="#前端字符表示方式" class="headerlink" title="前端字符表示方式"></a>前端字符表示方式</h2><ol>
<li>HTML中字符输出使用&amp;#x配上charCode值；</li>
<li>在JavaScript文件中为防止乱码转义，则是\u配上charCode值；</li>
<li>而在CSS文件中，如CSS伪元素的content属性，直接使用\配上charCode值。</li>
<li>unicode-range是U+配上charCode值。</li>
</ol>
<h1 id="三-标签"><a href="#三-标签" class="headerlink" title="三 标签"></a>三 标签</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">	&lt;meta name=&quot;&quot; content=&quot;&quot;&gt;</span><br><span class="line">	&lt;meta http-equiv=&quot;&quot; content=&quot;&quot;&gt;</span><br><span class="line">	&lt;base href=&quot;&quot; target=&quot;&quot;&gt;</span><br><span class="line">	&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">	&lt;link&gt;</span><br><span class="line">	&lt;style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;header&gt;</span><br><span class="line">	&lt;/header&gt;</span><br><span class="line">	&lt;main&gt;</span><br><span class="line">		&lt;article&gt;</span><br><span class="line">			&lt;section&gt;&lt;/section&gt;</span><br><span class="line">			&lt;section&gt;&lt;/section&gt;</span><br><span class="line">			&lt;aside&gt;&lt;/aside&gt;</span><br><span class="line">		&lt;/article&gt;</span><br><span class="line">	&lt;/main&gt;</span><br><span class="line">	&lt;footer&gt;</span><br><span class="line">	&lt;/footer&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-1-文档声明"><a href="#3-1-文档声明" class="headerlink" title="3.1 文档声明"></a>3.1 文档声明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-根元素"><a href="#3-2-根元素" class="headerlink" title="3.2 根元素"></a>3.2 根元素</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html lang=&quot;&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="lang-属性"><a href="#lang-属性" class="headerlink" title="lang 属性"></a>lang 属性</h3><ol>
<li>作用<ol>
<li>搜索引擎无法判断页面中的内容是什么语言，需要我们告诉它</li>
<li>浏览器会将读取到的页面语言和本地语言进行比较判断，如果一致，不做处理，否则提示是否需要翻译（如果有此功能）</li>
<li>有时候明明页面是中文由于设置的 <code>lang=&quot;en&quot;</code>，还会提示是否翻译，就是此原因</li>
</ol>
</li>
<li>值<ul>
<li>英文<ul>
<li><code>en</code></li>
</ul>
</li>
<li>中文<ul>
<li><code>zh-CN</code> 用的最多其实已过时</li>
<li><code>zh-Hans</code> 简体中文</li>
<li><code>zh-cmn-Hans</code> 以简体中文书写的普通话用词</li>
<li><code>zh-yue-Hans</code> 以简体中文书写的粤语用词</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="3-3-文档元数据（Metadata）"><a href="#3-3-文档元数据（Metadata）" class="headerlink" title="3.3 文档元数据（Metadata）"></a>3.3 文档元数据（Metadata）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 文档元数据定义在 head 标签中</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">	&lt;meta name=&quot;&quot; content=&quot;&quot;&gt;</span><br><span class="line">	&lt;meta http-equiv=&quot;&quot; content=&quot;&quot;&gt;</span><br><span class="line">	# 定义此文档中所有相对URL的根URL</span><br><span class="line">	&lt;base href=&quot;&quot; target=&quot;&quot;&gt;</span><br><span class="line">	&lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">	&lt;link&gt;</span><br><span class="line">	&lt;style&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-文档结构"><a href="#3-4-文档结构" class="headerlink" title="3.4 文档结构"></a>3.4 文档结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;header&gt;</span><br><span class="line">	&lt;/header&gt;</span><br><span class="line">	&lt;main&gt;</span><br><span class="line">		&lt;article&gt;</span><br><span class="line">			&lt;section&gt;&lt;/section&gt;</span><br><span class="line">			&lt;section&gt;&lt;/section&gt;</span><br><span class="line">			&lt;aside&gt;&lt;/aside&gt;</span><br><span class="line">		&lt;/article&gt;</span><br><span class="line">	&lt;/main&gt;</span><br><span class="line">	&lt;footer&gt;</span><br><span class="line">	&lt;/footer&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>标签</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;header&gt;</code></td>
<td>文档页眉，用于展示介绍性内容，通常包含一组介绍性的或是辅助导航的实用元素，如标题 Logo、搜索框、作者名称，等等</td>
</tr>
<tr>
<td><code>&lt;footer&gt;</code></td>
<td>文档页脚，通常包含该章节作者、版权数据或者与文档相关的链接等信息</td>
</tr>
<tr>
<td><code>&lt;main&gt;</code></td>
<td>文档主体</td>
</tr>
<tr>
<td><code>&lt;nav&gt;</code></td>
<td>导航链接，如菜单，目录和索引…</td>
</tr>
<tr>
<td><code>&lt;artical&gt;</code></td>
<td>定义独立的自包含内容区域</td>
</tr>
<tr>
<td><code>&lt;section&gt;</code></td>
<td>定义一个区块，一般是一组相似内容的排列组合</td>
</tr>
<tr>
<td><code>&lt;aside&gt;</code></td>
<td>附加区域，用于设置与主要区域无关的内容，比如侧面栏的广告等</td>
</tr>
</tbody></table>
<h3 id="lt-body-gt"><a href="#lt-body-gt" class="headerlink" title="&lt;body&gt;"></a><code>&lt;body&gt;</code></h3><ol>
<li><code>&lt;body&gt;</code> 默认并不是全屏的</li>
<li><code>&lt;body&gt;</code> 是块元素所以默认宽度为100%，高度0</li>
<li><code>&lt;body&gt;</code> 设置背景色时，会发现覆盖全屏，其实是因为当html不设置背景时，body的背景将作为整个浏览器的背景色</li>
</ol>
<h2 id="3-5-文本相关"><a href="#3-5-文本相关" class="headerlink" title="3.5 文本相关"></a>3.5 文本相关</h2><table>
<thead>
<tr>
<th>标签</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;br&gt;</code></td>
<td>换行</td>
</tr>
<tr>
<td><code>&lt;hr&gt;</code></td>
<td>横线</td>
</tr>
<tr>
<td><code>&lt;h1&gt;~&lt;h6&gt;</code></td>
<td>标题标签</td>
</tr>
<tr>
<td><code>&lt;div&gt;</code></td>
<td>块标签</td>
</tr>
<tr>
<td><code>&lt;span&gt;</code></td>
<td>行内标签</td>
</tr>
<tr>
<td><code>&lt;p&gt;</code></td>
<td>段落标签</td>
</tr>
<tr>
<td><code>&lt;pre&gt;</code></td>
<td>原样显示文本内容包括空白、换行等</td>
</tr>
<tr>
<td><code>&lt;em&gt;</code></td>
<td>着重元素，显示为斜体</td>
</tr>
<tr>
<td><code>&lt;i&gt;</code></td>
<td>斜体，因某些原因需要区分普通文本的一系列文本，如技术术语、外文短语或是小说中人物的思想活动</td>
</tr>
<tr>
<td><code>&lt;strong&gt;</code></td>
<td>强调</td>
</tr>
<tr>
<td><code>&lt;mark&gt;</code></td>
<td>突出显示，类似生活中使用的马克笔</td>
</tr>
<tr>
<td><code>&lt;del&gt;</code></td>
<td>表示删除的内容，通常与<code>&lt;ins&gt;</code> 配合表示更新与修正</td>
</tr>
<tr>
<td><code>&lt;ins&gt;</code></td>
<td>表示文档中添加的内容</td>
</tr>
<tr>
<td><code>&lt;abbr&gt;</code></td>
<td>缩写</td>
</tr>
<tr>
<td><code>&lt;sub&gt;</code></td>
<td>下标</td>
</tr>
<tr>
<td><code>&lt;sup&gt;</code></td>
<td>上标</td>
</tr>
<tr>
<td><code>&lt;cite&gt;</code></td>
<td>通常表示它所包含的文本对某个参考文献的引用，或文章作者的名字，来源</td>
</tr>
<tr>
<td><code>&lt;blockquote&gt;</code></td>
<td>用来定义摘自另一个源的块引用</td>
</tr>
<tr>
<td><code>&lt;q&gt;</code></td>
<td>用于表示行内引用文本</td>
</tr>
<tr>
<td><code>&lt;address&gt;</code></td>
<td>设置联系地址等信息，通常放在 <code>&lt;footer&gt;</code> 中</td>
</tr>
<tr>
<td><code>&lt;progress&gt;</code></td>
<td>进度条</td>
</tr>
</tbody></table>
<h2 id="3-6-图片-amp-链接"><a href="#3-6-图片-amp-链接" class="headerlink" title="3.6 图片 &amp; 链接"></a>3.6 图片 &amp; 链接</h2><h3 id="1-lt-img-gt"><a href="#1-lt-img-gt" class="headerlink" title="1 &lt;img&gt;"></a>1 <code>&lt;img&gt;</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;图片地址&quot; alt=&quot;图片无法正常显示时的文字&quot; &gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-lt-a-gt"><a href="#2-lt-a-gt" class="headerlink" title="2  &lt;a&gt;"></a>2  <code>&lt;a&gt;</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;支持协议的URL或锚点&quot; target=&quot;&quot; title=&quot;链接提示文本&quot;&gt; 链接显示文本 &lt;/a&gt;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>target</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>_selt</code></td>
<td>默认，当前页面打开</td>
</tr>
<tr>
<td><code>_blank</code></td>
<td>新页面打开</td>
</tr>
<tr>
<td><code>_parent</code></td>
<td>父级页面打开</td>
</tr>
<tr>
<td><code>_top</code></td>
<td>祖先页面打开</td>
</tr>
</tbody></table>
<h2 id="3-7-列表"><a href="#3-7-列表" class="headerlink" title="3.7 列表"></a>3.7 列表</h2><h3 id="1-lt-ul-gt"><a href="#1-lt-ul-gt" class="headerlink" title="1 &lt;ul&gt;"></a>1 <code>&lt;ul&gt;</code></h3><ul>
<li><code>unorder list</code>：无序列表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">	&lt;li&gt;&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;&lt;/li&gt;</span><br><span class="line">	...</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-lt-ol-gt"><a href="#2-lt-ol-gt" class="headerlink" title="2 &lt;ol&gt;"></a>2 <code>&lt;ol&gt;</code></h3><ul>
<li><code>order list</code>：有序列表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">	&lt;li type=&quot;1、A、a、I、i&quot; start=&quot;首项从第几个开始&quot;&gt;&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;&lt;/li&gt;</span><br><span class="line">	...</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-lt-dl-gt"><a href="#3-lt-dl-gt" class="headerlink" title="3 &lt;dl&gt;"></a>3 <code>&lt;dl&gt;</code></h3><ul>
<li><code>definition list</code>：定义列表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">	&lt;dt&gt;孙悟空&lt;/dt&gt;</span><br><span class="line">	&lt;dd&gt;美猴王&lt;/dd&gt;</span><br><span class="line">	&lt;dd&gt;齐天大圣&lt;/dd&gt;</span><br><span class="line">	&lt;dd&gt;斗战胜佛&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-8-表格标签"><a href="#3-8-表格标签" class="headerlink" title="3.8 表格标签"></a>3.8 表格标签</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">	&lt;colgroup&gt;</span><br><span class="line">		&lt;col width=&quot;控制第1列宽度&quot;&gt;</span><br><span class="line">		&lt;col width=&quot;控制第2列宽度&quot;&gt;</span><br><span class="line">		&lt;col width=&quot;控制第3列宽度&quot;&gt;</span><br><span class="line">	&lt;colgroup&gt;</span><br><span class="line">	&lt;caption&gt;表格标题&lt;/caption&gt;</span><br><span class="line">	&lt;thead&gt;</span><br><span class="line">		&lt;tr&gt;</span><br><span class="line">			&lt;th&gt;行列标题，内容默认居中，加粗&lt;/th&gt;</span><br><span class="line">		&lt;/tr&gt;	</span><br><span class="line">	&lt;/thead&gt;</span><br><span class="line">	&lt;tbody&gt;</span><br><span class="line">		&lt;tr&gt;</span><br><span class="line">			&lt;td colspan=&quot;列合并&quot; rowspan=&quot;行合并&quot;&gt;&lt;/td&gt;</span><br><span class="line">		&lt;/tr&gt;</span><br><span class="line">	&lt;/tbody&gt;</span><br><span class="line">	&lt;tfoot&gt;</span><br><span class="line">		&lt;tr&gt;</span><br><span class="line">			&lt;td&gt;&lt;/td&gt;</span><br><span class="line">		&lt;/tr&gt;</span><br><span class="line">	&lt;/tfoot&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用<code>&lt;thead&gt;&lt;tbody&gt;&lt;tfoot&gt;</code>的好处是规定位置，即使代码的顺序是乱的，显示也是正确的。</li>
<li><code>&lt;thead&gt;&lt;tfoot&gt;</code>可以没有，<code>&lt;tbody&gt;</code>不写也存在，且可以有多个</li>
</ol>
<h2 id="3-9-表单"><a href="#3-9-表单" class="headerlink" title="3.9 表单"></a>3.9 表单</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;&quot; method=&quot;&quot;&gt;</span><br><span class="line">	&lt;input type=&quot;&quot; name=&quot;提交key&quot; value=&quot;&quot;&gt;</span><br><span class="line">	&lt;select name=&quot;提交key&quot;&gt;</span><br><span class="line">		&lt;option value=&quot;提交值&quot; selected=&quot;&quot;&gt;页面显示值&lt;/option&gt;</span><br><span class="line">	&lt;/select&gt;</span><br><span class="line">	&lt;textarea name=&quot;提交key&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">	&lt;button&gt;&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>form</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;label&gt;</code></td>
<td>用于描述表单元素</td>
</tr>
<tr>
<td><code>&lt;button&gt;</code></td>
<td>按钮</td>
</tr>
<tr>
<td><code>&lt;input&gt;</code></td>
<td>表单交互式元素</td>
</tr>
<tr>
<td><code>&lt;select&gt;</code></td>
<td>选项菜单</td>
</tr>
<tr>
<td><code>&lt;textarea&gt;</code></td>
<td>文本域</td>
</tr>
<tr>
<td><code>&lt;datalist&gt;</code></td>
<td>为表单输入框准备一些选项列表</td>
</tr>
</tbody></table>
<h3 id="1-lt-label-gt"><a href="#1-lt-label-gt" class="headerlink" title="1 &lt;label&gt;"></a>1 <code>&lt;label&gt;</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1 id</span><br><span class="line">&lt;label for=&quot;表单元素的id&quot;&gt;</span><br><span class="line">&lt;input id=&quot;&quot;&gt;</span><br><span class="line">// 2 直接包裹表单元素</span><br><span class="line">&lt;label&gt;&lt;input&gt;&lt;/label&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-lt-input-gt"><a href="#2-lt-input-gt" class="headerlink" title="2 &lt;input&gt;"></a>2 <code>&lt;input&gt;</code></h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>表单类型，默认为 <code>text</code></td>
</tr>
<tr>
<td>name</td>
<td>后台接收字段名</td>
</tr>
<tr>
<td>value</td>
<td>默认值</td>
</tr>
<tr>
<td>required</td>
<td>必须输入</td>
</tr>
<tr>
<td>placeholder</td>
<td>提示文本内容，得到焦点不会消失，一输入值就消失</td>
</tr>
<tr>
<td>maxlength</td>
<td>允许最大输入字符数</td>
</tr>
<tr>
<td>disabled</td>
<td>禁止使用，不可以提交到后台</td>
</tr>
<tr>
<td>readonly</td>
<td>只读，可提交到后台</td>
</tr>
<tr>
<td>autocomplete</td>
<td><code>autocomplete=&quot;on&quot;</code>，代表如果<code>&lt;input&gt;</code>元素的 type 允许，则会具有自动填充的功能</td>
</tr>
</tbody></table>
<h4 id="1-type"><a href="#1-type" class="headerlink" title="1 type"></a>1 type</h4><table>
<thead>
<tr>
<th>type</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>text</code></td>
<td>默认，文本框</td>
</tr>
<tr>
<td><code>password</code></td>
<td>密码框</td>
</tr>
<tr>
<td><code>radio</code></td>
<td>单选框，<code>name</code> 相同的是一个组，<code>value</code> 为提交值，<code>checked</code> 默认选中</td>
</tr>
<tr>
<td><code>checkbox</code></td>
<td>复选框，<code>name</code> 相同的是一个组，<code>value</code> 为提交值，<code>checked</code> 默认选中</td>
</tr>
<tr>
<td><code>file</code></td>
<td>上传文件，<code>multiple=&quot;multiple&quot;</code> 支持多选</td>
</tr>
<tr>
<td><code>button</code></td>
<td>按钮</td>
</tr>
<tr>
<td><code>image</code></td>
<td>图片提交按钮</td>
</tr>
<tr>
<td><code>hidden</code></td>
<td>隐藏域</td>
</tr>
<tr>
<td><code>submit</code></td>
<td>提交按钮，不指定服务端会提交到当前页面</td>
</tr>
<tr>
<td><code>reset</code></td>
<td>复位按钮</td>
</tr>
<tr>
<td><code>email</code></td>
<td>邮件框</td>
</tr>
<tr>
<td><code>search</code></td>
<td>搜索框</td>
</tr>
<tr>
<td><code>datetime-local</code></td>
<td>日期</td>
</tr>
</tbody></table>
<h4 id="2-表单提交方式"><a href="#2-表单提交方式" class="headerlink" title="2 表单提交方式"></a>2 表单提交方式</h4><ol>
<li><code>&lt;input type=&quot;submit&quot; name=&quot;&quot; value=&quot;点我提交&quot;&gt;</code><ul>
<li>如果设置了name，按钮数据也会提交到后台，如果有多个表单项可以判断是哪个表单提交的。</li>
</ul>
</li>
<li><code>&lt;button type=&quot;submit&quot;&gt;点我提交&lt;/button&gt;</code><ul>
<li>html5 推荐使用<code>&lt;button&gt;</code> 而不是表单的 <code>&lt;input type=button&gt;</code></li>
</ul>
</li>
<li><code>&lt;input type=&quot;image&quot;&gt;</code><ul>
<li>图片也能提交</li>
</ul>
</li>
</ol>
<h3 id="3-lt-select-gt"><a href="#3-lt-select-gt" class="headerlink" title="3 &lt;select&gt;"></a>3 <code>&lt;select&gt;</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select name=&quot;&quot; multiple&gt;</span><br><span class="line">	&lt;option value=&quot;提交值&quot;&gt;显示值&lt;/option&gt;</span><br><span class="line">	&lt;optgroup label=&quot;体育&quot;&gt;</span><br><span class="line">		&lt;option value=&quot;lanqiu&quot;&gt;篮球&lt;/option&gt;</span><br><span class="line">		&lt;option value=&quot;zuqiu&quot;&gt;足球&lt;/option&gt;</span><br><span class="line">		&lt;option value=&quot;wangqiu&quot; selected&gt;网球&lt;/option&gt;</span><br><span class="line">	&lt;/optgroup&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>提交字段</td>
</tr>
<tr>
<td>multiple</td>
<td>支持多选. select默认是单选</td>
</tr>
<tr>
<td>disabled</td>
<td>禁止使用，不可以提交到后台</td>
</tr>
<tr>
<td>required</td>
<td>select的值不能为空</td>
</tr>
</tbody></table>
<h4 id="1-lt-optfroup-gt"><a href="#1-lt-optfroup-gt" class="headerlink" title="1 &lt;optfroup&gt;"></a>1 <code>&lt;optfroup&gt;</code></h4><ul>
<li>选项组，其实只是将一些option分了一下组，与直接写option没区别</li>
</ul>
<h4 id="2-相关操作"><a href="#2-相关操作" class="headerlink" title="2 相关操作"></a>2 相关操作</h4><ul>
<li><code>options</code><ul>
<li>option集合</li>
</ul>
</li>
<li><code>selectedIndex</code><ul>
<li>选中的option的索引</li>
</ul>
</li>
<li>获取选中的option<ul>
<li><code>var optionElement=selectElement[selectElement.selectedIndex]</code></li>
<li><code>var optionElement=selectElement.options[selectedIndex]</code></li>
</ul>
</li>
<li>获取option中的值<ul>
<li><code>var value=optionElement.value</code></li>
<li><code>var value=optionElement.innerHTML</code></li>
</ul>
</li>
<li>清空select中的option<ul>
<li><code>selectElement.options.length=0</code></li>
</ul>
</li>
</ul>
<h3 id="4-lt-button-gt"><a href="#4-lt-button-gt" class="headerlink" title="4 &lt;button&gt;"></a>4 <code>&lt;button&gt;</code></h3><ul>
<li><code>type</code><ul>
<li><code>submit</code><ul>
<li>默认</li>
</ul>
</li>
<li><code>reset</code><ul>
<li>重置所有组件为初始值</li>
</ul>
</li>
<li><code>button</code><ul>
<li>此按钮没有默认行为</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-lt-datalist-gt"><a href="#5-lt-datalist-gt" class="headerlink" title="5 &lt;datalist&gt;"></a>5 <code>&lt;datalist&gt;</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; list=&quot;自定义名&quot;&gt;</span><br><span class="line">&lt;datalist id=&quot;输入框list名&quot;&gt;</span><br><span class="line">	&lt;option value=&quot;&quot;&gt;&lt;/option&gt;</span><br><span class="line">	&lt;option value=&quot;&quot;&gt;&lt;/option&gt;</span><br><span class="line">	&lt;option value=&quot;&quot;&gt;&lt;/option&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-10-音-视频"><a href="#3-10-音-视频" class="headerlink" title="3.10 音/视频"></a>3.10 音/视频</h2><h3 id="1-lt-audio-gt"><a href="#1-lt-audio-gt" class="headerlink" title="1 &lt;audio&gt;"></a>1 <code>&lt;audio&gt;</code></h3><ul>
<li><code>&lt;audio src=&quot;&quot; controls muted preload&gt;</code></li>
</ul>
<h3 id="2-lt-video-gt"><a href="#2-lt-video-gt" class="headerlink" title="2 &lt;video&gt;"></a>2 <code>&lt;video&gt;</code></h3><ul>
<li><code>&lt;video src=&quot;&quot; controls muted autoplay poster=&quot;&quot; preload=&quot;&quot; loop&gt;</code><ul>
<li><code>controls</code><ul>
<li>视频进度条</li>
</ul>
</li>
<li><code>muted</code><ul>
<li>静音</li>
</ul>
</li>
<li><code>autoplay</code><ul>
<li>自动播放，要设置静音才有效</li>
</ul>
</li>
<li><code>poster</code><ul>
<li>视频封面图</li>
</ul>
</li>
<li><code>preload</code><ul>
<li>视频预加载方式</li>
</ul>
</li>
<li><code>loop</code><ul>
<li>循环播放</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="四-attribute-amp-property"><a href="#四-attribute-amp-property" class="headerlink" title="四 attribute &amp; property"></a>四 attribute &amp; property</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>attribute</code></td>
<td>HTML 预定义和自定义属性</td>
</tr>
<tr>
<td><code>property</code></td>
<td>DOM 属性</td>
</tr>
</tbody></table>
<h2 id="4-2-操作"><a href="#4-2-操作" class="headerlink" title="4.2 操作"></a>4.2 操作</h2><h3 id="1-property"><a href="#1-property" class="headerlink" title="1 property"></a>1 property</h3><p>操作|原生DOM|jQuery<br>-|-<br>读|<code>element.name</code>|<code>$element.prop(name)</code><br>写|<code>element.name=value</code>|<code>$element.prop(name, value)</code><br>删|<code>delete element.name</code>|<code>$element.removeProp(name)</code></p>
<h3 id="2-attribute"><a href="#2-attribute" class="headerlink" title="2 attribute"></a>2 attribute</h3><p>操作|原生DOM|jQuery<br>-|-<br>读|<code>element.getAttribute(name)</code>|<code>$element.attr(name)</code><br>写|<code>element.setAttribute(name, value)</code>|<code>$element.attr(name, value)</code><br>删|<code>element.removeAttribute(name)</code>|<code>$element.removeAttr(name)</code></p>
<h2 id="4-3-attribute-amp-property-的同步"><a href="#4-3-attribute-amp-property-的同步" class="headerlink" title="4.3 attribute &amp; property 的同步"></a>4.3 attribute &amp; property 的同步</h2><ol>
<li><strong>浏览器只认 property，用户操作的也是 property</strong></li>
<li>非布尔值属性<ul>
<li>实时同步</li>
</ul>
</li>
<li>布尔值属性<ol>
<li>property 永远都不会同步 attribute</li>
<li>attribute<ol>
<li>没有动过property<ul>
<li>attribute会同步property</li>
</ul>
</li>
<li>动过property <ul>
<li>attribute不会同步property</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4 总结"></a>4.4 总结</h2><ol>
<li>优先操作 <code>DOM property</code></li>
<li>没有 <code>DOM property</code> （如自定义属性 …）时，才使用 <code>HTML attribute</code></li>
</ol>
]]></content>
      <categories>
        <category>UI</category>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>学书无日不临池</title>
    <url>/anyeansan.github.io/2020/03/29/%E5%AD%A6%E4%B9%A6%E6%97%A0%E6%97%A5%E4%B8%8D%E4%B8%B4%E6%B1%A0/</url>
    <content><![CDATA[<p><img src="https://gitee.com/3noanswer/npics/raw/master/xx.png" alt=""></p>
]]></content>
      <categories>
        <category>Index</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 综合架构</title>
    <url>/anyeansan.github.io/2020/03/29/Linux-%E7%BB%BC%E5%90%88%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="一-中小规模网站综合架构组成"><a href="#一-中小规模网站综合架构组成" class="headerlink" title="一 中小规模网站综合架构组成"></a>一 中小规模网站综合架构组成</h1><h2 id="1-1-前端"><a href="#1-1-前端" class="headerlink" title="1.1 前端"></a>1.1 前端</h2><ol>
<li>防火墙<ul>
<li>访问策略控制</li>
</ul>
</li>
<li>负载均衡服务器<ul>
<li>对访问请求进行调度处理</li>
</ul>
</li>
<li>web服务器<ul>
<li>处理用户请求</li>
</ul>
</li>
</ol>
<h2 id="1-2-后端"><a href="#1-2-后端" class="headerlink" title="1.2 后端"></a>1.2 后端</h2><ol>
<li>数据库服务器<ul>
<li>存储字符数据，如订单…</li>
</ul>
</li>
<li>存储服务器<ul>
<li>存储图片 音频 视频 附件都数据</li>
</ul>
</li>
<li>备份服务器<ul>
<li>存储网站所有服务器重要数据</li>
</ul>
</li>
<li>缓存服务器<ul>
<li>将常用数据存储到内存中，减轻服务器压力，提升用户体验</li>
</ul>
</li>
</ol>
<h2 id="1-3-扩展"><a href="#1-3-扩展" class="headerlink" title="1.3 扩展"></a>1.3 扩展</h2><ol>
<li>批量管理服务器<ul>
<li>批量管理多台服务器主机</li>
</ul>
</li>
<li>VPN服务器<ul>
<li>内部员工访问架构 <code>PPTP vpn</code></li>
</ul>
</li>
<li>审计服务器（跳板机）<ul>
<li>内部员工操作管理架构 <code>jumpserver</code></li>
</ul>
</li>
<li>监控服务器<ul>
<li>综合架构服务器的监控 <code>zabbix</code></li>
</ul>
</li>
<li>网站架构单点问题（高可用服务）<ol>
<li>负载均衡服务器 <code>keepalived</code></li>
<li>数据库 <code>mha</code></li>
<li>存储服务器 <code>分布式存储</code></li>
<li>备份服务 <code>rsync 云存储</code></li>
<li>缓存服务 <code>集群/哨兵模式</code></li>
</ol>
</li>
</ol>
<h1 id="二-备份"><a href="#二-备份" class="headerlink" title="二 备份"></a>二 备份</h1><h2 id="2-1-备份策略"><a href="#2-1-备份策略" class="headerlink" title="2.1 备份策略"></a>2.1 备份策略</h2><ol>
<li>全量备份<ul>
<li>完整备份所有数据</li>
</ul>
</li>
<li>增量备份<ul>
<li>做一次完全备份，以后每次只备份新增的数据</li>
<li>例<ul>
<li>第一天完全备份</li>
<li>第二天备份第二天新增数据</li>
<li>第三天备份第三天新增数据</li>
<li>第四天备份第四天新增数据</li>
</ul>
</li>
</ul>
</li>
<li>差异备份<ul>
<li>做一次完全备份，以后每次只备份和第一次完全备份不同的数据</li>
<li>例<ul>
<li>第一天完全备份</li>
<li>第二天备份第二天新增数据</li>
<li>第三天备份第二天和第三天新增数据（和第一次比较）</li>
<li>第四天备份第二天第三天和第四天新增数据（和第一次比较）</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="2-2-备份命令"><a href="#2-2-备份命令" class="headerlink" title="2.2 备份命令"></a>2.2 备份命令</h2><ol>
<li>本地备份<ul>
<li><code>cp</code></li>
</ul>
</li>
<li>远程备份<ul>
<li><code>scp -rp</code><ul>
<li><code>-r</code><ul>
<li>递归</li>
</ul>
</li>
<li><code>-p</code><ul>
<li>保持文件属性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="2-3-rsync"><a href="#2-3-rsync" class="headerlink" title="2.3 rsync"></a>2.3 rsync</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>Rsync是一款开源的、快速的、多功能的、可实现全量及增量的本地或远程数据同步备份的优秀工具</li>
<li>安装 <code>rsync</code> 软件包</li>
</ol>
<h3 id="2-本地备份"><a href="#2-本地备份" class="headerlink" title="2 本地备份"></a>2 本地备份</h3><ul>
<li><code>rsync [OPTION] SRC DEST</code><ul>
<li>等价于 <code>cp</code> 命令</li>
</ul>
</li>
<li><code>rsync FILE</code><ul>
<li>等价于 <code>ls</code> 命令</li>
</ul>
</li>
</ul>
<h3 id="3-远程备份"><a href="#3-远程备份" class="headerlink" title="3 远程备份"></a>3 远程备份</h3><h4 id="1-Push"><a href="#1-Push" class="headerlink" title="1 Push"></a>1 Push</h4><ul>
<li><code>rsync [OPTION] SRC [USER@]HOST:DEST</code><ul>
<li>等价于 <code>scp</code> 命令</li>
<li><code>OPTION</code><ul>
<li><code>-a</code><ul>
<li>命令的归档参数，等价于 <code>-rtopgDl</code></li>
</ul>
</li>
<li><code>-v</code><ul>
<li>显示详细的传输信息</li>
</ul>
</li>
<li><code>-z</code><ul>
<li>传输时进行压缩以提高效率</li>
</ul>
</li>
<li><code>-r</code><ul>
<li>递归</li>
</ul>
</li>
<li><code>-t</code><ul>
<li>保持文件最后修改时间不变</li>
</ul>
</li>
<li><code>-o</code><ul>
<li>保持文件属主信息不变</li>
</ul>
</li>
<li><code>-p</code><ul>
<li>保持文件权限信息不变</li>
</ul>
</li>
<li><code>-g</code><ul>
<li>保持文件属组信息不变</li>
</ul>
</li>
<li><code>-D</code><ul>
<li>保持设备文件信息不变</li>
</ul>
</li>
<li><code>-P</code><ul>
<li>显示数据传输的进度信息</li>
</ul>
</li>
<li><code>-l</code><ul>
<li>保留软连接信息</li>
</ul>
</li>
<li><code>-L</code><ul>
<li>保留软连接指向目标文件的数据</li>
</ul>
</li>
<li><code>--exclude=PATTERN</code><ul>
<li>排除指定数据不被传输</li>
</ul>
</li>
<li><code>--exclude-from=file</code><ul>
<li>排除指定数据不被传输(批量排除)</li>
</ul>
</li>
<li><code>--bwlimit=RATE</code><ul>
<li>显示传输的速率</li>
</ul>
</li>
<li><code>--delete</code><ul>
<li>让目标和源数据保持一致，即会删除目标中源没有的数据</li>
</ul>
</li>
</ul>
</li>
<li><code>USER@</code><ul>
<li>以什么用户身份推送数据（默认以当前用户）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-Pull"><a href="#2-Pull" class="headerlink" title="2 Pull"></a>2 Pull</h4><ul>
<li><code>rsync [OPTION] [USER@]HOST:SRC [DEST]</code><ul>
<li><code>USER@</code><ul>
<li>以什么用户身份拉取数据（默认以当前用户）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-守护进程方式（一直在后台持续的运行）"><a href="#4-守护进程方式（一直在后台持续的运行）" class="headerlink" title="4 守护进程方式（一直在后台持续的运行）"></a>4 守护进程方式（一直在后台持续的运行）</h3><h4 id="1-rsync-守护进程部署流程"><a href="#1-rsync-守护进程部署流程" class="headerlink" title="1 rsync 守护进程部署流程"></a>1 rsync 守护进程部署流程</h4><ol>
<li>安装 <ul>
<li><code>rpm -qa rsync</code></li>
<li><code>yum install -y rsync</code> </li>
</ul>
</li>
<li>配置文件 <code>/etc/rsyncd.conf</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uid = nobody # 管理备份目录的用户</span><br><span class="line">gid = nobody # 管理备份目录的用户组</span><br><span class="line">port = 873 # rsync # 备份服务的端口号</span><br><span class="line">fake super = yes # 将rsync服务虚拟用户伪装成为一个超级管理员用户</span><br><span class="line">use chroot = yes # 安全相关</span><br><span class="line">max connections = 4 # 最大链接数</span><br><span class="line">timeout = 900 # 超时时间</span><br><span class="line">pid file = /var/run/rsyncd.pid # 记录进程号的文件，服务运行时才有</span><br><span class="line">lock file = /var/run/rsync.lock # 锁文件</span><br><span class="line">log file = /var/log/rsyncd.log # rsync 服务日志文件</span><br><span class="line">ignore errors # 忽略传输过程中的简单错误</span><br><span class="line">read only =false # 备份目录可读写</span><br><span class="line">list = false # 客户端是否可以查看服务端的模块信息</span><br><span class="line">hosts allow = # 白名单</span><br><span class="line">hosts deny =  # 黑名单</span><br><span class="line">auth users =	 # 指定认证用户</span><br><span class="line">secrests file = /etc/rsync.password # 指定认证用户密码文件 `用户名称:密码信息`</span><br><span class="line">[backup] # 模块信息</span><br><span class="line">	comment = # 注释信息  </span><br><span class="line">	path =  # 指定备份目录</span><br></pre></td></tr></table></figure></li>
<li>创建rsync服务的虚拟用户</li>
<li>创建rsync服务密码认证文件（权限 600）</li>
<li>创建备份目录并修改属主属组信息</li>
<li>启动服务 <code>systemctl start rsyncd</code></li>
</ol>
<h4 id="2-客户端免密码配置"><a href="#2-客户端免密码配置" class="headerlink" title="2 客户端免密码配置"></a>2 客户端免密码配置</h4><ol>
<li>创建一个密码文件（权限 600），存储密码</li>
<li>执行命令时，在命令后添加 <code>--password-file =密码文件路径</code></li>
</ol>
<h4 id="3-Push"><a href="#3-Push" class="headerlink" title="3 Push"></a>3 Push</h4><ul>
<li><code>rsync [OPTION] SRC [USER@]HOST::DEST</code><ul>
<li><code>OPTION</code><ul>
<li>常用 <code>-avz</code></li>
</ul>
</li>
<li><code>USER@</code><ul>
<li>指定认证用户信息</li>
</ul>
</li>
<li><code>DEST</code><ul>
<li>指定备份服务器的模块</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-Pull"><a href="#4-Pull" class="headerlink" title="4 Pull"></a>4 Pull</h4><ul>
<li><code>rsync [OPTION] [USER@]HOST::SRC [DEST]</code></li>
</ul>
<h3 id="5-rsync-原理"><a href="#5-rsync-原理" class="headerlink" title="5 rsync 原理"></a>5 rsync 原理</h3><ol>
<li>客户端当前登录用户通过命令向服务端发送推送请求</li>
<li>服务端判断客户端命令中认证用户是否存在配置 <code>/etc/rsyncd.conf</code> 中</li>
<li>服务端判断客户端认证用户密码是否正确 <code>/etc/rsync.password</code></li>
<li>开始传输后，无论客户端发送请求的是root还是普通用户，到服务端都是通过配置的虚拟管理用户来备份。也就是说，传输的文件属主和属组在服务端会改为虚拟管理用户。<ol>
<li>假如文件在客户端属主和属组是 root，服务端虚拟管理用户是 xiaoqiang，即在传输文件时需要把文件的属主和属组改为xiaoqiang，权限不足。</li>
<li><code>fake super</code> 配置会将虚拟管理用户伪装成root</li>
</ol>
</li>
</ol>
<h1 id="三-存储"><a href="#三-存储" class="headerlink" title="三 存储"></a>三 存储</h1><h2 id="3-1-存储服务"><a href="#3-1-存储服务" class="headerlink" title="3.1 存储服务"></a>3.1 存储服务</h2><ol>
<li>FTP（File Transfer Protocol）<ul>
<li>FTP 服务器</li>
<li>FTP 客户端</li>
</ul>
</li>
<li>samba<ul>
<li>windows–linux之间数据传输，Linux部署samba</li>
</ul>
</li>
<li>NFS（Network File System）<ul>
<li>linux–linux之间数据传输</li>
</ul>
</li>
<li>门户网站-分布式存储<ul>
<li>FastDFS</li>
<li>GlusterFS</li>
</ul>
</li>
</ol>
<h2 id="3-2-NFS"><a href="#3-2-NFS" class="headerlink" title="3.2 NFS"></a>3.2 NFS</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>网络文件共享系统，主要功能是通过网络（一般是局域网）让不同的主机系统之间可以共享文件</li>
</ol>
<h3 id="2-RPC（Remote-Procedure-Call）"><a href="#2-RPC（Remote-Procedure-Call）" class="headerlink" title="2 RPC（Remote Procedure Call）"></a>2 RPC（Remote Procedure Call）</h3><h1 id="四-批量管理"><a href="#四-批量管理" class="headerlink" title="四 批量管理"></a>四 批量管理</h1><h2 id="4-1-ansible"><a href="#4-1-ansible" class="headerlink" title="4.1 ansible"></a>4.1 ansible</h2><h1 id="五-WEB服务"><a href="#五-WEB服务" class="headerlink" title="五 WEB服务"></a>五 WEB服务</h1>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 定时任务</title>
    <url>/anyeansan.github.io/2020/03/29/Linux-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="一-定时任务"><a href="#一-定时任务" class="headerlink" title="一 定时任务"></a>一 定时任务</h1><h2 id="1-1-实现定时任务的软件"><a href="#1-1-实现定时任务的软件" class="headerlink" title="1.1 实现定时任务的软件"></a>1.1 实现定时任务的软件</h2><ol>
<li><code>cronie</code><ul>
<li>周期性定时任务</li>
</ul>
</li>
<li><code>atd</code><ul>
<li>定时任务只执行一次，一次性定时服务</li>
</ul>
</li>
<li><code>anacron</code><ul>
<li>非7*24小时运行的服务器，用在个人电脑上</li>
</ul>
</li>
</ol>
<h1 id="二-atd"><a href="#二-atd" class="headerlink" title="二 atd"></a>二 atd</h1><ul>
<li><code>at 时间</code><ul>
<li>创建一次性定时任务</li>
</ul>
</li>
<li><code>at -l</code><ul>
<li>查看一次性定时任务</li>
</ul>
</li>
<li><code>atrm 任务序号</code><ul>
<li>删除一次性定时任务</li>
</ul>
</li>
</ul>
<h1 id="三-crond"><a href="#三-crond" class="headerlink" title="三 crond"></a>三 crond</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol>
<li>Linux 系统定时任务由 crond 这个系统服务来控制，Linux 系统上原本就有非常多的计划性工作，所以 crond 服务是默认启动的</li>
<li>Linux 系统也提供了使用者控制计划任务的命令 <code>crontab</code> 命令</li>
</ol>
<h2 id="3-2-系统定时任务"><a href="#3-2-系统定时任务" class="headerlink" title="3.2 系统定时任务"></a>3.2 系统定时任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/cron.hourly # 每小时</span><br><span class="line">/etc/cron.daily # 每天 00:00-23:59</span><br><span class="line">/etc/cron.weekly # 每周 7天</span><br><span class="line">/etc/cron.monthly # 每月</span><br></pre></td></tr></table></figure>
<ol>
<li>放在以上4个目录中的脚本会在相应周期自动执行。</li>
<li><code>/etc/crontab</code><ul>
<li>系统定时任务的配置文件</li>
<li>只有root可以编辑</li>
</ul>
</li>
</ol>
<h2 id="3-3-用户定时任务（cronie）"><a href="#3-3-用户定时任务（cronie）" class="headerlink" title="3.3 用户定时任务（cronie）"></a>3.3 用户定时任务（cronie）</h2><h3 id="1-相关文件"><a href="#1-相关文件" class="headerlink" title="1 相关文件"></a>1 相关文件</h3><ol>
<li><code>/var/spool/cron/用户名</code><ul>
<li>用户定时任务配置文件</li>
</ul>
</li>
<li><code>/var/log/cron</code><ul>
<li>用户定时任务服务运行记录文件</li>
</ul>
</li>
<li><code>/etc/cron.allow</code><ul>
<li>当系统中有此文件时，只有写入此文件的用户可以使用 <code>crontab</code> 命令，优先级高于 <code>/etc/cron.deny</code></li>
</ul>
</li>
<li><code>/etc/cron.deny</code><ul>
<li>此文件中所列用户不允许使用 <code>crontab</code> 命令</li>
</ul>
</li>
</ol>
<h3 id="2-配置-crontab"><a href="#2-配置-crontab" class="headerlink" title="2 配置 crontab"></a>2 配置 crontab</h3><ul>
<li><code>crontab [-u USER] [OPTION] [FILE]</code><ul>
<li><code>USER</code><ul>
<li>如果省略则表示针对当前用户</li>
</ul>
</li>
<li><code>OPTION</code><ul>
<li><code>-l</code><ul>
<li>查看用户定时任务列表</li>
<li>等价于 <code>cat /var/spool/cron/用户名</code></li>
</ul>
</li>
<li><code>-e</code><ul>
<li>编辑用户定时任务</li>
<li>等价于 <code>vim /var/spool/cron/用户名</code></li>
</ul>
</li>
<li><code>-r</code><ul>
<li>删除用户定时任务</li>
<li>等价于 <code>rm -f /var/spool/cron/用户名</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-定时任务语法"><a href="#3-定时任务语法" class="headerlink" title="3 定时任务语法"></a>3 定时任务语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分 时 日 月 周 任务</span><br><span class="line">分：0-59</span><br><span class="line">时：0-23</span><br><span class="line">日：1-31</span><br><span class="line">月：1-12</span><br><span class="line">周：0-6</span><br></pre></td></tr></table></figure>
<ol>
<li><code>*</code><ul>
<li>表示每（分/时/天/月/周）</li>
</ul>
</li>
<li><code>*/N</code><ul>
<li>表示每隔 N（分/时/天/月/周）</li>
</ul>
</li>
<li><code>M/N</code><ul>
<li>表示从 M 开始每隔 N（分/时/天/月/周）</li>
</ul>
</li>
<li><code>M-N</code><ul>
<li>表示 M 到 N</li>
<li>如 <code>01-05 * * * *</code> 表示每小时的01分到05分（01 02 03 04 05）</li>
</ul>
</li>
<li><code>M,N</code><ul>
<li>表示 M 和 N</li>
<li>如 <code>01,05 * * * *</code> 表示每小时的01分和05分（01 05）</li>
</ul>
</li>
<li><code>N</code><ul>
<li>表示具体时间</li>
<li>如 <code>10 02 * * *</code> 表示每天的02时10分</li>
</ul>
</li>
</ol>
<h3 id="4-定时任务规范"><a href="#4-定时任务规范" class="headerlink" title="4 定时任务规范"></a>4 定时任务规范</h3><ol>
<li>编写定时任务要有注释说明</li>
<li>编写定时任务路径信息尽量使用绝对路径</li>
<li>编写定时任务要使用绝对路径命令<ul>
<li>定时任务识别的 PATH 信息只有<code>/usr/bin</code> 和 <code>/bin</code></li>
</ul>
</li>
<li>编写定时任务尽量不要产生屏幕信息</li>
<li>定时任务执行时如果产生标准输出/标准错误输出（即输出到屏幕的信息），会以邮件的方式通知用户<ul>
<li>问题<ul>
<li>可能会导致邮件文件过大，占用磁盘空间</li>
</ul>
</li>
<li>解决方式<ol>
<li>关闭邮件服务 <code>postfix</code>，虽然可以阻止邮件发送，但会类似其它邮箱的草稿，不断在 <code>/var/spool/postfix/maildrop/</code> 产生小文件占用磁盘空间 </li>
<li>标准输出/标准错误输出都不输出到屏幕，而是重定向到黑洞文件 <code>/dev/null</code> 中（推荐）</li>
</ol>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 网络</title>
    <url>/anyeansan.github.io/2020/03/29/Linux-%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="一-虚拟机网络连接"><a href="#一-虚拟机网络连接" class="headerlink" title="一 虚拟机网络连接"></a>一 虚拟机网络连接</h1><h2 id="1-1-Bridged（桥接模式）"><a href="#1-1-Bridged（桥接模式）" class="headerlink" title="1.1 Bridged（桥接模式）"></a>1.1 Bridged（桥接模式）</h2><ol>
<li>虚拟机相当于局域网内一台独立的主机，和宿主主机是对等的，同处于一个局域网</li>
<li>虚拟主机和宿主机网络地址是一致的</li>
<li>网卡：<code>VMnet0</code></li>
<li>优点<ul>
<li>局域网内其它物理主机可以直接和虚拟主机通信</li>
</ul>
</li>
<li>缺点<ul>
<li>占用局域网IP地址，同一个网段主机ip地址有限，可能会与其它物理主机ip冲突</li>
</ul>
</li>
</ol>
<h2 id="1-2-NAT（网络地址转换模式）"><a href="#1-2-NAT（网络地址转换模式）" class="headerlink" title="1.2 NAT（网络地址转换模式）"></a>1.2 NAT（网络地址转换模式）</h2><ol>
<li>虚拟主机 → 虚拟交换机 → 虚拟路由 → 宿主机</li>
<li>虚拟主机通过宿主机访问外网，宿主机相当于一个路由器，会将虚拟主机IP与宿主机IP做一个映射，访问外网使用的都是宿主机的IP</li>
<li><ol start="2">
<li>虚拟主机和宿主机网络地址可以不一致</li>
</ol>
</li>
<li>网卡：<code>VMnet8</code><ul>
<li>虚拟机的子网掩码、网关、DNS要与<code>Vmnet8</code>的网卡保持一致。</li>
</ul>
</li>
<li>优点<ul>
<li>虚拟主机不占用局域网IP地址</li>
</ul>
</li>
<li>缺点<ul>
<li>局域网内其它物理主机不能直接和虚拟主机通信</li>
</ul>
</li>
</ol>
<h2 id="1-3-Host-only（仅主机模式）"><a href="#1-3-Host-only（仅主机模式）" class="headerlink" title="1.3 Host-only（仅主机模式）"></a>1.3 Host-only（仅主机模式）</h2><ol>
<li>虚拟主机只能和宿主机通信，不能访问外网</li>
<li>网卡：<code>VMnet1</code></li>
</ol>
<h1 id="二-网络配置"><a href="#二-网络配置" class="headerlink" title="二 网络配置"></a>二 网络配置</h1><h2 id="2-1-图形界面"><a href="#2-1-图形界面" class="headerlink" title="2.1 图形界面"></a>2.1 图形界面</h2><ul>
<li><code>nmtui</code></li>
</ul>
<h2 id="2-2-网卡配置文件"><a href="#2-2-网卡配置文件" class="headerlink" title="2.2 网卡配置文件"></a>2.2 网卡配置文件</h2><ul>
<li><code>/etc/sysconfig/network-scripts/ifcfg-ens32</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TYPE=Ethernet # 网络类型 目前基本为以太网</span><br><span class="line">BOOTPROTO=none # 网络启动协议，如何让主机获得ip</span><br><span class="line">DEFROUTE=yes # 使用默认路由</span><br><span class="line">NAME=ens33 # 第一块网卡逻辑名称</span><br><span class="line">DEVICE=ens33 # 第一块网卡设备名称（物理名称）</span><br><span class="line">ONBOOT=yes # 网卡是否激活</span><br><span class="line">IPADDR=192.168.13.24 # 静态ip </span><br><span class="line">PREFIX=24 # 子网掩码</span><br><span class="line">GATEWAY=192.168.13.2 # 网关</span><br><span class="line">DNS1=223.5.5.5 # DNS</span><br></pre></td></tr></table></figure>
<ul>
<li><code>BOOTPROTO</code><ul>
<li><code>dhcp</code><ul>
<li>动态获取ip</li>
</ul>
</li>
<li><code>none</code>, <code>static</code><ul>
<li>静态ip（手动配置）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-3-其它配置文件"><a href="#2-3-其它配置文件" class="headerlink" title="2.3 其它配置文件"></a>2.3 其它配置文件</h2><ol>
<li><code>/etc/resolv.conf</code><ol>
<li>系统DNS客户端的配置文件</li>
<li>每次重启网卡此文件DNS都会更新为网卡配置文件所配置的DNS</li>
</ol>
</li>
<li><code>/etc/hosts</code><ol>
<li>系统本地的DNS解析文件</li>
<li>可以手动设置域名和IP绑定信息</li>
<li>首先使用本地设置的域名对应的ip，若没有设置，才使用所配置的DNS来解析域名</li>
</ol>
</li>
<li><code>/etc/hostname</code><ul>
<li>主机名配置文件</li>
</ul>
</li>
</ol>
<h1 id="三-系统路由设置"><a href="#三-系统路由设置" class="headerlink" title="三 系统路由设置"></a>三 系统路由设置</h1><table>
<thead>
<tr>
<th>配置 \ 版本</th>
<th>CentOS 6 <code>net-tools</code></th>
<th>CentOS 7 <code>iproute</code></th>
</tr>
</thead>
<tbody><tr>
<td>静态默认路由</td>
<td><code>route add/del default gw 网关</code></td>
<td><code>ip route add/del default via 网关</code></td>
</tr>
<tr>
<td>静态网段路由</td>
<td><code>route add/del -net 目标网络地址 netmask 子网掩码 gw 网关</code></td>
<td><code>ip route add/del -net 目标网络地址 netmask 子网掩码 via 网关</code></td>
</tr>
<tr>
<td>静态主机路由</td>
<td><code>route add/del -host 目标主机地址 dev 网关</code></td>
<td><code>ip route add/del -host 目标主机地址 via 网关</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 软件</title>
    <url>/anyeansan.github.io/2020/03/29/Linux-%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="一-软件包类型"><a href="#一-软件包类型" class="headerlink" title="一 软件包类型"></a>一 软件包类型</h1><p>类型|说明|安装方式<br>-|-<br><code>源码包</code>|源代码二进制包|编译安装<br><code>rpm包</code>|已编译过的二进制包|rpm 安装 / yum 安装</p>
<ol>
<li>rpm 安装<ol>
<li>安装时使用默认位置（大多数）</li>
<li>rpm包之间存在依赖性<ol>
<li>树形依赖</li>
<li>环形依赖</li>
<li>模块依赖<ul>
<li><code>.so</code></li>
<li><code>www.rpmfind.net</code> 模块依赖查询</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li>yum 安装<ul>
<li>自动解决rpm的依赖性</li>
</ul>
</li>
</ol>
<h1 id="二-源码包安装"><a href="#二-源码包安装" class="headerlink" title="二 源码包安装"></a>二 源码包安装</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol>
<li>可以自定义功能，安装时可以自定义路径</li>
<li>安装配置复杂，耗时</li>
<li>卸载方便（直接删除安装目录）</li>
</ol>
<h2 id="2-2-编译安装过程"><a href="#2-2-编译安装过程" class="headerlink" title="2.2 编译安装过程"></a>2.2 编译安装过程</h2><h3 id="1-编译器（没有则安装）"><a href="#1-编译器（没有则安装）" class="headerlink" title="1 编译器（没有则安装）"></a>1 编译器（没有则安装）</h3><ol>
<li><code>gcc</code><ul>
<li><code>yum -y install gcc gcc-c++ make zlib-devel pcre pcre-devel openssl-devel</code><ul>
<li><code>zlib</code>：压缩库</li>
<li><code>pcre</code>：支持正则表达式，地址重写rewrite</li>
<li><code>openssl</code>：提供https支持</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="2-下载源码包，解压并进入解压后目录"><a href="#2-下载源码包，解压并进入解压后目录" class="headerlink" title="2 下载源码包，解压并进入解压后目录"></a>2 下载源码包，解压并进入解压后目录</h3><h3 id="3-软件配置和检查，生成-Makefile-文件"><a href="#3-软件配置和检查，生成-Makefile-文件" class="headerlink" title="3 软件配置和检查，生成 Makefile 文件"></a>3 软件配置和检查，生成 Makefile 文件</h3><ul>
<li><code>./configure</code><ol>
<li>定义需要的功能选项</li>
<li>检测系统环境是否符合安装要求</li>
<li>把定义好的功能选项和检测环境信息都写入<code>Makefile</code>文件，用于后续的编译</li>
<li>常见参数<ul>
<li><code>--prefix=PATH</code><ul>
<li>指定安装路径</li>
</ul>
</li>
<li><code>--enable-ssl --disable-filter</code><ul>
<li>启用禁用某项功能</li>
</ul>
</li>
<li><code>--with-...</code><ul>
<li>支持模块功能</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="4-按照-Makefile-文件编译"><a href="#4-按照-Makefile-文件编译" class="headerlink" title="4 按照 Makefile 文件编译"></a>4 按照 Makefile 文件编译</h3><ul>
<li><code>make</code><ul>
<li>编译</li>
</ul>
</li>
<li><code>make -j 4</code><ul>
<li>指定4核心CPU编译，提升速度</li>
</ul>
</li>
<li><code>make clean</code><ul>
<li>清除make产生的文件</li>
<li>安装步骤之前，不会向安装位置写入任何文件，所以如果安装前有错误，执行<code>make clean</code>即可</li>
</ul>
</li>
</ul>
<h3 id="5-按照-Makefile-定义的文件路径安装"><a href="#5-按照-Makefile-定义的文件路径安装" class="headerlink" title="5 按照 Makefile 定义的文件路径安装"></a>5 按照 Makefile 定义的文件路径安装</h3><ul>
<li><code>make install</code></li>
</ul>
<h1 id="三-RPM（redhat-package-manager）"><a href="#三-RPM（redhat-package-manager）" class="headerlink" title="三  RPM（redhat package manager）"></a>三  RPM（redhat package manager）</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol>
<li>红帽软件包管理器</li>
<li>rpm通过将安装规则和源代码打包到一起，来降低软件的安装难度</li>
</ol>
<h2 id="3-2-rpm-操作"><a href="#3-2-rpm-操作" class="headerlink" title="3.2 rpm 操作"></a>3.2 rpm 操作</h2><h3 id="1-查询"><a href="#1-查询" class="headerlink" title="1 查询"></a>1 查询</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>rpm -qa</code></td>
<td>查询所有已安装的软件包</td>
</tr>
<tr>
<td><code>rpm -q 包名</code></td>
<td>查询软件包是否安装</td>
</tr>
<tr>
<td><code>rpm -qi 包名</code></td>
<td>查询已安装软件包的详细信息</td>
</tr>
<tr>
<td><code>rpm -qip 全包名</code></td>
<td>查询未安装软件包的详细信息</td>
</tr>
<tr>
<td><code>rpm -ql 包名</code></td>
<td>查询已安装软件包中的文件列表</td>
</tr>
<tr>
<td><code>rpm -qlp 全包名</code></td>
<td>查询未安装软件包中的文件列表</td>
</tr>
<tr>
<td><code>rpm -qf file</code></td>
<td>查询文件属于哪个安装包</td>
</tr>
<tr>
<td><code>rpm -qR 包名</code></td>
<td>查询软件包的依赖性</td>
</tr>
<tr>
<td><code>rpm -qg group</code></td>
<td>查询组中的软件包列表</td>
</tr>
</tbody></table>
<h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2 安装"></a>2 安装</h3><ul>
<li><code>rpm -ivh 包全名</code><ul>
<li><code>-i</code>, <code>--install</code><ul>
<li>安装</li>
</ul>
</li>
<li><code>-v</code><ul>
<li>显示详细信息</li>
</ul>
</li>
<li><code>-h</code>, <code>--hash</code><ul>
<li>显示进度</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-更新"><a href="#3-更新" class="headerlink" title="3 更新"></a>3 更新</h3><ul>
<li><code>rpm -Uvh 包名</code><ul>
<li><code>-U, --upgrade</code><ul>
<li>更新</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-卸载"><a href="#4-卸载" class="headerlink" title="4 卸载"></a>4 卸载</h3><ul>
<li><code>rpm -e 包名</code><ul>
<li><code>-e, --erase</code>    <ul>
<li>卸载</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-校验"><a href="#5-校验" class="headerlink" title="5 校验"></a>5 校验</h3><ul>
<li><code>rpm -V 包名</code><ul>
<li><code>-V</code><ul>
<li>校验，对已经安装软件进行校验</li>
<li>检查包内容是否被修改，校验安全</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>校验信息</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>S</code></td>
<td>文件大小是否改变</td>
</tr>
<tr>
<td><code>M</code></td>
<td>文件的类型或文件的权限（rwx）是否被改变</td>
</tr>
<tr>
<td><code>5</code></td>
<td>文件MD5校验和是否改变（可以看成文件内容是否改变）</td>
</tr>
<tr>
<td><code>D</code></td>
<td>设备中的从代码是否改变</td>
</tr>
<tr>
<td><code>L</code></td>
<td>文件路径是否改变</td>
</tr>
<tr>
<td><code>U</code></td>
<td>文件的属主是否改变</td>
</tr>
<tr>
<td><code>G</code></td>
<td>文件的属组是否改变</td>
</tr>
<tr>
<td><code>T</code></td>
<td>文件的修改时间是否改变</td>
</tr>
</tbody></table>
<h1 id="四-Yum（Yellowdog-Updater-Modified）"><a href="#四-Yum（Yellowdog-Updater-Modified）" class="headerlink" title="四 Yum（Yellowdog Updater Modified）"></a>四 Yum（Yellowdog Updater Modified）</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ul>
<li>yum通过将大量的常用rpm软件包放在一起，解决软件包之间的依赖关系，进一步降低软件的安装难度。</li>
</ul>
<h2 id="4-2-yum源"><a href="#4-2-yum源" class="headerlink" title="4.2 yum源"></a>4.2 yum源</h2><h3 id="1-配置基本-yum-源"><a href="#1-配置基本-yum-源" class="headerlink" title="1 配置基本 yum 源"></a>1 配置基本 yum 源</h3><h4 id="1-手撕配置文件"><a href="#1-手撕配置文件" class="headerlink" title="1 手撕配置文件"></a>1 手撕配置文件</h4><ul>
<li><code>/etc/yum.repos.d/CentOS-Base.repo</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[base] # 容器名称，唯一，区分不同yum源</span><br><span class="line">name=  # 描述</span><br><span class="line">#mirrorlist= # 镜像站点，可以注释掉，和baseurl使用哪个都行</span><br><span class="line">#baseurl= # yum源服务器的地址。默认是CentOS官方的yum源服务器</span><br><span class="line">gpgcheck= #  公钥校验rpm包正确性 0不校验 1校验</span><br><span class="line">enabled= # 此yum源是否生效 0不生效 1或省略 生效</span><br><span class="line">gpgkey= # 公钥路径</span><br><span class="line">$releaseserver = `/etc/centos-release`</span><br><span class="line">$basearch = `*86_64`</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-从网络下载配置文件（手动下载，wget，curl-…）"><a href="#2-从网络下载配置文件（手动下载，wget，curl-…）" class="headerlink" title="2 从网络下载配置文件（手动下载，wget，curl …）"></a>2 从网络下载配置文件（手动下载，wget，curl …）</h4><ul>
<li><code>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</code></li>
<li><a href="https://developer.aliyun.com/mirror/" target="_blank" rel="noopener" title="阿里云官方镜像站">Aliyun mirror</a></li>
</ul>
<h3 id="2-配置扩展-yum-源-EPEL"><a href="#2-配置扩展-yum-源-EPEL" class="headerlink" title="2 配置扩展 yum 源 EPEL"></a>2 配置扩展 yum 源 EPEL</h3><ul>
<li>EPEL（Extra Packages for Enterprise Linux）<ul>
<li>是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS等提供高质量软件包的项目。</li>
</ul>
</li>
<li><code>wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</code></li>
</ul>
<h3 id="3-配置本地-yum-源"><a href="#3-配置本地-yum-源" class="headerlink" title="3 配置本地 yum 源"></a>3 配置本地 yum 源</h3><ol>
<li>挂载光盘</li>
<li>备份默认本地 yum 源 <code>/etc/yum.repos.d/CentOS-Media.repo</code></li>
<li>配置新 <code>/etc/yum.repos.d/CentOS-Media.repo</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CentOS 7]</span><br><span class="line">name=CentOS-server</span><br><span class="line">baseurl=file:///mnt/cdrom</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0  </span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## 4.3 yum 操作</span><br><span class="line">### 1 软件包</span><br><span class="line">#### 1 查询</span><br><span class="line">命令|说明</span><br><span class="line">-|-</span><br><span class="line">`yum repolist`|查看可用的yum源信息</span><br><span class="line">`yum list [all]`|显示所有软件包</span><br><span class="line">`yum list available`|显示所有可安装的软件包</span><br><span class="line">`yum list installed`|显示所有已安装的软件包</span><br><span class="line">`yum list updates`|显示所有可更新的软件包</span><br><span class="line">`yum info 软件包名`|查看软件包信息</span><br><span class="line">`yum search keyword`|根据关键字搜索软件包</span><br><span class="line">`yum provides file`|查询文件的来源，属于哪个软件包</span><br><span class="line"></span><br><span class="line">#### 2 安装</span><br><span class="line">命令|说明</span><br><span class="line">-|-</span><br><span class="line">`yum install 软件包名`|安装指定软件包</span><br><span class="line"></span><br><span class="line">#### 3 更新</span><br><span class="line">命令|说明</span><br><span class="line">-|-</span><br><span class="line">`yum update`|更新所有可更新的软件包以及系统内核，保留旧包</span><br><span class="line">`yum upgrade`|更新所有可更新的软件包以及系统内核，删除旧包</span><br><span class="line">`yum update 软件包名`|更新指定软件包以及系统内核，保留旧包</span><br><span class="line">`yum upgrade 软件包名`|更新指定软件包以及系统内核，删除旧包</span><br><span class="line"></span><br><span class="line">#### 4 删除</span><br><span class="line">命令|说明</span><br><span class="line">-|-</span><br><span class="line">`yum remove 软件包名`|删除指定软件包</span><br><span class="line">`yum erase 软件包名`|删除指定软件包</span><br><span class="line"></span><br><span class="line">#### 5 缓存</span><br><span class="line">命令|说明</span><br><span class="line">-|-</span><br><span class="line">`yum makecache`|生成仓库软件索引表（类似字典索引）</span><br><span class="line">`yum clean all`|清除缓存</span><br><span class="line"></span><br><span class="line">#### 6 gpg key</span><br><span class="line">* 安装时如果 yum 源配置 `gpgkey=1` 会进行验证，缺少key会报错</span><br><span class="line">	1. 改为 `gpgkey=0`</span><br><span class="line">	2. `rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7`</span><br><span class="line">		* 执行此命令导入 gpg key</span><br><span class="line"></span><br><span class="line">### 2 软件包组（软件包操作命令加上 group 即可）</span><br><span class="line">1. `yum grouplist [all]`</span><br><span class="line">	* 显示所有软件包组</span><br><span class="line">2. `yum groupinstall 软件包组`</span><br><span class="line">3. `yum groupupdate 软件包组`</span><br><span class="line">4. `yum groupremove 软件包组`</span><br><span class="line"></span><br><span class="line"># 五 实例</span><br><span class="line">## 5.1 恶搞软件</span><br><span class="line">1. `cowsay`</span><br><span class="line">	* 动物说</span><br><span class="line">2. `sl`</span><br><span class="line">	* 火车</span><br><span class="line"></span><br><span class="line">## 5.2 JDK</span><br><span class="line">### 1 查询是否有安装</span><br><span class="line">1. `rpm -qa | grep java`</span><br><span class="line">	* 查看是否安装有jdk</span><br><span class="line">	* 如果是源码(.tar.gz)安装 查不出来</span><br><span class="line">2. `rpm -e 包名` 或 `yum remove 包名`</span><br><span class="line">	* 卸载</span><br><span class="line"></span><br><span class="line">### 2 下载</span><br><span class="line">* [JDK download](https://www.oracle.com/cn/java/technologies/javase-downloads.html &quot;JDK 官网&quot;)</span><br><span class="line">	*  下载 `.tar.gz` 压缩包（Linux Compressed Archive）</span><br><span class="line"></span><br><span class="line">### 3 安装</span><br><span class="line">1. 将 `.tar.gz` 压缩包上传至 Linux</span><br><span class="line">2. 解压到指定目录</span><br><span class="line"></span><br><span class="line">### 4 配置环境变量</span><br><span class="line">1. `/etc/profile`</span><br></pre></td></tr></table></figure>
export JAVA_HOME=解压路径<br>export PATH=$JAVA_HOME/bin:$PATH <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. `source /etc/profile`</span><br><span class="line">3. `java -version`</span><br><span class="line"></span><br><span class="line">## 5.3 Tomcat</span><br><span class="line">### 1 概述</span><br><span class="line">* tomcat 依赖 java 环境</span><br><span class="line"></span><br><span class="line">### 2 下载</span><br><span class="line">* [Tomcat download](https://tomcat.apache.org/ &quot;tomcat 官网&quot;)</span><br><span class="line">	* 下载 `.tar.gz`</span><br><span class="line"></span><br><span class="line">### 3 安装</span><br><span class="line">1. 将 `.tar.gz` 压缩包上传至 Linux</span><br><span class="line">2. 解压到指定目录</span><br><span class="line"></span><br><span class="line">### 4 如果未关闭防火墙，则需要开放 8080 端口</span><br></pre></td></tr></table></figure>
<h1 id="1-添加端口并设置永久生效"><a href="#1-添加端口并设置永久生效" class="headerlink" title="1 添加端口并设置永久生效"></a>1 添加端口并设置永久生效</h1>firewall-cmd –zone=public –add-port=8080/tcp –permanent<h1 id="2-重载"><a href="#2-重载" class="headerlink" title="2 重载"></a>2 重载</h1>firewall-cmd –reload<h1 id="3-查看是否开放"><a href="#3-查看是否开放" class="headerlink" title="3 查看是否开放"></a>3 查看是否开放</h1>firewall-cmd –zone=public –query-port=8080/tcp<pre><code></code></pre></li>
</ol>
<h3 id="5-启动-关闭"><a href="#5-启动-关闭" class="headerlink" title="5 启动 / 关闭"></a>5 启动 / 关闭</h3><ol>
<li><code>basedir/bin/version.sh</code><ul>
<li>查看 tomcat 版本信息</li>
</ul>
</li>
<li><code>basedir/bin/startup.sh</code><ul>
<li>启动 tomcat</li>
</ul>
</li>
<li><code>basedir/bin/shutdown.sh</code><ul>
<li>关闭 tomcat</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 文件信息</title>
    <url>/anyeansan.github.io/2020/03/29/Linux-%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h1 id="一-文件信息"><a href="#一-文件信息" class="headerlink" title="一 文件信息"></a>一 文件信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">33574978 -rw-------. 1 root root 1.5K Mar 25 15:10 anaconda-ks.cfg</span><br></pre></td></tr></table></figure>
<ol>
<li>文件属性（存储在文件的 inode 中）<ol>
<li>inode 编号</li>
<li>文件类型及权限</li>
<li>硬链接数</li>
<li>属主</li>
<li>属组</li>
<li>文件大小</li>
<li>最后修改时间 <code>mtime</code></li>
</ol>
</li>
<li>文件名（存储在父目录的 block 中）</li>
</ol>
<h1 id="二-inode-amp-block"><a href="#二-inode-amp-block" class="headerlink" title="二 inode &amp; block"></a>二 inode &amp; block</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol>
<li>存储设备格式化创建文件系统后，大致分为了两部分 <code>inode</code> 和 <code>block</code></li>
<li><code>inode</code> 用来存储文件属性信息（元数据），不包括文件名</li>
<li><code>block</code> 用来存储数据，文件名存储在父目录的 <code>block</code> 中</li>
<li>一个文件要占用一个 <code>inode</code> 和至少一个 <code>block</code></li>
</ol>
<h2 id="2-2-inode"><a href="#2-2-inode" class="headerlink" title="2.2 inode"></a>2.2 inode</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>inode index</code> 指向一个文件的 <code>inode</code>，是文件在文件系统中的唯一标识</li>
<li>文件名仅是为了方便人们的记忆和使用</li>
<li>修改文件会改变 <code>inode</code>，所以修改完服务器配置文件后，都需要重新加载一下配置文件</li>
</ol>
<h3 id="2-查看-inode-信息"><a href="#2-查看-inode-信息" class="headerlink" title="2 查看 inode 信息"></a>2 查看 inode 信息</h3><h4 id="1-stat-file"><a href="#1-stat-file" class="headerlink" title="1 stat file"></a>1 <code>stat file</code></h4><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Inode</code></td>
<td>inode 编号</td>
</tr>
<tr>
<td><code>Size</code></td>
<td>文件大小</td>
</tr>
<tr>
<td><code>Uid</code></td>
<td>文件属主</td>
</tr>
<tr>
<td><code>Gid</code></td>
<td>文件属组</td>
</tr>
<tr>
<td><code>Access</code></td>
<td>文件类型及权限</td>
</tr>
<tr>
<td><code>Links</code></td>
<td>链接数（硬链接）</td>
</tr>
<tr>
<td><code>Blocks</code></td>
<td>数据块 <code>block</code> 数量</td>
</tr>
<tr>
<td><code>IO Block</code></td>
<td>每个数据块 <code>block</code> 大小</td>
</tr>
<tr>
<td><code>Device</code></td>
<td>存储该文件的设备号码</td>
</tr>
<tr>
<td><code>Access time</code></td>
<td>atime，最后访问时间</td>
</tr>
<tr>
<td><code>Modify time</code></td>
<td>mtime，文件内容最后修改时间</td>
</tr>
<tr>
<td><code>Change time</code></td>
<td>ctime，inode 信息最后变动时间</td>
</tr>
</tbody></table>
<h4 id="2-df-i"><a href="#2-df-i" class="headerlink" title="2 df -i"></a>2 <code>df -i</code></h4><ul>
<li>查看 inode 使用情况</li>
</ul>
<h2 id="2-3-block"><a href="#2-3-block" class="headerlink" title="2.3 block"></a>2.3 block</h2><ol>
<li>文件的 <code>block</code> 存储数据，目录的 <code>block</code> 存储目录下文件的文件名和 <code>inode</code> 的对应关系</li>
<li>一个文件可能占用多个 <code>block</code>，一个 <code>block</code> 的读写就消耗一次 I/O</li>
<li>一个 <code>block</code> 只能存放一个文件，如果 <code>block</code> 没有占满，剩余空间就浪费掉了</li>
<li>一个 <code>block</code> 默认大小为 4 k，可调整<ol>
<li>如果存储文件较大，<code>block</code> 大点好，节省IO消耗</li>
<li>如果存储文件较小，<code>block</code> 小点好，提高磁盘利用率</li>
</ol>
</li>
</ol>
<h1 id="三-文件类型"><a href="#三-文件类型" class="headerlink" title="三 文件类型"></a>三 文件类型</h1><h2 id="3-1-查看文件类型"><a href="#3-1-查看文件类型" class="headerlink" title="3.1 查看文件类型"></a>3.1 查看文件类型</h2><ul>
<li><code>file [OPTION] FILE</code><ul>
<li>查看文件类型及编码</li>
<li><code>OPTION</code><ul>
<li><code>-i</code><ul>
<li>查看文件MIME类型及编码</li>
</ul>
</li>
<li><code>-L</code><ul>
<li>查看软链接文件时，查看的是软链接指向的目标文件的信息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-2-文件类型分类"><a href="#3-2-文件类型分类" class="headerlink" title="3.2 文件类型分类"></a>3.2 文件类型分类</h2><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-</code></td>
<td>文件</td>
</tr>
<tr>
<td><code>d</code></td>
<td>目录</td>
</tr>
<tr>
<td><code>l</code></td>
<td>链接文件（软连接）</td>
</tr>
<tr>
<td><code>s</code></td>
<td>socket 文件（网路编程）</td>
</tr>
<tr>
<td><code>b</code></td>
<td>块设备文件，（光驱 磁盘…）如<code>/dev/sda</code></td>
</tr>
<tr>
<td><code>c</code></td>
<td>字符设备文件，如 <code>/dev/tty0</code>，<code>dev/null</code>，<code>dev/zero</code>，<code>dev/urandom</code></td>
</tr>
<tr>
<td><code>p</code></td>
<td>pipe 管道文件</td>
</tr>
</tbody></table>
<h3 id="1"><a href="#1" class="headerlink" title="1 -"></a>1 <code>-</code></h3><ol>
<li><code>ASCII text</code><ul>
<li>纯文本文件，可直接查看和编辑</li>
</ul>
</li>
<li><code>binary</code><ul>
<li>二进制文件（命令文件），不可以编辑</li>
</ul>
</li>
<li><code>data</code><ul>
<li>数据文件（压缩文件）</li>
</ul>
</li>
</ol>
<h3 id="2-c"><a href="#2-c" class="headerlink" title="2 c"></a>2 <code>c</code></h3><ol>
<li><code>/dev/null</code><ul>
<li>“空”设备（黑洞文件）</li>
<li>读<ul>
<li>什么内容也读取不到</li>
</ul>
</li>
<li>写<ul>
<li>写入的内容会永远丢失</li>
</ul>
</li>
</ul>
</li>
<li><code>/dev/zero</code><ul>
<li>“零”设备</li>
<li>读<ul>
<li>读取时提供无限的空字符（<code>NULL， ASCII NUL，0x00</code>）</li>
<li>典型用法是用它来产生一个特定大小的空白文件</li>
</ul>
</li>
<li>写<ul>
<li>写入的内容会永远丢失</li>
</ul>
</li>
</ul>
</li>
<li><code>/dev/urandom</code><ul>
<li>伪随机数生成器</li>
</ul>
</li>
</ol>
<h1 id="四-链接"><a href="#四-链接" class="headerlink" title="四 链接"></a>四 链接</h1><h2 id="4-1-硬链接（Hard-Link）"><a href="#4-1-硬链接（Hard-Link）" class="headerlink" title="4.1 硬链接（Hard Link）"></a>4.1 硬链接（Hard Link）</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>Linux 允许同一个 <code>inode</code> 对应多个文件名，多个文件指向同一个 <code>inode</code> 就是硬链接</li>
<li>不能对目录进行创建，只能对已存在的文件创建硬链接</li>
<li>同一个分区 <code>inode</code> 是唯一的，不能跨文件系统或者跨分区进行硬链接的创建</li>
<li>硬链接与原文件都拥有相同的 <code>inode</code> 和 <code>block</code></li>
<li>删除一个硬链接不会影响原文件，只有文件的硬链接数为 <code>0</code> ，文件才会被真正的删除</li>
<li>每个目录下包含两个隐藏项<ol>
<li><code>.</code><ul>
<li>当前目录的硬链接</li>
</ul>
</li>
<li><code>..</code><ul>
<li>父目录的硬链接</li>
</ul>
</li>
</ol>
</li>
<li>链接数<ol>
<li>文件的硬链接数 = <code>1（文件本身）+ n（硬链接数）</code></li>
<li>目录的硬链接数 = <code>1（目录本身）+ 1（.）+ n（子目录数..）</code></li>
</ol>
</li>
</ol>
<h3 id="2-创建硬链接"><a href="#2-创建硬链接" class="headerlink" title="2 创建硬链接"></a>2 创建硬链接</h3><ul>
<li><code>ln 目标文件 硬链接文件</code></li>
</ul>
<h2 id="4-2-软连接（Symbolic-Link）"><a href="#4-2-软连接（Symbolic-Link）" class="headerlink" title="4.2 软连接（Symbolic Link）"></a>4.2 软连接（Symbolic Link）</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>软连接文件中存储的是另一个文件的指针，类似于快捷方式</li>
<li>软链接有自己 <code>inode</code> 和 <code>block</code></li>
<li>可对目录或文件（包括不存在的）创建软链接</li>
<li>软链接可跨文件系统和分区</li>
<li>删除原文件相关软连接会变成死链接</li>
</ol>
<h3 id="2-创建软连接"><a href="#2-创建软连接" class="headerlink" title="2 创建软连接"></a>2 创建软连接</h3><ul>
<li><code>ln -s 目标文件 软链接文件</code><ul>
<li><code>软连接文件 -&gt; 目标文件</code></li>
</ul>
</li>
</ul>
<h1 id="五-权限"><a href="#五-权限" class="headerlink" title="五 权限"></a>五 权限</h1><h2 id="5-1-基本权限"><a href="#5-1-基本权限" class="headerlink" title="5.1 基本权限"></a>5.1 基本权限</h2><h3 id="1-基本权限说明"><a href="#1-基本权限说明" class="headerlink" title="1 基本权限说明"></a>1 基本权限说明</h3><p>权限|二进制|八进制|文件|目录<br>-|-|-|-<br><code>r</code>|<code>100</code>|<code>4</code>|读取文件内容|查看目录中的内容（<code>ls</code>）<br><code>w</code>|<code>010</code>|<code>2</code>|编辑文件内容|在目录中操作（<code>touch mkdir rm cp mv</code>）<br><code>x</code>|<code>001</code>|<code>1</code>|执行文件|进入目录（<code>cd</code>）</p>
<h3 id="2-文件"><a href="#2-文件" class="headerlink" title="2 文件"></a>2 文件</h3><table>
<thead>
<tr>
<th>权限</th>
<th>属主（root）</th>
<th>属主（普通用户）</th>
<th>其它人（root）</th>
<th>其它人（普通用户）</th>
</tr>
</thead>
<tbody><tr>
<td><code>---</code></td>
<td><code>读 写</code></td>
<td><code>-</code></td>
<td><code>读 写</code></td>
<td><code>-</code></td>
</tr>
<tr>
<td><code>r--</code></td>
<td><code>读 写</code></td>
<td><code>读</code></td>
<td><code>读 写</code></td>
<td><code>读</code></td>
</tr>
<tr>
<td><code>-w-</code></td>
<td><code>读 写</code></td>
<td><code>写</code></td>
<td><code>读 写</code></td>
<td><code>写</code></td>
</tr>
<tr>
<td><code>--x</code></td>
<td><code>读 写 执行</code></td>
<td>-</td>
<td><code>读 写 执行</code></td>
<td>-</td>
</tr>
<tr>
<td><code>r-x</code></td>
<td><code>读 写 执行</code></td>
<td><code>读 执行</code></td>
<td><code>读 写 执行</code></td>
<td><code>读 执行</code></td>
</tr>
<tr>
<td>1. root 对所有文件可读写，执行需要有执行权限</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1. 读写：任意权限</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2. 执行：<code>x</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2. 普通用户读写文件需要有相应权限，执行需要有 读 + 执行权限</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1. 读：<code>r</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2. 写：<code>w</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3. 执行：<code>rx</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3. 通常文件权限需要有 <code>r</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="3-目录"><a href="#3-目录" class="headerlink" title="3 目录"></a>3 目录</h3><table>
<thead>
<tr>
<th>权限</th>
<th>属主（root）</th>
<th>属主（普通用户）</th>
<th>其它人（root）</th>
<th>其它人（普通用户）</th>
</tr>
</thead>
<tbody><tr>
<td><code>---</code></td>
<td><code>读 写 执行</code></td>
<td><code>-</code></td>
<td><code>读 写 执行</code></td>
<td><code>-</code></td>
</tr>
<tr>
<td><code>r--</code></td>
<td><code>读 写 执行</code></td>
<td><code>读（只有文件名，没有文件属性信息）</code></td>
<td><code>读 写 执行</code></td>
<td><code>读（只有文件名，没有文件属性信息）</code></td>
</tr>
<tr>
<td><code>-w-</code></td>
<td><code>读 写 执行</code></td>
<td><code>-</code></td>
<td><code>读 写 执行</code></td>
<td><code>-</code></td>
</tr>
<tr>
<td><code>--x</code></td>
<td><code>读 写 执行</code></td>
<td><code>执行</code></td>
<td><code>读 写 执行</code></td>
<td><code>执行</code></td>
</tr>
<tr>
<td><code>r-x</code></td>
<td><code>读 写 执行</code></td>
<td><code>读 执行</code></td>
<td><code>读 写 执行</code></td>
<td><code>读 执行</code></td>
</tr>
<tr>
<td><code>-wx</code></td>
<td><code>读 写 执行</code></td>
<td><code>写 执行</code></td>
<td><code>读 写 执行</code></td>
<td><code>写 执行</code></td>
</tr>
<tr>
<td>1. root 对所有目录可读、写、执行</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2. 普通用户对目录的读写需要 读写权限 + 执行权限</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1. 读：<code>rx</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2. 写：<code>rx</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3. 执行：<code>x</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3. 通常目录权限需要有 <code>x</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="4-umask-amp-默认权限"><a href="#4-umask-amp-默认权限" class="headerlink" title="4 umask &amp; 默认权限"></a>4 umask &amp; 默认权限</h3><h4 id="1-umask"><a href="#1-umask" class="headerlink" title="1 umask"></a>1 umask</h4><h5 id="1-命令"><a href="#1-命令" class="headerlink" title="1 命令"></a>1 命令</h5><ol>
<li><code>umask</code><ul>
<li>查看umask值，root 默认 <code>0022</code>，普通用户默认 <code>0002</code></li>
<li>第一位是特殊权限，后三位是基本权限 <code>rwx</code></li>
</ul>
</li>
<li><code>umask -S</code><ul>
<li>以rwx形式查看umask值</li>
</ul>
</li>
<li><code>umask 值</code><ul>
<li>临时修改umask值</li>
</ul>
</li>
</ol>
<h5 id="2-umask-和-默认权限的计算"><a href="#2-umask-和-默认权限的计算" class="headerlink" title="2 umask 和 默认权限的计算"></a>2 umask 和 默认权限的计算</h5><ol>
<li>没有umask时，文件的默认权限是 <code>0666</code>，目录的默认权限是 <code>0777</code></li>
<li>有umask时，文件和目录默认权限简单算法（不严谨）<ul>
<li><code>文件默认权限 = 666 - umask</code></li>
<li><code>目录默认权限 = 777 - umask</code></li>
</ul>
</li>
<li>有umask时，文件和目录默认权限科学算法<ol>
<li>将默认权限（目录777，文件666）和 umask 值转为 2 进制</li>
<li>对 umask 2 进制值取反</li>
<li>将默认权限和umask取反后的值进行与运算 <code>&amp;</code></li>
<li>将二进制结果转为八进制，即为默认权限</li>
</ol>
</li>
</ol>
<h4 id="2-默认权限"><a href="#2-默认权限" class="headerlink" title="2 默认权限"></a>2 默认权限</h4><ol>
<li>root<ol>
<li>文件默认权限为 644 <code>rw-r--r--</code></li>
<li>目录默认权限为 755 <code>rwxr-xr-x</code></li>
</ol>
</li>
<li>普通用户<ol>
<li>文件默认权限为 664 <code>rw-rw--r--</code></li>
<li>目录默认权限为 775 <code>rwxrwxr-x</code></li>
</ol>
</li>
</ol>
<h2 id="5-2-特殊权限"><a href="#5-2-特殊权限" class="headerlink" title="5.2 特殊权限"></a>5.2 特殊权限</h2><h3 id="1-SUID（set-uid）（4）"><a href="#1-SUID（set-uid）（4）" class="headerlink" title="1 SUID（set uid）（4）"></a>1 SUID（set uid）（4）</h3><h4 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>SUID 权限仅对可执行二进制文件有效，目录没有意义</li>
<li>SUID 权限只有在该命令文件执行过程中有效</li>
<li>执行者必须对文件有可执行权限</li>
<li>命令文件执行时，执行者可以拥有文件属主的权限</li>
<li><strong>总结</strong>：SUID 即将文件属主的权限分配给所有可执行此文件的人</li>
</ol>
<h4 id="2-例"><a href="#2-例" class="headerlink" title="2 例"></a>2 例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---------- 1 root root	/etc/shadow</span><br><span class="line">-rwsr-xr-x. 1 root root	/usr/bin/passwd</span><br><span class="line">-rwxr-xr-x. 1 root root	 /usr/bin/cat</span><br></pre></td></tr></table></figure>
<ol>
<li>执行 <code>passwd</code> 命令修改密码其实最终要修改 <code>/etc/shadow</code>，而只有 root 可以读写 <code>/etc/shadow</code> 文件</li>
<li>普通用户执行 <code>passwd</code> 命令能成功的原因<ol>
<li>普通用户对 <code>passwd</code> 命令有执行权限</li>
<li><code>passwd</code> 命令有SUID权限，所以在执行时普通用户拥有了 <code>passwd</code> 属主 root 的权限</li>
</ol>
</li>
<li><code>cat</code> 命令没有SUID权限，所以普通用户无法通过 <code>cat</code> 查看 <code>/etc/shadow</code></li>
</ol>
<h4 id="3-添加-SUID"><a href="#3-添加-SUID" class="headerlink" title="3 添加 SUID"></a>3 添加 SUID</h4><ol>
<li><code>chmod u+s FILE</code></li>
<li><code>chmod 4xxx FILE</code> （xxx 为普通权限）</li>
</ol>
<ul>
<li>设置SUID之后，属主权限的显示<ol>
<li>属主有 <code>x</code> 权限，则 <code>x</code> → <code>s</code></li>
<li>属主无 <code>x</code> 权限，则 <code>-</code> → <code>S</code></li>
</ol>
</li>
</ul>
<h4 id="4-删除-SUID"><a href="#4-删除-SUID" class="headerlink" title="4 删除 SUID"></a>4 删除 SUID</h4><ol>
<li><code>chmod u-s FILE</code></li>
<li><code>chmod xxx FILE</code>（去掉 4 即可）</li>
</ol>
<h3 id="2-SGID（set-gid）（2）"><a href="#2-SGID（set-gid）（2）" class="headerlink" title="2 SGID（set gid）（2）"></a>2 SGID（set gid）（2）</h3><h4 id="1-概述-4"><a href="#1-概述-4" class="headerlink" title="1 概述"></a>1 概述</h4><ul>
<li>文件<ol>
<li>可执行二进制文件</li>
<li>SGID 权限只有在该命令文件执行过程中有效</li>
<li>执行者必须对文件有可执行权限</li>
<li>命令文件执行时，执行者可以拥有文件属组的权限</li>
<li><strong>总结</strong>：SGID 即将文件属组的权限分配给所有可执行此文件的人</li>
</ol>
</li>
<li>目录<ol>
<li>普通用户在此目录中的有效组会变成此目录的属组</li>
<li>在此目录中新建文件或目录的属组为该目录的属组</li>
</ol>
</li>
</ul>
<h4 id="2-例-1"><a href="#2-例-1" class="headerlink" title="2 例"></a>2 例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-rwx--s--x 1 root slocate	/usr/bin/locate</span><br><span class="line">-rw-r----- 1 root slocate	/var/lib/mlocate/mlocate.db</span><br></pre></td></tr></table></figure>
<ol>
<li>执行 <code>locate</code> 命令需要读取 <code>/var/lib/mlocate/mlocate.db</code> 文件，而普通用户是没有读取此文件的权限的</li>
<li>普通用户执行 <code>locate</code> 命令能成功的原因<ol>
<li>普通用户对 <code>locate</code> 命令有执行权限</li>
<li><code>locate</code> 命令有 SGID 权限，所以在执行时普通用户拥有了 <code>locate</code> 属组 slocate 的权限，而 slocate 对 <code>mlocate.db</code> 文件是可读的</li>
</ol>
</li>
</ol>
<h4 id="3-添加-SGID"><a href="#3-添加-SGID" class="headerlink" title="3 添加 SGID"></a>3 添加 SGID</h4><ol>
<li><code>chmod g+s FILE</code></li>
<li><code>chmod 2xxx FILE</code></li>
</ol>
<ul>
<li>设置SGID之后，属组权限的显示<ol>
<li>属组有 <code>x</code> 权限，则 <code>x</code> → <code>s</code></li>
<li>属组无 <code>x</code> 权限，则 <code>-</code> → <code>S</code></li>
</ol>
</li>
</ul>
<h4 id="4-删除-SGID"><a href="#4-删除-SGID" class="headerlink" title="4 删除 SGID"></a>4 删除 SGID</h4><ol>
<li><code>chmod g-s FILE</code></li>
<li><code>chmod xxx FILE</code></li>
</ol>
<h3 id="3-SBIT（sticky-bit）（1）"><a href="#3-SBIT（sticky-bit）（1）" class="headerlink" title="3 SBIT（sticky bit）（1）"></a>3 SBIT（sticky bit）（1）</h3><h4 id="1-概述-5"><a href="#1-概述-5" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>粘滞位权限只对目录有效</li>
<li>如果一个用户对目录有 <code>wx</code> 权限，则意味着此用户可以删除目录下的所有文件（包含其它用户创建的文件）</li>
<li>若一个目录设置了 SBIT 权限，则在此目录下的文件只有 root 和 属主才可以删除或移动。</li>
</ol>
<h4 id="2-例-2"><a href="#2-例-2" class="headerlink" title="2 例"></a>2 例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drwxrwxrwt. 19 root root	/tmp</span><br></pre></td></tr></table></figure>
<ol>
<li>所有用户对 <code>/tmp</code> 目录都拥有完整权限，但普通用户却不能在 <code>/tmp</code> 下随意操作不属于自己的文件，是因为<code>/tmp</code> 设置了 SBIT 权限</li>
</ol>
<h4 id="3-添加-SBIT"><a href="#3-添加-SBIT" class="headerlink" title="3 添加 SBIT"></a>3 添加 SBIT</h4><ol>
<li><code>chmod o+t DIR</code></li>
<li><code>chmod 1xxx DIR</code></li>
</ol>
<ul>
<li>设置SBIT后，其它人权限的显示<ol>
<li>其它人有 <code>x</code> 权限，则 <code>x</code> → <code>t</code></li>
<li>其它人无 <code>x</code> 权限，则 <code>x</code> → <code>T</code></li>
</ol>
</li>
</ul>
<h4 id="4-删除-SBID"><a href="#4-删除-SBID" class="headerlink" title="4 删除 SBID"></a>4 删除 SBID</h4><ol>
<li><code>chmod o-t DIR</code></li>
<li><code>chmod xxx DIR</code></li>
</ol>
<h2 id="5-3-权限管理命令"><a href="#5-3-权限管理命令" class="headerlink" title="5.3 权限管理命令"></a>5.3 权限管理命令</h2><h3 id="1-chmod（change-file-mode-bits）"><a href="#1-chmod（change-file-mode-bits）" class="headerlink" title="1 chmod（change file mode bits）"></a>1 chmod（change file mode bits）</h3><ul>
<li><code>chmod [OPTION] mode file</code><ul>
<li>修改文件权限（只有 root 和属主能改变文件的权限）</li>
<li><code>OPTION</code><ul>
<li><code>-R</code><ul>
<li>递归设置</li>
</ul>
</li>
</ul>
</li>
<li><code>mode</code><ol>
<li><code>{ugoa} {+-=} {rwx}</code><ul>
<li><code>u=属主 g=属组 o=其它人 a=ugo</code></li>
</ul>
</li>
<li>八进制数字组合<ul>
<li>如 <code>755 ,644 ...</code></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="2-chown（change-file-owner-and-group）"><a href="#2-chown（change-file-owner-and-group）" class="headerlink" title="2 chown（change file owner and group）"></a>2 chown（change file owner and group）</h3><ul>
<li><code>chown [option] [OWNER][:[GROUP]] file</code><ul>
<li>修改文件的属主和属组<ol>
<li>只有 root 可以修改文件的属主</li>
<li>属主（非root）只能修改文件的属组，且修改后的属组必须还是属主所在组</li>
</ol>
</li>
<li><code>option</code><ul>
<li><code>-R</code><ul>
<li>递归修改</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-4-最大有效权限-mask"><a href="#5-4-最大有效权限-mask" class="headerlink" title="5.4 最大有效权限 mask"></a>5.4 最大有效权限 mask</h2><ol>
<li>mask 的默认权限是 <code>rwx</code>，通常不会修改</li>
<li>文件上的除了属主外的权限（属组/其它人/ACL）都需要和 mask 权限作“与”运算，才能得到真正的权限<ul>
<li>如设置的非属主权限是 <code>r-x</code>，则 <code>r-x &amp; rwx = r-x</code> </li>
</ul>
</li>
</ol>
<h2 id="5-5-ACL（Access-Control-List）"><a href="#5-5-ACL（Access-Control-List）" class="headerlink" title="5.5 ACL（Access Control List）"></a>5.5 ACL（Access Control List）</h2><h3 id="1-概述-6"><a href="#1-概述-6" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>访问控制列表</li>
<li>在普通权限中，用户对文件只有三种身份，属主、属组和其他人，但实际中只有这三个身份不太够用。</li>
<li>当用户对文件的权限与属主、属组和其它人这三种身份的权限都不相同时，就需要单独为用户分配权限，这就是 ACL 权限</li>
<li>文件权限信息最后的 <code>.</code> 就代表 ACL 权限<ul>
<li><code>.</code><ul>
<li>无 ACL 权限</li>
</ul>
</li>
<li><code>+</code><ul>
<li>有 ACL 权限</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="2-ACL-权限管理"><a href="#2-ACL-权限管理" class="headerlink" title="2 ACL 权限管理"></a>2 ACL 权限管理</h3><h4 id="1-setfacl（set-file-access-control-lists）"><a href="#1-setfacl（set-file-access-control-lists）" class="headerlink" title="1 setfacl（set file access control lists）"></a>1 setfacl（set file access control lists）</h4><ul>
<li><code>setfacl [OPTION] FILE</code><ul>
<li><code>OPTION</code><ul>
<li><code>-m, --modify</code><ul>
<li>设置 acl 权限</li>
</ul>
</li>
<li><code>-d, --default</code><ul>
<li>设置默认 acl 权限</li>
<li>只对目录生效，目录中新建立的文件都拥有此默认权限</li>
</ul>
</li>
<li><code>-k, --remove-default</code><ul>
<li>删除默认 acl 权限</li>
</ul>
</li>
<li><code>-x, --remove</code><ul>
<li>删除指定 acl 权限</li>
</ul>
</li>
<li><code>-b, --remove-all</code><ul>
<li>删除所有 acl 权限</li>
</ul>
</li>
<li><code>-R, --recursive</code><ul>
<li>递归设置 acl 权限</li>
<li>设定的 acl 权限会对目录下的所有子文件生效（新建文件不生效）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-查看-ACL-权限"><a href="#2-查看-ACL-权限" class="headerlink" title="2 查看 ACL 权限"></a>2 查看 ACL 权限</h4><ul>
<li><code>getfacl  FILE</code></li>
</ul>
<h4 id="3-增加-ACL-权限"><a href="#3-增加-ACL-权限" class="headerlink" title="3 增加 ACL 权限"></a>3 增加 ACL 权限</h4><ol>
<li><code>setfacl -m m:权限 FILE</code><ul>
<li>设置最大有效权限 mask</li>
</ul>
</li>
<li><code>setfacl -m u:用户名:权限 FILE</code><ul>
<li>为某个用户设置acl权限</li>
</ul>
</li>
<li><code>setfacl -m g:组名:权限 FILE</code><ul>
<li>为某个组设置acl权限</li>
</ul>
</li>
<li><code>setfacl -m d:u:用户名:权限 DIR</code><ul>
<li>对目录设置默认acl权限</li>
</ul>
</li>
<li><code>setfacl -m u:用户名:权限 DIR</code><ul>
<li>对目录递归设置acl权限</li>
</ul>
</li>
</ol>
<h4 id="4-删除-ACL-权限"><a href="#4-删除-ACL-权限" class="headerlink" title="4 删除 ACL 权限"></a>4 删除 ACL 权限</h4><ol>
<li><code>setfacl -x u:用户名 FILE</code><ul>
<li>删除用户的acl权限</li>
</ul>
</li>
<li><code>setfacl -x g:组名 FILE</code><ul>
<li>删除组的acl权限</li>
</ul>
</li>
<li><code>setfacl -b FILE</code><ul>
<li>删除文件所有的acl权限</li>
</ul>
</li>
<li><code>seffacl -k DIR</code><ul>
<li>删除目录默认的acl权限</li>
</ul>
</li>
</ol>
<h2 id="5-6-文件扩展属性（隐藏属性）"><a href="#5-6-文件扩展属性（隐藏属性）" class="headerlink" title="5.6 文件扩展属性（隐藏属性）"></a>5.6 文件扩展属性（隐藏属性）</h2><h3 id="1-chattr（change-file-attributes-on-a-Linux-file-system）"><a href="#1-chattr（change-file-attributes-on-a-Linux-file-system）" class="headerlink" title="1 chattr（change file attributes on a Linux file system）"></a>1 chattr（change file attributes on a Linux file system）</h3><ul>
<li><code>chattr {+-=} [属性] FILE</code><ul>
<li>修改文件或目录的隐藏属性（仅 root 可用）</li>
<li><code>+</code><ul>
<li>增加属性</li>
</ul>
</li>
<li><code>-</code><ul>
<li>删除属性</li>
</ul>
</li>
<li><code>=</code><ul>
<li>设置属性</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>文件</th>
<th>目录</th>
</tr>
</thead>
<tbody><tr>
<td><code>i（immutable）</code></td>
<td>不允许任何修改</td>
<td>可以修改目录下文件数据，不能新建和删除文件</td>
</tr>
<tr>
<td><code>a（append only）</code></td>
<td>可以给文件添加数据，不能修改和删除数据</td>
<td>可以修改目录下文件数据以及新建文件，不能删除文件</td>
</tr>
</tbody></table>
<h3 id="2-lsattr（list-file-attributes-on-a-Linux-second-extended-file-system）"><a href="#2-lsattr（list-file-attributes-on-a-Linux-second-extended-file-system）" class="headerlink" title="2 lsattr（list file attributes on a Linux second extended file system）"></a>2 lsattr（list file attributes on a Linux second extended file system）</h3><ul>
<li><code>lsattr [OPTION] [FILE]</code><ul>
<li>查看文件或目录的隐藏属性</li>
<li><code>OPTION</code><ul>
<li><code>-a</code><ul>
<li>若没有指定文件，则显示所有文件和目录</li>
</ul>
</li>
<li><code>-d</code><ul>
<li>若目标是目录，仅列出目录本身隐藏属性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 磁盘</title>
    <url>/anyeansan.github.io/2020/03/29/Linux-%E7%A3%81%E7%9B%98/</url>
    <content><![CDATA[<h1 id="一-磁盘接口分类"><a href="#一-磁盘接口分类" class="headerlink" title="一 磁盘接口分类"></a>一 磁盘接口分类</h1><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td><code>SAS</code></td>
<td><code>Serial Attached SCSI</code></td>
<td>服务器</td>
</tr>
<tr>
<td><code>SATA</code></td>
<td><code>Serial ATA</code></td>
<td>个人电脑</td>
</tr>
<tr>
<td><code>SSD</code></td>
<td><code>Solid State Disk</code></td>
<td>服务器，个人电脑</td>
</tr>
<tr>
<td><code>SCSI</code></td>
<td><code>Small Computer System Interface</code></td>
<td><code>@declared</code></td>
</tr>
<tr>
<td><code>IDE</code></td>
<td><code>Integrated Drive Electronics</code></td>
<td><code>@declared</code></td>
</tr>
</tbody></table>
<h1 id="二-磁盘物理结构"><a href="#二-磁盘物理结构" class="headerlink" title="二 磁盘物理结构"></a>二 磁盘物理结构</h1><h2 id="2-1-外部结构"><a href="#2-1-外部结构" class="headerlink" title="2.1 外部结构"></a>2.1 外部结构</h2><ol>
<li>磁盘主轴<ul>
<li>决定磁盘转速（rpm-round per minute）</li>
</ul>
</li>
<li>磁盘盘片<ul>
<li>用于存储数据</li>
</ul>
</li>
<li>磁盘磁头（Head）<ul>
<li>用于读取数据</li>
<li>每个盘面都有一个磁头</li>
<li><code>磁头数 = 盘面数 = 盘片 * 2</code></li>
</ul>
</li>
<li>磁盘接口<ul>
<li>用于连接主板，用于连接阵列卡</li>
</ul>
</li>
</ol>
<h2 id="2-2-内部结构"><a href="#2-2-内部结构" class="headerlink" title="2.2 内部结构"></a>2.2 内部结构</h2><ol>
<li>磁道（Track）<ol>
<li>盘面中一圈圈的同心圆称为磁道</li>
<li>每个盘面都被划分为数目相等的磁道，由外向内从 <code>0</code> 开始编号</li>
</ol>
</li>
<li>柱面（Cylinder）<ol>
<li>不同盘面上编号相同的磁道形成一个圆柱就叫做柱面</li>
<li>磁头在每个盘面上的都是一起移动的，所在磁道编号都相同，所以数据的读写以及磁盘分区都是按柱面进行的</li>
<li><code>柱面数 = 任意一个盘面的磁道数</code></li>
</ol>
</li>
<li>单元块（Units）<ol>
<li>单个柱面的大小</li>
</ol>
</li>
<li>扇区（Sector）<ol>
<li>磁道被直径划分为若干个弧段，每个弧段称为一个扇区，从1开始编号</li>
<li>扇区是磁盘存储的最小单位，通常是512字节</li>
</ol>
</li>
<li>簇（Clust）/ 块（Block）<ol>
<li>操作系统读取磁盘时，一个扇区一个扇区的读，效率太低，会一次性读取多个扇区，多个扇区就叫簇（windows）/ 块（linux）</li>
<li>簇 / 块 是文件系统存储的最小单位</li>
</ol>
</li>
</ol>
<h2 id="2-3-磁盘容量"><a href="#2-3-磁盘容量" class="headerlink" title="2.3 磁盘容量"></a>2.3 磁盘容量</h2><ul>
<li><code>磁盘容量 = 磁头数(盘面数) × 每面磁道数(柱面数) × 每道扇区数 × 每扇区字节数(512byte)</code></li>
</ul>
<h1 id="三-RAID（Redundant-Array-of-Independent-Disks）"><a href="#三-RAID（Redundant-Array-of-Independent-Disks）" class="headerlink" title="三 RAID（Redundant Array of Independent Disks）"></a>三 RAID（Redundant Array of Independent Disks）</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol>
<li>独立冗余磁盘阵列</li>
<li>把好几块硬盘通过一定组合方式把它组合起来，成为一个新的硬盘阵列组，从而使它能够达到高性能硬盘的要求</li>
</ol>
<h2 id="3-2-作用"><a href="#3-2-作用" class="headerlink" title="3.2 作用"></a>3.2 作用</h2><ol>
<li>提高磁盘存储效率<ul>
<li>提高I/O速度，提供了数据并发性</li>
</ul>
</li>
<li>提高磁盘存储安全<ul>
<li>数据冗余（备份），数据校验</li>
</ul>
</li>
<li>提高磁盘存储容量<ul>
<li>扩充容量</li>
</ul>
</li>
</ol>
<h2 id="3-3-RAID-级别（整合方式）"><a href="#3-3-RAID-级别（整合方式）" class="headerlink" title="3.3 RAID 级别（整合方式）"></a>3.3 RAID 级别（整合方式）</h2><ol>
<li><code>raid 0</code><ol>
<li>多块盘整合在一起，全部用作存储</li>
<li>可用容量为所有盘容量之和，性能高</li>
<li>没有冗余，有一块盘坏则整个raid 0 就坏，数据会丢失</li>
</ol>
</li>
<li><code>raid 1</code><ol>
<li>两块盘整合在一起，一个盘存储，一个盘备份</li>
<li>可用容量为一个盘，性能底</li>
<li>冗余100%，一块盘坏了数据也不会丢失</li>
</ol>
</li>
<li><code>raid 5</code><ol>
<li>至少有三个盘，一次只有两块盘存储，另一个盘作奇偶校验</li>
<li>容量为两个盘的容量，性能高</li>
<li>如果只有一块盘坏了，可以根据另外两块盘推算出这块盘的数据</li>
</ol>
</li>
<li><code>raid 10</code><ol>
<li>两个盘形成一个raid 1，然后两个raid 1形成一个raid 0</li>
</ol>
</li>
</ol>
<h3 id="RAID-各级别比较"><a href="#RAID-各级别比较" class="headerlink" title="RAID 各级别比较"></a>RAID 各级别比较</h3><ol>
<li>冗余<ul>
<li><code>RAID 1 &gt; RAID 10 &gt; RAID 5 &gt; RAID 0</code></li>
</ul>
</li>
<li>性能<ul>
<li><code>RAID 0 &gt; RAID 10 &gt; RAID 5 &gt; RAID 1</code></li>
</ul>
</li>
<li>成本<ul>
<li><code>RAID 10 &gt; RAID 1 &gt; RAID 5 &gt; RAID 0</code></li>
</ul>
</li>
</ol>
<h1 id="四-LVM（Logical-Volume-Manager）"><a href="#四-LVM（Logical-Volume-Manager）" class="headerlink" title="四 LVM（Logical Volume Manager）"></a>四 LVM（Logical Volume Manager）</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ol>
<li>逻辑卷管理器</li>
<li>实现分区的弹性扩容或缩容，逻辑卷通过命令可以从卷组中获取容量或者将容量返回给卷组</li>
</ol>
<h2 id="4-2-概念"><a href="#4-2-概念" class="headerlink" title="4.2 概念"></a>4.2 概念</h2><ol>
<li>物理卷 PV（Physical Volume）<ul>
<li>物理卷是 LVM 的基本存储逻辑块，可以是分区、磁盘或Raid</li>
<li>PE（physical extents）<ul>
<li>物理卷中可以分配的最小存储单元，PE的大小是可以指定的，默认为4MB</li>
</ul>
</li>
</ul>
</li>
<li>卷组 VG（Volume Group）<ul>
<li>一个卷组由一个或多个物理卷组成</li>
</ul>
</li>
<li>逻辑卷 LV（Logical Volume）<ul>
<li>逻辑卷建立在卷组之上，逻辑卷上可以建立文件系统，类似与其它硬盘的分区概念</li>
<li>LE（logical extent）<ul>
<li>逻辑卷中可以分配的最小存储单元，在同一个卷组中，LE的大小和PE是相同的，并且一一对应</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="五-磁盘分区"><a href="#五-磁盘分区" class="headerlink" title="五 磁盘分区"></a>五 磁盘分区</h1><h2 id="5-1-系统启动引导记录"><a href="#5-1-系统启动引导记录" class="headerlink" title="5.1 系统启动引导记录"></a>5.1 系统启动引导记录</h2><h3 id="1-MBR（Master-Boot-Record）"><a href="#1-MBR（Master-Boot-Record）" class="headerlink" title="1 MBR（Master Boot Record）"></a>1 MBR（Master Boot Record）</h3><ol>
<li>用于引导磁盘空间小于2T</li>
<li>磁盘的 0 磁头、0 磁道、1 扇区 （512 bytes）<ol>
<li>主引导程序（BootLoader）（446 bytes）</li>
<li>磁盘分区表DPT（Disk Partition table）（64 bytes）<ul>
<li>1 个分区占16 bytes，所以最多有 4 个分区</li>
</ul>
</li>
<li>分区有效(结束)标志（magic number）（2 bytes <code>55AA</code>）</li>
</ol>
</li>
</ol>
<h3 id="2-GPT"><a href="#2-GPT" class="headerlink" title="2 GPT"></a>2 GPT</h3><ul>
<li>用于引导磁盘空间大于2T</li>
</ul>
<h2 id="5-2-分区概述"><a href="#5-2-分区概述" class="headerlink" title="5.2 分区概述"></a>5.2 分区概述</h2><h3 id="1-Linux-磁盘和分区的命名规则"><a href="#1-Linux-磁盘和分区的命名规则" class="headerlink" title="1 Linux 磁盘和分区的命名规则"></a>1 Linux 磁盘和分区的命名规则</h3><table>
<thead>
<tr>
<th>磁盘种类</th>
<th>磁盘命名</th>
<th>分区命名</th>
</tr>
</thead>
<tbody><tr>
<td><code>SAS SATA SCSI</code></td>
<td>第一块：<code>sda</code><br>第二块：<code>sdb</code><br>…</td>
<td><code>sda1 sda2 ...</code><br><code>sdb1 sdb2 ...</code></td>
</tr>
<tr>
<td><code>IDE</code></td>
<td>第一块：<code>hda</code><br>第二块：<code>hdb</code><br>…</td>
<td><code>hda1 hda2 ...</code><br><code>hdb1 hdb2 ...</code></td>
</tr>
</tbody></table>
<h3 id="2-分区说明"><a href="#2-分区说明" class="headerlink" title="2 分区说明"></a>2 分区说明</h3><table>
<thead>
<tr>
<th>分区</th>
<th>编号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>主分区（Primary）</code></td>
<td><code>1 ~ 4</code></td>
<td>至少有 1 个，至多有 4 个</td>
</tr>
<tr>
<td><code>扩展分区（Extend）</code></td>
<td><code>1 ~ 4</code></td>
<td>至多有 1 个</td>
</tr>
<tr>
<td><code>逻辑分区（Logical）</code></td>
<td><code>5+</code></td>
<td>由扩展分区划分成一个个逻辑分区</td>
</tr>
<tr>
<td>1. 真正存放数据的是主分区和逻辑分区，大量数据都放在逻辑分区中</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2. 扩展分区可以理解为一个概念，用来划分逻辑分区用的，可以使用 <code>1 ~ 4</code> 任意一个编号</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="3-分区方式"><a href="#3-分区方式" class="headerlink" title="3 分区方式"></a>3 分区方式</h3><ol>
<li><code>1~4 个 主分区</code><ul>
<li>磁盘：<code>sda</code></li>
<li>主分区：<code>sda1 sda2 sda3 sda4</code>（数量任意）</li>
</ul>
</li>
<li><code>1~3 个 主分区 + 1 个扩展分区（分成 n 个逻辑分区）</code><ul>
<li>磁盘：<code>sda</code></li>
<li>主分区：<code>sda1 sda2 sda3</code>（数量任意）</li>
<li>扩展分区：<code>sda4</code>（编号 1 ~ 4 任意，不与主分区重复即可）</li>
<li>逻辑分区：<code>sda5 sda6 ...</code></li>
</ul>
</li>
</ol>
<h3 id="4-分区方案"><a href="#4-分区方案" class="headerlink" title="4 分区方案"></a>4 分区方案</h3><h4 id="1-普通分区方式"><a href="#1-普通分区方式" class="headerlink" title="1 普通分区方式"></a>1 普通分区方式</h4><ul>
<li><code>/boot</code><ul>
<li>引导分区，256Mb</li>
</ul>
</li>
<li><code>swap</code><ul>
<li>交换分区，把内存中暂时不用的数据临时存放到硬盘中，以腾出物理内存空间供给更活跃的程序服务来使用，目的是为了解决真实物理内存不足 </li>
<li>内存 &gt; 8G，swap = 8G，内存 &lt; 8G，swap = 内存 * 1.5</li>
</ul>
</li>
<li><code>/</code><ul>
<li>根分区，剩余大小</li>
</ul>
</li>
</ul>
<h4 id="2-存储服务器分区方式"><a href="#2-存储服务器分区方式" class="headerlink" title="2 存储服务器分区方式"></a>2 存储服务器分区方式</h4><ul>
<li><code>/boot</code></li>
<li><code>swap</code></li>
<li><code>/</code><ul>
<li>20G~200G</li>
</ul>
</li>
<li><code>/data</code><ul>
<li>剩余大小，<code>data</code> 名称可自定义</li>
</ul>
</li>
</ul>
<h4 id="3-灵活分区方式"><a href="#3-灵活分区方式" class="headerlink" title="3 灵活分区方式"></a>3 灵活分区方式</h4><ul>
<li><code>/boot</code></li>
<li><code>swap</code></li>
<li><code>/</code><ul>
<li>20G~200G</li>
<li>剩余保留，以后哪个部门使用，就分出相应的分区。</li>
</ul>
</li>
</ul>
<h2 id="5-3-分区操作"><a href="#5-3-分区操作" class="headerlink" title="5.3 分区操作"></a>5.3 分区操作</h2><h3 id="1-fdisk（manipulate-disk-partition-table）"><a href="#1-fdisk（manipulate-disk-partition-table）" class="headerlink" title="1 fdisk（manipulate disk partition table）"></a>1 fdisk（manipulate disk partition table）</h3><ol>
<li><code>fdisk -l [device]</code><ul>
<li>查看磁盘及其分区表信息</li>
</ul>
</li>
<li><code>fdisk device</code><ul>
<li>分区（交互式操作），有默认值时直接回车代表使用默认值</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>交互命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>n</code></td>
<td>创建分区</td>
</tr>
<tr>
<td><code>d</code></td>
<td>删除分区</td>
</tr>
<tr>
<td><code>p</code></td>
<td>显示分区表</td>
</tr>
<tr>
<td><code>q</code></td>
<td>不保存退出</td>
</tr>
<tr>
<td><code>w</code></td>
<td>将分区信息写入分区表，即保存退出</td>
</tr>
<tr>
<td><code>l</code></td>
<td>显示分区类型与分区类型id对照表，如 <code>83:linux，8e:linux LVM</code></td>
</tr>
<tr>
<td><code>t</code></td>
<td>改变分区类型</td>
</tr>
<tr>
<td><code>u</code></td>
<td>改变分区的方式（是否按照扇区进行划分）</td>
</tr>
<tr>
<td><code>g</code></td>
<td>创建一个新的空的 GPT 分区表</td>
</tr>
</tbody></table>
<h3 id="2-parted"><a href="#2-parted" class="headerlink" title="2 parted"></a>2 parted</h3><ul>
<li><code>parted device</code><ul>
<li>用来划分容量大于2T的磁盘（交互式操作）</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>交互命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>mklabel</code></td>
<td>创建一个分区表（默认为MBR）</td>
</tr>
<tr>
<td><code>mklabel gpt</code></td>
<td>修改分区表为GPT</td>
</tr>
<tr>
<td><code>print</code></td>
<td>显示分区表</td>
</tr>
<tr>
<td><code>mkpart PART-TYPE [FS-TYPE] START END</code></td>
<td>创建分区（立即生效）</td>
</tr>
<tr>
<td><code>rm NUMBER</code></td>
<td>根据编号删除分区</td>
</tr>
<tr>
<td><code>quit</code></td>
<td>退出</td>
</tr>
</tbody></table>
<h3 id="3-partprobe"><a href="#3-partprobe" class="headerlink" title="3 partprobe"></a>3 partprobe</h3><ul>
<li><code>partprobe [device]</code><ul>
<li>重新读取分区表信息</li>
<li>分区完成之后，要执行此命令让系统识别分区文件</li>
</ul>
</li>
</ul>
<h1 id="六-格式化"><a href="#六-格式化" class="headerlink" title="六 格式化"></a>六 格式化</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><ol>
<li>格式化用来创建文件系统</li>
<li>文件系统<ol>
<li><code>xfs</code><ul>
<li>CentOS 7</li>
</ul>
</li>
<li><code>ext3/4</code><ul>
<li>CentOS 6</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="6-2-格式化操作"><a href="#6-2-格式化操作" class="headerlink" title="6.2 格式化操作"></a>6.2 格式化操作</h2><h3 id="mkfs（make-file-system）"><a href="#mkfs（make-file-system）" class="headerlink" title="mkfs（make file system）"></a>mkfs（make file system）</h3><ol>
<li><code>mkfs -t type device</code><ul>
<li><code>type</code><ul>
<li>文件系统类型，如 <code>xfs ext4 ...</code></li>
</ul>
</li>
</ul>
</li>
<li><code>mkfs.type device</code></li>
</ol>
<h1 id="七-挂载"><a href="#七-挂载" class="headerlink" title="七 挂载"></a>七 挂载</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ol>
<li>Linux中的存储设备（磁盘、光盘…）是不能直接访问的，需要将一个目录与一个存储设备相关联，通过关联目录访问存储设备中的数据。<ol>
<li>将目录与存储设备关联的动作叫做 <strong>挂载</strong></li>
<li>与存储设备关联的目录叫做 <strong>挂载点</strong>。</li>
</ol>
</li>
<li>装完Linux系统后，能直接访问磁盘，是因为系统根据我们对磁盘的分区信息及顺序与指定目录进行了挂载，如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分区		 挂载点</span><br><span class="line">/dev/sda1	/boot</span><br><span class="line">/dev/sda2	swap</span><br><span class="line">/dev/sda3	/</span><br></pre></td></tr></table></figure></li>
<li>磁盘的使用<ul>
<li>分区（可选）→  格式化 → 挂载</li>
</ul>
</li>
</ol>
<h2 id="7-2-挂载操作"><a href="#7-2-挂载操作" class="headerlink" title="7.2 挂载操作"></a>7.2 挂载操作</h2><h3 id="1-查"><a href="#1-查" class="headerlink" title="1 查"></a>1 查</h3><ul>
<li><code>mount [-l]</code><ul>
<li>显示系统中已经挂载的设备，</li>
<li><code>-l</code><ul>
<li>会显示卷标名称</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-挂载"><a href="#2-挂载" class="headerlink" title="2 挂载"></a>2 挂载</h3><ul>
<li><code>mount [-t 文件系统] [-L 卷标名] [-o 挂载参数] 设备文件名 挂载点</code><ul>
<li>临时挂载设备，重启失效</li>
</ul>
</li>
</ul>
<h3 id="3-卸载挂载"><a href="#3-卸载挂载" class="headerlink" title="3 卸载挂载"></a>3 卸载挂载</h3><ul>
<li><code>umount 挂载点|设备文件</code></li>
</ul>
<h3 id="4-开机自动挂载"><a href="#4-开机自动挂载" class="headerlink" title="4 开机自动挂载"></a>4 开机自动挂载</h3><h4 id="1-使用开机自启动配置文件"><a href="#1-使用开机自启动配置文件" class="headerlink" title="1 使用开机自启动配置文件"></a>1 使用开机自启动配置文件</h4><ul>
<li><code>/etc/rc.local -&gt; /etc/rc.d/rc.local</code><ul>
<li>在此系统开机自启动配置文件，配置挂载命令，即可实现开机自动挂载</li>
<li>注意要给 <code>/etc/rc.d/rc.local</code> 赋予执行权限</li>
</ul>
</li>
</ul>
<h4 id="2-使用挂载配置文件"><a href="#2-使用挂载配置文件" class="headerlink" title="2 使用挂载配置文件"></a>2 使用挂载配置文件</h4><ul>
<li><code>/etc/fstab</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UUID=13ba788b-e881-484b-865f-2adc27ded83c    /        xfs     defaults    0    0</span><br><span class="line">UUID=a347b25e-b9a2-4dee-bd26-7d4214c4959b    /boot    xfs     defaults    0    0</span><br><span class="line">UUID=fbb8a2df-84b3-441f-a511-0760f45c9584    swap     swap    defaults    0    0</span><br><span class="line">设备/设备UUID 挂载点 文件系统类型 挂载参数 是否备份 是否自检</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li><code>blkid</code><ul>
<li>查看设备的名称、文件系统类型、UUID、LABEL等信息</li>
</ul>
</li>
<li><code>mount -a</code><ul>
<li>检查 <code>/etc/fstab</code> 文件中挂载的设备文件有无疏漏，若有，则进行挂载</li>
</ul>
</li>
</ol>
<h3 id="5-不同设备的挂载"><a href="#5-不同设备的挂载" class="headerlink" title="5 不同设备的挂载"></a>5 不同设备的挂载</h3><ol>
<li>挂载硬盘分区<ul>
<li><code>mount [-t xfs] /dev/分区名 挂载点</code></li>
</ul>
</li>
<li>挂载U盘<ul>
<li><code>mount [-t vfat] /dev/设备号 挂载点</code><ul>
<li>U盘和硬盘一样，设备号不固定，先使用 <code>fdisk -l</code> 查询设备号</li>
</ul>
</li>
</ul>
</li>
<li>挂载光盘<ul>
<li><code>mount [-t iso9660] {/dev/sr0 | /dev/cdrom} 挂载点</code><ul>
<li><code>/dev/cdrom</code> 是 <code>/dev/sr0</code> 的软连接</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="八-问题"><a href="#八-问题" class="headerlink" title="八 问题"></a>八 问题</h1><h2 id="8-1-磁盘空间不足（no-space-left-on-device）"><a href="#8-1-磁盘空间不足（no-space-left-on-device）" class="headerlink" title="8.1 磁盘空间不足（no space left on device）"></a>8.1 磁盘空间不足（no space left on device）</h2><ol>
<li>block 存储空间不足<ul>
<li>原因：存储数据过多</li>
<li>解决：删除没用数据</li>
</ul>
</li>
<li>inode 数量不足<ul>
<li>原因：大量小文件占用 inode</li>
<li>解决：删除大量的没用小文件</li>
</ul>
</li>
</ol>
<h2 id="8-2-调整-swap-分区大小"><a href="#8-2-调整-swap-分区大小" class="headerlink" title="8.2 调整 swap 分区大小"></a>8.2 调整 swap 分区大小</h2><ol>
<li>从磁盘分出一部分空间（创建一个空文件 <code>FILE</code>）<ul>
<li><code>dd if=/etc/zero of=DIR bs= count=</code></li>
</ul>
</li>
<li><code>mkswap FILE</code><ul>
<li>把文件作为 swap 空间使用</li>
</ul>
</li>
<li><code>swapon FILE</code><ul>
<li>激活扩展的 swap 空间</li>
</ul>
</li>
<li><code>swapoff FILE</code><ul>
<li>取消扩展的 swap 空间</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 用户管理</title>
    <url>/anyeansan.github.io/2020/03/29/Linux-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="一-用户分类"><a href="#一-用户分类" class="headerlink" title="一 用户分类"></a>一 用户分类</h1><p>UID|用户|说明|例<br>-|-<br><code>0</code>|超级管理员|<code>root</code> 不一定是超级管理员，<code>uid=0</code> 的一定是超级管理员|<code>root</code><br><code>1~999</code>|系统用户（虚拟用户）|用于维持、管理某个服务正常运行，不能登录且没有家目录，不能删除|<code>nobody</code><br><code>1000+</code>|普通用户|管理指定数据，可以管理指定进程，可以登录|<code>自定义</code></p>
<h1 id="二-配置文件"><a href="#二-配置文件" class="headerlink" title="二 配置文件"></a>二 配置文件</h1><h2 id="2-1-用户信息"><a href="#2-1-用户信息" class="headerlink" title="2.1 用户信息"></a>2.1 用户信息</h2><ul>
<li><code>/etc/passwd</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root: x: 0: 0: root: /root: /bin/bash</span><br><span class="line">1 用户名:</span><br><span class="line">2 用户密码占位符（x表示有密码）:</span><br><span class="line">3 用户Uid:</span><br><span class="line">4 用户Gid:</span><br><span class="line">5 用户描述信息:</span><br><span class="line">6 用户家目录:</span><br><span class="line">7 用户登录后使用的shell:</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2-2-用户密码信息，仅-root-可读"><a href="#2-2-用户密码信息，仅-root-可读" class="headerlink" title="2.2 用户密码信息，仅 root 可读"></a>2.2 用户密码信息，仅 root 可读</h2><ul>
<li><code>/etc/shadow</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root: $6$SlHDoVNtoeyDU/3w$y.ap.le40W39OROwHTk2xJnjDUbIcXX9GcAOOQA3k6yteiu9Xq9XyZzB8U/GbNzFSZ3LoC4q6Pazh806WZaKL0: : 0: 99999: 7: : :</span><br><span class="line">1 用户名：</span><br><span class="line">2 密码（加密）：</span><br><span class="line">3 密码最后修改时间：表示账号在1970-01-01之后的第 n 天修改的密码</span><br><span class="line">4 密码最小修改时间间隔：表示密码修改之后隔多久可以再次修改</span><br><span class="line">5 密码有效期：表示密码修改之后有效期限，超过期限会过期，必须重新修改</span><br><span class="line">6 密码过期前警告天数：默认为7，表示密码过期前7天会发送警告信息</span><br><span class="line">7 密码过期后宽限天数：</span><br><span class="line">8 账号失效时间：表示账号在1970-01-01之后的 n 天内有效，超过则失效</span><br><span class="line">9 保留字段：</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2-3-用户组信息"><a href="#2-3-用户组信息" class="headerlink" title="2.3 用户组信息"></a>2.3 用户组信息</h2><ul>
<li><code>/etc/group</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root: x: 0:</span><br><span class="line">1 组名：</span><br><span class="line">2 组密码占位符（x表示有密码）：</span><br><span class="line">3 组id（Gid）：</span><br><span class="line">4 组附加用户：即如果组是用户的初始组，则不显示此用户，只显示组中其它用户</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2-4-用户组密码信息"><a href="#2-4-用户组密码信息" class="headerlink" title="2.4 用户组密码信息"></a>2.4 用户组密码信息</h2><ul>
<li><code>/etc/gshadow</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root: : :</span><br><span class="line">1 组名：</span><br><span class="line">2 组密码：空表示没有组密码，`!` 表示没有组密码也没有组管理员</span><br><span class="line">3 组管理员：</span><br><span class="line">4 组附加用户：</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2-5-用户模板目录"><a href="#2-5-用户模板目录" class="headerlink" title="2.5 用户模板目录"></a>2.5 用户模板目录</h2><ul>
<li><code>/etc/skel/</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加用户时，此目录中文件会自动存入用户家目录</span><br><span class="line">.bash_logout  # 退出登录时执行</span><br><span class="line">.bash_profile</span><br><span class="line">.bashrc</span><br><span class="line">.viminfo # vim文件模板</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2-6-用户邮件目录"><a href="#2-6-用户邮件目录" class="headerlink" title="2.6 用户邮件目录"></a>2.6 用户邮件目录</h2><ul>
<li><code>/var/spool/mail/用户名/</code></li>
</ul>
<h2 id="2-7-新建用户配置文件"><a href="#2-7-新建用户配置文件" class="headerlink" title="2.7 新建用户配置文件"></a>2.7 新建用户配置文件</h2><ol>
<li><code>/etc/default/useradd</code><ul>
<li>创建用户时的默认值</li>
</ul>
</li>
<li><code>/etc/login.defs</code><ul>
<li>用于在创建用户时，对用户的一些基本属性做默认设置，例如指定用户 UID 和 GID 的范围，用户的过期时间，密码的最大长度，等等</li>
</ul>
</li>
</ol>
<h1 id="三-用户管理"><a href="#三-用户管理" class="headerlink" title="三 用户管理"></a>三 用户管理</h1><h2 id="3-1-查"><a href="#3-1-查" class="headerlink" title="3.1 查"></a>3.1 查</h2><h3 id="1-id（print-real-and-effective-user-and-group-IDs）"><a href="#1-id（print-real-and-effective-user-and-group-IDs）" class="headerlink" title="1 id（print real and effective user and group IDs）"></a>1 id（print real and effective user and group IDs）</h3><ul>
<li><code>id [OPTION] [USER]</code><ul>
<li>显示用户 <code>uid gid gids</code>，默认为显示当前用户</li>
<li><code>OPTION</code><ul>
<li><code>-u, --user</code><ul>
<li>显示用户 uid</li>
</ul>
</li>
<li><code>-g, --group</code><ul>
<li>显示用户 gid</li>
</ul>
</li>
<li><code>-G, --groups</code><ul>
<li>显示用户所有所在组的 gid</li>
</ul>
</li>
<li><code>-n, --name</code><ul>
<li>与 <code>u g G</code> 一起使用显示名称而不是id</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-w（Show-who-is-logged-on-and-what-they-are-doing）"><a href="#2-w（Show-who-is-logged-on-and-what-they-are-doing）" class="headerlink" title="2 w（Show who is logged on and what they are doing）"></a>2 w（Show who is logged on and what they are doing）</h3><ul>
<li><code>w</code><ul>
<li>显示登录用户信息及负载信息</li>
</ul>
</li>
</ul>
<h3 id="3-who（show-who-is-logged-on）"><a href="#3-who（show-who-is-logged-on）" class="headerlink" title="3 who（show who is logged on）"></a>3 who（show who is logged on）</h3><ul>
<li><code>who</code><ul>
<li>显示登录用户信息</li>
</ul>
</li>
</ul>
<h3 id="4-whoami"><a href="#4-whoami" class="headerlink" title="4 whoami"></a>4 whoami</h3><ul>
<li><code>whoami</code>    <ul>
<li>显示当前登录用户名</li>
</ul>
</li>
</ul>
<h3 id="5-last"><a href="#5-last" class="headerlink" title="5 last"></a>5 last</h3><ul>
<li><code>last</code><ul>
<li>查看系统的所有登录信息</li>
<li><code>last</code> 命令默认读取 <code>/var/log/wtmp</code> 日志，这是一个二进制文件</li>
</ul>
</li>
</ul>
<h3 id="6-lastlog"><a href="#6-lastlog" class="headerlink" title="6 lastlog"></a>6 lastlog</h3><ul>
<li><code>lastlog [-u UID]</code><ul>
<li>查看用户最后一次登录系统的信息</li>
<li><code>lastlog</code> 命令默认读取 <code>/var/log/lastlog</code> 日志，这是一个二进制文件</li>
</ul>
</li>
</ul>
<h2 id="3-2-增"><a href="#3-2-增" class="headerlink" title="3.2 增"></a>3.2 增</h2><h3 id="1-useradd（create-a-new-user-or-update-default-new-user-information）"><a href="#1-useradd（create-a-new-user-or-update-default-new-user-information）" class="headerlink" title="1 useradd（create a new user or update default new user information）"></a>1 useradd（create a new user or update default new user information）</h3><ul>
<li><code>useradd [OPTION] username</code><ul>
<li><code>OPTION</code><ul>
<li><code>-u, --uid UID</code><ul>
<li>指定Uid</li>
</ul>
</li>
<li><code>-g, --gid GROUP</code><ul>
<li>指定用户初始组（组必须存在），且不会创建默认同名组。</li>
<li>默认会创建一个与用户名相同的初始组。</li>
</ul>
</li>
<li><code>-G, --groups GROUP1[,GROUP2,...[,GROUPN]]]</code><ul>
<li>指定用户附加组</li>
</ul>
</li>
<li><code>-s, --shell SHELL</code><ul>
<li>指定SHELL，默认为 <code>/bin/bash</code></li>
</ul>
</li>
<li><code>-c, --comment COMMENT</code><ul>
<li>用户描述信息</li>
</ul>
</li>
<li><code>-d, --home-dir HOME_DIR</code><ul>
<li>指定用户家目录</li>
<li>默认的用户家目录为 <code>/home/username</code></li>
</ul>
</li>
<li><code>-M, --no-create-home</code><ul>
<li>不创建家目录</li>
</ul>
</li>
<li><code>-N, --no-user-group</code><ul>
<li>不创建与用户同名的初始组</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-passwd（update-user’s-authentication-tokens）"><a href="#2-passwd（update-user’s-authentication-tokens）" class="headerlink" title="2 passwd（update user’s authentication tokens）"></a>2 passwd（update user’s authentication tokens）</h3><ul>
<li><code>passwd [OPTION] [USER]</code><ul>
<li>修改用户密码（默认交互式）</li>
<li><code>OPTION</code><ul>
<li><code>-S</code><ul>
<li>查询用户密码状态（仅 root 可用）</li>
</ul>
</li>
<li><code>-l, --lock</code><ul>
<li>锁定用户。会在<code>/etc/shadow</code> 中指定用户的密码前添加 <code>!</code>，使密码失效（仅 root 可用）</li>
</ul>
</li>
<li><code>-u, --unlock</code><ul>
<li>解锁用户（仅 root 可用）</li>
</ul>
</li>
<li><code>--stdin</code><ul>
<li>接收标准输入（如管道）的数据作为密码（非交互式）</li>
<li><code>echo 密码 | passwd --stdin 用户</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-3-删"><a href="#3-3-删" class="headerlink" title="3.3 删"></a>3.3 删</h2><h3 id="1-userdel（delete-a-user-account-and-related-files）"><a href="#1-userdel（delete-a-user-account-and-related-files）" class="headerlink" title="1 userdel（delete a user account and related files）"></a>1 userdel（delete a user account and related files）</h3><ul>
<li><code>userdel [OPTION] USER</code><ul>
<li>删除用户<ol>
<li>实际就是从<code>/etc/passwd shadow group gshadow</code> 中删除用户信息</li>
<li>用户个人文件（家目录和邮件目录）默认会保留</li>
</ol>
</li>
<li><code>OPTION</code><ul>
<li><code>-r, --remove</code><ul>
<li>删除用户及个人文件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-4-改"><a href="#3-4-改" class="headerlink" title="3.4 改"></a>3.4 改</h2><h3 id="1-usermod（modify-a-user-account）"><a href="#1-usermod（modify-a-user-account）" class="headerlink" title="1 usermod（modify a user account）"></a>1 usermod（modify a user account）</h3><ul>
<li><code>usermod [OPTION] [USER]</code><ul>
<li>修改用户信息</li>
<li><code>OPTION</code><ul>
<li><code>-u UID</code><ul>
<li>修改用户uid</li>
</ul>
</li>
<li><code>-g GROUP</code><ul>
<li>修改用户初始组</li>
</ul>
</li>
<li><code>-G GROUPS</code><ul>
<li>修改用户附加组</li>
</ul>
</li>
<li><code>-c COMMENT</code><ul>
<li>修改用户说明</li>
</ul>
</li>
<li><code>-s SHELL</code><ul>
<li>修改用户Shell</li>
</ul>
</li>
<li><code>-d HOME__DIR</code><ul>
<li>修改用户家目录</li>
</ul>
</li>
<li><code>-l USERNAME</code><ul>
<li>修改用户名，注意修改家目录名和邮箱名以保持同步</li>
</ul>
</li>
<li><code>-L</code><ul>
<li>临时锁定用户</li>
</ul>
</li>
<li><code>-U</code><ul>
<li>解锁用户</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-chage（change-user-password-expiry-information）"><a href="#2-chage（change-user-password-expiry-information）" class="headerlink" title="2 chage（change user password expiry information）"></a>2 chage（change user password expiry information）</h3><ul>
<li><code>chage [OPTION] [USER]</code><ul>
<li>修改用户密码信息</li>
<li><code>OPTION</code><ul>
<li><code>-l, --list</code><ul>
<li>列出用户的详细密码状态</li>
</ul>
</li>
<li><code>-d LAST_DAY</code><ul>
<li>修改密码最后更改日期</li>
<li><code>0</code><ul>
<li>用户一登陆就要修改密码</li>
</ul>
</li>
</ul>
</li>
<li><code>-m MIN_DAYS</code><ul>
<li>修改两次密码最小修改间隔</li>
</ul>
</li>
<li><code>-M MAX_DAYS</code><ul>
<li>修改密码的有效期</li>
</ul>
</li>
<li><code>-W WARM_DAYS</code><ul>
<li>修改密码到期前的警告天数</li>
</ul>
</li>
<li><code>-I DAYS</code><ul>
<li>修改密码过期后的宽限天数</li>
</ul>
</li>
<li><code>-E EXPIRE_DATE</code><ul>
<li>修改账号失效时间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-5-用户切换"><a href="#3-5-用户切换" class="headerlink" title="3.5 用户切换"></a>3.5 用户切换</h2><h3 id="1-su"><a href="#1-su" class="headerlink" title="1 su"></a>1 su</h3><ul>
<li><code>su [OPTION] USER</code><ul>
<li>普通用户切换至其它用户需要密码，root 切换至其它用户不需要密码</li>
<li><code>OPTION</code><ul>
<li><code>-</code><ul>
<li>不加 <code>-</code> ，只有部分环境变量会变</li>
<li>加 <code>-</code>，表示完全切换用户，环境变量会随之改变</li>
</ul>
</li>
<li><code>-c command</code><ul>
<li>仅切换用户执行一次命令，执行后自动切换回来</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-sudo（execute-a-command-as-another-user）"><a href="#2-sudo（execute-a-command-as-another-user）" class="headerlink" title="2 sudo（execute a command as another user）"></a>2 sudo（execute a command as another user）</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li><code>sudo</code> 是一种权限管理机制</li>
<li>管理员可以授权普通用户以其它身份执行一些命令</li>
</ol>
<h4 id="2-授权方式"><a href="#2-授权方式" class="headerlink" title="2 授权方式"></a>2 授权方式</h4><ol>
<li><code>/etc/sudoers</code><ul>
<li>直接修改此配置文件</li>
</ul>
</li>
<li><code>visudo</code><ul>
<li>等效于 <code>vim /etc/sudoers</code>，有语法检查（推荐）</li>
</ul>
</li>
</ol>
<h4 id="3-配置"><a href="#3-配置" class="headerlink" title="3 配置"></a>3 配置</h4><ul>
<li><code>/etc/sudoers</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1 语法</span><br><span class="line">授权的`用户`  主机地址=(可使用的身份 授权命令绝对路径列表</span><br><span class="line">授权的`%组` 主机地址=(可使用的身份 授权命令绝对路径列表</span><br><span class="line"># 2 例子</span><br><span class="line">root	ALL=(ALL)	ALL --- 表示root用户可以在任意主机上以任意身份执行任意命令</span><br><span class="line">an3	ALL=(ALL)	/usr/bin/cat, /usr/bin/less --- 表示an3用户可以在任意主机上以任意身份执行cat和less</span><br><span class="line">an3	ALL=(ALL)	 /usr/sbin/*, !/usr/sbin/visudo --- 表示 an3 用户可以在任意主机上以任意身份执行 /usr/sbin/ 下的所有命令，但排除 visudo 命令</span><br><span class="line">an3	ALL=(ALL)	NOPASSWD: /usr/sbin/*, !/usr/sbin/visudo --- NOPASSWD：表示在使用sudo执行命令时不需要输入密码</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="4-使用"><a href="#4-使用" class="headerlink" title="4 使用"></a>4 使用</h4><ol>
<li><code>sudo -l</code><ul>
<li>查看当前用户 sudo 可用的命令</li>
</ul>
</li>
<li><code>sudo command</code><ul>
<li>以管理员身份执行命令</li>
</ul>
</li>
</ol>
<h1 id="四-用户组管理"><a href="#四-用户组管理" class="headerlink" title="四 用户组管理"></a>四 用户组管理</h1><h2 id="4-1-groupadd（create-a-new-group）"><a href="#4-1-groupadd（create-a-new-group）" class="headerlink" title="4.1 groupadd（create a new group）"></a>4.1 groupadd（create a new group）</h2><ul>
<li><code>groupadd [OPTION] GROUP</code><ul>
<li>创建用户组</li>
<li><code>OPTION</code><ul>
<li><code>-g, --gid GID</code><ul>
<li>指定gid</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-2-groupdel（delete-a-group）"><a href="#4-2-groupdel（delete-a-group）" class="headerlink" title="4.2 groupdel（delete a group）"></a>4.2 groupdel（delete a group）</h2><ul>
<li><code>groupdel GROUP</code><ul>
<li>删除组</li>
<li>如果组是某个用户的初始组，则不能删除</li>
</ul>
</li>
</ul>
<h2 id="4-3-groupmod"><a href="#4-3-groupmod" class="headerlink" title="4.3 groupmod"></a>4.3 groupmod</h2><ul>
<li><code>groupmod [OPTION] GROUP</code><ul>
<li>修改组</li>
<li><code>-g GID</code><ul>
<li>修改gid</li>
</ul>
</li>
<li><code>-n NEW_NAME</code><ul>
<li>修改组名</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-4-gpasswd"><a href="#4-4-gpasswd" class="headerlink" title="4.4 gpasswd"></a>4.4 gpasswd</h2><ul>
<li><code>gpasswd [OPTION] GROUP</code><ul>
<li><code>-A USER</code><ul>
<li>将用户设置为组管理员</li>
</ul>
</li>
<li><code>-a, --add USER</code><ul>
<li>把用户加入组</li>
</ul>
</li>
<li><code>-d --delete USER</code><ul>
<li>把用户从组中删除</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 服务</title>
    <url>/anyeansan.github.io/2020/03/29/Linux-%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="一-防火墙（firewalld）"><a href="#一-防火墙（firewalld）" class="headerlink" title="一 防火墙（firewalld）"></a>一 防火墙（firewalld）</h1><h2 id="1-1-操作"><a href="#1-1-操作" class="headerlink" title="1.1 操作"></a>1.1 操作</h2><p>操作\服务名|firewalld（CentOS 7）|iptables（CentOS 6）<br>-|-<br><code>查看状态</code>|<code>systemctl status firewalld</code>|<code>/etc/init.d/iptables status</code><br><code>开启</code>|<code>systemctl start firewalld</code>|<code>/etc/init.d/iptables start</code><br><code>关闭</code>|<code>systemctl stop firewalld</code>|<code>/etc/init.d/iptables stop</code><br><code>开机启动</code>|<code>systemctl enable firewalld</code>|<code>chkconfig iptables on</code><br><code>开机不启动</code>|<code>systemctl disable firewalld</code>|<code>chkconfig iptables off</code></p>
<h2 id="1-2-配置（firewall-cmd）"><a href="#1-2-配置（firewall-cmd）" class="headerlink" title="1.2 配置（firewall-cmd）"></a>1.2 配置（firewall-cmd）</h2><ol>
<li><code>firewall-cmd --zone=public --list-ports</code><ul>
<li>查看所有已经开放的端口</li>
<li><code>--zone</code><ul>
<li>作用域</li>
</ul>
</li>
</ul>
</li>
<li><code>firewall-cmd --zone=public --query-port=端口/协议</code><ul>
<li>查看某个端口是否开放</li>
</ul>
</li>
<li><code>firewall-cmd [--permanent] --zone=public --add-port=端口/协议</code><ul>
<li>开放端口</li>
<li><code>--permanent</code><ul>
<li>永久生效，没此参数重启后失效</li>
</ul>
</li>
</ul>
</li>
<li><code>firewall-cmd [--permanent] --zone=public --remove-port=端口/协议</code><ul>
<li>删除端口</li>
</ul>
</li>
<li><code>firewall-cmd --reload</code><ul>
<li>重载防火墙规则</li>
</ul>
</li>
</ol>
<h1 id="二-远程连接服务（sshd）"><a href="#二-远程连接服务（sshd）" class="headerlink" title="二 远程连接服务（sshd）"></a>二 远程连接服务（sshd）</h1><h2 id="2-1-SSH（Secure-Shell-Protocol）"><a href="#2-1-SSH（Secure-Shell-Protocol）" class="headerlink" title="2.1 SSH（Secure Shell Protocol）"></a>2.1 SSH（Secure Shell Protocol）</h2><ol>
<li><code>SSH</code> 加密传输，安全</li>
<li><code>Telnet</code> 明文传输，不安全</li>
<li><code>openssh</code><ul>
<li>服务端软件，ssh 协议的开源实现，CentOS默认安装</li>
</ul>
</li>
<li><code>openssl</code><ul>
<li>连接和传输过程中加密软件</li>
</ul>
</li>
</ol>
<h2 id="2-2-连接方式"><a href="#2-2-连接方式" class="headerlink" title="2.2 连接方式"></a>2.2 连接方式</h2><h3 id="1-基于密码的远程连接"><a href="#1-基于密码的远程连接" class="headerlink" title="1 基于密码的远程连接"></a>1 基于密码的远程连接</h3><ol>
<li>公钥和私钥只用来完成数据加密</li>
<li>服务器发送公钥给客户端</li>
<li>客户端使用公钥对密码加密后回传给服务器，服务器解密验证密码</li>
</ol>
<h3 id="2-基于密钥的远程连接"><a href="#2-基于密钥的远程连接" class="headerlink" title="2 基于密钥的远程连接"></a>2 基于密钥的远程连接</h3><ol>
<li>在客户端创建密钥对<ul>
<li><code>ssh-keygen -t rsa</code><ul>
<li><code>-t</code><ul>
<li>指定密钥加密类型</li>
</ul>
</li>
<li>命令会在 <code>~/.ssh/</code> 生成三个文件<ul>
<li><code>id_rsa</code><ul>
<li>私钥</li>
</ul>
</li>
<li><code>id_rsa.pub</code><ul>
<li>公钥</li>
</ul>
</li>
<li><code>known hosts</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>客户端把公钥发送给服务端<ol>
<li><code>ssh-copy-id -i 公钥路径 目标IP</code></li>
<li>手动上传</li>
</ol>
</li>
<li>服务端将公钥存在 <code>~/.ssh/authorized_keys</code> 权限 <code>600</code></li>
</ol>
<h2 id="2-3-配置文件"><a href="#2-3-配置文件" class="headerlink" title="2.3 配置文件"></a>2.3 配置文件</h2><ol>
<li><code>/etc/ssh/ssh_config</code>（客户端配置文件）</li>
<li><code>/etc/ssh/sshd_config</code>（服务端配置文件）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 17 #Port 22 # 配置端口 默认22</span><br><span class="line"> 19 #ListenAddress 0.0.0.0 # 指定的网卡才能够接收远程访问请求，默认所有网卡都可以接收</span><br><span class="line"></span><br><span class="line"> 22 HostKey /etc/ssh/ssh_host_rsa_key # 私钥位置</span><br><span class="line"> 23 #HostKey /etc/ssh/ssh_host_dsa_key</span><br><span class="line"> 24 HostKey /etc/ssh/ssh_host_ecdsa_key</span><br><span class="line"> 25 HostKey /etc/ssh/ssh_host_ed25519_key</span><br><span class="line"></span><br><span class="line"> 32 SyslogFacility AUTHPRIV # 日志记录ssh登录信息</span><br><span class="line"> 33 #LogLevel INFO # 日志等级</span><br><span class="line"></span><br><span class="line"> 38 #PermitRootLogin yes # 是否允许root远程连接</span><br><span class="line"> 43 #PubkeyAuthentication yes # 是否开启公钥验证</span><br><span class="line"> 47 AuthorizedKeysFile  .ssh/authorized_keys # 公钥位置</span><br><span class="line"> 65 PasswordAuthentication yes # 是否允许基于密码远程连接</span><br><span class="line"> 64 #PermitEmptyPasswords no  # 是否允许空密码用户远程连接</span><br><span class="line"> 79 GSSAPIAuthentication yes # GSSAPI认证是否开启（关闭）</span><br><span class="line">116 #UseDNS yes # 是否开启反向DNS解析功能（关闭）</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="2-4-SSH-相关命令"><a href="#2-4-SSH-相关命令" class="headerlink" title="2.4 SSH 相关命令"></a>2.4 SSH 相关命令</h2><ol>
<li><code>ssh [-p port] [USER@]remote</code><ul>
<li>连接</li>
</ul>
</li>
<li><code>ssh-keygen</code><ul>
<li>用于生成密钥对</li>
</ul>
</li>
<li><code>ssh-copy-id</code><ul>
<li>用于复制公钥到服务器</li>
</ul>
</li>
</ol>
<h1 id="三-网络服务（network）"><a href="#三-网络服务（network）" class="headerlink" title="三 网络服务（network）"></a>三 网络服务（network）</h1>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 系统管理</title>
    <url>/anyeansan.github.io/2020/03/29/Linux-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="一-Systemd"><a href="#一-Systemd" class="headerlink" title="一 Systemd"></a>一 Systemd</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ol>
<li>Systemd 是一系列工具的集合，用于取代System V初始进程</li>
<li>Systemd 可以管理所有系统资源，不同的资源统称为 Unit（单位）</li>
<li>Systemd 取代 init 成为系统中 PID 值为 1 的进程</li>
</ol>
<h2 id="1-2-命令"><a href="#1-2-命令" class="headerlink" title="1.2 命令"></a>1.2 命令</h2><h3 id="1-systemctl"><a href="#1-systemctl" class="headerlink" title="1 systemctl"></a>1 systemctl</h3><ul>
<li>Systemd 的主命令，用于管理系统</li>
</ul>
<h3 id="2-systemd-analyze"><a href="#2-systemd-analyze" class="headerlink" title="2 systemd-analyze"></a>2 systemd-analyze</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>systemd-analyze</code></td>
<td>查看启动耗时</td>
</tr>
<tr>
<td><code>systemd-analyze blame</code></td>
<td>查看每个服务的启动耗时</td>
</tr>
</tbody></table>
<h3 id="3-hostnamectl"><a href="#3-hostnamectl" class="headerlink" title="3 hostnamectl"></a>3 hostnamectl</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>hostnamectl</code></td>
<td>显示当前主机的信息</td>
</tr>
<tr>
<td><code>hostnamectl set-hostname xxx</code></td>
<td>设置主机名</td>
</tr>
</tbody></table>
<h3 id="4-localectl"><a href="#4-localectl" class="headerlink" title="4 localectl"></a>4 localectl</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>localectl</code></td>
<td>查看本地化设置</td>
</tr>
<tr>
<td><code>localectl set-locale en_US.UTF-8</code></td>
<td>设置字符集</td>
</tr>
<tr>
<td><code>localectl set-keymap us</code></td>
<td>设置键盘映射</td>
</tr>
<tr>
<td><code>localectl set-layout us</code></td>
<td>设置 x11 布局</td>
</tr>
</tbody></table>
<h3 id="5-timedatectl"><a href="#5-timedatectl" class="headerlink" title="5 timedatectl"></a>5 timedatectl</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>timedatectl</code></td>
<td>查看时间及时区信息</td>
</tr>
<tr>
<td><code>timedatectl list-timezones</code></td>
<td>显示所有可用的时区</td>
</tr>
<tr>
<td><code>timedatectl set-timezone Asia/Shanghai</code></td>
<td>设置时区</td>
</tr>
</tbody></table>
<h3 id="6-loginctl"><a href="#6-loginctl" class="headerlink" title="6 loginctl"></a>6 loginctl</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>loginctl list-sessions</code></td>
<td>显示当前所有连接会话</td>
</tr>
<tr>
<td><code>loginctl list-users</code></td>
<td>列出当前所有登录用户</td>
</tr>
<tr>
<td><code>loginctl show-user root</code></td>
<td>显示指定用户的信息</td>
</tr>
</tbody></table>
<h3 id="7-journalctl"><a href="#7-journalctl" class="headerlink" title="7 journalctl"></a>7 journalctl</h3><ol>
<li>管理所有 Unit 的启动日志</li>
<li>日志的配置文件是 <code>/etc/systemd/journald.conf</code></li>
</ol>
<h2 id="1-3-Unit"><a href="#1-3-Unit" class="headerlink" title="1.3 Unit"></a>1.3 Unit</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ul>
<li>Unit 是 Systemd 管理系统资源的基本单元，可以认为每个系统资源就是一个 Unit</li>
</ul>
<ol start="2">
<li>每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit </li>
<li>Systemd 默认从目录 <code>/etc/systemd/system/</code> 读取配置文件。但里面存放的大部分文件都是符号链接，指向目录 <code>/usr/lib/systemd/system/</code>，真正的配置文件存放在那个目录</li>
</ol>
<h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2 分类"></a>2 分类</h3><p>类型|扩展名|说明<br>-|-<br><code>Service unit</code>|<code>.service</code>|系统服务<br><code>Target  unit</code>|<code>.target</code>|对 Unit 文件进行逻辑分组，多个 Unit 构成的一个 Target<br><code>Device unit</code>|<code>.device</code>|硬件设备<br><code>Mount unit</code>|<code>.mount</code>|文件系统挂载点，可代替<code>/etc/fstab</code><br><code>Automount  unit</code>|<code>.automount</code>|自动挂载点<br><code>Socket unit</code>|<code>.socket</code>|进程间通信的socket<br><code>Path unit</code>|<code>.path</code>|文件或路径<br><code>Scope unit</code>|<code>.scope</code>|不是由Systemd启动的外部进程<br><code>Slice unit</code>|<code>.slice</code>|进程组<br><code>Snapshot unit</code>|<code>.snapshot</code>|Systemd快照，可以切回某个快照<br><code>Swap unit</code>|<code>.swap</code>|swap 文件<br><code>Timer unit</code>|<code>.timer</code>|定时器</p>
<h3 id="3-Unit-状态"><a href="#3-Unit-状态" class="headerlink" title="3 Unit 状态"></a>3 Unit 状态</h3><h4 id="1-Loaded（下次开机启动状态）"><a href="#1-Loaded（下次开机启动状态）" class="headerlink" title="1 Loaded（下次开机启动状态）"></a>1 Loaded（下次开机启动状态）</h4><table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>enabled</code></td>
<td>开机启动</td>
</tr>
<tr>
<td><code>disabled</code></td>
<td>开机不启动</td>
</tr>
<tr>
<td><code>static</code></td>
<td>不能自己启动，但有可能作为依赖被其它 <code>enabled</code> 服务启动</td>
</tr>
<tr>
<td><code>mask</code></td>
<td>禁止启动</td>
</tr>
</tbody></table>
<h4 id="2-Active（当前状态）"><a href="#2-Active（当前状态）" class="headerlink" title="2 Active（当前状态）"></a>2 Active（当前状态）</h4><table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>active（running）</code></td>
<td>持续运行</td>
</tr>
<tr>
<td><code>active（exited）</code></td>
<td>仅执行一次就正常结束的服务</td>
</tr>
<tr>
<td><code>active（waiting）</code></td>
<td>运行中，但要等待其它事件</td>
</tr>
<tr>
<td><code>inactive</code></td>
<td>没有运行</td>
</tr>
</tbody></table>
<h3 id="4-Unit-管理"><a href="#4-Unit-管理" class="headerlink" title="4 Unit 管理"></a>4 Unit 管理</h3><h4 id="1-查"><a href="#1-查" class="headerlink" title="1 查"></a>1 查</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>systemctl list-units</code></td>
<td>显示所有正在运行的 Unit</td>
</tr>
<tr>
<td><code>systemctl list-units --all</code></td>
<td>显示所有Unit，包括没有找到配置文件的或者启动失败的</td>
</tr>
<tr>
<td><code>systemctl list-units --all --state=inactive</code></td>
<td>显示所有没有运行的 Unit</td>
</tr>
<tr>
<td><code>systemctl list-units --failed</code></td>
<td>显示所有加载失败的 Unit</td>
</tr>
<tr>
<td><code>systemctl list-units --type=service</code></td>
<td>显示所有正在运行的、类型为 service 的 Unit</td>
</tr>
<tr>
<td><code>systemctl list-unit-files</code></td>
<td>显示所有配置文件</td>
</tr>
<tr>
<td><code>systemctl list-unit-files --type=service</code></td>
<td>显示指定类型的配置文件</td>
</tr>
</tbody></table>
<h4 id="2-依赖关系"><a href="#2-依赖关系" class="headerlink" title="2 依赖关系"></a>2 依赖关系</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>systemctl list-dependencies name.service</code></td>
<td>显示某个 Unit 的所有依赖</td>
</tr>
<tr>
<td><code>systemctl list-dependencies -all name.service</code></td>
<td>展开显示某个 Unit 的所有依赖</td>
</tr>
</tbody></table>
<h4 id="3-常用操作（以-service-为例）"><a href="#3-常用操作（以-service-为例）" class="headerlink" title="3 常用操作（以 service 为例）"></a>3 常用操作（以 service 为例）</h4><table>
<thead>
<tr>
<th>操作\版本</th>
<th>CentOS 7</th>
<th>CentOS 6</th>
</tr>
</thead>
<tbody><tr>
<td>启动服务</td>
<td><code>systemctl start name.service</code></td>
<td><code>service name start</code></td>
</tr>
<tr>
<td>关闭服务</td>
<td><code>systemctl stop name.service</code></td>
<td><code>service name stop</code></td>
</tr>
<tr>
<td>重启服务</td>
<td><code>systemctl restart name.service</code></td>
<td><code>service name restart</code></td>
</tr>
<tr>
<td>查看服务状态</td>
<td><code>systemctl status name.service</code></td>
<td><code>service name status</code></td>
</tr>
<tr>
<td>开机启动</td>
<td><code>systemctl enable name.service</code></td>
<td><code>chkconfig name on</code></td>
</tr>
<tr>
<td>开机不启动</td>
<td><code>systemctl disable name.service</code></td>
<td><code>chkconfig name off</code></td>
</tr>
<tr>
<td>是否启动</td>
<td><code>systemctl is-active name.service</code></td>
<td></td>
</tr>
<tr>
<td>是否开机启动</td>
<td><code>systemctl is-enabled name.service</code></td>
<td></td>
</tr>
<tr>
<td>重载某个配置文件</td>
<td><code>systemctl reload name.service</code></td>
<td></td>
</tr>
<tr>
<td>重载所有修改过的配置文件</td>
<td><code>systemctl daemon-reload</code></td>
<td></td>
</tr>
<tr>
<td>杀死服务所有子进程</td>
<td><code>systemctl kill name.service</code></td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-4-Target"><a href="#1-4-Target" class="headerlink" title="1.4 Target"></a>1.4 Target</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>启动系统时，需要启动大量的 Unit，非常不方便</li>
<li>Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit</li>
<li>System V 启动模式的 Runlevel 与 Target 作用类似，不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动</li>
</ol>
<h3 id="2-运行级别-amp-Target"><a href="#2-运行级别-amp-Target" class="headerlink" title="2 运行级别 &amp; Target"></a>2 运行级别 &amp; Target</h3><p>CentOS 6|CentOS 7| 说明<br>—|—<br><code>Runlevel 0</code> | <code>runlevel0.target  -&gt;  poweroff.target</code>|关机模式，系统默认运行级别不能设置为0，否则不能正常启动<br><code>Runlevel 1</code> | <code>runlevel1.target  -&gt;  rescue.target</code>|单用户模式，root权限，用于系统维护，修改root密码等等，禁止远程登陆<br><code>Runlevel 2</code> |<code>runlevel2.target  -&gt;  multi-user.target</code>|多用户模式（没有NFS），没有网络<br><code>Runlevel 3</code> |<code>runlevel3.target  -&gt;  multi-user.target</code>|完全的多用户模式(有NFS)，登陆后进入控制台命令行模式<br><code>Runlevel 4</code> |<code>runlevel4.target  -&gt;  multi-user.target</code>|系统未使用，保留<br><code>Runlevel 5</code> |<code>runlevel5.target  -&gt;  graphical.target</code>|X11控制台，登陆后进入图形GUI模式<br><code>Runlevel 6</code> |<code>runlevel6.target  -&gt;  reboot.target</code>|重启模式，默认运行级别不能设为6，否则不能正常启动<br><code>emergency</code>|<code>emergency.target</code>|急救模式</p>
<h3 id="3-查看-修改默认运行级别"><a href="#3-查看-修改默认运行级别" class="headerlink" title="3 查看/修改默认运行级别"></a>3 查看/修改默认运行级别</h3><table>
<thead>
<tr>
<th>操作/版本</th>
<th>CentOS 6</th>
<th>CentOS 7</th>
</tr>
</thead>
<tbody><tr>
<td>查看</td>
<td><code>runlevel</code></td>
<td><code>systemctl get-default</code></td>
</tr>
<tr>
<td>修改</td>
<td><code>/etc/inittab</code></td>
<td><code>systemctl set-default name.target</code></td>
</tr>
</tbody></table>
<h3 id="4-切换运行级别"><a href="#4-切换运行级别" class="headerlink" title="4 切换运行级别"></a>4 切换运行级别</h3><table>
<thead>
<tr>
<th>CentOS 6</th>
<th>CentOS 7</th>
</tr>
</thead>
<tbody><tr>
<td><code>init 0</code></td>
<td><code>systemctl poweroff</code></td>
</tr>
<tr>
<td><code>init 1</code></td>
<td><code>systemctl  isolate rescue.target</code></td>
</tr>
<tr>
<td><code>init 2/3/4</code></td>
<td><code>systemctl  isolate  multi-user.target</code></td>
</tr>
<tr>
<td><code>init 5</code></td>
<td><code>systemctl  isolate graphical.target</code></td>
</tr>
<tr>
<td><code>init 6</code></td>
<td><code>systemctl  reboot</code></td>
</tr>
<tr>
<td>* <code>isolate</code></td>
<td></td>
</tr>
<tr>
<td>1. 切换 Target 时，默认不关闭前一个 Target 启动的进程</td>
<td></td>
</tr>
<tr>
<td>2. 加上 <code>isolate</code> 会关闭前一个 Target 里面所有不属于后一个 Target 的进程</td>
<td></td>
</tr>
</tbody></table>
<h1 id="二-启动流程"><a href="#二-启动流程" class="headerlink" title="二 启动流程"></a>二 启动流程</h1><h2 id="2-1-CentOS-6-启动流程"><a href="#2-1-CentOS-6-启动流程" class="headerlink" title="2.1 CentOS 6 启动流程"></a>2.1 CentOS 6 启动流程</h2><p>![](<a href="https://gitee.com/3noanswer/npics/raw/master/Linux/CentOS6" target="_blank" rel="noopener">https://gitee.com/3noanswer/npics/raw/master/Linux/CentOS6</a> 启动流程.png)</p>
<h3 id="1-POST（Power-On-Self-Test）"><a href="#1-POST（Power-On-Self-Test）" class="headerlink" title="1 POST（Power-On-Self-Test）"></a>1 POST（Power-On-Self-Test）</h3><ol>
<li>加电自检，是BIOS功能的一个主要部分，负责完成硬件情况的检测</li>
<li>自检后根据设置获取第一个开机引导设备，如：光驱，硬盘，网络，USB</li>
</ol>
<ul>
<li>BIOS（Basic Input Output System）<ul>
<li>它是一组固化到计算机主板一个ROM芯片上的程序，它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序，它可从CMOS中读写系统设置的具体信息。 其主要功能是为计算机提供最底层的、最直接的硬件设置和控制</li>
</ul>
</li>
</ul>
<h3 id="2-MBR（Master-Boot-Record）"><a href="#2-MBR（Master-Boot-Record）" class="headerlink" title="2 MBR（Master Boot Record）"></a>2 MBR（Master Boot Record）</h3><ul>
<li>主引导记录，存储于磁盘的 0 柱面 0 磁道 1 扇区，大小为 512 byte<ol>
<li><code>446 byte</code><ul>
<li>BootLoader（GRUB）</li>
</ul>
</li>
<li><code>64 byte</code><ul>
<li>分区表</li>
</ul>
</li>
<li><code>2 byte</code><ul>
<li>55AA（用于MBR的有效性检查）</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="3-GRUB（GRand-Unified-Bootloader）"><a href="#3-GRUB（GRand-Unified-Bootloader）" class="headerlink" title="3 GRUB（GRand Unified Bootloader）"></a>3 GRUB（GRand Unified Bootloader）</h3><ol>
<li>是一个来自GNU项目的多操作系统启动程序，分为两个阶段<ol>
<li>第一阶段，MBR的前446 byte</li>
<li>1.5 阶段</li>
<li>第二阶段 <code>/boot/grub</code></li>
</ol>
</li>
<li><code>BootLoader</code><ul>
<li>提供菜单，允许用户选择不同的内核版本，然后将内核装载到内存的特定空间中，解压，展开，并把系统控制权移交给内核</li>
</ul>
</li>
</ol>
<h3 id="4-加载内核（Kernel）"><a href="#4-加载内核（Kernel）" class="headerlink" title="4 加载内核（Kernel）"></a>4 加载内核（Kernel）</h3><ul>
<li>Kernel 会开始侦测硬件并加载驱动程序</li>
</ul>
<h3 id="5-启动系统第一个进程-init"><a href="#5-启动系统第一个进程-init" class="headerlink" title="5 启动系统第一个进程 init"></a>5 启动系统第一个进程 init</h3><ul>
<li>init 进程控制后续各种服务的启动，init 是按照配置顺序启动服务（串行）<ul>
<li><code># chkconfig: 2345 10 90</code><ul>
<li>表示此服务可以在 Runlevel 2345 下启动，启动顺序为 10，关闭顺序为 90</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-获取系统运行级别"><a href="#6-获取系统运行级别" class="headerlink" title="6 获取系统运行级别"></a>6 获取系统运行级别</h3><ul>
<li>init 读取<code>/etc/inittab</code>配置文件， 获取系统默认运行级别</li>
</ul>
<h3 id="7-系统初始化"><a href="#7-系统初始化" class="headerlink" title="7 系统初始化"></a>7 系统初始化</h3><ul>
<li>init 执行 <code>/etc/rc.d/rc.sysinit</code> 脚本来进行系统初始化，准备软件执行的作业环境 (如网络、时区等)</li>
</ul>
<h3 id="8-启动服务"><a href="#8-启动服务" class="headerlink" title="8 启动服务"></a>8 启动服务</h3><ul>
<li>init 执行系统运行级别对应的脚本，如 <code>/etc/rc.d/rc3.d</code>，及 <code>/etc/rc3.d/*</code> 下所有脚本</li>
</ul>
<h3 id="9-开机自启动程序"><a href="#9-开机自启动程序" class="headerlink" title="9 开机自启动程序"></a>9 开机自启动程序</h3><ul>
<li>init 执行 <code>/etc/rc.d/rc.local</code> 脚本</li>
</ul>
<h3 id="10-登录界面"><a href="#10-登录界面" class="headerlink" title="10 登录界面"></a>10 登录界面</h3><ul>
<li>运行 mingetty 进程，进入登录界面</li>
</ul>
<h2 id="2-2-CentOS-7-启动流程"><a href="#2-2-CentOS-7-启动流程" class="headerlink" title="2.2 CentOS 7 启动流程"></a>2.2 CentOS 7 启动流程</h2><p>![](<a href="https://gitee.com/3noanswer/npics/raw/master/Linux/CentOS7" target="_blank" rel="noopener">https://gitee.com/3noanswer/npics/raw/master/Linux/CentOS7</a> 启动流程.png)</p>
<h1 id="三-进程"><a href="#三-进程" class="headerlink" title="三 进程"></a>三 进程</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ul>
<li>进程是已启动的可执行程序的运行实例，有以下组成部分：<ol>
<li>已分配内存的地址空间；</li>
<li>安全属性，包括所有权凭据和特权；</li>
<li>程序代码的一个或多个执行线程；</li>
<li>进程状态</li>
</ol>
</li>
</ul>
<h2 id="3-2-守护进程（Daemon）"><a href="#3-2-守护进程（Daemon）" class="headerlink" title="3.2 守护进程（Daemon）"></a>3.2 守护进程（Daemon）</h2><ol>
<li>Linux服务器的主要任务就是为本地或远程用户提供各种服务</li>
<li>Linux系统上提供服务的程序通常是守护进程</li>
<li>守护进程一直在系统后台运行，时刻地监听用户的服务请求，一旦用户发出了服务请求，守护进程便为它们提供服务</li>
</ol>
<h2 id="3-3-系统初始化进程"><a href="#3-3-系统初始化进程" class="headerlink" title="3.3 系统初始化进程"></a>3.3 系统初始化进程</h2><ol>
<li>系统初始化进程是一个特殊的的守护进程，其PID为1</li>
<li>是其他守护进程的父进程或者祖先进程，系统上所有的守护进程都是由系统初始化进程进行管理的（如启动、停止等）</li>
<li>在Linux的发展历史过程中，使用过3种初始化进程<ol>
<li><code>init</code></li>
<li><code>upstart</code></li>
<li><code>systemd</code></li>
</ol>
</li>
</ol>
<h2 id="3-4-进程状态"><a href="#3-4-进程状态" class="headerlink" title="3.4 进程状态"></a>3.4 进程状态</h2><table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>R（运行）</code></td>
<td>进程正在运行或在运行队列中等待</td>
</tr>
<tr>
<td><code>S（休眠）</code></td>
<td>可中断睡眠状态，可以被唤醒</td>
</tr>
<tr>
<td><code>D（不可中断）</code></td>
<td>不可中断睡眠状态，通常用于 I/O 情况</td>
</tr>
<tr>
<td><code>Z（僵死）</code></td>
<td>子进程退出，父进程还在运行，但是父进程没有读到子进程的退出状态，子进程进入僵死状态</td>
</tr>
<tr>
<td><code>T（暂停）</code></td>
<td>进程收到停止信号SIGSTOP后停止运行，可以发送SIGCONT信号让进程继续运行</td>
</tr>
<tr>
<td><code>X（死亡）</code></td>
<td>该状态是返回状态，在任务列表中看不到</td>
</tr>
<tr>
<td><code>t（追踪）</code></td>
<td>当利用gdb调试某个程序，程序停留在某个断点处时，就处于跟踪状态</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>状态组合符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>s</code></td>
<td>表示进程是控制进程</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>表示进程运行在高优先级上</td>
</tr>
<tr>
<td><code>N</code></td>
<td>表示进程运行在低优先级上</td>
</tr>
<tr>
<td><code>L</code></td>
<td>表示进程有页面锁定在内存中</td>
</tr>
<tr>
<td><code>l</code></td>
<td>表示进程是多线程的</td>
</tr>
<tr>
<td><code>+</code></td>
<td>表示进程运行在前台</td>
</tr>
</tbody></table>
<h2 id="3-5-查看进程"><a href="#3-5-查看进程" class="headerlink" title="3.5 查看进程"></a>3.5 查看进程</h2><h3 id="1-ps"><a href="#1-ps" class="headerlink" title="1 ps"></a>1 ps</h3><h4 id="1-ps-aux"><a href="#1-ps-aux" class="headerlink" title="1 ps -aux"></a>1 ps -aux</h4><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>user</code></td>
<td>启动进程的用户</td>
</tr>
<tr>
<td><code>PID</code></td>
<td>进程ID</td>
</tr>
<tr>
<td><code>%CPU</code></td>
<td>进程占用cpu百分比</td>
</tr>
<tr>
<td><code>%MEM</code></td>
<td>进程占用内存百分比</td>
</tr>
<tr>
<td><code>VSZ</code></td>
<td>进程占用虚拟内存大小（KB）</td>
</tr>
<tr>
<td><code>RSS</code></td>
<td>进程占用物理内存大小（KB）</td>
</tr>
<tr>
<td><code>TTY</code></td>
<td>进程启动终端</td>
</tr>
<tr>
<td><code>STAT</code></td>
<td>进程状态</td>
</tr>
<tr>
<td><code>START</code></td>
<td>进程启动时间</td>
</tr>
<tr>
<td><code>TIME</code></td>
<td>进程执行起到现在总的CPU占用时间</td>
</tr>
<tr>
<td><code>COMMAND</code></td>
<td>启动进程的命令</td>
</tr>
</tbody></table>
<h4 id="2-ps-ef"><a href="#2-ps-ef" class="headerlink" title="2 ps -ef"></a>2 ps -ef</h4><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>UID</code></td>
<td>启动进程的用户</td>
</tr>
<tr>
<td><code>PID</code></td>
<td>进程 ID</td>
</tr>
<tr>
<td><code>PPID</code></td>
<td>父进程 ID</td>
</tr>
<tr>
<td><code>C</code></td>
<td>进程生命周期中的CPU利用率</td>
</tr>
<tr>
<td><code>STIME</code></td>
<td>进程启动时间</td>
</tr>
<tr>
<td><code>TTY</code></td>
<td>进程启动终端</td>
</tr>
<tr>
<td><code>TIME</code></td>
<td>进程执行起到现在总的CPU占用时间</td>
</tr>
<tr>
<td><code>CMD</code></td>
<td>启动进程的命令</td>
</tr>
<tr>
<td>* <code>TTY</code></td>
<td></td>
</tr>
<tr>
<td>1. <code>?</code></td>
<td></td>
</tr>
<tr>
<td>* 表示与终端无关，这种进程一般是内核态进程</td>
<td></td>
</tr>
<tr>
<td>2. <code>tty1~7</code></td>
<td></td>
</tr>
<tr>
<td>* 本地终端</td>
<td></td>
</tr>
<tr>
<td>3. <code>pts/0+</code></td>
<td></td>
</tr>
<tr>
<td>* 远程终端</td>
<td></td>
</tr>
</tbody></table>
<h4 id="3-ps-le"><a href="#3-ps-le" class="headerlink" title="3 ps -le"></a>3 ps -le</h4><ul>
<li>信息更详细</li>
</ul>
<h3 id="2-pstree"><a href="#2-pstree" class="headerlink" title="2 pstree"></a>2 pstree</h3><ul>
<li><code>pstree [OPTION] [PID | USER]</code><ul>
<li>以树形结构显示程序和进程之间的关系</li>
<li><code>OPTION</code><ul>
<li><code>-a</code><ul>
<li>显示启动每个进程对应的完整指令，包括启动进程的路径、参数等</li>
</ul>
</li>
<li><code>-c</code><ul>
<li>不使用精简法显示进程信息，即显示的进程中包含子进程和父进程</li>
</ul>
</li>
<li><code>-n</code><ul>
<li>根据进程 PID 号来排序输出，默认是以程序名排序输出的</li>
</ul>
</li>
<li><code>-p</code><ul>
<li>显示进程的 PID</li>
</ul>
</li>
<li><code>-u</code><ul>
<li>显示进程对应的用户名称</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-lsof（list-opened-files）"><a href="#3-lsof（list-opened-files）" class="headerlink" title="3 lsof（list opened files）"></a>3 lsof（list opened files）</h3><ul>
<li><code>lsof [OPTION]</code><ul>
<li>列出进程调用或打开的文件的信息</li>
<li><code>OPTION</code><ul>
<li><code>-u 用户名</code><ul>
<li>列出某个用户的进程打开的文件</li>
</ul>
</li>
<li><code>-p pid</code><ul>
<li>列出指定进程号所打开的文件</li>
</ul>
</li>
<li><code>-c 字符串</code><ul>
<li>列出以字符串开头的进程打开的文件</li>
</ul>
</li>
<li><code>-i 条件</code><ul>
<li>列出符合条件的进程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-6-监听进程"><a href="#3-6-监听进程" class="headerlink" title="3.6 监听进程"></a>3.6 监听进程</h2><h3 id="1-top"><a href="#1-top" class="headerlink" title="1 top"></a>1 top</h3><ul>
<li><code>top [OPTION]</code><ul>
<li><code>OPTION</code><ul>
<li><code>-d 秒数</code><ul>
<li>指定每隔几秒刷新，默认3秒</li>
</ul>
</li>
<li><code>-n 次数</code><ul>
<li>指定 top 抿了执行次数</li>
</ul>
</li>
<li><code>-b</code><ul>
<li>使用批处理模式输出。</li>
<li>一般和 <code>-n</code> 选项合用，用于把 top 命令重定向到文件中</li>
</ul>
</li>
<li><code>-p PID</code><ul>
<li>仅查看的进程</li>
</ul>
</li>
<li><code>-u USER</code><ul>
<li>只监听某个用户的进程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-top-输出窗口交互命令"><a href="#2-top-输出窗口交互命令" class="headerlink" title="2 top 输出窗口交互命令"></a>2 top 输出窗口交互命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>?, h</code></td>
<td>显示交互模式的帮助</td>
</tr>
<tr>
<td><code>空格</code></td>
<td>默认 3s 刷新一次，按空格立即刷新</td>
</tr>
<tr>
<td><code>P</code></td>
<td>按照 CPU 的使用率排序（默认）</td>
</tr>
<tr>
<td><code>M</code></td>
<td>按照内存的使用率排序</td>
</tr>
<tr>
<td><code>N</code></td>
<td>按照 PID 排序</td>
</tr>
<tr>
<td><code>T</code></td>
<td>按照 CPU 的累积运算时间排序，即按照 <code>TIME+</code> 项排序</td>
</tr>
<tr>
<td><code>q</code></td>
<td>退出 top 命令</td>
</tr>
</tbody></table>
<h3 id="3-top-输出信息"><a href="#3-top-输出信息" class="headerlink" title="3 top 输出信息"></a>3 top 输出信息</h3><h4 id="第一行（任务队列信息）"><a href="#第一行（任务队列信息）" class="headerlink" title="第一行（任务队列信息）"></a>第一行（任务队列信息）</h4><ul>
<li><code>系统当前时间，系统运行时间，登录用户数，CPU负载</code></li>
</ul>
<h4 id="第二行（进程信息）"><a href="#第二行（进程信息）" class="headerlink" title="第二行（进程信息）"></a>第二行（进程信息）</h4><ul>
<li><code>系统进程总数，运行进程数，睡眠进程数，停止进程数，僵尸进程数</code></li>
</ul>
<h4 id="第三行（CPU-信息）"><a href="#第三行（CPU-信息）" class="headerlink" title="第三行（CPU 信息）"></a>第三行（CPU 信息）</h4><table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>us</code></td>
<td>用户模式占用的 CPU 百分比</td>
</tr>
<tr>
<td><code>sy</code></td>
<td>系统模式占用的 CPU 百分比</td>
</tr>
<tr>
<td><code>ni</code></td>
<td>改变过优先级的用户进程占用的 CPU 百分比</td>
</tr>
<tr>
<td><code>id</code></td>
<td>空闲 CPU 占用的 CPU 百分比</td>
</tr>
<tr>
<td><code>wa</code></td>
<td>等待输入/输出的进程占用的 CPU 百分比</td>
</tr>
<tr>
<td><code>hi</code></td>
<td>硬中断请求服务占用的 CPU 百分比</td>
</tr>
<tr>
<td><code>si</code></td>
<td>软中断请求服务占用的 CPU 百分比</td>
</tr>
<tr>
<td><code>st</code></td>
<td>虚拟时间百分比，就是当有虚拟机时，虚拟 CPU 等待实际 CPU 的时间百分比</td>
</tr>
</tbody></table>
<h4 id="第四行（物理内存信息-Mem）"><a href="#第四行（物理内存信息-Mem）" class="headerlink" title="第四行（物理内存信息 Mem）"></a>第四行（物理内存信息 Mem）</h4><table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>total</code></td>
<td>物理内存的总量</td>
</tr>
<tr>
<td><code>free</code></td>
<td>空闲的物理内存数量</td>
</tr>
<tr>
<td><code>used</code></td>
<td>己经使用的物理内存数量</td>
</tr>
<tr>
<td><code>buff/cache</code></td>
<td>作为缓冲/缓存的内存数量</td>
</tr>
</tbody></table>
<h4 id="第五行（交互分区信息-Swap）"><a href="#第五行（交互分区信息-Swap）" class="headerlink" title="第五行（交互分区信息 Swap）"></a>第五行（交互分区信息 Swap）</h4><table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>total</code></td>
<td>交换分区（虚拟内存）的总大小</td>
</tr>
<tr>
<td><code>free</code></td>
<td>空闲交换分区的大小</td>
</tr>
<tr>
<td><code>used</code></td>
<td>已经使用的交换分区的大小</td>
</tr>
<tr>
<td><code>avail Mem</code></td>
<td>总的可利用内存是多少</td>
</tr>
</tbody></table>
<h4 id="剩余部分（进程信息）"><a href="#剩余部分（进程信息）" class="headerlink" title="剩余部分（进程信息）"></a>剩余部分（进程信息）</h4><table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>PID</code></td>
<td>进程的 ID</td>
</tr>
<tr>
<td><code>USER</code></td>
<td>进程所属的用户</td>
</tr>
<tr>
<td><code>PR</code></td>
<td>优先级，数值越小优先级越高（由内核动态调整，用户不能修改）</td>
</tr>
<tr>
<td><code>NI</code></td>
<td>优先级，数值越小优先级越高（用户可以自己调整）</td>
</tr>
<tr>
<td><code>VIRT</code></td>
<td>进程使用的虚拟内存的大小，单位为 KB</td>
</tr>
<tr>
<td><code>RES</code></td>
<td>进程使用的物理内存的大小，单位为 KB</td>
</tr>
<tr>
<td><code>SHR</code></td>
<td>共享内存大小，单位为 KB</td>
</tr>
<tr>
<td><code>S</code></td>
<td>进程状态</td>
</tr>
<tr>
<td><code>%CPU</code></td>
<td>进程占用 CPU 的百分比</td>
</tr>
<tr>
<td><code>%MEM</code></td>
<td>进程占用内存的百分比</td>
</tr>
<tr>
<td><code>TIME+</code></td>
<td>进程执行起到现在总的CPU占用时间</td>
</tr>
<tr>
<td><code>COMMAND</code></td>
<td>启动进程的命令</td>
</tr>
</tbody></table>
<h2 id="3-6-结束进程"><a href="#3-6-结束进程" class="headerlink" title="3.6 结束进程"></a>3.6 结束进程</h2><h3 id="1-kill"><a href="#1-kill" class="headerlink" title="1 kill"></a>1 kill</h3><h4 id="1-原理"><a href="#1-原理" class="headerlink" title="1 原理"></a>1 原理</h4><ul>
<li>kill 命令会向操作系统内核发送一个信号和目标进程的 PID，然后系统内核根据收到的信号类型，对指定进程进行相应的操作</li>
</ul>
<h4 id="2-语法"><a href="#2-语法" class="headerlink" title="2 语法"></a>2 语法</h4><ol>
<li><code>kill -l</code><ul>
<li>查看所有信号信息</li>
</ul>
</li>
<li><code>kill [信号编号] PID</code></li>
</ol>
<table>
<thead>
<tr>
<th>信号编号</th>
<th>信号名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>1</code></td>
<td><code>SIGHUP</code></td>
<td>重启进程</td>
</tr>
<tr>
<td><code>2</code></td>
<td><code>SIGINT</code></td>
<td>非强制性结束进程，<code>ctrl + c</code> 发出的是 <code>kill -2</code> 的信号</td>
</tr>
<tr>
<td><code>9</code></td>
<td><code>SIGKILL</code></td>
<td>强制结束进程</td>
</tr>
<tr>
<td><code>15</code></td>
<td><code>SIGTERM</code></td>
<td>正常结束进程，默认信号</td>
</tr>
<tr>
<td><code>19</code></td>
<td><code>SIGSTOP</code></td>
<td>挂起一个进程，<code>ctrl + z</code> 发出的是 <code>kill -19</code> 信号</td>
</tr>
</tbody></table>
<h3 id="2-killall"><a href="#2-killall" class="headerlink" title="2 killall"></a>2 killall</h3><ul>
<li><code>killall [OPTION] [信号编号] 进程名</code><ul>
<li><code>kill</code> 命令使用 PID 结束进程，而 <code>killall</code> 使用进程名称来结束进程</li>
<li><code>OPTION</code><ul>
<li><code>-i</code><ul>
<li>交互式，询问是否要杀死某个进程</li>
</ul>
</li>
<li><code>-I</code><ul>
<li>忽略进程名的大小写</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-pkill"><a href="#4-pkill" class="headerlink" title="4 pkill"></a>4 pkill</h3><ol>
<li><code>pkill [OPTION] [信号编号] 进程名</code><ul>
<li>用来结束进程时，用法与 <code>killall</code> 一致</li>
</ul>
</li>
<li><code>pkill [信号编号] -t 终端号</code><ul>
<li>按照终端号踢出登陆用户</li>
</ul>
</li>
</ol>
<h1 id="四-硬件信息"><a href="#四-硬件信息" class="headerlink" title="四 硬件信息"></a>四 硬件信息</h1><h2 id="4-1-CPU"><a href="#4-1-CPU" class="headerlink" title="4.1 CPU"></a>4.1 CPU</h2><h3 id="1-CPU-信息"><a href="#1-CPU-信息" class="headerlink" title="1 CPU 信息"></a>1 CPU 信息</h3><ol>
<li>cpu 路数<ul>
<li>cpu 的物理个数</li>
</ul>
</li>
<li>cpu 核数<ul>
<li>cpu 的逻辑个数</li>
</ul>
</li>
<li>core<ul>
<li>一个物理 cpu 的核心数</li>
</ul>
</li>
<li><code>核数 = 路数 * core</code></li>
</ol>
<h3 id="2-查看-CPU-信息"><a href="#2-查看-CPU-信息" class="headerlink" title="2 查看 CPU 信息"></a>2 查看 CPU 信息</h3><ol>
<li><code>/proc/cpuinfo</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 每一核cpu信息以空行分隔</span><br><span class="line">model name:     # cpu型号</span><br><span class="line">physical id:    # cpu路数，从0开始编号</span><br><span class="line">cpu cores:      # 一路cpu的核数</span><br><span class="line">processor:      # cpu核数，从0开始编号</span><br></pre></td></tr></table></figure></li>
<li><code>lscpu</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">model name:            # cpu型号</span><br><span class="line">Socket(s):             # cpu路数，从0开始编号</span><br><span class="line">Core(s) per socket:    # 一路cpu的核数</span><br><span class="line">CPU(s):                # cpu核数，从0开始编号</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="3-CPU-负载"><a href="#3-CPU-负载" class="headerlink" title="3 CPU 负载"></a>3 CPU 负载</h3><ol>
<li>负载简单说就是 cpu 的任务量，任务队列的平均长度</li>
<li>负载值 与 cpu 核数有关，负载不应该超过核的数量</li>
<li>负载信息<ul>
<li><code>1分钟平均负载 5分钟平均负载 15分钟平均负载</code></li>
</ul>
</li>
</ol>
<h3 id="4-查看-CPU-负载"><a href="#4-查看-CPU-负载" class="headerlink" title="4 查看 CPU 负载"></a>4 查看 CPU 负载</h3><ol>
<li><code>/proc/loadavg</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.00 0.01 0.05 1/104 1445</span><br></pre></td></tr></table></figure></li>
<li><code>uptime</code><ul>
<li>显示 cpu 负载信息 <code>当前时间 系统运行时间 登录用户数 系统负载</code></li>
</ul>
</li>
<li><code>w</code><ul>
<li>显示 cpu 负载 及 登录用户信息</li>
</ul>
</li>
</ol>
<h2 id="4-2-内存"><a href="#4-2-内存" class="headerlink" title="4.2 内存"></a>4.2 内存</h2><h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h3><ol>
<li>通常 <code>空闲内存 &gt; 可用内存</code>，因为有时缓冲或缓存会空出一些内存，但是无法使用，这部分内存算在空闲内存上而不算在可用内存上<ul>
<li>空闲内存：没有使用的内存</li>
<li>可用内存：没有使用的内存中可以使用的内存</li>
</ul>
</li>
</ol>
<h3 id="2-查看内存信息"><a href="#2-查看内存信息" class="headerlink" title="2 查看内存信息"></a>2 查看内存信息</h3><ol>
<li><code>/proc/meminfo</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MemTotal:         # 总内存</span><br><span class="line">MemFree:          # 空闲内存</span><br><span class="line">MemAvailable:     # 可用内存</span><br><span class="line">Buffers:          # 缓冲</span><br><span class="line">Cached:           # 缓存</span><br><span class="line">SwapCached:       # 交换分区使用情况</span><br></pre></td></tr></table></figure></li>
<li><code>free [OPTION]</code><ul>
<li>显示内存信息</li>
<li><code>OPTION</code><ul>
<li><code>-h</code>, <code>--human</code><ul>
<li>以人类可读的方式显示信息</li>
</ul>
</li>
<li><code>-b</code>, <code>--bytes</code><ul>
<li>以 byte 为单位显示</li>
</ul>
</li>
<li><code>-k</code>, <code>--kilo</code><ul>
<li>以 kb 为单位显示，默认</li>
</ul>
</li>
<li><code>-m</code>, <code>--mega</code><ul>
<li>以 mb 为单位显示</li>
</ul>
</li>
<li><code>-g</code>, <code>--giga</code><ul>
<li>以 gb 为单位显示</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="4-3-磁盘"><a href="#4-3-磁盘" class="headerlink" title="4.3 磁盘"></a>4.3 磁盘</h2><h3 id="1-proc-mounts"><a href="#1-proc-mounts" class="headerlink" title="1 /proc/mounts"></a>1 <code>/proc/mounts</code></h3><ul>
<li>磁盘挂载信息</li>
</ul>
<h3 id="2-df"><a href="#2-df" class="headerlink" title="2 df"></a>2 df</h3><ul>
<li><code>df [OPTION] [file]</code><ul>
<li>查看磁盘信息及挂载信息</li>
<li><code>option</code><ul>
<li><code>-h</code>, <code>--human</code><ul>
<li>以人类可读的方式显示信息</li>
</ul>
</li>
<li><code>-a</code>, <code>--all</code><ul>
<li>显示所有文件系统信息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="五-系统信息"><a href="#五-系统信息" class="headerlink" title="五 系统信息"></a>五 系统信息</h1><ol>
<li><code>/etc/reedat-release</code><ul>
<li>系统版本信息（简略）</li>
</ul>
</li>
<li><code>/etc/os-release</code><ul>
<li>系统版本信息（详细）</li>
</ul>
</li>
<li><code>uname -a</code><ul>
<li>查看系统与内核相关信息</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 目录结构</title>
    <url>/anyeansan.github.io/2020/03/29/Linux-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="一-FHS"><a href="#一-FHS" class="headerlink" title="一 FHS"></a>一 FHS</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ol>
<li><a href="http://www.pathname.com/fhs/" target="_blank" rel="noopener" title="官网">FHS</a></li>
<li><code>FileSystem Hierarchy Standard</code><ul>
<li>文件系统层次化标准，即目录结构规范</li>
</ul>
</li>
</ol>
<h2 id="1-2-两层规范"><a href="#1-2-两层规范" class="headerlink" title="1.2 两层规范"></a>1.2 两层规范</h2><ol>
<li><code>/</code> 目录下的各个目录应该放什么文件数据</li>
<li>针对 <code>/usr</code> 及 <code>/var</code> 这两个目录的子目录来定义</li>
</ol>
<h1 id="二-Linux目录结构"><a href="#二-Linux目录结构" class="headerlink" title="二 Linux目录结构"></a>二 Linux目录结构</h1><h2 id="2-1"><a href="#2-1" class="headerlink" title="2.1 /"></a>2.1 <code>/</code></h2><table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>/</code></td>
<td>根目录</td>
</tr>
<tr>
<td><code>/root</code></td>
<td>Home directory for the root user (optional)</td>
</tr>
<tr>
<td><code>/home</code></td>
<td>User home directories (optional)</td>
</tr>
<tr>
<td><code>/bin → /usr/bin</code></td>
<td>Essential command binaries</td>
</tr>
<tr>
<td><code>/sbin → /usr/sbin</code></td>
<td>Essential system binaries</td>
</tr>
<tr>
<td><code>/boot</code></td>
<td>Static files of the boot loader 是boot分区的挂载点</td>
</tr>
<tr>
<td><code>/dev</code></td>
<td>Device files</td>
</tr>
<tr>
<td><code>/etc</code></td>
<td>Host-specific system configuration</td>
</tr>
<tr>
<td><code>/media</code></td>
<td>Mount point for removeable media</td>
</tr>
<tr>
<td><code>/mnt</code></td>
<td>Mount point for mounting a filesystem temporarily</td>
</tr>
<tr>
<td><code>/tmp</code></td>
<td>Temporary files</td>
</tr>
<tr>
<td><code>/var</code></td>
<td>Variable data</td>
</tr>
<tr>
<td><code>/usr</code></td>
<td>Secondary hierarchy 系统软件和用户程序所在目录</td>
</tr>
<tr>
<td><code>/srv</code></td>
<td>Data for services provided by this system</td>
</tr>
<tr>
<td><code>/lib → /usr/lib</code></td>
<td>Essential shared libraries and kernel modules</td>
</tr>
<tr>
<td><code>/opt</code></td>
<td>Add-on application software packages</td>
</tr>
<tr>
<td><code>/proc</code></td>
<td>Kernel and process information virtual filesystem 目录中数据存在内存 重启丢失</td>
</tr>
<tr>
<td><code>/sys</code></td>
<td>虚拟文件系统，记录内核相关信息，不占磁盘空间</td>
</tr>
<tr>
<td><code>/run</code></td>
<td>正在运行的进程相关信息的文件</td>
</tr>
<tr>
<td><code>lost + found</code></td>
<td>磁盘、文件系统损坏 断电 临时存放文件</td>
</tr>
</tbody></table>
<h2 id="2-2-usr"><a href="#2-2-usr" class="headerlink" title="2.2 /usr"></a>2.2 <code>/usr</code></h2><ol>
<li>最初linux只有一个盘，此盘挂载在 <code>/</code> 目录</li>
<li>后来一个盘不够用，又加了一个盘，第二个盘挂载在<code>/usr</code>目录，并且规定：<ol>
<li>第一块盘用来存放系统程序相关</li>
<li>第二块盘用来存放用户自己程序相关。</li>
</ol>
</li>
<li><code>/</code> 和 <code>/usr</code> 目录结构完全相同</li>
</ol>
<table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>/usr/locl</code></td>
<td>源码编译安装软件的默认路径</td>
</tr>
<tr>
<td><code>/usr/src</code></td>
<td>存放源码的目录</td>
</tr>
<tr>
<td><code>/usr/share</code></td>
<td>帮助与说明文件，也可放置共享文件</td>
</tr>
</tbody></table>
<h2 id="2-3-var-log"><a href="#2-3-var-log" class="headerlink" title="2.3 /var/log"></a>2.3 <code>/var/log</code></h2><table>
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>/var/log/messages</code></td>
<td>记录系统或服务运行的状态信息 和 错误信息</td>
</tr>
<tr>
<td><code>/var/log/secure</code></td>
<td>记录用户登录信息</td>
</tr>
<tr>
<td><code>/var/log/dmesg</code></td>
<td>记录了系统在开机时内核自检的信息（硬件加载）</td>
</tr>
<tr>
<td><code>/var/log/cron</code></td>
<td>记录了系统定时任务信息</td>
</tr>
</tbody></table>
<h2 id="2-4-etc"><a href="#2-4-etc" class="headerlink" title="2.4 /etc"></a>2.4 <code>/etc</code></h2><table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>/etc/sysconfig/network-scripts/ifcfg-ens33</code></td>
<td>网卡配置文件</td>
</tr>
<tr>
<td><code>/etc/resolv.conf</code></td>
<td>DNS客户端配置文件</td>
</tr>
<tr>
<td><code>/etc/hosts</code></td>
<td>系统本地的DNS解析文件</td>
</tr>
<tr>
<td><code>/etc/hostname</code></td>
<td>主机名配置文件</td>
</tr>
<tr>
<td><code>/etc/fstab</code></td>
<td>开机设备自动挂载配置文件</td>
</tr>
<tr>
<td><code>/etc/rc.local -&gt; /etc/rc.d/rc.local</code></td>
<td>开启自启动程序配置文件</td>
</tr>
<tr>
<td><code>/etc/bashrc</code> <code>/etc/profile</code></td>
<td>系统环境变量、别名等配置文件</td>
</tr>
<tr>
<td><code>/etc/init.d</code></td>
<td>软件启动程序所在目录（CentOS 6）</td>
</tr>
<tr>
<td><code>/etc/ininttab</code></td>
<td>系统运行级别配置文件（CentOS 6）</td>
</tr>
<tr>
<td><code>/etc/profile.d</code></td>
<td>用户登录后执行的脚本所在目录</td>
</tr>
<tr>
<td><code>/etc/issue</code></td>
<td>本地终端登录前欢迎信息</td>
</tr>
<tr>
<td><code>/etc/issue.net</code></td>
<td>远程终端登录前欢迎信息</td>
</tr>
<tr>
<td><code>/etc/motd</code></td>
<td>本地及远程登陆后欢迎信息</td>
</tr>
<tr>
<td><code>/etc/sysctl.conf</code></td>
<td>Linux系统内核的配置和优化</td>
</tr>
<tr>
<td><code>/etc/os-release</code></td>
<td>系统版本信息</td>
</tr>
<tr>
<td><code>/etc/redhat-release</code></td>
<td>系统版本信息</td>
</tr>
<tr>
<td><code>/etc/passwd</code></td>
<td>账号信息</td>
</tr>
<tr>
<td><code>/etc/shadow</code></td>
<td>密码信息</td>
</tr>
<tr>
<td><code>/etc/group</code></td>
<td>组信息</td>
</tr>
<tr>
<td><code>/etc/gshadow</code></td>
<td>组密码信息</td>
</tr>
<tr>
<td><code>/etc/sudoers</code></td>
<td>sudo 命令配置文件（权限提升）</td>
</tr>
<tr>
<td><code>/etc/login.defs</code></td>
<td>所有用户登录时的默认配置</td>
</tr>
<tr>
<td><code>/etc/selinux</code></td>
<td>selinux及其配置文件</td>
</tr>
<tr>
<td><code>/etc/locale.conf</code></td>
<td>系统语言及字符编码，环境变量<code>LANG</code></td>
</tr>
<tr>
<td><code>/etc/logrotate.conf</code></td>
<td>日志分割配置文件</td>
</tr>
<tr>
<td>* <code>/etc/rc.local -&gt; /etc/rc.d/rc.local</code></td>
<td></td>
</tr>
<tr>
<td>1. 开启自启动程序命令的配置文件，开机自动加载此文件</td>
<td></td>
</tr>
<tr>
<td>2. CentOS 7 需要先为此文件添加执行权限</td>
<td></td>
</tr>
</tbody></table>
<h2 id="2-5-proc"><a href="#2-5-proc" class="headerlink" title="2.5 /proc"></a>2.5 <code>/proc</code></h2><table>
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>/proc/meminfo</code></td>
<td>内存信息</td>
</tr>
<tr>
<td><code>/proc/cpuinfo</code></td>
<td>cpu信息，每一核以空行隔开</td>
</tr>
<tr>
<td><code>/proc/loadavg</code></td>
<td>负载信息</td>
</tr>
<tr>
<td><code>/proc/mounts -&gt; /proc/self/mounts</code></td>
<td>挂载信息</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Shell</title>
    <url>/anyeansan.github.io/2020/03/29/Shell/</url>
    <content><![CDATA[<h1 id="一-Shell-概述"><a href="#一-Shell-概述" class="headerlink" title="一 Shell 概述"></a>一 Shell 概述</h1><ol>
<li><code>硬件 → 内核 → shell → 外层应用程序</code></li>
<li>shell 是命令解析器，将命令解析成二进制，是人和计算机交互的桥梁，linux 命令，windows 图形操作都需要shell来解析</li>
<li>shell 还是编程语言，解释型的脚本语言，在shell中可以直接调用 linux系统命令</li>
</ol>
<h1 id="二-Shell-分类"><a href="#二-Shell-分类" class="headerlink" title="二 Shell 分类"></a>二 Shell 分类</h1><h2 id="2-1-Bourne-Shell"><a href="#2-1-Bourne-Shell" class="headerlink" title="2.1 Bourne Shell"></a>2.1 Bourne Shell</h2><ol>
<li>1979年 unix 就开始使用，主文件名为<code>sh</code></li>
<li>Bourne Shell 家族<ul>
<li><code>sh</code></li>
<li><code>Bash</code><ul>
<li>与<code>sh</code>兼容，现在为linux的默认 shell</li>
</ul>
</li>
<li><code>ksh</code></li>
<li><code>psh</code></li>
<li><code>zsh</code></li>
</ul>
</li>
</ol>
<h2 id="2-2-C-Shell"><a href="#2-2-C-Shell" class="headerlink" title="2.2 C Shell"></a>2.2 C Shell</h2><ol>
<li>主要用在BSD版的unix中，与Bourne Shell不兼容</li>
<li>C shell家族<ul>
<li><code>csh</code></li>
<li><code>tcsh</code></li>
</ul>
</li>
</ol>
<h1 id="三-Shell-相关配置文件"><a href="#三-Shell-相关配置文件" class="headerlink" title="三 Shell 相关配置文件"></a>三 Shell 相关配置文件</h1><ol>
<li><code>/etc/shells</code><ul>
<li>所有shell类型</li>
<li>输入shell名即可切换shell</li>
</ul>
</li>
<li><code>/etc/password</code><ul>
<li>用户具体使用哪一个shell，取决于此文件每一行的最后一个字段</li>
</ul>
</li>
</ol>
<h1 id="四-快捷键"><a href="#四-快捷键" class="headerlink" title="四 快捷键"></a>四 快捷键</h1><table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>tab</code></td>
<td>补全</td>
</tr>
<tr>
<td><code>ctrl + c</code></td>
<td>终止正在执行的任务或者结束当前行的输入，发送 SIGINT 信号，终止一个进程</td>
</tr>
<tr>
<td><code>ctrl + d</code></td>
<td>退出当前shell，同 <code>exit</code></td>
</tr>
<tr>
<td><code>ctrl + z</code></td>
<td>暂停执行命令并放入后台，发送 SIGSTOP信号，挂起一个进程</td>
</tr>
<tr>
<td><code>ctrl + a</code></td>
<td>光标回到命令行首</td>
</tr>
<tr>
<td><code>ctrl + e</code></td>
<td>光标回到命令行尾</td>
</tr>
<tr>
<td><code>ctrl + ← →</code></td>
<td>在单词间左右移动光标</td>
</tr>
<tr>
<td><code>ctrl + u</code></td>
<td>剪切（删除）光标到行首的字符</td>
</tr>
<tr>
<td><code>ctrl + k</code></td>
<td>剪切（删除）光标到行尾的字符</td>
</tr>
<tr>
<td><code>ctrl + w</code></td>
<td>剪切（删除）一个空格分隔的字符串</td>
</tr>
<tr>
<td><code>ctrl + y</code></td>
<td>粘贴剪切的内容</td>
</tr>
<tr>
<td><code>ctrl + insert</code></td>
<td>复制命令行内容</td>
</tr>
<tr>
<td><code>shift + insert</code></td>
<td>粘贴命令行内容</td>
</tr>
<tr>
<td><code>ctrl + r</code></td>
<td>搜索命令行使用过的历史命令</td>
</tr>
<tr>
<td><code>ctrl + g</code></td>
<td>退出<code>ctrl + r</code> 搜索历史命令模式</td>
</tr>
<tr>
<td><code>Esc + .</code></td>
<td>获取上一条命令的最后部分（空格分隔）</td>
</tr>
<tr>
<td><code>ctrl + l</code></td>
<td>清屏 同<code>clear</code></td>
</tr>
<tr>
<td><code>ctrl + s</code></td>
<td>锁定终端，使之无法输入内容</td>
</tr>
<tr>
<td><code>ctrl + q</code></td>
<td>结束 <code>ctrl + s</code> 的锁定</td>
</tr>
<tr>
<td><code>!!</code></td>
<td>执行上一条命令</td>
</tr>
<tr>
<td><code>!xx</code></td>
<td>执行最近以xx开头的命令</td>
</tr>
<tr>
<td><code>!xx:p</code></td>
<td>仅打印最近以xx开头的命令，但不执行</td>
</tr>
<tr>
<td><code>!num</code></td>
<td>执行历史命令列表的第num条命令</td>
</tr>
<tr>
<td><code>!$</code></td>
<td>获取上一条命令的最后部分，同 <code>Esc + .</code></td>
</tr>
</tbody></table>
<h1 id="五-命令"><a href="#五-命令" class="headerlink" title="五 命令"></a>五 命令</h1><h2 id="5-1-内置命令-amp-外部命令"><a href="#5-1-内置命令-amp-外部命令" class="headerlink" title="5.1 内置命令 &amp; 外部命令"></a>5.1 内置命令 &amp; 外部命令</h2><h3 id="1-内置命令"><a href="#1-内置命令" class="headerlink" title="1 内置命令"></a>1 内置命令</h3><ol>
<li>内置命令和shell是一体的，它们作为shell工具的组成部分存在。</li>
<li>内置命令在系统启动时就调入内存，是常驻内存的</li>
<li>内置命令一般在系统中不存在文件，而存在于bash解释器里</li>
<li>执行内置命令时不需要通过衍生出子进程来执行，也不需要打开程序文件。所以内置命令的执行速度要更快，效率也更高</li>
</ol>
<h3 id="2-外部命令"><a href="#2-外部命令" class="headerlink" title="2 外部命令"></a>2 外部命令</h3><ol>
<li>外部命令也称为文件系统命令，是bash shell之外的程序，它并不是shell 的一部分。</li>
<li>外部命令是系统软件的功能，用户需要时才从硬盘中读入内存</li>
<li>外部命令在系统路径下有相应的可执行文件，一般位于<code>/bin</code>、<code>/usr/bin</code>、<code>/sbin</code> 或 <code>/usr/sbin</code>。</li>
<li>执行外部命令时，Linux系统会创建出一个子进程（这种操作被称为衍生），Linux系统需要消耗资源来设置新子进程的环境，所以执行外部命令有额外的代价。</li>
</ol>
<h3 id="3-type"><a href="#3-type" class="headerlink" title="3 type"></a>3 type</h3><ul>
<li><code>type [-a] 命令</code><ul>
<li>查看命令类型<ul>
<li><code>pwd is a shell builtin</code><ul>
<li>内置命令</li>
</ul>
</li>
<li><code>pwd is /usr/bin/pwd</code><ul>
<li>显示命令路径则为外部命令</li>
</ul>
</li>
</ul>
</li>
<li><code>-a</code><ul>
<li>查看所有信息，有的命令如 <code>pwd</code>，即是内置命令又是外部命令</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-2-别名（alias）"><a href="#5-2-别名（alias）" class="headerlink" title="5.2 别名（alias）"></a>5.2 别名（alias）</h2><ol>
<li><code>alias</code><ul>
<li>查看别名列表</li>
</ul>
</li>
<li><code>alias 别名 = 命令</code><ul>
<li>为指定命令创建别名（临时）</li>
</ul>
</li>
<li><code>unalias 别名</code><ul>
<li>删除别名</li>
</ul>
</li>
<li>屏蔽别名<ol>
<li><code>\命令</code></li>
<li>命令绝对路径</li>
<li>删除别名</li>
</ol>
</li>
</ol>
<h2 id="5-3-命令执行流程"><a href="#5-3-命令执行流程" class="headerlink" title="5.3 命令执行流程"></a>5.3 命令执行流程</h2><p><img src="https://gitee.com/3noanswer/npics/raw/master/Linux/linux%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt=""></p>
<ol>
<li>判断输入的命令是否是绝对路径命令，是则直接执行，否 →2</li>
<li>判断输入的命令是否是别名命令，是则操作别名代表的真实命令，否操作输入的命令，无论是否，操作的命令 → 3</li>
<li>判断命令是否是内置命令，是则直接执行，否 → 4</li>
<li>判断外部命令是否有缓存，是则直接执行，否 → 5</li>
<li>根据系统环境变量 <code>PATH</code> 定义的路径依次查找命令的可执行文件，找到则执行，没找到则报错<ul>
<li>执行过的外部命令会保存在内部缓存中，当再次执行相同的命令，会通过缓存调取执行</li>
</ul>
</li>
</ol>
<h1 id="六-配置文件"><a href="#六-配置文件" class="headerlink" title="六 配置文件"></a>六 配置文件</h1><h2 id="6-1-login-shell-amp-non-login-shell"><a href="#6-1-login-shell-amp-non-login-shell" class="headerlink" title="6.1 login shell &amp; non-login shell"></a>6.1 login shell &amp; non-login shell</h2><h3 id="1-login-shell"><a href="#1-login-shell" class="headerlink" title="1 login shell"></a>1 login shell</h3><ul>
<li>取得 shell 时需要完整的登陆流程的，就称为 login shell。</li>
</ul>
<h3 id="2-non-login-shell"><a href="#2-non-login-shell" class="headerlink" title="2 non-login shell"></a>2 non-login shell</h3><ul>
<li>取得 shell 没有通过登录流程，就称为 non-loagin shee</li>
<li>比如在原本的 bash 环境下再次使用 bash 这个命令，建立了一个bash子进程，没有输入账号密码， 那第二个 bash 就是 non-login shell 。</li>
</ul>
<h4 id="3-一个判断的方式"><a href="#3-一个判断的方式" class="headerlink" title="3 一个判断的方式"></a>3 一个判断的方式</h4><ul>
<li><code>echo $0</code><ul>
<li><code>-bash</code>：login shell</li>
<li><code>bash</code>：non-login shell</li>
</ul>
</li>
</ul>
<h2 id="6-2-Interactive-shell-amp-non-interactive-shell"><a href="#6-2-Interactive-shell-amp-non-interactive-shell" class="headerlink" title="6.2 Interactive shell &amp; non-interactive shell"></a>6.2 Interactive shell &amp; non-interactive shell</h2><h3 id="1-Interactive-shell（交互式shell）"><a href="#1-Interactive-shell（交互式shell）" class="headerlink" title="1 Interactive shell（交互式shell）"></a>1 Interactive shell（交互式shell）</h3><ul>
<li>shell中的命令时由用户从键盘交互式地输入的，运行的结果也能够输出到终端显示给用户看。</li>
</ul>
<h3 id="2-non-interactive-shell（非交互式shell）"><a href="#2-non-interactive-shell（非交互式shell）" class="headerlink" title="2 non-interactive shell（非交互式shell）"></a>2 non-interactive shell（非交互式shell）</h3><ul>
<li>shell可能由某些自动化过程启动，不能直接接收用户的输入，也不能直接输出结果给终端用户看。</li>
</ul>
<h2 id="6-3-配置文件加载过程"><a href="#6-3-配置文件加载过程" class="headerlink" title="6.3 配置文件加载过程"></a>6.3 配置文件加载过程</h2><p><img src="https://gitee.com/3noanswer/npics/raw/master/Linux/login-shell%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png" alt=""></p>
<h3 id="1-login-shell-1"><a href="#1-login-shell-1" class="headerlink" title="1 login shell"></a>1 login shell</h3><ol>
<li><code>/etc/profile</code><ul>
<li>加载系统配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 配置了一些环境变量 `USER LOGNAME MAIL PATH HOSTNAME HISTSIZE`</span><br><span class="line">2 配置了默认 umask</span><br><span class="line">3 调用 /etc/profile.d 下的脚本文件</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>~/.bash_profile | ~/.bash_login | ~/.profile</code><ul>
<li>加载用户配置文件，三者按照顺序只会读取其中的一个<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1 加载 ~/.bashrc</span><br><span class="line">if [ -f ~/.bashrc ]; then</span><br><span class="line">	. ~/.bashrc </span><br><span class="line">fi</span><br><span class="line"># 2 由于脚本是顺序执行，所以首先加载 ~.bashrc，之后执行下边内容</span><br><span class="line">PATH=$PATH:$HOME/bin</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>~/.bashrc</code><ul>
<li>用户配置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1 定义了一些别名</span><br><span class="line">alias rm=&apos;rm -i&apos;</span><br><span class="line">alias cp=&apos;cp -i&apos;</span><br><span class="line">alias mv=&apos;mv -i&apos;</span><br><span class="line"># 2 加载 /etc/bashrc</span><br><span class="line">if [ -f /etc/bashrc ]; then</span><br><span class="line">	. /etc/bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>/etc/bashrc</code><ul>
<li>系统配置，配置了环境变量 <code>PS1</code></li>
</ul>
</li>
</ol>
<h3 id="2-non-login-shell-1"><a href="#2-non-login-shell-1" class="headerlink" title="2 non-login shell"></a>2 non-login shell</h3><ol>
<li><code>~/.bashrc</code><ul>
<li>只会读取 <code>~/.bashrc</code> 这一个文件</li>
</ul>
</li>
<li><code>/etc/bashrc</code><ol>
<li>配置了环境变量 <code>PS1 PATH</code></li>
<li>配置了 umask</li>
<li>调用 <code>/etc/profile.d</code> 下的脚本文件 <code>.sh</code></li>
</ol>
</li>
</ol>
<h2 id="6-4-重载配置文件"><a href="#6-4-重载配置文件" class="headerlink" title="6.4 重载配置文件"></a>6.4 重载配置文件</h2><ol>
<li><code>source 配置文件</code> </li>
<li><code>. 配置文件</code></li>
</ol>
<h1 id="七-Shell-中的符号"><a href="#七-Shell-中的符号" class="headerlink" title="七 Shell 中的符号"></a>七 Shell 中的符号</h1><h2 id="7-1-基本符号"><a href="#7-1-基本符号" class="headerlink" title="7.1 基本符号"></a>7.1 基本符号</h2><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>\</code></td>
<td>转义符</td>
</tr>
<tr>
<td><code>$</code></td>
<td>用于调用变量的值</td>
</tr>
<tr>
<td><code>&#39;&#39;</code></td>
<td>单引号，所见即所得。</td>
</tr>
<tr>
<td><code>&quot;&quot;</code></td>
<td>双引号，在双引号中<code>$ &#96; &lt;/code> 有特殊含义</td>
</tr>
<tr>
<td><code>&#96;&#96;</code></td>
<td>反引号，解析命令</td>
</tr>
<tr>
<td><code>$()</code></td>
<td>同反引号，解析命令</td>
</tr>
<tr>
<td><code>&#124;</code></td>
<td>管道符，将前一个命令的正确输出输入到后一个命令</td>
</tr>
<tr>
<td><code>;</code></td>
<td>前后命令没有逻辑关系，顺序执行</td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑与，前命令成功，后命令才执行</td>
</tr>
<tr>
<td><code>&#124;&#124;</code></td>
<td>逻辑或，前命令成功，后命令不执行；前命令不成功，后命令执行</td>
</tr>
</tbody></table>
<h2 id="7-2-集合-amp-序列"><a href="#7-2-集合-amp-序列" class="headerlink" title="7.2 集合 &amp; 序列"></a>7.2 集合 &amp; 序列</h2><h3 id="1-集合"><a href="#1-集合" class="headerlink" title="1 集合"></a>1 集合</h3><ul>
<li><code>{ele1, ele2, ele3, ...}</code></li>
</ul>
<h3 id="2-序列"><a href="#2-序列" class="headerlink" title="2 序列"></a>2 序列</h3><ul>
<li><code>{first .. last .. increment}</code><ul>
<li>从 <code>first</code> 开始，每次增长 <code>increment</code> ，不超过 <code>last</code></li>
</ul>
</li>
</ul>
<h3 id="3-集合或序列可与外部字符、集合或序列相结合"><a href="#3-集合或序列可与外部字符、集合或序列相结合" class="headerlink" title="3 集合或序列可与外部字符、集合或序列相结合"></a>3 集合或序列可与外部字符、集合或序列相结合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo a&#123;,2&#125; # a a2</span><br><span class="line">echo a&#123;1,2&#125; # a1 a2</span><br><span class="line">echo a&#123;1..3&#125; # a1 a2 a3</span><br><span class="line">echo &#123;1,2&#125;&#123;1..3&#125; # 11 12 13 21 22 23</span><br></pre></td></tr></table></figure>

<h2 id="7-3-通配符"><a href="#7-3-通配符" class="headerlink" title="7.3 通配符"></a>7.3 通配符</h2><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>?</code></td>
<td>1个 任意字符</td>
</tr>
<tr>
<td><code>*</code></td>
<td>0 或多个 任意字符</td>
</tr>
<tr>
<td>### 通配符 &amp; 正则</td>
<td></td>
</tr>
<tr>
<td>#### 1 通配符</td>
<td></td>
</tr>
<tr>
<td>1. 通配符根据文件名称进行筛选，是完全匹配</td>
<td></td>
</tr>
<tr>
<td>2. <code>ls、find、cp...</code> 这些命令不支持正则表达式，所以只能使用shell自己的通配符来进行匹配</td>
<td></td>
</tr>
</tbody></table>
<h4 id="2-正则"><a href="#2-正则" class="headerlink" title="2 正则"></a>2 正则</h4><ol>
<li>正则根据文件内容进行筛选，是包含匹配</li>
<li><code>grep、awk、se...</code> 等命令可以支持正则表达式</li>
</ol>
<h4 id="3-Shell的-和正则的"><a href="#3-Shell的-和正则的" class="headerlink" title="3 Shell的 * 和正则的 *"></a>3 Shell的 <code>*</code> 和正则的 <code>*</code></h4><ol>
<li>Shell 中的 <code>*</code> 表示匹配任意数量的任意字符，是文本，能单独出现</li>
<li>正则中的 <code>*</code> 代表数量，表示前一个字符或组连续出现 0 次或多次，不能单独出现</li>
</ol>
<h2 id="7-4-重定向"><a href="#7-4-重定向" class="headerlink" title="7.4 重定向"></a>7.4 重定向</h2><h3 id="1-标准输入-输出"><a href="#1-标准输入-输出" class="headerlink" title="1 标准输入/输出"></a>1 标准输入/输出</h3><table>
<thead>
<tr>
<th>类型</th>
<th>设备</th>
<th>设备文件名</th>
<th>文件描述符</th>
</tr>
</thead>
<tbody><tr>
<td>标准输入</td>
<td>键盘</td>
<td>/dev/stdin</td>
<td>0</td>
</tr>
<tr>
<td>标准输出</td>
<td>显示器</td>
<td>/dev/stdout</td>
<td>1</td>
</tr>
<tr>
<td>标准错误输出</td>
<td>显示器</td>
<td>/dev/stderr</td>
<td>2</td>
</tr>
<tr>
<td>* 文件描述符</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1. 是内核为了高效管理已被打开的文件所创建的索引，用于指向被打开的文件</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2. 对文件描述符的操作就是对文件本身的操作。 可以直接通过操作文件描述来修改文件</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="2-标准输入重定向"><a href="#2-标准输入重定向" class="headerlink" title="2 标准输入重定向"></a>2 标准输入重定向</h3><table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>命令 [0]&lt; 文件</code></td>
<td>将文件作为命令的输入</td>
</tr>
<tr>
<td><code>命令 [0]&lt;&lt; EOF ... EOF</code></td>
<td>把标识符之间内容作为命令的输入</td>
</tr>
<tr>
<td>* <code>EOF</code></td>
<td></td>
</tr>
<tr>
<td>* <code>end of file</code></td>
<td></td>
</tr>
<tr>
<td>* 可自定义，必须成对，后一个必须顶格（行首部）</td>
<td></td>
</tr>
</tbody></table>
<h3 id="3-标准输出重定向"><a href="#3-标准输出重定向" class="headerlink" title="3 标准输出重定向"></a>3 标准输出重定向</h3><table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>命令 [1]&gt; 文件</code></td>
<td>将命令的正确输出添加到文件（覆盖）</td>
</tr>
<tr>
<td><code>命令 [1]&gt;&gt; 文件</code></td>
<td>将命令的正确输出追加到文件</td>
</tr>
</tbody></table>
<h3 id="4-标准错误输出重定向"><a href="#4-标准错误输出重定向" class="headerlink" title="4 标准错误输出重定向"></a>4 标准错误输出重定向</h3><table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>命令 2&gt; 文件</code></td>
<td>将命令的错误输出添加到文件（覆盖）</td>
</tr>
<tr>
<td><code>命令 2&gt;&gt; 文件</code></td>
<td>将命令的错误输出追加到文件</td>
</tr>
</tbody></table>
<h3 id="5-标准输出重定向（正确输出-错误输出）"><a href="#5-标准输出重定向（正确输出-错误输出）" class="headerlink" title="5 标准输出重定向（正确输出+错误输出）"></a>5 标准输出重定向（正确输出+错误输出）</h3><table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>命令 &amp;&gt; 文件</code></td>
<td>将命令的输出（正确和错误）添加到文件（覆盖）</td>
</tr>
<tr>
<td><code>命令 &amp;&gt;&gt; 文件</code></td>
<td>将命令的输出（正确和错误）追加到文件</td>
</tr>
<tr>
<td><code>命令 &gt; 文件 2&gt;&amp;1</code></td>
<td>将命令的输出（正确和错误）添加到文件（覆盖）</td>
</tr>
<tr>
<td><code>命令 &gt;&gt; 文件 2&gt;&amp;1</code></td>
<td>将命令的输出（正确和错误）追加到文件</td>
</tr>
<tr>
<td><code>命令&gt;文件1 2&gt;文件2</code></td>
<td>把命令正确的输出添加到文件1中，错误的输出添加到文件2中（覆盖）</td>
</tr>
<tr>
<td><code>命令&gt;&gt;文件1 2&gt;&gt;文件2</code></td>
<td>把命令正确的输出追加到文件1中，错误的输出追加到文件2中</td>
</tr>
<tr>
<td>1. <code>1&gt;&amp;2</code></td>
<td></td>
</tr>
<tr>
<td>* 把正确输出输出到错误输出中</td>
<td></td>
</tr>
<tr>
<td>2. <code>2&gt;&amp;1</code></td>
<td></td>
</tr>
<tr>
<td>* 把错误输出输出到正确输出中</td>
<td></td>
</tr>
<tr>
<td>3. <code>命令 &gt;&gt; 文件 2&gt;&amp;1</code></td>
<td></td>
</tr>
<tr>
<td>* 没错误就把正确输出追加到文件</td>
<td></td>
</tr>
<tr>
<td>* 有错误就先把错误输出到正确输出中，然后一起追加到文件</td>
<td></td>
</tr>
</tbody></table>
<h1 id="八-变量"><a href="#八-变量" class="headerlink" title="八 变量"></a>八 变量</h1><h2 id="8-1-规则"><a href="#8-1-规则" class="headerlink" title="8.1 规则"></a>8.1 规则</h2><ol>
<li>变量名不能以数字开头，由数字，字母，下划线组成</li>
<li>变量默认类型都是字符串，如果要进行数值运算，必须指定变量为数值型</li>
<li>变量赋值时等号两边不能有空格</li>
<li>变量的值有空格，需要单引号或者双引号</li>
</ol>
<h2 id="8-2-普通变量（局部变量）"><a href="#8-2-普通变量（局部变量）" class="headerlink" title="8.2 普通变量（局部变量）"></a>8.2 普通变量（局部变量）</h2><ol>
<li>只对当前shell有效，临时变量，重启失效</li>
<li><code>set</code><ul>
<li>查看变量</li>
</ul>
</li>
<li><code>变量名=值</code><ul>
<li>定义变量</li>
</ul>
</li>
<li><code>unset 变量名</code><ul>
<li>删除变量</li>
</ul>
</li>
<li><code>$变量名</code><ul>
<li>取值</li>
</ul>
</li>
</ol>
<h2 id="8-3-环境变量（全局变量）"><a href="#8-3-环境变量（全局变量）" class="headerlink" title="8.3 环境变量（全局变量）"></a>8.3 环境变量（全局变量）</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>命令行定义时，对当前shell及其子shell有效，临时变量，重启失效</li>
<li>写入配置文件中，根据配置文件决定对哪个shell有效，永久变量</li>
</ol>
<h3 id="2-命令"><a href="#2-命令" class="headerlink" title="2 命令"></a>2 命令</h3><ol>
<li><code>env</code><ul>
<li>查询环境变量</li>
</ul>
</li>
<li><code>export 变量名=值</code><ul>
<li>定义环境变量</li>
</ul>
</li>
<li><code>unset 变量名</code><ul>
<li>删除变量</li>
</ul>
</li>
<li><code>$变量名</code><ul>
<li>获取值</li>
</ul>
</li>
</ol>
<h3 id="3-常见环境变量"><a href="#3-常见环境变量" class="headerlink" title="3 常见环境变量"></a>3 常见环境变量</h3><table>
<thead>
<tr>
<th>环境变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>PATH</code></td>
<td>定义命令行解释器搜索执行命令的路径</td>
</tr>
<tr>
<td><code>HOME</code></td>
<td>用户家目录</td>
</tr>
<tr>
<td><code>SHELL</code></td>
<td>用户使用的 Shell 解释器名称</td>
</tr>
<tr>
<td><code>LANG</code></td>
<td>系统语言及字符编码</td>
</tr>
<tr>
<td><code>EDITOR</code></td>
<td>用户默认的文本编辑器</td>
</tr>
<tr>
<td><code>PS1</code></td>
<td>Shell 的命令提示符</td>
</tr>
<tr>
<td><code>RANDOM</code></td>
<td>生成一个随机数字</td>
</tr>
<tr>
<td><code>HISTSIZE</code></td>
<td>输出的历史命令记录条数</td>
</tr>
<tr>
<td><code>HISTFILESIZE</code></td>
<td>保存的历史命令记录条数</td>
</tr>
<tr>
<td><code>MAIL</code></td>
<td>邮件保存路径</td>
</tr>
</tbody></table>
<h3 id="4-位置参数变量"><a href="#4-位置参数变量" class="headerlink" title="4 位置参数变量"></a>4 位置参数变量</h3><table>
<thead>
<tr>
<th>位置参数变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>$0</code></td>
<td>代表命令本身</td>
</tr>
<tr>
<td><code>$n</code></td>
<td>代表第 n 个参数，如果 n&gt;=10，用大括号包含，如 <code>${10}</code></td>
</tr>
<tr>
<td><code>$#</code></td>
<td>参数总个数</td>
</tr>
<tr>
<td><code>$@</code></td>
<td>获取所有参数，每个参数独立，默认用空格分隔</td>
</tr>
<tr>
<td><code>$*</code></td>
<td>不加双引号同 <code>$@</code>，加上双引号，把所有参数视为一个整体</td>
</tr>
<tr>
<td><code>$?</code></td>
<td>获取上一个命令的执行返回值，0 成功，非 0 失败。</td>
</tr>
<tr>
<td><code>$$</code></td>
<td>当前脚本的进程号（PID）</td>
</tr>
<tr>
<td><code>$!</code></td>
<td>后台运行的最后一个脚本的进程号（PID）</td>
</tr>
<tr>
<td><code>$_</code></td>
<td>获取命令行最后一个参数，相当于 <code>ESC .</code></td>
</tr>
</tbody></table>
<h3 id="5-变量值操作"><a href="#5-变量值操作" class="headerlink" title="5 变量值操作 ${}"></a>5 变量值操作 <code>${}</code></h3><ol>
<li><code>${变量#pattern}</code><ul>
<li><code>#</code><ul>
<li>从前往后匹配并删除</li>
</ul>
</li>
<li><code>##</code><ul>
<li>贪婪匹配</li>
</ul>
</li>
</ul>
</li>
<li><code>${变量%pattern}</code><ul>
<li><code>%</code><ul>
<li>从后往前匹配并删除</li>
</ul>
</li>
<li><code>%%</code><ul>
<li>贪婪匹配    </li>
</ul>
</li>
</ul>
</li>
<li><code>${变量/oldStr/newStr}</code><ul>
<li>替换一个匹配</li>
</ul>
</li>
<li><code>${变量//oldStr/newStr}</code><ul>
<li>替换所有匹配</li>
</ul>
</li>
</ol>
<h3 id="6-数值运算"><a href="#6-数值运算" class="headerlink" title="6 数值运算"></a>6 数值运算</h3><ol>
<li><code>$(())</code><ul>
<li>整数运算</li>
<li>可以用在引号中，不会直接输出</li>
</ul>
</li>
<li><code>$[]</code><ul>
<li>整数运算</li>
<li>可以用在引号中，不会直接输出</li>
</ul>
</li>
<li><code>expr 1 + 1</code><ul>
<li>整数运算，需要数字与运算符间要加空格</li>
<li>不能用在引号中，会直接输出</li>
</ul>
</li>
<li><code>echo 1+1|bc</code><ul>
<li>整数/小数运算</li>
</ul>
</li>
</ol>
<h1 id="九-Shell-编程"><a href="#九-Shell-编程" class="headerlink" title="九 Shell 编程"></a>九 Shell 编程</h1><h2 id="9-1-执行脚本方式"><a href="#9-1-执行脚本方式" class="headerlink" title="9.1 执行脚本方式"></a>9.1 执行脚本方式</h2><ol>
<li><code>sh/bash 脚本</code><ul>
<li>借助解释器执行，脚本可以不用是绝对路径</li>
</ul>
</li>
<li><code>脚本绝对路径</code><ul>
<li>把脚本当成命令执行（必须赋予执行权限）</li>
</ul>
</li>
</ol>
<h2 id="9-2-windows-脚本在linux执行"><a href="#9-2-windows-脚本在linux执行" class="headerlink" title="9.2 windows 脚本在linux执行"></a>9.2 windows 脚本在linux执行</h2><ol>
<li>问题<ul>
<li>linux 换行符识别为<code>$</code>，而windows 换行符识别为<code>^M$</code><ol>
<li><code>:set list</code><ul>
<li>在文件中查看</li>
</ul>
</li>
<li><code>cat -A FIle</code><ul>
<li>在外部查看</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>解决<ol>
<li>安装 <code>dos2unix</code></li>
<li><code>dos2unix FILE</code><ul>
<li>把文件从 dos 转为 unix，也就修改了换行符</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="9-3-脚本语法"><a href="#9-3-脚本语法" class="headerlink" title="9.3 脚本语法"></a>9.3 脚本语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 注释</span><br></pre></td></tr></table></figure>

<h2 id="9-4-条件表达式"><a href="#9-4-条件表达式" class="headerlink" title="9.4 条件表达式"></a>9.4 条件表达式</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h3><ol>
<li><code>[ 条件表达式 ]</code><ul>
<li>两侧各有一个空格</li>
<li>条件成立返回 0，反之 1</li>
</ul>
</li>
<li><code>test 条件表达式</code></li>
</ol>
<h3 id="2-文件"><a href="#2-文件" class="headerlink" title="2 文件"></a>2 文件</h3><table>
<thead>
<tr>
<th>表达式</th>
<th>单词</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-e FILE</code></td>
<td><code>exit</code></td>
<td>判断该文件是否存在</td>
</tr>
<tr>
<td><code>-f FILE</code></td>
<td><code>file</code></td>
<td>判断该文件是否存在，且是否是文件</td>
</tr>
<tr>
<td><code>-d FILE</code></td>
<td><code>directory</code></td>
<td>判断该文件是否存在，且是否是目录</td>
</tr>
<tr>
<td><code>-l FILE</code></td>
<td><code>link</code></td>
<td>判断该文件是否存在，且是否是链接文件</td>
</tr>
<tr>
<td><code>-r FILE</code></td>
<td><code>read</code></td>
<td>判断该文件是否存在，且是否有读权限</td>
</tr>
<tr>
<td><code>-w FILE</code></td>
<td><code>write</code></td>
<td>判断该文件是否存在，且是否有写权限</td>
</tr>
<tr>
<td><code>-x FILE</code></td>
<td><code>execute</code></td>
<td>判断该文件是否存在，且是否有执行权限</td>
</tr>
<tr>
<td><code>FILE1 -ef FILE2</code></td>
<td><code>equals file</code></td>
<td>判断两个文件是否一样（硬链接）</td>
</tr>
<tr>
<td><code>FILE1 -nt FILE2</code></td>
<td><code>new than</code></td>
<td>判断文件1是否比文件2新（最后修改时间）</td>
</tr>
<tr>
<td><code>FILE1 -ot FILE2</code></td>
<td><code>old than</code></td>
<td>判断文件1是否比文件2旧（最后修改时间）</td>
</tr>
</tbody></table>
<h3 id="3-数值"><a href="#3-数值" class="headerlink" title="3 数值"></a>3 数值</h3><table>
<thead>
<tr>
<th><code>[[表达式]]</code></th>
<th><code>[表达式]</code></th>
<th>单词</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>==</code></td>
<td><code>-eq</code></td>
<td><code>equal</code></td>
<td>等于</td>
</tr>
<tr>
<td><code>!=</code></td>
<td><code>-ne</code></td>
<td><code>not equal</code></td>
<td>不等于</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td><code>-gt</code></td>
<td><code>greater than</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td><code>-ge</code></td>
<td><code>greater equal</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td><code>-lt</code></td>
<td><code>less than</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td><code>-le</code></td>
<td><code>less equal</code></td>
<td>小于等于</td>
</tr>
</tbody></table>
<h3 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4 字符串"></a>4 字符串</h3><table>
<thead>
<tr>
<th>表达式</th>
<th>单词</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-z STRING</code></td>
<td><code>zero</code></td>
<td>判断字符串长度是否为 0</td>
</tr>
<tr>
<td><code>-n STRING</code></td>
<td><code>not zero</code></td>
<td>判断字符串长度是否不为 0</td>
</tr>
<tr>
<td><code>STR1 = STR2</code></td>
<td><code>equal</code></td>
<td>判断字符串是否相等</td>
</tr>
<tr>
<td><code>STR1 != STR2</code></td>
<td><code>not equal</code></td>
<td>判断字符串是否不相等</td>
</tr>
</tbody></table>
<h3 id="5-逻辑表达式"><a href="#5-逻辑表达式" class="headerlink" title="5 逻辑表达式"></a>5 逻辑表达式</h3><table>
<thead>
<tr>
<th>表达式</th>
<th>单词</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>EXPR1 -a EXPR2</code></td>
<td><code>and</code></td>
<td>逻辑与</td>
</tr>
<tr>
<td><code>EXPR1 -o EXPR2</code></td>
<td><code>or</code></td>
<td>逻辑或</td>
</tr>
<tr>
<td><code>! EXPR</code></td>
<td><code>not</code></td>
<td>逻辑非</td>
</tr>
</tbody></table>
<h3 id="6-正则表达式（使用-）"><a href="#6-正则表达式（使用-）" class="headerlink" title="6 正则表达式（使用 [[]]）"></a>6 正则表达式（使用 <code>[[]]</code>）</h3><table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>=~ PATTERN</code></td>
<td>判断是否匹配</td>
</tr>
</tbody></table>
<h2 id="9-5-语句"><a href="#9-5-语句" class="headerlink" title="9.5 语句"></a>9.5 语句</h2><h3 id="1-if"><a href="#1-if" class="headerlink" title="1 if"></a>1 if</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [条件]</span><br><span class="line">	then code</span><br><span class="line">elif [条件]</span><br><span class="line">	then code</span><br><span class="line">......</span><br><span class="line">else</span><br><span class="line">	code</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [条件]; then</span><br><span class="line">	code</span><br><span class="line">elif [条件]; then</span><br><span class="line">	code</span><br><span class="line">......</span><br><span class="line">else</span><br><span class="line">	code</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="2-for"><a href="#2-for" class="headerlink" title="2 for"></a>2 for</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for 变量名 in 取值列表 # 值用空格或换行隔开</span><br><span class="line">	do</span><br><span class="line">		code...</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for((初始值;循环条件;变量变换))</span><br><span class="line">	do</span><br><span class="line">		code</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<h3 id="3-while"><a href="#3-while" class="headerlink" title="3 while"></a>3 while</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while [条件]</span><br><span class="line">	do</span><br><span class="line">		code</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<h3 id="4-until"><a href="#4-until" class="headerlink" title="4 until"></a>4 until</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">until [条件]</span><br><span class="line">	do</span><br><span class="line">		code</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>
<ul>
<li>一直执行直到条件成立，即条件不成立就无限循环，与while相反</li>
</ul>
<h3 id="5-case"><a href="#5-case" class="headerlink" title="5 case"></a>5 case</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case $变量 in</span><br><span class="line">	模式1)</span><br><span class="line">		code</span><br><span class="line">		;;</span><br><span class="line">	模式2)</span><br><span class="line">		code</span><br><span class="line">		;;</span><br><span class="line">	*)</span><br><span class="line">		code（皆不符合时执行）</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<h3 id="6-shell-内置语句"><a href="#6-shell-内置语句" class="headerlink" title="6 shell 内置语句"></a>6 shell 内置语句</h3><ol>
<li><code>continue</code><ul>
<li>跳出本次循环，继续下一次</li>
</ul>
</li>
<li><code>break</code><ul>
<li>跳出循环</li>
</ul>
</li>
<li><code>exit</code><ul>
<li>结束，类似 <code>return</code></li>
</ul>
</li>
</ol>
<h2 id="9-6-函数"><a href="#9-6-函数" class="headerlink" title="9.6 函数"></a>9.6 函数</h2><h3 id="1-定义方式"><a href="#1-定义方式" class="headerlink" title="1 定义方式"></a>1 定义方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">function test() &#123; return 返回值&#125;</span><br><span class="line">2</span><br><span class="line">test() &#123;return 返回值&#125;</span><br><span class="line">3</span><br><span class="line">function test &#123;return 返回值&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-变量定义"><a href="#2-变量定义" class="headerlink" title="2 变量定义"></a>2 变量定义</h3><ol>
<li>shell脚本定义的变量默认都是全局的（包括在函数中定义）</li>
<li><code>local 变量=值</code><ul>
<li>使用local表示只在当前作用域有效</li>
</ul>
</li>
<li><code>let</code><ul>
<li>用来执行算术运算，等价于 <code>((运算式))</code></li>
</ul>
</li>
</ol>
<h3 id="3-传参"><a href="#3-传参" class="headerlink" title="3 传参"></a>3 传参</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test $1 $2 ...</span><br><span class="line"># 注意 $1 指的是脚本传参的顺序</span><br></pre></td></tr></table></figure>

<h3 id="4-外部调用"><a href="#4-外部调用" class="headerlink" title="4 外部调用"></a>4 外部调用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test.sh test $1 $2 ...</span><br></pre></td></tr></table></figure>

<h2 id="9-7-数组"><a href="#9-7-数组" class="headerlink" title="9.7 数组"></a>9.7 数组</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arrName=(val1 val2 ... valN)</span><br></pre></td></tr></table></figure>

<h3 id="2-获取属组长度"><a href="#2-获取属组长度" class="headerlink" title="2 获取属组长度"></a>2 获取属组长度</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;#arrName[*|@]&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-获取值"><a href="#3-获取值" class="headerlink" title="3 获取值"></a>3 获取值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 $&#123;arrName[index]&#125; # 获取指定值</span><br><span class="line">2 $&#123;arrName[*|@]:startIndex:length&#125; # 获取从startIndex开始的length个值</span><br></pre></td></tr></table></figure>

<h3 id="4-设置值"><a href="#4-设置值" class="headerlink" title="4 设置值"></a>4 设置值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arrName[index]=value</span><br></pre></td></tr></table></figure>

<h3 id="5-删除"><a href="#5-删除" class="headerlink" title="5 删除"></a>5 删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 unset arrName[index] # 删除指定值</span><br><span class="line">2 unset arrName # 清空数组</span><br></pre></td></tr></table></figure>

<h3 id="6-替换"><a href="#6-替换" class="headerlink" title="6 替换"></a>6 替换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;arrName[@|*]/pattern/new&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 安装和配置</title>
    <url>/anyeansan.github.io/2020/03/29/Linux-%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-硬件"><a href="#1-1-硬件" class="headerlink" title="1.1 硬件"></a>1.1 硬件</h2><ol>
<li>电源</li>
<li>CPU<ol>
<li>路数：即CPU的个数，1 路 = 1 CPU</li>
<li>核数</li>
</ol>
</li>
<li>内存<ol>
<li>缓冲（buffer）<ul>
<li>写：<code>数据 → 内存 → 磁盘</code></li>
</ul>
</li>
<li>缓存（cache）<ul>
<li>读：<code>磁盘 → 内存 → 数据</code></li>
</ul>
</li>
</ol>
</li>
<li>磁盘</li>
<li>主板</li>
<li>显卡</li>
<li>声卡</li>
<li>键鼠</li>
</ol>
<h2 id="1-2-服务器"><a href="#1-2-服务器" class="headerlink" title="1.2 服务器"></a>1.2 服务器</h2><ol>
<li>硬件服务器<ol>
<li>机架服务器</li>
<li>刀片服务器</li>
<li>塔式服务器</li>
</ol>
</li>
<li>虚拟服务器<ol>
<li>阿里云</li>
<li>亚马逊（AWS）</li>
<li>腾讯云</li>
</ol>
</li>
</ol>
<h2 id="1-3-操作系统"><a href="#1-3-操作系统" class="headerlink" title="1.3 操作系统"></a>1.3 操作系统</h2><ul>
<li><code>硬件 + 内核 + shell + 软件</code></li>
</ul>
<h2 id="1-4-Linux发展历史"><a href="#1-4-Linux发展历史" class="headerlink" title="1.4 Linux发展历史"></a>1.4 Linux发展历史</h2><ol>
<li><code>FSF</code><ul>
<li><code>free software foundation</code> 自由软件基金会，主要项目是GNU</li>
</ul>
</li>
<li><code>GNU</code><ul>
<li><code>GNU是“GNU is Not Unix”的递归缩写</code>，目标是建立可自由发布和移值的类unix操作系统</li>
<li>GNU类UNIX操作系统是由一系列应用程序，系统库和开发工具构成的软件集合（如Emacs，gcc，bash，gawk），并加上了用于资源分配和硬件管理的内核。</li>
</ul>
</li>
<li><code>GPL</code><ul>
<li><code>general public license</code>：通用公共许可，是一个开源许可协议</li>
</ul>
</li>
</ol>
<ul>
<li><code>linux 操作系统 = linux内核 + GNU软件和系统软件 + 必要的应用程序</code></li>
</ul>
<h2 id="1-5-Linux-发行版"><a href="#1-5-Linux-发行版" class="headerlink" title="1.5 Linux 发行版"></a>1.5 Linux 发行版</h2><ol>
<li><code>Fedora</code><ul>
<li>免费，新功能，小白鼠</li>
</ul>
</li>
<li><code>Red Hat</code><ul>
<li>收费</li>
</ul>
</li>
<li><code>CentOS</code><ul>
<li>去掉Red Hat的logo，收费软件被重新打包编译</li>
<li>后被Red Hat 收购</li>
</ul>
</li>
<li><code>Ubuntu</code><ul>
<li>桌面</li>
</ul>
</li>
<li><code>Debian FreeBSD</code><ul>
<li>安全 稳定</li>
</ul>
</li>
</ol>
<h2 id="1-6-语录"><a href="#1-6-语录" class="headerlink" title="1.6 语录"></a>1.6 语录</h2><ol>
<li>Linux 一切从根开始</li>
<li>Linux 一切皆文件</li>
<li>Linux 系统中命令行的修改大部分都是临时修改，配置文件是永久修改。</li>
<li>Linux 系统服务配置文件修改后，需要重启服务（重新加载配置文件）</li>
</ol>
<h1 id="二-CentOS-7-安装"><a href="#二-CentOS-7-安装" class="headerlink" title="二 CentOS 7 安装"></a>二 CentOS 7 安装</h1><h2 id="2-1-下载镜像"><a href="#2-1-下载镜像" class="headerlink" title="2.1 下载镜像"></a>2.1 下载镜像</h2><ol>
<li><a href="https://www.centos.org/" target="_blank" rel="noopener" title="CentOS 官网">CentoOS project</a></li>
<li><a href="https://developer.aliyun.com/mirror/" target="_blank" rel="noopener" title="阿里云官方镜像站">Aliyun mirror</a></li>
</ol>
<h2 id="2-2-准备虚拟环境"><a href="#2-2-准备虚拟环境" class="headerlink" title="2.2 准备虚拟环境"></a>2.2 准备虚拟环境</h2><ol>
<li>虚拟软件 <code>VMware Workstation</code></li>
</ol>
<h2 id="2-3-安装配置"><a href="#2-3-安装配置" class="headerlink" title="2.3 安装配置"></a>2.3 安装配置</h2><h3 id="1-软件安装"><a href="#1-软件安装" class="headerlink" title="1 软件安装"></a>1 软件安装</h3><ul>
<li><code>Minimal Insatll</code><ul>
<li><code>Debugging Tools</code></li>
<li><code>Compatibility Libraries</code></li>
<li><code>Development Tools</code></li>
<li><code>System Administration Tools</code></li>
</ul>
</li>
</ul>
<h3 id="2-网络（NAT）"><a href="#2-网络（NAT）" class="headerlink" title="2 网络（NAT）"></a>2 网络（NAT）</h3><ol>
<li>主机名</li>
<li><code>config</code><ol>
<li><code>General</code><ul>
<li>勾选自动连接</li>
</ul>
</li>
<li><code>IPv4 settings</code><ol>
<li><code>Method</code> <ul>
<li><code>Manual</code> （手动）</li>
</ul>
</li>
<li>ip 子网掩码 网关 <ul>
<li>根据虚拟机网络编辑器中 <code>VMnet8</code> 网卡设置</li>
</ul>
</li>
<li>dns <ul>
<li>如 <code>223.5.5.5</code>，<code>8.8.8.8</code></li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="3-磁盘分区（standard-partition）"><a href="#3-磁盘分区（standard-partition）" class="headerlink" title="3 磁盘分区（standard partition）"></a>3 磁盘分区（standard partition）</h3><ul>
<li><code>/boot</code><ul>
<li>引导分区，256Mb</li>
</ul>
</li>
<li><code>swap</code><ul>
<li>交换分区，</li>
<li>内存 &gt; 8G，swap = 8G，内存 &lt; 8G，swap = 内存 * 1.5</li>
</ul>
</li>
<li><code>/</code><ul>
<li>根分区，剩余大小</li>
</ul>
</li>
</ul>
<h3 id="4-关闭安全策略"><a href="#4-关闭安全策略" class="headerlink" title="4 关闭安全策略"></a>4 关闭安全策略</h3><ol>
<li><code>KDUMP</code></li>
<li><code>SECURITY POLICY</code></li>
</ol>
<h1 id="三-初始化配置"><a href="#三-初始化配置" class="headerlink" title="三 初始化配置"></a>三 初始化配置</h1><h2 id="3-1-配置-yum-源"><a href="#3-1-配置-yum-源" class="headerlink" title="3.1 配置 yum 源"></a>3.1 配置 yum 源</h2><h3 id="1-安装-wget"><a href="#1-安装-wget" class="headerlink" title="1 安装 wget"></a>1 安装 wget</h3><ul>
<li><code>yum install wget -y</code></li>
</ul>
<h3 id="2-备份"><a href="#2-备份" class="headerlink" title="2 备份"></a>2 备份</h3><ul>
<li><code>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code></li>
</ul>
<h3 id="3-下载基本-yum-源"><a href="#3-下载基本-yum-源" class="headerlink" title="3 下载基本 yum 源"></a>3 下载基本 yum 源</h3><ol>
<li><code>curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</code></li>
<li><code>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</code></li>
</ol>
<h3 id="4-下载扩展-yum-源-EPEL"><a href="#4-下载扩展-yum-源-EPEL" class="headerlink" title="4 下载扩展 yum 源 EPEL"></a>4 下载扩展 yum 源 EPEL</h3><ul>
<li><code>wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</code></li>
</ul>
<h2 id="3-2-更新系统和软件"><a href="#3-2-更新系统和软件" class="headerlink" title="3.2 更新系统和软件"></a>3.2 更新系统和软件</h2><ul>
<li><code>yum update -y</code></li>
</ul>
<h2 id="3-3-安装企业运维常用基础工具包"><a href="#3-3-安装企业运维常用基础工具包" class="headerlink" title="3.3 安装企业运维常用基础工具包"></a>3.3 安装企业运维常用基础工具包</h2><h3 id="1-CentOS-6-amp-7-都要安装的"><a href="#1-CentOS-6-amp-7-都要安装的" class="headerlink" title="1 CentOS 6 &amp; 7 都要安装的"></a>1 CentOS 6 &amp; 7 都要安装的</h3><ul>
<li><code>yum install tree nmap dos2unix lrzsz nc lsof tcpdump htop iftop iotop sysstat nethogs -y</code></li>
</ul>
<table>
<thead>
<tr>
<th>软件包名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>tree</code></td>
<td>树形结构显示文件和目录</td>
</tr>
<tr>
<td><code>nmap</code></td>
<td>扫描端口的工具</td>
</tr>
<tr>
<td><code>dos2unix</code></td>
<td>转换脚本格式的工具</td>
</tr>
<tr>
<td><code>lrzsz</code></td>
<td>包含上传（rz）和下载（sz）文件工具</td>
</tr>
<tr>
<td><code>nc</code></td>
<td>文件传输、端口检查工具</td>
</tr>
<tr>
<td><code>lsof</code></td>
<td>反查端口进程，以及服务开发文件工具</td>
</tr>
<tr>
<td><code>wget</code></td>
<td>网络下载工具</td>
</tr>
<tr>
<td><code>tcpdump</code></td>
<td>抓包、监听等重要排错工具</td>
</tr>
<tr>
<td><code>htop</code></td>
<td>系统进程相关信息查看工具</td>
</tr>
<tr>
<td><code>iftop</code></td>
<td>主机网卡宽带查看工具</td>
</tr>
<tr>
<td><code>sysstat</code></td>
<td>含有sar iostat 等重要系统性能查看工具</td>
</tr>
<tr>
<td><code>nethogs</code></td>
<td>显示进程的网络流量</td>
</tr>
</tbody></table>
<h3 id="2-CentOS-7-安装的"><a href="#2-CentOS-7-安装的" class="headerlink" title="2 CentOS 7 安装的"></a>2 CentOS 7 安装的</h3><ul>
<li><code>yum install psmisc net-tools bash-completion bash-completion-extras vim-enhanced -y</code></li>
</ul>
<table>
<thead>
<tr>
<th>软件包名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>psmisc</code></td>
<td>含有 <code>killalll pstree</code> 等命令</td>
</tr>
<tr>
<td><code>net-tools</code></td>
<td>含有 <code>netstat ifconfig route arp</code> 等命令</td>
</tr>
<tr>
<td><code>bash-completion</code></td>
<td>tab补全功能工具包</td>
</tr>
<tr>
<td><code>bash-completion-extras</code></td>
<td>tab补全功能扩展工具包</td>
</tr>
<tr>
<td><code>vim-enhanced</code></td>
<td>vim</td>
</tr>
</tbody></table>
<h2 id="3-4-修改网卡名称"><a href="#3-4-修改网卡名称" class="headerlink" title="3.4 修改网卡名称"></a>3.4 修改网卡名称</h2><h3 id="1-安装系统时"><a href="#1-安装系统时" class="headerlink" title="1 安装系统时"></a>1 安装系统时</h3><ol>
<li>菜单界面 按 <code>tab</code></li>
<li>输入 <code>net.ifnames=0 biosdevname=0</code></li>
</ol>
<h3 id="2-安装系统后"><a href="#2-安装系统后" class="headerlink" title="2 安装系统后"></a>2 安装系统后</h3><ol>
<li>修改网卡配置文件内容及文件名 <code>/etc/sysconfig/netword-scripts/ens33</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 修改内容</span><br><span class="line">	vim /etc/sysconfig/netword-scripts/ens33</span><br><span class="line">	name=eth0</span><br><span class="line">	device=eth0</span><br><span class="line">2 修改文件名</span><br><span class="line">	mv /etc/sysconfig/netword-scripts/ens33 /etc/sysconfig/netword-scripts/eth0</span><br></pre></td></tr></table></figure></li>
<li>修改网卡名称规则内核文件 <code>/etc/default/grub</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/default/grub</span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;rhgb quiet&quot; 改为</span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;net.ifnames=0 biosdevname=0 rhgb quiet&quot;</span><br><span class="line">```	</span><br><span class="line">3. 系统重新加载 grup 配置文件</span><br><span class="line">	* `grub2-mkconfig -o /boot/grub2/grub.cfg`</span><br><span class="line"></span><br><span class="line">## 3.5 系统优化</span><br><span class="line">### 1 selinux</span><br><span class="line">#### 1 概述</span><br><span class="line">* `Security-Enhanced Linux`</span><br><span class="line">	* 它是一个 Linux 内核模块，也是 Linux 的一个安全子系统。</span><br><span class="line">	* Selinux 用于对 root 用户的权限进行控制</span><br><span class="line"></span><br><span class="line">#### 2 操作</span><br><span class="line">1. `getenforce`</span><br><span class="line">	* 查看状态</span><br><span class="line">2. `setenforce 0`</span><br><span class="line">	* 临时关闭</span><br><span class="line">3. `/etc/selinux/config`</span><br></pre></td></tr></table></figure>
<h1 id="SELINUX-enforcing"><a href="#SELINUX-enforcing" class="headerlink" title="SELINUX=enforcing"></a>SELINUX=enforcing</h1>SELINUX=disabled # 永久关闭<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 2 关闭防火墙</span><br><span class="line">1. `systemctl stop firewalld`</span><br><span class="line">2. `systemctl disable firewalld`</span><br><span class="line"></span><br><span class="line">### 3 字符编码</span><br><span class="line">1. 修改环境变量 `LANG`（优先级高）</span><br><span class="line">2. 修改 `/etc/locale.conf`</span><br><span class="line">3. `localectl set-locale en_US.UTF-8`</span><br><span class="line"></span><br><span class="line">### 4 优化远程连接速度</span><br><span class="line">1. 修改ssh服务配置文件 `/etc/ssh/sshd_config`</span><br></pre></td></tr></table></figure>
79  GSSAPIAuthentication no<br>116 UseDNS no<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. 配置本地 hosts 文件 `/etc/hosts`</span><br></pre></td></tr></table></figure>
服务器ip 服务器主机名hostname</li>
<li>168.13.24 anyeansan<br>```</li>
<li>重启 ssh 服务<ul>
<li><code>systemctl restart sshd</code></li>
</ul>
</li>
</ol>
<h3 id="4-配置Shell命令提示符样式-PS1"><a href="#4-配置Shell命令提示符样式-PS1" class="headerlink" title="4 配置Shell命令提示符样式 PS1"></a>4 配置Shell命令提示符样式 PS1</h3><h4 id="1-设置格式"><a href="#1-设置格式" class="headerlink" title="1 设置格式"></a>1 设置格式</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>\h</code></td>
<td>hostname（short）</td>
</tr>
<tr>
<td><code>\H</code></td>
<td>hostname（full）</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>current working directory</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>current working directory（basename）</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>24小时格式显示时间 <code>HH:MM:SS</code></td>
</tr>
<tr>
<td><code>\d</code></td>
<td>日期 <code>weekday month date</code></td>
</tr>
<tr>
<td><code>\u</code></td>
<td>当前用户名</td>
</tr>
<tr>
<td><code>\$</code></td>
<td>root 显示 <code>#</code> 普通用户显示 <code>$</code></td>
</tr>
</tbody></table>
<h4 id="2-颜色"><a href="#2-颜色" class="headerlink" title="2 颜色"></a>2 颜色</h4><ul>
<li><code>\[\e[F;Bm\]内容\[\e[0m\]</code><ul>
<li><code>\[\e[F;Bm\]</code><ul>
<li>颜色开始<ul>
<li>F<ul>
<li>表示字体颜色，30~37</li>
</ul>
</li>
<li>B<ul>
<li>表示背景颜色，40~47</li>
</ul>
</li>
</ul>
</li>
<li>特殊显示<ul>
<li>0 关闭颜色</li>
<li>1 高亮</li>
<li>4 下划线</li>
<li>5 闪烁</li>
<li>7 反白</li>
<li>8 颜色不可见</li>
</ul>
</li>
</ul>
</li>
<li><code>\[\e[0m\]</code><ul>
<li>颜色结束</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-式样"><a href="#3-式样" class="headerlink" title="3 式样"></a>3 式样</h3><ol>
<li><code>export PS1=&#39;\[\e[32;1m\][\u@\h \W]\$ \[\e[0m\]&#39;</code></li>
<li><code>export PS1=&#39;\[\e[32;1m\][\u@\h \[\e[34;1m\]\W\[\e[32;1m\]]\$ \[\e[0m\]&#39;</code></li>
</ol>
<h1 id="四-远程连接"><a href="#四-远程连接" class="headerlink" title="四 远程连接"></a>四 远程连接</h1><h2 id="4-1-远程连接软件"><a href="#4-1-远程连接软件" class="headerlink" title="4.1 远程连接软件"></a>4.1 远程连接软件</h2><table>
<thead>
<tr>
<th>软件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>xShell</code></td>
<td>免费（实用）</td>
</tr>
<tr>
<td><code>ScureCRT</code></td>
<td>收费</td>
</tr>
<tr>
<td><code>Putty</code></td>
<td>免费 功能简单</td>
</tr>
</tbody></table>
<h2 id="4-2-xShell-相关配置"><a href="#4-2-xShell-相关配置" class="headerlink" title="4.2 xShell 相关配置"></a>4.2 xShell 相关配置</h2><h3 id="1-窗口外观"><a href="#1-窗口外观" class="headerlink" title="1 窗口外观"></a>1 窗口外观</h3><p><img src="https://gitee.com/3noanswer/npics/raw/master/Linux/xShell/%E7%AA%97%E5%8F%A3%E5%A4%96%E8%A7%82.png" alt=""></p>
<h3 id="2-默认会话属性"><a href="#2-默认会话属性" class="headerlink" title="2 默认会话属性"></a>2 默认会话属性</h3><p><img src="https://gitee.com/3noanswer/npics/raw/master/Linux/xShell/%E9%BB%98%E8%AE%A4%E4%BC%9A%E8%AF%9D%E5%B1%9E%E6%80%A7-01.png" alt=""><br><img src="https://gitee.com/3noanswer/npics/raw/master/Linux/xShell/%E9%BB%98%E8%AE%A4%E4%BC%9A%E8%AF%9D%E5%B1%9E%E6%80%A7-02.png" alt=""><br><img src="https://gitee.com/3noanswer/npics/raw/master/Linux/xShell/%E9%BB%98%E8%AE%A4%E4%BC%9A%E8%AF%9D%E5%B1%9E%E6%80%A7-03.png" alt=""><br><img src="https://gitee.com/3noanswer/npics/raw/master/Linux/xShell/%E9%BB%98%E8%AE%A4%E4%BC%9A%E8%AF%9D%E5%B1%9E%E6%80%A7-04.png" alt=""><br><img src="https://gitee.com/3noanswer/npics/raw/master/Linux/xShell/%E9%BB%98%E8%AE%A4%E4%BC%9A%E8%AF%9D%E5%B1%9E%E6%80%A7-05.png" alt=""><br><img src="https://gitee.com/3noanswer/npics/raw/master/Linux/xShell/%E9%BB%98%E8%AE%A4%E4%BC%9A%E8%AF%9D%E5%B1%9E%E6%80%A7-06.png" alt=""><br><img src="https://gitee.com/3noanswer/npics/raw/master/Linux/xShell/%E9%BB%98%E8%AE%A4%E4%BC%9A%E8%AF%9D%E5%B1%9E%E6%80%A7-07.png" alt=""><br><img src="https://gitee.com/3noanswer/npics/raw/master/Linux/xShell/%E9%BB%98%E8%AE%A4%E4%BC%9A%E8%AF%9D%E5%B1%9E%E6%80%A7-08.png" alt=""></p>
<h3 id="3-使用密钥连接"><a href="#3-使用密钥连接" class="headerlink" title="3 使用密钥连接"></a>3 使用密钥连接</h3><ol>
<li>将公钥上传至服务端 <code>~/.ssh/authorized_keys</code>，权限 <code>600</code></li>
<li>配置 xShell<br><img src="https://gitee.com/3noanswer/npics/raw/master/Linux/xShell/%E5%AF%86%E9%92%A5%E8%BF%9E%E6%8E%A5.png" alt=""></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 命令</title>
    <url>/anyeansan.github.io/2020/03/29/Linux-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="一-帮助命令"><a href="#一-帮助命令" class="headerlink" title="一 帮助命令"></a>一 帮助命令</h1><h2 id="1-1-man（manual）"><a href="#1-1-man（manual）" class="headerlink" title="1.1 man（manual）"></a>1.1 man（manual）</h2><ul>
<li><code>man [OPTION] 命令</code><ul>
<li>查看外部命令的功能 参数 帮助信息等等</li>
<li><code>OPTION</code><ul>
<li><code>1</code><ul>
<li>查看命令帮助文档</li>
</ul>
</li>
<li><code>5</code><ul>
<li>查看配置帮助文档，当命令和配置同名时，使用15来区分，如<code>passwd</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>文档操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>空格, f</code></td>
<td>向下翻页</td>
</tr>
<tr>
<td><code>b</code></td>
<td>向上翻页</td>
</tr>
<tr>
<td><code>回车</code></td>
<td>向下一行</td>
</tr>
<tr>
<td><code>k</code></td>
<td>向上一行</td>
</tr>
<tr>
<td><code>/key</code></td>
<td>向下查找key，n 下一个匹配，N 上一个匹配</td>
</tr>
<tr>
<td><code>?key</code></td>
<td>向上查找key</td>
</tr>
</tbody></table>
<h2 id="1-2-–help"><a href="#1-2-–help" class="headerlink" title="1.2 –help"></a>1.2 –help</h2><ul>
<li><code>命令 --help</code><ul>
<li>查看外部命令帮助</li>
</ul>
</li>
</ul>
<h2 id="1-3-help"><a href="#1-3-help" class="headerlink" title="1.3 help"></a>1.3 help</h2><ul>
<li><code>help 命令</code><ul>
<li>查看shell内置命令的帮助信息，如<code>cd, pwd, history..</code></li>
</ul>
</li>
</ul>
<h1 id="二-开关机命令"><a href="#二-开关机命令" class="headerlink" title="二 开关机命令"></a>二 开关机命令</h1><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>shutdown</code></td>
<td>开启一个一分钟后关机的计划</td>
</tr>
<tr>
<td><code>shutdown -c</code></td>
<td>取消关机计划</td>
</tr>
<tr>
<td><code>shutdown -h Time</code></td>
<td>指定时间关机，Time 可以是 <code>now</code> 或具体时间</td>
</tr>
<tr>
<td><code>shutdown -r Time</code></td>
<td>指定时间重启</td>
</tr>
<tr>
<td><code>systemctl poweroff</code></td>
<td>关机</td>
</tr>
<tr>
<td><code>systemctl reboot</code></td>
<td>重启</td>
</tr>
</tbody></table>
<h1 id="三-其它命令"><a href="#三-其它命令" class="headerlink" title="三 其它命令"></a>三 其它命令</h1><h2 id="3-1-echo（display-a-line-of-text）"><a href="#3-1-echo（display-a-line-of-text）" class="headerlink" title="3.1 echo（display a line of text）"></a>3.1 echo（display a line of text）</h2><ul>
<li><code>echo [OPTION] String</code><ul>
<li>显示文本</li>
<li><code>OPTION</code><ul>
<li><code>-n</code><ul>
<li>不换行输出</li>
</ul>
</li>
<li><code>-e</code><ul>
<li>支持转义字符<code>\b \t \r \n \e(escape键)...</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-2-xargs"><a href="#3-2-xargs" class="headerlink" title="3.2 xargs"></a>3.2 xargs</h2><ul>
<li><code>xargs [OPTION] &lt; input</code><ul>
<li>将标准输入的所有行一行显示，xargs 会自动忽略别名</li>
<li><code>OPTION</code><ul>
<li><code>-n num</code><ul>
<li>每一行显示原num行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-3-column"><a href="#3-3-column" class="headerlink" title="3.3 column"></a>3.3 column</h2><ul>
<li><code>column -t</code><ul>
<li>按表格显示</li>
</ul>
</li>
</ul>
<h2 id="3-4-tr"><a href="#3-4-tr" class="headerlink" title="3.4 tr"></a>3.4 tr</h2><ul>
<li><code>tr  oldStr newStr</code><ul>
<li>从标准输入中替换、缩减或删除字符，并将结果写到标准输出</li>
<li>tr 是一对一的替换<ol>
<li>oldStr 字符数 &lt; newStr 字符数，多的新字符忽略，如 <code>echo &quot;abc&quot;|tr &quot;abc&quot; &quot;12345&quot;</code>，结果为 123</li>
<li>oldStr 字符数 &gt; newStr 字符数，多的旧字符都用最后一个新字符替换，如 <code>echo &quot;abcde&quot;|tr &quot;abcde&quot; &quot;123&quot;</code>，结果为 12333</li>
<li>如果 oldStr 中有重复字符则使用最后一个对应的新字符，如<code>echo &quot;abcdba|tr &quot;abcdba&quot; &quot;123456&quot;</code>，结果为 653456        </li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="3-5-tee"><a href="#3-5-tee" class="headerlink" title="3.5 tee"></a>3.5 tee</h2><ul>
<li><code>tee [-a] File</code><ul>
<li>读取标准输入的数据，并将其内容输出成文件</li>
<li><code>-a</code><ul>
<li>追加`</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-6-read"><a href="#3-6-read" class="headerlink" title="3.6 read"></a>3.6 read</h2><ul>
<li><code>read [OPTION] 变量名</code><ul>
<li>接收标准输入并赋值给变量</li>
<li><code>OPTION</code><ul>
<li><code>-p &quot;提示信息&quot;</code><ul>
<li>在等待read输入时，输出提示信息</li>
</ul>
</li>
<li><code>-t 秒数</code><ul>
<li>read命令会一直等待用户输入，指定等待时间</li>
</ul>
</li>
<li><code>-n 字符数</code><ul>
<li>read命令只接受指定的字符数</li>
</ul>
</li>
<li><code>-s</code><ul>
<li>隐藏输入的数据，适用于机密信息的输入</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-7-cut"><a href="#3-7-cut" class="headerlink" title="3.7 cut"></a>3.7 cut</h2><ul>
<li><code>cut [OPTION] [File]</code><ul>
<li>按“列”提取文本字符</li>
<li><code>OPTION</code><ul>
<li><code>-f 列号</code><ul>
<li>提取第几列</li>
</ul>
</li>
<li><code>-d 分隔符</code><ul>
<li>按照指定分隔符分割列</li>
<li>默认为制表符</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-8-sort"><a href="#3-8-sort" class="headerlink" title="3.8 sort"></a>3.8 sort</h2><ul>
<li><code>sort [OPTION] [File]</code><ul>
<li><code>OPTION</code><ul>
<li><code>-f, --ignore-case</code><ul>
<li>忽略大小写</li>
</ul>
</li>
<li><code>-n, --numeric-sort</code><ul>
<li>依照数值的大小排序</li>
</ul>
</li>
<li><code>-r, --reverse</code><ul>
<li>反向排序</li>
</ul>
</li>
<li><code>-t, --field-separator=SEP</code><ul>
<li>指定排序时所用的分隔符</li>
</ul>
</li>
<li><code>-k n[,m]</code><ul>
<li>按照指定的字段范围排序。从第n字段开始，m字段结束（默认到行尾）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-9-history"><a href="#3-9-history" class="headerlink" title="3.9 history"></a>3.9 history</h2><ul>
<li><code>history [OPTION] [历史命令保存文件]</code><ul>
<li><code>OPTION</code><ul>
<li><code>-c</code><ul>
<li>清空历史命令</li>
</ul>
</li>
<li><code>-w</code><ul>
<li>把缓存中的历史命令写入历史命令保存文件</li>
<li>默认用户正常退出后才会保存</li>
<li>默认保存在家目录下<code>~/.bash_history</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-10-dd"><a href="#3-10-dd" class="headerlink" title="3.10 dd"></a>3.10 dd</h2><ul>
<li><code>dd if=输入文件 of=输出文件 bs=块大小 count=块个数</code><ul>
<li>按照指定大小和个数的数据块来复制文件或转换文件</li>
<li><code>if</code>（input file）<ul>
<li>指定输入文件或设备</li>
<li>如果不指定if，默认就会从 stdin 中读取输入</li>
</ul>
</li>
<li><code>of</code>（output file）<ul>
<li>指定输出文件或设备</li>
<li>如果不指定of，默认就会将 stdout 作为默认输出</li>
</ul>
</li>
<li><code>bs</code>（block size）<ul>
<li>数据块 block 大小，默认单位为 byte</li>
</ul>
</li>
<li><code>count</code><ul>
<li>数据块 block 数量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="四-文件-amp-目录命令"><a href="#四-文件-amp-目录命令" class="headerlink" title="四 文件 &amp; 目录命令"></a>四 文件 &amp; 目录命令</h1><h2 id="4-1-pwd（print-working-directory）"><a href="#4-1-pwd（print-working-directory）" class="headerlink" title="4.1 pwd（print working directory）"></a>4.1 pwd（print working directory）</h2><ul>
<li><code>pwd</code><ul>
<li>显示当前工作目录</li>
</ul>
</li>
</ul>
<h2 id="4-2-cd（change-directory）"><a href="#4-2-cd（change-directory）" class="headerlink" title="4.2 cd（change directory）"></a>4.2 cd（change directory）</h2><ul>
<li><code>cd dir</code><ul>
<li>切换目录</li>
<li><code>dir</code><ul>
<li><code>.</code><ul>
<li>当前目录</li>
</ul>
</li>
<li><code>..</code><ul>
<li>上级目录</li>
</ul>
</li>
<li><code>~</code><ul>
<li>根目录</li>
</ul>
</li>
<li><code>-</code><ul>
<li>前一个目录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-3-mkdir（make-directories）"><a href="#4-3-mkdir（make-directories）" class="headerlink" title="4.3 mkdir（make directories）"></a>4.3 mkdir（make directories）</h2><ul>
<li><code>mkdir [OPTION] dir</code><ul>
<li>创建一个或多个空目录，linux一切皆文件，目录也是文件，目录与文件不能重名</li>
<li><code>OPTION</code><ul>
<li><code>-p, --parents</code><ul>
<li>递归创建</li>
<li>目录有多层时，如果父目录不存在，首先创建父目录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-4-ls（list-directory-contents）"><a href="#4-4-ls（list-directory-contents）" class="headerlink" title="4.4 ls（list directory contents）"></a>4.4 ls（list directory contents）</h2><ul>
<li><code>ls [OPTION] [File]</code><ul>
<li>显示文件名或者目录下的内容（默认为当前目录）</li>
<li><code>OPTION</code><ul>
<li><code>-a</code>, <code>--all</code><ul>
<li>显示目录下所有文件，包含隐藏文件（以 <code>.</code> 开头的文件）</li>
</ul>
</li>
<li><code>-A</code>, <code>--almost-all</code><ul>
<li>同 <code>-a</code> 但不包含 <code>.</code> 和 <code>..</code></li>
</ul>
</li>
<li><code>-l</code><ul>
<li>显示详细信息</li>
</ul>
</li>
<li><code>-d</code>, <code>--directory</code><ul>
<li>显示目录本身的信息（而非目录下的内容）</li>
</ul>
</li>
<li><code>-t</code><ul>
<li>根据最后修改时间排序，newest first</li>
</ul>
</li>
<li><code>-r</code>, <code>--reverse</code><ul>
<li>反向排序</li>
</ul>
</li>
<li><code>-h</code>, <code>--human-readable</code><ul>
<li>以人类可读的信息显示大小</li>
</ul>
</li>
<li><code>-S</code><ul>
<li>文件从大到小排序</li>
</ul>
</li>
<li><code>-i</code>, <code>--inode</code><ul>
<li>显示inode number</li>
</ul>
</li>
<li><code>p</code><ul>
<li>区分文件和目录（目录名后添加 <code>/</code>）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-5-tree（list-contents-of-directories-in-a-tree-like-format）"><a href="#4-5-tree（list-contents-of-directories-in-a-tree-like-format）" class="headerlink" title="4.5 tree（list contents of directories in a tree-like format）"></a>4.5 tree（list contents of directories in a tree-like format）</h2><ul>
<li><code>tree [OPTION] dir</code><ul>
<li>树形显示目录，需要安装 <code>tree</code> 软件</li>
<li><code>OPTION</code><ul>
<li><code>-L level</code><ul>
<li>指定显示层级，如<code>-L 1</code> 显示一层</li>
</ul>
</li>
<li><code>-d</code><ul>
<li>只显示目录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-6-touch（change-file-timestamps）"><a href="#4-6-touch（change-file-timestamps）" class="headerlink" title="4.6 touch（change file timestamps）"></a>4.6 touch（change file timestamps）</h2><ul>
<li><code>touch File</code><ul>
<li>创建一个或多个空文件，如果文件存在则修改文件的最后访问时间和最后修改时间</li>
<li><code>File</code><ul>
<li>可以使用区间 <code>{begin..end}</code></li>
<li>如<code>touch {1..10}.txt</code>，即创建<code>1.txt 2.txt ...10.txt</code>10个文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-7-cp（copy-files-and-directories）"><a href="#4-7-cp（copy-files-and-directories）" class="headerlink" title="4.7 cp（copy files and directories）"></a>4.7 cp（copy files and directories）</h2><ul>
<li><code>cp [OPTION] Source Destdir</code><ul>
<li>复制一个或多个文件到指定目录</li>
<li><code>OPTION</code><ul>
<li><code>-r</code>, <code>--recursive</code><ul>
<li>递归复制，用于复制目录</li>
</ul>
</li>
<li><code>-p</code><ul>
<li>复制时保留文件属性（所有者、权限信息、时间…）</li>
</ul>
</li>
<li><code>-d</code><ul>
<li>复制时保留链接</li>
</ul>
</li>
<li><code>-a</code><ul>
<li>等同于 <code>-dpr</code> </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>cp test.txt{,.bak}</code><ul>
<li>例用 <code>{}</code> 的结合特性快捷复制，等价于 <code>cp test.txt test.txt.bak</code></li>
</ul>
</li>
</ul>
<h2 id="4-8-rm（remove-empty-directories）"><a href="#4-8-rm（remove-empty-directories）" class="headerlink" title="4.8 rm（remove empty directories）"></a>4.8 rm（remove empty directories）</h2><ul>
<li><code>rm [OPTION] File</code><ul>
<li>删除一个或多个文件</li>
<li><code>OPTION</code><ul>
<li><code>-r</code>, <code>--recursive</code><ul>
<li>递归删除，用于删除目录</li>
</ul>
</li>
<li><code>-f</code>, <code>--force</code><ul>
<li>确认</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-9-mv（move-rename-files）"><a href="#4-9-mv（move-rename-files）" class="headerlink" title="4.9 mv（move (rename) files）"></a>4.9 mv（move (rename) files）</h2><ul>
<li><code>mv Source Dest</code><ul>
<li>如果不在同一个目录则是剪切</li>
<li>如果在同一个目录则是重命名</li>
</ul>
</li>
</ul>
<h2 id="4-10-cat（concatenate-files-and-print-on-the-standard-output）"><a href="#4-10-cat（concatenate-files-and-print-on-the-standard-output）" class="headerlink" title="4.10 cat（concatenate files and print on the standard output）"></a>4.10 cat（concatenate files and print on the standard output）</h2><ul>
<li><code>cat [OPTION] File</code><ul>
<li>查看文件内容</li>
<li><code>OPTION</code><ul>
<li><code>-n</code>, <code>--number</code><ul>
<li>显示行号</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>tac File</code><ul>
<li>反向查看内容</li>
</ul>
</li>
</ul>
<h2 id="4-11-more（file-perusal-filter-for-crt-viewing）"><a href="#4-11-more（file-perusal-filter-for-crt-viewing）" class="headerlink" title="4.11 more（file perusal filter for crt viewing）"></a>4.11 more（file perusal filter for crt viewing）</h2><ul>
<li><code>more File</code><ul>
<li>分页显示内容，只能向下</li>
</ul>
</li>
</ul>
<h2 id="4-12-less（opposite-of-more）"><a href="#4-12-less（opposite-of-more）" class="headerlink" title="4.12 less（opposite of more）"></a>4.12 less（opposite of more）</h2><ul>
<li><code>less [OPTION] File</code><ul>
<li>分页显示内容，可向上向下</li>
<li><code>OPTION</code><ul>
<li><code>-N</code>, <code>--LINE-NUMBERS</code><ul>
<li>显示行号</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>f</code></td>
<td>下一页</td>
</tr>
<tr>
<td><code>b</code></td>
<td>上一页</td>
</tr>
<tr>
<td><code>回车</code></td>
<td>下一行</td>
</tr>
<tr>
<td><code>k</code></td>
<td>上一行</td>
</tr>
<tr>
<td><code>g</code></td>
<td>跳到第一行</td>
</tr>
<tr>
<td><code>G</code></td>
<td>跳到最后一行</td>
</tr>
<tr>
<td><code>p num%</code></td>
<td>跳到百分之num</td>
</tr>
</tbody></table>
<h2 id="4-13-head（output-the-first-part-of-files）"><a href="#4-13-head（output-the-first-part-of-files）" class="headerlink" title="4.13 head（output the first part of files）"></a>4.13 head（output the first part of files）</h2><ul>
<li><code>head [OPTION] File</code><ul>
<li>默认显示前10行</li>
<li><code>OPTION</code><ul>
<li><code>-n</code><ul>
<li>显示前 n 行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-14-tail（output-the-last-part-of-files）"><a href="#4-14-tail（output-the-last-part-of-files）" class="headerlink" title="4.14 tail（output the last part of files）"></a>4.14 tail（output the last part of files）</h2><ul>
<li><code>tail [OPTION] file</code><ul>
<li>默认显示后10行</li>
<li><code>OPTION</code><ul>
<li><code>-n</code><ul>
<li>显示后n行</li>
</ul>
</li>
<li><code>-f</code>, <code>--follow</code><ul>
<li>实时监控文件尾部变化，如查看日志</li>
<li>如果文件被删除或移动，没有信息提示，想要监控需要重新追踪</li>
</ul>
</li>
<li><code>-F</code><ul>
<li>实时监控文件尾部变化</li>
<li>如果文件被删除或移动，有信息提示，如果文件恢复会继续追踪</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-15-file（determine-file-type）"><a href="#4-15-file（determine-file-type）" class="headerlink" title="4.15 file（determine file type）"></a>4.15 file（determine file type）</h2><ul>
<li><code>file [OPTION] File</code><ul>
<li>查看文件类型及编码</li>
<li><code>OPTION</code><ul>
<li><code>-i</code><ul>
<li>查看文件MIME类型及编码</li>
</ul>
</li>
<li><code>-L</code><ul>
<li>查看软链接文件时，查看的是软链接指向的目标文件的信息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-16-diff（compare-files-line-by-line）"><a href="#4-16-diff（compare-files-line-by-line）" class="headerlink" title="4.16 diff（compare files line by line）"></a>4.16 diff（compare files line by line）</h2><ul>
<li><code>diff [OPTION] File</code><ul>
<li>比较文件内容的差异</li>
<li><code>OPTION</code><ul>
<li><code>-q</code><ul>
<li>仅输出文件是否有差异，不报告详细差异</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-17-stat"><a href="#4-17-stat" class="headerlink" title="4.17 stat"></a>4.17 stat</h2><ul>
<li><code>stat File</code><ul>
<li>查看文件 inode 信息</li>
</ul>
</li>
</ul>
<h2 id="4-18-wc"><a href="#4-18-wc" class="headerlink" title="4.18 wc"></a>4.18 wc</h2><ul>
<li><code>wc [OPTION] FILE | Input</code><ul>
<li>统计行数、字数、字节数</li>
<li><code>OPTION</code><ul>
<li><code>-c</code><ul>
<li>统计字节数</li>
</ul>
</li>
<li><code>-w</code><ul>
<li>统计单词数</li>
</ul>
</li>
<li><code>-l</code><ul>
<li>统计行数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-19-rename"><a href="#4-19-rename" class="headerlink" title="4.19 rename"></a>4.19 rename</h2><ul>
<li><code>rename expr replacement File</code><ul>
<li>将替换文件中匹配部分</li>
<li><code>expr</code><ul>
<li>File 中需要重命名的部分</li>
</ul>
</li>
<li><code>replacement</code><ul>
<li>expression 修改成的结果</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="五-时间命令"><a href="#五-时间命令" class="headerlink" title="五 时间命令"></a>五 时间命令</h1><h2 id="5-1-date"><a href="#5-1-date" class="headerlink" title="5.1 date"></a>5.1 date</h2><ul>
<li><code>date [OPTION] [Format]</code><ul>
<li>以默认格式查看时间</li>
<li><code>OPTION</code><ul>
<li><code>-s</code><ul>
<li>修改时间</li>
</ul>
</li>
</ul>
</li>
<li><code>Format</code><ul>
<li><code>&quot;+%y-%m-%d %H:%M:%S&quot;</code><ul>
<li><code>Y-M-D H:M:S</code></li>
</ul>
</li>
<li><code>+%F</code><ul>
<li><code>full date</code> 等价于 <code>%Y-%m-%d</code></li>
</ul>
</li>
<li><code>+%T</code><ul>
<li><code>time</code> 等价于 <code>%H:%M:%S</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-2-ntpdate"><a href="#5-2-ntpdate" class="headerlink" title="5.2 ntpdate"></a>5.2 ntpdate</h2><ul>
<li><code>ntpdate ip</code><ul>
<li>时间同步，需要安装 <code>ntpdate</code> 软件包</li>
<li><code>ip</code>（ntp 服务器）<ul>
<li><code>ntp.aliyun.com</code></li>
<li><code>cn.pool.ntp.org</code></li>
<li><code>cn.ntp.org.cn</code></li>
<li><code>time.asia.apple.com</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="六-打包压缩解压命令"><a href="#六-打包压缩解压命令" class="headerlink" title="六 打包压缩解压命令"></a>六 打包压缩解压命令</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><ol>
<li>Linux 中打包文件一般以 <code>.tar</code> 结尾，压缩命令一般以<code>.gz</code>结尾</li>
<li>通常打包和压缩是一起进行的，打包并压缩后的文件后缀一般为 <code>.tar.gz</code></li>
</ol>
<h2 id="6-2-打包压缩"><a href="#6-2-打包压缩" class="headerlink" title="6.2 打包压缩"></a>6.2 打包压缩</h2><ul>
<li><code>tar -zcvf 压缩包 文件</code><ul>
<li>将一个或多个文件打包压缩</li>
<li><code>-z, --gzip</code><ul>
<li>使用Gzip压缩，后缀名建议<code>.tar.gz</code></li>
</ul>
</li>
<li><code>-c, --create</code><ul>
<li>创建压缩包文件</li>
</ul>
</li>
<li><code>-v, --verbose</code><ul>
<li>显示过程</li>
</ul>
</li>
<li><code>-f, --file=</code><ul>
<li>指定压缩包文件路径</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-3-解压"><a href="#6-3-解压" class="headerlink" title="6.3 解压"></a>6.3 解压</h2><ul>
<li><code>tar -xvf 压缩包 [-C 解压路径]</code><ul>
<li>默认解压到当前路径</li>
<li><code>x</code>, <code>--extract</code>, <code>--get</code><ul>
<li>解压</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-4-查看压缩包中的文件"><a href="#6-4-查看压缩包中的文件" class="headerlink" title="6.4 查看压缩包中的文件"></a>6.4 查看压缩包中的文件</h2><ul>
<li><code>tar -tf 压缩包</code><ul>
<li><code>-t</code>, <code>--list</code></li>
</ul>
</li>
</ul>
<h1 id="七-搜索命令"><a href="#七-搜索命令" class="headerlink" title="七 搜索命令"></a>七 搜索命令</h1><h2 id="7-1-find（search-for-files-in-a-directory-hierarchy）"><a href="#7-1-find（search-for-files-in-a-directory-hierarchy）" class="headerlink" title="7.1 find（search for files in a directory hierarchy）"></a>7.1 find（search for files in a directory hierarchy）</h2><ul>
<li><code>find [路径] [条件] [操作]</code><ul>
<li>在指定路径根据条件查找文件，并对找到的文件执行指定操作</li>
<li><code>路径</code><ul>
<li>find 命令查找路径，默认为当前目录</li>
</ul>
</li>
<li><code>条件</code><ul>
<li>查找的条件，可以有多个</li>
<li><code>-a</code><ul>
<li>多个条件 逻辑与 关系，默认</li>
</ul>
</li>
<li><code>-o</code><ul>
<li>逻辑或</li>
</ul>
</li>
<li><code>-not</code><ul>
<li>逻辑非</li>
</ul>
</li>
</ul>
</li>
<li><code>操作</code><ul>
<li><code>-print</code><ul>
<li>打印找到的结果，默认</li>
</ul>
</li>
<li><code>-exec 命令 {} \;</code><ul>
<li>对匹配的结果逐个执行命令<ul>
<li><code>{}</code><ul>
<li>代表查到的内容</li>
</ul>
</li>
<li><code>\;</code><ul>
<li>匹配的文件可能有多个，即要执行多次命令，用分号隔开</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>条件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-name Pattern</code></td>
<td>根据文件名查找（精准匹配，可以用正则）</td>
</tr>
<tr>
<td><code>-iname Pattern</code></td>
<td>根据文件名查找，不区分大小写</td>
</tr>
<tr>
<td><code>-perm Mode</code></td>
<td>根据文件权限查找</td>
</tr>
<tr>
<td><code>-user User</code></td>
<td>根据文件属主查找</td>
</tr>
<tr>
<td><code>-group Group</code></td>
<td>根据文件属组查找</td>
</tr>
<tr>
<td><code>-type Type</code></td>
<td>根据文件类型查找</td>
</tr>
<tr>
<td><code>-size n/+n/-n</code></td>
<td>根据文件大小查找</td>
</tr>
<tr>
<td><code>-atime/ctime/mtime n/-n/+n</code></td>
<td>根据文件时间查找</td>
</tr>
<tr>
<td><code>-inum Num</code></td>
<td>根据文件 inode 号查找</td>
</tr>
<tr>
<td><code>-maxdepth level</code></td>
<td>指定目录查找层次深度</td>
</tr>
</tbody></table>
<h2 id="7-2-locate（find-files-by-name）"><a href="#7-2-locate（find-files-by-name）" class="headerlink" title="7.2 locate（find files by name）"></a>7.2 locate（find files by name）</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>此命令需要安装 <code>mlocate</code> 软件包</li>
<li>建立文件索引数据库，快速查找文件位置</li>
<li><code>/var/lib/mlocate/mlocate.db</code><ul>
<li>维护的数据库（文件资料库）</li>
</ul>
</li>
<li><code>/tmp</code> 不在数据库范围</li>
</ol>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h3><ol>
<li><code>updatedb</code><ul>
<li>更新数据库（建立文件和目录结构的对应关系）</li>
<li>如果没有更新过或者是新建立的文件，文件资料库没有，使用locate查找不到</li>
</ul>
</li>
<li><code>locate File</code><ul>
<li>查找文件绝对路径</li>
</ul>
</li>
</ol>
<h2 id="7-3-which（shows-the-full-path-of-shell-commands）"><a href="#7-3-which（shows-the-full-path-of-shell-commands）" class="headerlink" title="7.3 which（shows the full path of (shell) commands）"></a>7.3 which（shows the full path of (shell) commands）</h2><ul>
<li><code>which Command</code><ul>
<li>查看命令文件的绝对路径及别名信息</li>
<li>查找的范围是 <code>PATH</code> 所配置的路径</li>
</ul>
</li>
</ul>
<h2 id="7-4-whereis（locate-the-binary-source-and-manual-page-files-for-a-command）"><a href="#7-4-whereis（locate-the-binary-source-and-manual-page-files-for-a-command）" class="headerlink" title="7.4 whereis（locate the binary, source, and manual page files for a command）"></a>7.4 whereis（locate the binary, source, and manual page files for a command）</h2><ul>
<li><code>whereis Command</code><ul>
<li>查看命令文件的绝对路径及相关帮助文档绝对路径</li>
</ul>
</li>
</ul>
<h1 id="八-磁盘命令"><a href="#八-磁盘命令" class="headerlink" title="八 磁盘命令"></a>八 磁盘命令</h1><h2 id="8-1-df（report-file-system-disk-space-usage）"><a href="#8-1-df（report-file-system-disk-space-usage）" class="headerlink" title="8.1 df（report file system disk space usage）"></a>8.1 df（report file system disk space usage）</h2><ul>
<li><code>df [OPTION] [File]</code><ul>
<li>查看文件系统的磁盘空间使用信息及挂载信息</li>
<li><code>OPTION</code><ul>
<li><code>-a, --all</code><ul>
<li>显示所有文件系统信息，包括系统特有的 /proc、/sysfs 等文件系统</li>
</ul>
</li>
<li><code>-h, --human-readable</code><ul>
<li>使用人们习惯的 KB、MB 或 GB 等单位自行显示容量</li>
</ul>
</li>
<li><code>-k</code><ul>
<li>以 KB 为单位显示容量（默认）</li>
</ul>
</li>
<li><code>-m</code><ul>
<li>以 MB 为单位显示容量</li>
</ul>
</li>
<li><code>-T, --print-type</code><ul>
<li>显示文件系统类型</li>
</ul>
</li>
<li><code>-i, --inodes</code><ul>
<li>不用硬盘容量显示，而是以含有 inode 的数量来显示</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="8-2-du（disk-usage）"><a href="#8-2-du（disk-usage）" class="headerlink" title="8.2 du（disk usage）"></a>8.2 du（disk usage）</h2><ul>
<li><code>du [OPTION] [File]</code><ul>
<li>统计目录或文件所占磁盘空间大小</li>
<li>如果是目录，默认显示目录和子目录的磁盘占用量</li>
<li><code>OPTION</code><ul>
<li><code>-a, --all</code><ul>
<li>显示目录、子目录和子文件的磁盘占用量</li>
</ul>
</li>
<li><code>-s, --summarize</code><ul>
<li>只统计总磁盘占用量，而不列出子目录和子文件的磁盘占用量</li>
<li>即只显示目录的磁盘占用量</li>
</ul>
</li>
<li><code>-h, --human-readable</code><ul>
<li>以人类可读的单位显示磁盘占用量</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><ol>
<li><code>ls -l</code> 命令统计的是目录下的子文件名称和子目录名称所占大小</li>
<li><code>du</code> 命令统计占用磁盘空间</li>
<li>文件大小<ul>
<li>文件的实际大小，比如 <code>13KB</code></li>
</ul>
</li>
<li>文件占用磁盘空间<ol>
<li>文件占用磁盘空间取决于文件系统的 block 大小（linux 默认为 4 KB）</li>
<li>1 个block 只能被 1 个文件占用，如果 1 个 block 没有占满，其它空间也不能存储其它文件</li>
<li>1 个文件大小是 <code>13 KB</code>，<code>13 / 4 = 3.25</code>，文件占用磁盘空间就是 4 个block 即 <code>16 KB</code></li>
</ol>
</li>
</ol>
<h1 id="九-网络命令"><a href="#九-网络命令" class="headerlink" title="九 网络命令"></a>九 网络命令</h1><h2 id="9-1-curl"><a href="#9-1-curl" class="headerlink" title="9.1 curl"></a>9.1 curl</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>crul url</code></td>
<td>访问一个网址，获取该网址的文本信息</td>
</tr>
<tr>
<td><code>curl -i url</code></td>
<td>获取该网址的文本信息以及协议头部信息</td>
</tr>
<tr>
<td><code>curl -I url</code></td>
<td>只获取请求头</td>
</tr>
<tr>
<td><code>curl -O url</code></td>
<td>下载指定资源到当前目录，名称默认，<code>--progress</code> 显示进度</td>
</tr>
<tr>
<td><code>curl -o name url</code></td>
<td>下载指定资源到当前目录，名称name，</td>
</tr>
</tbody></table>
<h2 id="9-2-wget"><a href="#9-2-wget" class="headerlink" title="9.2 wget"></a>9.2 wget</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>wget url</code></td>
<td>下载文件</td>
</tr>
<tr>
<td><code>wget -O name url</code></td>
<td>下载文件并指定名称为name</td>
</tr>
</tbody></table>
<h2 id="9-3-net-tools-amp-iproute2"><a href="#9-3-net-tools-amp-iproute2" class="headerlink" title="9.3 net-tools &amp; iproute2"></a>9.3 net-tools &amp; iproute2</h2><p><img src="https://gitee.com/3noanswer/npics/raw/master/Linux/Linux-Nettools-vs-Iproute2.webp" alt=""></p>
<h3 id="1-netstat"><a href="#1-netstat" class="headerlink" title="1 netstat"></a>1 netstat</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>netstat -lntup</code></td>
<td>查看本机监听的端口</td>
</tr>
<tr>
<td><code>netstat -an</code></td>
<td>查看本机所有的网络连接</td>
</tr>
<tr>
<td><code>netstat -rn</code></td>
<td>查看本机路由表</td>
</tr>
</tbody></table>
<h3 id="2-route"><a href="#2-route" class="headerlink" title="2 route"></a>2 route</h3><h4 id="1-查"><a href="#1-查" class="headerlink" title="1 查"></a>1 查</h4><ul>
<li><code>route [-nee]</code><ul>
<li>查看路由表信息</li>
<li><code>-n</code><ul>
<li>不使用名字而使用IP和Port</li>
</ul>
</li>
<li><code>-ee</code><ul>
<li>更详细的信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-增删默认路由"><a href="#2-增删默认路由" class="headerlink" title="2 增删默认路由"></a>2 增删默认路由</h4><ol>
<li><code>route add/del  default gw 网关</code></li>
<li><code>route add/del  default dev 接口</code></li>
</ol>
<h4 id="3-增删网络路由"><a href="#3-增删网络路由" class="headerlink" title="3 增删网络路由"></a>3 增删网络路由</h4><ol>
<li><code>route add/del -net 目标网络地址 netmask 子网掩码 gw 网关</code></li>
<li><code>route add/del -net 目标网络地址 netmask 子网掩码 dev 接口</code></li>
</ol>
<h4 id="4-增删主机路由"><a href="#4-增删主机路由" class="headerlink" title="4 增删主机路由"></a>4 增删主机路由</h4><ol>
<li><code>route add/del -host 目标主机地址 netmask 子网掩码 gw 网关</code></li>
<li><code>route add/del -host 目标主机地址 netmask 子网掩码 dev 接口</code></li>
</ol>
<h3 id="3-ip"><a href="#3-ip" class="headerlink" title="3 ip"></a>3 ip</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ip addr show [eth0]</code></td>
<td>显示网卡及配置的地址信息</td>
</tr>
<tr>
<td><code>ip addr add/del IP/子网掩码 dev 网卡接口</code></td>
<td>临时添加删除IP</td>
</tr>
<tr>
<td><code>ip link set eth0 up/down</code></td>
<td>启用/禁用网卡</td>
</tr>
<tr>
<td><code>ip route show</code></td>
<td>查看策略路由，路由表 <code>/etc/iproute2/rt_tables</code></td>
</tr>
<tr>
<td><code>ip route get IP</code></td>
<td>通过IP地址查询路由包从哪条路由来</td>
</tr>
<tr>
<td><code>ip route add/del default via 网关</code></td>
<td>增删默认路由</td>
</tr>
<tr>
<td><code>ip route add/del -net 目标网络地址 netmask 子网掩码 via 网关</code></td>
<td>增删网络路由</td>
</tr>
<tr>
<td><code>ip route add/del -host 目标主机地址 netmask 子网掩码 via 网关</code></td>
<td>增删主机路由</td>
</tr>
<tr>
<td><code>ip -s link</code></td>
<td>显示所有网络接口的统计数据</td>
</tr>
<tr>
<td><code>ip -s -s link ls 网卡接口</code></td>
<td>获取一个特定网络接口的信息</td>
</tr>
</tbody></table>
<h3 id="4-ss"><a href="#4-ss" class="headerlink" title="4 ss"></a>4 ss</h3><ul>
<li><code>ss -lntup</code><ul>
<li>查看本机监听的端口</li>
</ul>
</li>
</ul>
<h1 id="十-三剑客"><a href="#十-三剑客" class="headerlink" title="十 三剑客"></a>十 三剑客</h1><h2 id="10-1-grep（print-lines-matching-a-pattern）"><a href="#10-1-grep（print-lines-matching-a-pattern）" class="headerlink" title="10.1 grep（print lines matching a pattern）"></a>10.1 grep（print lines matching a pattern）</h2><ul>
<li><code>grep [OPTION] Pattern [File]</code><ul>
<li>打印匹配行</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>OPTION</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-v, --invert-match</code></td>
<td>反向选择，即仅列出不匹配的行</td>
</tr>
<tr>
<td><code>-i</code>, <code>--ignore-case</code></td>
<td>忽略大小写</td>
</tr>
<tr>
<td><code>-n</code>, <code>--line-number</code></td>
<td>显示在原文件中的行号</td>
</tr>
<tr>
<td><code>-w</code>, <code>--word-regexp</code></td>
<td>单词必须完全匹配</td>
</tr>
<tr>
<td><code>-c</code>, <code>--count</code></td>
<td>统计匹配的行数</td>
</tr>
<tr>
<td><code>-o</code>, <code>--only-matching</code></td>
<td>只输出匹配内容，而非行</td>
</tr>
<tr>
<td><code>-E</code>, <code>--extended-regexp</code></td>
<td>扩展的grep，等同于 <code>egrep</code></td>
</tr>
<tr>
<td><code>-A num</code>, <code>--after-context=num</code></td>
<td>显示匹配行及其之后的 num 行</td>
</tr>
<tr>
<td><code>-B num</code>, <code>--before-context=num</code></td>
<td>显示匹配行及其之前的 num 行</td>
</tr>
<tr>
<td><code>-C num</code>, <code>num</code>, <code>--context=num</code></td>
<td>显示匹配行及其前后 num 行</td>
</tr>
</tbody></table>
<h2 id="10-2-sed（stream-editor-for-filtering-and-transforming-text）"><a href="#10-2-sed（stream-editor-for-filtering-and-transforming-text）" class="headerlink" title="10.2 sed（stream editor for filtering and transforming text）"></a>10.2 sed（stream editor for filtering and transforming text）</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>sed 是一种几乎包括在所有 UNIX 平台的轻量级流编辑器。</li>
<li>sed主要是用来对文本数据增、删、改、查。（以<strong>行</strong>为单位）</li>
</ol>
<h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2 原理"></a>2 原理</h3><ol>
<li>Sed默认并不直接修改源文件，而是将一行内容读取到内存中（模式空间 <code>pattern space</code>），然后判断内容是否符合条件，如果不符合则读取下一行，如果符合则执行相应指令。</li>
<li>所有的指令操作执行后，模式空间的内容默认输出至标准输出(即屏幕上)</li>
</ol>
<h3 id="3-语法"><a href="#3-语法" class="headerlink" title="3 语法"></a>3 语法</h3><ul>
<li><code>sed [OPTION] [address] command [File]</code><ul>
<li><code>OPTION</code><ul>
<li><code>-n</code><ul>
<li>sed 默认会完整输出所有内容</li>
<li><code>-n</code> 表示只输出经过sed命令处理的行</li>
</ul>
</li>
<li><code>-e script</code><ul>
<li>允许多个脚本指令被执行<ul>
<li><code>-e script1 -e script2</code></li>
<li><code>script1;scrpt2</code></li>
</ul>
</li>
</ul>
</li>
<li><code>-f script-file</code><ul>
<li>从文件中读取脚本指令</li>
</ul>
</li>
<li><code>-r</code><ul>
<li>识别扩展正则表达式</li>
</ul>
</li>
<li><code>-i[suffix]</code><ul>
<li>慎用，直接修改源文件（将内存中的信息覆盖到磁盘）</li>
<li>注意：<code>i</code> 和 <code>n</code> 一起使用相当于清空，因为 n 不输出内容</li>
<li><code>suffix</code><ul>
<li>代表为原文件生成一个指定后缀的备份文件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>address</code> （默认为全文）<ul>
<li><code>-number</code><ul>
<li>指定行号number</li>
</ul>
</li>
<li><code>$</code><ul>
<li>表示最后一行</li>
</ul>
</li>
<li><code>-first~step</code><ul>
<li>指定以first开始，步长为step</li>
</ul>
</li>
<li><code>addr1,addr2</code><ul>
<li>匹配从addr1到addr2的所有行</li>
</ul>
</li>
<li><code>addr1,+N</code><ul>
<li>匹配地址1以及后面的N行</li>
</ul>
</li>
<li><code>/regexp/</code><ul>
<li>正则</li>
</ul>
</li>
</ul>
</li>
<li><code>command</code><ul>
<li><code>p</code><ul>
<li>打印</li>
</ul>
</li>
<li><code>a</code><ul>
<li>在当前行下一行添加，可以使用 <code>\n</code> 来添加多行</li>
</ul>
</li>
<li><code>i</code><ul>
<li>在当前行上一行添加，可以使用 <code>\n</code> 来添加多行</li>
</ul>
</li>
<li><code>d</code><ul>
<li>删除指定行</li>
</ul>
</li>
<li><code>c</code><ul>
<li>替换指定行</li>
</ul>
</li>
<li><code>s</code><ul>
<li>替换字符串</li>
<li><code>s/pattern/replacement/flags</code><ul>
<li><code>replacment</code><ul>
<li><code>&amp;</code><ul>
<li>代表正则所匹配的内容</li>
</ul>
</li>
<li><code>\num</code><ul>
<li>引用num组</li>
</ul>
</li>
</ul>
</li>
<li><code>flags</code><ul>
<li><code>g</code><ul>
<li>对一行中所有匹配替换（默认只替换第一个匹配）</li>
</ul>
</li>
<li><code>n</code><ul>
<li>1~512的数字，表示对一行中第n个匹配替换</li>
</ul>
</li>
<li><code>p</code><ul>
<li>打印模式空间的内容</li>
</ul>
</li>
<li><code>-w file</code><ul>
<li>将模式空间的内容写到文件file中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="10-3-awk（pattern-scanning-and-processing-language）"><a href="#10-3-awk（pattern-scanning-and-processing-language）" class="headerlink" title="10.3 awk（pattern scanning and processing language）"></a>10.3 awk（pattern scanning and processing language）</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>/usr/bin/awk -&gt; /usr/bin/gawk</code><ul>
<li><code>g</code> 代表GNU组织</li>
</ul>
</li>
<li>awk 不仅仅是强大的文本分析工具，还是一种编程语言</li>
<li>awk 主要用来分析文本（以<strong>行</strong>为单位）</li>
</ol>
<h3 id="2-原理-1"><a href="#2-原理-1" class="headerlink" title="2 原理"></a>2 原理</h3><ol>
<li>若有 <code>BEGIN</code> 代码块，则执行一次</li>
<li>awk读取一行内容，判断是否符合条件，若符合则使用相应动作进行处理，否则读取下一行。</li>
<li>若有 <code>END</code> 代码块，则执行一次</li>
</ol>
<h3 id="3-语法-1"><a href="#3-语法-1" class="headerlink" title="3 语法"></a>3 语法</h3><ul>
<li><code>awk [OPTION] BEGIN{} [patten] {action} END{} [file]</code><ul>
<li><code>OPTION</code><ul>
<li><code>-F</code><ul>
<li>指定字段（列）分隔符（默认为空格）</li>
<li>指定分隔符时有加号 <code>+</code> 表示有连续多个分隔符只算一个</li>
<li><code>-F &quot;[分隔符列表]+&quot;</code><ul>
<li>使用多个分隔符</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>BEGIN{}</code><ul>
<li>初始化代码块，只在处理数据前执行一次，可以用来修改内置变量等等</li>
</ul>
</li>
<li><code>END{}</code><ul>
<li>结尾代码块，只在处理数据后执行一次</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-运算符"><a href="#1-运算符" class="headerlink" title="1 运算符"></a>1 运算符</h4><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>?</code></td>
<td>条件表达操作符</td>
</tr>
<tr>
<td><code>&#124;&#124; && !</code></td>
<td>逻辑或 与 非</td>
</tr>
<tr>
<td><code>~</code></td>
<td>匹配，非精确比较（<code>==</code> 是精确比较）</td>
</tr>
<tr>
<td><code>!~</code></td>
<td>不匹配，非精确比较</td>
</tr>
<tr>
<td><code>+ - * / % ++ --</code></td>
<td>算术运算符</td>
</tr>
<tr>
<td><code>= += -= *= /= %=</code></td>
<td>赋值运算符</td>
</tr>
<tr>
<td><code>&lt; &lt;= &gt; &gt;= == !=</code></td>
<td>比较运算符</td>
</tr>
</tbody></table>
<h4 id="2-内置变量"><a href="#2-内置变量" class="headerlink" title="2 内置变量"></a>2 内置变量</h4><table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>FS</code></td>
<td>字段分隔符，默认为空格</td>
</tr>
<tr>
<td><code>NF</code></td>
<td>当前行字段个数，即有多少列，<code>$NF</code> 表示最后一列</td>
</tr>
<tr>
<td><code>NR</code></td>
<td>已经读取的记录数，即当前行是第几行，从1开始</td>
</tr>
<tr>
<td><code>FNR</code></td>
<td>记录总数</td>
</tr>
<tr>
<td><code>FILENAME</code></td>
<td>当前文件名</td>
</tr>
<tr>
<td><code>OFS</code></td>
<td>输出字段分隔符， 默认是空格</td>
</tr>
<tr>
<td><code>ORS</code></td>
<td>输出的记录分隔符，默认是换行符</td>
</tr>
<tr>
<td><code>RS</code></td>
<td>控制记录分隔符，默认为换行符</td>
</tr>
<tr>
<td><code>ARGC</code></td>
<td>命令行参数个数</td>
</tr>
<tr>
<td><code>ARGV</code></td>
<td>命令行参数排列</td>
</tr>
<tr>
<td><code>$0</code></td>
<td>表示整行</td>
</tr>
<tr>
<td><code>$n</code></td>
<td>n&gt;0 代表第n列</td>
</tr>
</tbody></table>
<ul>
<li>自定义变量<ul>
<li><code>awk &#39;name=&quot;zsan&quot;{print name}&#39; file</code></li>
</ul>
</li>
</ul>
<h4 id="3-内置函数"><a href="#3-内置函数" class="headerlink" title="3 内置函数"></a>3 内置函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>gsub(r,s)</code></td>
<td>在整个$0中用s替代r</td>
</tr>
<tr>
<td><code>gsub(r,s,t)</code></td>
<td>在整个t中用s替代r</td>
</tr>
<tr>
<td><code>index(s,t)</code></td>
<td>返回s中字符串t的第一位置</td>
</tr>
<tr>
<td><code>length(s)</code></td>
<td>返回s长度</td>
</tr>
<tr>
<td><code>match(s,r)</code></td>
<td>测试s是否包含匹配r的字符串</td>
</tr>
<tr>
<td><code>split(s,a,fs)</code></td>
<td>在fs上将s分成序列a</td>
</tr>
<tr>
<td><code>sprint(fmt,exp)</code></td>
<td>返回经fmt格式化后的exp</td>
</tr>
<tr>
<td><code>sub(r,s)</code></td>
<td>用$0中最左边最长的子串代替s</td>
</tr>
<tr>
<td><code>substr(s,p)</code></td>
<td>返回字符串s中从p开始的后缀部分</td>
</tr>
<tr>
<td><code>substr(s,p,n)</code></td>
<td>返回字符串s中从p开始长度为n的后缀部分</td>
</tr>
</tbody></table>
<h4 id="4-print-amp-printf"><a href="#4-print-amp-printf" class="headerlink" title="4 print &amp; printf"></a>4 print &amp; printf</h4><ol>
<li><code>printf</code> 是标准格式输出命令，不会自动换行</li>
<li><code>print</code> 会自动添加换行符（linux 默认没有print）</li>
</ol>
<h5 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h5><ul>
<li><code>printf &#39;输出类型输出格式&#39; 输出内容</code><ul>
<li>输出类型<ul>
<li><code>%ns</code><ul>
<li>输出字符串。n是数字指输出几个字符</li>
</ul>
</li>
<li><code>%ni</code><ul>
<li>输出整数。n是数字指输出几个数字</li>
</ul>
</li>
<li><code>%m.nf</code><ul>
<li>输出浮点数。m和n是数字，指输出总位数(m)和小数位数(n)</li>
</ul>
</li>
</ul>
</li>
<li>输出格式<ul>
<li><code>\r</code></li>
<li><code>\n</code></li>
<li><code>\t</code><ul>
<li>水平tab</li>
</ul>
</li>
<li><code>\v</code><ul>
<li>垂直tab</li>
</ul>
</li>
<li><code>\b</code><ul>
<li>退格Backspaced</li>
</ul>
</li>
<li><code>\f</code><ul>
<li>清屏</li>
</ul>
</li>
<li><code>\a</code><ul>
<li>输出警告声音</li>
</ul>
</li>
</ul>
</li>
<li>输出内容<ul>
<li><code>$()</code><ul>
<li>使用命令获取内容</li>
<li>不能直接用文件，管道符也不行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="print"><a href="#print" class="headerlink" title="print"></a>print</h5><ul>
<li><code>print 输出内容</code><ul>
<li>输出内容如果用逗号隔开则代表显示结果使用空格隔开<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print &apos;a b&apos; # ab</span><br><span class="line">print &apos;a,b&apos; # a b</span><br><span class="line">print &apos;a&quot;,&quot;b&apos; # a,b</span><br><span class="line">print &apos;a123b&apos; # a123b</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo</title>
    <url>/anyeansan.github.io/2019/11/12/Hexo/</url>
    <content><![CDATA[<h1 id="一-搭建"><a href="#一-搭建" class="headerlink" title="一 搭建"></a>一 搭建</h1><h2 id="1-1-GitHub"><a href="#1-1-GitHub" class="headerlink" title="1.1 GitHub"></a>1.1 GitHub</h2><ol>
<li>注册账号</li>
<li>创建仓库，名为<code>yourname.github.io</code></li>
</ol>
<h2 id="1-2-Git"><a href="#1-2-Git" class="headerlink" title="1.2 Git"></a>1.2 Git</h2><ol>
<li>安装git及gitbash</li>
<li>配置github账号及ssh key</li>
</ol>
<h2 id="1-3-NodeJs"><a href="#1-3-NodeJs" class="headerlink" title="1.3 NodeJs"></a>1.3 NodeJs</h2><h2 id="1-4-Hexo"><a href="#1-4-Hexo" class="headerlink" title="1.4 Hexo"></a>1.4 Hexo</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h3><ul>
<li><code>npm install -g hexo</code></li>
</ul>
<h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2 初始化"></a>2 初始化</h3><ul>
<li><code>hexo init</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node_modules：依赖包</span><br><span class="line">public：存放生成的页面</span><br><span class="line">scaffolds：命令生成文章等的模板</span><br><span class="line">source：用命令创建的各种文章（post下为原始md文件）</span><br><span class="line">themes：主题</span><br><span class="line">_config.yml：整个博客的配置</span><br><span class="line">db.json：source解析所得到的</span><br><span class="line">package.json：项目所需模块项目的配置信息</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-root-config-yml配置deploy"><a href="#3-root-config-yml配置deploy" class="headerlink" title="3 root config.yml配置deploy"></a>3 root config.yml配置deploy</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:anyeansan/anyeansan.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<h1 id="二-命令"><a href="#二-命令" class="headerlink" title="二 命令"></a>二 命令</h1><h2 id="2-1-hexo-n"><a href="#2-1-hexo-n" class="headerlink" title="2.1 hexo n"></a>2.1 hexo n</h2><ul>
<li><code>hexo n xxx</code><ul>
<li>在<code>source/post</code>目录下根据<code>scaffolds/post.md</code>模板创建<code>xxx.md</code></li>
</ul>
</li>
<li><code>hexo n page xxx</code><ul>
<li>在<code>source</code>目录下根据<code>scaffolds/page.md</code>模板创建<code>xxx</code>文件夹并生成<code>index.md</code></li>
</ul>
</li>
</ul>
<h2 id="2-2-hexo-clean"><a href="#2-2-hexo-clean" class="headerlink" title="2.2 hexo clean"></a>2.2 hexo clean</h2><ul>
<li>删除根下<code>public</code>目录</li>
</ul>
<h2 id="2-3-hexo-g"><a href="#2-3-hexo-g" class="headerlink" title="2.3 hexo g"></a>2.3 hexo g</h2><ul>
<li>在根下创建<code>public</code>目录并生成静态文件</li>
<li><code>source</code>目录下的所有文件都会原样复制（除了md文件会转成html）到<code>public</code>目录</li>
</ul>
<h2 id="2-4-hexo-d"><a href="#2-4-hexo-d" class="headerlink" title="2.4 hexo d"></a>2.4 hexo d</h2><ul>
<li>部署到服务端</li>
<li><code>ERROR Deployer not found: git</code><ul>
<li>需要安装<code>npm install hexo-deployer-git --save</code></li>
</ul>
</li>
</ul>
<h2 id="2-5-hexo-s"><a href="#2-5-hexo-s" class="headerlink" title="2.5 hexo s"></a>2.5 hexo s</h2><ul>
<li>启动服务</li>
<li><code>http://localhost:4000</code></li>
</ul>
<h1 id="三-配置"><a href="#三-配置" class="headerlink" title="三 配置"></a>三 配置</h1><h2 id="3-1-root-config-yml"><a href="#3-1-root-config-yml" class="headerlink" title="3.1 root _config.yml"></a>3.1 root _config.yml</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: 安₃</span><br><span class="line">subtitle: 我未成名君未嫁 可能俱是不如人</span><br><span class="line">description: 一蓑烟雨任平生</span><br><span class="line">keywords:</span><br><span class="line">author: 安₃</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone:</span><br><span class="line"></span><br><span class="line"># Directory</span><br><span class="line">skip_render: README.md</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">url: https://anyeansan.github.io</span><br><span class="line">root: /anyeansan.github.io</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">theme: next</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">deploy:</span><br><span class="line">	type: git</span><br><span class="line">	repository: git@github.com:anyeansan/anyeansan.github.io.git</span><br><span class="line">	branch: master</span><br></pre></td></tr></table></figure>

<h2 id="3-2-本地搜索local-search"><a href="#3-2-本地搜索local-search" class="headerlink" title="3.2 本地搜索local-search"></a>3.2 本地搜索local-search</h2><ol>
<li><code>npm install hexo-generator-searchdb</code></li>
<li><code>root _config.yml</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">	path: search.xml</span><br><span class="line">	field: post</span><br><span class="line">	content: true</span><br><span class="line">	format: html</span><br></pre></td></tr></table></figure></li>
<li><code>_config.yml</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">		enable: true</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="3-3-RSS"><a href="#3-3-RSS" class="headerlink" title="3.3 RSS"></a>3.3 RSS</h2><ol>
<li><code>npm install hexo-generator-feed --save</code></li>
<li><code>root _config.yml</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feed:</span><br><span class="line">	type: atom</span><br><span class="line">	path: atom.xml</span><br><span class="line">	limit: 20</span><br></pre></td></tr></table></figure></li>
<li><code>_config.yml</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rss: /atom.xml</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="3-4-目录编号"><a href="#3-4-目录编号" class="headerlink" title="3.4 目录编号"></a>3.4 目录编号</h2><ul>
<li><code>_config.yml</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toc:</span><br><span class="line">	number: true/false</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-5-文章底部标签和结束语"><a href="#3-5-文章底部标签和结束语" class="headerlink" title="3.5 文章底部标签和结束语"></a>3.5 文章底部标签和结束语</h2><h3 id="1-底部标签"><a href="#1-底部标签" class="headerlink" title="1 底部标签"></a>1 底部标签</h3><ul>
<li><code>next/layout/_macro/post.swig</code>中搜索<code>rel=&quot;tag</code>去掉标签或修改标签样式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rel=&quot;tag&quot;&gt; &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-结束语"><a href="#2-结束语" class="headerlink" title="2 结束语"></a>2 结束语</h3><ol>
<li><code>next/layout/_macro</code>添加<code>passage-end-tag.swig</code>，内容如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #66ccff;font-size:14px;&quot;&gt;-------------The End&amp;nbsp;&amp;nbsp;&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;客官请自便-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div</span><br></pre></td></tr></table></figure></li>
<li><code>next/layout/_macro/post.swig</code>在<code>post-body</code>和<code>post-footer</code>之间添加<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	&#123;% if not is_index %&#125;</span><br><span class="line">		&#123;% include &apos;passage-end-tag.swig&apos; %&#125;</span><br><span class="line">	&#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="3-6-中英文"><a href="#3-6-中英文" class="headerlink" title="3.6 中英文"></a>3.6 中英文</h2><ul>
<li><code>next/languages/zh-CN.yml</code>酌情修改</li>
</ul>
<h2 id="3-7-图片"><a href="#3-7-图片" class="headerlink" title="3.7 图片"></a>3.7 图片</h2><h3 id="1-Logo"><a href="#1-Logo" class="headerlink" title="1 Logo"></a>1 Logo</h3><ul>
<li><code>_config.yml</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">favicon:</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-头像"><a href="#2-头像" class="headerlink" title="2 头像"></a>2 头像</h3><ul>
<li><code>_config.yml</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">avatar:</span><br><span class="line">	url: /images/lbb.png 头像</span><br><span class="line">	rounded: true 是否为圆形</span><br><span class="line">	rotated: true 是否鼠标放上去旋转</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-8-页面底部"><a href="#3-8-页面底部" class="headerlink" title="3.8 页面底部"></a>3.8 页面底部</h2><ul>
<li><code>_config.yml</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">	since: 2019</span><br><span class="line">	icon:</span><br><span class="line">	copyright:</span><br><span class="line">	powered:</span><br><span class="line">	theme:</span><br><span class="line">	beian:</span><br><span class="line">	creative_commons:</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-9-menu-amp-sidebar"><a href="#3-9-menu-amp-sidebar" class="headerlink" title="3.9 menu &amp; sidebar"></a>3.9 menu &amp; sidebar</h2><ul>
<li><code>_config.yml</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">sidebar:</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="四-技巧"><a href="#四-技巧" class="headerlink" title="四 技巧"></a>四 技巧</h1><h2 id="4-1-博文不显示全部内容"><a href="#4-1-博文不显示全部内容" class="headerlink" title="4.1 博文不显示全部内容"></a>4.1 博文不显示全部内容</h2><ul>
<li>在合适的位置加上<code>&lt;!--more--&gt;</code>即可</li>
</ul>
<h2 id="4-2-创建tags和categories"><a href="#4-2-创建tags和categories" class="headerlink" title="4.2 创建tags和categories"></a>4.2 创建tags和categories</h2><ol>
<li><code>hexo n page tages</code></li>
<li><code>source/tages/index.md</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: tags</span><br><span class="line">date: 2019-11-12 12:46:04</span><br><span class="line">type: &quot;tags&quot;</span><br></pre></td></tr></table></figure></li>
<li>文章中使用<ul>
<li>tags为多个标签<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tags:</span><br><span class="line">-空格one</span><br><span class="line">-空格two</span><br><span class="line">-空格three</span><br><span class="line">-空格...</span><br><span class="line">结果为：#one #two #three #...</span><br></pre></td></tr></table></figure></li>
<li>categorys为层级<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categorys:</span><br><span class="line">-空格爷</span><br><span class="line">-空格父</span><br><span class="line">-空格孙</span><br><span class="line">-空格...</span><br><span class="line">结果为：爷 &gt; 父 &gt; 孙 &gt;...</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="4-3-绑定域名"><a href="#4-3-绑定域名" class="headerlink" title="4.3 绑定域名"></a>4.3 绑定域名</h2><h3 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1 购买域名"></a>1 购买域名</h3><ul>
<li><a href="https://www.namesilo.com" target="_blank" rel="noopener">namesilo</a></li>
</ul>
<h3 id="2-设置dns"><a href="#2-设置dns" class="headerlink" title="2 设置dns"></a>2 设置dns</h3><ul>
<li>dns默认有四个<code>A A A CNAME</code>，只需要两个即可</li>
</ul>
<h4 id="1-A-A"><a href="#1-A-A" class="headerlink" title="1 A + A"></a>1 A + A</h4><table>
<thead>
<tr>
<th>类型</th>
<th>HOSTNAME</th>
<th>ADDRESS</th>
<th>TTL</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>空</td>
<td>ip</td>
<td>3600</td>
</tr>
<tr>
<td>A</td>
<td>www</td>
<td>ip</td>
<td>3600</td>
</tr>
<tr>
<td>* ip通过<code>ping yourname.github.io</code>获取</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="2-A-CNAME"><a href="#2-A-CNAME" class="headerlink" title="2 A + CNAME"></a>2 A + CNAME</h4><table>
<thead>
<tr>
<th>类型</th>
<th>HOSTNAME</th>
<th>ADDRESS</th>
<th>TTL</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>空</td>
<td>ip</td>
<td>3600</td>
</tr>
<tr>
<td>CNAME</td>
<td>www</td>
<td>yourname.github.io</td>
<td>3600</td>
</tr>
<tr>
<td>* 创建CNAME</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>* 在<code>source</code>目录创建<code>CNAME</code>文件，内容为你的域名</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="3-配置仓库"><a href="#3-配置仓库" class="headerlink" title="3 配置仓库"></a>3 配置仓库</h3><ul>
<li>在<code>yourname.github.io</code>仓库的<code>setting</code>中配置域名<ul>
<li><code>GitHub Pages -&gt; Custom domain</code></li>
<li>不确定是否必须0.0</li>
</ul>
</li>
</ul>
<h2 id="4-4-README-md"><a href="#4-4-README-md" class="headerlink" title="4.4 README.md"></a>4.4 README.md</h2><h3 id="1-原因"><a href="#1-原因" class="headerlink" title="1 原因"></a>1 原因</h3><ol>
<li><code>hexo g</code>会把<code>source</code>目录下的md文件(包括<code>Readme.md</code>)渲染为html文件并放到<code>public</code>目录下</li>
<li><code>hexo d</code>会把<code>public</code>目录下所有文件提交到<code>yourname.github.io</code>仓库</li>
<li>由于<code>public</code>目录下并没有<code>README.md</code>而只有<code>Readme.html</code>，所以deploy后<code>yourname.github.io</code>是没有<code>Readme.md</code>的</li>
</ol>
<h3 id="2-解决"><a href="#2-解决" class="headerlink" title="2 解决"></a>2 解决</h3><ol>
<li><code>source</code>目录下创建<code>README.md</code></li>
<li><code>root_config.yml</code><ul>
<li><code>skip_render: README.md</code></li>
</ul>
</li>
</ol>
<h2 id="4-5-首页不显示全文"><a href="#4-5-首页不显示全文" class="headerlink" title="4.5 首页不显示全文"></a>4.5 首页不显示全文</h2><ul>
<li><code>_config.yml</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">	enable: false # true 表示根据length显示，false表示显示全文</span><br><span class="line">	length: 150 # 预览长度</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-6-文章排序"><a href="#4-6-文章排序" class="headerlink" title="4.6 文章排序"></a>4.6 文章排序</h2><ul>
<li><code>basedir/node_modules/hexo-generator-index/lib/generator.js</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">posts.data = posts.data.sort(function(a, b) &#123;</span><br><span class="line">  if(a.top &amp;&amp; b.top) &#123; // 两篇文章都有top，top大的在前</span><br><span class="line">      if(a.top == b.top)</span><br><span class="line">	return b.date - a.date; // 若top值一样，最新的文章在前面</span><br><span class="line">      else</span><br><span class="line">	return b.top - a.top; // top大的在前面</span><br><span class="line">  &#125;</span><br><span class="line">  else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面</span><br><span class="line">      return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  else if(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">      return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  else return b.date - a.date; 	//都没有top标签，最新的文章在前面</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


</li>
</ul>
]]></content>
      <categories>
        <category>技</category>
        <category>hexo</category>
      </categories>
  </entry>
</search>
