<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>安₃</title>
  
  <subtitle>我未成名君未嫁 可能俱是不如人</subtitle>
  <link href="/anyeansan.github.io/atom.xml" rel="self"/>
  
  <link href="https://anyeansan.github.io/"/>
  <updated>2020-03-30T14:35:57.727Z</updated>
  <id>https://anyeansan.github.io/</id>
  
  <author>
    <name>安₃</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Javascript 异步</title>
    <link href="https://anyeansan.github.io/2020/03/30/Javascript-%E5%BC%82%E6%AD%A5/"/>
    <id>https://anyeansan.github.io/2020/03/30/Javascript-%E5%BC%82%E6%AD%A5/</id>
    <published>2020-03-30T14:33:35.000Z</published>
    <updated>2020-03-30T14:35:57.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-JavaScript是单线程的。"><a href="#1-1-JavaScript是单线程的。" class="headerlink" title="1.1 JavaScript是单线程的。"></a>1.1 JavaScript是单线程的。</h2><ul><li>注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合</li></ul><h2 id="1-2-同步任务和异步任务"><a href="#1-2-同步任务和异步任务" class="headerlink" title="1.2 同步任务和异步任务"></a>1.2 同步任务和异步任务</h2><ul><li>同步任务<ul><li>在主线程上排队执行的任务。</li><li>只有前一个任务执行完毕，才能执行后一个任务</li></ul></li><li>异步任务<ul><li>不进入主线程而进入任务队列的任务</li><li>只有引擎认为某个异步任务可以执行了，该任务才会进入主线程执行</li><li>异步任务不具有“堵塞”效应，即异步任务后的代码不用等待异步任务结束。</li></ul></li></ul><h2 id="1-3-任务队列和事件循环"><a href="#1-3-任务队列和事件循环" class="headerlink" title="1.3 任务队列和事件循环"></a>1.3 任务队列和事件循环</h2><ul><li>任务队列（task queue）<ul><li>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供任务队列，里面是各种需要当前程序处理的异步任务。（根据异步任务的类型，可以存在多个任务队列。）</li></ul></li><li>事件循环（Event Loop）<ul><li>同步任务执行完毕后，引擎会在任务队列循环检查，如果有可以执行的异步任务，则结束等待状态，进入主线程开始执行。</li></ul></li><li>执行步骤<ol><li>首先，主线程会去执行所有的同步任务，异步任务会进入任务队列。</li><li>同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。</li><li>直到任务队列清空，程序结束执行。</li></ol></li></ul><h2 id="1-4-异步操作模式"><a href="#1-4-异步操作模式" class="headerlink" title="1.4 异步操作模式"></a>1.4 异步操作模式</h2><ol><li>回调函数callback<ul><li>定时器，ajax……</li><li>缺点<ol><li>高耦合，维护困难，回调地狱，当多个异步任务多级依赖时，回调函数会形成多级嵌套</li><li>每个任务只能指定一个回调函数</li><li>如果多个异步操作没有顺序之分，同样需要等待上一个操作执行结束再进行下一个操作</li></ol></li></ul></li><li>事件监听</li><li>发布/订阅</li><li>promise</li><li>generators</li><li>async/await</li></ol><h1 id="二-promise"><a href="#二-promise" class="headerlink" title="二 promise"></a>二 promise</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol><li>Promise 对象本质上表示的是一系列操作的中间状态，或者说是未来某时刻一个操作完成或失败后返回的结果。</li><li>Promise 的回调函数不是正常的异步任务（宏任务），而是微任务（microtask）<ul><li>正常异步任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常异步任务</li></ul></li></ol><h2 id="2-2-promise-状态"><a href="#2-2-promise-状态" class="headerlink" title="2.2 promise 状态"></a>2.2 promise 状态</h2><h3 id="1-三种状态"><a href="#1-三种状态" class="headerlink" title="1 三种状态"></a>1 三种状态</h3><ol><li><code>pending</code> ：初始状态，初始化 promise 时的状态</li><li><code>fulfilled</code>：异步操作成功</li><li><code>rejected</code>：异步操作失败</li></ol><h3 id="2-说明"><a href="#2-说明" class="headerlink" title="2 说明"></a>2 说明</h3><ol><li><code>fulfilled</code> 和 <code>rejected</code> 统称 <code>settled</code> </li><li><code>resolved</code><ol><li>promise 已经 <code>settled</code></li><li>promise 已经使用另一个promise（B）来resolve <ul><li>此时promise的状态由B来决定，可能是<code>pending fulfilled rejected</code> 的任何一种</li></ul></li></ol></li><li><code>unresolved</code> &amp; <code>resolved</code><ul><li><code>unresolved</code> ：promise的状态只能是pending</li><li><code>resolved</code>：promise的状态可能是pending、fulfilled、rejected 的任何一种</li></ul></li></ol><h2 id="2-3-Promise-API"><a href="#2-3-Promise-API" class="headerlink" title="2.3 Promise API"></a>2.3 Promise API</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Promise(executor)</span><br><span class="line">// executor</span><br><span class="line">function(resolve, reject) &#123;&#125;</span><br><span class="line">// 或</span><br><span class="line">(resolve, reject) =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>executor</code><ol><li>指带有 resolve 和 reject 两个参数的函数</li><li>Promise构造函数执行时立即调用executor 函数</li><li>resolve 和 reject 是JavaScript 提供提供的两个函数<ol><li>resolve被调用时，将promise的状态改为<code>fulfilled</code></li><li>reject被调用时，将promise的状态改为<code>rejected</code></li></ol></li><li>如果executor内部出错，将promise的状态改为<code>rejected</code>，且忽略executor返回值</li></ol></li></ul><h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2 静态方法"></a>2 静态方法</h3><ol><li><p><code>Promise.resolve(value)</code></p><ul><li>返回一个以给定值解析后的Promise 对象。</li><li>value<ol><li>如果该value值为promise，返回这个promise；</li><li>如果该value值是thenable（即带有”then” 方法），会将thenable对象包装为promise并返回;</li><li>否则，返回的promise将以此value值完成，即此promise的成功值是value，也就是then方法中第一个函数的参数。</li></ol></li></ul></li><li><p><code>Promise.reject(reason)</code></p><ul><li>返回一个带有拒绝原因的Promise对象</li><li>reason<ul><li>拒绝的原因，通常是一个Error对象，也就是then方法中第二个函数的参数</li></ul></li></ul></li><li><p><code>Promise.all(iterable)</code><br> // TODO</p><ul><li>注：iterable中非promise元素会被转为promise</li></ul><ol><li>如果参数是一个空的可迭代对象<ol><li>返回一个已完成（already resolved）的 Promise。</li><li>此promise会调用成功回调函数，成功值是空数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promis.all([]).then(</span><br><span class="line">value =&gt; console.log(value), // []</span><br><span class="line">reason =&gt; console.log(reason)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol></li><li>如果iterable参数不包含任何 promise<ol><li>返回一个异步完成（asynchronously resolved） Promise</li><li>此promise会调用成功回调函数，成功值是由参数的元素构成的数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promis.all(&quot;abc&quot;).then(</span><br><span class="line">value =&gt; console.log(value), // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class="line">reason =&gt; console.log(reason)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol></li><li>其它情况下返回一个处理中（pending）的Promise<ol><li>如果iterable参数中包含的所有promise都成功，则此返回的promise调用成功函数，成功值为一个数组，数组元素为所有promise的成功值和非promise的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">resolve(&apos;p1-success&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">Promis.all([p1, 3, 4, &apos;abc&apos;]).then(</span><br><span class="line">value =&gt; console.log(value), // [&apos;p1-success&apos;,3,4,&apos;abc&apos;]</span><br><span class="line">reason =&gt; console.log(reason)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li>如果iterable参数中 包含的promise 有一个失败，则此返回的promise调用失败函数，失败原因是第一个失败的promise的原因<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">reject(&apos;p1-fail&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">Promis.all([p1, 3, 4, &apos;abc&apos;]).then(</span><br><span class="line">value =&gt; console.log(value), </span><br><span class="line">reason =&gt; console.log(reason) // p1-fail</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p><code>Promise.allSettled(iterable)</code></p><ul><li>返回一个fulfilled状态的promise，成功值为一个对象数组，每个对象包含两个属性，表示对应的iterable元素的结果<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;status: &quot;fulfilled&quot;, value: ...&#125;</span><br><span class="line">&#123;status: &quot;rejected&quot;, reason: ...&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Promise.race(iterable)</code></p><ul><li>返回一个promise，此返回promise的状态取决于iterable参数中promise 成功/失败的最快的那个。 </li></ul></li></ol><h3 id="3-原型方法"><a href="#3-原型方法" class="headerlink" title="3 原型方法"></a>3 原型方法</h3><h4 id="1-then"><a href="#1-then" class="headerlink" title="1 then"></a>1 then</h4><h5 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">then(onFulfilled[, onRejected])</span><br><span class="line"></span><br><span class="line">then(value =&gt; &#123;</span><br><span class="line">// fulfillment</span><br><span class="line">&#125;, reason =&gt; &#123;</span><br><span class="line">// rejection</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="2-参数"><a href="#2-参数" class="headerlink" title="2 参数"></a>2 参数</h5><ul><li>onFulfilled    ，可选<ul><li>当 Promise 变成fulfilled状态时调用的函数，参数为 <code>fulfillment  value</code>，表示成功的值</li><li>如果onFulfilled不是一个函数，会被忽略，内部变成<code>(value) =&gt; value</code>，即将<code>fulfillment  value</code>原样返回</li></ul></li><li>onRejected，可选<ul><li>当 Promise 变成rejected状态时调用的函数，参数为<code>rejection reason</code>，表示失败原因</li><li>如果onRejected不是函数，则会在内部被替换为一个 “Thrower” 函数，抛出失败原因</li></ul></li></ul><h5 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3 返回值"></a>3 返回值</h5><ol><li>如果then没有参数，或者要执行的回调函数对应的参数不是一个函数，则返回的promise与原promise状态相同，且成功值和失败原因也相同。</li><li>如果then没有返回值，则返回的promise，状态为fulfilled，成功值为undefined</li><li>如果then返回一个值，则返回的promise，状态为fulfilled，成功值为返回的值</li><li>如果then抛出错误，则返回的promise，状态为rejected，失败原因为抛出的错误</li><li>如果then返回一个promise（三种状态都有可能），则可以当作是最终返回的promise，即状态，成功值或者失败原因都是一样的</li></ol><table><thead><tr><th>内部返回值</th><th>最终返回promise状态</th><th>成功的值</th><th>失败原因</th></tr></thead><tbody><tr><td>错误</td><td>rejected</td><td>-</td><td>错误</td></tr><tr><td>无</td><td>fulfilled</td><td>undefined</td><td>-</td></tr><tr><td>非promise的值</td><td>fulfilled</td><td>非promise的值</td><td>-</td></tr><tr><td>promise值</td><td>同promise值</td><td>同promise值</td><td>同promise值</td></tr></tbody></table><h4 id="2-catch"><a href="#2-catch" class="headerlink" title="2 catch"></a>2 catch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">catch(onRejected)</span><br><span class="line"></span><br><span class="line">catch(reason =&gt; &#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>等同于 <code>then(undefined, onRejected)</code></li><li>catch之前任一promise状态变为rejected，如果此promise自己没有处理，则会被catch捕获 </li><li>catch返回一个promise，其状态取决于catch内部onRejected函数<ol><li>如果onRejected返回一个rejected状态的Promise或着抛出一个错误，则catch返回的promise状态为rejected</li><li>否则，catch返回的promise状态为fulfilled</li></ol></li></ol><h4 id="3-finally"><a href="#3-finally" class="headerlink" title="3 finally"></a>3 finally</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">finally(onFinally)</span><br><span class="line"></span><br><span class="line">finally(() =&gt; &#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>onFinally<ul><li>Promise 结束后，无论结果是fulfilled或者是rejected，都会执行onFinally回调函数</li></ul></li><li>返回一个设置了 finally 回调函数的Promise对象</li></ul><h1 id="三-async-await"><a href="#三-async-await" class="headerlink" title="三 async / await"></a>三 async / await</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol><li>async/await 是promise 的语法糖</li><li>async用来声明一个异步函数（async function），await操作符只能用在异步函数中</li></ol><h2 id="3-2-async"><a href="#3-2-async" class="headerlink" title="3.2 async"></a>3.2 async</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function show()&#123;&#125;</span><br><span class="line"></span><br><span class="line">let show = async function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">async show()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class xxx&#123;</span><br><span class="line">async show() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>异步函数返回一个promise<ol><li>如果异步函数正常执行，则返回的promise会调用成功函数，成功值为异步函数内部返回值。</li><li>如果异步函数抛出异常，则返回的promise会调用失败函数，失败原因是抛出异常</li></ol></li><li>错误处理<ul><li>async返回一个promise，可以调用catch来处理错误</li></ul></li></ol><h2 id="3-3-await"><a href="#3-3-await" class="headerlink" title="3.3 await"></a>3.3 await</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[return_value] = await expression;</span><br></pre></td></tr></table></figure><ol><li>await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成<ol><li>如果表达式是一个promise，则返回值为promise的处理结果</li><li>如果表达式不是一个promise，则返回该值本身</li></ol></li><li>错误处理<ol><li>await后边的promise出错，相当于async函数返回的promise为reject，所以可以在外部调用catch方法处理</li><li>可以在内部用try…catch…处理</li></ol></li><li>await的并行<ol><li>让promise先执行后再使用await处理结果</li><li>使用 Promise.all() 处理多个promise并行执行</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-JavaScript是单线程的。&quot;&gt;&lt;a href=&quot;#1-1-JavaScript是单线程的。&quot; cla
      
    
    </summary>
    
    
      <category term="UI" scheme="https://anyeansan.github.io/categories/UI/"/>
    
      <category term="Javascript" scheme="https://anyeansan.github.io/categories/UI/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>Javascript 模块化</title>
    <link href="https://anyeansan.github.io/2020/03/30/Javascript-%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>https://anyeansan.github.io/2020/03/30/Javascript-%E6%A8%A1%E5%9D%97%E5%8C%96/</id>
    <published>2020-03-30T14:31:03.000Z</published>
    <updated>2020-03-30T14:33:19.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-网上概述"><a href="#一-网上概述" class="headerlink" title="一 网上概述"></a>一 网上概述</h1><p><a href="https://segmentfault.com/a/1190000015302578" target="_blank" rel="noopener">网上概述</a></p><h1 id="二-概述"><a href="#二-概述" class="headerlink" title="二 概述"></a>二 概述</h1><ol><li>模块就是一个独立的文件，文件内部的变量，函数，类…外部无法获取</li><li>使用模块可以解决全局变量冲突</li><li>模块需要隐藏内部实现，只对外开发接口</li><li>模块可以避免滥用全局变量，造成代码不可控</li><li>模块可以被不同的应用使用，提高编码效率</li><li>模块默认运行在严格模式</li><li>模块都有独立的顶级作用域，不同模块间不能相互访问，类似函数作用域</li><li>模块在导入时只执行一次解析，之后的导入不会再执行模块代码，而使用第一次解析结果，并共享数据</li></ol><h1 id="三-加载"><a href="#三-加载" class="headerlink" title="三 加载"></a>三 加载</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>异步加载，即模块总是会在所有html解析后才执行</li></ul><h1 id="四-export"><a href="#四-export" class="headerlink" title="四 export"></a>四 export</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ul><li>模块中的功能默认外部无法使用，使用<code>export</code>命令规定模块的对面接口，即将指定功能导出供外部使用。</li></ul><h2 id="4-2-导出单个"><a href="#4-2-导出单个" class="headerlink" title="4.2 导出单个"></a>4.2 导出单个</h2><ul><li><code>export 声明语句</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export let name = &apos;xiaoqiang&apos;;</span><br><span class="line">export let obj = &#123;&#125;;</span><br><span class="line">export function show() &#123;&#125;;</span><br><span class="line">export class User &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-3-导出列表"><a href="#4-3-导出列表" class="headerlink" title="4.3 导出列表"></a>4.3 导出列表</h2><ul><li><code>export { name1, name2, …, nameN };</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export let name = &apos;xiaoqiang&apos;;</span><br><span class="line">export let obj = &#123;&#125;;</span><br><span class="line">export function show() &#123;&#125;;</span><br><span class="line">export class User &#123;&#125;</span><br><span class="line">export &#123;name, obj, show, User&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-4-别名"><a href="#4-4-别名" class="headerlink" title="4.4 别名"></a>4.4 别名</h2><ul><li><code>export { variable1 as name1, variable2 as name2, …, nameN };</code></li></ul><h2 id="4-5-默认导出"><a href="#4-5-默认导出" class="headerlink" title="4.5 默认导出"></a>4.5 默认导出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default expression;</span><br><span class="line">export default function (…) &#123; … &#125; // also class, function*</span><br><span class="line">export default function name1(…) &#123; … &#125; // also class, function*</span><br><span class="line">export &#123; name1 as default, … &#125;;</span><br></pre></td></tr></table></figure><ul><li>默认导出接口只能有一个，但默认导出可以与普通导出共存</li><li>本质上，<code>export default</code>就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字</li><li>默认导出时，函数和类可以具名也可以匿名，变量不能具名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default let a = 1; // 错误</span><br><span class="line">let a = 1;</span><br><span class="line">export default a; // 正确，相当于把a的值赋予default</span><br><span class="line">export default 1; // 正确，相当于直接把值赋予default</span><br></pre></td></tr></table></figure></li></ul><h1 id="五-import（静态导入）"><a href="#五-import（静态导入）" class="headerlink" title="五 import（静态导入）"></a>五 import（静态导入）</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol><li>import用于导入其它模块提供的功能。</li><li>import导入的变量名要与export导出的一致</li><li>import导入的变量是只读的</li><li>import命令具有提升效果，会提升到整个模块的头部，首先执行 </li><li>import是静态导入，不能使用表达式和变量</li><li>在浏览器中引用模块必须添加路径，但在打包工具如webpack中则不需要，因为他们有自己的存放方式。</li></ol><h2 id="5-2-导入所有导出接口"><a href="#5-2-导入所有导出接口" class="headerlink" title="5.2 导入所有导出接口"></a>5.2 导入所有导出接口</h2><ul><li><code>import * as name from &quot;module-name&quot;;</code><ul><li><code>name</code><ul><li>导入模块的命名空间</li></ul></li><li><code>module-name</code><ul><li>要导入的模块。通常是包含目标模块的.js文件的相对或绝对路径名，可以不包括.js扩展名。</li></ul></li><li>使用<code>default</code>获取默认导出</li></ul></li></ul><h2 id="5-3-导入指定导出接口"><a href="#5-3-导入指定导出接口" class="headerlink" title="5.3 导入指定导出接口"></a>5.3 导入指定导出接口</h2><ul><li><code>import { export1, export2, ..., exportN } from &quot;module-name&quot;;</code></li></ul><h2 id="5-4-别名"><a href="#5-4-别名" class="headerlink" title="5.4 别名"></a>5.4 别名</h2><ul><li><code>import { export1 as alias1, export2, ..., exportN } from &quot;module-name&quot;;</code></li></ul><h2 id="5-5-导入默认导出"><a href="#5-5-导入默认导出" class="headerlink" title="5.5 导入默认导出"></a>5.5 导入默认导出</h2><ul><li><code>import defaultExport from &quot;module-name&quot;;</code><ol><li>导入默认导出时名称任意</li><li>由于默认导出只有一个，所以不需要<code>{}</code></li></ol></li></ul><h2 id="5-6-混合导入"><a href="#5-6-混合导入" class="headerlink" title="5.6 混合导入"></a>5.6 混合导入</h2><ul><li><code>import defaultExport, { export1, export2, ..., exportN} from &quot;module-name&quot;;</code></li></ul><h1 id="六-export-default"><a href="#六-export-default" class="headerlink" title="六 export default"></a>六 export default</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><ol><li>使用<code>import</code>命令时，需要知道<code>export</code>导出的变量名。</li><li><code>export default</code> 本质是导出一个名为<code>defualt</code>的变量，使用<code>import</code>导入时可以以任意名称导入。</li><li>一个模块只能有一个默认输出，可以与普通导出共存</li></ol><h2 id="6-2-语法"><a href="#6-2-语法" class="headerlink" title="6.2 语法"></a>6.2 语法</h2><ol><li><code>export default expression</code><ul><li>将<code>expression</code>表达式的值赋给<code>default</code>导出<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = 1;</span><br><span class="line">export default a; // 将a的值1赋给default</span><br><span class="line">export default 1; // 将1赋给default</span><br><span class="line">export default let a = 1; // 错误 因为let a = 1不能计算出一个值</span><br></pre></td></tr></table></figure></li></ul></li><li><code>export default function(){}  // also class, function*</code><ul><li>导出匿名函数/类，名称为<code>default</code></li></ul></li><li><code>export default function name(…) { … } // also class, function*</code><ul><li>导出具名函数/类，名称为<code>default</code>，原有名称会被忽略</li></ul></li><li><code>export { name1 as default, … };</code><ul><li>由于 <code>export default</code> 本质是导出一个名为<code>default</code>的变量</li><li>可以使用<code>export</code>导出一个别名为<code>default</code>的变量</li></ul></li></ol><h1 id="七-export-import"><a href="#七-export-import" class="headerlink" title="七 export + import"></a>七 export + import</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ol><li>可以将导入的模块再次导出</li><li>如果<code>export</code>和<code>import</code>结合在一起，其实就相当于一个转发，并没有导入到当前模块，即当前模块不能使用导入导出的功能。</li></ol><h2 id="7-2-语法"><a href="#7-2-语法" class="headerlink" title="7.2 语法"></a>7.2 语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export * from …;</span><br><span class="line">export &#123; name1, name2, …, nameN &#125; from …;</span><br><span class="line">export &#123; import1 as name1, import2 as name2, …, nameN &#125; from …;</span><br><span class="line">export &#123; default &#125; from …;</span><br></pre></td></tr></table></figure><h1 id="八-import-（动态导入）"><a href="#八-import-（动态导入）" class="headerlink" title="八 import()（动态导入）"></a>八 import()（动态导入）</h1><ol><li>接收参数与静态导入一致 </li><li>使用<code>import()</code> 函数可以动态导入模块，它返回一个 promise 对象，可以按需加载</li><li><code>import()</code> 函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块</li></ol><h1 id="九-打包工具-webpack"><a href="#九-打包工具-webpack" class="headerlink" title="九 打包工具 webpack"></a>九 打包工具 webpack</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-网上概述&quot;&gt;&lt;a href=&quot;#一-网上概述&quot; class=&quot;headerlink&quot; title=&quot;一 网上概述&quot;&gt;&lt;/a&gt;一 网上概述&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000015302578&quot; 
      
    
    </summary>
    
    
      <category term="UI" scheme="https://anyeansan.github.io/categories/UI/"/>
    
      <category term="Javascript" scheme="https://anyeansan.github.io/categories/UI/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>Javascript Class</title>
    <link href="https://anyeansan.github.io/2020/03/30/Javascript-Class/"/>
    <id>https://anyeansan.github.io/2020/03/30/Javascript-Class/</id>
    <published>2020-03-30T14:28:26.000Z</published>
    <updated>2020-03-30T14:30:42.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol><li>JavaScript 中，生成实例对象的传统方法是通过构造函数</li><li>为了和其他语言继承形态一致，JS提供了class 关键词用于模拟传统的class ，但底层实现机制依然是原型继承</li><li>class 只是语法糖，为了让类的声明与继承更加简洁清晰</li><li>class 其实就是函数，<code>typeof 类</code>返回<code>function</code></li><li>class 内部代码始终以严格模式执行</li><li>class 不存在变量提升</li><li>class 中的属性名可以采用表达式<code>[]</code></li><li>class 中定义的属性都是实例属性，定义的方法都是原型方法且不可枚举</li></ol><h1 id="二-语法"><a href="#二-语法" class="headerlink" title="二 语法"></a>二 语法</h1><ol><li>类声明<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 类名 &#123;&#125;</span><br></pre></td></tr></table></figure></li><li>类表达式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let 类名= class&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="三-构造函数-constructor"><a href="#三-构造函数-constructor" class="headerlink" title="三 构造函数 constructor"></a>三 构造函数 constructor</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 基类默认构造函数</span><br><span class="line">constructor() &#123;&#125;</span><br><span class="line">// 派生类默认构造函数</span><br><span class="line">constructor(...args) &#123;</span><br><span class="line">super(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用类new一个对象时会自动调用构造函数</li><li>如果省略，则会有默认构造函数</li><li><code>constructor</code> 默认返回实例对象（即this），可以改为返回另一个对象</li><li>类的原型的constructor属性指向类本身<ul><li><code>类.prototype.constructor = 类</code></li></ul></li></ol><h1 id="四-属性-amp-方法"><a href="#四-属性-amp-方法" class="headerlink" title="四 属性 &amp; 方法"></a>四 属性 &amp; 方法</h1><h2 id="4-1-实例属性"><a href="#4-1-实例属性" class="headerlink" title="4.1 实例属性"></a>4.1 实例属性</h2><ol><li>旧：使用<code>this.</code> 定义在<code>constructor</code>中</li><li>新：在类中直接定义的属性就是实例属性</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">name = &apos;haha&apos;; </span><br><span class="line">constructor(age) &#123;</span><br><span class="line">this.age = age; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-原型方法"><a href="#4-2-原型方法" class="headerlink" title="4.2 原型方法"></a>4.2 原型方法</h2><ol><li>旧：在类的原型上定义方法，是可以枚举的</li><li>新：在类中直接定义的方法就是原型方法，且不可枚举（non-enumerable）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">show()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">User.prototype.show = function()&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-静态属性-方法"><a href="#4-3-静态属性-方法" class="headerlink" title="4.3 静态属性/方法"></a>4.3 静态属性/方法</h2><ol><li>定义在类上</li><li>在类中定义的属性/方法前加<code>static</code>关键字</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">static age = 10;</span><br><span class="line">static show() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">User.age = 10;</span><br><span class="line">User.show() = function()&#123;&#125;;</span><br></pre></td></tr></table></figure><ul><li>注意：如果静态方法包含this关键字，这个this指的是类本身，而不是实例对象</li></ul><h2 id="4-4-私有属性-方法"><a href="#4-4-私有属性-方法" class="headerlink" title="4.4 私有属性 / 方法"></a>4.4 私有属性 / 方法</h2><ul><li>私有属性：在属性名前加 <code>#</code></li><li>私有方法：以表达式形式定义方法并在方法前加<code>#</code> ，可以理解为就是定义私有属性，不过属性的值是一个函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">#phone = &apos;13800000000&apos;; // 私有属性</span><br><span class="line">#say = function() &#123;&#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-受保护属性-方法"><a href="#4-5-受保护属性-方法" class="headerlink" title="4.5 受保护属性 / 方法"></a>4.5 受保护属性 / 方法</h2><ul><li>在属性/方法名前加 <code>_</code>，这只是约定不是语法，不是规范</li><li>可以通过<code>symbol weakmap ...</code> 人为实现保护</li></ul><h1 id="五-访问器-getter-setter"><a href="#五-访问器-getter-setter" class="headerlink" title="五 访问器 getter/setter"></a>五 访问器 getter/setter</h1><ul><li>类中同样可以使用访问器，且访问器也是定义在属性的属性描述符上</li></ul><h1 id="六-class的继承"><a href="#六-class的继承" class="headerlink" title="六 class的继承"></a>六 class的继承</h1><h2 id="6-1-extends"><a href="#6-1-extends" class="headerlink" title="6.1 extends"></a>6.1 extends</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Fu &#123;</span><br><span class="line">constructor() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Zi extends Fu &#123;</span><br><span class="line">constructor() &#123;</span><br><span class="line">super();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>子类构造函数第一行必须先调用父类构造函数</li><li>class的继承做了两件事<ol><li>与ES5的 继承一样<ol><li>在子类构造函数中调用父类构造</li><li>子类的原型对象的原型指向父类的原型对象</li></ol></li><li><code>子类.__proto__ = 父类</code><ul><li>用于继承静态属性/方法</li></ul></li></ol></li></ul><h2 id="6-2-super"><a href="#6-2-super" class="headerlink" title="6.2 super"></a>6.2 super</h2><h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1 问题"></a>1 问题</h3><ol><li><code>子 父</code>：在子类中调用父类方法<ul><li>子：<code>this.__proto__.__proto__</code><ul><li>this代表子类实例，<code>this.__proto__.__proto__</code>就代表父类原型，就可以调用到父类的方法。</li></ul></li></ul></li><li><code>子 父 爷</code>：在子类中调用父类方法，父类方法中又调用了父类的父类的方法<ul><li>子：<code>this.__proto__.__proto__</code></li><li>父：<code>this.__proto__</code><ul><li>因为子类中调用父类方法的是父类原型对象，所以父类中的this代表的是父类原型，所以用<code>this.__proto__</code>获取爷爷的原型，就可以调用爷爷的方法</li></ul></li></ul></li><li><code>父 爷</code><ul><li>父：<code>this.__proto__.__proto__</code><ul><li>如果直接使用父类调用爷爷的方法，此时父类就是子，爷爷就是父类，就跟1<code>子 父</code>是一样的。</li><li>父类扮演不同角色时，代码是矛盾的。</li></ul></li></ul></li></ol><ul><li>如果只有双层继承，使用<code>this</code>是可以的，如果有多重继承，是行不通的。</li><li>使用call/apply指定this，在多重继承中也是行不通的。</li></ul><h3 id="2-用法"><a href="#2-用法" class="headerlink" title="2 用法"></a>2 用法</h3><ol><li>super 只能在类或对象的方法中使用，而不能在函数中使用</li><li>使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。<ul><li><code>console.log(super)</code> 无法看出是函数还是对象，错误</li></ul></li></ol><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super([arguments]);</span><br></pre></td></tr></table></figure><ol><li>调用 父对象/父类 的构造函数</li><li>此时super代表父对象/父类的构造函数</li></ol><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super.functionOnParent([arguments]);</span><br></pre></td></tr></table></figure><ol><li>调用 父对象/父类 上的方法</li><li>此时super代表父类原型对象</li><li>如果是静态方法则super代表父类本身</li></ol><h3 id="3-原生构造函数的继承"><a href="#3-原生构造函数的继承" class="headerlink" title="3 原生构造函数的继承"></a>3 原生构造函数的继承</h3><ol><li>之前，这些内置的构造函数如<code>Object() Array() ...</code> 是无法继承的</li><li>ES6 允许继承</li></ol><h3 id="4-mixin"><a href="#4-mixin" class="headerlink" title="4 mixin"></a>4 mixin</h3><ol><li>创建一个mixin类，包含许多供其它类使用的方法</li><li>将mixin类 合并到要使用功能的类的原型上</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;JavaScript 中，生成实例对象的传统方法是通过构造函数&lt;/li&gt;
&lt;li&gt;为了和其他语言继承形态一致，J
      
    
    </summary>
    
    
      <category term="UI" scheme="https://anyeansan.github.io/categories/UI/"/>
    
      <category term="Javascript" scheme="https://anyeansan.github.io/categories/UI/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>Javascript 继承和原型</title>
    <link href="https://anyeansan.github.io/2020/03/30/Javascript-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B/"/>
    <id>https://anyeansan.github.io/2020/03/30/Javascript-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B/</id>
    <published>2020-03-30T14:24:38.000Z</published>
    <updated>2020-03-31T01:30:54.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-原型"><a href="#一-原型" class="headerlink" title="一 原型"></a>一 原型</h1><p><img src="https://gitee.com/3noanswer/npics/raw/master/UI/JavaScript/js%E5%8E%9F%E5%9E%8B.png" alt=""></p><h2 id="1-1-原型链"><a href="#1-1-原型链" class="headerlink" title="1.1 原型链"></a>1.1 原型链</h2><p><img src="https://gitee.com/3noanswer/npics/raw/master/UI/JavaScript/js%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt=""></p><ul><li>对象有自己的原型对象，而原型对象也是对象，所以原型对象也有自己的原型对象，就会形成一个“原型链”（prototype chain）</li><li>对象有自己的原型对象，而对象又可以充当其他对象的原型；</li></ul><h2 id="1-2-proto"><a href="#1-2-proto" class="headerlink" title="1.2 __proto__"></a>1.2 <code>__proto__</code></h2><ol><li>是浏览器实现的非JavaScript标准的属性，在ES6写入了附录，用于获取或设置对象的原型</li><li><code>obj.__proto__</code><ol><li>并非是普通的属性访问方式，而是通过getter/setter访问器</li><li><code>__proto__</code>理解为<code>prototype</code> 属性的 getter/setter 实现</li></ol></li><li>每个对象都有<code>__proto__</code>属性，指向它的构造函数的原型对象，即如果A对象是由B函数构造的，则 <code>A.__proto__ === B.prototype</code><ol><li>普通对象的构造函数是其对应的构造函数，则<code>对象.__proto__ === 构造函数.prototype</code></li><li>函数（包括Function自身）的构造函数是Function，则 <code>函数.__proto__ === Function.prototype</code></li><li>原型对象默认的构造函数是Object，则<code>原型对象.__proto__ === Object.prototype</code></li><li>原型对象中<code>Object.prototype</code>比较特殊，它是原型链的顶端，<code>Object.prototype.__proto__ === null</code></li></ol></li><li>由于非标准，浏览器有这个属性，其它环境未必有。建议使用Object中的方法 替代<code>__proto__</code><ul><li><code>Object.getPrototypeOf(obj)</code></li><li><code>Object.setPrototypeOf(obj, prototype)</code></li><li><code>Object.create(proto[, propertiesObject])</code></li></ul></li></ol><h2 id="1-3-prototype"><a href="#1-3-prototype" class="headerlink" title="1.3 prototype"></a>1.3 prototype</h2><ol><li>函数作为对象有<code>__proto__</code>，又可以作为构造函数有<code>prototype</code></li><li>每个函数都有一个<code>prototype</code>属性，指向函数的原型对象，且函数的原型对象是普通对象。<ul><li><code>Function.prototype</code>是个例外<ol><li>它是Function函数的原型对象但它是个函数对象</li><li>它是函数对象但是没有<code>prototype</code>属性</li></ol></li></ul></li><li>实例对象的<code>__proto__</code>和其构造函数的<code>prototype</code>都指向构造函数的原型对象</li><li><code>prototype</code>的作用是让该函数所实例化的对象们都可以找到公用的属性和方法，即js的继承是通过<code>prototype</code>实现的</li></ol><h3 id="4-constructor"><a href="#4-constructor" class="headerlink" title="4 constructor"></a>4 constructor</h3><ol><li>只有原型对象才有<code>constructor</code>属性，此属性指向函数本身，即<ol><li><code>函数.prototype.constructor = 函数</code></li><li><code>实例对象.__proto__.constructor = 函数</code></li></ol></li></ol><h1 id="二-new"><a href="#二-new" class="headerlink" title="二 new"></a>二 new</h1><h2 id="2-1-new的执行过程"><a href="#2-1-new的执行过程" class="headerlink" title="2.1 new的执行过程"></a>2.1 new的执行过程</h2><ol><li>创建一个空对象 <code>let obj = {};</code></li><li>将新建对象的<code>__proto__</code>指向构造函数的原型对象，<code>obj.__proto__ = 构造函数.prototype</code></li><li>将新建对象作为构造函数执行的上下文，即将构造函数内部的this指向新建对象</li><li>执行构造函数，如果构造函数没有返回引用类型的值，则返回新建对象</li></ol><h2 id="2-2-自定义new"><a href="#2-2-自定义new" class="headerlink" title="2.2 自定义new"></a>2.2 自定义new</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let myNew = function(cons, args) &#123;</span><br><span class="line">let obj = &#123;&#125;; // 步骤1</span><br><span class="line">obj.__proto__ = cons.prototype; // 步骤2</span><br><span class="line">// let obj = Object.create(cons.prototype); 步骤1，2合在一起</span><br><span class="line">let result = cons.apply(obj, args); // 步骤3</span><br><span class="line">return result instanceof Object ? result : obj; // 步骤4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-3-new-target-属性"><a href="#2-3-new-target-属性" class="headerlink" title="2.3 new.target 属性"></a>2.3 new.target 属性</h2><ul><li>用来检测函数是否通过<code>new</code>或者<code>Reflect.construct()</code>调用的<ol><li>如果在普通函数中使用，返回undefined</li><li>在构造函数中使用指向被new调用的构造函数</li><li>在class的constructor函数中使用指向被new调用的class</li></ol></li></ul><h1 id="三-构造函数中的属性和方法"><a href="#三-构造函数中的属性和方法" class="headerlink" title="三 构造函数中的属性和方法"></a>三 构造函数中的属性和方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function User(name) &#123;</span><br><span class="line">let age = 18; // 私有属性</span><br><span class="line">let test = function()&#123;&#125;; // 私有方法</span><br><span class="line">this.name = name; // 实例属性</span><br><span class="line">this.show = function()&#123;&#125;// 实例方法</span><br><span class="line">&#125;</span><br><span class="line">User.country = &apos;中国&apos;; // 静态属性</span><br><span class="line">User.sayHello = function()&#123;&#125;; // 静态方法</span><br><span class="line">User.prototype.gender = &apos;男&apos;; // 原型属性</span><br><span class="line">User.prototype.change = function()&#123;&#125;; // 原型方法</span><br></pre></td></tr></table></figure><ol><li>私有实例属性 / 方法（private）<ul><li>在构造函数内部使用<code>var/let/const</code>声明的属性/方法</li></ul></li><li>公有实例属性 / 方法（public）<ul><li>在构造函数内部使用<code>this.</code>声明的属性/方法</li></ul></li><li>静态属性 / 方法（static）<ul><li>定义在构造函数上的属性/方法</li></ul></li><li>原型属性 / 方法（prototype）<ul><li>定义在构造函数原型上的属性/方法 ，<strong>原型方法默认可枚举</strong></li></ul></li></ol><h1 id="四-继承"><a href="#四-继承" class="headerlink" title="四 继承"></a>四 继承</h1><h2 id="4-1-设置原型方式"><a href="#4-1-设置原型方式" class="headerlink" title="4.1 设置原型方式"></a>4.1 设置原型方式</h2><ol><li>设置构造函数原型，使用函数的<code>prototype</code>属性</li><li>设置对象的原型<ol><li><code>Object.create(proto[, propertiesObject])</code> <ul><li>创建对象时指定原型（只是定义无法获取）</li></ul></li><li>使用对象的属性<code>__proto__</code> 获取或设置原型，在浏览器之外的环境可能不行。</li><li>Object的方法，与<code>__proto__</code>效果一样，但是是js标准<ul><li><code>Object.getPrototypeOf(obj)</code><ul><li>获取对象的原型，即<code>__proto__</code></li></ul></li><li><code>Object.setPrototypeOf(obj, prototype)</code><ul><li>设置对象的原型</li></ul></li></ul></li></ol></li></ol><h2 id="4-2-继承原理"><a href="#4-2-继承原理" class="headerlink" title="4.2 继承原理"></a>4.2 继承原理</h2><p><img src="https://gitee.com/3noanswer/npics/raw/master/UI/JavaScript/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF.png" alt=""></p><ul><li>将子类构造函数的原型对象的原型指向父类构造函数的原型对象</li></ul><h2 id="4-3-实现继承的方式"><a href="#4-3-实现继承的方式" class="headerlink" title="4.3 实现继承的方式"></a>4.3 实现继承的方式</h2><h3 id="1-原型链-1"><a href="#1-原型链-1" class="headerlink" title="1 原型链-1"></a>1 原型链-1</h3><p><img src="https://gitee.com/3noanswer/npics/raw/master/UI/JavaScript/%E7%BB%A7%E6%89%BF1.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.prototype.__proto__ = B.prototype;</span><br></pre></td></tr></table></figure><ul><li>将子类构造函数的原型对象的原型直接指向父类构造函数的原型</li><li>好处<ul><li>父类原型在子类原型链上，则子类可以继承父类的原型属性/方法</li></ul></li><li>弊端<ul><li>创建子类时不会调用父类构造函数，无法继承父类的实例属性/方法</li></ul></li></ul><h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2 构造函数"></a>2 构造函数</h3><ul><li>在子类构造函数中通过<code>call/apply</code>调用父类构造函数，并指定this为子类对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Fu(name, age) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.show = function()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">function Zi(name, age) &#123;</span><br><span class="line">Fu(name,age); // 不行，因为直接调用时，父类构造函数this是指向window的</span><br><span class="line">Fu.call(this, name, age); </span><br><span class="line">Fu.apply(this, [name, age])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>好处<ul><li>创建的子类实例具备父类实例属性/方法</li></ul></li><li>弊端<ol><li>只是子类的实例，不是父类的实例（只是通过调用父类构造函数模拟继承）</li><li>无法继承父类原型属性/方法</li></ol></li></ul><h3 id="3-原型链-2"><a href="#3-原型链-2" class="headerlink" title="3 原型链-2"></a>3 原型链-2</h3><p><img src="https://gitee.com/3noanswer/npics/raw/master/UI/JavaScript/%E7%BB%A7%E6%89%BF2.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.prototype = new B();</span><br></pre></td></tr></table></figure><ul><li>将子类构造函数的原型对象修改为一个父类实例（舍弃原有原型对象）</li><li>好处<ul><li>父类实例对象具有父类的实例属性/方法，父类实例对象的原型又指向父类构造函数原型，所以父类的实例属性/方法 和 原型属性/方法，子类都可以继承</li></ul></li><li>弊端<ol><li>父类的实例属性/方法是在子类原型对象上，这就导致父类的实例属性/方法实际上变成了子类的原型属性/方法。</li><li>需要手动为新的子类原型对象添加 <code>constructor</code>属性</li></ol></li></ul><h4 id="1-对新增对象的影响"><a href="#1-对新增对象的影响" class="headerlink" title="1 对新增对象的影响"></a>1 对新增对象的影响</h4><ul><li>如果新增对象在修改原型操作之前，那就意味着，新增对象指向的原型还是原来被舍弃的原型，所以这种方式只对修改原型操作之后新增的对象有效 </li></ul><h4 id="2-对constructor的影响"><a href="#2-对constructor的影响" class="headerlink" title="2 对constructor的影响"></a>2 对constructor的影响</h4><ul><li>由于这种方式是将子类原型修改成了一个新的对象，而这个新对象中是没有<code>constructor</code>属性的，所以需要手动为新对象添加<code>constructor</code>属性，并指向子类构造函数</li></ul><ol><li>直接添加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.prototype.constructor = A;</span><br></pre></td></tr></table></figure><ul><li>直接添加的方式有一个弊端，就是<code>constructor</code>属性默认可遍历</li></ul></li><li>使用Object的<code>defineProperty()</code> 添加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(A.prototype, &quot;constructor&quot;, &#123;</span><br><span class="line">value: A,</span><br><span class="line">enumerable: false</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-组合继承1（构造函数-原型链2）"><a href="#4-组合继承1（构造函数-原型链2）" class="headerlink" title="4 组合继承1（构造函数+原型链2）"></a>4 组合继承1（构造函数+原型链2）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function B(name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.gender = &apos;nan&apos;;</span><br><span class="line">B.prototype.eat = function() &#123;&#125;;</span><br><span class="line">function A(age) &#123;</span><br><span class="line">B.call(this, &apos;小猫&apos;); // 第一次调用</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype = new B(&apos;小狗&apos;); // 第二次调用</span><br><span class="line">A.prototype.constructor = A;</span><br></pre></td></tr></table></figure><ul><li>好处<ul><li>通过构造函数方式可以继承到父类的实例属性/方法</li><li>通过原型链方式可以继承到父类的原型属性/方法</li></ul></li><li>弊端<ol><li>父类的实例属性会在子类实例和子类原型上都定义一份，不过不影响，因为会先使用实例自己的属性</li><li>会调用两次父类构造函数</li><li>需要手动为新的子类原型对象添加 <code>constructor</code>属性</li></ol></li></ul><h3 id="5-组合继承2（构造函数-原型链1）"><a href="#5-组合继承2（构造函数-原型链1）" class="headerlink" title="5 组合继承2（构造函数+原型链1）"></a>5 组合继承2（构造函数+原型链1）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function B(name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.gender = &apos;nan&apos;;</span><br><span class="line">B.prototype.eat = function() &#123;&#125;;</span><br><span class="line">function A(age) &#123;</span><br><span class="line">B.call(this, &apos;小猫&apos;); </span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.__proto__ = B.prototype</span><br></pre></td></tr></table></figure><ul><li>好处<ul><li>通过构造函数方式可以继承到父类的实例属性/方法</li><li>通过原型链方式可以继承到父类的原型属性/方法</li></ul></li><li>弊端<ul><li><code>__proto__</code> 在浏览器之外的环境可能不行。</li></ul></li></ul><h3 id="6-最终方式"><a href="#6-最终方式" class="headerlink" title="6 最终方式"></a>6 最终方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function B(name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.gender = &apos;nan&apos;;</span><br><span class="line">B.prototype.eat = function() &#123;&#125;;</span><br><span class="line">function A(age) &#123;</span><br><span class="line">B.call(this, &apos;小猫&apos;); </span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype = Object.create(B.prototype);</span><br><span class="line">Object.defineProperty(A.prototype, &quot;constructor&quot;, &#123;</span><br><span class="line">value: A,</span><br><span class="line">enumerable: false</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>将<code>__proto__</code> 方式改为<code>Object.create()</code></li><li><code>A.prototype = Object.create(B.prototype);</code><ul><li>以父类的原型创建一个对象作为子类原型对象，此新建对象没有调用父类构造函数，没有父类实例属性/方法</li></ul></li></ul><h2 id="4-4-对象工厂"><a href="#4-4-对象工厂" class="headerlink" title="4.4 对象工厂"></a>4.4 对象工厂</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Fu(name)&#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">function createObj(...args) &#123;</span><br><span class="line">const obj = Object.create(Fu.prototype);</span><br><span class="line">Fu.call(obj, ...args); //通过调用父类</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>与继承方式类似，只是通过对象工厂创建子类对象，不需要子类构造函数<ol><li>创建一个以父类原型为原型的对象，相当于继承了父类原型属性/方法</li><li>调用父类构造函数，并设置this为新建对象，即相当于继承了父类实例属性</li><li>返回新建对象</li></ol></li></ul><h2 id="4-5-静态属性-方法的继承"><a href="#4-5-静态属性-方法的继承" class="headerlink" title="4.5 静态属性/方法的继承"></a>4.5 静态属性/方法的继承</h2><ul><li>静态属性/方法即在构造函数上定义的属性/方法，继承原理都是一样的，函数也是对象，把子类构造函数看作对象，设置其原型为父类构造函数，即可继承静态属性/方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Fu() &#123;&#125;</span><br><span class="line">Fu.haha = &quot;wangcai&quot;;</span><br><span class="line">Fu.show = function() &#123;</span><br><span class="line">console.log(&apos;fu static show&apos;)</span><br><span class="line">&#125;</span><br><span class="line">function Zi() &#123;&#125;</span><br><span class="line">Zi.__proto__ = Fu;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-6-多继承"><a href="#4-6-多继承" class="headerlink" title="4.6 多继承"></a>4.6 多继承</h2><ul><li>js不支持多继承，也没有接口实现，如果要使用多个类的方法时可以使用mixin混合模式来完成</li></ul><h3 id="Mixin模式"><a href="#Mixin模式" class="headerlink" title="Mixin模式"></a>Mixin模式</h3><ol><li>Mixin模式 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口</li><li>mixin 可以看作是一个包含许多功能的对象，使用时将这些功能合并到要使用功能的对象原型上即可</li></ol><ul><li>例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let myMix = &#123;</span><br><span class="line">sayHi() &#123;&#125;,</span><br><span class="line">sayBye() &#123;&#125;,</span><br><span class="line">eat()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">function User() &#123;&#125;</span><br><span class="line">// 合并之后，User的实例就有了myMix的功能了</span><br><span class="line">Object.assign(User.prototype, myMix);</span><br><span class="line">// 手动添加某个功能</span><br><span class="line">User.prototype.eat = myHix.eat;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-原型&quot;&gt;&lt;a href=&quot;#一-原型&quot; class=&quot;headerlink&quot; title=&quot;一 原型&quot;&gt;&lt;/a&gt;一 原型&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/3noanswer/npics/raw/master/UI/Java
      
    
    </summary>
    
    
      <category term="UI" scheme="https://anyeansan.github.io/categories/UI/"/>
    
      <category term="Javascript" scheme="https://anyeansan.github.io/categories/UI/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>Javascript 闭包</title>
    <link href="https://anyeansan.github.io/2020/03/30/Javascript-%E9%97%AD%E5%8C%85/"/>
    <id>https://anyeansan.github.io/2020/03/30/Javascript-%E9%97%AD%E5%8C%85/</id>
    <published>2020-03-30T14:24:25.000Z</published>
    <updated>2020-03-30T14:24:50.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol><li>通常情况下，函数执行时（入栈）创建一个单独的作用域，函数执行完毕（弹栈），此作用域销毁，函数内部的变量也就销毁了，无法再访问。</li><li>闭包则会添加一个对函数的引用，使得函数作用域一直保存到闭包不存在为止。</li></ol><h1 id="二-概念及现象"><a href="#二-概念及现象" class="headerlink" title="二 概念及现象"></a>二 概念及现象</h1><ul><li>闭包是由函数以及创建该函数的词法环境组合而成。在此词法环境外调用函数时，可以访问到词法环境中的变量。</li><li>通俗来说就是：<ol><li>有一个单独的作用域，此作用域中定义一个函数，则这个函数与它能在此作用域中所有能访问的变量构成了闭包。</li><li>在此作用域外调用函数时，函数能够使用作用域中的变量。</li></ol></li></ul><h1 id="三-如何形成闭包"><a href="#三-如何形成闭包" class="headerlink" title="三 如何形成闭包"></a>三 如何形成闭包</h1><h2 id="3-1-条件"><a href="#3-1-条件" class="headerlink" title="3.1 条件"></a>3.1 条件</h2><ol><li>单独的作用域：为了创建局部变量</li><li>内部定义一个函数：形成闭包</li><li>将函数暴漏给外部：为了能在外部访问到函数</li></ol><h2 id="3-2-方式"><a href="#3-2-方式" class="headerlink" title="3.2 方式"></a>3.2 方式</h2><ol><li>函数嵌套<ol><li>外部函数是一个单独的函数作用域</li><li>定义一个内部函数，此内部函数与外部函数中的变量构成了闭包</li><li>把内部函数return, 或者添加到window对象上，暴漏给外部。</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function outer() &#123;</span><br><span class="line">let i = 0;</span><br><span class="line">return function() &#123;</span><br><span class="line">console.log(i++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let inner = outer(); </span><br><span class="line">inner(); // 外部函数执行完毕后，依然可以访问到外部函数中的变量</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;通常情况下，函数执行时（入栈）创建一个单独的作用域，函数执行完毕（弹栈），此作用域销毁，函数内部的变量也就销毁了
      
    
    </summary>
    
    
      <category term="UI" scheme="https://anyeansan.github.io/categories/UI/"/>
    
      <category term="Javascript" scheme="https://anyeansan.github.io/categories/UI/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>Javascript 引用数据类型</title>
    <link href="https://anyeansan.github.io/2020/03/30/Javascript-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://anyeansan.github.io/2020/03/30/Javascript-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-03-30T14:13:52.000Z</published>
    <updated>2020-03-30T14:21:56.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-属性描述符"><a href="#一-属性描述符" class="headerlink" title="一 属性描述符"></a>一 属性描述符</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ol><li>JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为属性描述符（property descriptor），或者叫属性描述对象</li><li>属性描述符有两种主要形式，且只能取其一<ol><li>数据描述符可以具有的属性<ul><li><code>configurable enumerable value writable</code></li></ul></li><li>存取描述符可以具有的属性<ul><li><code>configurable enumerable get set</code></li></ul></li></ol></li></ol><h2 id="1-2-元属性（属性描述对象中用来描述属性元信息的属性）"><a href="#1-2-元属性（属性描述对象中用来描述属性元信息的属性）" class="headerlink" title="1.2 元属性（属性描述对象中用来描述属性元信息的属性）"></a>1.2 元属性（属性描述对象中用来描述属性元信息的属性）</h2><table><thead><tr><th>元属性</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td><code>value</code></td><td>表示该属性的值</td><td><code>undefined</code></td></tr><tr><td><code>writable</code></td><td>表示该属性是否可写</td><td><code>true</code></td></tr><tr><td><code>enumerable</code></td><td>表示该属性是否可遍历</td><td><code>true</code></td></tr><tr><td><code>configurable</code></td><td>1 该属性是否可删除<br>2 该属性的属性描述符是否可修改</td><td><code>true</code></td></tr><tr><td><code>get</code></td><td>表示该属性的取值函数getter</td><td><code>undefined</code></td></tr><tr><td><code>set</code></td><td>表示该属性的存值函数setter</td><td><code>undefined</code></td></tr></tbody></table><h1 id="二-对象"><a href="#二-对象" class="headerlink" title="二 对象"></a>二 对象</h1><h2 id="2-1-Object"><a href="#2-1-Object" class="headerlink" title="2.1 Object"></a>2.1 Object</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><ol><li><code>Object([value])</code><ol><li>普通函数，作用是类型转换，将value转成一个对象</li><li>用法与构造函数相同，只是语义上的区别</li></ol></li><li><code>new Object([value])</code><ol><li>构造函数，创建一个对象，值为value转成的对象</li><li>如果参数value<ol><li>为空或者是<code>undefined null</code>，返回一个空对象</li><li>是基本类型的值则返回其包装对象</li><li>是引用类型则直接返回</li></ol></li></ol></li></ol><h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2 静态方法"></a>2 静态方法</h3><h4 id="1-获取"><a href="#1-获取" class="headerlink" title="1 获取"></a>1 获取</h4><ol><li><code>Object.keys(obj)</code><ul><li>返回对象自身可枚举属性键的数组</li></ul></li><li><code>Object.values(obj)</code><ul><li>返回对象自身可枚举属性值的数组</li></ul></li><li><code>Object.entries(obj)</code><ul><li>返回对象自身可枚举属性键值对的数组</li><li>以上三个方法与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）</li></ul></li><li><code>Object.getOwnPropertyNames(obj)</code><ul><li>返回对象自身的所有属性（包含可枚举和不可枚举属性，不包含Symbol属性）键的数组</li></ul></li><li><code>Object.getOwnPropertySymbols(obj)</code><ul><li>返回对象自身的所有 Symbol 属性的数组</li></ul></li></ol><h4 id="2-属性描述符"><a href="#2-属性描述符" class="headerlink" title="2 属性描述符"></a>2 属性描述符</h4><ol><li><code>Object.getOwnPropertyDescriptor(obj, prop)</code><ul><li>获取对象自身某个属性的属性描述对象</li></ul></li><li><code>Object.getOwnPropertyDescriptors(obj)</code><ul><li>获取对象自身所有属性的属性描述对像</li></ul></li><li><code>Object.defineProperty(obj, prop, descriptor)</code><ul><li>如果对象自身存在指定属性，则修改它的属性描述对象，否则为对象添加指定属性并定义属性描述对象。返回该对象</li><li>通过这种方式定义属性描述法时的默认值<ul><li><code>configurable enumerable writable</code> 均为false</li><li><code>value get set</code> 均为undefined</li></ul></li></ul></li><li><code>Object.defineProperties(obj, props)</code><ul><li>修改或添加对象多个属性的属性描述对象，返回该对象</li></ul></li></ol><h4 id="3-创建对象"><a href="#3-创建对象" class="headerlink" title="3 创建对象"></a>3 创建对象</h4><ol><li><code>Object.create(proto[, propertiesObject])</code><ul><li>指定原型对象和属性（使用属性描述符定义），返回一个新的对象</li><li><code>propertiesObject</code> 同 <code>Object.defineProperties(obj, props)</code> 的<code>props</code></li></ul></li><li><code>Object.assign(target, ...sources)</code><ul><li>将一个或多个源对象的所有可枚举属性复制到目标对象。并返回目标对象<ol><li>如果目标对象与源对象有同名属性，或多个源对象有同名属性，后边覆盖前边</li><li><code>Object.assign</code> 方法实行的是浅拷贝</li><li>数组会被当作对象，即相同索引会覆盖</li><li>如果属性值是取值函数，会计算后再复制</li></ol></li></ul></li><li><code>Object.fromEntries(iterable)</code><ul><li>把键值对列表转换为一个对象</li><li>是 <code>Object.entries()</code> 的反转</li></ul></li></ol><h4 id="4-原型"><a href="#4-原型" class="headerlink" title="4 原型"></a>4 原型</h4><ol><li><code>Object.getPrototypeOf(obj)</code><ul><li>获取对象的Prototype对象，即<code>__proto__</code></li></ul></li><li><code>Object.setPrototypeOf(obj, prototype)</code><ul><li>修改对象的prototype对象</li></ul></li></ol><h4 id="5-状态"><a href="#5-状态" class="headerlink" title="5 状态"></a>5 状态</h4><ol><li><code>Object.preventExtensions(obj)</code><ul><li>让一个对象变的不可扩展，也就是永远不能再添加新的属性</li></ul></li><li><code>Object.isExtensible(obj)</code><ul><li>判断一个对象是否可扩展</li></ul></li><li><code>Object.seal(obj)</code><ul><li>封闭一个对象，此对象不可扩展且对象所有自身属性<code>configurable</code>标记为false </li><li>不能添加、删除属性，属性修饰符不可配置</li></ul></li><li><code>Object.isSealed(obj)</code><ul><li>判断一个对象是否被封闭</li></ul></li><li><code>Object.freeze(obj)</code><ul><li>冻结一个对象，此对象不可扩展且对象所有自身属性 <code>writable configurable</code> 标记为false</li><li>不能添加、修改和删除属性，属性修饰符不可配置</li></ul></li><li><code>Object.isFrozen(obj)</code><ul><li>判断一个对象是否被冻结</li></ul></li></ol><h4 id="6-判断"><a href="#6-判断" class="headerlink" title="6 判断"></a>6 判断</h4><ol><li><code>Object.is(value1, value2)</code><ul><li>判断两个值是否相等，不会作类型转换</li><li>与<code>===</code>的区别<ol><li><code>===</code> 认为<code>-0</code>和<code>+0</code>相等，此方法认为不相等</li><li><code>===</code> 认为<code>NaN</code>和<code>NaN</code>不相等，此方法认为相等</li></ol></li></ul></li></ol><h3 id="3-原型方法"><a href="#3-原型方法" class="headerlink" title="3 原型方法"></a>3 原型方法</h3><ol><li><code>valueOf()</code><ul><li>返回对象原始值，若没有原始值，返回对象本身，通常会覆盖</li></ul></li></ol><table><thead><tr><th>对象</th><th>返回值</th></tr></thead><tbody><tr><td><code>Number</code></td><td>数值</td></tr><tr><td><code>Boolean</code></td><td>布尔值</td></tr><tr><td><code>String</code></td><td>字符串值</td></tr><tr><td><code>Object</code></td><td>对象本身</td></tr><tr><td><code>Array</code></td><td>数组本身</td></tr><tr><td><code>Function</code></td><td>函数本身</td></tr><tr><td><code>Date</code></td><td>距离1970-01-01 00:00:00 的毫秒数</td></tr></tbody></table><ol start="2"><li><code>toString()</code><ul><li>默认返回 <code>[object type]</code>，通常会覆盖</li></ul></li><li><code>toLocaleString()</code><ul><li>默认返回调用 <code>toString()</code> 的结果，可以覆盖</li></ul></li><li><code>hasOwnProperty(prop)</code><ul><li>判断对象自身是否含有某个属性</li></ul></li><li><code>propertyIsEnumerable(prop)</code><ul><li>判断某个属性是否可枚举</li></ul></li><li><code>isPrototypeOf(object)</code><ul><li>判断调用对象是否在另一个对象的原型链上</li><li>和 <code>instanceof</code> 的区别<ul><li><code>A instanceof B</code> ：判断 <code>B.prototype</code>是否在A的原型链上</li><li><code>B.isPrototypeOf(A)</code>：判断B是否在A的原型链上</li></ul></li></ul></li></ol><h2 id="2-2-创建对象方式"><a href="#2-2-创建对象方式" class="headerlink" title="2.2 创建对象方式"></a>2.2 创建对象方式</h2><ol><li>Object构造函数</li><li>对象字面量<ul><li>对象字面量内部调用了Object的构造函数</li></ul></li><li><code>Object.create(proto, [propertiesObject])</code><ul><li>这种方式可以指定原型</li></ul></li></ol><h2 id="2-3-对象字面量"><a href="#2-3-对象字面量" class="headerlink" title="2.3 对象字面量"></a>2.3 对象字面量</h2><ol><li>标准形式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let obj =&#123;</span><br><span class="line">key:value,</span><br><span class="line">key:function()&#123;&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>如果属性值是方法，可以简写<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key:function()&#123;&#125; </span><br><span class="line"> //简写</span><br><span class="line">key()&#123;&#125;</span><br></pre></td></tr></table></figure></li><li>如果属性名是一个表达式，使用<code>[]</code>包裹，意思是取表达式的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = &apos;haha&apos;;</span><br><span class="line">let obj = &#123; [a]:a &#125;; </span><br><span class="line">console.log(obj); // &#123;haha:&apos;haha&apos;&#125;</span><br></pre></td></tr></table></figure></li><li>如果属性值是外部变量的值，属性名与变量名相同时可以简写（其实就是将变量作为对象属性）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a = &apos;haha&apos;；</span><br><span class="line">let obj = &#123; a:a &#125;;</span><br><span class="line">// 简写</span><br><span class="line">let obj = &#123;a&#125;; </span><br><span class="line">console.log(obj); // &#123;a:&apos;haha&apos;&#125;</span><br></pre></td></tr></table></figure></li><li>与json的区别<ol><li>json只允许<code>&quot;property&quot;:value</code>，属性名必须用双引号括起来</li><li>json值仅允许字符串，数字，数组，true，false，null或其他（JSON）对象，值不能是函数</li></ol></li></ol><h2 id="2-4-自定义构造函数"><a href="#2-4-自定义构造函数" class="headerlink" title="2.4 自定义构造函数"></a>2.4 自定义构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 可以空参</span><br><span class="line">function Person(name,age)&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">this.age=age;</span><br><span class="line">this.show=function()&#123;code...&#125;</span><br><span class="line">&#125;</span><br><span class="line">let person=new Person(&quot;xq&quot;,8);</span><br></pre></td></tr></table></figure><h2 id="2-5-工厂函数"><a href="#2-5-工厂函数" class="headerlink" title="2.5 工厂函数"></a>2.5 工厂函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function userFactory(name) &#123;</span><br><span class="line">let obj = &#123;&#125;;</span><br><span class="line">obj.name = name;</span><br><span class="line">obj.show = function()&#123;&#125;;</span><br><span class="line">return obj;</span><br><span class="line">// 或者简写</span><br><span class="line">return &#123;</span><br><span class="line">name,</span><br><span class="line">show()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在函数内部根据传入的参数创建一个对象（可以使用字面量或Object构造等等方式），然后将对象返回，为了复用</li><li>与自定义构造函数方式的区别<ul><li>工厂函数是函数调用，自定义构造是new</li><li>工厂函数是函数名称小写，自定义构造名称大写</li><li>工厂函数内部需要显式创建一个对象，然后根据参数赋值后再显式返回</li><li>自定义构造根据参数自动创建一个对象并返回</li></ul></li></ul><h2 id="2-6-属性管理"><a href="#2-6-属性管理" class="headerlink" title="2.6 属性管理"></a>2.6 属性管理</h2><h3 id="1-属性的访问"><a href="#1-属性的访问" class="headerlink" title="1 属性的访问"></a>1 属性的访问</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 obj.property</span><br><span class="line">2 obj[&apos;property&apos;]</span><br></pre></td></tr></table></figure><ol><li>点后边只能是属性名，中括号中可以是一个表达式</li><li>当属性名称比较特殊时，如数字,空格…，只能用中括号</li><li>当属性名称是变量时，如遍历时，只能用中括号</li></ol><h3 id="2-属性的删除"><a href="#2-属性的删除" class="headerlink" title="2 属性的删除"></a>2 属性的删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 delete object.property </span><br><span class="line">2 delete object[&apos;property&apos;]</span><br></pre></td></tr></table></figure><ol><li>删除自身属性，返回布尔值</li><li>如果要删除的属性不存在，返回true</li></ol><h2 id="2-7-访问器（get-set）"><a href="#2-7-访问器（get-set）" class="headerlink" title="2.7 访问器（get/set）"></a>2.7 访问器（get/set）</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// getter</span><br><span class="line">1 get prop() &#123; ... &#125;</span><br><span class="line">2 get [expression]() &#123; ... &#125;</span><br><span class="line">// setter</span><br><span class="line">1 set prop(val) &#123; . . . &#125;</span><br><span class="line">2 set [expression](val) &#123; . . . &#125;</span><br></pre></td></tr></table></figure><ol><li>函数名可以是一个表达式</li><li>访问器函数调用方式与访问对象属性一样，其实是调用访问器函数<ol><li><code>obj.访问器名</code></li><li><code>obj[&#39;访问器名&#39;]</code></li></ol></li><li>访问器跟属性同名时，如果访问器方法内部访问属性会造成无限循环。</li></ol><h3 id="2-定义方式"><a href="#2-定义方式" class="headerlink" title="2 定义方式"></a>2 定义方式</h3><ol><li>通过配置属性描述符对象定义访问器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">name : &apos;小明&apos;;</span><br><span class="line">&#125;</span><br><span class="line">Object.defineProperty(obj, &apos;name&apos;, &#123;</span><br><span class="line">get() &#123;</span><br><span class="line">return obj.name; // 跟取值方式一样，也会调用get，会无限循环</span><br><span class="line">&#125;,</span><br><span class="line">set(value) &#123;</span><br><span class="line">obj.name = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.name; // 调用get取值</span><br><span class="line">obj.name = &apos;旺财&apos;; // 调用set设置值</span><br></pre></td></tr></table></figure></li><li>对象字面量中直接定义<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">_name: &apos;小明&apos;,</span><br><span class="line">get name() &#123;</span><br><span class="line">return this._name;</span><br><span class="line">&#125;,</span><br><span class="line">set name(value) &#123;</span><br><span class="line">this._name = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-8-对象拷贝"><a href="#2-8-对象拷贝" class="headerlink" title="2.8 对象拷贝"></a>2.8 对象拷贝</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h3><ul><li>浅拷贝<ul><li>如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 </li><li>一个对象修改可能会影响到另一个对象</li></ul></li><li>深拷贝<ul><li>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象</li><li>一个对象修改不会影响到另一个对象</li></ul></li></ul><h3 id="2-浅拷贝方式"><a href="#2-浅拷贝方式" class="headerlink" title="2 浅拷贝方式"></a>2 浅拷贝方式</h3><ol><li>创建新对象，然后使用<code>for...in</code>遍历原对象属性并一个一个连值一起添加到新对象上<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let source = &#123;name:&apos;an3&apos;, age:18&#125;;</span><br><span class="line">let cp = &#123;&#125;;</span><br><span class="line">for (const key in source)&#123;</span><br><span class="line">if(source.hasOwnProperty(key)&#123;</span><br><span class="line">cp[key] = source[key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用<code>Object.assign(目标对象, 原对象列表)</code>，并将目标对象设为空对象，就相当于返回了对原对象的浅拷贝<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let source = &#123;name:&apos;an3&apos;, age:18&#125;;</span><br><span class="line">let cp = Object.assign(&#123;&#125;, source);</span><br></pre></td></tr></table></figure></li><li>展开语法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let source = &#123;name:&apos;an3&apos;, age:18&#125;;</span><br><span class="line">let cp = &#123;...source&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-深拷贝方式"><a href="#3-深拷贝方式" class="headerlink" title="3 深拷贝方式"></a>3 深拷贝方式</h3><ol><li>使用JSON<ol><li>步骤<ol><li><code>JSON.stringify()</code>：将一个对象序列成一个字符串</li><li><code>JSON.parse()</code>：将字符串反序列化生成深拷贝对象</li></ol></li><li>注意<ol><li>拷贝的对象的值中如果有函数,undefined,symbol则经过JSON.stringify()序列化后的JSON字符串中这个键值对会消失</li><li>无法拷贝不可枚举的属性，无法拷贝对象的原型链</li><li>拷贝Date引用类型会变成字符串</li><li>拷贝RegExp引用类型会变成空对象</li><li>对象中含有NaN、Infinity和-Infinity，则序列化的结果会变成null</li><li>无法拷贝对象的循环应用(即obj[key] = obj)</li></ol></li></ol></li><li>递归<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy(obj) &#123;</span><br><span class="line">// 对象的属性值有可能是数组，判断一下防止递归时把数组变成了对象</span><br><span class="line">let cpObj = obj instanceof Array ? [] : &#123;&#125;;</span><br><span class="line">// 我用for in 也可以，但for in 不推荐用来遍历数组，Object.entries()方法对于对象和数组返回结果形式是一样的</span><br><span class="line">for(const [k, v] of Object.entries(obj)) &#123;</span><br><span class="line">// 判断对象属性如果是引用类型就递归拷贝，最终就是深拷贝</span><br><span class="line">cpObj[k] = typeof v == &apos;object&apos; ? deepCopy(v) : v;</span><br><span class="line">&#125;  </span><br><span class="line">return cpObj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>原理就是浅拷贝只拷贝一层，那我们就递归，如果这一层属性的值是引用类型，就再拷贝一层……</li></ul></li></ol><h2 id="2-9-代理"><a href="#2-9-代理" class="headerlink" title="2.9 代理"></a>2.9 代理</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>代理（拦截器）是对象的访问控制，setter/getter 访问器是对对象单个属性的控制</li></ol><h3 id="2-Proxy"><a href="#2-Proxy" class="headerlink" title="2 Proxy"></a>2 Proxy</h3><h4 id="1-构造函数-1"><a href="#1-构造函数-1" class="headerlink" title="1 构造函数"></a>1 构造函数</h4><ul><li><code>new Proxy(target, handler)</code><ul><li>返回一个Proxy实例</li><li><code>target</code><ul><li>用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）</li></ul></li><li><code>handler</code><ul><li>处理器对象，有许多拦截相应操作的函数，如果没有配置，则执行默认操作</li><li>注意：处理操作都是针对代理对象的，目标对象无效。</li></ul></li></ul></li></ul><h4 id="2-handler"><a href="#2-handler" class="headerlink" title="2 handler"></a>2 handler</h4><ol><li><code>get(target, property, receiver)</code><ul><li>参数<ul><li><code>target</code><ul><li>目标对象</li></ul></li><li><code>property</code><ul><li>获取的属性名</li></ul></li><li><code>reveiver</code><ul><li>Proxy或者继承Proxy的对象</li></ul></li></ul></li><li>说明<ul><li>get 方法拦截属性的获取，可以返回任何值</li></ul></li></ul></li><li><code>set(target, property, value, receiver)</code><ul><li>参数<ul><li><code>value</code><ul><li>被设置的新值</li></ul></li></ul></li><li>说明<ul><li>set 方法拦截属性的设置</li><li>严格模式下 set 必须返回布尔值，且如果返回false会报错</li></ul></li></ul></li><li><code>apply(target, thisArg, argumentsList)</code><ul><li>参数<ul><li><code>target</code><ul><li>目标函数</li></ul></li><li><code>thisArg</code><ul><li>被调用时的上下文对象</li></ul></li><li><code>argumentsList</code><ul><li>被调用时的参数数组</li></ul></li></ul></li><li>说明<ul><li>apply 方法拦截函数调用，可以返回任何值<ol><li>直接调用</li><li><code>Function.prototype.call()</code> 方式调用</li><li><code>Function.prototype.apply()</code> 方式调用</li><li><code>Reflet.apply()</code> 方式调用</li></ol></li></ul></li></ul></li><li><code>has(target, prop)</code><ul><li>参数<ul><li><code>target</code><ul><li>目标对象</li></ul></li><li><code>prop</code><ul><li>需要检查是否存在的属性.</li></ul></li></ul></li><li>说明<ul><li>拦截 <code>prop in object</code> 语句，返回布尔值</li></ul></li></ul></li><li><code>construct(target, argumentsList, newTarget)</code><ul><li>参数<ul><li><code>target</code><ul><li>目标构造函数</li></ul></li><li><code>argumentsList</code><ul><li>constructor的参数列表</li></ul></li><li><code>newTarget</code><ul><li>生成的代理对象（即代理构造函数）</li></ul></li></ul></li><li>说明<ul><li>拦截new操作，必须返回一个对象</li></ul></li></ul></li><li><code>deleteProperty(target, prop)</code><ul><li>拦截<code>delete</code> 操作，必须返回布尔值</li></ul></li><li><code>defineProperty(target, property, descriptor)</code><ul><li>拦截<code>Object.defineProperty()</code>，必须返回布尔值</li></ul></li><li><code>getOwnPropertyDescriptor(target, prop)</code><ul><li>拦截 <code>Object.getOwnPropertyDescriptor()</code>，必须返回一个对象或undefined</li></ul></li><li><code>getPrototypeOf(target)</code><ul><li>拦截获取原型操作</li></ul></li><li><code>setPrototypeOf(target, prototype)</code><ul><li>拦截设置原型操作，返回布尔值</li></ul></li><li><code>preventExtensions(target)</code><ul><li>拦截<code>Object.preventExtensions()</code>，返回一个布尔值</li></ul></li><li><code>isExtensible(target)</code><ul><li>拦截<code>Object.isExtensible()</code>，必须返回布尔值</li></ul></li><li><code>ownKeys(target)</code><ul><li>拦截对象获取自身属性的操作</li></ul></li></ol><h2 id="2-10-Reflect"><a href="#2-10-Reflect" class="headerlink" title="2.10 Reflect"></a>2.10 Reflect</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>Reflect不是一个构造函数，不能new，Reflect的所有属性和方法都是静态的（就像Math对象）。</li><li>将Object对象的一些明显属于语言内部的方法（如Object.defineProperty），放到Reflect对象上</li><li>修改某些Object方法的返回结果，让其变得更合理<ul><li>如Object.defineProperty无法定义属性时，会抛出错误，而Reflect.defineProperty会返回false</li></ul></li><li>让Object操作都变成函数行为<ul><li>如 <code>prop in object</code> ，对应<code>Reflect.has(obj, prop)</code></li><li><code>delete obj.prop</code>，对应<code>Reflect.deleteProperty(obj, prop)</code></li></ul></li><li>Reflect对象与Proxy的handler 方法完全一致，在使用代理拦截某些操作时，使用Reflect的方法可以保证原生行为能正常执行。</li></ol><h3 id="2-静态方法-1"><a href="#2-静态方法-1" class="headerlink" title="2 静态方法"></a>2 静态方法</h3><ul><li>见Proxy handler</li></ul><h2 id="2-11-this-amp-super"><a href="#2-11-this-amp-super" class="headerlink" title="2.11 this &amp; super"></a>2.11 this &amp; super</h2><h3 id="1-this"><a href="#1-this" class="headerlink" title="1 this"></a>1 this</h3><ol><li>在全局环境中 或者 在函数中<ol><li>非严格模式：this指向顶层对象window</li><li>严格模式：this为undefined</li></ol></li><li>在对象中，this代表当前对象的引用</li><li>在对象方法（对象的属性是函数则称为方法）中，this指向调用该方法的对象</li><li>在箭头函数中，this与定义箭头函数时所在的环境指向同一个this</li><li>在构造函数中，this指向正在构造的新对象</li><li>在DOM事件处理函数中，this指向触发事件的元素</li><li>在内联事件处理函数中，this指向监听器所在的DOM元素</li></ol><h3 id="2-super"><a href="#2-super" class="headerlink" title="2 super"></a>2 super</h3><ul><li>super指向当前对象的原型对象</li></ul><h1 id="三-数组"><a href="#三-数组" class="headerlink" title="三 数组"></a>三 数组</h1><h2 id="3-1-Array"><a href="#3-1-Array" class="headerlink" title="3.1 Array"></a>3.1 Array</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>数组都是Array对象的实例</li><li>数组可以存任意类型的数据</li><li>数组长度可变</li><li>ES6 明确数组中空位值为undefined</li><li>数组字面量<ul><li><code>[ele0, ele1, ..., eleN]</code></li></ul></li></ol><h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2 构造函数"></a>2 构造函数</h3><ol><li><code>Array()</code> 和 <code>new Array()</code> 是等同的</li><li><code>new Array(arrayLength)</code><ul><li>如果参数只有一个且是 0-2<sup>32</sup>-1 之间的整数，则创建一个指定长度的数组</li></ul></li><li><code>new Array(element0, element1[, ...[, elementN]])</code><ul><li>创建一个指定元素的数组</li></ul></li></ol><h3 id="3-静态属性"><a href="#3-静态属性" class="headerlink" title="3 静态属性"></a>3 静态属性</h3><ul><li><code>length</code></li></ul><h3 id="4-静态方法"><a href="#4-静态方法" class="headerlink" title="4  静态方法"></a>4  静态方法</h3><ol><li><code>Array.isArray(obj)</code><ul><li>如果值是 Array，则返回true，否则返回false</li><li>用来弥补<code>typeof</code>，因为<code>typeof 数组</code> 返回的是<code>object</code></li></ul></li><li><code>Array.of(element0[, element1[, ...[, elementN]]])</code><ul><li>将一组值转换为数组</li><li>用来弥补构造函数，构造函数参数个数不同会导致结果不同。</li></ul></li><li><code>Array.from(arrayLike[, mapFn[, thisArg]])</code><ul><li>从一个类数组对象或可迭代对象创建一个新的浅拷贝的数组实例并返回</li><li><code>mapFn</code><ul><li>如果指定了该参数，新数组中的每个元素都会执行该回调函数</li></ul></li><li><code>thisArg</code><ul><li>执行回调函数 mapFn 时的 this 对象</li></ul></li></ul></li></ol><h3 id="5-原型方法"><a href="#5-原型方法" class="headerlink" title="5 原型方法"></a>5 原型方法</h3><h4 id="1-获取-1"><a href="#1-获取-1" class="headerlink" title="1 获取"></a>1 获取</h4><ol><li><code>valueOf()</code><ul><li>返回数组本身</li></ul></li><li><code>toString()</code><ul><li>返回数组的字符串形式</li></ul></li><li><code>join([separator])</code><ul><li>以指定分隔符（默认为逗号）将所有数组成员连接为一个字符串返回</li></ul></li></ol><h4 id="2-增删改"><a href="#2-增删改" class="headerlink" title="2 增删改"></a>2 增删改</h4><ol><li><code>push(element1, ..., elementN)</code><ul><li>将一个或多个元素添加到数组的末尾，并返回该数组的新长度，改变原数组</li><li>如果参数为数组，把数组作为元素添加到数组中。(二维数组)</li></ul></li><li><code>pop()</code><ul><li>删除并返回最后一个元素，改变原数组</li></ul></li><li><code>unshift(element1, ..., elementN)</code><ul><li>将一个或多个元素添加到数组的开头，并返回该数组的新长度，改变原数组</li><li>参数可以是数组（二维数组）</li></ul></li><li><code>shift()</code><ul><li>删除并返回第一个元素，改变原数组</li></ul></li><li><code>fill(value[, start[, end]])</code><ul><li>使用指定值填充数组，可指定开始结束索引，返回修改后的数组</li></ul></li><li><code>slice([begin[, end]])</code><ul><li>提取目标数组的一部分，返回一个浅拷贝新数组，原数组不变</li></ul></li><li><code>splice(start[, deleteCount[, item1[, item2[, ...]]]])</code><ul><li>删除目标数组的一部分成员，并可以在删除的位置添加新的数组成员，返回被删除的元素组成的数组，改变原数组</li></ul></li><li><code>concat(value1, value2, ..., valueN)</code><ul><li>将一个或多个值合并到数组中，返回新数组，不改变原数组</li></ul></li><li><code>copyWithin(target[, start[, end]])</code><ul><li>复制数组的一部分到数组指定位置（覆盖原有成员），并返回数组，改变原数组但不改变数组长度（因为会覆盖原有成员）</li><li><code>target</code><ul><li>目标位置</li></ul></li><li><code>start</code><ul><li>复制的起始索引，默认为0</li></ul></li><li><code>end</code><ul><li>复制的终止索引（不含），默认为尾部</li></ul></li></ul></li><li><code>flat([depth])</code><ul><li>将数组降维，返回新数组，不改变原数组</li><li><code>depth</code><ul><li>指定结构深度，默认值为 1，即只可以将二维数组合并成一维数组</li></ul></li></ul></li><li><code>flatMap(callback[, thisArg])</code><ul><li>对数组中每一个元素执行回调函数，然后对返回值组成的数组执行flat()方法，结构深度 depth 值为1，返回新数组</li><li><code>callback(currentValue[, index[, array]])</code><ul><li><code>currentValue</code>：当前遍历的元素</li><li><code>index</code>：当前遍历到的索引</li><li><code>array</code>：当前数组</li></ul></li></ul></li></ol><h4 id="3-查"><a href="#3-查" class="headerlink" title="3 查"></a>3 查</h4><ol><li><code>indexOf(searchElement[, fromIndex])</code><ul><li>返回第一个匹配索引，如果不存在，则返回-1</li></ul></li><li><code>lastIndexOf(searchElement[, fromIndex])</code><ul><li>返回从后往前的第一个匹配索引，如果不存在，则返回-1</li></ul></li><li><code>includes(valueToFind[, fromIndex])</code><ul><li>判断数组是否包含指定元素</li></ul></li><li><code>find(callback[, thisArg])</code><ul><li>返回数组中第一个满足所提供测试函数（返回true）的元素的值，否则返回 undefined</li><li><code>callback(element[, index[, array]])</code><ul><li><code>element</code>：当前遍历的元素</li><li><code>index</code>：当前遍历到的索引</li><li><code>array</code>：当前数组</li></ul></li><li><code>thisArg</code><ul><li>执行回调时函数时this 指向的对象。</li></ul></li></ul></li><li><code>findIndex(callback[, thisArg])</code><ul><li>返回数组中第一个满足所提供测试函数（返回true）的元素的索引，否则返回 -1</li></ul></li></ol><h4 id="4-排序"><a href="#4-排序" class="headerlink" title="4 排序"></a>4 排序</h4><ol><li><code>reverse()</code><ul><li>反转数组并返回，改变原数组</li></ul></li><li><code>sort([compareFunction])</code><ul><li>默认是按照字典顺序排序，返回排序后的数组，改变原数组</li><li><code>compareFunction(value1, value2)</code><ul><li>返回一个数字，如果小于0则value1排在value2之前</li></ul></li></ul></li></ol><h4 id="5-循环遍历"><a href="#5-循环遍历" class="headerlink" title="5 循环遍历"></a>5 循环遍历</h4><ol><li><code>forEach(callback[, thisArg])</code><ul><li><code>callback(currentValue[, index[, array]])</code><ul><li><code>currentValue</code>：当前遍历的元素</li><li><code>index</code>：当前遍历到的索引</li><li><code>array</code>：当前数组</li></ul></li></ul></li><li><code>keys()</code><ul><li>返回数组元素键的迭代器对象</li></ul></li><li><code>values()</code><ul><li>返回数组元素值的迭代器对象</li></ul></li><li><code>entries()</code><ul><li>返回数组元素键值对的迭代器对象</li></ul></li></ol><h4 id="6-扩展方法"><a href="#6-扩展方法" class="headerlink" title="6 扩展方法"></a>6 扩展方法</h4><ol><li><code>every(callback[, thisArg])</code><ul><li>判断数组元素是否全部能通过指定测试函数，返回布尔值，碰到一个元素返回false，则every立即返回false</li><li><code>callback(element[, index[, array]])</code><ul><li><code>element</code>：当前遍历的元素</li><li><code>index</code>：当前遍历到的索引</li><li><code>array</code>：当前数组</li></ul></li></ul></li><li><code>some(callback[, thisArg])</code><ul><li>数组中有至少一个元素通过回调函数的测试就会返回true；</li></ul></li><li><code>filter(callback[, thisArg])</code><ul><li>返回一个新的由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组</li></ul></li><li><code>map(callback[, thisArg])</code><ul><li>对数组中每一个元素执行回调函数，返回每一个回调函数结果组成的新数组</li></ul></li><li><code>reduce(callback[, initialValue])</code><ul><li>返回回调函数累计处理的结果</li><li><code>callback(accumulator, currentValue[, index[, array]])</code><ul><li><code>accumulator</code><ul><li>第一次循环<ol><li>有<code>initialValue</code>，则为<code>initialValue</code></li><li>无<code>initialValue</code>，则为数组第一个元素</li></ol></li><li>从第二次循环往后为回调函数返回值</li></ul></li><li><code>currentValue</code><ul><li>数组中当前循环的元素</li><li>第一次循环时，如果没有<code>initialValue</code>，由于<code>accumulator</code>是数组第一个元素，则<code>currentValue</code>会从第二个元素开始循环</li></ul></li><li><code>index</code><ul><li>数组中当前循环的元素的索引</li></ul></li><li><code>array</code><ul><li>当前数组</li></ul></li></ul></li></ul></li><li><code>reduceRight(callback[, initialValue])</code><ul><li>与<code>reduce()</code>相似，只是从右向左遍历数组</li></ul></li></ol><h1 id="四-函数"><a href="#四-函数" class="headerlink" title="四 函数"></a>四 函数</h1><h2 id="4-1-Function"><a href="#4-1-Function" class="headerlink" title="4.1 Function"></a>4.1 Function</h2><h3 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1 概述"></a>1 概述</h3><ul><li>每个 JavaScript 函数都是一个 Function 对象</li></ul><h3 id="2-构造函数-1"><a href="#2-构造函数-1" class="headerlink" title="2 构造函数"></a>2 构造函数</h3><ul><li><code>new Function ([arg1[, arg2[, ...argN]],] functionBody)</code><ul><li><code>arg1, arg2, ... argN</code><ul><li>字符串，字符串中多个参数用逗号分隔</li></ul></li><li><code>functionBody</code><ul><li>函数体的字符串</li></ul></li></ul></li></ul><h3 id="3-静态属性-1"><a href="#3-静态属性-1" class="headerlink" title="3 静态属性"></a>3 静态属性</h3><ol><li><code>Function.length</code><ul><li>函数的形参个数</li></ul></li><li><code>Function.name</code><ul><li>函数的名称</li></ul></li></ol><h3 id="4-原型方法"><a href="#4-原型方法" class="headerlink" title="4 原型方法"></a>4 原型方法</h3><ol><li><code>call(thisArg, arg1, arg2, ...)</code><ul><li>使用指定的 this 值和参数列表来调用此函数</li><li><code>thisArg</code><ul><li>函数运行时this的值</li></ul></li><li>与 bind 不同 call/apply 会立即执行函数</li></ul></li><li><code>apply(thisArg, [argsArray])</code><ul><li>同<code>call()</code>，不同的是接受的是一个参数数组</li></ul></li><li><code>bind(thisArg[, arg1[, arg2[, ...]]])</code><ul><li>使用指定的this和参数列表创建一个原函数的拷贝并返回</li><li>call() 和 apply() 用来执行函数，bind()用来创建函数，即不会立即执行</li><li>bind设置的参数优先级高（即调用时设置的相应参数无效）</li></ul></li><li><code>toString()</code><ul><li>返回表示函数源代码的字符串</li></ul></li></ol><h2 id="4-2-立即执行函数（IIFE-Imdiately-Invoked-Function-Expression）"><a href="#4-2-立即执行函数（IIFE-Imdiately-Invoked-Function-Expression）" class="headerlink" title="4.2 立即执行函数（IIFE Imdiately Invoked Function Expression）"></a>4.2 立即执行函数（IIFE Imdiately Invoked Function Expression）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 (function()&#123;...&#125;())</span><br><span class="line">2 (function()&#123;...&#125;)()</span><br></pre></td></tr></table></figure><ol><li>不必为函数命名</li><li>形成单独的作用域，封装遍历，避免重名…</li></ol><h2 id="4-3-定义函数"><a href="#4-3-定义函数" class="headerlink" title="4.3 定义函数"></a>4.3 定义函数</h2><h3 id="1-函数声明"><a href="#1-函数声明" class="headerlink" title="1 函数声明"></a>1 函数声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 函数名(参数列表) &#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>函数提升，提升优先级高于var变量提升</li><li>函数会添加到window对象中</li><li>优先级高于函数表达式</li></ol><h3 id="2-函数表达式"><a href="#2-函数表达式" class="headerlink" title="2 函数表达式"></a>2 函数表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var/let/const 函数名 = function (参数列表) &#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>函数不会提升</li><li>var声明的函数会添加到window对象中，但let/const则不会</li></ol><h3 id="3-Function构造函数"><a href="#3-Function构造函数" class="headerlink" title="3 Function构造函数"></a>3 Function构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var/let/const 函数名 = new Function(&quot;参数列表&quot;,&quot;函数体&quot;);</span><br></pre></td></tr></table></figure><ol><li>函数不会提升</li><li>var声明的函数会添加到window对象中，但let/const则不会</li></ol><h2 id="4-4-参数"><a href="#4-4-参数" class="headerlink" title="4.4 参数"></a>4.4 参数</h2><h3 id="1-形参-amp-实参"><a href="#1-形参-amp-实参" class="headerlink" title="1 形参 &amp; 实参"></a>1 形参 &amp; 实参</h3><ul><li>形参是默认声明的，不用var/let/const修饰</li><li>实参数量小于形参时，没有传递的形参值为 undefined</li><li>实参数量大于形参时，多余的实参将忽略并不会报错</li></ul><h3 id="2-参数默认值"><a href="#2-参数默认值" class="headerlink" title="2 参数默认值"></a>2 参数默认值</h3><ul><li>在形参上可以直接定义参数默认值，如果传递对应参数则使用传递值，否则使用默认值</li></ul><h3 id="3-arguments"><a href="#3-arguments" class="headerlink" title="3 arguments"></a>3 arguments</h3><ul><li>arguments 对象是所有（非箭头）函数中都可用的局部变量，是一个类数组对象，存储了传递的实参</li></ul><h2 id="4-5-箭头函数"><a href="#4-5-箭头函数" class="headerlink" title="4.5 箭头函数"></a>4.5 箭头函数</h2><h3 id="1-概述-4"><a href="#1-概述-4" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>箭头函数内部的<code>this</code> 是固定的，指向定义时所在的环境的this</li><li>箭头函数不可以当作构造函数，也就是说，不可以使用new命令</li><li>箭头函数内部不存在<code>arguments</code> 对象</li><li>箭头函数不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数</li></ol><h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2 语法"></a>2 语法</h3><ol><li>基础语法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(param1, param2, …, paramN) =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure></li><li>没有参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure></li><li>只有一个参数，小括号可以省略<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">singleParam =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure></li><li>函数体只有一句，return、分号和大括号都可以省略<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(param1, param2, …, paramN) =&gt; expression</span><br><span class="line">//相当于</span><br><span class="line">(param1, param2, …, paramN) =&gt;&#123; return expression; &#125;</span><br><span class="line">// 返回对象</span><br><span class="line">(param1, param2, …, paramN) =&gt; (&#123;name: &apos;xiaoming&apos;&#125;)</span><br></pre></td></tr></table></figure><ul><li>注意：如果返回的是一个对象，要用<code>()</code>包括，因为<code>{}</code>会被认为是一个代码块</li></ul></li></ol><h1 id="五-集合"><a href="#五-集合" class="headerlink" title="五 集合"></a>五 集合</h1><h2 id="5-1-Set"><a href="#5-1-Set" class="headerlink" title="5.1 Set"></a>5.1 Set</h2><h3 id="1-概述-5"><a href="#1-概述-5" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>Set中的元素有序（存取顺序一致） 唯一</li><li>基本数据类型和引用数据类型都可以存储（包括NaN，undefined和null）</li><li>元素相等 基于 <code>sameValueZero</code> 算法<ul><li>类似<code>===</code>，除了NaN不同，<code>NaN === NaN</code>返回false，但是在Set中看作相等</li></ul></li></ol><h3 id="2-构造函数-2"><a href="#2-构造函数-2" class="headerlink" title="2 构造函数"></a>2 构造函数</h3><ul><li><code>new Set([iterable])</code><ul><li><code>iterable</code><ul><li>可迭代对象，它的所有元素将不重复地被添加到 Set中。</li><li>如果省略或其值为null，则新的 Set为空</li></ul></li></ul></li></ul><h3 id="3-原型属性"><a href="#3-原型属性" class="headerlink" title="3 原型属性"></a>3 原型属性</h3><ol><li><code>size</code><ul><li>返回Set对象中元素的个数</li></ul></li></ol><h3 id="4-原型方法-1"><a href="#4-原型方法-1" class="headerlink" title="4 原型方法"></a>4 原型方法</h3><ol><li><code>add(value)</code><ul><li>向Set末尾添加元素，返回Set</li></ul></li><li><code>delete(value)</code><ul><li>从Set 中删除指定元素，成功删除返回 true，否则返回 false</li></ul></li><li><code>has(value)</code><ul><li>判断Set中是否有指定的元素</li></ul></li><li><code>clear()</code><ul><li>清空Set</li></ul></li><li><code>keys()</code><ul><li>由于 Set 结构没有键，只有值，keys() 与 values() 完全一样</li></ul></li><li><code>values()</code><ul><li>返回值的迭代器对象</li></ul></li><li><code>entries()</code><ul><li>返回键值对的迭代器对象</li><li>键值对形式为<code>[value, value]</code>，即Set中的元素即是键也是值</li></ul></li><li><code>forEach(callback[, thisArg])</code> <ul><li>根据集合中元素的插入顺序，依次执行提供的回调函数</li><li><code>callback([currentValue[, currentKey[, set]]])</code><ul><li><code>currentValue</code><ul><li>当前元素</li></ul></li><li><code>currentKey</code><ul><li>由于Set没有键，currentKey与currentValue永远都一样，即也是当前元素</li></ul></li><li><code>set</code><ul><li>当前Set</li></ul></li></ul></li><li><code>thisArg</code><ul><li>回调函数执行过程中的 this 值</li></ul></li></ul></li></ol><h3 id="6-Set转数组"><a href="#6-Set转数组" class="headerlink" title="6 Set转数组"></a>6 Set转数组</h3><ol><li>展开语法<ul><li><code>...set</code></li></ul></li><li><code>Array.from(set)</code></li></ol><h2 id="5-2-WeakSet"><a href="#5-2-WeakSet" class="headerlink" title="5.2 WeakSet"></a>5.2 WeakSet</h2><ol><li>用法同Set大致相同</li><li>与Set的区别<ol><li>WeakSet只能存引用数据类型</li><li>WeakSet是弱引用<ul><li>当对象引用数量为0时，会被垃圾回收掉，弱引用的意思就是不会增加对象的引用数量。</li></ul></li><li>WeakSet 不可遍历<ul><li>因为WeakSet弱引用，其中的对象随时有可能别垃圾回收掉</li></ul></li><li>没有<code>size</code> 属性</li><li>原型方法只有 <code>add() delete() has()</code></li></ol></li></ol><h2 id="5-3-Map"><a href="#5-3-Map" class="headerlink" title="5.3 Map"></a>5.3 Map</h2><h3 id="1-概述-6"><a href="#1-概述-6" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>Map是键值对的集合，且键有序（存取一致）</li><li>对象的键只能是字符串，Map的键可以是任何值</li><li>如果键相等，后边的值回覆盖前边，键相等 基于 <code>sameValueZero</code> 算法<ul><li>类似<code>===</code>，除了NaN不同，<code>NaN === NaN</code>返回false，但是在Map中看作相等</li></ul></li></ol><h3 id="2-构造函数-3"><a href="#2-构造函数-3" class="headerlink" title="2 构造函数"></a>2 构造函数</h3><ul><li><code>new Map([iterable])</code><ul><li><code>iterable</code><ul><li>可迭代对象，其元素为键值对。</li><li>如数组为 <code>[[&#39;name&#39;,&#39;xiaoming&#39;],[&#39;age&#39;,18]]</code></li></ul></li></ul></li></ul><h3 id="3-原型属性-1"><a href="#3-原型属性-1" class="headerlink" title="3 原型属性"></a>3 原型属性</h3><ol><li><code>size</code><ul><li>返回Map中键值对的个数</li></ul></li></ol><h3 id="4-原型方法-2"><a href="#4-原型方法-2" class="headerlink" title="4 原型方法"></a>4 原型方法</h3><ol><li><code>set(key, value)</code><ul><li>向Map添加元素，返回Map</li></ul></li><li><code>get(key)</code><ul><li>根据key获取value，没有返回undefined</li></ul></li><li><code>delete(key)</code><ul><li>根据key删除元素，删除成功返回true，否则返回false</li></ul></li><li><code>clear()</code><ul><li>清空Map</li></ul></li><li><code>has(key)</code><ul><li>判断指定key的元素是否存在</li></ul></li><li><code>keys()</code><ul><li>返回键的迭代器对象</li></ul></li><li><code>values()</code><ul><li>返回值的迭代器对象</li></ul></li><li><code>entries()</code><ul><li>返回键值对<code>[key, value]</code>的迭代器对象</li></ul></li><li><code>forEach(callback[, thisArg])</code><ul><li>根据集合中元素的插入顺序，依次执行提供的回调函数</li><li><code>callback([value[, key[, map]]])</code></li></ul></li></ol><h3 id="5-Map转数组"><a href="#5-Map转数组" class="headerlink" title="5 Map转数组"></a>5 Map转数组</h3><ul><li>展开语法<ul><li><code>...map</code></li></ul></li></ul><h2 id="5-4-WeakMap"><a href="#5-4-WeakMap" class="headerlink" title="5.4 WeakMap"></a>5.4 WeakMap</h2><ol><li>用法同Map大致相同</li><li>与Map的区别<ol><li>WeakMap的键只能是引用数据类型（不能为null）</li><li>WeakMap的键是弱引用</li><li>WeakMap不能遍历</li><li>WeakMap没有<code>size</code>属性</li><li>WeakMap原型方法只有 <code>set() get() delete() has()</code></li></ol></li></ol><h1 id="六-Date"><a href="#六-Date" class="headerlink" title="六 Date"></a>六 Date</h1><h2 id="6-1-构造函数"><a href="#6-1-构造函数" class="headerlink" title="6.1 构造函数"></a>6.1 构造函数</h2><ol><li><code>Date([value])</code><ul><li>普通函数，无论有没有参数，都返回当前日期和时间的字符串</li></ul></li><li><code>new Date()</code><ol><li><code>new Date()</code><ul><li>创建一个当前日期和时间的Date对象</li></ul></li><li><code>new Date(value)</code><ul><li><code>value</code><ul><li>Unix 时间戳，是一个整数值，表示自1970年1月1日00:00:00 UTC（the Unix epoch）以来的毫秒数</li></ul></li></ul></li><li><code>new Date(dateString)</code><ul><li><code>dateString</code><ul><li>表示日期的字符串。该字符串能被 <code>Date.parse()</code>正确识别</li></ul></li></ul></li><li><code>new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]])</code><ul><li>分别指定年月日时分秒毫秒</li></ul></li></ol></li></ol><h2 id="6-2-静态方法"><a href="#6-2-静态方法" class="headerlink" title="6.2 静态方法"></a>6.2 静态方法</h2><ol><li><code>Date.now()</code><ul><li>返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数</li></ul></li><li><code>Date.parse(dateString)</code><ul><li>解析日期字符串，返回该时间距离时间零点的毫秒数。</li></ul></li><li><code>Date.UTC(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]])</code><ul><li>返回该时间距离时间零点的毫秒数</li></ul></li></ol><h2 id="6-3-原型方法"><a href="#6-3-原型方法" class="headerlink" title="6.3 原型方法"></a>6.3 原型方法</h2><h3 id="1-to"><a href="#1-to" class="headerlink" title="1 to"></a>1 to</h3><ol><li><code>valueOf()</code><ul><li>返回实例对象距离时间零点对应的毫秒数，同<code>getTime()</code></li></ul></li><li><code>toString()</code> / <code>toDateString()</code> / <code>toTimeString()</code><ul><li>返回一个日期时间字符串 / 日期字符串 / 时间字符串</li></ul></li><li><code>toLocaleString()</code> / <code>toLocaleDateString()</code> / <code>toLocaleTimeString()</code><ul><li>返回一个本地日期时间字符串 / 本地日期字符串 / 本地时间字符串</li></ul></li><li><code>toUTCString()</code><ul><li>返回使用UTC时区表示给定日期的字符串，比北京时间晚8个小时</li></ul></li><li><code>toISOString()</code><ul><li>返回对应时间的 ISO8601 写法的字符串</li></ul></li><li><code>toJSON()</code><ul><li>返回一个符合 JSON 格式的 ISO 日期字符串，与<code>toISOString()</code>方法的返回结果完全相同</li></ul></li></ol><h3 id="2-get"><a href="#2-get" class="headerlink" title="2 get"></a>2 get</h3><ol><li><code>getTime()</code><ul><li>返回Date实例距离事件元点的毫秒数</li></ul></li><li><code>getFullYear</code><ul><li>四位数的年份</li></ul></li><li><code>getMonth()</code><ul><li>月 0-11</li></ul></li><li><code>getDate()</code><ul><li>日 1-31</li></ul></li><li><code>getDay()</code><ul><li>星期 0-6</li></ul></li><li><code>getHours()</code><ul><li>时 0-23</li></ul></li><li><code>getMinutes()</code><ul><li>分 0-59</li></ul></li><li><code>getSeconds()</code><ul><li>秒 0-59</li></ul></li><li><code>getMilliseconds</code><ul><li>毫秒 0-999</li></ul></li></ol><h3 id="3-set"><a href="#3-set" class="headerlink" title="3 set"></a>3 set</h3><ul><li>set 与 get 一一相对应，除了没有 <code>setDay()</code>，因为星期是算的</li></ul><h1 id="七-RegExp"><a href="#七-RegExp" class="headerlink" title="七 RegExp"></a>七 RegExp</h1><h2 id="7-1-构造函数"><a href="#7-1-构造函数" class="headerlink" title="7.1 构造函数"></a>7.1 构造函数</h2><ol><li><code>RegExp()</code> 和 <code>new RegExp()</code> 一样，返回正则对象</li><li><code>new RegExp(pattern [, flags])</code> <ul><li><code>pattern</code><ul><li>正则表达式的文本</li></ul></li><li><code>flags</code><ul><li>修饰符，可以是<code>g i m u y s</code>的任意组合</li></ul></li></ul></li></ol><h2 id="7-2-字面量"><a href="#7-2-字面量" class="headerlink" title="7.2 字面量"></a>7.2 字面量</h2><ul><li><code>/pattern/flags</code><ul><li><code>/</code> 斜杠表示开始和结束</li></ul></li></ul><h2 id="7-3-原型属性"><a href="#7-3-原型属性" class="headerlink" title="7.3 原型属性"></a>7.3 原型属性</h2><ol><li><code>global</code><ul><li>只读，返回一个布尔值，判断是否设置了修饰符<code>g</code></li></ul></li><li><code>ignoreCase</code><ul><li>只读，返回一个布尔值，判断是否设置了修饰符<code>i</code></li></ul></li><li><code>multiline</code><ul><li>只读，返回一个布尔值，判断是否设置了修饰符<code>m</code></li></ul></li><li><code>unicode</code><ul><li>只读，返回一个布尔值，判断是否设置了修饰符<code>u</code></li></ul></li><li><code>sticky</code><ul><li>只读，返回一个布尔值，判断是否设置了修饰符<code>y</code></li></ul></li><li><code>dotAll</code><ul><li>只读，返回一个布尔值，判断是否设置了修饰符<code>s</code></li></ul></li><li><code>flags</code><ul><li>只读，返回一个字符串，包含已经设置的所有修饰符，按字母排序</li></ul></li><li><code>source</code><ul><li>只读，返回正则表达式文本字符串，该字符串不包含正则字面量两边的斜杠以及任何的标志字符    </li></ul></li><li><code>lastIndex</code><ul><li>可读写，用来指定下一次匹配的起始索引。只有正则表达式使用了表示全局检索的 “g” 标志时，该属性才会起作用</li></ul></li></ol><h2 id="7-4-原型方法"><a href="#7-4-原型方法" class="headerlink" title="7.4 原型方法"></a>7.4 原型方法</h2><ol><li><code>test(str)</code><ul><li>如果正则表达式与指定的字符串匹配 ，返回true；否则false</li><li>更新正则对象的<code>lastIndex</code>属性</li></ul></li><li><code>exec(str)</code><ul><li>如果匹配成功，返回一个数组且具有详细信息，并更新正则表达式对象的 lastIndex 属性。<ul><li>当正则有g标志时，可以多次执行 exec 方法来查找同一个字符串中的成功匹配，且查找将从正则表达式的 lastIndex 属性指定的位置开始</li></ul></li><li>如果匹配失败，返回 null，并将 lastIndex 重置为 0 </li></ul></li></ol><h1 id="八-JSON"><a href="#八-JSON" class="headerlink" title="八 JSON"></a>八 JSON</h1><h2 id="8-1-语法"><a href="#8-1-语法" class="headerlink" title="8.1 语法"></a>8.1 语法</h2><ol><li>属性名称必须是双引号括起来的字符串；最后一个属性后不能有逗号</li><li>基本类型的值<ol><li>字符串</li><li>数值（必须十进制，NaN不行）</li><li>布尔值</li><li>null（undefined不行）</li></ol></li><li>引用类型的值<ol><li>数组</li><li>对象</li></ol></li></ol><h2 id="8-2-静态方法"><a href="#8-2-静态方法" class="headerlink" title="8.2 静态方法"></a>8.2 静态方法</h2><ol><li><code>JSON.stringify(value[, replacer [, space]])</code><ul><li>将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被<code>parse()</code>方法还原。</li><li><code>value</code><ul><li>要被序列化的对象</li><li>如果对象有自定义的<code>toJSON()</code>方法，那么<code>JSON.stringify()</code>会使用<code>toJSON()</code>方法的返回值作为参数</li></ul></li><li><code>replacer</code><ol><li>如果是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的处理</li><li>如果是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中</li></ol></li><li><code>space</code>：<ul><li>指定缩进用的空白字符串，用于美化输出（pretty-print）增加可读性。<ol><li>如果是数字，表示每个属性前面添加的空格（不超过10个）</li><li>如果是字符串（不超过10个字符），则该字符串会添加在每行前面</li></ol></li></ul></li></ul></li><li><code>JSON.parse(text[, reviver])</code><ul><li>将 JSON 字符串转换成对应的对象</li><li><code>reviver(currentKey, currentValue)</code><ul><li>转换器，此函数调用时机在parse 函数返回之前，用于在返回之前对所得到的对象执行操作  </li><li>转成的对象的所有属性都会调用reviver 函数，并且会将reviver返回值作为新的属性值，如果reviver返回undefined，会删除当前属性</li></ul></li></ul></li></ol><h1 id="九-Error"><a href="#九-Error" class="headerlink" title="九 Error"></a>九 Error</h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><ul><li>当代码运行时的发生错误，会创建新的Error 对象，并将其抛出</li></ul><h2 id="9-2-构造函数"><a href="#9-2-构造函数" class="headerlink" title="9.2 构造函数"></a>9.2 构造函数</h2><ul><li><code>new Error([message])</code></li></ul><h2 id="9-3-原型属性"><a href="#9-3-原型属性" class="headerlink" title="9.3 原型属性"></a>9.3 原型属性</h2><ol><li><code>message</code><ul><li>错误信息</li></ul></li><li><code>name</code><ul><li>error类型的名称.初始值为<code>Error</code></li></ul></li></ol><h2 id="9-4-其它类型的错误构造函数"><a href="#9-4-其它类型的错误构造函数" class="headerlink" title="9.4 其它类型的错误构造函数"></a>9.4 其它类型的错误构造函数</h2><ol><li><code>EvalError</code><ul><li>错误原因：与 eval() 有关</li></ul></li><li><code>RangeError</code><ul><li>错误原因：数值变量或参数超出其有效范围</li></ul></li><li><code>ReferenceError</code><ul><li>错误原因：无效引用</li></ul></li><li><code>SyntaxError</code><ul><li>错误原因：语法错误</li></ul></li><li><code>TypeError</code><ul><li>错误原因：变量或参数不属于有效类型</li></ul></li><li><code>URIError</code><ul><li>错误原因：给 encodeURI()或  decodeURl()传递的参数无效</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-属性描述符&quot;&gt;&lt;a href=&quot;#一-属性描述符&quot; class=&quot;headerlink&quot; title=&quot;一 属性描述符&quot;&gt;&lt;/a&gt;一 属性描述符&lt;/h1&gt;&lt;h2 id=&quot;1-1-概述&quot;&gt;&lt;a href=&quot;#1-1-概述&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="UI" scheme="https://anyeansan.github.io/categories/UI/"/>
    
      <category term="Javascript" scheme="https://anyeansan.github.io/categories/UI/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>Javascript 基本数据类型</title>
    <link href="https://anyeansan.github.io/2020/03/30/Javascript-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://anyeansan.github.io/2020/03/30/Javascript-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-03-30T14:10:22.000Z</published>
    <updated>2020-03-30T14:13:41.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-number"><a href="#一-number" class="headerlink" title="一 number"></a>一 number</h1><h2 id="1-1-数值"><a href="#1-1-数值" class="headerlink" title="1.1 数值"></a>1.1 数值</h2><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td><code>任意数字</code></td><td>整数或者浮点数</td></tr><tr><td><code>+Infinity</code></td><td>正无穷</td></tr><tr><td><code>-Infinity</code></td><td>负无穷</td></tr><tr><td><code>NaN</code></td><td>not a number 一个不是数字的数字类型</td></tr><tr><td>1. JavaScript的number类型为双精度IEEE 754 64位浮点类型。范围（-2<sup>53</sup>- 2<sup>53</sup>）</td><td></td></tr><tr><td>2. JavaScript 内部，整数和浮点数采用的是同样的储存方法。所以<code>1===1.0</code> 为true</td><td></td></tr><tr><td>3. 进制</td><td></td></tr><tr><td>* 十进制</td><td></td></tr><tr><td>* 二进制：以<code>0b</code>开头</td><td></td></tr><tr><td>* 八进制：以<code>0o</code>开头</td><td></td></tr><tr><td>* 十六进制：以<code>0x</code>开头</td><td></td></tr></tbody></table><h2 id="1-2-Number（包装类）"><a href="#1-2-Number（包装类）" class="headerlink" title="1.2 Number（包装类）"></a>1.2 Number（包装类）</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><ol><li><code>Number([value])</code><ul><li>普通函数，作用是类型转换，将value转成一个数值number<ol><li>如果参数为空，返回<code>0</code></li><li>如果参数无法被转换为数字，则返回 <code>NaN</code></li></ol></li></ul></li><li><code>new Number([value])</code><ul><li>构造函数，创建一个Number对象，值为value转换成的数值</li></ul></li></ol><h3 id="2-静态属性"><a href="#2-静态属性" class="headerlink" title="2 静态属性"></a>2 静态属性</h3><ol><li><code>Number.POSITIVE_INFINITY</code><ul><li>正的无限，指向 <code>+Infinity</code></li></ul></li><li><code>Number.NEGATIVE_INFINITY</code><ul><li>负的无限，指向 <code>-Infinity</code></li></ul></li><li><code>Number.NaN</code><ul><li>表示<code>NaN</code></li></ul></li><li><code>Number.MIN_VALUE</code><ul><li>表示在 JavaScript 中所能表示的最小的正值</li></ul></li><li><code>Number.MAX_VALUE</code><ul><li>表示在 JavaScript 里所能表示的最大数值</li></ul></li><li><code>Number.MIN_SAFE_INTEGER</code><ul><li>表示在 JavaScript 中能够准确表示的整数范围下限（-(2<sup>53</sup> - 1)）</li></ul></li><li><code>Number.MAX_SAFE_INTEGER</code><ul><li>表示在 JavaScript 中能够准确表示的整数范围上限（2<sup>53</sup> - 1）</li></ul></li><li><code>Number.EPSILON</code><ul><li>表示 1 与大于 1 的最小的浮点数之间的差值</li><li>实际上是 JavaScript 能够表示的最小精度</li></ul></li></ol><h3 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="3 静态方法"></a>3 静态方法</h3><ol><li><code>Number.isNaN(value)</code><ul><li>判断给定的值是否是 NaN。</li><li>和全局函数<code>isNaN()</code> 的区别<ul><li>全局函数 <code>isNaN()</code> 会先将非数值转换为数值，再进行判断</li><li><code>Number.isNaN()</code> 只对数值有效，非数值直接返回false</li></ul></li></ul></li><li><code>Number.isFinite(value)</code><ul><li>判断给定的值是否是有穷数</li><li>和全局函数<code>isFinite()</code> 函数的区别<ul><li>全局函数 <code>isFinite()</code> 会先将非数值转换为数值，再进行判断</li><li><code>Number.isFinite()</code> 只对数值有效，非数值直接返回false</li></ul></li></ul></li><li><code>Number.isInteger(value)</code><ul><li>判断给定值是否是整数</li></ul></li><li><code>Number.parseInt(string[, radix])</code><ul><li>将一个字符串转换成指定进制的整数</li><li><code>radix</code><ul><li>指定进制（2-36），默认10</li></ul></li><li>同 全局函数 <code>parseInt()</code>，移植到Number上，目的是逐步减少全局性方法，使得语言逐步模块化</li></ul></li><li><code>Number.parseFloat(string)</code><ul><li>把一个字符串解析成浮点数</li><li>同 全局函数<code>parseFloat()</code>，移植到Number上，目的是逐步减少全局性方法，使得语言逐步模块化</li></ul></li></ol><h3 id="4-原型方法"><a href="#4-原型方法" class="headerlink" title="4 原型方法"></a>4 原型方法</h3><ol><li><code>valueOf()</code><ul><li>返回基本类型的值</li></ul></li><li><code>toString([radix])</code><ul><li>返回字符串形式</li></ul></li><li><code>toFixed([digits])</code><ul><li>返回保留指定位数浮点数的字符串</li><li><code>digits</code><ul><li>小数点后数字的个数，默认为0</li></ul></li></ul></li></ol><h2 id="1-3-Math"><a href="#1-3-Math" class="headerlink" title="1.3 Math"></a>1.3 Math</h2><h3 id="1-静态属性"><a href="#1-静态属性" class="headerlink" title="1 静态属性"></a>1 静态属性</h3><ol><li><code>Math.E</code><ul><li>欧拉常数 <code>e</code></li></ul></li><li><code>Math.PI</code><ul><li>常数 <code>π</code></li></ul></li></ol><h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2 静态方法"></a>2 静态方法</h3><ol><li><code>Math.abs(x)</code><ul><li>绝对值</li></ul></li><li><code>Math.ceil(x)</code><ul><li>向上取整</li></ul></li><li><code>Math.floor(x)</code><ul><li>向下取整</li></ul></li><li><code>Math.pow(x, y)</code><ul><li>返回 x 的 y 次幂</li></ul></li><li><code>Math.random()</code><ul><li>返回0-1之间的伪随机数(含0不含1)</li></ul></li><li><code>Math.round(x)</code><ul><li>四舍五入</li></ul></li><li><code>Math.sqrt(x)</code><ul><li>平方</li></ul></li><li><code>Math.log(x)</code><ul><li>对数</li></ul></li><li><code>Math.exp(x)</code><ul><li><code>e</code> 的指数（e的x次方）</li></ul></li><li><code>Math.min([value1[,value2, ...]])</code><ul><li>返回给定的一组数字中的最小值。如果任一参数不能转换为数值，则返回NaN。</li></ul></li><li><code>Math.max(value1[,value2, ...])</code><ul><li>返回给定的一组数字中的最大值。如果任一参数不能转换为数值，则返回NaN。</li></ul></li><li><code>Math.sin(x)</code><ul><li>正弦</li></ul></li><li><code>Math.cos(x)</code><ul><li>余弦</li></ul></li><li><code>Math.tan(x)</code><ul><li>正切    </li></ul></li></ol><h1 id="二-boolean"><a href="#二-boolean" class="headerlink" title="二 boolean"></a>二 boolean</h1><h2 id="2-1-布尔值"><a href="#2-1-布尔值" class="headerlink" title="2.1 布尔值"></a>2.1 布尔值</h2><ul><li><code>true</code></li><li><code>false</code></li></ul><h2 id="2-2-类型转换"><a href="#2-2-类型转换" class="headerlink" title="2.2 类型转换"></a>2.2 类型转换</h2><h3 id="1-类型转换规则"><a href="#1-类型转换规则" class="headerlink" title="1 类型转换规则"></a>1 类型转换规则</h3><table><thead><tr><th>值</th><th>转换结果</th></tr></thead><tbody><tr><td><code>0</code></td><td>false</td></tr><tr><td><code>NaN</code></td><td>false</td></tr><tr><td><code>&quot;&quot;</code></td><td>false</td></tr><tr><td><code>false</code></td><td>false</td></tr><tr><td><code>null</code></td><td>false</td></tr><tr><td><code>undefined</code></td><td>false</td></tr><tr><td>其它</td><td>true</td></tr></tbody></table><ol><li>隐式转换<ul><li>基本上所有类型都可以隐式转换为 boolean类型。</li><li>注意：值和布尔值是不同的概念</li></ul></li><li>显式转换<ol><li><code>Boolean()</code></li><li><code>!!</code></li><li><code>new Boolean()</code><ul><li>不太好，因为返回一个对象，而将对象转换成布尔值必为true</li></ul></li></ol></li></ol><h2 id="2-3-Boolean（包装类）"><a href="#2-3-Boolean（包装类）" class="headerlink" title="2.3 Boolean（包装类）"></a>2.3 Boolean（包装类）</h2><h3 id="1-构造函数-1"><a href="#1-构造函数-1" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><ol><li><code>Boolean([value])</code><ul><li>普通函数，作用是类型转换，将value转成一个布尔值boolean</li></ul></li><li><code>new Boolean([value])</code><ul><li>构造函数，创建一个Boolean对象<ol><li>如果省略参数，则Boolean对象值为false</li><li>如果value不是布尔值，则先转成布尔值</li></ol></li></ul></li></ol><h3 id="2-原型方法"><a href="#2-原型方法" class="headerlink" title="2 原型方法"></a>2 原型方法</h3><ol><li><code>valueOf()</code><ul><li>返回基本类型的值<code>true/false</code></li></ul></li><li><code>toString()</code><ul><li>返回字符串形式 <code>&#39;true&#39;/&#39;false&#39;</code></li></ul></li></ol><h1 id="三-string"><a href="#三-string" class="headerlink" title="三 string"></a>三 string</h1><h2 id="3-1-字符串字面量"><a href="#3-1-字符串字面量" class="headerlink" title="3.1 字符串字面量"></a>3.1 字符串字面量</h2><ol><li>单/双引号（特殊字符使用<code>\</code>转义）</li><li>反引号（模板字面量，特殊字符直接使用，反引号需要使用<code>\</code>转义）</li></ol><h2 id="3-2-字符的-Unicode表示法"><a href="#3-2-字符的-Unicode表示法" class="headerlink" title="3.2 字符的 Unicode表示法"></a>3.2 字符的 Unicode表示法</h2><ol><li><code>\uxxxx</code><ul><li>只限于Unicode编码在<code>\u0000~\uFFFF</code>（0-65535）之间的字符</li></ul></li><li><code>\u{}</code><ul><li>使用<code>{}</code>，大于<code>\uFFFF</code>的字符也能正确表示</li></ul></li></ol><h2 id="3-3-字符串换行"><a href="#3-3-字符串换行" class="headerlink" title="3.3 字符串换行"></a>3.3 字符串换行</h2><ol><li>末尾加<code>\</code></li><li>加号连接</li><li>反引号</li></ol><h2 id="3-4-模板字面量"><a href="#3-4-模板字面量" class="headerlink" title="3.4 模板字面量"></a>3.4 模板字面量</h2><ol><li>模板字面量是增强版的字符串，它用反引号标识</li><li>空格换行等都会原样输出</li><li><code>${表达式}</code> <ul><li>占位符就如同一个普通字符串一样，可以插入到字符串中的任意位置</li><li>作用是取表达式的值</li></ul></li><li>反引号可以嵌套</li></ol><h2 id="3-5-模板字面量标签"><a href="#3-5-模板字面量标签" class="headerlink" title="3.5 模板字面量标签"></a>3.5 模板字面量标签</h2><ol><li>模板字面量标签通常是一个函数</li><li>调用标签函数，将它放在模板字面量前即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert`hello`;</span><br><span class="line">function myTag (strings, ...values)&#123;&#125;</span><br><span class="line">myTag`hello`</span><br></pre></td></tr></table></figure></li><li>调用标签函数时，会将模板字面量处理成参数，传递给函数<ol><li>第一个参数是数组，存储模板字面量中占位符<code>${}</code>两侧的字符串</li><li>第二个参数是可变参数，存储占位符<code>${}</code>的返回值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let name = &apos;xiaoming&apos;, age = 18;</span><br><span class="line">alert`hello$&#123;name&#125;,ni$&#123;18&#125;了吗`; </span><br><span class="line">// 相当于</span><br><span class="line">alert ([&apos;hello&apos;, &apos;,ni&apos;, &apos;了吗&apos;], &apos;xiaoming&apos;, 18);</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="3-6-String（包装类）"><a href="#3-6-String（包装类）" class="headerlink" title="3.6 String（包装类）"></a>3.6 String（包装类）</h2><h3 id="1-构造函数-2"><a href="#1-构造函数-2" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><ol><li><code>String([value])</code><ul><li>普通函数，作用是类型转换，将value转成一个字符串string<ol><li>如果参数为空，则返回空字符串<code>&#39;&#39;</code></li><li>如果参数是基本类型，则返回基本类型的字符串形式</li><li>如果参数是引用类型，相当于调用其<code>toString()</code></li></ol></li></ul></li><li><code>new String([value])</code><ul><li>构造函数，创建一个String对象，值为value转成的字符串</li></ul></li></ol><h3 id="2-实例属性"><a href="#2-实例属性" class="headerlink" title="2 实例属性"></a>2 实例属性</h3><ul><li><code>length</code></li></ul><h3 id="3-静态方法-1"><a href="#3-静态方法-1" class="headerlink" title="3 静态方法"></a>3 静态方法</h3><ol><li><code>String.fromCharCode(num1, ..., numN)</code><ul><li>返回使用指定的 Unicode 编码创建的字符串（不能识别大于<code>0xFFFF</code>的字符）</li><li><code>num1, ..., numN</code><ul><li>一串 Unicode 编码</li></ul></li></ul></li><li><code>String.fromCodePoint(num1[, ...[, numN]])</code><ul><li>返回使用指定的 Unicode 编码创建的字符串（可以识别大于<code>0xFFFF</code>的字符）</li></ul></li><li><code>String.raw&#96;templateString&#96;</code><ul><li>返回模板字符串的原始字符串</li><li>是唯一一个内置的模板字符串标签函数</li></ul></li></ol><h3 id="4-原型方法-1"><a href="#4-原型方法-1" class="headerlink" title="4 原型方法"></a>4 原型方法</h3><h4 id="1-获取"><a href="#1-获取" class="headerlink" title="1 获取"></a>1 获取</h4><ol><li><code>valueOf()</code><ul><li>返回字符串对象的原始字符串</li></ul></li><li><code>repeat(count)</code><ul><li>当前字符串重复count次组成新字符串并返回</li></ul></li><li><code>concat(str1, str2[, ..., strN])</code><ul><li>将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回，不改变原字符串</li></ul></li><li><code>slice(beginIndex[, endIndex])</code><ul><li>提取从开始索引到结束索引之间（含头不含尾）的字符串并返回，不改变原字符串</li><li>索引可以为负，则索引为负时表示从后开始（-1, -2 …）</li><li>索引超过字符串长度时，会被当作末尾</li></ul></li><li><code>substring(beginIndex[, endIndex])</code><ul><li>提取从开始索引到结束索引之间（含头不含尾）的字符串并返回，不改变原字符串</li><li>索引为负时或为 NaN，则被当作 0</li><li>索引超过字符串长度时，会被当作末尾</li></ul></li><li><code>substr(beginIndex, length)</code>（    已过时）<ul><li>提取从起始索引号指定数目的字符串并返回，不改变原字符串</li></ul></li></ol><h4 id="2-改"><a href="#2-改" class="headerlink" title="2 改"></a>2 改</h4><ol><li><code>toLowerCase() / toUpperCase()</code><ul><li>将一个字符串转小/大写，返回一个新字符串，不改变原字符串</li></ul></li><li><code>trim()</code><ul><li>去除字符串两端的空格，返回一个新字符串，不改变原字符串</li></ul></li><li><code>trimStart() / trimEnd()</code><ul><li><code>trimLeft()</code>是 <code>trimStart()</code> 的别名，<code>trimRight()</code> 是<code>trimEnd()</code>的别名</li></ul></li><li><code>padStart(targetLength [, padString])</code><ul><li>以指定字符串<code>padString</code>在原字符串开头补充，以达到目标长度<code>targetLength</code></li><li><code>targetLength</code><ul><li>当前字符串需要填充到的目标长度，如果小于等于当前字符串长度，则返回当前字符串</li></ul></li><li><code>padString</code><ul><li>填充字符串，如果省略则使用空格</li></ul></li></ul></li><li><code>padEnd(targetLength [, padString])</code></li></ol><h4 id="3-查"><a href="#3-查" class="headerlink" title="3 查"></a>3 查</h4><ol><li><code>charAt(index)</code><ul><li>返回指定位置的字符</li></ul></li><li><code>charCodeAt(index)</code><ul><li>返回指定位置的字符Unicode 值（十进制）</li><li>只能获取2个字节表示的字符，对于4个字节表示的字符会认为是两个字符</li></ul></li><li><code>codePointAt(index)</code><ul><li>返回指定位置的字符Unicode 值（十进制）</li><li>可以正确获取4个字节表示的字符</li><li>javaScript内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。（<code>0-65535</code> 或 <code>0x0000-0xFFFF</code>）</li></ul></li><li><code>indexOf(searchValue[, fromIndex])</code><ul><li>返回一个字符串在另一个字符串中第一次出现的索引，未找到返回-1</li><li>默认从0索引开始往后找</li></ul></li><li><code>lastIndexOf(searchValue[, fromIndex])</code><ul><li>返回一个字符串在另一个字符串中从后往前第一次出现的索引，未找到返回-1</li></ul></li></ol><h4 id="4-判断"><a href="#4-判断" class="headerlink" title="4 判断"></a>4 判断</h4><ol><li><code>includes(searchString[, fromIndex])</code><ul><li>判断是否包含指定字符串</li></ul></li><li><code>startsWith(searchString[, fromIndex])</code><ul><li>判断是否以指定字符串开头</li></ul></li><li><code>endsWith(searchString[, length])</code><ul><li>判断是否以指定字符串结尾</li><li><code>length</code><ul><li>表示只判断当前字符串指定长度的子串，如3，则表示只判断前三个字符是否以指定字符串结尾</li><li>默认为当前字符串的length大小</li></ul></li></ul></li></ol><h4 id="5-正则"><a href="#5-正则" class="headerlink" title="5 正则"></a>5 正则</h4><ol><li><code>split([separator[, limit]])</code><ul><li>按照给定规则分割字符串，返回一个由分割出来的子字符串以指定分隔符组成的数组</li><li><code>separator</code><ul><li>可以是一个字符串或正则表达式</li></ul></li><li><code>limit</code><ul><li>限定返回的分割片段数量</li></ul></li></ul></li><li><code>search(regexp)</code><ul><li>返回正则表达式在字符串中首次匹配项的索引;否则，返回 -1</li><li><code>regexp</code><ul><li>正则对象，如果传入一个非正则对象，则会先转成正则对象</li></ul></li></ul></li><li><code>match(regexp)</code><ul><li>如果正则没有g标志，则返回包含第一个匹配结果的数组，且有附加属性（index, input, groups,…）</li><li>如果正则有g标志，则返回包含所有匹配结果的数组，没有附加属性</li><li>如果没有匹配，返回null</li></ul></li><li><code>matchAll(regexp)</code><ul><li>返回一个包含所有匹配正则表达式的结果（包含附加属性）的迭代器</li><li>没有<code>matchAll</code>之前，使用while循环加exec方式（且正则表达式需使用g标志），来获取所有匹配项</li></ul></li><li><code>replace(regexp|substr, newSubStr|function)</code><ul><li><code>regexp|substr</code><ul><li>正则匹配的内容或者指定的内容</li></ul></li><li><code>newSubStr</code><ul><li>使用新的字符串替换，替换时可以插入特殊变量</li></ul></li><li><code>function</code><ul><li>使用函数返回的字符串替换</li></ul></li></ul></li></ol><table><thead><tr><th align="center">特殊变量</th><th>说明</th></tr></thead><tbody><tr><td align="center"><code>$$</code></td><td>插入一个 “$”</td></tr><tr><td align="center"><code>$&amp;</code></td><td>插入匹配的子串</td></tr><tr><td align="center">$`</td><td>插入当前匹配的子串左边的内容</td></tr><tr><td align="center"><code>$&#39;</code></td><td>插入当前匹配的子串右边的内容</td></tr><tr><td align="center"><code>$n</code></td><td>如果第一个参数是RegExp对象，表示插入第n组的内容</td></tr></tbody></table><table><thead><tr><th align="center">函数参数</th><th>说明</th></tr></thead><tbody><tr><td align="center"><code>match</code></td><td>匹配的子串。（对应<code>$&amp;</code>。）</td></tr><tr><td align="center"><code>p1,p2,...</code></td><td>如果第一个参数是RegExp对象，表示第n组的内容（对应<code>$n</code>）</td></tr><tr><td align="center"><code>offset</code></td><td>匹配到的子字符串在原字符串中起始索引</td></tr><tr><td align="center"><code>string</code></td><td>被匹配的原字符串</td></tr><tr><td align="center"><code>NamedCaptureGroup</code></td><td>命名捕获组匹配的对象</td></tr></tbody></table><h1 id="四-null-amp-undefined"><a href="#四-null-amp-undefined" class="headerlink" title="四 null &amp; undefined"></a>四 null &amp; undefined</h1><ol><li>一个没有赋值的变量默认值为undefined<ul><li>基本类型：初始化推荐undefined（惯例，其实默认就是undefined，null也可以）</li><li>引用类型：初始化推荐null（惯例，undefined也可以）</li></ul></li><li>值为undefined的情况<ol><li>变量或者对象属性没有赋值，则默认值undefined</li><li>调用函数时，没有传值的参数则默认为undefined</li><li>函数没有返回值时，默认返回 undefined </li></ol></li></ol><h1 id="五-symbol"><a href="#五-symbol" class="headerlink" title="五 symbol"></a>五 symbol</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol><li>symbol 的值是唯一的，独一无二的不会重复的</li><li>symbol 值作为对象属性名时，不能用点运算符，只能使用<code>[]</code><ol><li>不会被<code>for...in for... of</code>遍历到</li><li>不会被<code>Object.keys() Object.getOwnPropertyNames() JSON.stringify()</code>返回</li><li>使用<code>Object.getOwnPropertySymbols()</code>可以获取</li></ol></li><li>symbol 值不能与其他类型的值进行运算，可以转为字符串和布尔值</li></ol><h2 id="5-2-Symbol（包装类）"><a href="#5-2-Symbol（包装类）" class="headerlink" title="5.2 Symbol（包装类）"></a>5.2 Symbol（包装类）</h2><h3 id="1-构造函数-3"><a href="#1-构造函数-3" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><ol><li><code>Symbol([description])</code><ol><li>返回一个symbole类型的值，且是唯一的</li><li>不会放入全局symbol注册表</li><li><code>description</code><ul><li>字符串类型。仅仅是对symbol的描述，为了控制台显示时或者转为字符串时比较容易区分，不会影响symbol的值（即使用相同描述创建的symbol也不同）</li><li>如果传入的不是字符串，会先转成字符串</li></ul></li></ol></li><li><code>new Symbol()</code><ul><li>不支持此语法</li></ul></li></ol><h3 id="2-静态属性-1"><a href="#2-静态属性-1" class="headerlink" title="2 静态属性"></a>2 静态属性</h3><ul><li>ES6 提供了 11 个内置的 Symbol 值，指向语言内部使用的方法</li></ul><ol><li><code>Symbol.hasInstance</code><ul><li><code>A instanceof B</code> 实际调用的是 <code>B[Symbol.hasInstance](A)</code></li></ul></li><li><code>Symbol.iterator</code><ul><li><code>for(let a of A)</code> 会调用 <code>A[Symbol.iterator]()</code> 返回对象的迭代器</li></ul></li></ol><h3 id="3-实例属性"><a href="#3-实例属性" class="headerlink" title="3 实例属性"></a>3 实例属性</h3><ol><li><code>description</code><ul><li>只读属性，返回 Symbol 对象的可选的描述字符串</li></ul></li></ol><h3 id="4-静态方法"><a href="#4-静态方法" class="headerlink" title="4 静态方法"></a>4 静态方法</h3><ol><li><code>Symbol.for(key)</code><ul><li>根据键 key 从全局symbol注册表中查询，如果找到则返回，否则创建一个与key关联的symbol，放入全局 symbol 注册表中，并返回</li><li><code>key</code><ul><li>一个字符串，作为 symbol 注册表中与某 symbol 关联的键（同时也会作为该 symbol 的描述）</li></ul></li></ul></li><li><code>Symbol.keyFor(sym)</code><ul><li>获取全局symbol 注册表中与某个 symbol 关联的键，若存在则返回字符串key，否则返回undefined</li></ul></li></ol><h1 id="六-bigInt"><a href="#六-bigInt" class="headerlink" title="六 bigInt"></a>六 bigInt</h1><ul><li>用任意精度表示整数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-number&quot;&gt;&lt;a href=&quot;#一-number&quot; class=&quot;headerlink&quot; title=&quot;一 number&quot;&gt;&lt;/a&gt;一 number&lt;/h1&gt;&lt;h2 id=&quot;1-1-数值&quot;&gt;&lt;a href=&quot;#1-1-数值&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="UI" scheme="https://anyeansan.github.io/categories/UI/"/>
    
      <category term="Javascript" scheme="https://anyeansan.github.io/categories/UI/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>Javascript 数据类型概述</title>
    <link href="https://anyeansan.github.io/2020/03/30/Javascript-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0/"/>
    <id>https://anyeansan.github.io/2020/03/30/Javascript-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0/</id>
    <published>2020-03-30T14:07:41.000Z</published>
    <updated>2020-03-30T14:10:07.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-数据类型判断"><a href="#一-数据类型判断" class="headerlink" title="一 数据类型判断"></a>一 数据类型判断</h1><h2 id="1-1-typeof"><a href="#1-1-typeof" class="headerlink" title="1.1 typeof"></a>1.1 typeof</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof operand  // operand：表示对象或基本值的表达式</span><br><span class="line">typeof(operand)</span><br></pre></td></tr></table></figure><ul><li>判断数据类型并返回字符串形式</li></ul><h3 id="2-返回值"><a href="#2-返回值" class="headerlink" title="2 返回值"></a>2 返回值</h3><table><thead><tr><th>type</th><th>typeof Result</th></tr></thead><tbody><tr><td>number</td><td>“number”</td></tr><tr><td>bigint</td><td>“bigint”</td></tr><tr><td>string</td><td>“string”</td></tr><tr><td>boolean</td><td>“boolean”</td></tr><tr><td>undefined</td><td>“undefined”</td></tr><tr><td>null</td><td>“object”</td></tr><tr><td>symbol</td><td>“symbol”</td></tr><tr><td>function object (implements [[Call]])</td><td>“function”</td></tr><tr><td>any other object</td><td>“object”</td></tr><tr><td>* <code>typeof null</code>返回<code>object</code>是历史原因</td><td></td></tr></tbody></table><h2 id="1-2-instanseof"><a href="#1-2-instanseof" class="headerlink" title="1.2 instanseof"></a>1.2 instanseof</h2><ul><li><code>object instanceof constructor</code><ul><li>用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</li></ul></li></ul><h1 id="二-数据类型分类"><a href="#二-数据类型分类" class="headerlink" title="二 数据类型分类"></a>二 数据类型分类</h1><h2 id="2-1-基本数据类型"><a href="#2-1-基本数据类型" class="headerlink" title="2.1 基本数据类型"></a>2.1 基本数据类型</h2><ol><li>number</li><li>boolean</li><li>string</li><li>null</li><li>undefined</li><li>symbol</li><li>bigInt</li></ol><h2 id="2-2-引用数据类型"><a href="#2-2-引用数据类型" class="headerlink" title="2.2 引用数据类型"></a>2.2 引用数据类型</h2><ul><li>object<ol><li>内置对象<ol><li>对象 （Object）</li><li>数组 （Array）</li><li>集合 （Map Set WeakMap WeakSet）</li><li>函数（Function）</li><li>基本类型包装对象（Number Boolean String Symbol BigInt）</li><li>数学（Math）</li><li>日期（Date）</li><li>Json（JSON）</li><li>正则（RegExp）</li><li>错误（Error）</li><li>……</li></ol></li><li>自定义对象</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-数据类型判断&quot;&gt;&lt;a href=&quot;#一-数据类型判断&quot; class=&quot;headerlink&quot; title=&quot;一 数据类型判断&quot;&gt;&lt;/a&gt;一 数据类型判断&lt;/h1&gt;&lt;h2 id=&quot;1-1-typeof&quot;&gt;&lt;a href=&quot;#1-1-typeof&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="UI" scheme="https://anyeansan.github.io/categories/UI/"/>
    
      <category term="Javascript" scheme="https://anyeansan.github.io/categories/UI/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>Javascript 语法</title>
    <link href="https://anyeansan.github.io/2020/03/30/Javascript-%E8%AF%AD%E6%B3%95/"/>
    <id>https://anyeansan.github.io/2020/03/30/Javascript-%E8%AF%AD%E6%B3%95/</id>
    <published>2020-03-30T14:02:03.000Z</published>
    <updated>2020-03-30T14:23:03.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-严格模式"><a href="#一-严格模式" class="headerlink" title="一 严格模式"></a>一 严格模式</h1><h2 id="1-1-启用"><a href="#1-1-启用" class="headerlink" title="1.1 启用"></a>1.1 启用</h2><ul><li><code>&quot;use strict;&quot;</code><ol><li>放在脚本文件的第一行，整个脚本都将以严格模式运行。</li><li>放在函数体的第一行，则整个函数以严格模式运行。</li></ol></li></ul><h2 id="1-2-严格模式中的变化"><a href="#1-2-严格模式中的变化" class="headerlink" title="1.2 严格模式中的变化"></a>1.2 严格模式中的变化</h2><h3 id="1-显式报错"><a href="#1-显式报错" class="headerlink" title="1 显式报错"></a>1 显式报错</h3><ol><li>严格模式会使引起静默失败(silently fail，不报错也没有任何效果)的赋值操作抛出异常<ul><li>只读属性的写操作，不可扩展对象扩展操作，</li></ul></li><li>严格模式下，试图删除不可删除的属性时会抛出异常</li><li>严格模式下禁止对象属性重名</li><li>严格模式下禁止函数参数重名</li><li>严格模式禁止八进制数字语法</li></ol><h3 id="2-安全措施"><a href="#2-安全措施" class="headerlink" title="2 安全措施"></a>2 安全措施</h3><ol><li>严格模式下，变量必须先声明，然后再使用</li><li>禁止 this 关键字指向全局对象window</li><li>严格模式禁止删除声明变量</li></ol><h3 id="3-静态绑定"><a href="#3-静态绑定" class="headerlink" title="3 静态绑定"></a>3 静态绑定</h3><ul><li>js允许动态绑定，即属性或方法属于哪个对象不是编译时确定的，而是在运行时确定</li><li>严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定，即编译时就确定属性或方法属于哪个对象。</li></ul><ol><li>严格模式禁用 <code>with</code>语句</li><li>创设 eval 作用域<ul><li>正常模式下，eval语句的作用域，取决于它处于全局作用域，还是函数作用域。</li><li>严格模式下，eval语句本身就是一个作用域，即eval所生成的变量只能用于eval内部</li></ul></li><li>arguments 不再追踪参数的变化<ul><li>变量arguments代表函数的参数。</li><li>严格模式下，函数内部改变参数与arguments的联系被切断了，两者不再存在联动关系</li></ul></li></ol><h1 id="二-顶层对象"><a href="#二-顶层对象" class="headerlink" title="二 顶层对象"></a>二 顶层对象</h1><ol><li>JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。</li><li>顶层对象在各种实现里面是不统一的</li><li>ES2020标准中，引入<code>globalThis</code>作为顶层对象。也就是说，任何环境下，<code>globalThis</code>都是存在的</li></ol><table><thead><tr><th>环境</th><th>顶层对象</th><th>ES2020</th></tr></thead><tbody><tr><td>浏览器</td><td>window，self</td><td>globalThis</td></tr><tr><td>Web Worker</td><td>self</td><td>globalThis</td></tr><tr><td>Node</td><td>global</td><td>globalThis</td></tr></tbody></table><h1 id="三-注释"><a href="#三-注释" class="headerlink" title="三 注释"></a>三 注释</h1><ol><li><code>//</code></li><li><code>/* */</code><ul><li>不能嵌套</li></ul></li></ol><h1 id="四-作用域"><a href="#四-作用域" class="headerlink" title="四 作用域"></a>四 作用域</h1><ol><li>全局作用域</li><li>块作用域</li><li>函数作用域</li></ol><h1 id="五-声明关键字"><a href="#五-声明关键字" class="headerlink" title="五 声明关键字"></a>五 声明关键字</h1><p>关键字|初始化|变量提升|块作用域|window|同一作用域重复声明<br>:-:|-|-|-|-<br><code>var</code>|可选|有|无|全局变量会成为window对象属性|可以，后者覆盖前者<br><code>let</code>|可选|无|有|全局变量不属于window属性|不能<br><code>const</code>|必须|无|有|全局变量不属于window属性|不能</p><ol><li>变量提升<ul><li>变量的声明语句，被提升到代码的头部</li></ul></li><li>暂时性死区（temporal dead zone，简称 TDZ<ul><li>let和const没有变量提升，所以必须先声明后使用</li><li>从作用域开始到声明语句的区域，如果使用声明的变量就会会导致 ReferenceError，这块区域称为暂时性死区。</li></ul></li><li>const 常量指向的内存地址不能改变<ol><li>基本类型值不能改变</li><li>引用类型地址值不能修改</li></ol></li></ol><h1 id="六-变量"><a href="#六-变量" class="headerlink" title="六 变量"></a>六 变量</h1><ol><li>变量的声明和赋值，是分开的两个步骤<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = 1;  // 其实是下边两步</span><br><span class="line">let a;</span><br><span class="line">a = 1;</span><br></pre></td></tr></table></figure></li><li>同一条声明语句中可以声明多个变量</li><li>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</li><li>变量标识符命名规则<ol><li>不能用数字开头</li><li>可以用中文</li><li>不能使用js保留字</li></ol></li></ol><h1 id="七-运算符"><a href="#七-运算符" class="headerlink" title="七 运算符"></a>七 运算符</h1><h2 id="7-1-赋值运算符"><a href="#7-1-赋值运算符" class="headerlink" title="7.1 赋值运算符"></a>7.1 赋值运算符</h2><table><thead><tr><th>运算符</th><th>名称</th><th>运算式</th><th>等价于</th></tr></thead><tbody><tr><td><code>=</code></td><td>赋值</td><td><code>x = y</code></td><td><code>x = y</code></td></tr><tr><td><code>+=</code></td><td>加赋值</td><td><code>x += y</code></td><td><code>x = x + y</code></td></tr><tr><td><code>-=</code></td><td>减赋值</td><td><code>x -= y</code></td><td><code>x = x - y</code></td></tr><tr><td><code>*=</code></td><td>乘赋值</td><td><code>x *= y</code></td><td><code>x = x * y</code></td></tr><tr><td><code>/=</code></td><td>除赋值</td><td><code>x /= y</code></td><td><code>x = x / y</code></td></tr><tr><td><code>%=</code></td><td>模赋值</td><td><code>x %= y</code></td><td><code>x = x % y</code></td></tr><tr><td><code>**=</code></td><td>指数赋值</td><td><code>x **= y</code></td><td><code>x = x ** y</code></td></tr><tr><td><code>&lt;&lt;=</code></td><td>左移赋值</td><td><code>x &lt;&lt;= y</code></td><td><code>x = x &lt;&lt; y</code></td></tr><tr><td><code>&gt;&gt;=</code></td><td>右移赋值</td><td><code>x &gt;&gt;= y</code></td><td><code>x = x &gt;&gt; y</code></td></tr><tr><td><code>&gt;&gt;&gt;=</code></td><td>无符号右移赋值</td><td><code>x &gt;&gt;&gt;= y</code></td><td><code>x = x &gt;&gt;&gt; y</code></td></tr><tr><td><code>&amp;=</code></td><td>按位与赋值</td><td><code>x &amp;= y</code></td><td><code>x = x &amp; y</code></td></tr><tr><td><code>&#124;=</code></td><td>按位或赋值</td><td><code>x &#124;= y</code></td><td><code>x = x &#124; y</code></td></tr><tr><td><code>^=</code></td><td>按位异或赋值</td><td><code>x ^= y</code></td><td><code>x = x ^ y</code></td></tr></tbody></table><h2 id="7-2-算术运算符"><a href="#7-2-算术运算符" class="headerlink" title="7.2 算术运算符"></a>7.2 算术运算符</h2><table><thead><tr><th>运算符</th><th>名称</th><th>运算式</th></tr></thead><tbody><tr><td><code>+</code></td><td>加法</td><td><code>x + y</code></td></tr><tr><td><code>-</code></td><td>减法</td><td><code>x - y</code></td></tr><tr><td><code>*</code></td><td>乘法</td><td><code>x * y</code></td></tr><tr><td><code>/</code></td><td>除法</td><td><code>x / y</code></td></tr><tr><td><code>%</code></td><td>求余</td><td><code>x % y</code></td></tr><tr><td><code>**</code></td><td>幂</td><td><code>x ** y</code></td></tr><tr><td><code>++</code></td><td>自增</td><td><code>x++</code> 或 <code>++x</code></td></tr><tr><td><code>--</code></td><td>自减</td><td><code>x--</code> 或 <code>--x</code></td></tr><tr><td><code>+</code></td><td>一元正号</td><td><code>+x</code></td></tr><tr><td><code>-</code></td><td>一元负号</td><td><code>-x</code></td></tr></tbody></table><h3 id="1-加法"><a href="#1-加法" class="headerlink" title="1 加法"></a>1 加法</h3><ol><li>允许非数值的相加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true + true = 2</span><br><span class="line">1 + true = 2</span><br></pre></td></tr></table></figure></li><li>遇到字符串会变成连接</li><li>对象相加，必须先转成原始类型的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: 1 &#125;;</span><br><span class="line">obj + 2 // &quot;[object Object]2&quot;</span><br><span class="line">// obj.valueOf() 结果为&#123;p:1&#125;</span><br><span class="line">// obj.valueOf().toString() 结果为&quot;[object object]&quot;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 2 一元加号/减号</span><br><span class="line">* 一元加号/减号运算符的作用在于可以将任何值转为数值</span><br></pre></td></tr></table></figure></li></ol><p>+true // 1<br>+[] // 0<br>+{} // NaN</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3 幂运算符</span><br><span class="line">1. 前一个运算子是底数，后一个运算子是指数</span><br><span class="line">2. 幂运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算。</span><br></pre></td></tr></table></figure><p>2 ** 4 // 16 即2的4次方<br>2 ** 3 ** 2// 512 相当于2** (3 ** 2) 即先求3的2次方=9 再求2的9次方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 7.3 比较运算符</span><br><span class="line">### 1 非相等比较</span><br><span class="line">运算符|名称|运算式</span><br><span class="line">-|-|-</span><br><span class="line">`&gt;`|大于|`x &gt; y`</span><br><span class="line">`&lt;`|小于|`x &lt; y`</span><br><span class="line">`&gt;=`|大于等于|`x &gt;= y`</span><br><span class="line">`&lt;=`|小于等于|`x &lt;= y`</span><br><span class="line">1. 基本类型</span><br><span class="line">1. 非字符串：先转成数值再比较</span><br><span class="line">2. 字符串：按照字典顺序比较（实际上是比较 Unicode 码点）</span><br><span class="line">2. 引用类型</span><br><span class="line">* 先转为基本类型的值，再进行比较</span><br><span class="line"></span><br><span class="line">### 2 相等比较</span><br><span class="line">运算符|名称|运算式</span><br><span class="line">-|-|-</span><br><span class="line">`==`|相等|` x == y`</span><br><span class="line">`===`|严格相等|`x === y`</span><br><span class="line">`!=`|不相等|`x != y`</span><br><span class="line">`!==`|严格不相等|`x !== y`</span><br><span class="line">1. `===`</span><br><span class="line">1. 先比较类型，类型相同再比较值</span><br><span class="line">2. 引用类型比较地址值</span><br><span class="line">3. `NaN`与任何值都不严格相等（包括自己）</span><br><span class="line">4. `undefined`和`null`与自身严格相等</span><br><span class="line">5. `+0` 与 `-0` 严格相等 </span><br><span class="line">6. `!==`</span><br><span class="line">* 先求`===`的结果，然后返回相反值。</span><br><span class="line">2. `==`</span><br><span class="line">1. 比较不同类型的数据时，会先将数据进行类型转换，然后再用`===`比较。</span><br><span class="line">2.  `NaN`与任何值都不相等（包括自己）</span><br><span class="line">3. `undefined`和`null`与其他类型的值比较时，结果都为false， 它们之间比较为true</span><br><span class="line">4. `!=`</span><br><span class="line">* 先求`==`的结果，然后返回相反值。</span><br><span class="line"></span><br><span class="line">## 7.4 逻辑运算符</span><br><span class="line">运算符|名称|运算式|说明</span><br><span class="line">-|-|-|-</span><br><span class="line">`&amp;&amp;`|逻辑与|`expr1 &amp;&amp; expr2`|若`expr1`为true，则返回`expr2`的值，否则，返回`expr1`的值，且不再计算`expr2`</span><br><span class="line">&lt;code&gt;&amp;#124;&amp;#124;&lt;/code&gt;|逻辑或|&lt;code&gt;expr1 &amp;#124;&amp;#124; expr2&lt;/code&gt;|若`expr1`为false，则返回`expr2`的值，否则，返回`expr1`的值，且不再计算`expr2`</span><br><span class="line">`!`|逻辑非|`!expr`|若`expr` 为 true，则返回 `false`，否则，返回`true`</span><br><span class="line">`!!`|双重非|`!!expr`|显式地将任意值强制转换为其对应的布尔值</span><br><span class="line">1. 表达式的布尔值与值不是一个概念，如`1 - 1` 返回的值是0，返回的布尔值是false</span><br><span class="line">2. 逻辑与和逻辑或存在短路计算，即整个表达式的值在第一个表达式计算后已经确定了，就不再计算第二个。</span><br><span class="line">3. 逻辑与的优先级高于逻辑或</span><br><span class="line"></span><br><span class="line">## 7.5 按位运算符</span><br><span class="line">运算符|名称|运算式|说明</span><br><span class="line">-|-|-|-</span><br><span class="line">`&amp;`|按位与|`x &amp; y`|有0则0</span><br><span class="line">&lt;code&gt;&amp;#124;&lt;/code&gt;|按位或|&lt;code&gt;x &amp;#124; y&lt;/code&gt;|有1则1</span><br><span class="line">`~`|按位非|`~x`|1变0，0变1</span><br><span class="line">`^`|按位异或|`x ^ y`|相同则0，不同则1</span><br><span class="line">`&lt;&lt;`|左移|`x &lt;&lt; y`|低位补0，相当于&lt;code&gt;x * 2&lt;sup&gt;y&lt;/sup&gt;&lt;/code&gt;</span><br><span class="line">`&gt;&gt;`|右移|`x &gt;&gt; y`|舍去低位，正数高位补0，负数高位补1，相当于&lt;code&gt;x / 2&lt;sup&gt;y&lt;/sup&gt;&lt;/code&gt;</span><br><span class="line">`&gt;&gt;&gt;`|无符号右移|`x &gt;&gt;&gt; y`|舍去低位，高位补0，相当于&lt;code&gt;x / 2&lt;sup&gt;y&lt;/sup&gt;&lt;/code&gt;</span><br><span class="line"></span><br><span class="line">## 7.6 三元运算符</span><br><span class="line">* `condition ? exprIfTrue : exprIfFalse`</span><br><span class="line">1. 若`condition` 为true，返回`exprIfTrue`的值，否则，返回`exprIfFalse`的值</span><br><span class="line">2. 和 `if else` 的区别：if...else是语句，没有返回值；三元运算符是表达式，具有返回值。</span><br><span class="line"></span><br><span class="line">## 7.7 void运算符</span><br><span class="line">* `void expression`</span><br><span class="line">* 对给定的表达式进行求值，然后返回 undefined</span><br><span class="line">* void 运算符通常只用于获取 undefined的原始值，一般使用`void(0)`（等同于`void 0`）</span><br><span class="line">* 应用</span><br><span class="line">1. JavaScript URIs</span><br><span class="line">* 当url使用`javascript:`协议，点击时，会执行URI中的代码，然后用返回的值替换页面内容，除非返回的值是undefined。</span><br><span class="line">* void运算符可用于返回undefined。</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);" target="_blank" rel="noopener">xxx</a> // 不会跳转。<br><a href="#">xxx</a> // 会跳转只是跳向本页面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2. 在箭头函数中避免泄漏</span><br><span class="line">* 箭头函数标准中，允许在函数体不使用括号来直接返回值。 如果右侧调用了一个原本没有返回值的函数，其返回值改变后，则会导致非预期的副作用</span><br><span class="line">* 应该使用 void 运算符，来确保返回 undefined</span><br></pre></td></tr></table></figure><p>() =&gt; void doSomething();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 7.8 逗号运算符</span><br><span class="line">* `expr1, expr2, expr3...`</span><br><span class="line">* 从左到右依次计算每个表达式，并返回最后一个表达式的值</span><br></pre></td></tr></table></figure><p>‘a’, ‘b’ // “b”<br>var x = 0;<br>var y = (x++, 10);  // x=1 y=10</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 八 展开语法(Spread syntax)</span><br><span class="line">## 8.1 概述</span><br><span class="line">1. 展开语法用  `...` 进行表示</span><br><span class="line">2. 展开语法在函数调用或构造字面量数组时, 将**可迭代对象**（如数组, string, ...）在语法层面展开；</span><br><span class="line">3. 展开语法在构造字面量对象时, 将对象表达式按key-value的方式展开</span><br><span class="line"> </span><br><span class="line">## 8.2 应用</span><br><span class="line">### 1 函数调用</span><br></pre></td></tr></table></figure><p>function show(x, y, z) { }<br>let args = [0, 1, 2];<br>show(…args); // &lt;=&gt; show(0, 1, 2)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 2 字面量数组</span><br></pre></td></tr></table></figure><p>let arr1 = [0, 1, 2];<br>let arr2 = [3, 4, 5];<br>let arr3 = […arr1, …arr2]; // [0,1,2,3,4,5]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3 字面量对象</span><br></pre></td></tr></table></figure><p>let obj1 = { foo: ‘bar’, x: 42 };<br>let obj2 = { foo: ‘baz’, y: 13 };<br>let clonedObj = { …obj1 };<br>// 克隆后的对象: { foo: “bar”, x: 42 }<br>let mergedObj = { …obj1, …obj2 };<br>// 合并后的对象: { foo: “baz”, x: 42, y: 13 }</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 九 剩余参数</span><br><span class="line">## 9.1 概述</span><br><span class="line">1. 剩余参数是一个数组，用于接收形参外的所有参数</span><br><span class="line">2. 剩余参数必须是最后一个参数</span><br><span class="line"></span><br><span class="line">## 9.2 语法</span><br></pre></td></tr></table></figure><p>function(a, b, …theArgs) {<br>    // …<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 9.3 剩余参数和 arguments对象的区别</span><br><span class="line">1. 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。</span><br><span class="line">2. arguments对象不是一个真正的数组，而剩余参数是真正的 Array实例，即剩余参数可以使用所有的数组方法</span><br><span class="line"></span><br><span class="line"># 十 解构赋值</span><br><span class="line">## 10.1 概述</span><br><span class="line">1. 解构赋值：从数组和对象中提取值，对变量进行赋值</span><br><span class="line">2. 解构对象时会查找原型链（如果属性不在对象自身，将从原型链中查找）</span><br><span class="line"></span><br><span class="line">## 10.2 解构数组</span><br><span class="line">1. 先声明后赋值的解构</span><br></pre></td></tr></table></figure><p>let a, b;<br>[a, b] = [10, 20]; // a=10 b=20</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 声明并赋值的解构</span><br></pre></td></tr></table></figure><p>let [a,b] = [10, 20]; // a=10 b=20</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 默认值</span><br></pre></td></tr></table></figure><p>let [a = 3, b = 4] = [1]; // a=1 b=4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4. 变量数量小于值数量时，忽略多余值</span><br></pre></td></tr></table></figure><p>let [a, b] = [1, 2, 3, 4]; // a =1 b = 2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5. 可用于交换变量</span><br></pre></td></tr></table></figure><p>let a =1;<br>let b = 2;<br>[a, b] = [b, a]; // a=2 b=1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6. 剩余参数</span><br></pre></td></tr></table></figure><p>let [a, …b] = [1, 2, 3]; // a=1 b=[2,3]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 10.3 解构对象</span><br><span class="line">1. 基本语法</span><br></pre></td></tr></table></figure><p>let {key:变量} = {key:value};</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* `&#123;key:变量&#125;`</span><br><span class="line">* 将对象中属性key的值赋值给变量</span><br><span class="line">2. 变量名与属性名相同可以简写</span><br></pre></td></tr></table></figure><p>let {key:key} = {key:value};<br>let {key} = {key:value}; // 简写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 先声明后赋值的解构</span><br></pre></td></tr></table></figure><p>let name, age;<br>{name,age} =  {name:’an3’, age:18}); // 错误<br>({name, age} = {name:’an3’, age:18}); // name=’an3’ age=18</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 赋值时必须使用()包括，因为左边`&#123;name, age&#125;`会被认为是块而不是对象字面量</span><br><span class="line">4. 默认值</span><br></pre></td></tr></table></figure><p>let {name=’haha’, age=10} = {name:’an3’}; // name=’an3’ age=10<br>let {name:n=’haha’ age:a=10} = {name:’an3’}; // n=’an3’ a=10</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5. 变量数量小于值数量时，忽略多余值</span><br></pre></td></tr></table></figure><p>let {name=’haha’, age=10} = {name:’an3’,age:10,sex:1}; // name=’an3’ age=18</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6. 解构嵌套</span><br></pre></td></tr></table></figure><p>let user = {<br>    name:’xiaoming’,<br>    lesson:{<br>        title:’js’,<br>        score:90<br>    }<br>};<br>let {name,lesson:{title,score}} = user;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 十一 语句</span><br><span class="line">## 11.1 &#123;&#125;</span><br><span class="line">* `&#123; StatementList &#125;`</span><br><span class="line">* 声明块作用域</span><br><span class="line"></span><br><span class="line">## 11.2 if...else</span><br><span class="line">## 11.3 switch</span><br></pre></td></tr></table></figure><p>switch (expression) {<br>    case value1:<br>    // 当 expression 的结果与 value1 匹配时，执行此处语句<br>    [break;]<br>    case value2:<br>    // 当 expression 的结果与 value2 匹配时，执行此处语句<br>    [break;]<br>    …<br>    case valueN:<br>    // 当 expression 的结果与 valueN 匹配时，执行此处语句<br>    [break;]<br>    [default:<br>    // 如果 expression 与上面的 value 值都不匹配，执行此处语句<br>    [break;]]<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* switch内部采用严格相等</span><br><span class="line">* 省略break：会继续运行下一个case语句无论值是否匹配</span><br><span class="line"></span><br><span class="line">## 11.4 for</span><br></pre></td></tr></table></figure><p>for ([initialization]; [condition]; [final-expression]){<br>    statement<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* for循环每次循环都是一个单独的函数作用域</span><br><span class="line">1. 在 for 循环中使用let/const 会在每一次循环重新生成不同的变量</span><br><span class="line">2. 在 for 循环中使用var声明的变量是全局共享的</span><br><span class="line"></span><br><span class="line">## 11.5 while / do...while</span><br><span class="line">## 11.6 label</span><br></pre></td></tr></table></figure><p>label :<br>    statement</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* 相当于定位符，用于跳转到程序的任意位置，通常与break语句和continue语句配合使用，break 可用于任何标记语句，而 continue 用于循环标记语句</span><br><span class="line">* `break [label]` 或 `continue [label]`</span><br><span class="line">* label ：任何不属于保留关键字的 JavaScript 标识符</span><br><span class="line"></span><br><span class="line">## 11.7 in</span><br><span class="line">* `prop in object`</span><br><span class="line">* 判断对象自身或其原型链上是否包含某个属性</span><br><span class="line"></span><br><span class="line">## 11.8 for...in</span><br></pre></td></tr></table></figure><p>for (let/const key in object){<br>    // statements<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 遍历对象</span><br><span class="line">1. 遍历对象的所有可枚举属性（包括它的原型链上的可枚举属性），属性是否可枚举由属性描述符的`enumerable`决定</span><br><span class="line">2. 每次循环获取的是属性名</span><br><span class="line">2. 遍历数组（不推荐）</span><br><span class="line">1. 数组键名是数字，但每次循环获取的是索引的字符串</span><br><span class="line">2. 除了遍历数组元素外，数组本身以及原型链上的可枚举属性也会被遍历到</span><br><span class="line">3. 某些情况下，不能保证按顺序返回索引</span><br><span class="line"></span><br><span class="line">## 11.9 for...of</span><br></pre></td></tr></table></figure><p>for (let/const value of iterable) {<br>    //statements<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1. 用来遍历可迭代对象（Array，Map，Set，String，TypedArray，arguments对象，DOM NodeList对象，Generator对象...）</span><br><span class="line">2. 每次循环取出的是值</span><br><span class="line"></span><br><span class="line"># 十二 概念</span><br><span class="line">1. 可枚举属性：属性描述符 `enumerable: true` 的属性</span><br><span class="line">2. 普通对象：没有数字键和length属性的对象</span><br><span class="line">3. 类数组对象：存在数值键名和length属性的对象</span><br><span class="line"></span><br><span class="line">## 十三 Iterator</span><br><span class="line">## 13.1 迭代器</span><br><span class="line">* 迭代器就是具有`next()`方法的对象</span><br><span class="line">* `next()` </span><br><span class="line">* 返回一个对象，返回对象拥有两个属性</span><br><span class="line">1. `value`：当前迭代的值</span><br><span class="line">1. `done`：布尔值，迭代是否结束。</span><br><span class="line">* false表示没结束，`done:false` 可以省略</span><br><span class="line">* true表示结束，此时value为undefined，`value:undefined` 可以省略</span><br><span class="line"></span><br><span class="line">## 13.2 Iterator 接口</span><br><span class="line">1. 一个数据结构只要具有 `Symbol.iterator` 属性，就认为是实现了Iterator接口</span><br><span class="line">2. 对象（或者其原型链）上拥有 `Symbol.iterator` 属性，就是可迭代对象</span><br><span class="line"></span><br><span class="line">## 13.3 Symbol.iterator</span><br><span class="line">1. `Symbol.iterator` 本身是一个函数，就是当前数据结构默认的迭代器生成函数。执行这个函数，就会返回一个迭代器</span><br><span class="line">2. `Symbol.iterator` 要放在方括号中，因为它作为属性名是一个表达式，返回Symbole对象的iterator属性。</span><br><span class="line"></span><br><span class="line">## 13.4 for... of</span><br><span class="line">1. for... of 内部就是调用了可迭代对象的 `Symbol.iterator` 生成了迭代器</span><br><span class="line">2. 自定义for... of</span><br></pre></td></tr></table></figure><p>function myForOf(arr) {<br>    let it = arr<a href="">Symbol.iterator</a>;<br>    let res = it.next();<br>    while(!res.done) {<br>        console.log(res.value);<br>        res = it.next();<br>    }<br>}</p><p>```</p><h1 id="十四-全局函数"><a href="#十四-全局函数" class="headerlink" title="十四 全局函数"></a>十四 全局函数</h1><ol><li><code>encodeURI(URI)</code><ul><li>使用UTF-8进行URL编码，编码后的格式为UTF-8编码的每个字节前加<code>%</code></li><li>不会编码的字符<ol><li><code>; , / ? : @ &amp; = + $</code></li><li><code>字母 数字 - _ . ! ~ * &#39; ( )</code></li><li><code>#</code></li></ol></li></ul></li><li><code>decodeURI(encodedURI)</code><ul><li><code>encodeURI()</code>对应的解码函数</li></ul></li><li><code>encodeURIComponent(str)</code><ul><li>类似<code>encodeURI()</code>，区别在于不会编码的字符。</li><li>不会编码的字符<ul><li><code>字母 数字 - _ . ! ~ * &#39; ( )</code></li></ul></li></ul></li><li><code>decodeURIComponent(encodedURI)</code><ul><li><code>encodeURIComponent()</code>对应的解码函数</li></ul></li><li><code>isFinite(value)</code><ul><li>见 <code>Number.isFinite(value)</code></li></ul></li><li><code>isNaN(value)</code><ul><li>见 <code>Number.isNaN(value)</code></li></ul></li><li><code>parseInt(string[, radix])</code><ul><li>见 <code>Number.parseInt(string[, radix])</code></li></ul></li><li><code>parseFloat(string)</code><ul><li>见 <code>Number.parseFloat(string)</code></li></ul></li><li><code>eval(string)</code>（永远不要使用!）<ul><li>将传入的字符串当做 JavaScript 代码进行执行</li><li><code>string</code><ol><li>如果是表达式，则对表达式进行求值</li><li>如果是一个或多个 JavaScript 语句，则执行这些语句</li></ol></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-严格模式&quot;&gt;&lt;a href=&quot;#一-严格模式&quot; class=&quot;headerlink&quot; title=&quot;一 严格模式&quot;&gt;&lt;/a&gt;一 严格模式&lt;/h1&gt;&lt;h2 id=&quot;1-1-启用&quot;&gt;&lt;a href=&quot;#1-1-启用&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="UI" scheme="https://anyeansan.github.io/categories/UI/"/>
    
      <category term="Javascript" scheme="https://anyeansan.github.io/categories/UI/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>Javascript 概述</title>
    <link href="https://anyeansan.github.io/2020/03/30/Javascript-%E6%A6%82%E8%BF%B0/"/>
    <id>https://anyeansan.github.io/2020/03/30/Javascript-%E6%A6%82%E8%BF%B0/</id>
    <published>2020-03-30T14:01:05.000Z</published>
    <updated>2020-03-30T14:01:39.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ol><li>跨平台的解释性脚本语言 </li><li>ECMAScript是规范，JavaScript是实现</li></ol><h2 id="1-2-组成"><a href="#1-2-组成" class="headerlink" title="1.2 组成"></a>1.2 组成</h2><ol><li>ECMAScript<ul><li>根据MCMA-262标准，实现的通用脚本语言规范</li></ul></li><li>DOM<ul><li><code>document object model</code></li><li>文档对象模型</li></ul></li><li>BOM<ul><li><code>browser object moel</code></li><li>浏览器对象模型</li></ul></li></ol><h2 id="1-3-JavaScript处理引擎"><a href="#1-3-JavaScript处理引擎" class="headerlink" title="1.3 JavaScript处理引擎"></a>1.3 JavaScript处理引擎</h2><ul><li>专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器之中</li><li>主要浏览器引擎<ol><li><code>chrome v8</code></li><li><code>firefox SpiderMonkey</code></li><li><code>edge chakra</code></li><li><code>Opera Carakan</code></li><li>……</li></ol></li></ul><h2 id="1-4-网页加载流程-前端"><a href="#1-4-网页加载流程-前端" class="headerlink" title="1.4 网页加载流程 - 前端"></a>1.4 网页加载流程 - 前端</h2><ol><li>浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。</li><li>css 和 html 是并行加载的，过程中如果遇到css 或者 img，则会向浏览器返回一个请求，待资源返回后，将其添加到dom的相应位置中</li><li>解析过程中，浏览器发现<code>&lt;script&gt;</code>元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎（原因是 JavaScript 代码可以修改 DOM，所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题。）</li><li>如果<code>&lt;script&gt;</code>元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</li><li>JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页</li></ol><h1 id="二-引入JavaScript脚本"><a href="#二-引入JavaScript脚本" class="headerlink" title="二  引入JavaScript脚本"></a>二  引入JavaScript脚本</h1><h2 id="2-1-JavaScript脚本位置"><a href="#2-1-JavaScript脚本位置" class="headerlink" title="2.1 JavaScript脚本位置"></a>2.1 JavaScript脚本位置</h2><ol><li>浏览器加载 JavaScript 脚本，主要通过<code>&lt;script&gt;</code>元素完成</li><li>如果外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。所以<code>&lt;script&gt;</code> 最好放在页面底部<ol><li>即使遇到脚本失去响应，网页主体的渲染也已经完成了，用户至少可以看到内容</li><li>在 DOM 结构生成之前就调用 DOM 节点，JavaScript 会报错，如果脚本都在网页尾部加载，就不存在这个问题，因为这时 DOM 肯定已经生成了。</li></ol></li></ol><h2 id="2-2-javascript-协议"><a href="#2-2-javascript-协议" class="headerlink" title="2.2 javascript: 协议"></a>2.2 <code>javascript:</code> 协议</h2><ul><li>URL 支持<code>javascript:</code>协议，即在 URL 的位置写入代码，使用这个 URL 的时候就会执行 JavaScript 代码。</li></ul><h2 id="2-3-JavaScript-脚本引入方式"><a href="#2-3-JavaScript-脚本引入方式" class="headerlink" title="2.3 JavaScript 脚本引入方式"></a>2.3 JavaScript 脚本引入方式</h2><h3 id="1-内联脚本"><a href="#1-内联脚本" class="headerlink" title="1 内联脚本"></a>1 内联脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;alert(&apos;xxx&apos;)&quot;&gt;第一种直接写方法体&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;button onclick=&quot;fn()&quot;&gt;第二种传递方法&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function fn() &#123;</span><br><span class="line">alert(&apos;xxx&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="2-内部脚本"><a href="#2-内部脚本" class="headerlink" title="2 内部脚本"></a>2 内部脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;button&gt;点我&lt;/button&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">document.querySelector(&apos;button&apos;).addEventListener(&apos;click&apos;,() =&gt; alert(&apos;xxx&apos;));</span><br><span class="line">&lt;script&gt;</span><br></pre></td></tr></table></figure><ul><li>type可以省略 默认<code>text/javascript</code>，新的浏览器可以写<code>application/javascript</code></li></ul><h3 id="3-外部脚本"><a href="#3-外部脚本" class="headerlink" title="3 外部脚本"></a>3 外部脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;xxx.js&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol><li>标签体不能有内容，<code>&lt;/script&gt;</code>不能省略</li><li><code>src</code> 默认是http协议</li><li>外部的js文件中不能包含<code>&lt;script&gt;</code>标签。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一 前言&quot;&gt;&lt;/a&gt;一 前言&lt;/h1&gt;&lt;h2 id=&quot;1-1-概述&quot;&gt;&lt;a href=&quot;#1-1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.1 概
      
    
    </summary>
    
    
      <category term="UI" scheme="https://anyeansan.github.io/categories/UI/"/>
    
      <category term="Javascript" scheme="https://anyeansan.github.io/categories/UI/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>MongoDB</title>
    <link href="https://anyeansan.github.io/2020/03/30/MongoDB/"/>
    <id>https://anyeansan.github.io/2020/03/30/MongoDB/</id>
    <published>2020-03-30T13:57:12.000Z</published>
    <updated>2020-03-30T13:57:31.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-安装"><a href="#一-安装" class="headerlink" title="一 安装"></a>一 安装</h1><ol><li>下载解压，并修改属主属组</li><li>关闭 Linux 大页内存 THP（transparent huge pages）<ul><li><code>https://docs.mongodb.com/v3.6/tutorial/transparent-huge-pages/</code></li></ul></li><li>创建所需用户和用户组</li><li>创建存储目录并修改属主属组<ol><li><code>data directory</code></li><li><code>log file</code></li><li><code>conf directory</code></li></ol></li><li>设置用户环境变量<ol><li>切换到创建用户</li><li>修改用户目录下 <code>.bash_profile</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=basedir/bin:$PATH</span><br></pre></td></tr></table></figure></li><li><code>source .bash_profile</code></li></ol></li></ol><h1 id="二-配置"><a href="#二-配置" class="headerlink" title="二 配置"></a>二 配置</h1><ul><li>在指定的 <code>conf directory</code> 下创建配置文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># YAML 模式配置 模板</span><br><span class="line">systemLog:</span><br><span class="line">   destination: file</span><br><span class="line">   path: /var/log/mongodb/mongod.log</span><br><span class="line">   logAppend: true</span><br><span class="line">storage:</span><br><span class="line">   journal:</span><br><span class="line">      enabled: true</span><br><span class="line">      dbPath: </span><br><span class="line">processManagement:</span><br><span class="line">   fork: true # 后台守护进程</span><br><span class="line">   pidFilePath: # pid文件位置，建议不配置，直接生成到data下</span><br><span class="line">net:</span><br><span class="line">   bindIp: 127.0.0.1 # 监听地址，默认 0.0.0.0</span><br><span class="line">   port: 27017</span><br><span class="line">security:</span><br><span class="line">    authorization: enabled # 用户验证</span><br></pre></td></tr></table></figure></li></ul><h1 id="三-启动与关闭-mongod"><a href="#三-启动与关闭-mongod" class="headerlink" title="三 启动与关闭 mongod"></a>三 启动与关闭 mongod</h1><h2 id="3-1-启动"><a href="#3-1-启动" class="headerlink" title="3.1 启动"></a>3.1 启动</h2><ol><li><code>mongod -f 配置文件</code><ul><li>启动</li></ul></li></ol><h2 id="3-2-关闭"><a href="#3-2-关闭" class="headerlink" title="3.2 关闭"></a>3.2 关闭</h2><ol><li><code>mongod -f 配置文件 --shutdown</code><ul><li>关闭</li></ul></li><li><code>db.shutdownServer()</code></li><li><code>kill -2 &lt;mongod process ID&gt;</code></li></ol><h1 id="四-登录与退出"><a href="#四-登录与退出" class="headerlink" title="四 登录与退出"></a>四 登录与退出</h1><ol><li><code>mongo -u -p ip/验证库</code></li><li><code>exit</code></li></ol><h1 id="五-概述"><a href="#五-概述" class="headerlink" title="五 概述"></a>五 概述</h1><h2 id="5-1-逻辑结构"><a href="#5-1-逻辑结构" class="headerlink" title="5.1 逻辑结构"></a>5.1 逻辑结构</h2><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td><code>database</code></td><td>库</td></tr><tr><td><code>collection</code></td><td>表（集合）</td></tr><tr><td><code>document</code></td><td>文档（数据行）</td></tr><tr><td><code>field</code></td><td>字段</td></tr><tr><td><code>index</code></td><td>索引</td></tr><tr><td><code>primary key</code></td><td>主键，MongoDB自动将 <code>_id</code> 字段设置为主键</td></tr><tr><td>* 文档数据都是 BSON 格式。</td><td></td></tr><tr><td>* BSON 是一种类似 JSON 的二进制形式的存储格式，是 Binary JSON 的简称</td><td></td></tr></tbody></table><h2 id="5-2-默认库"><a href="#5-2-默认库" class="headerlink" title="5.2 默认库"></a>5.2 默认库</h2><ol><li><code>test</code><ul><li>登录时默认所在库</li></ul></li><li><code>admin</code><ul><li>系统预留库，MongoDB系统管理库</li></ul></li><li><code>local</code><ul><li>本地预留库，存储关键日</li></ul></li><li><code>config</code><ul><li>MongoDB配置信息库</li></ul></li></ol><h1 id="六-操作"><a href="#六-操作" class="headerlink" title="六 操作"></a>六 操作</h1><h2 id="6-1-库操作"><a href="#6-1-库操作" class="headerlink" title="6.1 库操作"></a>6.1 库操作</h2><h3 id="1-帮助"><a href="#1-帮助" class="headerlink" title="1 帮助"></a>1 帮助</h3><ol><li><code>db.help()</code><ul><li>帮助</li></ul></li><li><code>db.[tab][tab]</code><ul><li>两次 tab</li></ul></li></ol><h3 id="2-查"><a href="#2-查" class="headerlink" title="2 查"></a>2 查</h3><ol><li><code>show dbs / show databases</code></li><li><code>db</code><ul><li>相当于 <code>select database()</code></li></ul></li><li><code>db.status()</code></li></ol><h3 id="3-增"><a href="#3-增" class="headerlink" title="3 增"></a>3 增</h3><ul><li><code>use db_name</code><ul><li>若存在，切换到数据库，</li><li>若不存在，则创建并切换（注意库中存有数据才会显示在数据库列表中）</li></ul></li></ul><h3 id="4-删"><a href="#4-删" class="headerlink" title="4 删"></a>4 删</h3><ul><li><code>db.dropDatabase()</code></li></ul><h2 id="6-2-集合操作"><a href="#6-2-集合操作" class="headerlink" title="6.2 集合操作"></a>6.2 集合操作</h2><h3 id="1-查"><a href="#1-查" class="headerlink" title="1 查"></a>1 查</h3><ul><li><code>show collections / show tables</code></li></ul><h3 id="2-增"><a href="#2-增" class="headerlink" title="2 增"></a>2 增</h3><ul><li><code>db.createCollection(name, options)</code><ul><li><code>name</code><ul><li>集合名称</li></ul></li><li><code>options</code><ol><li><code>capped</code><ol><li><code>false</code> ：默认</li><li><code>true</code> ：创建固定大小的集合，当达到最大值时，它会自动覆盖最早的文档，必须指定 <code>size</code> 参数</li></ol></li><li><code>size</code><ul><li>为固定集合指定一个最大值（KB）</li></ul></li><li><code>max</code><ul><li>指定固定集合中包含文档的最大数量</li></ul></li><li><code>autoIndexId</code><ol><li><code>false</code> ：默认</li><li><code>true</code> ：自动在 _id 字段创建索引</li></ol></li></ol></li></ul></li></ul><h3 id="3-删"><a href="#3-删" class="headerlink" title="3 删"></a>3 删</h3><ul><li><code>db.collection.drop()</code></li></ul><h2 id="6-3-文档操作"><a href="#6-3-文档操作" class="headerlink" title="6.3 文档操作"></a>6.3 文档操作</h2><h3 id="1-增"><a href="#1-增" class="headerlink" title="1 增"></a>1 增</h3><ol><li><code>db.collection_name.insertOne()</code><ul><li>如果指定 collection 不存在，则会创建</li></ul></li><li><code>db.collection_name.insertMany()</code></li></ol><h3 id="2-删"><a href="#2-删" class="headerlink" title="2 删"></a>2 删</h3><ol><li><code>db.collection_name.deleteOne()</code></li><li><code>db.collection_name.deleteMany()</code></li></ol><h3 id="4-改"><a href="#4-改" class="headerlink" title="4 改"></a>4 改</h3><ol><li><code>db.collection_name.updateOne()</code></li><li><code>db.collection_name.updateMany()</code></li><li><code>db.collection_name.replaceOne()</code></li></ol><h3 id="4-查"><a href="#4-查" class="headerlink" title="4 查"></a>4 查</h3><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h4><ul><li><code>db.collection_name.find()[.limit()][.pretty()]</code><ul><li>查询所有</li><li><code>.pretty()</code><ul><li>以 json 格式显示结果</li></ul></li></ul></li></ul><h4 id="2-比较"><a href="#2-比较" class="headerlink" title="2 比较"></a>2 比较</h4><table><thead><tr><th>格式</th><th>说明</th></tr></thead><tbody><tr><td><code>{key:value}</code></td><td>等于</td></tr><tr><td><code>{key:{$ne:value}}</code></td><td>不等于</td></tr><tr><td><code>{key:{$lt:value}}</code></td><td>小于</td></tr><tr><td><code>{key:{$lte:value}}</code></td><td>小于等于</td></tr><tr><td><code>{key:{$gt:value}}</code></td><td>大于</td></tr><tr><td><code>{key:{$gte:value}}</code></td><td>大于等于</td></tr></tbody></table><h4 id="3-and"><a href="#3-and" class="headerlink" title="3 and"></a>3 and</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">key:value,</span><br><span class="line">key:value,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-or"><a href="#4-or" class="headerlink" title="4 or"></a>4 or</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">$or: [</span><br><span class="line">&#123;key:value&#125;,</span><br><span class="line">&#123;key:value&#125;,</span><br><span class="line">...</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七-用户管理"><a href="#七-用户管理" class="headerlink" title="七 用户管理"></a>七 用户管理</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ol><li>验证库<ul><li>登陆时要指定验证库才能登录，验证库即创建用户时 user 到的库</li></ul></li><li>管理员验证库为 <code>admin</code>，即管理员必须在 <code>admin</code> 库下创建</li><li>普通用户在所管理的库下创建</li></ol><h2 id="7-2-创建用户"><a href="#7-2-创建用户" class="headerlink" title="7.2 创建用户"></a>7.2 创建用户</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">user db_name # 指定验证库</span><br><span class="line">db.createUser(</span><br><span class="line">&#123;</span><br><span class="line">user: &quot;用户名&quot;,</span><br><span class="line">pwd: &quot;密码&quot;,</span><br><span class="line">roles: [</span><br><span class="line">&#123;role: &quot;root&quot;, db: &quot;admin&quot;&#125;, # 用来创建管理员</span><br><span class="line">&#123;role: &quot;read&quot;, db: &quot;数据库&quot;&#125;,</span><br><span class="line">&#123;role: &quot;readWrite&quot;, db: &quot;数据库&quot;&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">db.auth(&apos;username&apos;,&apos;password&apos;) # 验证用户</span><br></pre></td></tr></table></figure><h2 id="7-3-查看用户"><a href="#7-3-查看用户" class="headerlink" title="7.3 查看用户"></a>7.3 查看用户</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.system.users.find().pretty()</span><br></pre></td></tr></table></figure><h2 id="7-4-删除用户（管理员登录）"><a href="#7-4-删除用户（管理员登录）" class="headerlink" title="7.4 删除用户（管理员登录）"></a>7.4 删除用户（管理员登录）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user db_name </span><br><span class="line">db.dropUser(&quot;username&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-安装&quot;&gt;&lt;a href=&quot;#一-安装&quot; class=&quot;headerlink&quot; title=&quot;一 安装&quot;&gt;&lt;/a&gt;一 安装&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;下载解压，并修改属主属组&lt;/li&gt;
&lt;li&gt;关闭 Linux 大页内存 THP（transparent huge
      
    
    </summary>
    
    
      <category term="DB" scheme="https://anyeansan.github.io/categories/DB/"/>
    
      <category term="MongoDB" scheme="https://anyeansan.github.io/categories/DB/MongoDB/"/>
    
    
  </entry>
  
  <entry>
    <title>MySql 数据库设计</title>
    <link href="https://anyeansan.github.io/2020/03/30/MySql-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <id>https://anyeansan.github.io/2020/03/30/MySql-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</id>
    <published>2020-03-30T13:50:13.000Z</published>
    <updated>2020-03-30T13:50:53.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-范式概述"><a href="#一-范式概述" class="headerlink" title="一 范式概述"></a>一 范式概述</h1><ul><li><code>Normal Format</code><ul><li>是一种离散数学中的知识, 是为了解决一种数据的存储与优化的问题: 保存数据的存储之后, 凡是能够通过关系寻找出来的数据,坚决不再重复存储: 终极目标是为了减少数据的冗余.</li></ul></li><li>范式是一种分层结构的规范, 分为六层: 每一次层都比上一层更加严格: 若要满足下一层范式,前提是满足上一层范式.<ul><li>1NF,2NF,3NF…6NF</li><li>1NF是最底层,要求最低;6NF最高层,最严格</li></ul></li></ul><h1 id="二-1NF"><a href="#二-1NF" class="headerlink" title="二 1NF"></a>二 1NF</h1><ul><li>第一范式: 在设计表存储数据的时候, 如果表中设计的字段存储的数据,在取出来使用之前还需要额外的处理(拆分),那么说表的设计不满足第一范式</li><li>第一范式要求字段的数据具有原子性: 不可再分</li><li>解决<ul><li>拆分字段</li></ul></li></ul><h1 id="二-2NF"><a href="#二-2NF" class="headerlink" title="二 2NF"></a>二 2NF</h1><ul><li>第二范式: 在数据表设计的过程中,如果有复合主键(多字段主键), 且表中有字段并不是由整个主键来确定, 而是依赖主键中的某个字段(主键的部分): 存在字段依赖主键的部分的问题, 称之为部分依赖:</li><li>第二范式就是要解决表设计不允许出现部分依赖</li><li>解决<ol><li>可以将复合主键字段单独成表</li><li>取消复合主键，使用逻辑主键 </li></ol></li></ul><h1 id="三-3NF"><a href="#三-3NF" class="headerlink" title="三 3NF"></a>三 3NF</h1><ul><li>第三范式: 理论上讲,应该一张表中的所有字段都应该直接依赖主键(逻辑主键: 代表的是业务主键), 如果表设计中存在一个字段, 并不直接依赖主键,而是通过某个非主键字段依赖,最终实现依赖主键: 把这种不是直接依赖主键,而是依赖非主键字段的依赖关系称之为传递依赖</li><li>第三范式就是要解决传递依赖的问题.</li><li>解决<ul><li>将存在传递依赖的字段,以及依赖的字段本身单独取出,形成一个单独的表, 然后在需要对应的信息的时候, 使用对应的实体表的主键加进来.</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-范式概述&quot;&gt;&lt;a href=&quot;#一-范式概述&quot; class=&quot;headerlink&quot; title=&quot;一 范式概述&quot;&gt;&lt;/a&gt;一 范式概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Normal Format&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;是一种离散数学中的知识, 
      
    
    </summary>
    
    
      <category term="DB" scheme="https://anyeansan.github.io/categories/DB/"/>
    
      <category term="MySql" scheme="https://anyeansan.github.io/categories/DB/MySql/"/>
    
    
  </entry>
  
  <entry>
    <title>MySql 触发器</title>
    <link href="https://anyeansan.github.io/2020/03/30/MySql-%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>https://anyeansan.github.io/2020/03/30/MySql-%E8%A7%A6%E5%8F%91%E5%99%A8/</id>
    <published>2020-03-30T13:47:22.000Z</published>
    <updated>2020-03-30T13:49:45.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol><li>事先为某张表绑定好一段代码 ,当表中的某些内容发生改变的时候(增删改)系统会自动触发代码,执行</li><li>一张表中只能拥有一种触发时间的一种类型的触发器<ul><li>一张表最多能有6个触发器<ul><li>增删改/前后 6种组合</li></ul></li></ul></li></ol><h1 id="二-事件类型"><a href="#二-事件类型" class="headerlink" title="二 事件类型"></a>二 事件类型</h1><ul><li>增(insert)</li><li>删(delete)</li><li>改(update)</li></ul><h1 id="三-触发时间"><a href="#三-触发时间" class="headerlink" title="三 触发时间"></a>三 触发时间</h1><ul><li>前(before)</li><li>后(after)</li></ul><h1 id="四-触发对象"><a href="#四-触发对象" class="headerlink" title="四 触发对象"></a>四 触发对象</h1><ul><li>表中的每一条记录(行)</li></ul><h1 id="五-创建触发器"><a href="#五-创建触发器" class="headerlink" title="五 创建触发器"></a>五 创建触发器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 临时修改语句结束符</span><br><span class="line">Delimiter 自定义符号: 后续代码中只有碰到自定义符号才算结束</span><br><span class="line"></span><br><span class="line">Create trigger 触发器名字 触发时间 事件类型 on 表名 for each row</span><br><span class="line"></span><br><span class="line">Begin-- 代表左大括号: 开始</span><br><span class="line">-- 里面就是触发器的内容: 每行内容都必须使用语句结束符: 分号</span><br><span class="line">End-- 代表右带括号: 结束</span><br><span class="line"></span><br><span class="line">-- 语句结束符</span><br><span class="line">自定义符号</span><br><span class="line"></span><br><span class="line">-- 将临时修改修正过来</span><br><span class="line">Delimiter  ;</span><br></pre></td></tr></table></figure><h1 id="六-查看触发器"><a href="#六-查看触发器" class="headerlink" title="六 查看触发器"></a>六 查看触发器</h1><ul><li><code>Information_schema.triggers</code><ul><li>所有的触发器都会保存这一张表中</li></ul></li><li><code>Show triggers [like ‘pattern’]</code><ul><li>查看所有或者模糊匹配</li></ul></li><li><code>Show create trigger 触发器名</code><ul><li>查看触发器创建语句</li></ul></li></ul><h1 id="七-使用触发器"><a href="#七-使用触发器" class="headerlink" title="七 使用触发器"></a>七 使用触发器</h1><ul><li>不需要手动调用, 而是当某种情况发生时会自动触发.</li></ul><h1 id="八-修改-amp-删除触发器"><a href="#八-修改-amp-删除触发器" class="headerlink" title="八 修改&amp;删除触发器"></a>八 修改&amp;删除触发器</h1><ul><li>触发器不能修改</li><li><code>Drop trigger 触发器名</code><ul><li>删除</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;事先为某张表绑定好一段代码 ,当表中的某些内容发生改变的时候(增删改)系统会自动触发代码,执行&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="DB" scheme="https://anyeansan.github.io/categories/DB/"/>
    
      <category term="MySql" scheme="https://anyeansan.github.io/categories/DB/MySql/"/>
    
    
  </entry>
  
  <entry>
    <title>MySql 存储过程</title>
    <link href="https://anyeansan.github.io/2020/03/30/MySql-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <id>https://anyeansan.github.io/2020/03/30/MySql-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2020-03-30T13:45:27.000Z</published>
    <updated>2020-03-30T13:47:02.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol><li>SQL 的执行过程<ul><li><code>sql语句 → mysql引擎 → 检查语法 → 编译 → 执行 → 返回结果</code></li></ul></li><li>存储过程是一组为了完成特定功能的sql语句和流程控制语句的预编译集合，存储在数据库内，可以由应用程序调用。</li><li>存储过程的好处<ol><li>可复用</li><li>预编译：只在创建时编译一次，以后调用时不再编译，速度快</li><li>减少网络流量：存储过程存储在数据库服务器上，都在数据库服务器上运行，调用存储过程时只需要传递名称和参数即可。</li><li>安全：可防止sql注入。</li></ol></li></ol><h1 id="二-语法"><a href="#二-语法" class="headerlink" title="二 语法"></a>二 语法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE</span><br><span class="line">[DEFINER = user]</span><br><span class="line">PROCEDURE sp_name ([proc_parameter[,...]])</span><br><span class="line">[characteristic ...]</span><br><span class="line">routine_body</span><br><span class="line"></span><br><span class="line">proc_parameter:</span><br><span class="line">    [ IN | OUT | INOUT ] param_name type</span><br></pre></td></tr></table></figure><h1 id="三-创建"><a href="#三-创建" class="headerlink" title="三 创建"></a>三 创建</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DROP PROCEDURE IF EXISTS 存储过程名;</span><br><span class="line">DELIMITER [结束标记]</span><br><span class="line">CREATE PROCEDURE 存储过程名([参数列表])</span><br><span class="line">BEGIN</span><br><span class="line">        [存储过程体(一组合法的SQL语句)]</span><br><span class="line">END [结束标记]</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><ul><li>形参<ul><li><code>in</code><ul><li>输入参数，调用存储过程时传入的值</li></ul></li><li><code>out</code><ul><li>输出参数，可在存储过程内部被改变并返回。</li><li><code>into</code><ul><li>使用 <code>into</code> 为out参数赋值</li></ul></li></ul></li><li><code>inout</code><ul><li>输入输出参数，调用存储过程时传入值，在存储过程内部可以改变并返回。</li></ul></li></ul></li><li>返回值<ul><li>存储过程可以有返回值也可以没有返回值。</li></ul></li></ul><h1 id="四-查看"><a href="#四-查看" class="headerlink" title="四 查看"></a>四 查看</h1><ol><li><code>show procedure status [like ‘pattern’]</code><ul><li>查看所有存储过程或模糊匹配</li></ul></li><li><code>show create procedure 过程名</code><ul><li>查看过程创建语句:</li></ul></li></ol><h1 id="五-调用"><a href="#五-调用" class="headerlink" title="五 调用"></a>五 调用</h1><ul><li><code>call 存储过程名(in参数, @out参数, @inout参数)</code><ol><li>存储过程没有返回值（通过out返回），不能用select调用。</li><li>实参<ol><li>in参数：直接传递即可</li><li>out参数：定义一个变量接收返回值<code>@变量名</code></li><li>inout参数：在外部定义一个变量，并设置值</li></ol></li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// in</span><br><span class="line">call inpr(3);</span><br><span class="line">// out</span><br><span class="line">call outpr(@name);</span><br><span class="line">select @name;</span><br><span class="line">// inout</span><br><span class="line">set @age = 10;</span><br><span class="line">call inoutpr(@age);</span><br><span class="line">select @age;</span><br></pre></td></tr></table></figure><h1 id="六-修改-amp-删除"><a href="#六-修改-amp-删除" class="headerlink" title="六 修改&amp;删除"></a>六 修改&amp;删除</h1><ol><li>存储过程不可修改</li><li>删除<ul><li><code>drop procedoure [if exists] 存储过程名</code></li></ul></li></ol><h1 id="七-存储过程和自定义函数的区别"><a href="#七-存储过程和自定义函数的区别" class="headerlink" title="七 存储过程和自定义函数的区别"></a>七 存储过程和自定义函数的区别</h1><ol><li>存储过程实现的功能更复杂，函数的针对性更强</li><li>存储过程可以返回多个值，函数只能返回一个值</li><li>存储过程一般单独执行，函数可以作为其它sql语句的组成部分。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;SQL 的执行过程&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sql语句 → mysql引擎 → 检查语法 → 编译 → 执行
      
    
    </summary>
    
    
      <category term="DB" scheme="https://anyeansan.github.io/categories/DB/"/>
    
      <category term="MySql" scheme="https://anyeansan.github.io/categories/DB/MySql/"/>
    
    
  </entry>
  
  <entry>
    <title>MySql 视图</title>
    <link href="https://anyeansan.github.io/2020/03/30/MySql-%E8%A7%86%E5%9B%BE/"/>
    <id>https://anyeansan.github.io/2020/03/30/MySql-%E8%A7%86%E5%9B%BE/</id>
    <published>2020-03-30T13:41:53.000Z</published>
    <updated>2020-03-30T13:45:10.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol><li>view可以看作是一张虚拟表，是表通过某种运算得到的一个投影。</li><li>视图中并没有真正存储数据。</li><li>表的改变会影响视图(视图就好像表的影子一样)</li><li>视图的改变也能影响表。(如果可以改变的话)</li><li>可以跟基本表一样，进行增删改查操作</li></ol><h1 id="二-数据操作"><a href="#二-数据操作" class="headerlink" title="二 数据操作"></a>二 数据操作</h1><ol><li>主要是用来查询</li><li>增删改操作有条件限制<ul><li>如果视图的数据与表的数据是一一对应出来的，改变不会影响其它数据，就可以增删改。</li><li>如果视图的数据是通过计算得来的，改变则会影响表中的其它数据，不可以增删改。</li></ul></li></ol><h1 id="三-视图作用"><a href="#三-视图作用" class="headerlink" title="三 视图作用"></a>三 视图作用</h1><ol><li>方便操作，特别是查询操作，减少复杂的SQL语句<ul><li>将一条复杂的查询语句使用视图进行保存: 以后可以直接对视图进行操作</li></ul></li><li>数据安全<ul><li>视图操作是主要针对查询的, 如果对视图结构进行处理(删除), 不会影响基表数据(相对安全).</li><li>可以对外提供有用的数据, 但是隐藏关键(无用)的数据</li><li>数据库授权命令不能限定到特定行和特定列，但是通过合理创建视图，可以把权限限定到行列级别</li></ul></li><li>权限控制<ul><li>不希望用户访问表中某些含敏感信息的列,可以通过view开放某几个列</li></ul></li><li>数据过多时，分表用</li></ol><h1 id="四-视图操作"><a href="#四-视图操作" class="headerlink" title="四 视图操作"></a>四 视图操作</h1><h2 id="4-1-创建视图"><a href="#4-1-创建视图" class="headerlink" title="4.1 创建视图"></a>4.1 创建视图</h2><ul><li><code>create view 视图名 as select语句</code></li></ul><h2 id="4-2-查看视图"><a href="#4-2-查看视图" class="headerlink" title="4.2 查看视图"></a>4.2 查看视图</h2><ul><li><code>show create table/view 视图名</code></li><li><code>show tables [like]/desc 视图名</code><ul><li>视图是一张虚拟表，表的所有查看方式，视图都能用，且视图比表多一个关键字view</li></ul></li></ul><h2 id="4-3-修改视图"><a href="#4-3-修改视图" class="headerlink" title="4.3 修改视图"></a>4.3 修改视图</h2><ul><li><code>alter view 视图名 as 新的select语句</code><ul><li>视图本身不可修改，但视图来源可以修改</li></ul></li></ul><h2 id="4-4-删除视图"><a href="#4-4-删除视图" class="headerlink" title="4.4 删除视图"></a>4.4 删除视图</h2><ul><li><code>drop view 视图名</code></li></ul><h1 id="五-视图算法-algorithm"><a href="#五-视图算法-algorithm" class="headerlink" title="五 视图算法(algorithm)"></a>五 视图算法(algorithm)</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ul><li>系统对视图以及外部查询视图的Select语句的一种解析方式</li><li><code>create algorithm=xxx view 视图名 as select 语句</code><ul><li>是对标准sql的mysql的扩展</li></ul></li></ul><h2 id="5-2-分类"><a href="#5-2-分类" class="headerlink" title="5.2 分类"></a>5.2 分类</h2><ul><li><code>undefined</code><ul><li>未定义(默认的), 这不是一种实际使用算法, 是一种推卸责任的算法: 告诉系统,视图没有定义算法, 系统自己看着办<ul><li>未定义由系统定义，它倾向于MERGE而不是TEMPTABLE</li><li>因为MERGE通常更有效，而且如果使用了临时表，视图是不可更新的。</li></ul></li></ul></li><li><code>temptable</code><ul><li>临时表算法: 系统应该先执行视图的select语句,后执行外部查询语句<ul><li>视图的结果将被置于临时表中，然后使用它执行语句</li><li>适合复杂查询形成的view</li></ul></li></ul></li><li><code>merge</code><ul><li>合并算法: 系统应该先将视图对应的select语句与外部查询视图的select语句进行合并,然后执行(效率高: 常态)<ul><li>将查询视图的语句与视图定义语句合并起来<ul><li>查询视图的语句+视图定义语句=查询物理表的语句</li></ul></li><li>合并查询语句，不会创建临时表</li><li>适合简单查询形成的view</li></ul></li></ul></li></ul><h2 id="5-3-算法选择"><a href="#5-3-算法选择" class="headerlink" title="5.3 算法选择"></a>5.3 算法选择</h2><ul><li>如果视图的select语句中会包含一个查询子句(五子句), 而且很有可能顺序比外部的查询语句要靠后, 一定要使用算法temptable,其他情况可以不用指定(默认即可)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;view可以看作是一张虚拟表，是表通过某种运算得到的一个投影。&lt;/li&gt;
&lt;li&gt;视图中并没有真正存储数据。&lt;/
      
    
    </summary>
    
    
      <category term="DB" scheme="https://anyeansan.github.io/categories/DB/"/>
    
      <category term="MySql" scheme="https://anyeansan.github.io/categories/DB/MySql/"/>
    
    
  </entry>
  
  <entry>
    <title>MySql 日志</title>
    <link href="https://anyeansan.github.io/2020/03/30/MySql-%E6%97%A5%E5%BF%97/"/>
    <id>https://anyeansan.github.io/2020/03/30/MySql-%E6%97%A5%E5%BF%97/</id>
    <published>2020-03-30T13:39:18.000Z</published>
    <updated>2020-03-30T13:41:38.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-日志分类"><a href="#一-日志分类" class="headerlink" title="一 日志分类"></a>一 日志分类</h1><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>Error log</code></td><td>错误日志</td></tr><tr><td><code>Binary log</code></td><td>二进制日志</td></tr><tr><td><code>Slow query log</code></td><td>慢查询日志</td></tr><tr><td><code>General query log</code></td><td>常规日志</td></tr></tbody></table><h1 id="二-错误日志"><a href="#二-错误日志" class="headerlink" title="二 错误日志"></a>二 错误日志</h1><ol><li>默认开启</li><li>默认存储位置 <code>datadir/hostname.err</code></li><li><code>select @@log_error</code><ul><li>查看错误日志位置</li></ul></li><li>手动配置 <code>/etc/my.cnf</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log_error=路径</span><br></pre></td></tr></table></figure></li></ol><h1 id="三-二进制日志"><a href="#三-二进制日志" class="headerlink" title="三 二进制日志"></a>三 二进制日志</h1><h2 id="3-1-作用"><a href="#3-1-作用" class="headerlink" title="3.1 作用"></a>3.1 作用</h2><ol><li>主从环境必须依赖二进制日志</li><li>备份恢复必须依赖二进制日志</li></ol><h2 id="3-2-配置"><a href="#3-2-配置" class="headerlink" title="3.2 配置"></a>3.2 配置</h2><ol><li>默认没有开启</li><li>手动配置 <code>/etc/my.cnf</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">1 server_id= </span><br><span class="line"># 服务ID号 0 ~ 65535</span><br><span class="line">2 log_bin=1</span><br><span class="line"># 开启二进制日志</span><br><span class="line">3 log_bin_basename=/目录/二进制日志文件名前缀</span><br><span class="line"># 设置存储目录及文件前缀</span><br><span class="line">4 log_bin=/目录/二进制日志文件名前缀</span><br><span class="line"># 等同于 2,3两步</span><br><span class="line">5 binlog_format=row</span><br><span class="line"># 二进制日志格式，5.7 默认配置，可以省略</span><br><span class="line">6 sync_binlog=1</span><br><span class="line"># 每次提交都立即刷写binlog到磁盘</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-3-二进制日志记录内容"><a href="#3-3-二进制日志记录内容" class="headerlink" title="3.3 二进制日志记录内容"></a>3.3 二进制日志记录内容</h2><h3 id="1-内容"><a href="#1-内容" class="headerlink" title="1 内容"></a>1 内容</h3><ul><li>记录了数据库所有变更类的操作日志<ol><li>DDL：原封不动的记录当前 DDL（statement 语句方式），即原样记录语句</li><li>DCL：原封不动的记录当前 DCL（statement 语句方式）</li><li>DML：只记录已经提交的事务 DML</li></ol></li></ul><h3 id="2-DML-记录模式"><a href="#2-DML-记录模式" class="headerlink" title="2 DML 记录模式"></a>2 DML 记录模式</h3><ol><li><code>statment</code><ul><li>SBR（statement based replication）模式</li><li>语句模式，原封不动的记录当前DML</li><li>可读性较高，日志量少，但是不够严谨</li></ul></li><li><code>row</code><ul><li>RBR（ROW based replication）模式</li><li>记录数据行的变化（用户看不懂，需要工具分析）</li><li>可读性很低，日志量大，足够严谨</li></ul></li><li><code>mixed</code><ul><li>MBR（mixed based replication）模式 </li><li>以上两种模式的混合</li></ul></li></ol><h2 id="3-4-二进制日记记录单元-event"><a href="#3-4-二进制日记记录单元-event" class="headerlink" title="3.4 二进制日记记录单元 event"></a>3.4 二进制日记记录单元 event</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>event 是二进制日志的最小记录单元</li><li>DDL DCL<ul><li>一个语句就是一个 event</li></ul></li><li>DML ：只记录已提交的事务<ol><li>begin 是一个 event</li><li>DML 语句的 event</li><li>commit 是一个 event</li></ol></li></ol><h3 id="2-event-组成"><a href="#2-event-组成" class="headerlink" title="2 event 组成"></a>2 event 组成</h3><ol><li>事件的开始标识：<code>position</code> 号</li><li>事件内容</li><li>事件的结束标识：<code>end_log_position</code> 号</li></ol><h2 id="3-5-二进制日志-操作"><a href="#3-5-二进制日志-操作" class="headerlink" title="3.5 二进制日志 操作"></a>3.5 二进制日志 操作</h2><h3 id="1-查看信息"><a href="#1-查看信息" class="headerlink" title="1 查看信息"></a>1 查看信息</h3><ol><li><code>show variables like &#39;%log_bin%&#39;</code><ul><li>查看二进制日志路径</li></ul></li><li><code>show binary logs</code><ul><li>查看所有二进制日志</li></ul></li><li><code>show master status</code><ul><li>查看当前使用的二进制日志</li></ul></li><li><code>show binlog events in &#39;log_name&#39; [from pos] [limit]</code><ul><li>查看二进制日志 event 信息</li></ul></li></ol><h3 id="2-查看内容-mysqlbinlog"><a href="#2-查看内容-mysqlbinlog" class="headerlink" title="2 查看内容 mysqlbinlog"></a>2 查看内容 mysqlbinlog</h3><ul><li><code>mysqlbinlog [OPTION] 日志路径</code><ul><li><code>--base64-output=decode-rows</code><ul><li>以指定格式输出</li></ul></li><li><code>-vvv</code><ul><li>更详细</li></ul></li><li><code>--start-position</code><ul><li>开始位置</li></ul></li><li><code>--stop-position</code><ul><li>结束位置</li></ul></li><li><code>-d db_name</code><ul><li>只查看指定库的日志</li></ul></li></ul></li></ul><h3 id="3-恢复"><a href="#3-恢复" class="headerlink" title="3 恢复"></a>3 恢复</h3><ol><li><code>mysqlbinlog --start-position= --stop--position= &gt;/tmp/log.sql</code><ul><li>将指定位置的二进制日志内容截取出来输出到一个文件，其实就是sql脚本，执行即可</li></ul></li><li><code>set sql_log_bin=0</code><ul><li>临时关闭二进制日志，因为恢复时也会产生二进制日志，没有必要</li></ul></li><li><code>source /tmp/log.sql</code></li><li><code>set sql_log_bin=1</code></li></ol><h2 id="3-6-GTID-模式管理二进制日志"><a href="#3-6-GTID-模式管理二进制日志" class="headerlink" title="3.6 GTID 模式管理二进制日志"></a>3.6 GTID 模式管理二进制日志</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>GTID <code>Global Transaction ID</code></li><li>对二进制日志中每一个事务，自动生成一个 GTID 号<ol><li>DDL DCL<ul><li>一个 event 就是一个事务，就有一个 GTID</li></ul></li><li>DML<ul><li>一个事务（从 begin 到 commit）一个 GTID</li></ul></li></ol></li><li>GTID 幂等性<ul><li>使用有 GTID 的二进制日志做恢复时，会检查当前系统是否有相同的 GTID，若有则跳过不再执行。</li><li>会影响恢复和主从复制</li></ul></li></ol><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2 配置"></a>2 配置</h3><ol><li>默认未开启</li><li><code>/etc/my.cnf</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">gtid-mode=on</span><br><span class="line">enforce-gtid-consistency=true</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-GTID-组成"><a href="#3-GTID-组成" class="headerlink" title="3 GTID 组成"></a>3 GTID 组成</h3><ul><li><code>server_uuid:transaction_id</code><ul><li><code>server_uuid</code><ul><li>启动 mysql 自动生成，存储在 <code>datadir/auto.cnf</code></li></ul></li><li><code>transaction_id</code><ul><li>从 1 开始，自增长</li></ul></li></ul></li></ul><h3 id="4-查看有-GTID-的日志内容"><a href="#4-查看有-GTID-的日志内容" class="headerlink" title="4 查看有 GTID 的日志内容"></a>4 查看有 GTID 的日志内容</h3><ul><li><code>mysqlbinlog [OPTION] 日志路径</code><ul><li><code>OPTION</code><ul><li><code>--incude-gtids</code><ul><li>包含指定 gtid，多个逗号隔开，连续可以 <code>server_uuid:1-8</code></li></ul></li><li><code>--exclude-gtids</code><ul><li>排除指定 gtid</li></ul></li><li><code>--skip-gtids</code><ul><li>由于 gtid 的幂等性，导出的 sql 执行时会报错，因为已经存在相同 gtid</li><li>此选项表示：导出时，忽略原有的 GTID 信息，恢复时当作新事务对待</li></ul></li></ul></li></ul></li></ul><h3 id="5-基于-GTID-的恢复"><a href="#5-基于-GTID-的恢复" class="headerlink" title="5  基于 GTID 的恢复"></a>5  基于 GTID 的恢复</h3><ol><li><code>mysqlbinlog --skip-gtids --include-gtids= 日志路径&gt;/tmp/log.sql</code></li><li><code>set sql_log_bin=0</code></li><li><code>source /tmp/log.sql</code></li><li><code>set sql_log_bin=1</code></li></ol><h2 id="3-7-二进制日志清理"><a href="#3-7-二进制日志清理" class="headerlink" title="3.7 二进制日志清理"></a>3.7 二进制日志清理</h2><h3 id="1-自动清理"><a href="#1-自动清理" class="headerlink" title="1 自动清理"></a>1 自动清理</h3><ul><li><code>expire_logs_days</code><ul><li>二进制日志过期天数，<code>0</code> 表示永不过期</li><li>建议至少保留两个全备周期 +1</li></ul></li></ul><h3 id="2-手动清理"><a href="#2-手动清理" class="headerlink" title="2 手动清理"></a>2 手动清理</h3><ol><li><code>purge binary logs to &#39;log_name&#39;</code><ul><li>删除指定日志之前的日志</li></ul></li><li><code>purge binary logs before &#39;time&#39;</code><ul><li>删除指定日期之前的日志</li></ul></li></ol><h2 id="3-8-日志滚动"><a href="#3-8-日志滚动" class="headerlink" title="3.8 日志滚动"></a>3.8 日志滚动</h2><ol><li><code>flush logs</code></li><li>重启 mysql 会自动滚动一个新的</li><li>日志文件达到 <code>max_binlog_size</code></li></ol><h1 id="四-慢查询日志"><a href="#四-慢查询日志" class="headerlink" title="四 慢查询日志"></a>四 慢查询日志</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ul><li>记录运行较慢的 SQL语句，优化常用</li></ul><h2 id="4-2-配置"><a href="#4-2-配置" class="headerlink" title="4.2 配置"></a>4.2 配置</h2><ol><li>默认未开启</li><li><code>/etc/my.cnf</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">1 slow_query_log=1 </span><br><span class="line"># 开启 </span><br><span class="line">2 slow_query_log_file=/目录/文件</span><br><span class="line"># 日志文件路径</span><br><span class="line">3 long_query_time=0.1</span><br><span class="line"># 设置慢查询时间，超过此时间就算慢，默认 10.000000 10秒，小数位表示粒度</span><br><span class="line">4 log_queries_not_using_indexes</span><br><span class="line"># 没走索引的语句也记录</span><br></pre></td></tr></table></figure></li></ol><h2 id="4-3-分析"><a href="#4-3-分析" class="headerlink" title="4.3 分析"></a>4.3 分析</h2><ul><li><code>mysqldumpslow -s c -t N 日志路径</code><ul><li><code>-s c</code><ul><li>sort，按次数排序</li></ul></li><li><code>-t N</code><ul><li>top，取前多少个</li></ul></li></ul></li></ul><h2 id="4-4-相关参数"><a href="#4-4-相关参数" class="headerlink" title="4.4 相关参数"></a>4.4 相关参数</h2><ol><li><code>slow_query_log</code></li><li><code>long_query_time</code></li><li><code>log_throttle_queries_not_using_indexes</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-日志分类&quot;&gt;&lt;a href=&quot;#一-日志分类&quot; class=&quot;headerlink&quot; title=&quot;一 日志分类&quot;&gt;&lt;/a&gt;一 日志分类&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thea
      
    
    </summary>
    
    
      <category term="DB" scheme="https://anyeansan.github.io/categories/DB/"/>
    
      <category term="MySql" scheme="https://anyeansan.github.io/categories/DB/MySql/"/>
    
    
  </entry>
  
  <entry>
    <title>MySql 事务</title>
    <link href="https://anyeansan.github.io/2020/03/30/MySql-%E4%BA%8B%E5%8A%A1/"/>
    <id>https://anyeansan.github.io/2020/03/30/MySql-%E4%BA%8B%E5%8A%A1/</id>
    <published>2020-03-30T13:37:10.000Z</published>
    <updated>2020-03-30T13:39:01.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-ACID-特性"><a href="#一-ACID-特性" class="headerlink" title="一 ACID 特性"></a>一 ACID 特性</h1><p>特性||说明<br>-|-<br><code>原子性 Atomicity</code>|一个事务是一个不可分割的单元，事务中的操作要么都成功，要么都取消<br><code>一致性 Consistency</code>|事务的执行不能破坏数据库数据的完整性和一致性<br><code>隔离性 Isolation</code>|事务之间是互不干扰的<br><code>持久性 Durability</code>|一个事务一旦被提交，它对数据库中数据的改变就是永久性的</p><h1 id="二-事务的生命周期"><a href="#二-事务的生命周期" class="headerlink" title="二 事务的生命周期"></a>二 事务的生命周期</h1><h2 id="2-1-标准生命周期"><a href="#2-1-标准生命周期" class="headerlink" title="2.1 标准生命周期"></a>2.1 标准生命周期</h2><ol><li><code>begin</code></li><li><code>DML（insert update delete）</code></li><li><code>commit | rollback</code></li></ol><h2 id="2-2-autocommit"><a href="#2-2-autocommit" class="headerlink" title="2.2 autocommit"></a>2.2 autocommit</h2><ol><li>默认 <code>atutocommit = 1</code> 即开启自动提交</li><li>执行 <code>DML</code> 时会自动开启事务并提交</li><li>关闭自动提交<ol><li><code>set autocommit = 0</code><ul><li>会话级别</li></ul></li><li><code>set global autocommit = 0</code><ul><li>全局级别，影响所有会话，重启失效</li></ul></li><li><code>vim /etc/my.cnf</code> 中添加 <code>autocommit=0</code><ul><li>永久生效</li></ul></li></ol></li></ol><h2 id="2-3-隐式提交"><a href="#2-3-隐式提交" class="headerlink" title="2.3 隐式提交"></a>2.3 隐式提交</h2><ul><li>开启事务后，在事务中执行一些语句会触发隐式提交（应避免）<ol><li>DDL（<code>alte</code> <code>create</code> <code>drop</code> <code>truncate</code>）</li><li>DCL（<code>grant</code> <code>revoke</code> <code>set password</code>）</li><li>锁（<code>lock tables</code> <code>unlock tables</code>）</li><li>…</li></ol></li></ul><h1 id="三-事务原理"><a href="#三-事务原理" class="headerlink" title="三 事务原理"></a>三 事务原理</h1><h2 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h2><ol><li><code>redo log</code><ul><li>保存在 <code>ib_logfile0~1</code> 默认50M，轮询使用</li><li><code>redo log buffer</code><ul><li>redo log 缓冲区</li></ul></li></ul></li><li><code>ibd</code><ul><li>存储数据行和索引</li><li><code>data bufer pool</code><ul><li>数据和索引的缓冲区</li></ul></li></ul></li><li><code>LSN</code><ul><li>日志序列号（<code>redo log</code> 及其缓冲区， <code>ibd</code> 及其缓冲区 都有LSN）</li><li>MySQL 每次启动都会比较 <code>ibd</code> 和 <code>redo log</code> 的 LSN，两者必须一致数据库才能正常启动</li></ul></li><li><code>WAL</code>（write ahead log）<ul><li>持久化的实现机制（日志优先于数据写入磁盘）</li></ul></li><li><code>脏页</code><ul><li>内存中发生了修改，没写入到磁盘之前，把内存页称之为脏页</li></ul></li><li><code>CKPT</code>（checkpoint）<ul><li>检查点,就是将脏页刷写到磁盘的动作</li></ul></li><li><code>TXID</code><ul><li>事务号，InnoDB会为每一个事务生成一个事务号，伴随着整个事务</li></ul></li></ol><h2 id="3-2-原理"><a href="#3-2-原理" class="headerlink" title="3.2 原理"></a>3.2 原理</h2><ol><li>开启事务后，DML 将 <code>ibd</code> 按照数据页（16kb）为单位读取到内存 <code>data bufer pool</code> 进行操作。</li><li><code>undo log</code> 会记录数据的原始状态以及事务 ID</li><li><code>redo log buff</code> 会记录内存数据页的变化、LSN 号以及事务ID</li><li>操作正常 <code>commit</code><ol><li>优先将 <code>redo log buff</code> 写入 <code>redo log</code>（WAL）</li><li>将内存数据的改变写入磁盘</li><li>如果 commit 之后出现意外（如断电，断开连接 …），再次重启时可以根据 <code>redo log</code> 进行同步（因为都有 LSN，类似于版本号，所以知道哪个是新版本）</li></ol></li><li>操作未正常完成（如断电，断开连接 rollback …）<ul><li>不写入 <code>redo log</code>，也不写入数据</li></ul></li></ol><h1 id="四-锁"><a href="#四-锁" class="headerlink" title="四 锁"></a>四 锁</h1><h2 id="4-1-悲观锁"><a href="#4-1-悲观锁" class="headerlink" title="4.1 悲观锁"></a>4.1 悲观锁</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>数据库提供实现</li><li>悲观的认为别人一定会修改我使用的数据，我就未为我使用的数据加锁，防止别人修改</li></ol><h3 id="2-锁粒度划分"><a href="#2-锁粒度划分" class="headerlink" title="2 锁粒度划分"></a>2 锁粒度划分</h3><ol><li>表锁<ul><li>开销小，加锁快；不会出现死锁；但锁粒度大，锁冲突概率高，并发度低</li></ul></li><li>行锁<ul><li>开销大，加锁慢；会出现死锁；锁定粒度小，锁冲突概率低，并发度高。</li></ul></li></ol><h3 id="3-锁机制划分"><a href="#3-锁机制划分" class="headerlink" title="3 锁机制划分"></a>3 锁机制划分</h3><ol><li>读锁/共享锁<ul><li>其他事务可以读，但不能写</li></ul></li><li>写锁/排他锁<ul><li>其他事务不能读取，也不能写</li></ul></li></ol><h2 id="4-2-乐观锁"><a href="#4-2-乐观锁" class="headerlink" title="4.2 乐观锁"></a>4.2 乐观锁</h2><ol><li>需要自己实现</li><li>乐观的认为数据一般是不会造成冲突的。只有在提交数据的时候，才会对数据的冲突进行检测</li><li>类似与 版本控制（git / svn），会有一个版本号，在提交时会对比版本号，如果冲突则不能提交。</li><li>例：<ul><li><code>id=1 money=100 version=1</code>甲乙同时操作money-10</li><li>甲先提交<code>id=1 money=90 version=2</code>提交成功。</li><li>乙后提交<code>id=1 money=90 version=2</code>提交失败</li><li>乙需要从新查询，然后修改提交<code>id=1 money=80 version=3</code></li></ul></li></ol><h1 id="五-隔离级别"><a href="#五-隔离级别" class="headerlink" title="五 隔离级别"></a>五 隔离级别</h1><h2 id="5-1-问题"><a href="#5-1-问题" class="headerlink" title="5.1 问题"></a>5.1 问题</h2><h3 id="1-脏读"><a href="#1-脏读" class="headerlink" title="1 脏读"></a>1 脏读</h3><ul><li>在一个事务中读取到了另一个事务未提交的数据。</li><li><strong>例</strong><ol><li>我开启事务查看工资，老板开启事务发工资</li><li>本来是 1 万，老板多按了个 0 发了 10 万，老板没有提交事务，但我却看到发了 10 万，高兴坏了。</li><li>然后老板发现错了，回滚了，最后实际还是发了 1 万，我白高兴了，这肯定不合适。</li><li>在这个过程中我读到了老板未提交的数据，就是 脏读</li></ol></li></ul><h3 id="2-不可重复读"><a href="#2-不可重复读" class="headerlink" title="2 不可重复读"></a>2 不可重复读</h3><ul><li>在一个事务中读取到了另一个事务已提交的数据（update），导致在一个事务中多次读取结果不一样</li><li><strong>例</strong><ol><li>我开启事务查看卡里有多少钱，发现还有 1 万</li><li>此时我媳妇开启事务从卡里转走了 1 万并提交了。</li><li>然后我想确认一下，又查了一遍，发现没钱了，我懵逼了。</li><li>如果此时媳妇又转回来 5000，我再查一遍，发现余额是 5000，那我一定觉得自己疯了</li><li>在这个过程中我读到了媳妇提交的更新数据，就是 不可重复读</li></ol></li></ul><h3 id="3-幻读"><a href="#3-幻读" class="headerlink" title="3 幻读"></a>3 幻读</h3><ul><li>在一个事务中读取到了另一个事务已提交的数据（insert），导致在一个事务中多次读取结果不一样</li><li><strong>例</strong><ol><li>我开启事务查看班级里多少人的成绩已经录入，发现录入了 24 条数据</li><li>此时老师开启事务又录入了一条</li><li>然后我打印出来发现有 25 条数据</li><li>在这个过程中我读到了 老师提交的插入数据，就是 幻读</li></ol></li></ul><h2 id="5-2-隔离级别分类"><a href="#5-2-隔离级别分类" class="headerlink" title="5.2 隔离级别分类"></a>5.2 隔离级别分类</h2><table><thead><tr><th>隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td><code>read uncommitted</code></td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td><code>read committed</code></td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td><code>repeatable read</code></td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td><code>serializable</code></td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr><tr><td>* <code>repeatable read</code></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td>* 是MySQl 默认 隔离级别</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td>* 有可能出现幻读，可通过 <code>gap + next lock</code> 来防止幻读</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="5-3-设置隔离级别"><a href="#5-3-设置隔离级别" class="headerlink" title="5.3 设置隔离级别"></a>5.3 设置隔离级别</h2><ol><li><code>select @@tx_isolation</code><ul><li>查看隔离级别</li><li><code>repeatable read</code></li></ul></li><li><code>set transaction isolation lever 隔离级别</code><ul><li>设置隔离级别（会话级别）</li><li>必须在开启事务之前</li></ul></li><li><code>vim /etc/my.cnf</code> 添加 <code>transaction_isolation=隔离级别</code><ul><li>永久设置</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-ACID-特性&quot;&gt;&lt;a href=&quot;#一-ACID-特性&quot; class=&quot;headerlink&quot; title=&quot;一 ACID 特性&quot;&gt;&lt;/a&gt;一 ACID 特性&lt;/h1&gt;&lt;p&gt;特性||说明&lt;br&gt;-|-&lt;br&gt;&lt;code&gt;原子性 Atomicity&lt;/code
      
    
    </summary>
    
    
      <category term="DB" scheme="https://anyeansan.github.io/categories/DB/"/>
    
      <category term="MySql" scheme="https://anyeansan.github.io/categories/DB/MySql/"/>
    
    
  </entry>
  
  <entry>
    <title>MySql 索引</title>
    <link href="https://anyeansan.github.io/2020/03/30/MySql-%E7%B4%A2%E5%BC%95/"/>
    <id>https://anyeansan.github.io/2020/03/30/MySql-%E7%B4%A2%E5%BC%95/</id>
    <published>2020-03-30T13:34:48.000Z</published>
    <updated>2020-03-30T13:36:56.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol><li>系统根据某种算法，将已有的数据（或未来可能新增的数据）单独建立一个文件，此文件能够实现快速的匹配数据，并且能够快速的找到对应表中的记录</li><li>几乎所有的索引都是建立在字段之上</li><li>索引本身会产生索引文件(有时候有可能比数据文件还大)，会占用磁盘空间.</li><li>索引类似书或字典前边的目录，提升查询速度，但是增删改时，索引也要动态的维护，降低了效率。</li></ol><h1 id="二-作用"><a href="#二-作用" class="headerlink" title="二 作用"></a>二 作用</h1><ol><li>优化查询<ul><li>如果某个字段需要作为查询的条件经常使用，那么可以使用索引</li></ul></li><li>约束数据的有效性<ul><li>如果某个字段需要进行数据的有效性约束, 也可能使用索引（主键,唯一键 …）</li></ul></li></ol><h1 id="三-索引分类（算法）"><a href="#三-索引分类（算法）" class="headerlink" title="三 索引分类（算法）"></a>三 索引分类（算法）</h1><table><thead><tr><th>算法</th><th>说明</th></tr></thead><tbody><tr><td><code>B-tree</code></td><td>B 树索引</td></tr><tr><td><code>FullText</code></td><td>全文索引</td></tr><tr><td><code>Hash</code></td><td>哈希索引</td></tr><tr><td><code>GIS</code></td><td>地理位置索引</td></tr><tr><td><code>R-tree</code></td><td>R 树索引</td></tr></tbody></table><ul><li><code>B-tree</code><ol><li><code>B-tree</code></li><li><code>B+tree</code></li><li><code>B*tree</code><ul><li>Mysql 默认</li></ul></li></ol></li></ul><h1 id="四-索引分类（物理-功能）"><a href="#四-索引分类（物理-功能）" class="headerlink" title="四 索引分类（物理/功能）"></a>四 索引分类（物理/功能）</h1><h2 id="4-1-辅助索引-普通索引（secondary-index）"><a href="#4-1-辅助索引-普通索引（secondary-index）" class="headerlink" title="4.1 辅助索引 / 普通索引（secondary index）"></a>4.1 辅助索引 / 普通索引（secondary index）</h2><ol><li>辅助索引手动生成，基于表中的列（索引键）生成B树结构</li><li>提取列的所有索引键，进行排序</li><li>将排序后的索引键均匀的分布在叶节点中，且叶节点中生成索引键对应表数据的指针</li><li>根据叶节点生成枝节点和根节点，生成树结构。</li></ol><h2 id="4-2-聚集索引"><a href="#4-2-聚集索引" class="headerlink" title="4.2 聚集索引"></a>4.2 聚集索引</h2><ol><li>聚集索引由数据库自动生成</li><li>Mysql 自动选择主键列作为聚集索引列，没有主键则选择唯一键（如果都没有，会生成隐藏的）</li><li>Mysql 存储数据时，会按照聚集索引列值的顺序存储数据行（又称之为聚集索引组织表）</li><li>将排好序的数据行作为叶节点，进而生成树结构。</li><li>查询时<ol><li>根据辅助索引的B树，查找到辅助索引键</li><li>进而找到辅助索引键对应表数据的指针（即聚集索引键，通常为主键 ID）</li><li>根据聚集索引的B树，查找到聚集索引键</li><li>而聚集索引的叶节点其实就是表数据，所以就查找到了聚集索引键对应的表数据</li></ol></li></ol><h2 id="4-3-区别"><a href="#4-3-区别" class="headerlink" title="4.3 区别"></a>4.3 区别</h2><ol><li>表中任何一列都可以创建辅助索引，且可以有多个（不重名即可）</li><li>一张表聚集索引只能有一个，通常是主键列</li><li>辅助索引叶节点存储<ol><li>索引列的值（索引键）</li><li>聚集索引列的值（聚集索引键）</li></ol></li><li>聚集索引叶节点存储<ol><li>有序的整行数据</li></ol></li><li>mysql 的表数据存储的是聚集索引组织表</li></ol><h1 id="五-索引分类（逻辑）"><a href="#五-索引分类（逻辑）" class="headerlink" title="五 索引分类（逻辑）"></a>五 索引分类（逻辑）</h1><ol><li>主键索引 <code>primary key</code></li><li>唯一索引 <code>unique key</code></li><li>普通索引 <code>index / key</code><ol><li>单列索引</li><li>多列索引（联合索引）</li><li>前缀索引<ul><li>建索引时，可以只索引列的一部分内容</li></ul></li></ol></li><li>全文索引 <code>full text</code></li></ol><h1 id="六-索引操作"><a href="#六-索引操作" class="headerlink" title="六 索引操作"></a>六 索引操作</h1><h2 id="6-1-查"><a href="#6-1-查" class="headerlink" title="6.1 查"></a>6.1 查</h2><ol><li><code>desc 表名</code><ul><li><code>key</code> 列显示索引信息<ol><li><code>PRI</code> ：主键索引</li><li><code>UNI</code> ：唯一索引</li><li><code>MUL</code> ：普通索引</li></ol></li></ul></li><li><code>show index from 表名</code><ul><li>显示索引详细信息</li></ul></li></ol><h2 id="6-2-增"><a href="#6-2-增" class="headerlink" title="6.2 增"></a>6.2 增</h2><h3 id="1-普通索引"><a href="#1-普通索引" class="headerlink" title="1 普通索引"></a>1 普通索引</h3><ol><li><code>alter table 表名 add index 索引名(列1[(lenght)][,列2, ...])</code><ul><li>创建单列/双列/前缀 普通索引</li></ul></li><li><code>create index 索引名 on 表名(列1(lenght)][,列2, ...])</code></li></ol><h3 id="2-唯一索引"><a href="#2-唯一索引" class="headerlink" title="2 唯一索引"></a>2 唯一索引</h3><ol><li><code>alter table 表名 add unique index 索引名(列名)</code></li><li><code>create unique index 索引名 on 表名(列名)</code></li></ol><h2 id="6-3-删"><a href="#6-3-删" class="headerlink" title="6.3 删"></a>6.3 删</h2><ol><li><code>alter table 表名 drop index 索引名</code></li><li><code>drop index 索引名 on 表名</code></li></ol><h1 id="七-执行计划"><a href="#七-执行计划" class="headerlink" title="七 执行计划"></a>七 执行计划</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ol><li>SQL 层解析器会生成多个执行计划，优化器会选择最优的执行计划</li><li>执行计划分析<ul><li>就是在执行前获取这个最优执行计划，查看其计划信息，可以有效的防止性能较差的语句带来的性能问题</li></ul></li></ol><h2 id="7-2-获取执行计划"><a href="#7-2-获取执行计划" class="headerlink" title="7.2 获取执行计划"></a>7.2 获取执行计划</h2><ol><li><code>desc sql语句</code></li><li><code>explain sql语句</code></li></ol><h2 id="7-3-执行计划分析"><a href="#7-3-执行计划分析" class="headerlink" title="7.3 执行计划分析"></a>7.3 执行计划分析</h2><ol><li><code>table</code><ul><li>查询所操作的表</li></ul></li><li><code>type</code><ol><li>全表扫描：<code>all</code><ul><li>不走索引<ol><li>没有查询条件，或者查询条件列无索引</li><li>查询结构集是原表中的大部分数据，一般25%以上</li><li><code>! not</code><ul><li>普通索引列</li></ul></li><li><code>like %xxx</code></li><li>联合索引有时只走部分索引</li></ol></li></ul></li><li>索引扫描（性能依次变好）<ol><li><code>index</code><ul><li>全索引扫描<ul><li>无条件查询索引列 <code>select id from t</code></li></ul></li></ul></li><li><code>range</code><ul><li>索引范围扫描<ol><li><code>&gt; &gt;= &lt; &lt;= between and or in()</code></li><li><code>like xxx%</code></li><li><code>! not</code><ul><li>主键索引或唯一索引列</li></ul></li></ol></li></ul></li><li><code>ref</code><ul><li>普通索引列的等值查询</li></ul></li><li><code>eq_ref</code><ul><li>在多表连接时，子表（被连接表）使用主键列或者唯一列作为连接条件</li></ul></li><li><code>consist(system)</code><ul><li>主键索引或唯一索引列的等值查询</li></ul></li><li><code>null</code></li></ol></li></ol></li><li><code>possible_key</code><ul><li>可能会用到的索引</li></ul></li><li><code>key</code><ul><li>真正使用的索引</li></ul></li><li><code>key_len</code><ul><li>索引最大预留长度</li></ul></li><li><code>extra</code><ul><li><code>using filesort</code><ul><li>说明查询中有关排序的条件列没有合理的应用索引，因为索引本身已经是有序的</li></ul></li></ul></li></ol><h2 id="7-4-联合索引"><a href="#7-4-联合索引" class="headerlink" title="7.4 联合索引"></a>7.4 联合索引</h2><h3 id="1-联合索引说明"><a href="#1-联合索引说明" class="headerlink" title="1 联合索引说明"></a>1 联合索引说明</h3><ul><li>优化器会自动对查询条件按照索引创建时的顺序排序<ol><li>最终使用的索引列是排序后连续的等值比较查询</li><li>也就是说碰到不连续的或者非等值比较查询（&gt; &gt;= &lt; &lt;= like …）就会停止</li></ol></li><li>例：创建联合索引 <code>inx_haha(a,b,c,d)</code><ol><li>查询条件是 <code>b= c= a= d=</code>，排序后 <code>a= b= c= d=</code>，最终使用的索引列 <code>abcd</code></li><li>查询条件是 <code>b= a= d=</code>，排序后 <code>a= b= d=</code>，最终使用的索引列 <code>ab</code></li><li>查询条件是 <code>c= a= d=</code>，排序后 <code>a= c= d=</code>，最终使用的索引列 <code>a</code></li><li>查询条件是 <code>b&gt; a= c= d=</code>，排序后 <code>a= b&gt; c= d=</code>，最终使用的索引列 <code>ab</code></li></ol></li></ul><h3 id="2-联合索引优化"><a href="#2-联合索引优化" class="headerlink" title="2 联合索引优化"></a>2 联合索引优化</h3><ol><li>创建联合索引时唯一键多的列放在最左侧</li><li>创建联合索引时等值比较的列放在最左侧</li><li>如果查询中出现多种子句（where group by …），要按照子句的执行顺序建立索引</li></ol><h2 id="7-5-索引应用规范"><a href="#7-5-索引应用规范" class="headerlink" title="7.5 索引应用规范"></a>7.5 索引应用规范</h2><ol><li>建表必须有主键，一般是个无关列，自增值</li><li>经常需要where 、ORDER BY、GROUP BY,join on等操作的列建立索引，</li><li>值长度较长的列，建议使用前缀索引</li><li>索引不是越多越好，不要创建无用索引，不常使用的索引要清理</li><li>索引维护避开业务繁忙期</li><li>小表不建索引</li><li>联合索引优化</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;系统根据某种算法，将已有的数据（或未来可能新增的数据）单独建立一个文件，此文件能够实现快速的匹配数据，并且能够快
      
    
    </summary>
    
    
      <category term="DB" scheme="https://anyeansan.github.io/categories/DB/"/>
    
      <category term="MySql" scheme="https://anyeansan.github.io/categories/DB/MySql/"/>
    
    
  </entry>
  
  <entry>
    <title>MySql 元数据和语法</title>
    <link href="https://anyeansan.github.io/2020/03/30/MySql-%E5%85%83%E6%95%B0%E6%8D%AE%E5%92%8C%E8%AF%AD%E6%B3%95/"/>
    <id>https://anyeansan.github.io/2020/03/30/MySql-%E5%85%83%E6%95%B0%E6%8D%AE%E5%92%8C%E8%AF%AD%E6%B3%95/</id>
    <published>2020-03-30T13:32:42.000Z</published>
    <updated>2020-03-30T13:33:53.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol><li>元数据可以简单理解为描述数据的数据，除了存储在数据库中的数据外，大多可以理解为元数据</li><li>元数据存储在“基表”中，不能直接访问<ol><li><code>infomation_schema</code> 表中保存了大量元数据查询的视图</li><li><code>show</code> 命令是封装好的，提供元数据查询的基础功能</li></ol></li></ol><h1 id="二-information-schema"><a href="#二-information-schema" class="headerlink" title="二 information_schema"></a>二 information_schema</h1><h2 id="2-1-schemata"><a href="#2-1-schemata" class="headerlink" title="2.1 schemata"></a>2.1 schemata</h2><ol><li>存储当前 mysql 实例中所有数据库的信息。</li><li><code>show databases</code> 命令从这个表获取数据</li></ol><h2 id="2-2-tables"><a href="#2-2-tables" class="headerlink" title="2.2 tables"></a>2.2 tables</h2><ol><li>存储数据库中的表信息（包括视图），包括表属于哪个数据库，表的类型、存储引擎、创建时间等信息。</li><li><code>show tables [from db_name]</code> 命令从这个表获取结果</li></ol><table><thead><tr><th>列</th><th>说明</th></tr></thead><tbody><tr><td><code>table_schema</code></td><td>表所在库名</td></tr><tr><td><code>table_name</code></td><td>表名</td></tr><tr><td><code>engine</code></td><td>存储引擎</td></tr><tr><td><code>table_rows</code></td><td>总行数</td></tr><tr><td><code>avg_row_length</code></td><td>行平均长度</td></tr><tr><td><code>index_length</code></td><td>索引长度</td></tr></tbody></table><ul><li><code>表大小 = avg_row_length * table_rows + index_length</code></li></ul><h2 id="2-3-columns"><a href="#2-3-columns" class="headerlink" title="2.3 columns"></a>2.3 columns</h2><ul><li>存储数据库中每张表的列信息，会记录这列是属于哪张表( <code>TABLE_NAME</code> )、以及哪个库( <code>TABLE_SCHEMA</code> )、这列的数据类型是什么、列的注释( <code>COLUMN_COMMENT</code> )等信息</li></ul><h2 id="2-4-statistics"><a href="#2-4-statistics" class="headerlink" title="2.4 statistics"></a>2.4 statistics</h2><ul><li>存储表索引信息</li></ul><h2 id="2-5-collations"><a href="#2-5-collations" class="headerlink" title="2.5 collations"></a>2.5 collations</h2><ul><li>存储了字符集和校对集对照信息</li></ul><h1 id="三-show"><a href="#三-show" class="headerlink" title="三 show"></a>三 show</h1><ol><li><code>show databases</code><ul><li>查看所有库名</li></ul></li><li><code>show tables [from db_name]</code><ul><li>查看库中所有表名</li></ul></li><li><code>show create database db_name</code><ul><li>查看建库语句</li></ul></li><li><code>show create table t_name</code><ul><li>查看建表语句</li></ul></li><li><code>show processlist</code><ul><li>查看数据库连接情况</li></ul></li><li><code>show charset</code><ul><li>查看支持的字符集</li></ul></li><li><code>show collation</code><ul><li>查看支持的校对集</li></ul></li><li><code>show engines</code><ul><li>查看支持的存储引擎</li></ul></li><li><code>show grants for user_name</code><ul><li>查看用户权限</li></ul></li><li><code>shwo variables [like pattern]</code><ul><li>查看变量信息</li></ul></li><li><code>show index from t_name</code><ul><li>查看表的索引信息</li></ul></li><li><code>show engine innodb statsu\G</code><ul><li>查看 innodb 引擎详细状态信息（横向）</li></ul></li><li><code>show status [like pattern]</code><ul><li>查看数据库状态信息</li></ul></li><li><code>show binary logs</code><ul><li>查看二进制日志的列表信息</li></ul></li><li><code>show binlog events in log_name</code><ul><li>查看二进制日志的事件信息</li></ul></li><li><code>show master status</code><ul><li>查看 mysql 当前使用的二进制日志信息</li></ul></li><li><code>show relaylog events in log_name</code><ul><li>查看中继日志的事件信息</li></ul></li></ol><h1 id="四-语法"><a href="#四-语法" class="headerlink" title="四 语法"></a>四 语法</h1><h2 id="4-1-运算符"><a href="#4-1-运算符" class="headerlink" title="4.1 运算符"></a>4.1 运算符</h2><h3 id="1-数学运算符"><a href="#1-数学运算符" class="headerlink" title="1 数学运算符"></a>1 数学运算符</h3><table><thead><tr><th align="center">运算符</th><th>说明</th></tr></thead><tbody><tr><td align="center"><code>+</code></td><td>加</td></tr><tr><td align="center"><code>-</code></td><td>减</td></tr><tr><td align="center"><code>*</code></td><td>乘</td></tr><tr><td align="center"><code>/</code></td><td>除</td></tr><tr><td align="center"><code>DIV</code></td><td>整除</td></tr><tr><td align="center"><code>% MOD</code></td><td>模</td></tr></tbody></table><h3 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2 比较运算符"></a>2 比较运算符</h3><table><thead><tr><th align="center">运算符</th><th>说明</th></tr></thead><tbody><tr><td align="center"><code>&gt;</code></td><td>大于</td></tr><tr><td align="center"><code>&gt;=</code></td><td>大于等于</td></tr><tr><td align="center"><code>&lt;</code></td><td>小于</td></tr><tr><td align="center"><code>&lt;=</code></td><td>小于等于</td></tr><tr><td align="center"><code>=</code></td><td>等于，<code>null = null</code> 返回 null</td></tr><tr><td align="center"><code>&lt;=&gt;</code></td><td>等于，<code>null = null</code> 返回 1</td></tr><tr><td align="center"><code>&lt;&gt; !=</code></td><td>不等于</td></tr></tbody></table><h3 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3 逻辑运算符"></a>3 逻辑运算符</h3><table><thead><tr><th align="center">运算符</th><th>说明</th></tr></thead><tbody><tr><td align="center"><code>and &amp;&amp;</code></td><td>逻辑与</td></tr><tr><td align="center"><code>or &#124;&#124;</code></td><td>逻辑或</td></tr><tr><td align="center"><code>not !</code></td><td>逻辑非</td></tr><tr><td align="center"><code>xor</code></td><td>逻辑异或</td></tr></tbody></table><h2 id="4-2-变量"><a href="#4-2-变量" class="headerlink" title="4.2 变量"></a>4.2 变量</h2><h3 id="1-系统变量"><a href="#1-系统变量" class="headerlink" title="1 系统变量"></a>1 系统变量</h3><h4 id="1-查看系统变量"><a href="#1-查看系统变量" class="headerlink" title="1 查看系统变量"></a>1 查看系统变量</h4><ol><li><code>show [session | global] variables [like pattern]</code><ul><li>查看变量信息</li></ul></li><li><code>select @@变量名</code><ul><li>查看具体变量</li></ul></li></ol><h4 id="2-修改系统变量"><a href="#2-修改系统变量" class="headerlink" title="2 修改系统变量"></a>2 修改系统变量</h4><ol><li><code>Set @@session.变量名 = 值</code><ul><li>会话级别</li></ul></li><li><code>Set @@global.变量名 = 值</code><ul><li>全局级别（仅影响新会话，重启失效）</li></ul></li></ol><h3 id="2-自定义变量"><a href="#2-自定义变量" class="headerlink" title="2 自定义变量"></a>2 自定义变量</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h4><ol><li>为了区分系统变量, 规定用户自定义变量必须使用一个 <code>@</code> 符号</li><li>所有自定义的变量都是会话级别</li><li>所有自定义变量不区分数据库(用户级别)</li></ol><h4 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2 作用域"></a>2 作用域</h4><ol><li>全局变量<ol><li><code>set @变量名 = 值</code><ul><li>声明并赋值</li></ul></li><li><code>select @变量名 :=</code> <ul><li>使用 select 赋值，但必须使用 <code>:=</code></li></ul></li><li><code>select @变量名</code><ul><li>查看变量值</li></ul></li></ol></li><li>局部变量<ol><li><code>declare 变量名 类型 [default 默认值]</code><ul><li>局部变量需要先声明</li><li>赋值与查看与全局变量一致</li></ul></li></ol></li></ol><h2 id="4-3-函数"><a href="#4-3-函数" class="headerlink" title="4.3 函数"></a>4.3 函数</h2><h3 id="1-信息函数"><a href="#1-信息函数" class="headerlink" title="1 信息函数"></a>1 信息函数</h3><ol><li><code>user()</code><ul><li>返回当前用户及所在主机</li></ul></li><li><code>database()</code><ul><li>返回当前数据库名</li></ul></li><li><code>version()</code><ul><li>返回数据库的版本号</li></ul></li><li><code>connection_id()</code><ul><li>连接id</li></ul></li><li><code>last_insert_id()</code><ul><li>最后插入记录的id</li></ul></li></ol><h3 id="2-数字函数"><a href="#2-数字函数" class="headerlink" title="2 数字函数"></a>2 数字函数</h3><ol><li><code>abs(X)</code><ul><li>绝对值</li></ul></li><li><code>ceil(X)</code><ul><li>向上取整</li></ul></li><li><code>floor(X)</code><ul><li>向下取整</li></ul></li><li><code>round(X[, D])</code><ul><li>四舍五入</li><li><code>D</code><ul><li>小数位数</li></ul></li></ul></li><li><code>truncate(X, D)</code><ul><li>数字截取</li><li><code>D</code><ul><li>小数位数</li></ul></li></ul></li><li><code>conv(X, from_base, to_base)</code><ul><li>将x从进制from_base转为进制to_base的字符串。</li><li><code>X</code><ul><li>可以数字或数字的字符串</li></ul></li></ul></li><li><code>mod(N, M)</code><ul><li>等价于 <code>N % M</code> 或者 <code>N MOD M</code></li></ul></li></ol><h3 id="3-字符串函数"><a href="#3-字符串函数" class="headerlink" title="3 字符串函数"></a>3 字符串函数</h3><ol><li><code>concat(str1, str2, ...)</code><ol><li>将一个或多个参数连接为字符串</li><li>参数为数字会被转成字符串</li><li>如果有一个参数为null，则返回null</li></ol></li><li><code>concat_ws(separator, str1, str2, ...)</code><ul><li>使用指定分隔符将一个或多个参数连接为字符串</li></ul></li><li><code>format(X, D)</code><ul><li>将一个数字X格式化为类似<code>#,###,###.##</code>形式的字符串，小数位数由D指定</li></ul></li><li><code>length(str)</code><ul><li>返回字符串长度</li></ul></li><li><code>lower(str)</code><ul><li>转小写</li></ul></li><li><code>upper(str)</code><ul><li>转大写</li></ul></li><li><code>trim([{both | leading | trailing}] [remstr from] str)</code><ul><li>去除str两端空格</li><li><code>both|leading|trailing</code><ul><li>默认为both，可指定左右</li></ul></li><li><code>remstr</code><ul><li>默认空格，可以指定去除字符</li></ul></li></ul></li><li><code>ltrim(str)</code><ul><li>去除str左端空格</li></ul></li><li><code>rtrim(str)</code><ul><li>去除str右端空格</li></ul></li><li><code>reverse(str)</code><ul><li>反转str</li></ul></li><li><code>left(str, len)</code><ul><li>返回str从左开始len个字符的字符串。</li></ul></li><li><code>right(str, len)</code><ul><li>返回str从右开始len个字符的字符串。</li></ul></li><li><code>substring(str, [from] pos, [[for] len])</code><ul><li>返回从str位置pos开始的len个字符的字符串</li><li><code>pos</code><ul><li>从1开始，可以为负</li></ul></li><li><code>len</code><ul><li>若省略，则默认到字符串结尾</li><li>若len &lt; 1 则返回空字符串。</li></ul></li><li><code>substr()</code> 等价于 <code>substring()</code></li></ul></li><li><code>locate(substr, str[, pos])</code><ul><li>返回子串substr在str中第一次出现的位置，没有则返回 0</li><li><code>pos</code><ul><li>指定开始匹配位置</li><li>默认从1开始，及字符串开头</li></ul></li></ul></li><li><code>instr(str, substr)</code><ul><li>返回子串substr在str中第一次出现的位置，没有则返回0</li><li>等价于 <code>locate(substr, str)</code></li></ul></li><li><code>insert(str, pos, len, newstr)</code><ul><li>将str中从位置pos开始的len个字符替换为newstr</li></ul></li><li><code>replace(str, from_str, to_str)</code><ul><li>将str中的from_str替换为to_str</li></ul></li><li><code>strcmp(expr1,expr2)</code><ul><li>比较两个字符串<ol><li><code>expr1 = expr2</code>，返回 0</li><li><code>expr1 &lt; expr2</code>，返回 -1</li><li><code>expr1 &gt; expr2</code> ，返回 1</li></ol></li></ul></li><li><code>repeat(str, count)</code><ul><li>返回str重复count次组成的字符串</li></ul></li><li><code>isnull(expr)</code><ul><li>判断表达式是否为空</li></ul></li></ol><h3 id="4-日期函数"><a href="#4-日期函数" class="headerlink" title="4 日期函数"></a>4 日期函数</h3><ol><li><code>now()</code><ul><li>返回当前日期和时间。<code>yyyy-MM--dd HH:mm:ss</code></li></ul></li><li><code>curdate()</code><ul><li>返回当前日期 <code>yyyy-MM-dd</code></li></ul></li><li><code>curtime()</code><ul><li>返回当前时间 <code>HH:mm:ss</code></li></ul></li><li><code>dayofyear(date)</code><ul><li>返回指定日期是当年的第几天</li><li><code>date</code> 格式为 <code>yyyy-mm-dd</code></li></ul></li><li><code>dayofmonth(date)</code><ul><li>返回指定日期是当月的第几天</li></ul></li><li><code>dayofweek(date)</code><ul><li>返回指定日期是当周的第几天（周日是第一天）</li></ul></li><li><code>datediff(expr1, expr2)</code><ul><li>返回<code>expr1 - expr2</code> 的日期差值</li></ul></li><li><code>date_format(date, format)</code><ul><li>日期格式化</li></ul></li><li><code>date_add(date, INTERVAL expr unit)</code><ul><li>给日期加上指定值</li><li><code>unit</code><ul><li>指定日期项，如<code>day year day_hour day_second ...</code></li></ul></li></ul></li><li><code>date_sub(date, INTERVAL expr unit)</code><ul><li>给日期减去指定值</li></ul></li></ol><h3 id="5-加密函数"><a href="#5-加密函数" class="headerlink" title="5 加密函数"></a>5 加密函数</h3><ol><li><code>md5(str)</code><ul><li>md5加密</li></ul></li></ol><h3 id="6-JSON-函数"><a href="#6-JSON-函数" class="headerlink" title="6 JSON 函数"></a>6 JSON 函数</h3><ol><li><code>json_array([val[, val ...]])</code><ul><li>返回由参数组成json数组</li></ul></li><li><code>json_object([key, val[, key, val ...]])</code><ul><li>返回由参数组成的json对象，奇数参数是key，偶数参数是value</li></ul></li><li><code>json_pretty(json_val)</code><ul><li>漂亮的打印json</li></ul></li><li><code>json_array_append(json_doc, path, val[, path, val ...])</code><ul><li>在json_doc指定位置上的值后追加值<ul><li>假如数组或对象指定位置上是一个数组，则在数组尾部追加<ul><li><code>[a, b]</code> append c <code>[a, b, c]</code></li></ul></li><li>假如数组或对象指定位置上是一个值，则变成一个数组并在尾部追加<ul><li><code>a</code> append b <code>[a, b]</code></li></ul></li></ul></li><li><code>json_doc</code><ul><li>可以是json对象也可以是json数组</li></ul></li><li><code>path</code><ul><li><code>$[索引]</code></li><li><code>$.key</code></li></ul></li></ul></li><li><code>json_array_insert(json_doc, path, val[, path, val ...])</code><ul><li>向json数组指定位置插入值，返回新数组，不改变原有数组</li><li><code>json_doc</code><ul><li>要插入值的json数组</li></ul></li><li><code>path</code><ul><li>格式为 <code>$[索引值]</code>，数组索引从0开始</li></ul></li></ul></li><li><code>json_insert(json_doc, path, val[, path, val ...])</code><ul><li>向json对象添加新的键值对，返回新对象，不改变原对象</li><li><code>json_doc</code><ul><li>要插入值的json对象</li></ul></li><li><code>path</code><ul><li>格式为 <code>$.key</code></li><li>如果key在原对象中存在，不会添加也不改变原有值。</li></ul></li></ul></li><li><code>json_set(json_doc, path, val[, path, val ...])</code><ul><li>替换json_doc指定位置现有的值，如果不存在则添加</li></ul></li><li><code>json_replace(json_doc, path, val[, path, val ...])</code><ul><li>仅替换现有的值</li></ul></li><li><code>json_remove(json_doc, path[, path...])</code><ul><li>删除json_doc指定位置的值</li></ul></li><li><code>json_extract(json_doc, path[, path...])</code><ul><li>返回json_doc指定位置的值</li></ul></li><li><code>json_contains_path(json_doc, one_or_all, path[, path...])</code><ul><li>判断是否包含指定路径（索引或者key）</li><li><code>one</code><ul><li>只要有一个包含就返回1</li></ul></li><li><code>all</code><ul><li>只要有一个不包含就返回0</li></ul></li></ul></li><li><code>json_contains(target, candidate[, path])</code><ul><li>判断是否包含指定值</li><li><code>candidate</code><ul><li>要查找的值</li></ul></li><li><code>path</code><ul><li>如果设置则代表查找开始位置</li></ul></li></ul></li><li><code>json_length(json_doc[, path])</code><ul><li>返回json_doc的长度</li></ul></li></ol><h3 id="7-自定义函数"><a href="#7-自定义函数" class="headerlink" title="7 自定义函数"></a>7 自定义函数</h3><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CREATE</span><br><span class="line">[DEFINER = user]</span><br><span class="line">FUNCTION sp_name ([func_parameter[,...]])</span><br><span class="line">RETURNS type</span><br><span class="line">[characteristic ...] </span><br><span class="line">routine_body</span><br><span class="line"></span><br><span class="line">func_parameter: </span><br><span class="line">param_name type</span><br><span class="line">type:</span><br><span class="line">Any valid MySQL data type</span><br><span class="line">characteristic:</span><br><span class="line">  COMMENT &apos;string&apos;</span><br><span class="line">| LANGUAGE SQL</span><br><span class="line">| [NOT] DETERMINISTIC</span><br><span class="line">| &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;</span><br><span class="line">| SQL SECURITY &#123; DEFINER | INVOKER &#125;</span><br></pre></td></tr></table></figure><h4 id="2-创建"><a href="#2-创建" class="headerlink" title="2 创建"></a>2 创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DROP FUNCTION IF EXISTS 函数名;</span><br><span class="line">DELIMITER 结束标记</span><br><span class="line">CREATE FUNCTION 函数名 ([参数列表]) RETURNS 返回值类型</span><br><span class="line">BEGIN </span><br><span class="line">    函数体</span><br><span class="line">    RETURN 返回值;</span><br><span class="line">END 结束标记</span><br><span class="line">DELIMITER ; -- 将结束标记改回默认分号</span><br></pre></td></tr></table></figure><ul><li>形参<ul><li><code>形参名 形参类型</code></li></ul></li><li>返回值<ul><li><code>{STRING|INTEGER|REAL|DECIMAL}</code></li><li>必须有返回值且只有一个</li></ul></li></ul><h4 id="3-查看"><a href="#3-查看" class="headerlink" title="3 查看"></a>3 查看</h4><ol><li><code>show function status [like ‘pattern’]</code><ul><li>查看所有函数或模糊匹配</li></ul></li><li><code>show create function 函数名</code><ul><li>查看函数的创建语句</li></ul></li></ol><h4 id="4-修改-删除-函数"><a href="#4-修改-删除-函数" class="headerlink" title="4 修改/删除 函数"></a>4 修改/删除 函数</h4><ol><li>函数不能修改</li><li>删除<ul><li><code>drop function [if exists] 函数名</code></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;元数据可以简单理解为描述数据的数据，除了存储在数据库中的数据外，大多可以理解为元数据&lt;/li&gt;
&lt;li&gt;元数据存
      
    
    </summary>
    
    
      <category term="DB" scheme="https://anyeansan.github.io/categories/DB/"/>
    
      <category term="MySql" scheme="https://anyeansan.github.io/categories/DB/MySql/"/>
    
    
  </entry>
  
  <entry>
    <title>MySql SQL语句</title>
    <link href="https://anyeansan.github.io/2020/03/30/MySql-SQL%E8%AF%AD%E5%8F%A5/"/>
    <id>https://anyeansan.github.io/2020/03/30/MySql-SQL%E8%AF%AD%E5%8F%A5/</id>
    <published>2020-03-30T13:23:46.000Z</published>
    <updated>2020-03-30T13:30:16.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-SQL（Structure-Query-Language）"><a href="#一-SQL（Structure-Query-Language）" class="headerlink" title="一 SQL（Structure Query Language）"></a>一 SQL（Structure Query Language）</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ol><li>结构化查询语言，关系型数据库通用命令</li><li>遵循SQL92标准</li></ol><h2 id="1-2-严格模式（SQL-MODE）"><a href="#1-2-严格模式（SQL-MODE）" class="headerlink" title="1.2 严格模式（SQL_MODE）"></a>1.2 严格模式（SQL_MODE）</h2><ol><li><code>set sql_mode = &#39;traditional&#39;</code><ul><li>设置严格模式，默认</li></ul></li><li><code>set sql_mode = &#39;&#39;</code><ul><li>关闭严格模式</li></ul></li></ol><h2 id="1-3-SQL-规范"><a href="#1-3-SQL-规范" class="headerlink" title="1.3 SQL 规范"></a>1.3 SQL 规范</h2><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1 注释"></a>1 注释</h3><ul><li><code>--</code><ul><li>单行</li></ul></li><li><code>/* */</code><ul><li>多行</li></ul></li><li><code>#</code><ul><li>mysql 特有</li></ul></li></ul><h3 id="2-编码规范"><a href="#2-编码规范" class="headerlink" title="2 编码规范"></a>2 编码规范</h3><h4 id="1-库"><a href="#1-库" class="headerlink" title="1 库"></a>1 库</h4><ol><li>关键字 和 函数名 大写</li><li>库名 小写，不能以数字开头，不能使用关键字和保留字</li><li>必须设置字符集</li></ol><h4 id="2-表"><a href="#2-表" class="headerlink" title="2 表"></a>2 表</h4><ol><li>关键字 和 函数名 大写</li><li>表名 小写，不能以数字开头，不能使用关键字和保留字</li><li>选择合适的数据类型及长度</li><li>每个列设置 <code>NOT NULL + DEFAULT</code><ol><li>数值默认为 <code>0</code> 或其它有效数字</li><li>字符串默认为空格字符串 <code>&#39; &#39;</code> 或其它有效字符串</li></ol></li><li>enum 类型不要用于数值，只能用于字符串</li><li>每个列设置注释</li><li>表必须设置存储引擎和字符集</li><li>主键列最好是无关数值列，且自增长</li></ol><h2 id="1-4-SQL-常用分类"><a href="#1-4-SQL-常用分类" class="headerlink" title="1.4 SQL 常用分类"></a>1.4 SQL 常用分类</h2><ol><li>DQL（Data Query Language）<ul><li>数据查询语言，如 <code>select show</code></li></ul></li><li>DDL（Data Definition Language）<ul><li>数据定义语言，如 <code>create alter drop truncate</code></li></ul></li><li>DML（Data Manipulation Language）<ul><li>数据操作语言，如 <code>insert update delete</code></li></ul></li><li>DCL（Data Control Language）<ul><li>数据控制语言，如 <code>grant revoke</code></li></ul></li></ol><h1 id="二-库-操作"><a href="#二-库-操作" class="headerlink" title="二 库 操作"></a>二 库 操作</h1><h2 id="2-1-查"><a href="#2-1-查" class="headerlink" title="2.1 查"></a>2.1 查</h2><ol><li><code>show databases</code><ul><li>查看所有库</li></ul></li><li><code>show create database db_name</code><ul><li>查看建库语句</li></ul></li><li><code>show variables like &#39;character_set_database&#39;</code><ul><li>查看当前数据库字符集</li></ul></li><li><code>show variables like &#39;collation_database&#39;</code><ul><li>查看当前数据库校对集</li></ul></li></ol><h2 id="2-2-增"><a href="#2-2-增" class="headerlink" title="2.2 增"></a>2.2 增</h2><ul><li><code>create database [if not exists] 库名 [charset 字符集 collate 校对集]</code></li></ul><h2 id="2-3-删"><a href="#2-3-删" class="headerlink" title="2.3 删"></a>2.3 删</h2><ul><li><code>drop database [if exists] 库名</code></li></ul><h2 id="2-4-改"><a href="#2-4-改" class="headerlink" title="2.4 改"></a>2.4 改</h2><ul><li><code>alter database 库名 [charset 字符集 collate 校对集]</code><ol><li>库名不可修改</li><li>字符集和校对集可修改</li></ol></li></ul><h1 id="三-表-操作"><a href="#三-表-操作" class="headerlink" title="三 表 操作"></a>三 表 操作</h1><h2 id="3-1-指定库"><a href="#3-1-指定库" class="headerlink" title="3.1 指定库"></a>3.1 指定库</h2><ol><li><code>use 库名</code><ol><li>指定当前使用的数据库</li><li>表依赖于库，任何一个表都必须指定数据库<ul><li><code>库名.表名</code><ul><li>在 sql 语句中显式的指定</li></ul></li></ul></li></ol></li><li><code>select database()</code><ul><li>查看正在使用的数据库</li></ul></li></ol><h2 id="3-2-查"><a href="#3-2-查" class="headerlink" title="3.2 查"></a>3.2 查</h2><ol><li><code>show tables [from 库名]</code><ul><li>查看库（默认为当前库）中的所有表</li></ul></li><li><code>show create table 表名</code><ul><li>查看当前库中指定的表</li></ul></li><li><code>desc 表名</code><ul><li>查看表结构</li></ul></li><li><code>show columns from 表名</code><ul><li>查看表结构</li></ul></li></ol><h2 id="3-3-增"><a href="#3-3-增" class="headerlink" title="3.3 增"></a>3.3 增</h2><ol><li>.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table [if not exists] 表名(</span><br><span class="line">列名 列属性,</span><br><span class="line">......</span><br><span class="line">列名 列属性</span><br><span class="line">)[表属性]</span><br></pre></td></tr></table></figure><ul><li>表属性<ol><li><code>charset 字符集</code></li><li><code>collate 校对集</code></li><li><code>engine 存储引擎</code></li></ol></li></ul></li><li><code>create table 新表名 like 旧表名</code><ul><li>根据已有表结构创建新表</li></ul></li></ol><h2 id="3-4-删"><a href="#3-4-删" class="headerlink" title="3.4 删"></a>3.4 删</h2><ul><li><code>drop table [if exists] 表名</code></li></ul><h2 id="3-5-改"><a href="#3-5-改" class="headerlink" title="3.5 改"></a>3.5 改</h2><h3 id="1-表名"><a href="#1-表名" class="headerlink" title="1 表名"></a>1 表名</h3><ol><li><code>rename table 表名 to 新表名</code></li><li><code>alter table 表名 rename 新表名</code></li></ol><h3 id="2-表属性"><a href="#2-表属性" class="headerlink" title="2 表属性"></a>2 表属性</h3><ol><li><code>alter table 表名 表属性</code></li></ol><h3 id="3-表结构"><a href="#3-表结构" class="headerlink" title="3 表结构"></a>3 表结构</h3><ol><li><code>alter table 表名 add [column] 列名 列属性 [位置]</code><ul><li>默认在最后新增一列</li><li>位置<ul><li><code>first</code></li><li><code>after 列名</code></li></ul></li></ul></li><li><code>alter table 表名 add [column] (列名 列属性, ...)</code><ul><li>新增多列</li></ul></li><li><code>alter table 表名 drop [column] 列名</code><ul><li>删除列</li></ul></li><li><code>alter table 表名 modify 列名 列属性</code><ul><li>修改列属性</li></ul></li><li><code>alter table 表名 change 列名 新列名 列属性</code><ul><li>修改列名和列属性</li></ul></li></ol><h1 id="四-数据操作-DML"><a href="#四-数据操作-DML" class="headerlink" title="四 数据操作 DML"></a>四 数据操作 DML</h1><h2 id="4-1-insert"><a href="#4-1-insert" class="headerlink" title="4.1 insert"></a>4.1 insert</h2><ol><li><code>insert [into] 表名(列1,列2,列3,...) values(值1,值2,值3,...)[,(值1,值2,值3,...),...]</code><ol><li>列与值一一对应</li><li>非数字值，要加引号（建议单引号）</li><li>自增列可以用 <code>null / default</code> 占位，默认列可以用 <code>default</code> 占位</li><li>如果为表的所有列插入数据，可以省略 <code>(列1,列2,列3,...)</code></li></ol></li><li><code>insert [into] 表名 set 列=值,...</code><ul><li>一次插入一条记录，值可以使用子查询</li></ul></li></ol><h2 id="4-2-update"><a href="#4-2-update" class="headerlink" title="4.2 update"></a>4.2 update</h2><ul><li><code>update 表名 set 列 = 值 [where条件]</code><ul><li>不加条件会更新所有行</li></ul></li></ul><h2 id="4-3-delete"><a href="#4-3-delete" class="headerlink" title="4.3 delete"></a>4.3 delete</h2><ol><li><code>delete from 表名 [where条件]</code><ul><li>若没有条件，表示删除所有行</li></ul></li><li><code>truncate [table] 表名;</code><ul><li>清空表</li></ul></li></ol><ul><li>truncate 和 delete 区别<ul><li>DELETE <ol><li>DML 操作，是逻辑性质删除，逐行删除速度慢</li><li>删除表中的数据，表结构还在，删除后的数据可以找回</li><li>自增长主键不会重置</li></ol></li><li>TRUNCATE <ol><li>DDL 操作，对表段中的数据页进行清空，速度快</li><li>相当于把表扔了又创建一个同样表结构的新表</li><li>自增长主键会重置</li></ol></li></ul></li></ul><h1 id="五-数据操作-DQL"><a href="#五-数据操作-DQL" class="headerlink" title="五 数据操作 DQL"></a>五 数据操作 DQL</h1><h2 id="5-1-语法"><a href="#5-1-语法" class="headerlink" title="5.1 语法"></a>5.1 语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select [选项] 表达式[, [选项] 表达式, ...]</span><br><span class="line">[</span><br><span class="line">from 数据源 </span><br><span class="line">[where 子句]</span><br><span class="line">[group by 子句]</span><br><span class="line">[having 子句]</span><br><span class="line">[order by 子句]</span><br><span class="line">[limit 子句]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="5-2-select-子句"><a href="#5-2-select-子句" class="headerlink" title="5.2 select 子句"></a>5.2 select 子句</h2><h3 id="1-选项"><a href="#1-选项" class="headerlink" title="1  选项"></a>1  选项</h3><ol><li><code>all</code><ul><li>保留所有结果（默认）</li></ul></li><li><code>distinct</code><ul><li>去除重复</li></ul></li><li><code>distinct row</code></li><li><code>top</code></li></ol><h3 id="2-表达式"><a href="#2-表达式" class="headerlink" title="2 表达式"></a>2 表达式</h3><ol><li>每一个表达式代表一列，可以是列名，变量，函数 …</li><li><code>*</code><ul><li>代表所有列</li></ul></li></ol><h3 id="3-别名"><a href="#3-别名" class="headerlink" title="3 别名"></a>3 别名</h3><ul><li><code>[as] 别名</code> <ol><li>表别名<ul><li>可用于全局</li></ul></li><li>列别名<ul><li>别名可用于 <code>having</code>，<code>order by</code>  </li></ul></li></ol></li></ul><h2 id="5-2-from-子句"><a href="#5-2-from-子句" class="headerlink" title="5.2 from 子句"></a>5.2 from 子句</h2><ul><li>本质上只要数据类似二维表，都可以作为数据源<ol><li>单表数据源</li><li>多表数据源</li><li>查询语句</li></ol></li></ul><h2 id="5-4-where-子句"><a href="#5-4-where-子句" class="headerlink" title="5.4 where 子句"></a>5.4 where 子句</h2><h3 id="1-比较运算符"><a href="#1-比较运算符" class="headerlink" title="1 比较运算符"></a>1 比较运算符</h3><ul><li><code>&gt; &gt;= &lt; &lt;= = != ...</code></li></ul><h3 id="2-逻辑运算符"><a href="#2-逻辑运算符" class="headerlink" title="2 逻辑运算符"></a>2 逻辑运算符</h3><ul><li><code>and or not</code></li></ul><h3 id="3-语句"><a href="#3-语句" class="headerlink" title="3 语句"></a>3 语句</h3><ol><li><code>like pattern</code><ul><li>模糊查询</li><li><code>pattern</code><ul><li><code>%</code>：匹配任意个任意字符</li><li><code>_</code>：匹配一个任意字符</li></ul></li></ul></li><li><code>between ... and ...</code></li><li><code>is null</code></li><li><code>is not null</code></li><li><code>is boolean_value</code><ul><li>判断一个值的布尔值是否为 <code>boolean_value</code></li><li><code>boolean_value</code><ul><li><code>true</code></li><li><code>false</code></li><li><code>unknown</code></li></ul></li></ul></li><li><code>in()</code><ul><li>匹配其中任意一个值，则为 true，类似逻辑或</li></ul></li><li><code>any()</code><ul><li>必须配合比较运算符使用，代表（大于, 小于, …）其中任意一个值，则为 true</li></ul></li><li><code>some()</code><ul><li>是 <code>any()</code> 的别名</li></ul></li><li><code>all()</code><ul><li>必须配合比较运算符使用，代表（大于, 小于, …）其中所有值，则为 true</li></ul></li></ol><table><thead><tr><th align="center">运算符</th><th align="center">any()</th><th align="center">all()</th></tr></thead><tbody><tr><td align="center"><code>&gt; &gt;=</code></td><td align="center">最小值</td><td align="center">最大值</td></tr><tr><td align="center"><code>&lt; &lt;=</code></td><td align="center">最大值</td><td align="center">最小值</td></tr><tr><td align="center"><code>=</code></td><td align="center">任意值</td><td align="center">-</td></tr><tr><td align="center"><code>&lt;&gt; !=</code></td><td align="center">-</td><td align="center">任意值</td></tr></tbody></table><h2 id="5-5-group-by-子句"><a href="#5-5-group-by-子句" class="headerlink" title="5.5 group by 子句"></a>5.5 group by 子句</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>通常配合聚合函数使用</li><li>可以有多个分组列，以逗号分隔</li><li>select 中查询的列只能有三种<ol><li>分组的列</li><li>聚合函数的列</li><li>与分组列一对一的列</li></ol></li></ol><h3 id="2-group-by-原理"><a href="#2-group-by-原理" class="headerlink" title="2 group by 原理"></a>2 group by 原理</h3><ol><li>先按照分组列 排序、去重，形成一张虚拟表</li><li>虚拟表的结构：分组列与其它列的对应关系<ol><li>分组列一对一的列可以直接查询（即与分组列对应的列只有一行记录）</li><li>分组列一对多的列不能直接查询（即与分组列对应的列有多行记录）<ol><li>使用聚合函数将多行记录统计为一行记录</li><li>使用 <code>group_concat()</code> 将多行记录合并连接为一行记录</li></ol></li></ol></li></ol><h3 id="3-聚合函数"><a href="#3-聚合函数" class="headerlink" title="3 聚合函数"></a>3 聚合函数</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>max()</code></td><td>列最大值</td></tr><tr><td><code>min()</code></td><td>列最小值</td></tr><tr><td><code>count()</code></td><td>列记录总数</td></tr><tr><td><code>sum()</code></td><td>列和</td></tr><tr><td><code>avg()</code></td><td>列平均值</td></tr><tr><td><code>group_concat()</code></td><td>将group by产生的同一个分组中的其它列的所有值连接成一个字符串（多行记录变一行）</td></tr><tr><td>* <code>count()</code></td><td></td></tr><tr><td>1. <code>count(1) count(*) count(&#39;abc&#39;) ...</code></td><td></td></tr><tr><td>* 此类参数表示数数，有一行记录总数就+1，也就是说总数与记录内容无关</td><td></td></tr><tr><td>* 记录总数（包含空行）</td><td></td></tr><tr><td>2. <code>count(列名)</code></td><td></td></tr><tr><td>* 记录总数（不包含空行）</td><td></td></tr></tbody></table><h2 id="5-6-having-子句"><a href="#5-6-having-子句" class="headerlink" title="5.6 having 子句"></a>5.6 having 子句</h2><ul><li>having 是对其之前子句筛选出的数据进行条件过滤</li></ul><h2 id="5-7-order-by子句"><a href="#5-7-order-by子句" class="headerlink" title="5.7 order by子句"></a>5.7 order by子句</h2><table><thead><tr><th>语句</th><th>说明</th></tr></thead><tbody><tr><td><code>asc</code></td><td>升序（默认）</td></tr><tr><td><code>desc</code></td><td>降序</td></tr><tr><td>1. 排序依赖校对集</td><td></td></tr><tr><td>2. <code>order by 列1 asc,列2 desc...</code></td><td></td></tr><tr><td>* 多个排序条件时，前一个排序结果相同才会按照下一个条件排序</td><td></td></tr></tbody></table><h2 id="5-8-limit-子句"><a href="#5-8-limit-子句" class="headerlink" title="5.8 limit 子句"></a>5.8 limit 子句</h2><ol><li><code>limit [startIndex] length</code><ul><li>从 <code>startIndex</code> 开始，取 <code>length</code> 条数据。</li><li><code>startIndex</code><ul><li>起始索引，若省略相当于 0。</li><li>数据库索引从 0 开始</li></ul></li></ul></li><li><code>limit length offset startIndex</code></li></ol><h2 id="5-9-union-amp-union-all"><a href="#5-9-union-amp-union-all" class="headerlink" title="5.9 union &amp; union all"></a>5.9 union &amp; union all</h2><ul><li>合并多个查询结果集</li><li>一般情况下,会将 <code>in()</code> 或者 <code>OR</code> 语句 改写成 <code>UNION ALL</code> ,来提高性能</li></ul><ol><li><code>union</code><ul><li>去除重复</li></ul></li><li><code>union all</code><ul><li>保留所有</li></ul></li></ol><h2 id="5-10-查询过程"><a href="#5-10-查询过程" class="headerlink" title="5.10 查询过程"></a>5.10 查询过程</h2><ol><li>from<ul><li>确定数据源</li></ul></li><li>where<ol><li>where 是直接对表中数据进行判断，所以只能使用表中的列，且不能使用别名</li><li>where 从表中查询出符合条件的数据形成一个概念中的临时结果集，存入内存</li><li>where 保证进入内存的数据都是有效的</li></ol></li><li>group by<ul><li>按照指定列进行分组</li></ul></li><li>select<ul><li>处理表达式（函数, 别名, 运算 …），形成结果集</li></ul></li><li>having<ul><li>对结果集进行过滤</li></ul></li><li>order by<ul><li>对过滤后的结果集进行排序</li></ul></li><li>limit<ul><li>对排序后的结果集进行条目限制，形成最终结果集</li></ul></li></ol><h1 id="六-多表连接"><a href="#六-多表连接" class="headerlink" title="六 多表连接"></a>六 多表连接</h1><h2 id="6-1-语法"><a href="#6-1-语法" class="headerlink" title="6.1 语法"></a>6.1 语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">表1 </span><br><span class="line">&#123;[inner | cross] | &#123;left | right&#125; [outer]&#125;  join</span><br><span class="line">表2</span><br><span class="line">on 条件表达式</span><br><span class="line">[</span><br><span class="line">&#123;[inner | cross] | &#123;left | right&#125; [outer]&#125;  join</span><br><span class="line">表3</span><br><span class="line">on 条件表达式</span><br><span class="line">......</span><br><span class="line">]</span><br><span class="line">[where 子句]</span><br><span class="line">[group by 子句]</span><br><span class="line">[having 子句]</span><br><span class="line">[order by 子句]</span><br><span class="line">[limit 子句]</span><br></pre></td></tr></table></figure><ol><li>多表连接可以用在<ol><li>多表查询</li><li>多表更新</li><li>多表删除</li></ol></li><li><strong>自连接</strong><ul><li>连接的表是同一张表。</li></ul></li></ol><h2 id="6-2-内连接"><a href="#6-2-内连接" class="headerlink" title="6.2 内连接"></a>6.2 内连接</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 表1 [inner | cross] join 表2 on 条件</span><br><span class="line">2 from 表1,表2 where 条件</span><br></pre></td></tr></table></figure><ol><li>查出多表中符合条件的数据，即交集</li><li>内连接为左外连接与右外连接的交集。</li><li>内连接如果没有条件，结果会形成笛卡儿积</li></ol><h3 id="2-笛卡尔积"><a href="#2-笛卡尔积" class="headerlink" title="2 笛卡尔积"></a>2 笛卡尔积</h3><ol><li>笛卡儿积是元素相组合，不是数学相乘</li><li>数学中的笛卡儿积<ul><li>集合A有m个元素，集合B有n个元素，则笛卡尔积共 <code>m * n</code>个元素</li><li>例<ul><li>集合 A = {a, b}，集合 B = {0, 1, 2}</li><li>两个集合的笛卡尔积 = {(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}</li></ul></li></ul></li><li>数据库中的笛卡儿积<ul><li>表 A 有 m 条数据，表 B 中有 n 条数据，则笛卡尔积结果：<ol><li>行（记录数）= <code>m * n</code></li><li>列 = <code>表A的列数 + 表B的列数</code></li></ol></li></ul></li></ol><h2 id="6-3-外连接"><a href="#6-3-外连接" class="headerlink" title="6.3 外连接"></a>6.3 外连接</h2><h3 id="1-左外连接"><a href="#1-左外连接" class="headerlink" title="1 左外连接"></a>1 左外连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表1 left [outer] join 表2 on 条件</span><br></pre></td></tr></table></figure><ul><li>以左表为主，查出左表的全部记录和右表符合条件的记录，不符合条件的字段置为 <code>null</code></li></ul><h3 id="2-右外连接"><a href="#2-右外连接" class="headerlink" title="2 右外连接"></a>2 右外连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表1 right [outer] join 表2 on 条件</span><br></pre></td></tr></table></figure><ul><li>以右表为主，查出右表的全部记录和左表符合条件的记录，不符合条件的字段置为 <code>null</code></li></ul><h2 id="6-4-例"><a href="#6-4-例" class="headerlink" title="6.4 例"></a>6.4 例</h2><h3 id="1-原始表-t1-amp-t2"><a href="#1-原始表-t1-amp-t2" class="headerlink" title="1 原始表 t1 &amp; t2"></a>1 原始表 t1 &amp; t2</h3><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>a</td></tr><tr><td>2</td><td>b</td></tr><tr><td>3</td><td>c</td></tr></tbody></table><table><thead><tr><th>id</th><th>age</th></tr></thead><tbody><tr><td>2</td><td>D</td></tr><tr><td>3</td><td>E</td></tr><tr><td>4</td><td>F</td></tr></tbody></table><h3 id="2-内连接"><a href="#2-内连接" class="headerlink" title="2 内连接"></a>2 内连接</h3><ul><li><code>select * from t1 inner join t2 on t1.id=t2.id;</code></li></ul><table><thead><tr><th>id</th><th>name</th><th>id</th><th>age</th></tr></thead><tbody><tr><td>2</td><td>a</td><td>2</td><td>D</td></tr><tr><td>3</td><td>c</td><td>3</td><td>E</td></tr></tbody></table><h3 id="3-左外连接"><a href="#3-左外连接" class="headerlink" title="3 左外连接"></a>3 左外连接</h3><ul><li><code>select * from t1 left join t2 on t1.id=t2.id;</code></li></ul><table><thead><tr><th>id</th><th>name</th><th>id</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>a</td><td>null</td><td>null</td></tr><tr><td>2</td><td>b</td><td>2</td><td>D</td></tr><tr><td>3</td><td>c</td><td>3</td><td>E</td></tr></tbody></table><h3 id="4-右外连接"><a href="#4-右外连接" class="headerlink" title="4 右外连接"></a>4 右外连接</h3><ul><li><code>select * from t1 right join t2 on t1.id=t2.id;</code></li></ul><table><thead><tr><th>id</th><th>name</th><th>id</th><th>age</th></tr></thead><tbody><tr><td>2</td><td>b</td><td>2</td><td>D</td></tr><tr><td>3</td><td>c</td><td>3</td><td>E</td></tr><tr><td>null</td><td>null</td><td>4</td><td>F</td></tr></tbody></table><h3 id="5-全连接（-full-join-mysql不支持）"><a href="#5-全连接（-full-join-mysql不支持）" class="headerlink" title="5 全连接（(full join) mysql不支持）"></a>5 全连接（(full join) mysql不支持）</h3><ul><li><code>select * from t1 full join t2 on t1.id=t2.id;</code></li></ul><table><thead><tr><th>id</th><th>name</th><th>id</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>a</td><td>null</td><td>null</td></tr><tr><td>2</td><td>b</td><td>2</td><td>D</td></tr><tr><td>3</td><td>c</td><td>3</td><td>E</td></tr><tr><td>null</td><td>null</td><td>4</td><td>F</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-SQL（Structure-Query-Language）&quot;&gt;&lt;a href=&quot;#一-SQL（Structure-Query-Language）&quot; class=&quot;headerlink&quot; title=&quot;一 SQL（Structure Query Language
      
    
    </summary>
    
    
      <category term="DB" scheme="https://anyeansan.github.io/categories/DB/"/>
    
      <category term="MySql" scheme="https://anyeansan.github.io/categories/DB/MySql/"/>
    
    
  </entry>
  
</feed>
