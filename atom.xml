<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>安₃</title>
  
  <subtitle>我未成名君未嫁 可能俱是不如人</subtitle>
  <link href="/anyeansan.github.io/atom.xml" rel="self"/>
  
  <link href="https://anyeansan.github.io/"/>
  <updated>2020-09-29T08:05:08.331Z</updated>
  <id>https://anyeansan.github.io/</id>
  
  <author>
    <name>安₃</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java-日志</title>
    <link href="https://anyeansan.github.io/2020/09/29/Java/Java-%E6%97%A5%E5%BF%97/"/>
    <id>https://anyeansan.github.io/2020/09/29/Java/Java-%E6%97%A5%E5%BF%97/</id>
    <published>2020-09-29T08:04:53.000Z</published>
    <updated>2020-09-29T08:05:08.331Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol><li><p>日志门面（接口）：</p><ol><li><code>JCL（jakarta commons logging）</code></li><li><code>slf4j（simple logging facade for java）</code> </li></ol></li><li><p>日志实现</p><ol><li><code>JUL（Java util Logging）</code></li><li><code>logback</code></li><li><code>log4j</code></li><li><code>log4j2</code></li></ol></li></ol><h1 id="二-日志门面"><a href="#二-日志门面" class="headerlink" title="二 日志门面"></a>二 日志门面</h1><h2 id="2-1-JCL"><a href="#2-1-JCL" class="headerlink" title="2.1 JCL"></a>2.1 <code>JCL</code></h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li><code>Jakarta Commons Logging</code></li><li>包： <code>commons-looging.jar</code></li><li>Apache 提供的一个通用日志接口，它是为 “所有的 Java 日志实现”提供一个统一的接口，它自身也提供一个日志的实现 <code>SimpleLog</code>，但是功能非常弱</li><li>通过动态查找的机制，在程序运行时自动找出真正使用的日志库，如果未提供任何第三方实现，则默认使用 <code>JUL</code></li></ol><h3 id="2-API"><a href="#2-API" class="headerlink" title="2 API"></a>2 API</h3><ol><li><code>Log</code>：日志记录器</li><li><code>LogFactory</code>：负责创建 <code>Log</code></li></ol><h2 id="2-2-slf4j"><a href="#2-2-slf4j" class="headerlink" title="2.2 slf4j"></a>2.2 <code>slf4j</code></h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li><p><code>Simple Logging Facade For Java</code></p></li><li><p>SLF4J 主要是为了给 Java 日志访问提供一套标准、规范的 API 框架，其主要意义在于提供接口，具体的实现可以交由其他日志框架</p></li><li><p>slf4j 内置一个简单的日志实现 <code>slf4j-simple</code> ，不过很少使用</p></li><li><p>通常 slf4j 作为门面，配上具体的实现框架，中接使用桥接器完成桥接</p></li><li><p>主要功能：</p><ol><li>日志框架的绑定</li><li>日志框架的桥接</li></ol></li><li><p><code>slf4j-api.jar</code> 核心 API 包</p></li><li><p>日志级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-绑定日志实现"><a href="#2-绑定日志实现" class="headerlink" title="2 绑定日志实现"></a>2 绑定日志实现</h3><h4 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1 步骤"></a>1 步骤</h4><ol><li>添加 slf4j 的依赖包 <code>slf4j-api.jar</code></li><li>绑定具体的日志实现框架<ol><li>已经实现 slf4j 的日志框架，如 <code>logback</code>，直接添加其依赖即可</li><li>没有实现 slf4j 的日志框架，如 <code>JUL log4j log4j2</code>，除了日志框架的依赖包外，还需要适配器（包）</li></ol></li><li>如果绑定了多个实现，默认使用第一个</li></ol><h4 id="2-包"><a href="#2-包" class="headerlink" title="2 包"></a>2 包</h4><h5 id="1-slf4j-JUL"><a href="#1-slf4j-JUL" class="headerlink" title="1 slf4j + JUL"></a>1 slf4j + JUL</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slf4j-api.jar</span><br><span class="line">slf4j-jdk14.jar</span><br></pre></td></tr></table></figure><h5 id="2-slf4j-log4j"><a href="#2-slf4j-log4j" class="headerlink" title="2 slf4j + log4j"></a>2 slf4j + log4j</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slf4j-api.jar</span><br><span class="line">log4j.jar</span><br><span class="line">slf4j-log4j12.jar</span><br></pre></td></tr></table></figure><h5 id="3-slf4j-log4j2"><a href="#3-slf4j-log4j2" class="headerlink" title="3 slf4j + log4j2"></a>3 slf4j + log4j2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slf4j-api.jar</span><br><span class="line">log4j-api.jar</span><br><span class="line">log4j-core.jar</span><br><span class="line">log4j-slf4j-impl.jar</span><br></pre></td></tr></table></figure><h5 id="4-slf4j-logback"><a href="#4-slf4j-logback" class="headerlink" title="4 slf4j + logback"></a>4 slf4j + logback</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slf4j-api.jar</span><br><span class="line">logback-core.jar</span><br><span class="line">logback-classic.jar</span><br></pre></td></tr></table></figure><h3 id="3-桥接旧的日志框架"><a href="#3-桥接旧的日志框架" class="headerlink" title="3 桥接旧的日志框架"></a>3 桥接旧的日志框架</h3><h4 id="1-步骤-1"><a href="#1-步骤-1" class="headerlink" title="1 步骤"></a>1 步骤</h4><ol><li>去除旧的日志依赖</li><li>配置桥接器（包）</li><li>绑定新的日志实现</li></ol><h4 id="2-桥接器"><a href="#2-桥接器" class="headerlink" title="2 桥接器"></a>2 桥接器</h4><ol><li><code>jul-to-slf4j.jar</code><ul><li>将 JUL 的日志桥接到 slf4j ，即不再使用 JUL，而使用新的日志实现</li></ul></li><li><code>log4j-over-slf4j.jar</code><ul><li>将 log4j 的日志桥接到 slf4j</li></ul></li><li><code>jcl-over-slf4j.jar</code><ul><li>将 JCL 的日志桥接到 slf4j</li></ul></li></ol><h3 id="4-API"><a href="#4-API" class="headerlink" title="4 API"></a>4 API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Logger LoggerFactory.getLogger(字节码文件)</span><br><span class="line">Logger LoggerFactory.getLogger(全限定类名)</span><br></pre></td></tr></table></figure><h1 id="三-日志实现"><a href="#三-日志实现" class="headerlink" title="三 日志实现"></a>三 日志实现</h1><h2 id="3-1-log4j2"><a href="#3-1-log4j2" class="headerlink" title="3.1 log4j2"></a>3.1 <code>log4j2</code></h2><h3 id="1-配置"><a href="#1-配置" class="headerlink" title="1 配置"></a>1 配置</h3><ul><li>默认加载类路径下 <code>log4j2.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">日志级别： </span></span><br><span class="line"><span class="comment">OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL</span></span><br><span class="line"><span class="comment">    日期格式：</span></span><br><span class="line"><span class="comment">        %d 输出的时间</span></span><br><span class="line"><span class="comment">        %t 输出当前线程名称</span></span><br><span class="line"><span class="comment">        %F 输出所在的类文件名</span></span><br><span class="line"><span class="comment">        %L 输出行号</span></span><br><span class="line"><span class="comment">        %M 输出所在方法名</span></span><br><span class="line"><span class="comment">        %n 换行</span></span><br><span class="line"><span class="comment">        %-5level 输出日志级别，-5表示左对齐并且固定输出5个字符，如果不足在右边补0</span></span><br><span class="line"><span class="comment">        %logger 输出logger名称，Root Logger没有名称</span></span><br><span class="line"><span class="comment">        %l 输出语句所在的行数, 包括类名、方法名、文件名、行数</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">status：设置log4j2自身内部的信息输出，可以不设置</span></span><br><span class="line"><span class="comment">monitorInterval：指定每隔多久重新读取配置文件，可以不重启应用的情况下修改配置</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span> <span class="attr">monitorInterval</span>=<span class="string">"30"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1 定义属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 2 配置 appender--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2.1 console--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--输出日志格式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2.2 file--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">fileName</span>=<span class="string">"文件路径"</span> <span class="attr">append</span>=<span class="string">"是否追加"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--输出日志格式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2.3 rollingFile--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">fileName</span>=<span class="string">""</span> <span class="attr">filePattern</span>=<span class="string">"指定当发生Rolling时，文件的转移和重命名规则"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--输出日志格式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 过滤器--&gt;</span>      </span><br><span class="line"><span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">""</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 日志拆分规则--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 系统启动就触发拆分规则，产生一个新的日志文件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">OnStartupTriggeringPolicy</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 按照时间节点拆分，根据 filePattern 的配置，如最小时间粒度是HH，则表示每小时产生一个新的日志文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 按照文件大小拆分，超过大小就产生一个新的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--同一目录最多保存的文件个数，超过则覆盖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3 logger 只有定义了logger并引入的appender，appender才会生效--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3.1 root--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--3.2 自定义 logger--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">level</span>=<span class="string">""</span> <span class="attr">additivity</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-异步日志"><a href="#2-异步日志" class="headerlink" title="2 异步日志"></a>2 异步日志</h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h4><ol><li>异步日志需要添加依赖 <code>com.lmax.disruptor</code></li><li>有两种实现方式<ol><li><code>AsyncLogger</code>（官方推荐）：全局+混合</li><li><code>AsyncAppender</code></li></ol></li><li>注意三种方式不要同时使用</li></ol><h4 id="2-AsyncLogger"><a href="#2-AsyncLogger" class="headerlink" title="2 AsyncLogger"></a>2 <code>AsyncLogger</code></h4><h5 id="1-全局异步"><a href="#1-全局异步" class="headerlink" title="1 全局异步"></a>1 全局异步</h5><ol><li><p>所有的日志都异步的记录，在配置文件上不用做任何改动，只需要添加一个 <code>log4j2.component.properties</code> 配置</p></li><li><p><code>log4j2.component.properties</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Log4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector</span><br></pre></td></tr></table></figure></li></ol><h5 id="2-混合异步"><a href="#2-混合异步" class="headerlink" title="2 混合异步"></a>2 混合异步</h5><ol><li><p>同时使用同步日志和异步日志，通过配置指定哪些同步哪些异步</p></li><li><p>配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">自定义异步 logger</span></span><br><span class="line"><span class="comment">includeLocation：是否包含日志记录的行号信息，要关闭</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AsyncLogger</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">level</span>=<span class="string">""</span> <span class="attr">includeLocation</span>=<span class="string">"false"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">AsyncLogger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="3-AsyncAppender"><a href="#3-AsyncAppender" class="headerlink" title="3 AsyncAppender"></a>3 <code>AsyncAppender</code></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 定义异步 appender ，之后引入 logger 即可</span><br><span class="line"><span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Async</span> <span class="attr">name</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Async</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-2-logback"><a href="#3-2-logback" class="headerlink" title="3.2 logback"></a>3.2 <code>logback</code></h2><h3 id="1-模块"><a href="#1-模块" class="headerlink" title="1 模块"></a>1 模块</h3><ol><li><code>logback-core</code>：其它两个模块的基础模块</li><li><code>logback-classic</code>：它是 log4j 的一个改良版本，同时它完整实现了slf4j API</li><li><code>logback-access</code>：访问模块与 Servlet 容器集成提供通过 Http 来访问日志的功能</li></ol><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2 配置"></a>2 配置</h3><h4 id="1-依次读取"><a href="#1-依次读取" class="headerlink" title="1 依次读取"></a>1 依次读取</h4><ol><li><code>logback.groovy</code></li><li><code>logback-test.xml</code></li><li><code>logback.xml</code></li></ol><h4 id="2-详解"><a href="#2-详解" class="headerlink" title="2 详解"></a>2 详解</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1 配置集中管理属性，获取value语法 $&#123;name&#125; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2 Appdender 配置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2.1 console --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--输出流对象 默认 System.out--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span>&gt;</span><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志输出格式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span><span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2.2 file --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.FileAppender"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志输出路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">file</span>&gt;</span><span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志输出格式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span><span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2.3 htmlFile --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.FileAppender"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志输出路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">file</span>&gt;</span><span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志输出格式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.encoder.LayoutWrappingEncoder"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.html.HTMLLayout"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span><span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- 2.4 rollingFile --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志输出路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">file</span>&gt;</span><span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志输出格式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span><span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定日志文件拆分和压缩规则--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--按照时间和压缩格式声明拆分的文件名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span><span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--按照文件大小拆分--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span><span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志级别过滤器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--过滤规则--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">level</span>&gt;</span><span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">      // 超过指定级别放行还是拦截</span><br><span class="line">      <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">      // 低于指定级别放行还是拦截</span><br><span class="line">      <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2.5 异步 async --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.AsyncAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3 root Logger 配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"默认debug"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"console"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--4 自定义 logger --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.itheima"</span> <span class="attr">level</span>=<span class="string">"debug"</span> <span class="attr">additivity</span>=<span class="string">"是否继承rootLogger，默认true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-3-JUL"><a href="#3-3-JUL" class="headerlink" title="3.3 JUL"></a>3.3 <code>JUL</code></h2><h3 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li><code>Java util Logging</code></li><li>是 Java 原生的日志框架，使用时不需要另外引用第三方类库</li><li>配置文件：<code>$JAVA_HOME\conf\logging.properties</code></li><li>所在包：<code>java.util.logging</code> </li></ol><h3 id="2-架构"><a href="#2-架构" class="headerlink" title="2 架构"></a>2 架构</h3><table><thead><tr><th>对象</th><th>说明</th></tr></thead><tbody><tr><td><code>Logger</code></td><td>日志记录器，程序通过此对象的 API 来发布日志，每个 <code>Logger</code> 可以关联多个 <code>Appender / Handler</code></td></tr><tr><td><code>Appender / Handler</code></td><td>日志处理器，决定日志记录的位置，如 控制台、文件…</td></tr><tr><td><code>Layout / Formatter</code></td><td>负责日志记录的数据转换和格式化</td></tr><tr><td><code>Level</code></td><td>日志级别</td></tr></tbody></table><h3 id="2-API-1"><a href="#2-API-1" class="headerlink" title="2 API"></a>2 API</h3><h4 id="1-Logger"><a href="#1-Logger" class="headerlink" title="1 Logger"></a>1 Logger</h4><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static Logger</code></td><td><code>getLogger(String name)</code></td><td>获取或创建 <code>Logger</code> 对象</td></tr><tr><td><code>void</code></td><td><code>log(Level, String msg)</code></td><td>输出指定级别的信息</td></tr><tr><td><code>void</code></td><td><code>info(String msg)</code></td><td>输出指定级别的信息，还有其它级别方法</td></tr><tr><td><code>void</code></td><td><code>addHandler(Handler handler)</code></td><td>关联 <code>Handler</code></td></tr><tr><td><code>void</code></td><td><code>setUseParentHandlers(Boolean useParentHandlers)</code></td><td>是否会输出到父 <code>Logger</code></td></tr><tr><td><code>void</code></td><td><code>setLevel(Level newLevel)</code></td><td>设置日志级别</td></tr></tbody></table><ol><li><code>Logger</code> 之间存在父子关系，根据名称会自动继承，如 <code>com.cn.an 和 com.cn 和 com</code></li><li>最顶层是一个 <code>RootLogger</code></li><li>子 <code>Logger</code> 输出会同时传递给父 <code>Logger</code> 输出</li></ol><h4 id="2-Lever"><a href="#2-Lever" class="headerlink" title="2 Lever"></a>2 Lever</h4><table><thead><tr><th>静态属性</th><th>说明</th></tr></thead><tbody><tr><td><code>ALL</code></td><td>启用所有级别信息</td></tr><tr><td><code>OFF</code></td><td>关闭日志</td></tr><tr><td><code>SEVERE</code></td><td>错误</td></tr><tr><td><code>WARNING</code></td><td>警告</td></tr><tr><td><code>INFO</code>（默认）</td><td>信息</td></tr><tr><td><code>CONFIG</code></td><td>配置</td></tr><tr><td><code>FINE FINER FINEST</code></td><td>debug <code>详细 较详细 非常详细</code></td></tr></tbody></table><h4 id="3-Handler"><a href="#3-Handler" class="headerlink" title="3 Handler"></a>3 Handler</h4><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>setLevel(Level newLevel)</code></td><td>设置日志级别</td></tr><tr><td><code>void</code></td><td><code>setForMatter(Formater newFormatter)</code></td><td>关联  <code>Formatter</code></td></tr></tbody></table><h2 id="3-4-Log4j"><a href="#3-4-Log4j" class="headerlink" title="3.4 Log4j"></a>3.4 <code>Log4j</code></h2><h3 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1 配置文件"></a>1 配置文件</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定日志级别和使用的输出端appender：console为自定义名称</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">INFO,console</span></span><br><span class="line"><span class="comment"># 控制台输出配置</span></span><br><span class="line"><span class="meta">log4j.appender.console</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="string">%d [%t] %-5p [%c] - %m%n</span></span><br></pre></td></tr></table></figure><ol><li>名称：<code>log4j.properties</code></li><li>将配置文件放在类路径下，会自动读取</li></ol><h3 id="2-组件"><a href="#2-组件" class="headerlink" title="2 组件"></a>2 组件</h3><h4 id="1-Looger"><a href="#1-Looger" class="headerlink" title="1 Looger"></a>1 Looger</h4><ol><li>Log4j 有一个根 <code>Logger</code>：<code>root</code></li><li>其它所有的 <code>Logger</code> 都会直接或间接继承 <code>root</code></li></ol><h4 id="2-Appender"><a href="#2-Appender" class="headerlink" title="2 Appender"></a>2 Appender</h4><ol><li><code>ConsoleAppender</code></li><li><code>FileAppender</code></li><li><code>DailyRollingFileAppender</code></li><li><code>RollingFileAppender</code></li><li><code>JDBCAppender</code></li></ol><h4 id="3-Layout"><a href="#3-Layout" class="headerlink" title="3 Layout"></a>3 Layout</h4><ol><li><code>HTMLLayout</code></li><li><code>SimpleLayout</code></li><li><code>PatternLayout</code></li></ol><ul><li><h1 id="配置文件log4j2-xml"><a href="#配置文件log4j2-xml" class="headerlink" title="配置文件log4j2.xml"></a><strong>配置文件<code>log4j2.xml</code></strong></h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span> <span class="attr">monitorInterval</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>log4j2默认会在classpath目录下寻找log4j.json、log4j.jsn、log4j2.xml等名称的文件，如果都没有找到，则会按默认配置输出，也就是输出到控制台。</li><li><code>status</code><ul><li>表示log4j2本身的日志信息打印级别</li><li>用于设置log4j2自身内部的信息输出,可以不设置,当设置成trace时,会看到log4j2内部各种详细输出</li></ul></li><li><code>monitorInterval</code><ul><li>Log4j能够自动检测修改配置文件和重新配置本身, 设置间隔秒数。</li></ul></li><li><code>Appender</code><ul><li>定义日志的输出目的地</li><li><code>Console</code><ul><li>定义输出到控制台的Appender</li><li><code>name</code><ul><li>指定Appender的名字</li></ul></li><li><code>target</code><ul><li>SYSTEM_OUT 或 SYSTEM_ERR,一般只设置默认:SYSTEM_OUT.</li></ul></li><li><code>PatternLayout</code><ul><li>输出格式，不设置默认为:%m%n.</li></ul></li></ul></li><li><code>File</code><ul><li>定义输出到指定位置的文件的Appender</li><li><code>name</code><ul><li>指定Appender的名字</li></ul></li><li><code>fileName</code><ul><li>指定输出日志的目的文件带全路径的文件名</li></ul></li><li><code>PatternLayout</code><ul><li>输出格式，不设置默认为:%m%n.</li></ul></li></ul></li><li><code>RollingFile</code><ul><li>定义超过指定大小自动删除旧的创建新的的Appender.</li><li><code>name</code><ul><li>指定Appender的名字</li></ul></li><li><code>fileName</code><ul><li>指定输出日志的目的文件带全路径的文件名</li></ul></li><li><code>PatternLayout</code><ul><li>输出格式，不设置默认为:%m%n.</li></ul></li><li><code>filePattern</code><ul><li>指定新建日志文件的名称格式.</li></ul></li><li><code>Policies</code><ul><li>指定滚动日志的策略，就是什么时候进行新建日志文件输出日志</li><li><code>TimeBasedTriggeringPolicy</code><ul><li>基于时间的滚动策略</li><li><code>interval</code><ul><li>指定多久滚动一次，默认是1 hour</li></ul></li><li><code>modulate</code><ul><li>=true用来调整时间</li><li>比如现在是早上3am，interval是4，那么第一次滚动是在4am，接着是8am，12am…而不是7am</li></ul></li></ul></li><li><code>SizeBasedTriggeringPolicy</code><ul><li>基于指定文件大小的滚动策略</li><li><code>size</code><ul><li>定义每个日志文件的大小</li></ul></li></ul></li></ul></li><li><code>DefaultRolloverStrategy</code><ul><li>指定同一个文件夹下最多有几个日志文件时开始删除最旧的，创建新的</li><li><code>max</code><ul><li>配置最多日志文件数</li></ul></li></ul></li></ul></li></ul></li><li><code>Loggers</code><ul><li><code>Root</code><ul><li>指定项目的根日志，如果没有单独指定Logger，那么就会默认使用该Root日志输出</li><li><code>level</code><ul><li>日志输出级别，共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF</li></ul></li><li><code>AppenderRef</code><ul><li>指定该日志输出到哪个Appender</li></ul></li></ul></li><li><code>Logger</code><ul><li>单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等</li><li><code>level</code></li><li><code>name</code><ul><li>指定该Logger所适用的类或者类所在的包全路径,继承自Root节点</li></ul></li><li><code>AppenderRef</code><ul><li>指定该日志输出到哪个Appender,如果没有指定，就会默认继承自Root.如果指定了，那么会在指定的这个Appender和Root的Appender中都会输出。<ul><li>若设置Logger的additivity=”false”只在自定义的Appender中进行输出。        </li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;日志门面（接口）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;JCL（jakarta commons logg
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="Java" scheme="https://anyeansan.github.io/categories/CS/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-时间日期</title>
    <link href="https://anyeansan.github.io/2020/09/29/Java/Java-%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F/"/>
    <id>https://anyeansan.github.io/2020/09/29/Java/Java-%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F/</id>
    <published>2020-09-29T08:04:17.000Z</published>
    <updated>2020-09-29T08:04:27.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-JDK8-之前的日期时间"><a href="#一-JDK8-之前的日期时间" class="headerlink" title="一 JDK8 之前的日期时间"></a>一 JDK8 之前的日期时间</h1><h2 id="1-1-java-util-Date"><a href="#1-1-java-util-Date" class="headerlink" title="1.1 java.util.Date"></a>1.1 <code>java.util.Date</code></h2><h3 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1 构造方法"></a>1 构造方法</h3><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Date()</code></td><td>当前时间，使用的是当前时间到 <code>1970-01-01 00:00:00</code> 的毫秒值创建</td></tr><tr><td><code>Date​(long date)</code></td><td>使用指定毫秒值</td></tr></tbody></table><h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2 方法"></a>2 方法</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>long getTime()</code></td><td>获取 <code>1970-01-01 00:00:00</code> 到此时间的毫秒值</td></tr></tbody></table><h2 id="1-2-java-util-Calendar"><a href="#1-2-java-util-Calendar" class="headerlink" title="1.2 java.util.Calendar"></a>1.2 <code>java.util.Calendar</code></h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li><code>Calendar</code> 类是一个抽象类，提供了很多关于日期时间计算的方法</li><li><code>GregorianCalendar</code>（公历）是 <code>Calendar</code> 的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统</li></ol><h3 id="2-方法-1"><a href="#2-方法-1" class="headerlink" title="2 方法"></a>2 方法</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static Calendar getInstance()</code></td><td>使用默认时区和语言环境获得一个日历</td></tr><tr><td><code>static Calendar getInstance​(TimeZone zone, Locale aLocale)</code></td><td>使用指定时区和语言环境获得一个日历</td></tr></tbody></table><h2 id="1-3-java-text-SimpleDateFormat"><a href="#1-3-java-text-SimpleDateFormat" class="headerlink" title="1.3 java.text.SimpleDateFormat"></a>1.3 <code>java.text.SimpleDateFormat</code></h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>SimpleDateFormat​(String pattern)</code></td><td>指定格式创建对象</td></tr><tr><td><code>String format​(Date date)</code></td><td>日期 → 字符串</td></tr><tr><td><code>Date parse​(String source)</code></td><td>字符串 → 日期</td></tr></tbody></table><h1 id="二-JDK8-的日期时间"><a href="#二-JDK8-的日期时间" class="headerlink" title="二 JDK8 的日期时间"></a>二 JDK8 的日期时间</h1><table><thead><tr><th>包</th><th>说明</th></tr></thead><tbody><tr><td><code>java.time</code></td><td>基础包，使用标准的 <code>iso-8601</code> 历法（公历）</td></tr><tr><td><code>java.time.format</code></td><td>格式化和解析日期时间</td></tr><tr><td><code>java.time.temporal</code></td><td>包括底层框架和扩展特性</td></tr><tr><td><code>java.time.chrono</code></td><td>提供对不同的日历系统的访问</td></tr><tr><td><code>java.time.zone</code></td><td>包含支持不同时区以及相关规定的类</td></tr></tbody></table><h1 id="三-java-time-包"><a href="#三-java-time-包" class="headerlink" title="三 java.time 包"></a>三 <code>java.time</code> 包</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><table><thead><tr><th>类</th><th>说明</th></tr></thead><tbody><tr><td><code>LocalDateTime</code></td><td>本地日期时间（不包含时区）</td></tr><tr><td><code>LocalDate</code></td><td>本地日期</td></tr><tr><td><code>LocalTime</code></td><td>本地时间</td></tr><tr><td><code>Instant</code></td><td>瞬时（时间戳），是 UTC 时间，没有时区概念</td></tr><tr><td><code>Period</code></td><td>日期间隔</td></tr><tr><td><code>Duration</code></td><td>时间间隔</td></tr><tr><td><code>ZoneOffset</code></td><td>时区偏移量</td></tr><tr><td><code>ZonedDateTime</code></td><td>指定时区的日期时间</td></tr><tr><td><code>ZoneId</code></td><td>包含了所有的时区信息，格式 <code>区域/城市</code></td></tr><tr><td><code>Clock</code></td><td>时钟</td></tr></tbody></table><h2 id="3-2-LocalDateTime-amp-LocalDate-amp-LocalTime"><a href="#3-2-LocalDateTime-amp-LocalDate-amp-LocalTime" class="headerlink" title="3.2 LocalDateTime &amp; LocalDate &amp; LocalTime"></a>3.2 <code>LocalDateTime &amp; LocalDate &amp; LocalTime</code></h2><h3 id="1-创建（now，of）"><a href="#1-创建（now，of）" class="headerlink" title="1 创建（now，of）"></a>1 创建（<code>now，of</code>）</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static LocalDateTime</code></td><td><code>now()</code></td><td>获取当前日期时间（默认时区）</td></tr><tr><td><code>static LocalDateTime</code></td><td><code>now​(ZoneId zone)</code></td><td>获取当前日期时间（指定时区）</td></tr><tr><td><code>static LocalDateTime</code></td><td><code>of(xxx)</code></td><td>获取指定日期时间（一系列重载）</td></tr></tbody></table><h3 id="2-获取（get）"><a href="#2-获取（get）" class="headerlink" title="2 获取（get）"></a>2 获取（<code>get</code>）</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>getYear()</code></td><td>获取年份</td></tr><tr><td><code>Month</code></td><td><code>getMonth()</code></td><td>获取月份（<code>Month</code> 是枚举类）</td></tr><tr><td><code>int</code></td><td><code>getMonthValue()</code></td><td>获取一年中的第几个月 <code>1 ~ 12</code></td></tr><tr><td><code>int</code></td><td><code>getDayOfYear()</code></td><td>获取一年中的第几天 <code>1 ~ 365/366</code></td></tr><tr><td><code>int</code></td><td><code>getDayOfMonth()</code></td><td>获取一月中的第几天 <code>1 ~ 31</code></td></tr><tr><td><code>DayOfWeek</code></td><td><code>getDayOfWeek()</code></td><td>获取星期几（<code>DayOfWeek</code> 是枚举类）</td></tr><tr><td><code>int</code></td><td><code>getHour()</code></td><td>获取时</td></tr><tr><td><code>int</code></td><td><code>getMinute()</code></td><td>获取分</td></tr><tr><td><code>int</code></td><td><code>getSecond()</code></td><td>获取秒</td></tr><tr><td><code>int</code></td><td><code>getNano()</code></td><td>获取纳秒</td></tr></tbody></table><h3 id="3-格式化和解析（format，parse）"><a href="#3-格式化和解析（format，parse）" class="headerlink" title="3 格式化和解析（format，parse）"></a>3 格式化和解析（<code>format，parse</code>）</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>String</code></td><td><code>format​(DateTimeFormatter formatter)</code></td><td>日期时间转成指定格式的字符串</td></tr><tr><td><code>static LocalDateTime</code></td><td><code>parse​(CharSequence text)</code></td><td>解析默认格式字序列</td></tr><tr><td><code>static LocalDateTime</code></td><td><code>parse​(CharSequence text, DateTimeFormatter formatter)</code></td><td>解析指定格式字符序列</td></tr></tbody></table><h3 id="4-判断（is）"><a href="#4-判断（is）" class="headerlink" title="4 判断（is）"></a>4 判断（<code>is</code>）</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>isAfter​(ChronoLocalDate other)</code></td><td>是否在之后</td></tr><tr><td><code>boolean</code></td><td><code>isBefore(ChronoLocalDate other)</code></td><td>是否在之前</td></tr><tr><td><code>boolean</code></td><td><code>isEqual(ChronoLocalDate other)</code></td><td>是否相等</td></tr><tr><td><code>boolean</code></td><td><code>isLeapYear()</code></td><td>是否是闰年</td></tr></tbody></table><h3 id="5-修改（with）"><a href="#5-修改（with）" class="headerlink" title="5 修改（with）"></a>5 修改（<code>with</code>）</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>LocalDateTime</code></td><td><code>with​(TemporalAdjuster adjuster)</code></td><td>将当前日期时间设置为校对器指定的日期时间</td></tr><tr><td><code>LocalDateTime</code></td><td><code>withYear(int year)</code></td><td>修改年</td></tr><tr><td><code>LocalDateTime</code></td><td><code>withMonth(int month)</code></td><td>修改月</td></tr><tr><td><code>LocalDateTime</code></td><td><code>withDayOfYear(int dayOfYear)</code></td><td>修改年第几天</td></tr><tr><td><code>LocalDateTime</code></td><td><code>withDayOfMonth(int dayOfMonth)</code></td><td>修改月第几天</td></tr><tr><td><code>LocalDateTime</code></td><td><code>withHour(int hour)</code></td><td>修改时</td></tr><tr><td><code>LocalDateTime</code></td><td><code>withMinute(int minute)</code></td><td>修改分</td></tr><tr><td><code>LocalDateTime</code></td><td><code>withSecond(int second)</code></td><td>修改秒</td></tr></tbody></table><h3 id="6-计算-plus，minus"><a href="#6-计算-plus，minus" class="headerlink" title="6 计算 plus，minus"></a>6 计算 <code>plus，minus</code></h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>LocalDateTime</code></td><td><code>minus(TemporalAmount amountToSubtract)</code></td><td>减去一个 <code>Duration</code> 或 <code>Period</code></td></tr><tr><td><code>LocalDateTime</code></td><td><code>plus(TemporalAmount amountToAdd)</code></td><td>添加一个 <code>Duration</code> 或 <code>Period</code></td></tr><tr><td><code>LocalDateTime</code></td><td><code>plusYears(long years)</code></td><td>当前日期时间加指定年</td></tr><tr><td><code>LocalDateTime</code></td><td><code>plusMonths(long months)</code></td><td>当前日期时间加指定月</td></tr><tr><td><code>LocalDateTime</code></td><td><code>plusDays(long days)</code></td><td>当前日期时间加指定日</td></tr><tr><td><code>LocalDateTime</code></td><td><code>plusWeeks(long weeks)</code></td><td>当前日期时间加指定周</td></tr><tr><td><code>LocalDateTime</code></td><td><code>plusHours(long hours)</code></td><td>当前日期时间加指定时</td></tr><tr><td><code>LocalDateTime</code></td><td><code>plusMinutes(long minutes)</code></td><td>当前日期时间加指定分</td></tr><tr><td><code>LocalDateTime</code></td><td><code>plusSeconds(long seconds)</code></td><td>当前日期时间加指定秒</td></tr></tbody></table><h3 id="7-转换（to）"><a href="#7-转换（to）" class="headerlink" title="7 转换（to）"></a>7 转换（<code>to</code>）</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>String</code></td><td><code>toString()</code></td><td>获取字符串</td></tr><tr><td><code>LocalDate</code></td><td><code>toLocalDate()</code></td><td>获取日期</td></tr><tr><td><code>LocalTime</code></td><td><code>toLocalTime()</code></td><td>获取时间</td></tr></tbody></table><h2 id="3-3-Instant"><a href="#3-3-Instant" class="headerlink" title="3.3 Instant"></a>3.3 <code>Instant</code></h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static Instant</code></td><td><code>now()</code></td><td>获取当前UTC时间的时间戳</td></tr><tr><td><code>static Instant</code></td><td><code>ofEpochMilli​(long epochMilli)</code></td><td>获取指定毫秒值距元时间的时间戳</td></tr><tr><td><code>long</code></td><td><code>toEpochMilli()</code></td><td>获取距元时间的毫秒数</td></tr><tr><td><code>OffsetDateTime</code></td><td><code>atOffset​(ZoneOffset offset)</code></td><td>结合时区偏移创建 <code>OffsetDateTime</code></td></tr></tbody></table><h2 id="3-4-Period"><a href="#3-4-Period" class="headerlink" title="3.4 Period"></a>3.4 <code>Period</code></h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static Period</code></td><td><code>between​(LocalDate startDateInclusive, LocalDate endDateExclusive)</code></td><td>获取两个日期的间隔对象  <code>Period</code></td></tr><tr><td><code>int</code></td><td><code>getYears()</code></td><td>相隔年份</td></tr><tr><td><code>int</code></td><td><code>getMonths()</code></td><td>相隔月份（只比较月字段）</td></tr><tr><td><code>int</code></td><td><code>getDays()</code></td><td>相隔天数（只比较日字段）</td></tr><tr><td><code>long</code></td><td><code>toTotalMonths()</code></td><td>相隔总月份</td></tr></tbody></table><h2 id="3-5-Duration"><a href="#3-5-Duration" class="headerlink" title="3.5 Duration"></a>3.5 <code>Duration</code></h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static Duration</code></td><td><code>between​(Temporal startInclusive, Temporal endExclusive)</code></td><td>获取两个时间的间隔对象  <code>Duration</code></td></tr><tr><td><code>long</code></td><td><code>toDays()</code></td><td>相隔总天数</td></tr><tr><td><code>long</code></td><td><code>toHours()</code></td><td>相隔总小时数</td></tr><tr><td><code>long</code></td><td><code>toMinutes()</code></td><td>相隔总分钟数</td></tr><tr><td><code>long</code></td><td><code>toSeconds()</code></td><td>相隔总秒数</td></tr><tr><td><code>long</code></td><td><code>toMillis()</code></td><td>相隔总毫秒数</td></tr><tr><td><code>long</code></td><td><code>toNanos()</code></td><td>相隔总纳秒数</td></tr></tbody></table><h2 id="3-6-ZoneId"><a href="#3-6-ZoneId" class="headerlink" title="3.6 ZoneId"></a>3.6 <code>ZoneId</code></h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static Set&lt;String&gt;</code></td><td><code>getAvailableZoneIds()</code></td><td>获取所有时区ID，格式<code>区域/城市</code></td></tr><tr><td><code>static ZoneId</code></td><td><code>systemDefault()</code></td><td>获取系统默认时区</td></tr><tr><td><code>static ZoneId</code></td><td><code>of​(String zoneId)</code></td><td>根据时区ID获取时区</td></tr></tbody></table><h1 id="四-DateTimeFormatter"><a href="#四-DateTimeFormatter" class="headerlink" title="四 DateTimeFormatter"></a>四 <code>DateTimeFormatter</code></h1><h2 id="4-1-预定义标准格式"><a href="#4-1-预定义标准格式" class="headerlink" title="4.1 预定义标准格式"></a>4.1 预定义标准格式</h2><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td><code>ISO_LOCAL_DATE_TIME</code></td><td><code>YYYY-MM-DD HH:MM:SS</code></td></tr><tr><td><code>ISO_LOCAL_DATE</code></td><td><code>YYYY-MM-DD</code></td></tr><tr><td><code>ISO_LOCAL_TIME</code></td><td><code>HH:MM:SS</code></td></tr><tr><td><code>...</code></td><td><code>...</code></td></tr></tbody></table><h2 id="4-2-本地化相关格式"><a href="#4-2-本地化相关格式" class="headerlink" title="4.2 本地化相关格式"></a>4.2 本地化相关格式</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static DateTimeFormatter</code></td><td><code>ofLocalizedDateTime​(FormatStyle dateTimeStyle)</code></td><td><code>FormatStyle</code> 是枚举类，其中 <code>FULL，LONG</code>适用于 <code>DateTime</code></td></tr><tr><td><code>static DateTimeFormatter</code></td><td><code>ofLocalizedDate​(FormatStyle dateStyle)</code></td><td><code>MEDIUM，SHORT</code> 适用于 <code>Date</code></td></tr><tr><td><code>static DateTimeFormatter</code></td><td><code>ofLocalizedTime​(FormatStyle timeStyle)</code></td><td><code>MEDIUM，SHORT</code> 适用于 <code>Time</code></td></tr></tbody></table><h2 id="4-3-自定义格式"><a href="#4-3-自定义格式" class="headerlink" title="4.3 自定义格式"></a>4.3 自定义格式</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static DateTimeFormatter</code></td><td><code>ofPattern​(String pattern)</code></td><td>使用自定义格式和默认地区</td></tr><tr><td><code>static DateTimeFormatter</code></td><td><code>ofPattern​(String pattern, Locale locale)</code></td><td>使用自定义格式和指定地区</td></tr></tbody></table><h1 id="五-TemporalAdjusters"><a href="#五-TemporalAdjusters" class="headerlink" title="五 TemporalAdjusters"></a>五 <code>TemporalAdjusters</code></h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol><li>时间校正器工具类</li><li>获取时间校正器对象，之后可以通过日期时间对象的 <code>with</code> 方法来调整</li></ol><h2 id="5-2-API"><a href="#5-2-API" class="headerlink" title="5.2 API"></a>5.2 API</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> TemporalAdjuster <span class="title">firstXxx</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> TemporalAdjuster <span class="title">lastXxx</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> TemporalAdjuster <span class="title">nextXxx</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> TemporalAdjuster <span class="title">previousXxx</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h1 id="六-新旧日期时间的转换"><a href="#六-新旧日期时间的转换" class="headerlink" title="六 新旧日期时间的转换"></a>六 新旧日期时间的转换</h1><table><thead><tr><th>旧类</th><th>新类</th><th>旧 → 新</th><th>新 → 旧</th></tr></thead><tbody><tr><td><code>java.util.Date</code></td><td><code>java.time.Instant</code></td><td><code>date.toInstant()</code></td><td><code>Date.from(instant)</code></td></tr><tr><td><code>java.sql.Timestamp</code></td><td><code>java.time.Instant</code></td><td><code>timestamp.toInstant()</code></td><td><code>Timestamp.from(instant)</code></td></tr><tr><td><code>java.sql.Timestamp</code></td><td><code>java.time.LocalDateTime</code></td><td><code>timestamp.toLocalDateTime()</code></td><td><code>Timestamp.valueOf(localDateTIme)</code></td></tr><tr><td><code>java.sql.Date</code></td><td><code>java.time.LocalDate</code></td><td><code>date.toLocalDate()</code></td><td><code>Date.valueOf(LocalDate)</code></td></tr><tr><td><code>java.sql.Time</code></td><td><code>java.time.LocalTime</code></td><td><code>time.toLocalTime()</code></td><td><code>TIme.valueOf(LocalTime)</code></td></tr></tbody></table><ol><li>旧转为新 <code>to</code></li><li>新转为旧 <code>from，valueOf</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-JDK8-之前的日期时间&quot;&gt;&lt;a href=&quot;#一-JDK8-之前的日期时间&quot; class=&quot;headerlink&quot; title=&quot;一 JDK8 之前的日期时间&quot;&gt;&lt;/a&gt;一 JDK8 之前的日期时间&lt;/h1&gt;&lt;h2 id=&quot;1-1-java-util-Dat
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="Java" scheme="https://anyeansan.github.io/categories/CS/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-常用API</title>
    <link href="https://anyeansan.github.io/2020/09/29/Java/Java-%E5%B8%B8%E7%94%A8API/"/>
    <id>https://anyeansan.github.io/2020/09/29/Java/Java-%E5%B8%B8%E7%94%A8API/</id>
    <published>2020-09-29T08:03:31.000Z</published>
    <updated>2020-09-29T08:03:47.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-java-lang-Object"><a href="#一-java-lang-Object" class="headerlink" title="一 java.lang.Object"></a>一 <code>java.lang.Object</code></h1><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>hashCode()</code></td><td>返回该对象的哈希码值</td></tr><tr><td><code>boolean</code></td><td><code>equals(Object obj)</code></td><td>默认比较对象的地址值</td></tr><tr><td><code>Class&lt;?&gt;</code></td><td><code>getClass()</code></td><td>返回此对象的字节码对象</td></tr><tr><td><code>String</code></td><td><code>toString()</code></td><td><code>getClass().getName() + &#39;@&#39; + Integer.toHexString(hashCode())</code></td></tr><tr><td><code>protected Object</code></td><td><code>clone()</code></td><td>浅拷贝</td></tr><tr><td><code>void</code></td><td><code>wait()</code></td><td>无限等待直到被唤醒，相当于 <code>wait(0)</code></td></tr><tr><td><code>void</code></td><td><code>wait(long timeoutMillis)</code></td><td>等待指定时间或被唤醒</td></tr><tr><td><code>void</code></td><td><code>wait(long timeoutMillis, int nanos)</code></td><td>等待指定时间或被唤醒</td></tr><tr><td><code>void</code></td><td><code>notify()</code></td><td>唤醒一个</td></tr><tr><td><code>void</code></td><td><code>notifyAll()</code></td><td>唤醒所有</td></tr></tbody></table><h2 id="1-1-和-equals"><a href="#1-1-和-equals" class="headerlink" title="1.1 ==  和  equals()"></a>1.1 <code>==</code>  和  <code>equals()</code></h2><table><thead><tr><th>比较符</th><th>基本数据类型</th><th>引用数据类型</th></tr></thead><tbody><tr><td><code>==</code></td><td>比较值，<code>==</code> 是运算符所以同样适用基本类型运算时的类型转换 <code>byte short char -&gt; int -&gt; long -&gt; float -&gt; double</code></td><td>比较地址值</td></tr><tr><td><code>equals()</code></td><td>&nbsp;</td><td>比较地址值</td></tr></tbody></table><h2 id="1-2-重写-equals-时也要重写-hashCode"><a href="#1-2-重写-equals-时也要重写-hashCode" class="headerlink" title="1.2 重写 equals() 时也要重写 hashCode()"></a>1.2 重写 <code>equals()</code> 时也要重写 <code>hashCode()</code></h2><ol><li>判断元素是否相同：<ol><li>判断两个元素哈希值是否相同（判断的是对象的 <code>hashCode()</code></li><li>如果哈希值相同判断内容是否相同（判断的是对象的 <code>equals()</code>）</li></ol></li><li>两个对象相同则哈希值一定相同，如果只重写 <code>equals()</code> 方法，结果返回 <code>true</code> 时，<code>hashCode()</code> 返回值可能不一样</li></ol><h1 id="二-java-util-Objects"><a href="#二-java-util-Objects" class="headerlink" title="二 java.util.Objects"></a>二 <code>java.util.Objects</code></h1><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static boolean</code></td><td><code>equals​(Object a, Object b)</code></td><td>判断是否是同一对象</td></tr><tr><td><code>static boolean</code></td><td><code>isNull​(Object obj)</code></td><td>判断对象是否为空</td></tr><tr><td><code>static boolean</code></td><td><code>nonNull​(Object obj)</code></td><td>判断对象是否不为空</td></tr><tr><td><code>static &lt;T&gt; T</code></td><td><code>requireNonNull​(T obj [, String message])</code></td><td>如果对象不为空则返回，为空则抛空指针异常（可指定异常信息）</td></tr><tr><td><code>static &lt;T&gt; int</code></td><td><code>compare​(T a, T b, Comparator&lt;? super T&gt; c)</code></td><td>如果 <code>a==b</code> 返回 0，否则使用比较器比较</td></tr><tr><td><code>static String</code></td><td><code>toString​(Object o)</code></td><td>如果对象不为空则调用 <code>toString()</code>，为空则返回 <code>&quot;null&quot;</code></td></tr></tbody></table><h1 id="三-基本类型包装类"><a href="#三-基本类型包装类" class="headerlink" title="三 基本类型包装类"></a>三 基本类型包装类</h1><h2 id="3-1-包装类"><a href="#3-1-包装类" class="headerlink" title="3.1 包装类"></a>3.1 包装类</h2><table><thead><tr><th>基本数据类型</th><th>包装类（<code>java.lang</code>）</th></tr></thead><tbody><tr><td><code>byte</code></td><td><code>Byte</code></td></tr><tr><td><code>short</code></td><td><code>Short</code></td></tr><tr><td><code>int</code></td><td><code>Integer</code></td></tr><tr><td><code>long</code></td><td><code>Long</code></td></tr><tr><td><code>float</code></td><td><code>Float</code></td></tr><tr><td><code>double</code></td><td><code>Double</code></td></tr><tr><td><code>char</code></td><td><code>Character</code></td></tr><tr><td><code>boolean</code></td><td><code>Boolean</code></td></tr></tbody></table><ul><li>除了 <code>Character</code> 和 <code>Boolean</code> 外，都是 <code>Number</code> 类的子类</li></ul><h2 id="3-2-自动装箱和拆箱"><a href="#3-2-自动装箱和拆箱" class="headerlink" title="3.2 自动装箱和拆箱"></a>3.2 自动装箱和拆箱</h2><ul><li>装箱：<code>基本数据类型 → 包装类对象</code></li><li>拆箱：<code>包装类对象 → 基本数据类型</code></li></ul><h2 id="3-3-包装类的缓存"><a href="#3-3-包装类的缓存" class="headerlink" title="3.3 包装类的缓存"></a>3.3 包装类的缓存</h2><table><thead><tr><th>包装类</th><th>缓存范围</th></tr></thead><tbody><tr><td><code>Boolean</code></td><td><code>true false</code></td></tr><tr><td><code>Byte Short Long</code></td><td><code>-128~127</code></td></tr><tr><td><code>Integer</code></td><td><code>-128~127</code>（上限可以调整）</td></tr><tr><td><code>Character</code></td><td><code>0~127</code> （最早的 ASCII 码的128个字符）</td></tr><tr><td><code>Double Float</code></td><td>没有缓存</td></tr></tbody></table><ul><li><p>自动装箱时，如果在缓存范围内，则不会创建新对象，而是使用缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">i1 == i2; <span class="comment">// false ，因为不是同一个对象</span></span><br><span class="line">i1.equals(i2); <span class="comment">// true ，Integer重写了equals方法，比较的是数值</span></span><br><span class="line"></span><br><span class="line">Integer i1 = <span class="number">127</span>;</span><br><span class="line">Integer i2 = <span class="number">127</span>;</span><br><span class="line">i1 == i2; <span class="comment">// true ，因为缓存，指向同一个地址</span></span><br><span class="line">i1.equals(i2); <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line">Integer i1 = <span class="number">128</span>;</span><br><span class="line">Integer i2 = <span class="number">128</span>;</span><br><span class="line">i1 == i2; <span class="comment">// false ，不在缓存范围，则需要重新 new 是两个不同的地址</span></span><br><span class="line">i1.equals(i2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="3-4-基本类型及其包装类与字符串的转换"><a href="#3-4-基本类型及其包装类与字符串的转换" class="headerlink" title="3.4 基本类型及其包装类与字符串的转换"></a>3.4 基本类型及其包装类与字符串的转换</h2><ol><li><code>int/Integer -&gt; string</code><ol><li><code>+ &quot;&quot;</code></li><li><code>toString()</code></li><li><code>String.valueOf()</code></li></ol></li><li><code>String -&gt; int/Integer</code><ol><li><code>Integer.parseInt(String s)</code></li></ol></li></ol><h1 id="四-比较器"><a href="#四-比较器" class="headerlink" title="四 比较器"></a>四 比较器</h1><h2 id="4-1-java-lang-Comparable"><a href="#4-1-java-lang-Comparable" class="headerlink" title="4.1 java.lang.Comparable"></a>4.1 <code>java.lang.Comparable</code></h2><ol><li>实现此接口的类具有比较性</li><li>实现 <code>int compareTo(T o)</code> 方法<ul><li>如果当前对象大于形参对象则返回正整数</li><li>如果当前对象等于形参对象则返回 0</li><li>如果当前对象小于形参对象则返回负整数</li></ul></li></ol><h2 id="4-2-java-util-Comparator"><a href="#4-2-java-util-Comparator" class="headerlink" title="4.2 java.util.Comparator"></a>4.2 <code>java.util.Comparator</code></h2><ol><li>比较器接口，实现此接口创建新的比较器</li><li>实现 <code>int compare(T o1, T o2)</code> 方法<ul><li><code>o1 &gt; o2</code> 返回正整数</li><li><code>o1 == o2</code> 返回 0</li><li><code>o1 &lt; o2</code> 返回负整数</li></ul></li></ol><h1 id="五-java-lang-System"><a href="#五-java-lang-System" class="headerlink" title="五 java.lang.System"></a>五 <code>java.lang.System</code></h1><h2 id="5-1-属性"><a href="#5-1-属性" class="headerlink" title="5.1 属性"></a>5.1 属性</h2><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td><code>in</code></td><td>标准输入</td></tr><tr><td><code>out</code></td><td>标准输出</td></tr><tr><td><code>err</code></td><td>标准错误输出</td></tr></tbody></table><h2 id="5-2-方法"><a href="#5-2-方法" class="headerlink" title="5.2 方法"></a>5.2 方法</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static long</code></td><td><code>currentTimeMillis()</code></td><td><code>1970-01-01 00:00:00</code> 到当前时间的毫秒值</td></tr><tr><td><code>static Properties</code></td><td><code>getProperties()</code></td><td>获取系统属性值</td></tr><tr><td><code>static String</code></td><td><code>getProperty(String key)</code></td><td>获取系统指定属性的值</td></tr><tr><td><code>static void</code></td><td><code>gc()</code></td><td>运行垃圾回收器</td></tr><tr><td><code>static void</code></td><td><code>exit(int status)</code></td><td>终止当前正在运行的 Java 虚拟机， <code>0</code> 表示正常终止，非 <code>0</code> 异常退出</td></tr><tr><td><code>static void</code></td><td><code>arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code></td><td>拷贝数组</td></tr><tr><td><code>static void</code></td><td><code>setIn​(InputStream in)</code></td><td>重新分配标准输入</td></tr><tr><td><code>static void</code></td><td><code>setOut​(PrintStream out)</code></td><td>重新分配标准输出</td></tr><tr><td><code>static void</code></td><td><code>setErr​(PrintStream err)</code></td><td>重新分配标准错误输出</td></tr></tbody></table><h1 id="六-java-util-Scanner"><a href="#六-java-util-Scanner" class="headerlink" title="六 java.util.Scanner"></a>六 <code>java.util.Scanner</code></h1><h2 id="6-1-构造"><a href="#6-1-构造" class="headerlink" title="6.1 构造"></a>6.1 构造</h2><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Scanner(File source [, String charsetName])</code></td><td>扫描文件</td></tr><tr><td><code>Scanner​(InputStream source [, String charsetName])</code></td><td>扫描字节输入流</td></tr><tr><td><code>Scanner​(String source)</code></td><td>扫描字符串</td></tr></tbody></table><h2 id="6-2-方法"><a href="#6-2-方法" class="headerlink" title="6.2 方法"></a>6.2 方法</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>hasNext()</code></td><td>是否有下一个字符串</td></tr><tr><td><code>String</code></td><td><code>next()</code></td><td>获取下一个字符串，遇到空白符结束（空格 制表符 回车）</td></tr><tr><td><code>String</code></td><td><code>nextLine()</code></td><td>获取下一个字符串，遇到换行符结束</td></tr><tr><td><code>boolean</code></td><td><code>hasNextXxx()</code></td><td>是否有下一个指定类型的数据，<code>hasNextInt ()hasNextDouble() ...</code></td></tr><tr><td><code>Xxx</code></td><td><code>nextXxx()</code></td><td>获取下一个指定类型的数据，<code>nextInt() nextDouble() ...</code></td></tr></tbody></table><ul><li>当 <code>nextXxx()</code> 和 <code>nextLine()</code> 连用时的问题<ul><li>比如输入 <code>8</code> ，实际输入的是 <code>8\r\n</code>，而 <code>nextInt()</code> 读到 <code>8</code> 就结束了，下一个使用 <code>nextLine()</code> 读到 <code>\r\n</code> 直接就结束了</li></ul></li><li>解决<ol><li>在语句之后加一个 <code>nextLine()</code> 语句用来读取没有读到的 <code>\r\n</code></li><li>都使用 <code>nextLine()</code>，输入字符串，需要数字就转换。</li></ol></li></ul><h1 id="七-java-util-Random"><a href="#七-java-util-Random" class="headerlink" title="七 java.util.Random"></a>七 <code>java.util.Random</code></h1><h2 id="7-1-构造"><a href="#7-1-构造" class="headerlink" title="7.1 构造"></a>7.1 构造</h2><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Random()</code></td><td>默认种子是系统时间的纳秒值</td></tr><tr><td><code>Random​(long seed)</code></td><td>指定种子，种子相同，多次执行获得的随机数是一样的</td></tr></tbody></table><h2 id="7-2-方法"><a href="#7-2-方法" class="headerlink" title="7.2 方法"></a>7.2 方法</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>nextInt()</code></td><td>获取 int 范围内的随机数</td></tr><tr><td><code>int</code></td><td><code>nextInt(int bound)</code></td><td>获取 <code>0&lt; x &lt; bound</code> 的随机数</td></tr></tbody></table><h1 id="八-Arrays"><a href="#八-Arrays" class="headerlink" title="八 Arrays"></a>八 <code>Arrays</code></h1><h2 id="8-1-数组-→-集合"><a href="#8-1-数组-→-集合" class="headerlink" title="8.1 数组 → 集合"></a>8.1 数组 → 集合</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static &lt;T&gt; List&lt;T&gt;</code></td><td><code>asList(T... a)</code></td><td>数组 → <code>List</code></td></tr></tbody></table><ol><li>数组长度固定，所以转成的集合的增删方法不能使用</li><li>集合中只能存储引用数据类型，所以：<ul><li>如果数组中的元素是引用类型，则直接作为集合元素</li><li>如果数组中的元素是基本类型，则将数组作为集合元素</li></ul></li></ol><h2 id="8-2-二分查找"><a href="#8-2-二分查找" class="headerlink" title="8.2 二分查找"></a>8.2 二分查找</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static int</code></td><td><code>binarySearch(T[] a, T key)</code></td><td>找到则返回索引，没找到返回 <code>-插入点-1</code></td></tr><tr><td><code>static int</code></td><td><code>binarySearch(T[] a, int fromIndex, int toIndex, T key)</code></td><td>指定范围 <code>[from, to)</code></td></tr><tr><td><code>static &lt;T&gt; int</code></td><td><code>binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c)</code></td><td>指定比较器</td></tr><tr><td><code>static &lt;T&gt; int</code></td><td><code>binarySearch(T[] a, int fromIndex, int toIndex, T key, Comparator&lt;? super T&gt; c)</code></td><td>指定比较器，并指定范围 <code>[from, to)</code></td></tr></tbody></table><h2 id="8-3-排序"><a href="#8-3-排序" class="headerlink" title="8.3 排序"></a>8.3 排序</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static void</code></td><td><code>sort(T[] a)</code></td><td>数组排序</td></tr><tr><td><code>static void</code></td><td><code>sort(T[] a, int fromIndex, int toIndex)</code></td><td>指定范围 <code>[from, to)</code></td></tr><tr><td><code>static &lt;T&gt; void</code></td><td><code>sort(T[] a, Comparator&lt;? super T&gt; c)</code></td><td>指定比较器</td></tr><tr><td><code>static &lt;T&gt; void</code></td><td><code>sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; c)</code></td><td>指定比较器，并指定范围 <code>[from, to)</code></td></tr></tbody></table><h2 id="8-4-复制"><a href="#8-4-复制" class="headerlink" title="8.4 复制"></a>8.4 复制</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static &lt;T&gt; T[]</code></td><td><code>copyOf(T[] original, int newLength)</code></td><td>将原数组复制到新数组并指定新数组长度，新数组长度大的话根据类型使用 <code>0 false null</code> 填充</td></tr><tr><td><code>static &lt;T&gt; T[]</code></td><td><code>copyOfRange(T[] original, int from, int to)</code></td><td>复制原数组指定内容到新数组</td></tr></tbody></table><h2 id="8-5-填充"><a href="#8-5-填充" class="headerlink" title="8.5 填充"></a>8.5 填充</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static void</code></td><td><code>fill(T[], T val)</code></td><td>将数组所有元素用 <code>val</code> 替换</td></tr><tr><td><code>static void</code></td><td><code>fill(T[], int fromIndex, int toIndex, T val)</code></td><td>将数组 <code>[from, to)</code> 范围的元素用 <code>val</code> 替换</td></tr></tbody></table><h2 id="8-6-相等比较"><a href="#8-6-相等比较" class="headerlink" title="8.6 相等比较"></a>8.6 相等比较</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static boolean</code></td><td><code>equals(T[] a1, T[] a2)</code></td><td>比较两个数组的长度和元素是否相等</td></tr><tr><td><code>static boolean</code></td><td><code>deepEquals(Object[] a1, Object[] a2)</code></td><td>深度相等比较</td></tr></tbody></table><h2 id="8-7-toString"><a href="#8-7-toString" class="headerlink" title="8.7 toString"></a>8.7 <code>toString</code></h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static String</code></td><td><code>toString(T[] arr)</code></td><td>将数组元素以 <code>[元素1, 元素2 ...]</code> 格式拼接成一个字符串</td></tr></tbody></table><h2 id="8-8-流"><a href="#8-8-流" class="headerlink" title="8.8 流"></a>8.8 流</h2><table><thead><tr><th>修饰</th><th>方法</th></tr></thead><tbody><tr><td><code>static IntStream</code></td><td><code>stream(int[] array)</code></td></tr><tr><td><code>static IntStream</code></td><td><code>stream(int[] array, int startInclusive, int endExclusive)</code></td></tr><tr><td><code>static LongStream</code></td><td><code>stream(long[] array)</code></td></tr><tr><td><code>static LongStream</code></td><td><code>stream(long[] array, int startInclusive, int endExclusive)</code></td></tr><tr><td><code>static DoubleStream</code></td><td><code>stream(double[] array)</code></td></tr><tr><td><code>static DoubleStream</code></td><td><code>stream(double[] array, int startInclusive, int endExclusive)</code></td></tr><tr><td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td><td><code>stream(T[] array)</code></td></tr><tr><td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td><td><code>stream(T[] array, int startInclusive, int endExclusive)</code></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-java-lang-Object&quot;&gt;&lt;a href=&quot;#一-java-lang-Object&quot; class=&quot;headerlink&quot; title=&quot;一 java.lang.Object&quot;&gt;&lt;/a&gt;一 &lt;code&gt;java.lang.Object&lt;/code&gt;&lt;
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="Java" scheme="https://anyeansan.github.io/categories/CS/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-Stream</title>
    <link href="https://anyeansan.github.io/2020/09/29/Java/Java-Stream/"/>
    <id>https://anyeansan.github.io/2020/09/29/Java/Java-Stream/</id>
    <published>2020-09-29T08:02:42.000Z</published>
    <updated>2020-09-29T08:02:54.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol><li><code>java.util.stream</code> 包</li><li>流：从支持数据处理操作的源生成的元素序列<ol><li>流不存储元素，只是对数据进行处理</li><li>流的操作不会修改数据源，而是返回一个持有结果的新流</li><li>惰性求值：流的中间操作形成一条流水线，但不会真正执行，只有在执行终端操作时才会一次性全部处理</li><li>流只能消费一次</li></ol></li><li>集合关注的是数据存储，与内存打交道</li><li>流关注的是数据运算，与CPU打交道</li></ol><h1 id="二-流的操作"><a href="#二-流的操作" class="headerlink" title="二 流的操作"></a>二 流的操作</h1><h2 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h2><ol><li>流水线</li><li>内部迭代<ul><li>使用集合：需要用户去做迭代，这称为外部迭代</li><li>使用流：数据处理完全是在库内部进行的，这称为内部迭代</li></ul></li></ol><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%86%85%E9%83%A8-%E5%A4%96%E9%83%A8%E8%BF%AD%E4%BB%A3.png" alt=""></p><h2 id="2-2-流程"><a href="#2-2-流程" class="headerlink" title="2.2 流程"></a>2.2 流程</h2><table><thead><tr><th>流程</th><th>说明</th></tr></thead><tbody><tr><td>1 创建流</td><td>通过一个数据源（如：集合、数组），获取一个流</td></tr><tr><td>2 中间操作</td><td>对数据源的数据进行 n 次处理，多个中间操作形成操作链（在终端操作前，并不会真正执行中间操作链）</td></tr><tr><td>3 终端操作</td><td>一旦执行终端操作，就执行中间操作链，最终产生结果并结束流</td></tr></tbody></table><h1 id="三-创建流"><a href="#三-创建流" class="headerlink" title="三 创建流"></a>三 创建流</h1><h2 id="3-1-由值创建流：java-util-stream-Stream"><a href="#3-1-由值创建流：java-util-stream-Stream" class="headerlink" title="3.1 由值创建流：java.util.stream.Stream"></a>3.1 由值创建流：<code>java.util.stream.Stream</code></h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td><td><code>ofNullable(T t)</code></td><td>若 <code>t</code> 为 <code>null</code> ，则返回空流，否则返回包含 <code>t</code> 的流</td></tr><tr><td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td><td><code>empty()</code></td><td>获取一个不包含任何元素的空流</td></tr><tr><td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td><td><code>of(T... values)</code></td><td>获取一个有限流，元素固定</td></tr><tr><td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td><td><code>generate(Supplier&lt;? extends T&gt; s)</code></td><td>获取一个无限流，元素通过反复调用 <code>s</code> 生成</td></tr><tr><td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td><td><code>iterate(T seed, UnaryOperator&lt;T&gt; f)</code></td><td>获取一个无限流，元素： <code>seed</code> 为初始值，之后依次由上一个值通过 <code>f</code> 生成下一个值</td></tr><tr><td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td><td><code>iterate(T seed, Predicate&lt;? super T&gt; hasNext, UnaryOperator&lt;T&gt; f)</code></td><td>获取一个有限流，和无限流的区别是会在某个元素不满足 <code>hasNext</code> 时停止</td></tr></tbody></table><h2 id="3-2-由集合创建流：-java-util-Collection-lt-E-gt"><a href="#3-2-由集合创建流：-java-util-Collection-lt-E-gt" class="headerlink" title="3.2 由集合创建流： java.util.Collection&lt;E&gt;"></a>3.2 由集合创建流： <code>java.util.Collection&lt;E&gt;</code></h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>default Stream&lt;E&gt;</code></td><td><code>stream()</code></td><td>获取一个顺序流</td></tr><tr><td><code>default Stream&lt;E&gt;</code></td><td><code>parallelStream()</code></td><td>获取一个并行流</td></tr></tbody></table><h2 id="3-3-由数组创建流：java-util-Arrays"><a href="#3-3-由数组创建流：java-util-Arrays" class="headerlink" title="3.3 由数组创建流：java.util.Arrays"></a>3.3 由数组创建流：<code>java.util.Arrays</code></h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td><td><code>stream(T[] array[, int start, int end])</code></td><td>获取 <code>Stream</code> 流，可指定范围 <code>[start, end)</code></td></tr><tr><td><code>static IntStream</code></td><td><code>stream(int[] array[, int start, int end])</code></td><td>获取 <code>IntStream</code> 流，可指定范围 <code>[start, end)</code></td></tr><tr><td><code>static LongStream</code></td><td><code>stream(long[] array[, int start, int end])</code></td><td>获取 <code>LongStream</code> 流，可指定范围 <code>[start, end)</code></td></tr><tr><td><code>static DoubleStream</code></td><td><code>stream(double[] array[, int start, int end])</code></td><td>获取 <code>DoubleStream</code> 流，可指定范围 <code>[start, end)</code></td></tr></tbody></table><h2 id="3-4-由文件生成流：java-nio-file-Files"><a href="#3-4-由文件生成流：java-nio-file-Files" class="headerlink" title="3.4 由文件生成流：java.nio.file.Files"></a>3.4 由文件生成流：<code>java.nio.file.Files</code></h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static Stream&lt;String&gt;</code></td><td><code>lines(Path path)</code></td><td>流元素为文件中的行，字符集默认为 <code>UTF-8</code></td></tr><tr><td><code>static Stream&lt;String&gt;</code></td><td><code>lines(Path path, Charset cs)</code></td><td>流元素为文件中的行，可指定字符集</td></tr></tbody></table><h1 id="四-中间操作"><a href="#四-中间操作" class="headerlink" title="四 中间操作"></a>四 中间操作</h1><h2 id="4-1-筛选和切片"><a href="#4-1-筛选和切片" class="headerlink" title="4.1 筛选和切片"></a>4.1 筛选和切片</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Stream&lt;T&gt;</code></td><td><code>filter(Predicate&lt;? super T&gt; predicate)</code></td><td>由所有符合条件的元素构成一个流</td></tr><tr><td><code>Stream&lt;T&gt;</code></td><td><code>takeWhile(Predicate&lt;? super T&gt; predicate)</code></td><td>从第一个元素开始匹配，遇到不匹配就停止，由所有筛选出的元素构成一个流</td></tr><tr><td><code>Stream&lt;T&gt;</code></td><td><code>dropWhile(Predicate&lt;? super T&gt; predicate)</code></td><td>从第一个元素开始匹配，由第一个不匹配的元素及其之后的所有元素构成一个流</td></tr><tr><td><code>Stream&lt;T&gt;</code></td><td><code>distinct()</code></td><td>去重</td></tr><tr><td><code>Stream&lt;T&gt;</code></td><td><code>limit(long maxSize)</code></td><td>限制数量</td></tr><tr><td><code>Stream&lt;T&gt;</code></td><td><code>skip(long n)</code></td><td>跳过前 n 个元素，若数量不够则返回空流</td></tr></tbody></table><h2 id="4-2-排序"><a href="#4-2-排序" class="headerlink" title="4.2 排序"></a>4.2 排序</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Stream&lt;T&gt;</code></td><td><code>sorted()</code></td><td>自然排序</td></tr><tr><td><code>Stream&lt;T&gt;</code></td><td><code>sorted​(Comparator&lt;? super T&gt; comparator)</code></td><td>定制排序</td></tr></tbody></table><h2 id="4-3-映射"><a href="#4-3-映射" class="headerlink" title="4.3 映射"></a>4.3 映射</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;R&gt; Stream&lt;R&gt;</code></td><td><code>map​(Function&lt;? super T,​? extends R&gt; mapper)</code></td><td>流中每个元素映射为一个新元素，所有新元素组成流，新旧流元素个数相同</td></tr><tr><td><code>&lt;R&gt; Stream&lt;R&gt;</code></td><td><code>flatMap​(Function&lt;? super T,​? extends Stream&lt;? extends R&gt;&gt; mapper)</code></td><td>流中每个元素都映射为一个流，所有流连接为一个新流（即映射成的每个流中的元素组成新流），新旧流元素个数可能不同</td></tr></tbody></table><h2 id="4-4-操作"><a href="#4-4-操作" class="headerlink" title="4.4 操作"></a>4.4 操作</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Stream&lt;T&gt;</code></td><td><code>peek​(Consumer&lt;? super T&gt; action)</code></td><td>流中元素不变，对每个元素进行一些操作</td></tr><tr><td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td><td><code>concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</code></td><td>由流 <code>a</code> 的一个元素后跟流 <code>b</code> 的一个元素组成的元素构成一个流</td></tr></tbody></table><h1 id="五-终止操作"><a href="#五-终止操作" class="headerlink" title="五 终止操作"></a>五 终止操作</h1><h2 id="5-1-迭代"><a href="#5-1-迭代" class="headerlink" title="5.1 迭代"></a>5.1 迭代</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>forEach​(Consumer&lt;? super T&gt; action)</code></td><td>迭代流中元素</td></tr><tr><td><code>Iterator&lt;T&gt;</code></td><td><code>iterator()</code></td><td>旧式迭代器</td></tr></tbody></table><h2 id="5-2-统计"><a href="#5-2-统计" class="headerlink" title="5.2 统计"></a>5.2 统计</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>long</code></td><td><code>count()</code></td><td>统计流中元素个数</td></tr></tbody></table><h2 id="5-3-匹配"><a href="#5-3-匹配" class="headerlink" title="5.3 匹配"></a>5.3 匹配</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>anyMatch​(Predicate&lt;? super T&gt; predicate)</code></td><td>是否有任意元素匹配</td></tr><tr><td><code>boolean</code></td><td><code>allMatch​(Predicate&lt;? super T&gt; predicate)</code></td><td>是否全部元素都匹配</td></tr><tr><td><code>boolean</code></td><td><code>noneMatch​(Predicate&lt;? super T&gt; predicate)</code></td><td>是否没有元素匹配</td></tr></tbody></table><h2 id="5-4-查找"><a href="#5-4-查找" class="headerlink" title="5.4 查找"></a>5.4 查找</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Optional&lt;T&gt;</code></td><td><code>findFirst()</code></td><td>返回流中第一个元素</td></tr><tr><td><code>Optional&lt;T&gt;</code></td><td><code>findAny()</code></td><td>返回流中任意一个元素（如果是稳定流，也返回第一个元素）</td></tr><tr><td><code>Optional&lt;T&gt;</code></td><td><code>max​(Comparator&lt;? super T&gt; comparator)</code></td><td>返回流中最大元素，使用给定比较器定义的排序规则</td></tr><tr><td><code>Optional&lt;T&gt;</code></td><td><code>min​(Comparator&lt;? super T&gt; comparator)</code></td><td>返回流中最小元素</td></tr></tbody></table><h2 id="5-5-归约"><a href="#5-5-归约" class="headerlink" title="5.5 归约"></a>5.5 归约</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Optional&lt;T&gt;</code></td><td><code>reduce​(BinaryOperator&lt;T&gt; accumulator)</code></td><td>元素1和元素2运算获取累计结果，结果再和下一个元素运算获取累计结果…，直到获取最终结果，由于流可能没有元素，所以返回 <code>Optional</code></td></tr><tr><td><code>T</code></td><td><code>reduce​(T identity, BinaryOperator&lt;T&gt; accumulator)</code></td><td>同上，只是指定一个初始元素，由于肯定有值，所以不用返回 <code>Optional</code></td></tr></tbody></table><h2 id="5-6-收集"><a href="#5-6-收集" class="headerlink" title="5.6 收集"></a>5.6 收集</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;R,A&gt; R</code></td><td><code>collect​(Collector&lt;? super T,​A,​R&gt; collector)</code></td><td>使用指定收集器收集流中元素</td></tr><tr><td><code>Object[]</code></td><td><code>toArray[]</code></td><td>收集到对象数组中</td></tr><tr><td><code>&lt;A&gt; A[]</code></td><td><code>toArray(IntFunction&lt;A[]&gt; generator)</code></td><td>传入 <code>A[]::new</code> 收集到 <code>A[]</code> 类型数组中</td></tr></tbody></table><h1 id="六-流收集器"><a href="#六-流收集器" class="headerlink" title="六 流收集器"></a>六 流收集器</h1><h2 id="6-1-收集器接口：Collector-lt-T-A-R-gt"><a href="#6-1-收集器接口：Collector-lt-T-A-R-gt" class="headerlink" title="6.1 收集器接口：Collector&lt;T,A,R&gt;"></a>6.1 收集器接口：<code>Collector&lt;T,A,R&gt;</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Supplier&lt;A&gt; <span class="title">supplier</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">BiConsumer&lt;A, T&gt; <span class="title">accumulator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Function&lt;A, R&gt; <span class="title">finisher</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">BinaryOperator&lt;A&gt; <span class="title">combiner</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span></span>;</span><br><span class="line">T：是流中要收集的元素的泛型。</span><br><span class="line">A：是累加器的类型，累加器是在收集过程中用于累积部分结果的对象。</span><br><span class="line">R 是收集操作得到的对象（通常但并不一定是集合）的类型</span><br></pre></td></tr></table></figure><h3 id="1-supplier：建立新的结果容器"><a href="#1-supplier：建立新的结果容器" class="headerlink" title="1 supplier：建立新的结果容器"></a>1 <code>supplier</code>：建立新的结果容器</h3><ol><li><code>supplier</code> 方法必须返回一个结果为空的 <code>Supplier</code> ，调用此 <code>Supplier</code> 时创建一个空的累加器实例（结果容器），供数据收集过程使用</li><li>累加器类型为 <code>A</code></li></ol><h3 id="2-accumulator：将元素添加到结果容器"><a href="#2-accumulator：将元素添加到结果容器" class="headerlink" title="2 accumulator：将元素添加到结果容器"></a>2 <code>accumulator</code>：将元素添加到结果容器</h3><ol><li><code>accumulator</code> 方法会返回执行归约操作的函数</li><li>返回的函数有两个参数（假设遍历到流中第 <code>n</code> 个元素）<ol><li>保存归约结果的累加器（已收集了流中的前 <code>n - 1</code> 个项目）</li><li>第 <code>n</code> 个元素本身</li></ol></li></ol><h3 id="3-finisher：对结果容器应用最终转换"><a href="#3-finisher：对结果容器应用最终转换" class="headerlink" title="3 finisher：对结果容器应用最终转换"></a>3 <code>finisher</code>：对结果容器应用最终转换</h3><ol><li>在遍历完流后， <code>finisher</code> 方法必须返回在累积过程的最后要调用的一个函数，以便将累加器对象转换为整个集合操作的最终结果</li><li>如果累加器对象恰好符合预期的最终结果，则无需进行转换，只需返回 <code>Function.identity()</code></li></ol><h3 id="4-combiner：合并两个结果容器"><a href="#4-combiner：合并两个结果容器" class="headerlink" title="4 combiner：合并两个结果容器"></a>4 <code>combiner</code>：合并两个结果容器</h3><ol><li><code>combiner</code> 方法会返回一个供归约操作使用的函数，它定义了对流的各个子部分进行并行处理时，各个子部分归约所得的累加器要如何合并</li><li>并行流使用，将多个线程产生的结果容器合并</li></ol><h3 id="5-characteristics"><a href="#5-characteristics" class="headerlink" title="5 characteristics"></a>5 <code>characteristics</code></h3><ol><li><code>characteristics</code> 会返回一个不可变的 <code>Characteristics</code> 集合，它定义了收集器的行为——尤其是关于流是否可以并行归约，以及可以使用哪些优化的提示</li><li><code>Characteristics</code> 是一个包含三个项目的枚举<ul><li><code>UNORDERED</code><ul><li>归约结果不受流中元素的遍历和累积顺序的影响</li></ul></li><li><code>CONCURRENT</code><ul><li><code>accumulator</code> 函数可以从多个线程同时调用，且该收集器可以并行归约流</li><li>如果收集器没有标为 <code>UNORDERED</code> ，那它仅在用于无序数据源时才可以并行归约</li></ul></li><li><code>IDENTITY_FINISH</code><ul><li>表明完成器方法返回的函数是一个恒等函数，可以跳过。</li><li>这种情况下，累加器对象将会直接用作归约过程的最终结果。这也意味着，将累加器 <code>A</code> 不加检查地转换为结果 <code>R</code> 是安全的</li></ul></li></ul></li></ol><h2 id="6-2-预定于收集器：Collectors"><a href="#6-2-预定于收集器：Collectors" class="headerlink" title="6.2 预定于收集器：Collectors"></a>6.2 预定于收集器：<code>Collectors</code></h2><h3 id="1-收集"><a href="#1-收集" class="headerlink" title="1 收集"></a>1 收集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()</span><br><span class="line">toMap()</span><br><span class="line">toConcurrentMap()</span><br><span class="line"><span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt; Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory)</span><br></pre></td></tr></table></figure><table><thead><tr><th>工厂方法</th><th>返回类型</th><th>说明</th></tr></thead><tbody><tr><td><code>toList</code></td><td><code>List&lt;T&gt;</code></td><td>把流中所有项目收集到一个 List（类型不确定）</td></tr><tr><td><code>toSet</code></td><td><code>Set&lt;T&gt;</code></td><td>把流中所有项目收集到一个 Set（类型不确定），删除重复项</td></tr><tr><td><code>toCollection</code></td><td><code>Collection&lt;T&gt;</code></td><td>把流中所有项目收集到给定的供应源创建的集合，既可以指定集合具体类型</td></tr></tbody></table><h3 id="2-归约和汇总"><a href="#2-归约和汇总" class="headerlink" title="2 归约和汇总"></a>2 归约和汇总</h3><h4 id="1-统计个数，最小-大值"><a href="#1-统计个数，最小-大值" class="headerlink" title="1 统计个数，最小/大值"></a>1 统计个数，最小/大值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Long&gt; counting()</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; minBy(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span><br></pre></td></tr></table></figure><table><thead><tr><th>工厂方法</th><th>返回类型</th><th>说明</th></tr></thead><tbody><tr><td><code>counting</code></td><td><code>Long</code></td><td>计算流中元素的个数</td></tr><tr><td><code>minBy</code></td><td><code>Optional&lt;T&gt;</code></td><td>一个包裹了流中按照给定比较器选出的最小元素的 <code>Optional</code> ，或如果流为空则为 <code>Optional.empty()</code></td></tr><tr><td><code>maxBy</code></td><td><code>Optional&lt;T&gt;</code></td><td>一个包裹了流中按照给定比较器选出的最大元素的 <code>Optional</code> ，或如果流为空则为 <code>Optional.empty()</code></td></tr></tbody></table><h4 id="2-和-平均值"><a href="#2-和-平均值" class="headerlink" title="2 和/平均值"></a>2 和/平均值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Long&gt; summingLong(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; summingDouble(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingLong(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br></pre></td></tr></table></figure><table><thead><tr><th>工厂方法</th><th>返回类型</th><th>说明</th></tr></thead><tbody><tr><td><code>summingInt</code></td><td><code>Integer</code></td><td>对流中元素的一个整数属性求和</td></tr><tr><td><code>summingLong</code></td><td><code>Long</code></td><td>对流中元素的一个长整型属性求和</td></tr><tr><td><code>summingDouble</code></td><td><code>Double</code></td><td>对流中元素的一个浮点型属性求和</td></tr><tr><td><code>averagingInt</code></td><td><code>Double</code></td><td>对流中元素的一个整数属性求平均值</td></tr><tr><td><code>averagingLong</code></td><td><code>Double</code></td><td>对流中元素的一个长整型属性求平均值</td></tr><tr><td><code>averagingDouble</code></td><td><code>Double</code></td><td>对流中元素的一个浮点型属性求平均值</td></tr></tbody></table><h4 id="3-统计个数-最小-大值-和-平均值"><a href="#3-统计个数-最小-大值-和-平均值" class="headerlink" title="3 统计个数 + 最小/大值 + 和/平均值"></a>3 统计个数 + 最小/大值 + 和/平均值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, LongSummaryStatistics&gt; summarizingLong(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, DoubleSummaryStatistics&gt; summarizingDouble(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br></pre></td></tr></table></figure><table><thead><tr><th>工厂方法</th><th>返回类型</th><th>说明</th></tr></thead><tbody><tr><td><code>summarizingInt</code></td><td><code>IntSummaryStatistics</code></td><td>收集流中元素统计个数 + 最小/大值 + 和/平均值</td></tr><tr><td><code>summarizingLong</code></td><td><code>LongSummaryStatistics</code></td><td>收集流中元素统计个数 + 最小/大值 + 和/平均值</td></tr><tr><td><code>summarizingDouble</code></td><td><code>DoubleSummaryStatistics</code></td><td>收集流中元素统计个数 + 最小/大值 + 和/平均值</td></tr></tbody></table><ul><li><p>返回类型中提供了相应的 <code>getter</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getCount()</span><br><span class="line">getMin()</span><br><span class="line">getMax()</span><br><span class="line">getSum()</span><br><span class="line">getAverage()</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-连接字符串"><a href="#4-连接字符串" class="headerlink" title="4 连接字符串"></a>4 连接字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static Collector&lt;CharSequence, ?, String&gt; joining()</span><br><span class="line">static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter)</span><br><span class="line">static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)</span><br></pre></td></tr></table></figure><table><thead><tr><th>工厂方法</th><th>返回类型</th><th>说明</th></tr></thead><tbody><tr><td><code>joining</code></td><td><code>String</code></td><td>连接对流中每个元素调用 <code>toString</code> 方法所生成的字符串，可指定分隔符、前缀、后缀</td></tr></tbody></table><h4 id="5-广义的归约汇总"><a href="#5-广义的归约汇总" class="headerlink" title="5 广义的归约汇总"></a>5 广义的归约汇总</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; reducing(BinaryOperator&lt;T&gt; op)</span><br><span class="line">static &lt;T&gt; Collector&lt;T, ?, T&gt; reducing(T identity, BinaryOperator&lt;T&gt; op)</span><br><span class="line">static &lt;T, U&gt; Collector&lt;T, ?, U&gt; reducing(U identity, Function&lt;? super T, ? extends U&gt; mapper, BinaryOperator&lt;U&gt; op)</span><br></pre></td></tr></table></figure><table><thead><tr><th>工厂方法</th><th>返回类型</th><th>说明</th></tr></thead><tbody><tr><td><code>reducing</code></td><td>归约操作产生的类型</td><td>从一个作为累加器的初始值开始，利用 <code>BinaryOperator</code> 与流中的元素逐个结合，从而将流归约为单个值</td></tr></tbody></table><ol><li>以上所有归约和汇总收集器都是 <code>reducing</code> 工厂方法定义的归约过程的特殊情况而已，仅仅是为了方便程序员使用而已</li><li>三个参数<ul><li>初始值</li><li>转换函数</li><li>累计函数</li></ul></li></ol><h3 id="3-分组"><a href="#3-分组" class="headerlink" title="3 分组"></a>3 分组</h3><h4 id="1-分组"><a href="#1-分组" class="headerlink" title="1 分组"></a>1 分组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一级分组：根据 T 的某个属性 K 分组，返回 Map&lt;K, list&lt;T&gt;&gt;</span></span><br><span class="line"><span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier)</span><br><span class="line"><span class="comment">// 多级分组：根据 T 的某个属性 K 分组，返回 Map&lt;K, list&lt;T&gt;&gt;，之后使用第三个参数队属性 K 收集，返回 Map&lt;K, D&gt;</span></span><br><span class="line"><span class="keyword">static</span> &lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier, Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream)</span><br><span class="line"><span class="comment">// 多级分组：可以自己提供 Map 类型</span></span><br><span class="line"><span class="keyword">static</span> &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt; Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier, Supplier&lt;M&gt; mapFactory, Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream)</span><br></pre></td></tr></table></figure><table><thead><tr><th>工厂方法</th><th>返回类型</th><th>说明</th></tr></thead><tbody><tr><td><code>groupingBy</code></td><td><code>Map&lt;K, List&lt;T&gt;&gt;</code></td><td>根据元素某个属性映射的值分组，并作为键，元素收集到 <code>List</code> 中作为值（单参数的 <code>groupingBy</code> 其实第二个参数省略了 <code>Collectors.toList()</code>）</td></tr><tr><td><code>groupingBy</code></td><td><code>Map&lt;K, D&gt;</code></td><td>根据元素某个属性映射的值分组，并作为键，第二个收集器返回值作为值</td></tr></tbody></table><ul><li><code>groupingByConcurrent</code> 返回的是 <code>ConcurrentMap</code></li></ul><h4 id="2-常与分组联合使用的收集器"><a href="#2-常与分组联合使用的收集器" class="headerlink" title="2 常与分组联合使用的收集器"></a>2 常与分组联合使用的收集器</h4><h5 id="1-collectingAndThen"><a href="#1-collectingAndThen" class="headerlink" title="1 collectingAndThen"></a>1 <code>collectingAndThen</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将第一个参数（旧收集器）的结果传入第二个参数（转换函数）返回新的类型</span><br><span class="line">static &lt;T, A, R, RR&gt; Collector&lt;T, A, RR&gt; collectingAndThen(Collector&lt;T, A, R&gt; downstream, Function&lt;R, RR&gt; finisher)</span><br></pre></td></tr></table></figure><table><thead><tr><th>工厂方法</th><th>返回类型</th><th>说明</th></tr></thead><tbody><tr><td><code>collectingAndThen</code></td><td>转换函数返回的类型</td><td>包裹另一个收集器，对其结果应用转换函数</td></tr></tbody></table><h5 id="2-mapping"><a href="#2-mapping" class="headerlink" title="2 mapping"></a>2 <code>mapping</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T, U, A, R&gt; Collector&lt;T, ?, R&gt; mapping(Function&lt;? super T, ? extends U&gt; mapper, Collector&lt;? super U, A, R&gt; downstream)</span><br></pre></td></tr></table></figure><table><thead><tr><th>工厂方法</th><th>返回类型</th><th>说明</th></tr></thead><tbody><tr><td><code>mapping</code></td><td>转换函数返回的类型</td><td>原收集器中的每个元素映射为一个新值，并使用一个新收集器收集</td></tr></tbody></table><h3 id="4-分区"><a href="#4-分区" class="headerlink" title="4 分区"></a>4 分区</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一级分区</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span><br><span class="line"><span class="comment">// 多级分区</span></span><br><span class="line"><span class="keyword">static</span> &lt;T, D, A&gt; Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate, Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream)</span><br></pre></td></tr></table></figure><table><thead><tr><th>工厂方法</th><th>返回类型</th><th>说明</th></tr></thead><tbody><tr><td><code>partitioningBy</code></td><td><code>Map&lt;Boolean,List&lt;T&gt;&gt;</code></td><td>根据对流中每个元素应用谓词的结果来对元素进行分区</td></tr></tbody></table><ol><li>分区是分组的特殊情况：由一个谓词（返回一个布尔值的函数）作为分类函数，它称分区函数</li><li>分区函数返回一个布尔值，这意味着得到的分组 Map 的键类型是 <code>Boolean</code> ，即最多可以分为两组—— <code>true</code> 是一组， <code>false</code> 是一组</li></ol><h1 id="七-基本类型流"><a href="#七-基本类型流" class="headerlink" title="七 基本类型流"></a>七 基本类型流</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ol><li>流操作基本类型时暗含装箱操作，Java8 提供了基本类型流来解决<ol><li><code>IntStream</code>：<code>byte short char int boolean</code></li><li><code>DoubleStream</code>：<code>float double</code></li><li><code>LongStream</code>：<code>long</code></li></ol></li><li><code>IntStream DoubleStream LongStream</code> 分别将流中的元素转为 <code>int double long</code> ，从而避免了暗含的装箱成本，且每个接口有新的常用数值归约方法以及转回对象流的方法</li></ol><h2 id="7-2-对象流与基本类型流的转换"><a href="#7-2-对象流与基本类型流的转换" class="headerlink" title="7.2 对象流与基本类型流的转换"></a>7.2 对象流与基本类型流的转换</h2><h3 id="1-对象流-→-基本类型流"><a href="#1-对象流-→-基本类型流" class="headerlink" title="1 对象流 → 基本类型流"></a>1 对象流 → 基本类型流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IntStream <span class="title">mapToInt</span><span class="params">(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span></span><br><span class="line"><span class="function">DoubleStream <span class="title">mapToDouble</span><span class="params">(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span></span><br><span class="line"><span class="function">LongStream <span class="title">mapToLong</span><span class="params">(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span></span><br></pre></td></tr></table></figure><h3 id="2-基本类型流-→-对象流"><a href="#2-基本类型流-→-对象流" class="headerlink" title="2 基本类型流 → 对象流"></a>2 基本类型流 → 对象流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;Integer&gt; <span class="title">boxed</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Stream&lt;Double&gt; <span class="title">boxed</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Stream&lt;Long&gt; <span class="title">boxed</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&lt;U&gt; Stream&lt;U&gt; <span class="title">mapToObj</span><span class="params">(IntFunction&lt;? extends U&gt; mapper)</span></span></span><br></pre></td></tr></table></figure><h2 id="7-3-IntStream"><a href="#7-3-IntStream" class="headerlink" title="7.3 IntStream"></a>7.3 <code>IntStream</code></h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static IntStream</code></td><td><code>range(int start, int end)</code></td><td><code>[start, end)</code> 范围内数值构成流</td></tr><tr><td><code>static IntStream</code></td><td><code>rangeClosed(int start, int end)</code></td><td><code>[start, end]</code> 范围内数值构成流</td></tr><tr><td><code>int</code></td><td><code>sum()</code></td><td>求和</td></tr><tr><td><code>OptionalInt</code></td><td><code>max()</code></td><td>求最大值</td></tr><tr><td><code>OptionalInt</code></td><td><code>min()</code></td><td>求最小值</td></tr><tr><td><code>long</code></td><td><code>count()</code></td><td>统计个数</td></tr></tbody></table><h1 id="八-并行流"><a href="#八-并行流" class="headerlink" title="八 并行流"></a>八 并行流</h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><ol><li>并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流</li><li>并行流背后使用的基础架构是 Java 7 中引入的分支/合并框架（<code>Fork/Join</code>）</li></ol><h2 id="8-2-转换"><a href="#8-2-转换" class="headerlink" title="8.2 转换"></a>8.2 转换</h2><ol><li><code>parallel()</code>：顺序流 → 并行流</li><li><code>sequential()</code>：并行流 → 顺序流</li></ol><h2 id="8-3-Spliterator-lt-T-gt"><a href="#8-3-Spliterator-lt-T-gt" class="headerlink" title="8.3 Spliterator&lt;T&gt;"></a>8.3 <code>Spliterator&lt;T&gt;</code></h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/spliterator.png" alt=""></p><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li><code>Spliterator</code> 是 Java 8中加入的一个新接口；这个名字代表“可分迭代器”（<code>splitable iterator</code>）</li><li>和 <code>Iterator</code> 一样， <code>Spliterator</code> 也用于遍历数据源中的元素，但它是为了并行执行而设计的</li><li>Java 8 为集合框架中包含的所有数据结构提供了一个默认的 <code>Spliterator</code> 实现</li></ol><h3 id="2-API"><a href="#2-API" class="headerlink" title="2 API"></a>2 API</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>tryAdvance(Consumer&lt;? super T&gt; action)</code></td><td>按顺序一个一个使用 <code>Spliterator</code> 中的元素，并且如果还有元素要遍历就返回 <code>true</code></td></tr><tr><td><code>Spliterator&lt;T&gt;</code></td><td><code>trySplit()</code></td><td>把一些元素划出去分给第二个 <code>Spliterator</code> （由该方法返回），让它们两个并行处理。当返回 <code>null</code> 时 ，表明它处理的数据结构不能再分割</td></tr><tr><td><code>long</code></td><td><code>estimateSize()</code></td><td>估计还剩下多少元素要遍历</td></tr><tr><td><code>int</code></td><td><code>characteristics()</code></td><td>返回一个 <code>int</code> ，代表 <code>Spliterator</code> 本身特性集的编码</td></tr></tbody></table><h3 id="3-特性"><a href="#3-特性" class="headerlink" title="3 特性"></a>3 特性</h3><table><thead><tr><th>特性 <code>int</code></th><th>说明</th></tr></thead><tbody><tr><td><code>ORDERED</code></td><td>元素有既定的顺序（例如 <code>List</code> ），因此 <code>Spliterator</code> 在遍历和划分时也会遵循这一顺序</td></tr><tr><td><code>DISTINCT</code></td><td>对于任意一对遍历过的元素 x 和 y ， <code>x.equals(y)</code> 返回 <code>false</code></td></tr><tr><td><code>SORTED</code></td><td>遍历的元素按照一个预定义的顺序排序</td></tr><tr><td><code>SIZED</code></td><td>该 <code>Spliterator</code> 由一个已知大小的源建立（例如 <code>Set</code> ），因此 <code>estimatedSize()</code> 返回的是准确值</td></tr><tr><td><code>NONNULL</code></td><td>保证遍历的元素不会为 <code>null</code></td></tr><tr><td><code>IMMUTABLE</code></td><td><code>Spliterator</code> 的数据源不能修改。这意味着在遍历时不能添加、删除或修改任何元素</td></tr><tr><td><code>CONCURRENT</code></td><td>该 <code>Spliterator</code> 的数据源可以被其他线程同时修改而无需同步</td></tr><tr><td><code>SUBSIZED</code></td><td>该 <code>Spliterator</code> 和所有从它拆分出来的 <code>Spliterator</code> 都是 <code>SIZED</code></td></tr></tbody></table><h1 id="九-java-util-Optional-lt-T-gt"><a href="#九-java-util-Optional-lt-T-gt" class="headerlink" title="九 java.util.Optional&lt;T&gt;"></a>九 <code>java.util.Optional&lt;T&gt;</code></h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><ol><li><code>Optional&lt;T&gt;</code> 是一种包装器对象，且只包装一个对象：<code>T</code> 或 <code>null</code><ul><li>对象存在时，则返回封装对象的 <code>Optional</code></li><li>对象不存在时，由方法 <code>Optional.empty()</code> 返回一个空的 <code>Optional</code></li></ul></li><li>使用原则<ul><li>不能为 <code>null</code> 的属性正常声明 <code>T</code></li><li>可能为 <code>null</code> 的属性声明为 <code>Optional&lt;T&gt;</code></li></ul></li><li><code>Optional&lt;T&gt;</code> 也有三个基本类型版本：<code>OptionalInt、OptionalDouble、OptionalLong</code></li></ol><h2 id="9-2-API"><a href="#9-2-API" class="headerlink" title="9.2 API"></a>9.2 API</h2><h3 id="1-创建-Optional"><a href="#1-创建-Optional" class="headerlink" title="1 创建 Optional"></a>1 创建 <code>Optional</code></h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static &lt;T&gt; Optional&lt;T&gt;</code></td><td><code>empty()</code></td><td>返回空的 <code>Optional</code></td></tr><tr><td><code>static &lt;T&gt; Optional&lt;T&gt;</code></td><td><code>of​(T t)</code></td><td>将指定值用 <code>Optional</code> 封装之后返回，如果该值为 <code>null</code> ，则抛出一个 <code>NullPointerException</code> 异常</td></tr><tr><td><code>static &lt;T&gt; Optional&lt;T&gt;</code></td><td><code>ofNullable​(T t)</code></td><td>将指定值用 <code>Optional</code> 封装之后返回，如果该值为 <code>null</code> ，则返回一个空的 <code>Optional</code> 对象</td></tr></tbody></table><h3 id="2-获取-Optional-容器中的值"><a href="#2-获取-Optional-容器中的值" class="headerlink" title="2 获取 Optional 容器中的值"></a>2 获取 <code>Optional</code> 容器中的值</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>T</code></td><td><code>get()</code></td><td>如果值存在则返回，否则抛 <code>NoSuchElementException</code> 异常</td></tr><tr><td><code>T</code></td><td><code>orElse​(T other)</code></td><td>如果值存在则返回，否则返回 <code>other</code></td></tr><tr><td><code>T</code></td><td><code>orElseGet​(Supplier&lt;? extends T&gt; supplier)</code></td><td>如果值存在则返回，否则返回由 <code>Supplier</code> 提供的值</td></tr><tr><td><code>&lt;X extends Throwable&gt; T</code></td><td><code>orElseThrow​(Supplier&lt;? extends X&gt; exceptionSupplier)</code></td><td>如果值存在则返回，否则抛出由 <code>Supplier</code> 提供的异常</td></tr></tbody></table><h3 id="3-操作-Optional-中的值"><a href="#3-操作-Optional-中的值" class="headerlink" title="3 操作 Optional 中的值"></a>3 操作 <code>Optional</code> 中的值</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>isPresent()</code></td><td>如果值存在就返回 <code>true</code> ，否则返回 <code>false</code></td></tr><tr><td><code>void</code></td><td><code>ifPresent​(Consumer&lt;? super T&gt; action)</code></td><td>如果值存在则传递给 <code>action</code> 执行；否则就不进行任何操作</td></tr><tr><td><code>void</code></td><td><code>ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)</code></td><td>如果值存在则传递给 <code>action</code> 执行；否则调用 <code>emptyAction</code></td></tr><tr><td><code>&lt;U&gt; Optional&lt;U&gt;</code></td><td><code>map​(Function&lt;? super T,​? extends U&gt; mapper)</code></td><td>如果值存在则映射一个新值（如果映射值为 <code>null</code> 会空指针异常），然后返回存储新值的 <code>Optional</code>；否则返回空的 <code>Optional</code></td></tr><tr><td><code>&lt;U&gt; Optional&lt;U&gt;</code></td><td><code>flatMap​(Function&lt;? super T,​? extends Optional&lt;? extends U&gt;&gt; mapper)</code></td><td><code>map</code> 方法的问题在于如果映射成的值还是一个 <code>Optional</code>，会形成多层 <code>Optional&lt;Optional&lt;T&gt;&gt;</code>，此方法能将多层的 <code>Optional</code> 合并为一个</td></tr><tr><td><code>Optional&lt;T&gt;</code></td><td><code>filter​(Predicate&lt;? super T&gt; predicate)</code></td><td>如果值存在并且满足提供的谓词，就返回包含该值的 <code>Optional</code> 对象；否则返回空的 <code>Optional</code> 对象</td></tr><tr><td><code>Optional&lt;T&gt;</code></td><td><code>or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</code></td><td>如果值存在，则返回存储此值的 <code>Optional</code>，否则返回由 <code>Supplier</code> 提供的 <code>Optional</code></td></tr></tbody></table><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/flatmap.png" alt=""></p><h3 id="4-其它"><a href="#4-其它" class="headerlink" title="4 其它"></a>4 其它</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Stream&lt;T&gt;</code></td><td><code>stream()</code></td><td>如果值存在则获取只包含此元素的流，否则获取空流</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;java.util.stream&lt;/code&gt; 包&lt;/li&gt;
&lt;li&gt;流：从支持数据处理操作的源生成
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="Java" scheme="https://anyeansan.github.io/categories/CS/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-Lambda</title>
    <link href="https://anyeansan.github.io/2020/09/29/Java/Java-Lambda/"/>
    <id>https://anyeansan.github.io/2020/09/29/Java/Java-Lambda/</id>
    <published>2020-09-29T08:01:27.000Z</published>
    <updated>2020-09-29T08:01:40.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-Lambda-概述"><a href="#一-Lambda-概述" class="headerlink" title="一 Lambda 概述"></a>一 Lambda 概述</h1><ol><li>Lambda 是一个匿名函数，但在 Java 中 Lambda 表达式的本质是函数式接口的一个实例，也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用 Lambda 表达式来表示</li><li>Lambda 需要函数式接口的支持</li><li>闭包<ol><li>在 Lambda 表达式中引用了局部变量，会形成闭包，延长局部变量声明周期</li><li>此被引用的局部变量会变成 <code>final</code> 的</li></ol></li></ol><h1 id="二-Lambda-语法"><a href="#二-Lambda-语法" class="headerlink" title="二 Lambda 语法"></a>二 Lambda 语法</h1><h2 id="2-1-基础语法"><a href="#2-1-基础语法" class="headerlink" title="2.1 基础语法"></a>2.1 基础语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(形参列表) -&gt; &#123;方法体&#125;</span><br><span class="line"><span class="comment">// 形参列表：对应函数式接口中抽象方法的形参列表</span></span><br><span class="line"><span class="comment">// 方法体：即重写的函数式接口中抽象方法的方法体</span></span><br></pre></td></tr></table></figure><ol><li>参数类型可以省略（类型推断）</li><li>当且仅当参数只有一个时，可以省略小括号</li><li>如果方法体只有一句，可以省略大括号</li><li>如果方法体只有一句且是返回语句，大括号和 <code>return</code> 要一致<ul><li>省略大括号的同时必须省略 <code>return</code> 关键字</li><li>不省略大括号那么也不能省略 <code>return</code> 关键字</li></ul></li></ol><h2 id="2-2-方法引用"><a href="#2-2-方法引用" class="headerlink" title="2.2 方法引用"></a>2.2 方法引用</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li><p>方法引用即将 Lambda 表达式的实现指向一个已经实现的方法，也就是说通过调用一个现有的方法来完成功能</p></li><li><p>方法引用其实返回的就是一个函数式接口的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只要符合条件就能当成对应函数式接口的实例</span></span><br><span class="line"><span class="comment">// 所谓的符合条件：引用的方法与函数式接口的抽象方法有着相同形参和返回值，比如接收一个类型的参数，返回另一个类型...</span></span><br><span class="line">Consumer consumer = System.out::println;</span><br><span class="line">Runable runable = System.out::println;</span><br></pre></td></tr></table></figure></li><li><p>条件</p><ol><li>引用方法的形参列表（数量、顺序和类型）必须与接口中的方法一致<ul><li>特殊情况：接口中方法的第一个形参是方法的调用者，剩余形参与引用方法一致（即指向类的实例方法的方法引用）</li></ul></li><li>引用方法的返回值必须和接口中的方法一致</li></ol></li></ol><h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2 语法"></a>2 语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line">方法隶属者::方法名</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有三种使用情况</span></span><br><span class="line">对象::实例方法名</span><br><span class="line">类::静态方法名</span><br><span class="line">类::实例方法名</span><br></pre></td></tr></table></figure><ol><li><p>指向对象的实例方法的方法引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(args) -&gt; expr.instanceMethod(args)</span><br><span class="line">expr::instanceMethod</span><br></pre></td></tr></table></figure></li><li><p>指向类的静态方法的方法引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(args) -&gt; ClassName.staticMethod(args)</span><br><span class="line">CLassName::staticMethod</span><br></pre></td></tr></table></figure></li><li><p>指向类的实例方法的方法引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(arg0, rest) -&gt; arg0.instanceMethod(rest)</span><br><span class="line">CLassName::instanceMethod</span><br><span class="line"><span class="comment">// arg0 是 ClassName 类型的实例，即是实例方法的调用者又是方法的第一个参数</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="2-3-构造器引用"><a href="#2-3-构造器引用" class="headerlink" title="2.3 构造器引用"></a>2.3 构造器引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类::<span class="keyword">new</span></span><br></pre></td></tr></table></figure><ol><li>构造器形参列表要与函数式接口中抽象方法的形参列表一致</li><li>新创建的对象与函数式接口中抽象方法的返回值一致</li></ol><h2 id="2-4-数组引用"><a href="#2-4-数组引用" class="headerlink" title="2.4 数组引用"></a>2.4 数组引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组类型[]::<span class="keyword">new</span></span><br></pre></td></tr></table></figure><ul><li>可以把数组看作一个构造器</li></ul><h1 id="三-函数式接口"><a href="#三-函数式接口" class="headerlink" title="三 函数式接口"></a>三 函数式接口</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol><li><code>SAM：Simple Abstract Method</code></li><li>有且仅有一个抽象方法的接口就是函数式接口，可以有其它方法（静态，默认…）</li><li><code>@FunctionalInterface</code>：此注解用来标识函数式接口</li><li><code>java.lang.util.function</code> 包下定义了许多函数式接口</li></ol><h2 id="3-2-常用函数式接口"><a href="#3-2-常用函数式接口" class="headerlink" title="3.2 常用函数式接口"></a>3.2 常用函数式接口</h2><table><thead><tr><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>接口方法</th><th>说明</th><th>原始类型特化</th></tr></thead><tbody><tr><td><code>Predicate&lt;T&gt;</code></td><td><code>T</code></td><td><code>boolean</code></td><td><code>boolean test(T t)</code></td><td>传入 <code>T</code>，返回布尔值</td><td><code>IntPredicate</code><br><code>LongPredicate</code><br/><code>DoublePredicate</code></td></tr><tr><td><code>BiPredicate&lt;T, U&gt;</code></td><td><code>T, U</code></td><td><code>boolean</code></td><td><code>boolean test(T t, U u)</code></td><td>传入 <code>T U</code>，返回布尔值</td><td></td></tr><tr><td><code>Consumer&lt;T&gt;</code></td><td><code>T</code></td><td><code>void</code></td><td><code>void accept(T t)</code></td><td>传入 <code>T</code>，无返回</td><td><code>IntConsumer</code><br><code>LongConsumer</code><br/><code>DoubleConsumer</code></td></tr><tr><td><code>BiConsumer&lt;T, U&gt;</code></td><td><code>T, U</code></td><td><code>void</code></td><td><code>void accept(T t, U u)</code></td><td>传入 <code>T U</code>，无返回</td><td><code>ObjIntConsumer&lt;T&gt;</code><br><code>ObjLongConsumer&lt;T&gt;</code><br><code>ObjDoubleConsumer&lt;T&gt;</code></td></tr><tr><td><code>Supplier&lt;T&gt;</code></td><td><code>无</code></td><td><code>T</code></td><td><code>T get()</code></td><td>无传入，返回 <code>T</code></td><td><code>IntSupplier</code><br><code>BooleanSupplier</code><br/><code>LongSupplier</code><br/><code>DoubleSupplier</code></td></tr><tr><td><code>Function&lt;T, R&gt;</code></td><td><code>T</code></td><td><code>R</code></td><td><code>R apply(T t)</code></td><td>传入 <code>T</code>，返回 <code>R</code></td><td><code>IntFunction&lt;R&gt;</code><br><code>LongFunction&lt;R&gt;</code><br/><code>DoubleFunction&lt;R&gt;</code><br><code>ToIntFunction&lt;T&gt;</code><br><code>ToLongFunction&lt;T&gt;</code><br/><code>ToDoubleFunction&lt;T&gt;</code><br><code>IntToLongFunction</code><br><code>IntToDoubleFunction</code><br/><code>LongToIntFunction</code><br/><code>LongToDoubleFunction</code></td></tr><tr><td><code>UnaryOperator&lt;T&gt;</code></td><td><code>T</code></td><td><code>T</code></td><td><code>T apply(T t)</code></td><td>传入 <code>T</code>，返回 <code>T</code>，继承 <code>Function&lt;T, T&gt;</code> 接口</td><td><code>IntUnaryOperator</code><br><code>LongUnaryOperator</code><br><code>DoubleUnaryOperator</code></td></tr><tr><td><code>BiFunction&lt;T, U, R&gt;</code></td><td><code>T, U</code></td><td><code>R</code></td><td><code>R apply(T t, U u)</code></td><td>传入 <code>T U</code> ，返回 <code>R</code></td><td><code>ToIntBiFunction&lt;T,U&gt;</code><br><code>ToLongBiFunction&lt;T,U&gt;</code><br><code>ToDoubleBiFunction&lt;T,U&gt;</code></td></tr><tr><td><code>BinaryOperator&lt;T&gt;</code></td><td><code>T, T</code></td><td><code>T</code></td><td><code>T apply(T t1, T t2)</code></td><td>传入 <code>T T</code> ，返回 <code>T</code>，继承 <code>BiFunction&lt;T, T, T&gt;</code> 接口</td><td><code>IntBinaryOperator</code><br><code>LongBinaryOperator</code><br><code>DoubleBinaryOperator</code></td></tr><tr><td><code>Runnable</code></td><td><code>无</code></td><td><code>void</code></td><td><code>void run()</code></td><td>无传入，无返回</td><td></td></tr><tr><td><code>Comparator&lt;T&gt;</code></td><td><code>T, T</code></td><td><code>int</code></td><td><code>int compare(T t1, T t2)</code></td><td>传入 <code>T T</code>，返回 <code>int</code></td><td></td></tr></tbody></table><h2 id="3-3-复合-Lambda-表达式的有用方法"><a href="#3-3-复合-Lambda-表达式的有用方法" class="headerlink" title="3.3 复合 Lambda 表达式的有用方法"></a>3.3 复合 Lambda 表达式的有用方法</h2><h3 id="1-比较器复合"><a href="#1-比较器复合" class="headerlink" title="1 比较器复合"></a>1 比较器复合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">逆序：reversed</span><br><span class="line">比较器链：thenComparing</span><br></pre></td></tr></table></figure><h3 id="2-谓词复合"><a href="#2-谓词复合" class="headerlink" title="2 谓词复合"></a>2 谓词复合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">非：negate</span><br><span class="line">与：and</span><br><span class="line">或：or</span><br></pre></td></tr></table></figure><h3 id="3-函数复合"><a href="#3-函数复合" class="headerlink" title="3 函数复合"></a>3 函数复合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">andThen</span><br><span class="line">f.anThen(g)：先执行 f 后 执行 g，即 g(f(x))</span><br><span class="line">compose</span><br><span class="line">f.compose(g)：先执行 g 后 执行 f，即 f(g(x))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-Lambda-概述&quot;&gt;&lt;a href=&quot;#一-Lambda-概述&quot; class=&quot;headerlink&quot; title=&quot;一 Lambda 概述&quot;&gt;&lt;/a&gt;一 Lambda 概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Lambda 是一个匿名函数，但在 Java 中 Lam
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="Java" scheme="https://anyeansan.github.io/categories/CS/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-网络编程</title>
    <link href="https://anyeansan.github.io/2020/09/29/Java/Java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://anyeansan.github.io/2020/09/29/Java/Java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2020-09-29T08:00:45.000Z</published>
    <updated>2020-09-29T08:01:02.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-网络模型"><a href="#1-1-网络模型" class="headerlink" title="1.1 网络模型"></a>1.1 网络模型</h2><h3 id="1-OSI（Open-System-Interconnection）"><a href="#1-OSI（Open-System-Interconnection）" class="headerlink" title="1 OSI（Open System Interconnection）"></a>1 OSI（<code>Open System Interconnection</code>）</h3><table><thead><tr><th>层</th><th>说明</th><th>相关协议</th></tr></thead><tbody><tr><td><code>应用层</code></td><td>网络服务和最终用户的接口</td><td><code>HTTP HTTPS FTP SMTP POP3 DNS ...</code></td></tr><tr><td><code>表示层</code></td><td>数据的表示、安全、压缩</td><td></td></tr><tr><td><code>会话层</code></td><td>建立、管理和终止会话</td><td></td></tr><tr><td><code>传输层</code></td><td>定义传输数据的协议端口号，以及流量控制和差错校验</td><td><code>TCP UDP</code></td></tr><tr><td><code>网络层</code></td><td>进行逻辑地址寻找，实现不同网络间的路径选择</td><td><code>IP ARP RARP ICMP IGMP ...</code></td></tr><tr><td><code>数据链路层</code></td><td>建立逻辑连接、进行硬件地址寻址、差错校验等功能</td><td><code>MAC</code> 地址</td></tr><tr><td><code>物理层</code></td><td>建立，维护，断开物理连接</td><td></td></tr></tbody></table><h3 id="2-TCP-IP-分层模型"><a href="#2-TCP-IP-分层模型" class="headerlink" title="2 TCP/IP 分层模型"></a>2 TCP/IP 分层模型</h3><table><thead><tr><th>层</th><th>相关协议</th></tr></thead><tbody><tr><td><code>应用层</code></td><td><code>HTTP HTTPS FTP DNS ...</code></td></tr><tr><td><code>传输层</code></td><td><code>TCP UDP</code></td></tr><tr><td><code>网络层</code></td><td><code>IP ARP ICMP...</code></td></tr><tr><td><code>物理+数据链路层</code></td><td>硬件层面</td></tr></tbody></table><h2 id="1-2-网络编程"><a href="#1-2-网络编程" class="headerlink" title="1.2 网络编程"></a>1.2 网络编程</h2><ol><li>目的：直接或间接的通过网络协议与其它计算机通信，进行数据交换</li><li>两个问题：<ul><li>如何准确定位网络上的一台或多台主机，以及如果定位主机上特定的应用</li><li>定位后，如何可靠高速的进行数据传输</li></ul></li></ol><h2 id="1-3-网络通信三要素"><a href="#1-3-网络通信三要素" class="headerlink" title="1.3 网络通信三要素"></a>1.3 网络通信三要素</h2><ol><li>IP 地址：确定设备</li><li>端口：确定设备上的程序</li><li>网络协议</li></ol><h2 id="1-4-常见端口"><a href="#1-4-常见端口" class="headerlink" title="1.4 常见端口"></a>1.4 常见端口</h2><table><thead><tr><th>服务</th><th>端口</th></tr></thead><tbody><tr><td><code>HTTP</code></td><td><code>80</code></td></tr><tr><td><code>HTTPS</code></td><td><code>443</code></td></tr><tr><td><code>SSH</code></td><td><code>22</code></td></tr><tr><td><code>Tomcat</code></td><td><code>8080</code></td></tr><tr><td><code>MySQL</code></td><td><code>3306</code></td></tr><tr><td><code>Oracle</code></td><td><code>1521</code></td></tr><tr><td><code>SMTP</code></td><td><code>25</code></td></tr><tr><td><code>POP3</code></td><td><code>110</code></td></tr></tbody></table><h1 id="二-java-net-InetAddress"><a href="#二-java-net-InetAddress" class="headerlink" title="二 java.net.InetAddress"></a>二 <code>java.net.InetAddress</code></h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol><li>用来包装 IP 地址对象</li><li>子类<ol><li><code>Inet4Address</code></li><li><code>Inet6Address</code></li></ol></li></ol><h2 id="2-2-方法"><a href="#2-2-方法" class="headerlink" title="2.2 方法"></a>2.2 方法</h2><h3 id="1-获取-IP-对象"><a href="#1-获取-IP-对象" class="headerlink" title="1 获取 IP 对象"></a>1 获取 IP 对象</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static InetAddress</code></td><td><code>getLocalHost()</code></td><td>获取本地主机 IP 对象，等价于 <code>getByName(&quot;127.0.0.1&quot;)</code></td></tr><tr><td><code>static InetAddress</code></td><td><code>getByName​(String host)</code></td><td>根据主机名（<code>ip</code> 或 域名）获取 IP 对象</td></tr></tbody></table><h3 id="2-获取主机信息"><a href="#2-获取主机信息" class="headerlink" title="2 获取主机信息"></a>2 获取主机信息</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>String</code></td><td><code>getHostName()</code></td><td>获取主机名（域名）</td></tr><tr><td><code>String</code></td><td><code>getHostAddress()</code></td><td>获取主机 IP 地址</td></tr></tbody></table><h1 id="三-Socket"><a href="#三-Socket" class="headerlink" title="三 Socket"></a>三 <code>Socket</code></h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol><li>IP 和端口组合得出一个网络套接字：<code>Socket</code></li><li><code>Socket</code> 是网络通信的一种机制，是两台机器间通信的端点</li><li>分类<ol><li>流套接字（TCP）</li><li>数据报套接字（UDP）</li></ol></li></ol><table><thead><tr><th>类</th><th>说明</th></tr></thead><tbody><tr><td><code>java.net.Socket</code></td><td>TCP 客户端 Socket</td></tr><tr><td><code>java.net.ServerSocket</code></td><td>TCP 服务端 Socket</td></tr><tr><td><code>java.net.DatagramSocket</code></td><td>UDP Socket</td></tr><tr><td><code>java.net.DatagramPacket</code></td><td>UDP 数据包</td></tr></tbody></table><h2 id="3-2-TCP"><a href="#3-2-TCP" class="headerlink" title="3.2 TCP"></a>3.2 TCP</h2><h3 id="1-java-net-Socket（客户端）"><a href="#1-java-net-Socket（客户端）" class="headerlink" title="1 java.net.Socket（客户端）"></a>1 <code>java.net.Socket</code>（客户端）</h3><h4 id="1-构造"><a href="#1-构造" class="headerlink" title="1 构造"></a>1 构造</h4><table><thead><tr><th>构造</th><th>说明</th></tr></thead><tbody><tr><td><code>Socket​(String host, int port)</code></td><td>指定服务端主机地址，以及要连接的服务端口</td></tr><tr><td><code>Socket​(InetAddress address, int port)</code></td><td>指定服务端主机 IP 地址对象，以及要连接的服务端口</td></tr></tbody></table><h4 id="2-方法"><a href="#2-方法" class="headerlink" title="2 方法"></a>2 方法</h4><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>InputStream</code></td><td><code>getInputStream()</code></td><td>获取字节输入流</td></tr><tr><td><code>OutputStream</code></td><td><code>getOutputStream()</code></td><td>获取字节输出流</td></tr><tr><td><code>InetAddress</code></td><td><code>getLocalAddress()</code></td><td>获取 <code>Socket</code> 绑定的本地主机 IP 对象</td></tr><tr><td><code>InetAddress</code></td><td><code>getInetAddress()</code></td><td>获取 <code>Socket</code> 连接的主机 IP 对象</td></tr><tr><td><code>void</code></td><td><code>shutdownInput()</code></td><td>关闭 Socket 输入通道</td></tr><tr><td><code>void</code></td><td><code>shutdownOutput()</code></td><td>关闭 Socket 输出通道</td></tr><tr><td><code>void</code></td><td><code>close()</code></td><td>关闭 <code>Socket</code>，会自动关闭流</td></tr></tbody></table><h3 id="2-java-net-ServerSocket（服务端）"><a href="#2-java-net-ServerSocket（服务端）" class="headerlink" title="2 java.net.ServerSocket（服务端）"></a>2 <code>java.net.ServerSocket</code>（服务端）</h3><h4 id="1-构造-1"><a href="#1-构造-1" class="headerlink" title="1 构造"></a>1 构造</h4><table><thead><tr><th>构造</th><th>说明</th></tr></thead><tbody><tr><td><code>ServerSocket​(int port)</code></td><td>指定服务监听端口</td></tr></tbody></table><h4 id="2-方法-1"><a href="#2-方法-1" class="headerlink" title="2 方法"></a>2 方法</h4><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Socket</code></td><td><code>accept()</code></td><td>等待并接收客户端连接，阻塞方法</td></tr><tr><td><code>void</code></td><td><code>close()</code></td><td>关闭 Socket，会自动关闭流</td></tr></tbody></table><h3 id="3-应用"><a href="#3-应用" class="headerlink" title="3 应用"></a>3 应用</h3><h4 id="1-客户端"><a href="#1-客户端" class="headerlink" title="1 客户端"></a>1 客户端</h4><ol><li>创建 <code>Socket</code> 对象</li><li>使用 <code>Socket</code> 对象获取输入输出流来读写</li><li>关闭 <code>Socket</code></li></ol><h4 id="2-服务端"><a href="#2-服务端" class="headerlink" title="2 服务端"></a>2 服务端</h4><ol><li>创建 <code>ServerSocket</code> 对象，指定监听端口</li><li>使用 <code>ServerSokcet</code> 接收客户端 <code>Socket</code></li><li>使用 <code>Socket</code> 对象获取输入输出流来读写</li><li>关闭 <code>Socket</code></li></ol><h3 id="4-注意：如果服务端和客户端都等待"><a href="#4-注意：如果服务端和客户端都等待" class="headerlink" title="4 注意：如果服务端和客户端都等待"></a>4 注意：如果服务端和客户端都等待</h3><ol><li>数据没有刷新，使用 <code>BufferedReader</code> 包装字节输入流时，<code>readLIne()</code> 结束标记是换行符<ol><li>使用 <code>PrintStream</code> 包装字节输出流，可以自动刷新，如使用 <code>println()</code> </li><li>使用 <code>PrintWrter</code> 包装字节输出流，使用 <code>println()</code> 需要手动刷新或者构造函数中设置自动刷新</li><li>使用 <code>BufferedWriter</code> 包装字节输出流，输出后需要 <code>newLine()</code></li></ol></li><li>阻塞式方法没有结束标记<ul><li><code>void shutdownInput()</code></li><li>``void shutdownOutput()`</li></ul></li></ol><h3 id="5-服务端接收多个客户端连接"><a href="#5-服务端接收多个客户端连接" class="headerlink" title="5 服务端接收多个客户端连接"></a>5 服务端接收多个客户端连接</h3><ol><li><p>将每个客户端的业务封装为线程任务</p></li><li><p>使用多线程实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket ss=<span class="keyword">new</span> ServerSocket(<span class="number">8866</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">Socket socket = ss.accept();</span><br><span class="line"><span class="keyword">new</span> ClientTask(socket).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-3-UDP"><a href="#3-3-UDP" class="headerlink" title="3.3 UDP"></a>3.3 UDP</h2><h3 id="1-java-net-DatagramSocket"><a href="#1-java-net-DatagramSocket" class="headerlink" title="1 java.net.DatagramSocket"></a>1 <code>java.net.DatagramSocket</code></h3><h4 id="1-构造-2"><a href="#1-构造-2" class="headerlink" title="1 构造"></a>1 构造</h4><table><thead><tr><th>构造</th><th>说明</th></tr></thead><tbody><tr><td><code>DatagramSocket()</code></td><td>发送端不用指定端口</td></tr><tr><td><code>DatagramSocket(int port)</code></td><td>接收端需要指定端口</td></tr></tbody></table><h4 id="2-方法-2"><a href="#2-方法-2" class="headerlink" title="2 方法"></a>2 方法</h4><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>send(DatagramPacket p)</code></td><td>发送数据包</td></tr><tr><td><code>void</code></td><td><code>receive(DatagramPacket p)</code></td><td>接收数据包</td></tr><tr><td><code>void</code></td><td><code>close()</code></td><td>关闭 Socket，会自动关闭流</td></tr></tbody></table><h3 id="2-java-net-DatagramPacket"><a href="#2-java-net-DatagramPacket" class="headerlink" title="2 java.net.DatagramPacket"></a>2 <code>java.net.DatagramPacket</code></h3><h4 id="1-构造-3"><a href="#1-构造-3" class="headerlink" title="1 构造"></a>1 构造</h4><table><thead><tr><th>构造</th><th>说明</th></tr></thead><tbody><tr><td><code>DatagramPacket​(byte[] buf, int length)</code></td><td>接收端接收数据包</td></tr><tr><td><code>DatagramPacket​(byte[] buf, int length, InetAddress address, int port)</code></td><td>发送端打包需要指定接收端 IP 和 Port</td></tr></tbody></table><h4 id="2-方法-3"><a href="#2-方法-3" class="headerlink" title="2 方法"></a>2 方法</h4><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>byte[]</code></td><td><code>getData()</code></td><td>接收的数据</td></tr><tr><td><code>int</code></td><td><code>getLength()</code></td><td>接收的数据实际长度</td></tr></tbody></table><h3 id="3-应用-1"><a href="#3-应用-1" class="headerlink" title="3 应用"></a>3 应用</h3><h4 id="1-发送端"><a href="#1-发送端" class="headerlink" title="1 发送端"></a>1 发送端</h4><ol><li>创建 <code>DatagramSocket</code>，不需端口</li><li>创建 <code>DatagramPacket</code> 数据包，指定数据存储数组，长度，接收端 IP 和 Port</li><li>发送数据包</li><li>关闭 <code>DatagramSocket</code></li></ol><h4 id="2-接收端"><a href="#2-接收端" class="headerlink" title="2 接收端"></a>2 接收端</h4><ol><li>创建 <code>DatagramSocket</code>，指定端口</li><li>创建 <code>DatagramPacket</code>，指定数据存储数组，长度</li><li>接收数据包</li><li>从数据包提取数据</li><li>关闭 <code>DatagramSocket</code></li></ol><h1 id="四-java-net-URL"><a href="#四-java-net-URL" class="headerlink" title="四 java.net.URL"></a>四 <code>java.net.URL</code></h1><h2 id="4-1-构造"><a href="#4-1-构造" class="headerlink" title="4.1 构造"></a>4.1 构造</h2><table><thead><tr><th>构造</th><th>说明</th></tr></thead><tbody><tr><td><code>URL​(String spec)</code></td><td>根据 URL 地址字符串构造 URL 对象</td></tr><tr><td><code>URL​(String protocol, String host, int port, String file)</code></td><td>根据指定 protocol、host、port 号和 file 创建 URL 对象</td></tr></tbody></table><h2 id="4-2-方法"><a href="#4-2-方法" class="headerlink" title="4.2 方法"></a>4.2 方法</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>String</code></td><td><code>getProtocol()</code></td><td>获取此 URL 的协议名称</td></tr><tr><td><code>String</code></td><td><code>getHost()</code></td><td>获取此 URL 的主机地址</td></tr><tr><td><code>int</code></td><td><code>getPort()</code></td><td>获取此 URL 的端口号</td></tr><tr><td><code>String</code></td><td><code>getFile()</code></td><td>获取此 URL 的文件资源路径（完整 URI）</td></tr><tr><td><code>String</code></td><td><code>getPath()</code></td><td>获取此 URL 的路径部分（URI不带参数）</td></tr><tr><td><code>String</code></td><td><code>getQuery()</code></td><td>获取此 URL 的查询部分（参数）</td></tr><tr><td><code>URLConnection</code></td><td><code>openConnection()</code></td><td>返回一个 <code>URLConnection</code> 对象，它表示到 URL 所引用的远程对象的连接</td></tr><tr><td><code>InputStream</code></td><td><code>openStream()</code></td><td>打开到此 URL 的连接并返回一个用于从该连接读入的 <code>InputStream</code></td></tr></tbody></table><h1 id="五-java-net-URLConnection"><a href="#五-java-net-URLConnection" class="headerlink" title="五 java.net.URLConnection"></a>五 <code>java.net.URLConnection</code></h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol><li>URL 连接器对象</li><li>表示与 URL 建立的通信连接</li></ol><h2 id="5-2-方法"><a href="#5-2-方法" class="headerlink" title="5.2 方法"></a>5.2 方法</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>URL</code></td><td><code>getURL()</code></td><td>获取此链接的 URL 对象</td></tr><tr><td><code>abstract void</code></td><td><code>connect()</code></td><td>连接</td></tr><tr><td><code>InputStream</code></td><td><code>getInputStream()</code></td><td>获取此链接的字节输入流</td></tr><tr><td><code>OutputStream</code></td><td><code>getOutputStream()</code></td><td>获取此连接的字节输出流</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-网络模型&quot;&gt;&lt;a href=&quot;#1-1-网络模型&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="Java" scheme="https://anyeansan.github.io/categories/CS/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-反射</title>
    <link href="https://anyeansan.github.io/2020/09/29/Java/Java-%E5%8F%8D%E5%B0%84/"/>
    <id>https://anyeansan.github.io/2020/09/29/Java/Java-%E5%8F%8D%E5%B0%84/</id>
    <published>2020-09-29T07:59:44.000Z</published>
    <updated>2020-09-29T08:00:02.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-反射"><a href="#一-反射" class="headerlink" title="一 反射"></a>一 反射</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ol><li>反射 <code>Reflection</code> 允许程序在运行期间：<ul><li>获取任意类型的详细信息</li><li>创建任意类型的对象</li><li>读写任意对象的任意属性</li><li>调用任意对象的任意方法</li><li>读取某个注解信息</li><li>读取某个类的泛型信息</li><li>生成动态代理</li><li>。。。</li></ul></li><li>加载完类之后，在方法区中旧产生了一个 <code>Class</code> 对象（一个类对应一个），此对象包含了类的完整结构信息</li></ol><h2 id="1-2-动态语言-amp-静态语言"><a href="#1-2-动态语言-amp-静态语言" class="headerlink" title="1.2 动态语言 &amp; 静态语言"></a>1.2 动态语言 &amp; 静态语言</h2><ol><li>动态语言：<ul><li>运行时可以根据某些条件改变自身结构</li><li><code>Object-C、C#、JavaScript、PHP、Python、Erlang</code></li></ul></li><li>静态语言：<ul><li>运行时结构不可变</li><li><code>Java、C、C++</code></li><li>Java 不是动态语言，但有一定的动态性（利用反射）</li></ul></li></ol><h1 id="二-Java-类型"><a href="#二-Java-类型" class="headerlink" title="二 Java 类型"></a>二 Java 类型</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/Java%E7%B1%BB%E5%9E%8B.png" alt=""></p><table><thead><tr><th>类型</th><th>说明</th><th>例</th></tr></thead><tbody><tr><td><code>Type</code></td><td>Java 中所有类型的公共高级接口</td><td></td></tr><tr><td><code>Class</code></td><td>普通类型（类，接口，数组，枚举，注解，基本数据类型，<code>void</code>），没有泛型信息</td><td><code>Person</code></td></tr><tr><td><code>ParameterizedType</code></td><td>参数化类型（即泛型）</td><td><code>Map&lt;String, Integer&gt;</code>，<code>List&lt;T&gt;</code></td></tr><tr><td><code>GenericArrayType</code></td><td>泛型数组类型</td><td><code>T[]</code>，<code>List&lt;T&gt;[]</code></td></tr><tr><td><code>TypeVariable&lt;D&gt;</code></td><td>类型变量（即泛型中的变量）</td><td><code>T K V</code></td></tr><tr><td><code>WildcardType</code></td><td>带通配符 <code>?</code> 的类型</td><td><code>List&lt;?&gt;</code>，<code>List&lt;? extends Object&gt;</code></td></tr></tbody></table><h2 id="2-2-ParameterizedType"><a href="#2-2-ParameterizedType" class="headerlink" title="2.2 ParameterizedType"></a>2.2 <code>ParameterizedType</code></h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Type[]</code></td><td><code>getActualTypeArguments()</code></td><td>获取泛型的实际类型，泛型可能有多个，所以返回数组（<strong>该方法只返回最外层的<code>&lt;&gt;</code>中的类型，无论该<code>&lt;&gt;</code>内有多少个<code>&lt;&gt;</code></strong>）</td></tr><tr><td><code>Type</code></td><td><code>getRawType()</code></td><td>获取声明泛型的类或者接口，也就是泛型中<code>&lt;&gt;</code>前面的那个值</td></tr><tr><td><code>Type</code></td><td><code>getOwnerType()</code></td><td>获取泛型的拥有者，例如： <code>Map</code> 就是 <code>Map.Entry&lt;String,String&gt;</code> 的拥有者</td></tr></tbody></table><h1 id="三-java-lang-ClassLoader"><a href="#三-java-lang-ClassLoader" class="headerlink" title="三 java.lang.ClassLoader"></a>三 <code>java.lang.ClassLoader</code></h1><h2 id="3-1-获取-ClassLoader"><a href="#3-1-获取-ClassLoader" class="headerlink" title="3.1 获取 ClassLoader"></a>3.1 获取 ClassLoader</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 获取当前类的 ClassLoader</span></span><br><span class="line">clazz.getClassLoader()</span><br><span class="line"><span class="comment">// 2 获取当前线程上下文的 ClassLoader</span></span><br><span class="line">Thread.currentThread().getContextClassLoader()</span><br><span class="line"><span class="comment">// 3 获取系统的 ClassLoader</span></span><br><span class="line">ClassLoader.getSystemClassLoader()</span><br><span class="line"><span class="comment">// 4 获取调用者的 ClassLoader</span></span><br><span class="line">DriverManager.getCallClassLoader()</span><br><span class="line">Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br></pre></td></tr></table></figure><h2 id="3-2-API"><a href="#3-2-API" class="headerlink" title="3.2 API"></a>3.2 API</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Class&lt;?&gt;</code></td><td><code>loadClass​(String name)</code></td><td>加载指定全限定名的类，返回 <code>Class</code> 对象</td></tr><tr><td><code>protected Class&lt;?&gt;</code></td><td><code>findClass(String name)</code></td><td>查找指定全限定名的类，返回 <code>Class</code> 对象</td></tr><tr><td><code>protected Class&lt;?&gt;</code></td><td><code>defineClass(String name, byte[] b, int off, int len)</code></td><td>将字节数组转为一个 <code>Class</code> 对象</td></tr><tr><td><code>InputStream</code></td><td><code>getResourceAsStream​(String name)</code></td><td>获取指定资源文件的流</td></tr><tr><td><code>URL</code></td><td><code>getResource​(String name)</code></td><td>获取指定资源文件的 URL 对象</td></tr><tr><td><code>ClassLoader</code></td><td><code>getParent()</code></td><td>获取父加载器</td></tr></tbody></table><h2 id="3-3-Class-和-ClassLoader-获取资源"><a href="#3-3-Class-和-ClassLoader-获取资源" class="headerlink" title="3.3 Class 和 ClassLoader 获取资源"></a>3.3 <code>Class</code> 和 <code>ClassLoader</code> 获取资源</h2><h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line">App</span><br><span class="line">src</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">Test.java</span><br><span class="line">hello.xml</span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line">App</span><br><span class="line">WEB-INF</span><br><span class="line">classes</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">Test<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">hello</span>.<span class="title">xml</span></span></span><br></pre></td></tr></table></figure><ol><li><code>Class</code> 和 <code>ClassLoader</code> 资源路径都是相对于编译后的工程结构来说</li><li><code>getResource()</code> 和 <code>getResourceAsStream()</code> 两个方法路径用法是一样的</li></ol><h3 id="2-Class"><a href="#2-Class" class="headerlink" title="2 Class"></a>2 <code>Class</code></h3><ol><li><p>相对路径：相对于当前类的 <code>.class</code> 文件路径</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class.getResouce("hello.xml")</span><br></pre></td></tr></table></figure></li><li><p>绝对路径：<code>/</code> 代表 <code>classpath</code> 根路径，即 <code>classes</code> 目录</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class.getResource("/a/b/hello.xml")</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-ClassLoader"><a href="#3-ClassLoader" class="headerlink" title="3 ClassLoader"></a>3 <code>ClassLoader</code></h3><ul><li><p>默认就是从 <code>classpath</code> 下寻找资源，所以不能写 <code>/</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classLoader.getResource(<span class="string">"a/b/hello.xml"</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-文件流"><a href="#4-文件流" class="headerlink" title="4 文件流"></a>4 文件流</h3><ul><li>文件流是相对于当前工程</li></ul><h1 id="四-java-lang-Class"><a href="#四-java-lang-Class" class="headerlink" title="四 java.lang.Class"></a>四 <code>java.lang.Class</code></h1><h2 id="4-1-获取-Class-对象的方式"><a href="#4-1-获取-Class-对象的方式" class="headerlink" title="4.1 获取 Class 对象的方式"></a>4.1 获取 <code>Class</code> 对象的方式</h2><table><thead><tr><th>方式</th><th>说明</th></tr></thead><tbody><tr><td><code>类.class</code></td><td>编译期这个类型就要存在</td></tr><tr><td><code>类对象.getClass()</code></td><td>需要先创建对象</td></tr><tr><td><code>Class.forName(&quot;全限定类名&quot;)</code></td><td>类型可以在编译期未知，类名可以在代码中或配置文件中等等</td></tr><tr><td><code>类加载器对象.loadClass(&quot;全限定类名&quot;)</code></td><td>一般用在自定义类加载器去加载指定路径的类</td></tr></tbody></table><h2 id="4-2-API"><a href="#4-2-API" class="headerlink" title="4.2 API"></a>4.2 API</h2><h3 id="1-获取-Class-和-ClassLoader"><a href="#1-获取-Class-和-ClassLoader" class="headerlink" title="1 获取 Class 和 ClassLoader"></a>1 获取 <code>Class</code> 和 <code>ClassLoader</code></h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static Class&lt;?&gt;</code></td><td><code>forName​(String className)</code></td><td>根据全限定类名获取 <code>Class</code> 对象</td></tr><tr><td><code>ClassLoader</code></td><td><code>getClassLoader()</code></td><td>获取类加载器对象</td></tr></tbody></table><h3 id="2-获取类信息"><a href="#2-获取类信息" class="headerlink" title="2 获取类信息"></a>2 获取类信息</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Package</code></td><td><code>getPackage()</code></td><td>获取包</td></tr><tr><td><code>String</code></td><td><code>getPackageName()</code></td><td>获取包名</td></tr><tr><td><code>String</code></td><td><code>getName()</code></td><td>获取类名</td></tr><tr><td><code>int</code></td><td><code>getModifiers()</code></td><td>获取类修饰符编号 <code>mod</code></td></tr><tr><td><code>Class&lt;? super T&gt;</code></td><td><code>getSuperclass()</code></td><td>获取父类（不带泛型）</td></tr><tr><td><code>Type</code></td><td><code>getGenericSuperclass()</code></td><td>获取带泛型的父类</td></tr><tr><td><code>Class&lt;?&gt;[]</code></td><td><code>getInterfaces()</code></td><td>获取所有实现的接口（不带泛型）</td></tr><tr><td><code>Type[]</code></td><td><code>getGenericInterfaces()</code></td><td>获取所有实现接口（带泛型）</td></tr></tbody></table><h3 id="3-获取构造器-Constructor"><a href="#3-获取构造器-Constructor" class="headerlink" title="3 获取构造器  Constructor"></a>3 获取构造器  <code>Constructor</code></h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Constructor&lt;?&gt;[]</code></td><td><code>getConstructors()</code></td><td>获取本类所有 <code>public</code> 构造器</td></tr><tr><td><code>Constructor&lt;?&gt;[]</code></td><td><code>getDeclaredConstructors()</code></td><td>获取本类所有构造器</td></tr><tr><td><code>Constructor&lt;T&gt;</code></td><td><code>getConstructor(Class&lt;?&gt;... parameterTypes)</code></td><td>获取本类指定参数类型的 <code>public</code> 构造器</td></tr><tr><td><code>Constructor&lt;T&gt;</code></td><td><code>getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code></td><td>获取本类指定参数类型的构造器</td></tr></tbody></table><h3 id="4-获取属性-Field"><a href="#4-获取属性-Field" class="headerlink" title="4 获取属性 Field"></a>4 获取属性 <code>Field</code></h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Field[]</code></td><td><code>getFields()</code></td><td>获取本类及父类的所有 <code>public</code> 属性</td></tr><tr><td><code>Field[]</code></td><td><code>getDeclaredFields()</code></td><td>获取本类的所有属性</td></tr><tr><td><code>Field</code></td><td><code>getField​(String name)</code></td><td>获取本类及父类中指定名称的 <code>public</code> 属性</td></tr><tr><td><code>Field</code></td><td><code>getDeclaredField​(String name)</code></td><td>获取本类中指定名称的属性</td></tr></tbody></table><h3 id="5-获取方法-Method"><a href="#5-获取方法-Method" class="headerlink" title="5 获取方法 Method"></a>5 获取方法 <code>Method</code></h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Method[]</code></td><td><code>getMethods()</code></td><td>获取本类及父类的所有 <code>public</code> 方法</td></tr><tr><td><code>Method[]</code></td><td><code>getDeclaredMethods()</code></td><td>获取本类的所有方法</td></tr><tr><td><code>Method</code></td><td><code>getMethod​(String name, Class&lt;?&gt;... parameterTypes)</code></td><td>获取本类及父类中指定方法名和参数类型的 <code>public</code> 方法</td></tr><tr><td><code>Method</code></td><td><code>getDeclaredMethod​(String name, Class&lt;?&gt;... parameterTypes)</code></td><td>获取本类中指定方法名和参数类型的方法</td></tr></tbody></table><h3 id="6-获取注解-Annotation"><a href="#6-获取注解-Annotation" class="headerlink" title="6 获取注解 Annotation"></a>6 获取注解 <code>Annotation</code></h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Annotation[]</code></td><td><code>getAnnotations()</code></td><td>获取类上的所有注解</td></tr><tr><td><code>&lt;A extends Annotation&gt; A</code></td><td><code>getAnnotation​(Class&lt;A&gt; annotationClass)</code></td><td>获取类上指定注解类型的注解</td></tr></tbody></table><h1 id="五-java-lang-reflect-包"><a href="#五-java-lang-reflect-包" class="headerlink" title="五 java.lang.reflect 包"></a>五 <code>java.lang.reflect</code> 包</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%8F%8D%E5%B0%84%E5%8C%85.png" alt=""></p><table><thead><tr><th>类</th><th>说明</th></tr></thead><tbody><tr><td><code>AccessibleObject</code></td><td>访问修饰符控制</td></tr><tr><td><code>Modifier</code></td><td>修饰符</td></tr><tr><td><code>Constructor&lt;T&gt;</code></td><td>构造器</td></tr><tr><td><code>Field</code></td><td>属性</td></tr><tr><td><code>Method</code></td><td>方法</td></tr><tr><td><code>Proxy</code></td><td>代理</td></tr></tbody></table><h2 id="5-2-Modifier"><a href="#5-2-Modifier" class="headerlink" title="5.2 Modifier"></a>5.2 <code>Modifier</code></h2><h3 id="1-属性"><a href="#1-属性" class="headerlink" title="1 属性"></a>1 属性</h3><table><thead><tr><th>修饰</th><th>属性</th></tr></thead><tbody><tr><td><code>static int</code></td><td><code>PUBLIC</code></td></tr><tr><td><code>static int</code></td><td><code>PRIVATE</code></td></tr><tr><td><code>...</code></td><td></td></tr></tbody></table><ul><li><p>此类为修饰符定义了常量值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PUBLIC = <span class="number">0x00000001</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRIVATE = <span class="number">0x00000002</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2 方法"></a>2 方法</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static String</code></td><td><code>toString(int mod)</code></td><td>获取编号对应的修饰符</td></tr></tbody></table><h2 id="5-3-AccessibleObject"><a href="#5-3-AccessibleObject" class="headerlink" title="5.3 AccessibleObject"></a>5.3 <code>AccessibleObject</code></h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Annotation[]</code></td><td><code>getAnnotations()</code></td><td>获取当前元素（构造、属性、方法）上的所有注解</td></tr><tr><td><code>&lt;T extends Annotation&gt; T</code></td><td><code>getAnnotation(Class&lt;T&gt; annotationClass)</code></td><td>获取当前元素上的指定类型的注解</td></tr><tr><td><code>void</code></td><td><code>setAccessible​(boolean flag)</code></td><td><code>true</code> 表示不启用 Java 访问修饰符的检查，可以访问非 <code>public</code> 修饰的成员</td></tr></tbody></table><h2 id="5-4-Constructor"><a href="#5-4-Constructor" class="headerlink" title="5.4 Constructor"></a>5.4 <code>Constructor</code></h2><h3 id="1-构造器信息"><a href="#1-构造器信息" class="headerlink" title="1 构造器信息"></a>1 构造器信息</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>getModifiers()</code></td><td>获取构造方法修饰符</td></tr><tr><td><code>String</code></td><td><code>getName()</code></td><td>获取构造方法名</td></tr><tr><td><code>Class&lt;?&gt;[]</code></td><td><code>getParameterTypes()</code></td><td>获取构造方法形参类型列表</td></tr></tbody></table><h3 id="2-构造器操作"><a href="#2-构造器操作" class="headerlink" title="2 构造器操作"></a>2 构造器操作</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>T</code></td><td><code>newInstance​(Object... initargs)</code></td><td>使用构造器创建对象</td></tr></tbody></table><h2 id="5-4-Field"><a href="#5-4-Field" class="headerlink" title="5.4 Field"></a>5.4 <code>Field</code></h2><h3 id="1-属性信息"><a href="#1-属性信息" class="headerlink" title="1 属性信息"></a>1 属性信息</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>getModifiers()</code></td><td>获取属性修饰符</td></tr><tr><td><code>Class&lt;?&gt;</code></td><td><code>getType()</code></td><td>获取属性类型</td></tr><tr><td><code>String</code></td><td><code>getName()</code></td><td>获取属性名</td></tr></tbody></table><h3 id="2-属性操作"><a href="#2-属性操作" class="headerlink" title="2 属性操作"></a>2 属性操作</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Object</code></td><td><code>get​(Object obj)</code></td><td>获取指定对象此属性的值</td></tr><tr><td><code>void</code></td><td><code>set​(Object obj, Object value)</code></td><td>为指定对象设置此属性的值</td></tr></tbody></table><h2 id="5-5-Method"><a href="#5-5-Method" class="headerlink" title="5.5 Method"></a>5.5 <code>Method</code></h2><h3 id="1-方法信息"><a href="#1-方法信息" class="headerlink" title="1 方法信息"></a>1 方法信息</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>getModifiers()</code></td><td>获取方法修饰符</td></tr><tr><td><code>Class&lt;?&gt;</code></td><td><code>getReturnType()</code></td><td>获取返回值类型</td></tr><tr><td><code>String</code></td><td><code>getName()</code></td><td>获取方法名</td></tr><tr><td><code>Class&lt;?&gt;[]</code></td><td><code>getParameterTypes()</code></td><td>获取方法形参类型列表</td></tr><tr><td><code>Class&lt;?&gt;[]</code></td><td><code>getExceptionTypes()</code></td><td>获取抛出异常类型列表</td></tr></tbody></table><h3 id="2-方法操作"><a href="#2-方法操作" class="headerlink" title="2 方法操作"></a>2 方法操作</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Object</code></td><td><code>invoke​(Object obj, Object... args)</code></td><td>调用非静态方法传入指定对象，调用静态方法传入 <code>null</code> 或 <code>类.class</code></td></tr></tbody></table><h2 id="5-6-Proxy"><a href="#5-6-Proxy" class="headerlink" title="5.6 Proxy"></a>5.6 <code>Proxy</code></h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static Object</code></td><td><code>newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code></td><td>创建代理对象</td></tr></tbody></table><h1 id="六-应用"><a href="#六-应用" class="headerlink" title="六 应用"></a>六 应用</h1><ol><li><p><code>List&lt;Integer&gt;</code> 中添加字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型只在编译期，在运行期通过反射即可实现</span></span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"java.util.ArrayList"</span>);</span><br><span class="line">Method method = clazz.getMethod(<span class="string">"add"</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">method.invoke(list, <span class="string">"哈哈哈"</span>);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-反射&quot;&gt;&lt;a href=&quot;#一-反射&quot; class=&quot;headerlink&quot; title=&quot;一 反射&quot;&gt;&lt;/a&gt;一 反射&lt;/h1&gt;&lt;h2 id=&quot;1-1-概述&quot;&gt;&lt;a href=&quot;#1-1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.1 概
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="Java" scheme="https://anyeansan.github.io/categories/CS/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-多线程</title>
    <link href="https://anyeansan.github.io/2020/09/29/Java/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://anyeansan.github.io/2020/09/29/Java/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-09-29T07:57:44.000Z</published>
    <updated>2020-09-29T07:57:58.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概念"><a href="#一-概念" class="headerlink" title="一 概念"></a>一 概念</h1><h2 id="1-1-同步（Synchronous）-amp-异步（Asynchronous）"><a href="#1-1-同步（Synchronous）-amp-异步（Asynchronous）" class="headerlink" title="1.1 同步（Synchronous）&amp; 异步（Asynchronous）"></a>1.1 同步（Synchronous）&amp; 异步（Asynchronous）</h2><ol><li>同步和异步都用来形容一次方法调用</li><li>同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为</li><li>异步方法调用一旦开始，方法调用会立即返回，调用者可以继续后续操作，而异步方法通常会在另一个线程中 “真实” 的执行。异步调用的整个过程不会阻碍调用者的工作，如果异步调用需要返回结果，那么当此异步调用真正完成时，会通知调用者。</li></ol><h2 id="1-2-并发（Concurrency）-amp-并行（Parallelism）"><a href="#1-2-并发（Concurrency）-amp-并行（Parallelism）" class="headerlink" title="1.2 并发（Concurrency）&amp; 并行（Parallelism）"></a>1.2 并发（Concurrency）&amp; 并行（Parallelism）</h2><ol><li>并发：<ul><li>同一时间多个任务交替执行，只是切换速度较快，看起来是同时执行而并非真正同时执行</li><li>同一时间应对多件事情的能力</li></ul></li><li>并行：<ul><li>同一时间多个任务真正的同时执行</li><li>同一时间做多件事情的能力</li></ul></li></ol><h2 id="1-3-进程（Process）-amp-线程（Thread）"><a href="#1-3-进程（Process）-amp-线程（Thread）" class="headerlink" title="1.3 进程（Process）&amp; 线程（Thread）"></a>1.3 进程（Process）&amp; 线程（Thread）</h2><ol><li><p>进程：</p><ul><li>正在运行的程序的实例，是系统进行资源分配的基本单位</li><li>进程是容纳线程的容器</li></ul></li><li><p>线程：</p><ul><li><p>线程是调度 CPU 的基本单位</p></li><li><p>进程中的一条执行路径，一个进程至少有一个线程</p></li><li><p>线程是程序执行的最小单位</p></li></ul></li></ol><h1 id="二-体系"><a href="#二-体系" class="headerlink" title="二 体系"></a>二 体系</h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E7%BA%BF%E7%A8%8B%E4%BD%93%E7%B3%BB.png" alt=""></p><ol><li><code>Runnable</code> 和 <code>Callable</code> 都可以作为线程的任务<ul><li><code>Runnable</code> 没有返回值，不能抛异常</li><li><code>Callable</code> 有返回值，能抛异常，主要用于线程池</li></ul></li><li><code>Future</code> 用来存储将会产生的结果</li><li><code>FutureTask</code> 技能存储结果也能作为任务，相当于 <code>Future + Runnable</code></li></ol><h1 id="三-Thread"><a href="#三-Thread" class="headerlink" title="三 Thread"></a>三 <code>Thread</code></h1><h2 id="3-1-创建线程"><a href="#3-1-创建线程" class="headerlink" title="3.1 创建线程"></a>3.1 创建线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 使用 Thread 自身的任务</span></span><br><span class="line">Thread()</span><br><span class="line">Thread(String name)</span><br><span class="line">Thread(ThreadGroup group, String name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 使用 Runnable 任务</span></span><br><span class="line">Thread(Runnable target)</span><br><span class="line">Thread(Runnable target, String name)</span><br><span class="line">Thread(ThreadGroup group, Runnable target)</span><br><span class="line">Thread(ThreadGroup group, Runnable target, String name)</span><br></pre></td></tr></table></figure><ol><li>若不指定线程名称，默认为  <code>Thread-0,1,2...</code></li><li>若不指定线程组，默认为父线程（创建此线程的线程）的线程组</li><li>构造函数中的 <code>statcksize</code> 代表该线程占用的栈大小，如果未指定，默认为 0，0 代表忽略该参数，该参数会被 JNI 函数去使用。（该参数有些平台有效，有些则无效）</li></ol><h2 id="3-2-启动线程"><a href="#3-2-启动线程" class="headerlink" title="3.2 启动线程"></a>3.2 启动线程</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>start()</code></td><td>启动线程</td></tr><tr><td><code>void</code></td><td><code>run()</code></td><td>子类必须重写，任务方法</td></tr><tr><td><code>static void</code></td><td>sleep(long millis)`</td><td>控制线程休眠若干毫秒</td></tr></tbody></table><h2 id="3-3-线程信息"><a href="#3-3-线程信息" class="headerlink" title="3.3 线程信息"></a>3.3 线程信息</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>String</code></td><td><code>getName()</code></td><td>获取线程名称</td></tr><tr><td><code>void</code></td><td><code>setName(String name)</code></td><td>设置线程名字</td></tr><tr><td><code>long</code></td><td><code>getId()</code></td><td>获取线程 ID</td></tr><tr><td><code>Thread.state</code></td><td><code>getState()</code></td><td>获取线程状态</td></tr><tr><td><code>static Thread</code></td><td><code>currentThread()</code></td><td>获取当前线程对象</td></tr></tbody></table><h2 id="3-4-加入线程"><a href="#3-4-加入线程" class="headerlink" title="3.4 加入线程"></a>3.4 加入线程</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>join()</code></td><td>当前线程阻塞，等待插入线程执行完毕</td></tr><tr><td><code>void</code></td><td><code>join(long millis)</code></td><td>当前线程阻塞，等待插入线程执行完毕，但最多只等待指定时间</td></tr><tr><td><code>void</code></td><td><code>join(long millis, int nanos)</code></td><td>时间更精确一点</td></tr></tbody></table><h2 id="3-5-中断线程"><a href="#3-5-中断线程" class="headerlink" title="3.5 中断线程"></a>3.5 中断线程</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>interrupt()</code></td><td>1 运行线程： 设置中断标志位，不代表会退出线程<br/>2 阻塞线程（ <code>wait join sleep</code>）：终止阻塞状态并抛出 <code>InterruptedException</code> 异常，且清除中断标志位</td></tr><tr><td><code>static boolean</code></td><td><code>interrupted()</code></td><td>判断当前线程是否被中断，会清除中断标志位</td></tr><tr><td><code>boolean</code></td><td><code>isInterrupted()</code></td><td>判断此线程是否中断，不会清除中断标志位</td></tr></tbody></table><ol><li>每个线程都有一个表示 <code>中断状态</code> 的 <code>boolean</code> 标记</li><li>每个线程都应该不时检查此标记，以判断线程是否被中断</li></ol><h2 id="3-6-守护线程"><a href="#3-6-守护线程" class="headerlink" title="3.6 守护线程"></a>3.6 守护线程</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>setDaemon(boolean on)</code></td><td>是否将线程设置为守护线程，必须在线程启动前调用</td></tr><tr><td><code>boolean</code></td><td><code>isDaemon</code></td><td>判断是否是守护线程</td></tr></tbody></table><h2 id="3-7-礼让线程"><a href="#3-7-礼让线程" class="headerlink" title="3.7 礼让线程"></a>3.7 礼让线程</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static void</code></td><td><code>yield()</code></td><td>让出本次 CPU 执行权，加入下一次的抢夺中，效果不明显</td></tr></tbody></table><h2 id="3-8-线程组"><a href="#3-8-线程组" class="headerlink" title="3.8 线程组"></a>3.8 线程组</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>ThreadGroup</code></td><td><code>getThreadGroup()</code></td><td>获取线程所在线程组</td></tr></tbody></table><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>线程组可以对一批线程进行分类管理，Java 允许程序直接对线程组进行控制</li><li>创建线程对象时，如果未指定线程组，则默认为父线程的线程组</li><li>主线程的线程组为 <code>main</code></li></ol><h3 id="2-ThreadGroup"><a href="#2-ThreadGroup" class="headerlink" title="2 ThreadGroup"></a>2 <code>ThreadGroup</code></h3><h4 id="1-构造"><a href="#1-构造" class="headerlink" title="1 构造"></a>1 构造</h4><table><thead><tr><th>构造</th><th>说明</th></tr></thead><tbody><tr><td><code>ThreadGroup(String name)</code></td><td>创建线程组并指定名称</td></tr><tr><td><code>ThreadGroup(ThreadGroup parent, String name)</code></td><td>创建线程组并指定父线程组及名称</td></tr></tbody></table><h4 id="2-方法"><a href="#2-方法" class="headerlink" title="2 方法"></a>2 方法</h4><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>String</code></td><td><code>getName()</code></td><td>获取线程组名称</td></tr><tr><td><code>ThreadGroup</code></td><td><code>getParent()</code></td><td>获取线程组的父线程组</td></tr><tr><td><code>int</code></td><td><code>activeCount()</code></td><td>获取线程组中活动线程数</td></tr><tr><td><code>int</code></td><td><code>enumerate(Thread[] list)</code></td><td>枚举线程组中的活动线程</td></tr></tbody></table><h2 id="3-9-线程优先级"><a href="#3-9-线程优先级" class="headerlink" title="3.9 线程优先级"></a>3.9 线程优先级</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>getPriority()</code></td><td>获取线程优先级</td></tr><tr><td><code>void</code></td><td><code>setPriority(int newPriority)</code></td><td>设置线程优先级 <code>1-10</code>，仅仅是概率增加了，玄不改命</td></tr><tr><td></td><td><code>Thread.MIN_PRIORITY</code></td><td>最小优先级 <code>1</code></td></tr><tr><td></td><td><code>Thread.NORM_PRIORITY</code></td><td>默认优先级 <code>5</code></td></tr><tr><td></td><td><code>Thread.MAX_PRIORITY</code></td><td>最大优先级 <code>10</code></td></tr></tbody></table><h1 id="四-线程状态"><a href="#四-线程状态" class="headerlink" title="四 线程状态"></a>四 线程状态</h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt=""></p><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td><code>New</code></td><td>新建状态</td></tr><tr><td><code>Runnable</code></td><td>可运行状态：一个线程可能正在运行也可能没有运行</td></tr><tr><td><code>Blocked</code></td><td>阻塞状态</td></tr><tr><td><code>Waiting</code></td><td>无限等待</td></tr><tr><td><code>Timed waiting</code></td><td>限时等待</td></tr><tr><td><code>Terminated</code></td><td>终止状态：正常结束或异常意外终止</td></tr></tbody></table><h1 id="五-终止线程"><a href="#五-终止线程" class="headerlink" title="五 终止线程"></a>五 终止线程</h1><ol><li><p><code>stop()</code></p><ol><li>已过时</li><li><code>stop()</code> 方法过于暴力，会强行把执行到一半的线程终止，可能会引起一些数据不一致的问题</li></ol></li><li><p><code>suspend() resume()</code></p><ol><li>已过时</li><li>挂起和恢复线程这两个方法同样会破坏同步</li></ol></li><li><p>定义标记，自行决定线程何时退出</p></li><li><p><code>Two Phase Termination</code>：两阶段终止模式</p><p><img src="https://gitee.com/anis5/pic/raw/master/Java/%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B.png" alt=""></p><ol><li>通过中断标记实现</li><li><code>volatile</code> 实现</li></ol></li></ol><h1 id="六-JMM"><a href="#六-JMM" class="headerlink" title="六 JMM"></a>六 JMM</h1><h2 id="6-1-CPU-缓存"><a href="#6-1-CPU-缓存" class="headerlink" title="6.1 CPU 缓存"></a>6.1 CPU 缓存</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7.png" alt=""></p><ol><li>读写速度（离 CPU 越近，速度越快）：<code>寄存器 &gt; cache L1 &gt; cache L2 &gt; cache L3 &gt; 内存 &gt; 硬盘</code></li><li><code>cache line</code> 是 <code>cache</code> 的最小存储单元</li><li>在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，这就有了<strong>缓存一致性（CacheCoherence）</strong>问题</li><li>为了解决一致性的问题，有许多协议，如 MSI、<br>MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol，等等</li></ol><h3 id="2-MESI-缓存一致性协议"><a href="#2-MESI-缓存一致性协议" class="headerlink" title="2 MESI 缓存一致性协议"></a>2 <code>MESI</code> 缓存一致性协议</h3><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td><code>M（Modified）</code></td><td>该 <code>cache line</code> 有效，数据被修改了，和内存中的数据不一致，数据只存在于本 <code>Cache</code> 中</td></tr><tr><td><code>E（Exclusive）</code></td><td>该 <code>cache line</code> 有效，数据和内存中的数据一致，数据只存在于本 <code>Cache</code> 中</td></tr><tr><td><code>S（Shared）</code></td><td>该 <code>cache line</code> 有效，数据和内存中的数据一致，数据存在于多个 <code>Cache</code> 中</td></tr><tr><td><code>I（Invalid）</code></td><td>该 <code>cache line</code> 无效</td></tr></tbody></table><ol><li>内存中数据，只有一个  <code>cache</code> 中有，则为独占状态 <code>E</code></li><li>当不止一个 <code>cache</code> 中有时，则全为共享状态 <code>S</code></li><li>当某个 <code>cache</code> 修改了数据，则其变为修改状态 <code>M</code>，且其它 <code>cache</code> 变为无效状态 <code>I</code></li><li>多个 CPU 从主内存读取同一个数据到各自的高速缓存，当其中某个 CPU 修改了缓存里的数据，该数据会马上同步回主内存，其它 CPU 通过 <strong>总线嗅探机制</strong> （类似于事件监听）可以感知到数据的变化从而将自己缓存里的数据失效</li><li>底层实现通过汇编 <code>lock</code> 指令<ol><li>锁定这块内存区域的缓存（缓存行锁定），并立即将修改数据写回系统内存</li><li>这个写回内存的操作会引起在其它 CPU 里缓存了该内存地址的数据无效</li></ol></li></ol><h2 id="6-2-JMM-概述"><a href="#6-2-JMM-概述" class="headerlink" title="6.2 JMM 概述"></a>6.2 JMM 概述</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/JMM.png" alt=""></p><ol><li><p><code>Java Memory Model</code> </p></li><li><p>Java内存模型是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p><ul><li>实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享，受到内存模型控制</li><li>局部变量，方法参数，异常处理参数不会在线程之间共享，不受内存模型影响</li></ul></li><li><p>相关概念</p><ol><li><p><strong>临界区 <code>Critical Section</code></strong></p><ul><li><p>表示一种公共资源或共享数据，可以被多个线程使用，但每次只能有一个线程使用，一旦临界区资源被占用，其它线程就必须等待</p></li><li><p>一段代码内如果存在对共享数据的多线程读写操作，则这段代码称为临界区</p></li></ul></li><li><p><strong>竞态条件 <code>Race Condition</code></strong></p><ul><li>多个线程在临界区内执行，由于代码执行序列不同而导致结果无法预测，称为发生了竞态条件</li></ul></li><li><p>为避免临界区的竞态条件发生</p><ol><li>阻塞式解决方案：<code>synchronized, Lock</code> </li><li>非阻塞式解决方案：原子变量 CAS</li></ol></li><li><p>同步和互斥</p><ol><li>同步：是由于线程执行的顺序不同，需要一个线程等待其它线程运行到某个点</li><li>互斥：保证同一时刻只有一个线程执行临界区代码</li></ol></li></ol></li></ol><h2 id="6-3-JMM-内存交互操作（原子操作）"><a href="#6-3-JMM-内存交互操作（原子操作）" class="headerlink" title="6.3 JMM 内存交互操作（原子操作）"></a>6.3 JMM 内存交互操作（原子操作）</h2><table><thead><tr><th>操作</th><th>作用对象</th><th>说明</th></tr></thead><tbody><tr><td><code>read</code></td><td>主内存</td><td>从主内存读取数据到工作内存中</td></tr><tr><td><code>load</code></td><td>工作内存</td><td>将 <code>read</code> 读取的数据载入工作内存变量副本中</td></tr><tr><td><code>use</code></td><td>工作内存</td><td>从工作内存读取数据传递给执行引擎计算</td></tr><tr><td><code>assign</code></td><td>工作内存</td><td>将执行引擎计算好的值重新赋值给工作内存</td></tr><tr><td><code>store</code></td><td>工作内存</td><td>将工作内存数据传送到主内存</td></tr><tr><td><code>write</code></td><td>工作内存</td><td>将 <code>stroe</code> 传送的数据赋值给主内存的变量</td></tr><tr><td><code>lock</code></td><td>主内存</td><td>将主内存变量加锁，标记为线程独占状态</td></tr><tr><td><code>unlock</code></td><td>主内存</td><td>将主内存变量解锁，解锁后才可以被其他线程锁定</td></tr></tbody></table><h2 id="6-4-JMM-特性"><a href="#6-4-JMM-特性" class="headerlink" title="6.4 JMM 特性"></a>6.4 JMM 特性</h2><h3 id="1-原子性-Atomicity"><a href="#1-原子性-Atomicity" class="headerlink" title="1 原子性 Atomicity"></a>1 原子性 <code>Atomicity</code></h3><ol><li><p>原子性指一个操作是不可分割的单元，是不可中断的，要嘛都执行，要嘛都不执行</p></li><li><p>一个原子性操作一旦开始，就不会被其它线程干扰，而一个非原子性操作，在多线程环境下有可能被其它线程所干扰</p></li><li><p>从一个线程观察另外一个线程的时候，看到的都是一个个原子性的操作</p></li><li><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">从一个线程观察另一个线程执行上述代码，只有两种结果</span><br><span class="line"><span class="number">1</span> a,b 都被赋值成功</span><br><span class="line"><span class="number">2</span> a,b 都未被赋值</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-可见性-Visibility"><a href="#2-可见性-Visibility" class="headerlink" title="2 可见性 Visibility"></a>2 可见性 <code>Visibility</code></h3><ol><li>可见性指当一个线程修改了某个共享变量后，其他线程是否能够立即知道这个修改</li><li>每个线程都有自己的工作内存，所以当线程修改完某个变量之后，在其他的线程中，未必能观察到该变量已经被修改</li></ol><h3 id="3-有序性-Ordering"><a href="#3-有序性-Ordering" class="headerlink" title="3 有序性 Ordering"></a>3 有序性 <code>Ordering</code></h3><ol><li>指令重排序<ol><li>JVM 在不影响正确性的前提下，可以调整指令的执行顺序，这种特性称之为『指令重排』，指令重排可以提高 CPU 的处理性能</li><li><code>as-if-serial</code> 语义：不管如何重排序，必须保证串行语义一致，即单线程下，程序的执行结果不会改变</li></ol></li><li>指令重排在多线程下有可能影响正确性</li></ol><h2 id="6-5-Happens-Before-规则"><a href="#6-5-Happens-Before-规则" class="headerlink" title="6.5 Happens-Before 规则"></a>6.5 <code>Happens-Before</code> 规则</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li><code>happens-before</code> 规则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据</li><li>可以通过此规则分析一个并发程序是否安全</li><li>如果 <code>A happens-bofore B</code>，则 A 操作先于 B 操作发生，且 <code>A</code> 操作的结果对 B 可见</li></ol><h3 id="2-规则"><a href="#2-规则" class="headerlink" title="2 规则"></a>2 规则</h3><table><thead><tr><th>规则</th><th>说明</th></tr></thead><tbody><tr><td>程序顺序规则（<code>Program Order Rule</code>）</td><td>一个线程内保证语义的串行性，即按照代码顺序执行，前面的操作 <code>happens-before</code> 后续的任何操作</td></tr><tr><td>管程锁定规则（<code>Monitor Lock Rule</code>）</td><td>同一个锁的解锁操作 <code>happens-before</code> 后续对这个锁的加锁操作</td></tr><tr><td><code>volatile</code> 变量规则（<code>volatile Variable Rule</code>）</td><td><code>volatile</code> 变量的写操作，<code>happens-before</code> 后续对这个变量的读操作</td></tr><tr><td>线程启动规则（<code>Thread Start Rule</code>）</td><td>线程 <code>start()</code> 方法 <code>happens-before</code> 线程中的每一个操作</td></tr><tr><td>线程终止规则（<code>Thread Termination Rule</code>）</td><td>线程的所有操作 <code>happens-before</code> 线程的终结</td></tr><tr><td>线程中断规则（<code>Thread Interruption Rule</code>）</td><td>线程 <code>interrupt()</code> 方法的调用 <code>happens—before</code> 被中断线程的代码检测到中断事件的发生</td></tr><tr><td>对象终结规则（<code>Finalizer Rule</code>）</td><td>一个对象的初始化完成（构造函数执行）<code>happens—before</code> 它的 <code>finalize()</code> 方法</td></tr><tr><td>传递性（<code>Transitivity</code>）</td><td>如果 <code>A happens-before B，B happens-before C</code>，那么 <code>A happens-before C</code></td></tr></tbody></table><h2 id="6-6-volatile"><a href="#6-6-volatile" class="headerlink" title="6.6 volatile"></a>6.6 <code>volatile</code></h2><h3 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li><code>volatile</code> 是Java虚拟机提供的轻量级的同步机制</li><li><code>volatile</code> 有两个作用：<ol><li>保证可见性</li><li>禁止指令重排序</li></ol></li><li><code>volatile</code> 无法保证原子性</li><li>内存屏障 <code>Memory Barrier</code><ol><li>对 <code>volatile</code> 变量的写指令后会加入写屏障 <code>storefence</code></li><li>对<code>volatile</code> 变量的读指令前会加入读屏障 <code>loadfence</code></li></ol></li></ol><h3 id="2-Volatile-可见性"><a href="#2-Volatile-可见性" class="headerlink" title="2 Volatile 可见性"></a>2 <code>Volatile</code> 可见性</h3><ol><li>硬件层面：<code>MESI</code><ul><li>当某个线程修改了被 <code>volatile</code> 修饰的共享变量的值，会马上同步到主内存，而开启了 CPU 总线嗅探机制的线程就会得知此修改，然后将自己工作内存中的共享变量副本失效，这样使用时就需要重新从主内存中读取</li></ul></li><li>JVM 层面：<code>Memory Barrier</code><ol><li>写屏障保证在该屏障之前的，对共享变量的改动，都同步到主内存当中</li><li>读屏障保证在该屏障之后，对共享变量的读取，加载的是主内存中最新数据</li></ol></li></ol><h3 id="3-Volatile-有序性"><a href="#3-Volatile-有序性" class="headerlink" title="3 Volatile 有序性"></a>3 <code>Volatile</code> 有序性</h3><ol><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ol><h2 id="6-7-synchronized"><a href="#6-7-synchronized" class="headerlink" title="6.7 synchronized"></a>6.7 <code>synchronized</code></h2><h3 id="1-概述-4"><a href="#1-概述-4" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li><code>synchronized</code> 内置锁是一种对象锁（锁的是对象而非引用），作用粒度是对象，可以用来实现对临界资源的同步互斥访问，是可重入的</li><li><code>synchronized</code> 可以保证原子性和可见性，不能保证有序性，但如果共享变量完全被 <code>synchronized</code> 控制，则不会出现有序性问题</li></ol><h3 id="2-同步代码块"><a href="#2-同步代码块" class="headerlink" title="2 同步代码块"></a>2 同步代码块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(锁) &#123;</span><br><span class="line">1. 同步代码块的锁可以是任意对象</span><br><span class="line">2. 不要使用 String Integer Long 作为锁对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-同步函数"><a href="#3-同步函数" class="headerlink" title="3 同步函数"></a>3 同步函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 synchronized 返回值 方法名(形参列表)&#123;</span><br><span class="line">1. 非静态同步函数的锁是 this</span><br><span class="line">2. 静态同步函数的锁是当前类的字节码对象 类.class</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-synchronized-原理"><a href="#4-synchronized-原理" class="headerlink" title="4 synchronized 原理"></a>4 <code>synchronized</code> 原理</h3><h4 id="1-对象头"><a href="#1-对象头" class="headerlink" title="1 对象头"></a>1 对象头</h4><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" alt=""></p><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/MarkWord32.png" alt=""></p><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/MarkWord64.png" alt=""></p><h4 id="2-Monitor：监视器-管程"><a href="#2-Monitor：监视器-管程" class="headerlink" title="2 Monitor：监视器/管程"></a>2 <code>Monitor</code>：监视器/管程</h4><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/monitor.png" alt=""></p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>Owner</code></td><td>当一个线程获取锁，并正常执行，则将 <code>Owner</code> 指向此线程，<code>Owner</code> 只能有一个值</td></tr><tr><td><code>EntryList</code></td><td>尝试获取此锁的线程如果获取不到，会阻塞进入 <code>EntryList</code></td></tr><tr><td><code>WaitSet</code></td><td>已经获取锁但条件不满足，进入等待状态的线程会进入 <code>WaitSet</code></td></tr></tbody></table><h4 id="3-原理"><a href="#3-原理" class="headerlink" title="3 原理"></a>3 原理</h4><ol><li><p>每个 Java 对象都有一个自己的 <code>Monitor</code> 对象，当给对象上锁（重量级锁）后，该对象头的 <code>Mark Word</code> 就会指向 <code>Monitor</code></p></li><li><p><code>Monitor</code> 的实现依赖底层操作系统的 <code>Mutex lock</code>（互斥锁）实现，它是一个重量级锁性能较低</p></li><li><p><code>synchronized</code> JVM内置锁通过内部对象 <code>Monitor</code> 实现，基于进入与退出 <code>Monitor</code> 对象实现方法与代码块同步</p></li><li><p><code>synchronized</code> 关键字被编译成字节码后会被翻译成 <code>monitorenter</code> 和 <code>monitorexit</code> 两条指令分别在同步块逻辑代码的起始位置与结束位置</p><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/smonitor.png" alt=""></p></li></ol><h3 id="4-锁优化"><a href="#4-锁优化" class="headerlink" title="4 锁优化"></a>4 锁优化</h3><h4 id="1-锁粗化"><a href="#1-锁粗化" class="headerlink" title="1 锁粗化"></a>1 锁粗化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sb.append(<span class="number">1</span>);</span><br><span class="line">    sb.append(<span class="number">2</span>);</span><br><span class="line">    sb.append(<span class="number">3</span>);</span><br><span class="line">    sb.append(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">StringBuffer是线程安全的，append方法有sychronized修饰，那么调用了4次append方法，就相当于有了四个同步块</span></span><br><span class="line"><span class="comment">    sychronized()&#123;</span></span><br><span class="line"><span class="comment">        append(1);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    sychronized()&#123;</span></span><br><span class="line"><span class="comment">        append(2);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    sychronized()&#123;</span></span><br><span class="line"><span class="comment">        append(3);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    sychronized()&#123;</span></span><br><span class="line"><span class="comment">        append(4);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">而这是没有必要的，锁粗化相当于</span></span><br><span class="line"><span class="comment">    sychronized()&#123;</span></span><br><span class="line"><span class="comment">        append(1);</span></span><br><span class="line"><span class="comment">        append(2);</span></span><br><span class="line"><span class="comment">        append(3);</span></span><br><span class="line"><span class="comment">        append(4);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure><h4 id="2-锁消除"><a href="#2-锁消除" class="headerlink" title="2 锁消除"></a>2 锁消除</h4><ul><li>Java虚拟机在 JIT 编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间</li></ul><h4 id="3-锁膨胀升级"><a href="#3-锁膨胀升级" class="headerlink" title="3 锁膨胀升级"></a>3 锁膨胀升级</h4><h5 id="1-概述-5"><a href="#1-概述-5" class="headerlink" title="1 概述"></a>1 概述</h5><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/synchronized%E9%94%81%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png" alt=""></p><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E9%94%81%E5%8D%87%E7%BA%A7.png" alt=""></p><ul><li>偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁</li><li>轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争</li><li>重量级锁：有实际竞争，且锁竞争时间长</li></ul><h5 id="2-偏向锁"><a href="#2-偏向锁" class="headerlink" title="2 偏向锁"></a>2 偏向锁</h5><ol><li>在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁（会涉及到一些 CAS 操作）的代价而引入偏向锁</li><li>偏向锁核心思想：如果一个线程获得了锁，那么锁就进入偏向模式，此时 <code>Mark Word</code> 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作（即获取锁的过程），这样就省去了大量有关锁申请的操作</li><li>偏向锁默认开启，但有延迟</li><li>调用了对象的 <code>hashCode</code> ，会导致偏向锁被撤销</li><li>如果发生了竞争，则偏向锁会失效，会膨胀为轻量级锁</li></ol><h5 id="3-轻量级锁"><a href="#3-轻量级锁" class="headerlink" title="3 轻量级锁"></a>3 轻量级锁</h5><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%811.png" alt=""></p><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%812.png" alt=""></p><ol><li>轻量级锁所适应的场景是线程交替执行同步块的场合</li><li>轻量级锁在没有竞争时，每次锁重入仍需要执行 <code>CAS</code> 操作</li><li>如果在尝试加轻量级锁的过程中，<code>CAS</code> 操作无法成功，一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），则轻量级锁会失败，轻量级锁失败后并不会立即膨胀为重量级锁，而是会先使用锁自旋的优化手段</li><li><strong>自旋锁</strong><ol><li>在大多数情况下，线程持有锁的时间都不会太长，如果当前线程获取轻量级锁失败后直接挂起，可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高</li><li>自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，将轻量级锁膨胀为重量级锁</li></ol></li></ol><h3 id="5-锁活跃性"><a href="#5-锁活跃性" class="headerlink" title="5 锁活跃性"></a>5 锁活跃性</h3><ol><li>死锁：一个线程需要同时获取多把锁，这时就容易发生死锁（例如锁嵌套）</li><li>活锁：两个线程互相改变对方的结束条件，导致谁也无法结束</li><li>饥饿：一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束</li></ol><h2 id="6-8-常见线程安全类"><a href="#6-8-常见线程安全类" class="headerlink" title="6.8 常见线程安全类"></a>6.8 常见线程安全类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String</span><br><span class="line">Integer</span><br><span class="line">StringBuffer</span><br><span class="line">Random</span><br><span class="line">Vector</span><br><span class="line">Hashtable</span><br><span class="line">java.util.concurrent.*</span><br></pre></td></tr></table></figure><ol><li>线程安全指的是多个线程调用这些类的同一实例的同一方法是线程安全的</li><li>它们每个方法是原子的，但多个方法的组合不是原子的</li></ol><h1 id="七-等待唤醒机制"><a href="#七-等待唤醒机制" class="headerlink" title="七 等待唤醒机制"></a>七 等待唤醒机制</h1><h2 id="7-1-wait-notify"><a href="#7-1-wait-notify" class="headerlink" title="7.1 wait/notify"></a>7.1 <code>wait/notify</code></h2><h3 id="1-概述-6"><a href="#1-概述-6" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>只有重量级锁才有等待唤醒方法<ol><li><code>wait()</code>：相当于 <code>wait(0)</code>，无限等待直到被唤醒</li><li><code>wait(long timeout)</code>：等待指定时间或被唤醒</li><li><code>notify()</code></li><li><code>notifyAll()</code></li></ol></li><li>获取锁之后才能调用等待唤醒方法，即等待唤醒的方法要在同步代码中执行，且需要同一个锁对象来调用</li><li>等待时释放锁，进入 <code>Monitor</code> 的 <code>WaitSet</code>，唤醒之后不会立即获取锁，而是进入 <code>Monitor</code> 的 <code>EntrySet</code> 重新竞争</li></ol><h3 id="2-wait-amp-sleep"><a href="#2-wait-amp-sleep" class="headerlink" title="2 wait &amp; sleep"></a>2 <code>wait</code> &amp; <code>sleep</code></h3><table><thead><tr><th>方法</th><th>所属</th><th>参数</th><th>锁</th><th>使用</th></tr></thead><tbody><tr><td><code>wait()</code></td><td><code>Object</code></td><td>无参：无限等待<br/>有参：有限等待</td><td>释放锁</td><td>必须先获取锁，在同步代码中使用</td></tr><tr><td><code>sleep()</code></td><td><code>Thread</code></td><td>有参：有限睡眠</td><td>不释放锁</td><td>可直接使用</td></tr></tbody></table><h3 id="3-模式"><a href="#3-模式" class="headerlink" title="3 模式"></a>3 模式</h3><ol><li>同步模式之保护性暂停 <ol><li><code>Guarded Suspension</code>：用在一个线程等待另一个线程的执行结果</li><li>结果需要从一个线程传递到另一个线程，让他们关联同一个 <code>GuardedObject</code></li><li>产生结果的线程与消费结果的线程需要一一对应</li><li>JDK 中，<code>join</code> 的实现、<code>Future</code> 的实现，采用的就是此模式</li></ol></li><li>异步模式之生产者/消费者<ol><li>产生结果的线程与消费结果的线程不需要一一对应</li><li>JDK 中各种阻塞队列，采用的就是这种模式</li></ol></li></ol><h2 id="7-2-park-unpark"><a href="#7-2-park-unpark" class="headerlink" title="7.2 park/unpark"></a>7.2 <code>park/unpark</code></h2><h3 id="1-与-wait-amp-notify-相比"><a href="#1-与-wait-amp-notify-相比" class="headerlink" title="1 与 wait &amp; notify 相比"></a>1 与 <code>wait &amp; notify</code> 相比</h3><ol><li><code>wait &amp; notify</code> 必须配合 <code>Object Monitor</code> 使用，<code>park &amp; unpark</code> 则不必</li><li><code>wait &amp; notify</code> 只能随机唤醒等待线程，<code>park &amp; unpark</code> 是以线程为单位来等待唤醒的，所以精确</li><li><code>wait &amp; notify</code> 不能先 <code>notify</code>，<code>park &amp; unpark</code> 可以先 <code>unpark</code>，即先 <code>unpark</code> 也能恢复 <code>park</code> 的线程</li></ol><h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2 原理"></a>2 原理</h3><ol><li>每个线程都有自己的一个 <code>Parker</code> 对象，由三部分组成<ul><li><code>_counter</code></li><li><code>_cond</code></li><li><code>_mutex</code></li></ul></li><li><code>park()</code><ol><li>判断 <code>_counter</code><ul><li><code>_counter == 0</code> 则等待</li><li><code>_counter == 1</code> 则继续运行</li></ul></li><li>将 <code>_counter</code> 设置为 <code>0</code></li></ol></li><li><code>unpark()</code><ol><li>将 <code>_counter</code> 设置为 <code>1</code></li><li>判断线程状态<ol><li>如果线程正在等待，则唤醒线程</li><li>如果线程正在运行，则继续运行，且由于 <code>_counter</code> 设置为了 <code>1</code> ，线程下次调用 <code>park()</code> 时，会继续执行</li></ol></li></ol></li></ol><h1 id="八-CAS"><a href="#八-CAS" class="headerlink" title="八 CAS"></a>八 <code>CAS</code></h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><ol><li><code>Compare And Swap</code> 或 <code>Compare And Set</code></li><li>CAS 是一种无锁算法，体现的是无锁并发、无阻塞并发</li><li>CAS 必须借助 <code>volatile</code> ，因为需要保证可见性来读取最新值</li><li>内部通过 <code>Unsafe</code> 实现，<code>Unsafe</code> 直接操作虚拟机内存，类似 <code>C C++</code> 的指针</li><li><code>ABA</code> 问题：<code>version</code></li></ol><h2 id="8-2-原理"><a href="#8-2-原理" class="headerlink" title="8.2 原理"></a>8.2 原理</h2><ol><li>CAS 包含三个操作数：<ul><li>内存值 <code>V</code></li><li>预估值 <code>A</code></li><li>更新值 <code>B</code></li></ul></li><li>第一次读取内存值记录为 <code>A</code>，之后进行一些操作</li><li>当真正写入数据时，再次读取内存值 <code>V</code>，当且仅当 <code>V == A</code> 时，才会更新 <code>V = B</code></li></ol><h1 id="九-java-util-concurrent-atomic"><a href="#九-java-util-concurrent-atomic" class="headerlink" title="九 java.util.concurrent.atomic"></a>九 <code>java.util.concurrent.atomic</code></h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><table><thead><tr><th>类型</th><th>名称</th></tr></thead><tbody><tr><td>基本类型原子类</td><td><code>AtomicInteger</code><br><code>AtomicBoolean</code><br><code>AtomicLong</code></td></tr><tr><td>引用类型原子类</td><td><code>AtomicReference&lt;V&gt;</code><br><code>AtomicStampedReference&lt;V&gt;</code><br><code>AtomicMarkableReference&lt;V&gt;</code></td></tr><tr><td>数组类型原子类</td><td><code>AtomicIntegerArray</code><br/><code>AtomicLongArray</code><br/><code>AtomicReferenceArray&lt;E&gt;</code></td></tr><tr><td>原子字段更新器</td><td><code>AtomicIntegerFieldUpdater&lt;T&gt;</code><br/><code>AtomicLongFieldUpdater&lt;T&gt;</code><br/><code>AtomicReferenceFieldUpdater&lt;T, V&gt;</code></td></tr><tr><td>原子累加器</td><td><code>LongAdder</code><br/><code>DoubleAdder</code><br/><code>LongAccumulator</code><br><code>DoubleAccumulator</code></td></tr></tbody></table><ol><li><code>AtomicReference&lt;V&gt;</code><ul><li>只关心当前值和预期值是否相等，不知道值是否被修改过（ABA问题），如 <code>A → B → C → A</code></li></ul></li><li><code>AtomicStampedReference&lt;V&gt;</code><ul><li>增加一个版本号属性，每次修改都使版本号 + 1，可以知道值被修改过几次</li></ul></li><li><code>AtomicMarkableReference&lt;V&gt;</code><ul><li>增加要给布尔属性，判断值是否被修改过</li></ul></li></ol><h2 id="9-2-AtomicInteger"><a href="#9-2-AtomicInteger" class="headerlink" title="9.2 AtomicInteger"></a>9.2 <code>AtomicInteger</code></h2><h3 id="1-构造-1"><a href="#1-构造-1" class="headerlink" title="1 构造"></a>1 构造</h3><table><thead><tr><th>构造</th><th>说明</th></tr></thead><tbody><tr><td><code>AtomicInteger()</code></td><td>使用默认值 <code>0</code></td></tr><tr><td><code>AtomicInteger(int initialValue)</code></td><td>使用指定值</td></tr></tbody></table><h3 id="2-方法-1"><a href="#2-方法-1" class="headerlink" title="2 方法"></a>2 方法</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>get()</code></td><td>获取当前值</td></tr><tr><td><code>boolean</code></td><td><code>compareAndSet(int expectedValue, int newValue)</code></td><td>如果当前值与预期值相等，则将当前值设置为新值并返回 <code>true</code></td></tr><tr><td><code>int</code></td><td><code>getAndIncrement()</code></td><td><code>i++</code></td></tr><tr><td><code>int</code></td><td><code>incrementAndGet()</code></td><td><code>++i</code></td></tr><tr><td><code>int</code></td><td><code>getAndDecrement()</code></td><td><code>i--</code></td></tr><tr><td><code>int</code></td><td><code>decrementAndGet()</code></td><td><code>--i</code></td></tr><tr><td><code>int</code></td><td><code>getAndAdd(int delta)</code></td><td>返回原值，之后将值加上指定值</td></tr><tr><td><code>int</code></td><td><code>addAndGet(int delta)</code></td><td>将值加上指定值并返回</td></tr><tr><td><code>int</code></td><td><code>getAndUpdate(IntUnaryOperator updateFunction)</code></td><td>获取原值并计算</td></tr><tr><td><code>int</code></td><td><code>updateAndGet(IntUnaryOperator updateFunction)</code></td><td>计算并返回</td></tr></tbody></table><h1 id="十-java-util-concurrent-locks"><a href="#十-java-util-concurrent-locks" class="headerlink" title="十 java.util.concurrent.locks"></a>十 <code>java.util.concurrent.locks</code></h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/JUC-locks.png" alt=""></p><h2 id="10-1-Lock"><a href="#10-1-Lock" class="headerlink" title="10.1 Lock"></a>10.1 <code>Lock</code></h2><h3 id="1-API"><a href="#1-API" class="headerlink" title="1 API"></a>1 API</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>lock()</code></td><td>获取锁</td></tr><tr><td><code>void</code></td><td><code>unlock()</code></td><td>释放锁</td></tr><tr><td><code>boolean</code></td><td><code>tryLock()</code></td><td>尝试获取锁</td></tr><tr><td><code>boolean</code></td><td><code>tryLock(long time, TimeUnit unit)</code></td><td>尝试获取锁，会尝试指定时间</td></tr><tr><td><code>void</code></td><td><code>lockInterruptibly()</code></td><td>功能同 <code>locak</code>，如果线程被中断会抛出异常</td></tr><tr><td><code>Condition</code></td><td><code>newCondition()</code></td><td>创建一个该锁的 <code>Condition</code> 对象</td></tr></tbody></table><h3 id="2-典型使用"><a href="#2-典型使用" class="headerlink" title="2 典型使用"></a>2 典型使用</h3><h4 id="1-lock"><a href="#1-lock" class="headerlink" title="1 lock()"></a>1 <code>lock()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock l = ...;</span><br><span class="line">l.lock(); <span class="comment">// 获取锁后要紧跟 try</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// access the resource protected by this lock</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  l.unlock(); <span class="comment">// 释放锁要在 finally 的第一行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-tryLock"><a href="#2-tryLock" class="headerlink" title="2 tryLock()"></a>2 <code>tryLock()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line"><span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// manipulate protected state</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// perform alternative actions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-ReentrantLock"><a href="#3-ReentrantLock" class="headerlink" title="3 ReentrantLock"></a>3 <code>ReentrantLock</code></h3><h4 id="1-构造-2"><a href="#1-构造-2" class="headerlink" title="1 构造"></a>1 构造</h4><table><thead><tr><th>构造</th><th>说明</th></tr></thead><tbody><tr><td><code>ReentrantLock()</code></td><td>默认为非公平锁</td></tr><tr><td><code>ReentrantLock(boolean fair)</code></td><td>可创建公平锁（但没有必要，会降低并发度）</td></tr></tbody></table><h4 id="2-与-synchronized-比较"><a href="#2-与-synchronized-比较" class="headerlink" title="2 与 synchronized 比较"></a>2 与 <code>synchronized</code> 比较</h4><ol><li>在 <code>synchronized</code> 未优化之前，皆为重量级锁，所以才引入 <code>ReentrantLock</code>，<code>ReentrantLock</code> 提供了更丰富的 API</li><li><code>synchronized</code> 和 <code>ReetrantLock</code> 都是可重入锁</li><li><code>synchronized</code> 获取不到锁会一直阻塞；<code>ReentrantLock</code> 获取不到锁可以被中断或超时</li><li><code>ReetrantLock</code> 可设置公平锁</li><li><code>synchronized</code>只有一个条件，不满足时进入 <code>WaitSet</code> 等待；<code>ReetrantLock</code> 一个锁可以对应多个 <code>Condition</code></li></ol><h2 id="10-2-Condition"><a href="#10-2-Condition" class="headerlink" title="10.2 Condition"></a>10.2 <code>Condition</code></h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>await()</code></td><td>当前线程等待，直到被打断或被唤醒</td></tr><tr><td><code>boolean</code></td><td><code>await(long time, TimeUnit unit)</code></td><td>当前线程等待，直到被打断或被唤醒或超时</td></tr><tr><td><code>long</code></td><td><code>awaitNanos(long nanosTimeout)</code></td><td>当前线程等待，直到被打断或被唤醒或超时</td></tr><tr><td><code>void</code></td><td><code>awaitUninterruptibly()</code></td><td>当前线程等待，直到被唤醒</td></tr><tr><td><code>void</code></td><td><code>signal()</code></td><td>唤醒一个等待线程</td></tr><tr><td><code>void</code></td><td><code>signalAll()</code></td><td>唤醒所有等待线程</td></tr></tbody></table><h2 id="10-3-ReadWriteLock"><a href="#10-3-ReadWriteLock" class="headerlink" title="10.3 ReadWriteLock"></a>10.3 <code>ReadWriteLock</code></h2><h3 id="1-概述-7"><a href="#1-概述-7" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>读写锁，将锁更细粒度的划分：<ul><li>共享锁（读）</li><li>排他锁（写）</li></ul></li><li>读锁可以被多个线程共享（当读操作多时，多个读线程可以并发执行，提高效率），写锁则只能一个线程独占</li><li><code>ReentrantReadWriteLock</code>：唯一实现类</li><li><code>StampedLock</code>：能力更强的读写锁</li></ol><h3 id="2-API"><a href="#2-API" class="headerlink" title="2 API"></a>2 API</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Lock</code></td><td><code>readLock()</code></td><td>获取读锁</td></tr><tr><td><code>Lock</code></td><td><code>writeLock()</code></td><td>获取写锁</td></tr></tbody></table><h2 id="10-4-LockSupport"><a href="#10-4-LockSupport" class="headerlink" title="10.4 LockSupport"></a>10.4 <code>LockSupport</code></h2><table><thead><tr><th>修饰</th><th>方法</th></tr></thead><tbody><tr><td><code>static Object</code></td><td><code>getBlocker(Thread t)</code></td></tr><tr><td><code>static void</code></td><td><code>park()</code></td></tr><tr><td><code>static void</code></td><td><code>park(Object blocker)</code></td></tr><tr><td><code>static void</code></td><td><code>parkNanos(long nanos)</code></td></tr><tr><td><code>static void</code></td><td><code>parkNanos(Object blocker, long nanos)</code></td></tr><tr><td><code>static void</code></td><td><code>parkUntil(long deadline)</code></td></tr><tr><td><code>static void</code></td><td><code>parkUntil(Object blocker, long deadline)</code></td></tr><tr><td><code>static void</code></td><td><code>unpark(Thread thread)</code></td></tr></tbody></table><h1 id="十一-辅助工具类"><a href="#十一-辅助工具类" class="headerlink" title="十一 辅助工具类"></a>十一 辅助工具类</h1><h2 id="11-1-Semaphore"><a href="#11-1-Semaphore" class="headerlink" title="11.1 Semaphore"></a>11.1 <code>Semaphore</code></h2><h3 id="1-概述-8"><a href="#1-概述-8" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li><code>Semaphore</code> 是一个计数信号量，必须由获取它的线程释放</li><li>用来控制同时访问资源的线程数量（限流）</li></ol><h3 id="2-构造"><a href="#2-构造" class="headerlink" title="2 构造"></a>2 构造</h3><table><thead><tr><th>构造</th><th>说明</th></tr></thead><tbody><tr><td><code>Semaphore(int permits)</code></td><td>创建具有给定许可数的计数信号量，默认为非公平信号量</td></tr><tr><td><code>Semaphore(int permits, boolean fair)</code></td><td>创建具有给定许可数的计数信号量，可设置为公平信号量</td></tr></tbody></table><h3 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>acquire()</code></td><td>从信号量中获取一个许可，在提供一个可用许可之前一直等待</td></tr><tr><td><code>void</code></td><td><code>acquire(int permits)</code></td><td>从信号量中获取指定数量的许可</td></tr><tr><td><code>void</code></td><td><code>release()</code></td><td>释放一个许可，将其返回给信号量</td></tr><tr><td><code>void</code></td><td><code>release(int permits)</code></td><td>释放指定数量的许可，将其返回给信号量</td></tr><tr><td><code>int</code></td><td><code>availablePermits()</code></td><td>获取当前可用的许可个数</td></tr><tr><td><code>boolean</code></td><td><code>hasQueuedThreads()</code></td><td>是否有线程在等待获取许可</td></tr><tr><td>`int</td><td><code>getQueueLength()</code></td><td>获取正在等待获取许可的线程数</td></tr><tr><td><code>protected Collection&lt;Thread&gt;</code></td><td><code>getQueuedThreads()</code></td><td>获取所有等待获取许可的线程集合</td></tr><tr><td><code>int</code></td><td><code>drainPermits()</code></td><td>获取可用许可个数，并将可用许可置为 0</td></tr></tbody></table><h2 id="11-2-CountDownLatch"><a href="#11-2-CountDownLatch" class="headerlink" title="11.2 CountDownLatch"></a>11.2 <code>CountDownLatch</code></h2><h3 id="1-概述-9"><a href="#1-概述-9" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>用来进行线程同步写作，等待所有线程完成倒计时</li><li>允许一个或多个线程等待其他线程完成操作</li></ol><h3 id="2-构造-1"><a href="#2-构造-1" class="headerlink" title="2 构造"></a>2 构造</h3><table><thead><tr><th>构造</th><th>说明</th></tr></thead><tbody><tr><td><code>CountDownLatch(int count)</code></td><td>构造时传入一个计数</td></tr></tbody></table><h3 id="3-方法-1"><a href="#3-方法-1" class="headerlink" title="3 方法"></a>3 方法</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>countDown()</code></td><td>计数减 <code>1</code></td></tr><tr><td><code>void</code></td><td><code>await()</code></td><td>当前线程等待，当计数归 <code>0</code>，当前线程继续执行</td></tr><tr><td><code>boolean</code></td><td><code>await(long timeout, TimeUnit unit)</code></td><td>当前线程等待，当计数归 <code>0</code> 或者超时，当前线程继续执行</td></tr></tbody></table><h2 id="11-3-CyclicBarrier"><a href="#11-3-CyclicBarrier" class="headerlink" title="11.3 CyclicBarrier"></a>11.3 <code>CyclicBarrier</code></h2><h3 id="1-概述-10"><a href="#1-概述-10" class="headerlink" title="1 概述"></a>1 概述</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/CyclicBarrier.gif" alt=""></p><ol><li>循环栅栏，用来进行线程协作，等待线程满足某个计数</li><li>阻塞一组线程直到某个事件的发生</li><li><code>CountDownLatch</code> 只能拦截一轮，<code>CyclicBarrier</code> 可以实现循环拦截</li><li>构造时设置计数，每个线程执行到某个需要同步的时刻则等待，当等待的线程数满足计数时，继续执行</li></ol><h3 id="2-构造-2"><a href="#2-构造-2" class="headerlink" title="2 构造"></a>2 构造</h3><table><thead><tr><th>构造</th><th>说明</th></tr></thead><tbody><tr><td><code>CyclicBarrier(int parties)</code></td><td>构造时传入一个计数，表示需要等待的线程数</td></tr><tr><td><code>CyclicBarrier(int parties, Runnable barrierAction)</code></td><td><code>barrierAction</code>：等待线程数达到时首先执行的任务</td></tr></tbody></table><h3 id="3-方法-2"><a href="#3-方法-2" class="headerlink" title="3 方法"></a>3 方法</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>await()</code></td><td>当前线程等待，直到等待线程数达到初始计数</td></tr><tr><td><code>int</code></td><td><code>await(long timeout, TimeUnit unit)</code></td><td>当前线程等待，直到等待线程数达到初始计数或超时</td></tr></tbody></table><h1 id="十二-线程池"><a href="#十二-线程池" class="headerlink" title="十二 线程池"></a>十二 线程池</h1><h2 id="12-1-线程池体系"><a href="#12-1-线程池体系" class="headerlink" title="12.1 线程池体系"></a>12.1 线程池体系</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/JUC-executor.png" alt=""></p><h2 id="12-2-线程池执行过程"><a href="#12-2-线程池执行过程" class="headerlink" title="12.2 线程池执行过程"></a>12.2 线程池执行过程</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%87%E7%A8%8B01.png" alt=""></p><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%87%E7%A8%8B02.png" alt=""></p><h2 id="12-3-线程池状态"><a href="#12-3-线程池状态" class="headerlink" title="12.3 线程池状态"></a>12.3 线程池状态</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.png" alt=""></p><table><thead><tr><th>状态</th><th>高 3 位</th><th>说明</th></tr></thead><tbody><tr><td><code>Running</code></td><td><code>111</code></td><td>接收新任务，能处理已添加任务</td></tr><tr><td><code>Shutdown</code></td><td><code>000</code></td><td>不接收新任务，能处理已添加任务</td></tr><tr><td><code>Stop</code></td><td><code>001</code></td><td>不接收新任务，不处理已添加任务，且中断正在处理的任务</td></tr><tr><td><code>Tidying</code></td><td><code>010</code></td><td>所有任务已终止，<code>ctl</code> 记录的活动线程为 0，即将进入终结</td></tr><tr><td><code>Terminated</code></td><td><code>011</code></td><td>线程池彻底终止</td></tr></tbody></table><ol start="2"><li>线程池的运行状态和活动线程数信息存储在一个原子变量 <code>AtomicInteger ctl</code> 中，目的是将线程池状态和线程个数合二为一，这样就可以用一次 <code>CAS</code> 原子操作进行赋值</li><li><code>ctl</code> 高 3 位表示线程池状态，低 29 位表示线程池数量</li></ol><h2 id="12-4-线程池数量"><a href="#12-4-线程池数量" class="headerlink" title="12.4 线程池数量"></a>12.4 线程池数量</h2><ol><li><code>N<sub>threds</sub> = N<sub>CPU</sub> * U<sub>CPU</sub> * (1 + W/C)</code><ul><li><code>N<sub>CPU</sub></code> ：CPU 的核数</li><li><code>U<sub>CPU</sub></code> ：CPU 期望利用率 <code>(0, 1]</code></li><li><code>W/C</code> ：等待时间和计算时间比率</li></ul></li><li>CPU 密集型运算：<code>线程数 = CPU核数 + 1</code></li><li>I/O 密集型运算：<code>线程数 = CPU核数 * 期望CPU利用率 *（CPU计算时间 + 等待时间）/ CPU计算时间</code></li></ol><h2 id="12-5-ThreadPoolExecutor"><a href="#12-5-ThreadPoolExecutor" class="headerlink" title="12.5 ThreadPoolExecutor"></a>12.5 <code>ThreadPoolExecutor</code></h2><h3 id="1-构造-3"><a href="#1-构造-3" class="headerlink" title="1 构造"></a>1 构造</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, </span><br><span class="line">                    <span class="keyword">int</span> maximumPoolSize, </span><br><span class="line">                    <span class="keyword">long</span> keepAliveTime, </span><br><span class="line">                    TimeUnit unit, </span><br><span class="line">                    BlockingQueue&lt;Runnable&gt; workQueue, </span><br><span class="line">                    ThreadFactory threadFactory, </span><br><span class="line">                    RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>int corePoolSize</code></td><td>核心线程数</td></tr><tr><td><code>int maximumPoolSize</code></td><td>最大线程数</td></tr><tr><td><code>long keepAliveTime</code></td><td>线程最大空闲时间，如果线程池中线程数量超过 <code>corePoolSize</code>，超出线程空闲时间超过 <code>keepAliveTime</code> 会被终止</td></tr><tr><td><code>TimeUnit unit</code></td><td>空闲时间单位</td></tr><tr><td><code>BlockingQueue&lt;Runnable&gt; workQueue</code></td><td>任务阻塞队列</td></tr><tr><td><code>ThreadFactory threadFactory</code></td><td>线程工厂</td></tr><tr><td><code>RejectedExecutionHandler handler</code></td><td>拒绝策略</td></tr></tbody></table><h4 id="1-Enum-TimeUnit"><a href="#1-Enum-TimeUnit" class="headerlink" title="1 Enum TimeUnit"></a>1 <code>Enum TimeUnit</code></h4><h5 id="1-枚举项：时间粒度"><a href="#1-枚举项：时间粒度" class="headerlink" title="1 枚举项：时间粒度"></a>1 枚举项：时间粒度</h5><table><thead><tr><th>粒度</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><code>NANOSECONDS</code></td><td>纳秒 <code>ns</code></td><td><code>1 s  = 10<sup>9</sup> ns</code></td></tr><tr><td><code>MICROSECONDS</code></td><td>微秒 <code>μs</code></td><td><code>1 s  = 10<sup>6</sup> μs</code></td></tr><tr><td><code>MILLISECONDS</code></td><td>毫秒 <code>ms</code></td><td><code>1 s  = 10<sup>3</sup> ms</code></td></tr><tr><td><code>SECONDS</code></td><td>秒 <code>s</code></td><td></td></tr><tr><td><code>MINUTES</code></td><td>分 <code>min</code></td><td></td></tr><tr><td><code>HOURS</code></td><td>时 <code>h</code></td><td></td></tr><tr><td><code>DAYS</code></td><td>日 <code>d</code></td><td></td></tr></tbody></table><h5 id="2-方法：线程"><a href="#2-方法：线程" class="headerlink" title="2 方法：线程"></a>2 方法：线程</h5><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>sleep(long timeout)</code></td><td>当前线程睡眠当前粒度的 <code>timout</code>，替代 <code>Thread.sleep(timeout)</code></td></tr><tr><td><code>void</code></td><td><code>timedJoin(Thread thread, long timeout)</code></td><td>指定线程 <code>join</code> 当前粒度的 <code>timeout</code>，替代 <code>t.join(timout)</code></td></tr><tr><td><code>void</code></td><td><code>timedWait(Object obj, long timeout)</code></td><td>锁对象 <code>obj</code> 等待当前粒度的 <code>timout</code>，替代 <code>obj.wait(timout)</code></td></tr></tbody></table><h5 id="3-方法：时间粒度转换"><a href="#3-方法：时间粒度转换" class="headerlink" title="3 方法：时间粒度转换"></a>3 方法：时间粒度转换</h5><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>long</code></td><td><code>convert(Duration duration)</code></td><td>将指定时间间隔 <code>duration</code> 转换为当前粒度</td></tr><tr><td><code>long</code></td><td><code>convert(long sourceDuration, TimeUnit sourceUnit)</code></td><td>将指定数值 <code>sourceDuration</code> 的指定粒度 <code>sourceUnit</code> 转换为当前粒度</td></tr><tr><td><code>long</code></td><td><code>toNanos(long duration)</code></td><td>将指定数值 <code>duration</code> 的当前粒度转换为纳秒</td></tr><tr><td><code>long</code></td><td><code>toMicros(long duration)</code></td><td>将指定数值 <code>duration</code> 的当前粒度转换为微秒</td></tr><tr><td><code>long</code></td><td><code>toMillis(long duration)</code></td><td>将指定数值 <code>duration</code> 的当前粒度转换为毫秒</td></tr><tr><td><code>long</code></td><td><code>toSeconds(long duration)</code></td><td>将指定数值 <code>duration</code> 的当前粒度转换为秒</td></tr><tr><td><code>long</code></td><td><code>toMinutes(long duration)</code></td><td>将指定数值 <code>duration</code> 的当前粒度转换为分</td></tr><tr><td><code>long</code></td><td><code>toHours(long duration)</code></td><td>将指定数值 <code>duration</code> 的当前粒度转换为时</td></tr><tr><td><code>long</code></td><td><code>toDays(long duration)</code></td><td>将指定数值 <code>duration</code> 的当前粒度转换为日</td></tr></tbody></table><h4 id="2-ThreadFactory"><a href="#2-ThreadFactory" class="headerlink" title="2 ThreadFactory"></a>2 <code>ThreadFactory</code></h4><ol><li>默认使用 <code>Executors.defaultThreadFactory()</code></li><li>自定义线程工厂实现此接口</li><li>使用不同的工厂，可以更改线程名称，线程组，优先级，守护线程状态等等</li></ol><h4 id="3-RejectedExecutionHandler"><a href="#3-RejectedExecutionHandler" class="headerlink" title="3 RejectedExecutionHandler"></a>3 <code>RejectedExecutionHandler</code></h4><table><thead><tr><th>内置拒绝策略</th><th>说明</th></tr></thead><tbody><tr><td><code>AbortPolicy</code>（默认）</td><td>放弃本次任务，抛 <code>RejectedExecutionException</code> 异常</td></tr><tr><td><code>DiscardPolicy</code></td><td>放弃本次任务</td></tr><tr><td><code>DiscardOldestPolicy</code></td><td>放弃队列中最早的任务，本次任务取而代之</td></tr><tr><td><code>CallerRunsPolicy</code></td><td>让调用者处理任务</td></tr></tbody></table><ul><li>自定义拒绝策略实现此接口<ol><li><code>Dubbo</code> 的实现：抛 异常之前会记录日志，并 <code>dump</code> 线程栈信息，方便定位</li><li><code>Netty</code> 的实现：创建一个新线程来执行任务</li><li><code>ActiveMQ</code> 的实现：带超时等待（60s）尝试放入队列</li><li><code>PinPoint</code> 的实现：使用了一个拒绝策略链，会逐一尝试</li></ol></li></ul><h3 id="2-方法-2"><a href="#2-方法-2" class="headerlink" title="2 方法"></a>2 方法</h3><h4 id="1-提交任务"><a href="#1-提交任务" class="headerlink" title="1 提交任务"></a>1 提交任务</h4><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>`void</td><td><code>execute(Runnable command)</code></td><td>执行任务 <code>Runnable</code> 任务</td></tr><tr><td><code>&lt;T&gt; Future&lt;T&gt;</code></td><td><code>submit(Callable&lt;T&gt; task)</code></td><td>提交 <code>Callable</code> 任务，使用 <code>Future</code> 获取任务执行结果</td></tr><tr><td><code>Future&lt;?&gt;</code></td><td><code>submit(Runnable task)</code></td><td>提交 <code>Runnbale</code> 任务，使用 <code>Future</code> 获取任务执行结果</td></tr><tr><td>`<T> Future<T></td><td><code>submit(Runnable task, T result)</code></td><td>提交带返回值的 <code>Runnbale</code> 任务，使用 <code>Future</code> 获取任务执行结果</td></tr><tr><td><code>&lt;T&gt; List&lt;Future&lt;T&gt;&gt;</code></td><td><code>invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</code></td><td>提交多个任务</td></tr><tr><td><code>&lt;T&gt; List&lt;Future&lt;T&gt;&gt;</code></td><td><code>invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)</code></td><td>提交多个任务，带超时时间</td></tr><tr><td><code>&lt;T&gt; T</code></td><td><code>invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</code></td><td>提交多个任务，哪个任务先成功执行完毕则返回其结果，其它任务取消</td></tr><tr><td><code>&lt;T&gt; T</code></td><td><code>invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)</code></td><td>提交多个任务，哪个任务先成功执行完毕则返回其结果，其它任务取消，带超时时间</td></tr></tbody></table><h4 id="2-关闭线程池"><a href="#2-关闭线程池" class="headerlink" title="2 关闭线程池"></a>2 关闭线程池</h4><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>shutdown()</code></td><td>线程池状态变为 <code>Shutdown</code>，不再接收新任务，已提交任务会被执行完，此方法不会阻塞调用线程的执行</td></tr><tr><td><code>List&lt;Runnable&gt;</code></td><td><code>shutdownNow()</code></td><td>线程池状态变为 <code>Stop</code>，不再接收新任务，用 <code>interrupt()</code> 中断正在执行的任务，返回队列中等待执行的任务</td></tr><tr><td><code>boolean</code></td><td><code>isShutdown()</code></td><td>测试线程池是否关闭，线程池状态不为 <code>Running</code>，都会返回 <code>true</code></td></tr><tr><td><code>boolean</code></td><td><code>isTerminated()</code></td><td>测试是否所有任务都执行完毕了，线程池状态为 <code>Terminated</code>，返回 <code>true</code></td></tr><tr><td><code>boolean</code></td><td><code>awaitTermination(long timeout, TimeUnit unit)</code></td><td>由于调用 <code>shutdown</code> 后，调用线程并不会等待所有任务执行完毕，可以使用此方法等待线程池状态变为 <code>Terminated</code></td></tr></tbody></table><h2 id="12-6-Executors"><a href="#12-6-Executors" class="headerlink" title="12.6 Executors"></a>12.6 <code>Executors</code></h2><h3 id="1-固定大小线程池"><a href="#1-固定大小线程池" class="headerlink" title="1 固定大小线程池"></a>1 固定大小线程池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">return new ThreadPoolExecutor(nThreads, nThreads, </span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS, </span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>核心线程数 = 最大线程数，即不会有救急线程被创建，也就没有超时时间</li><li>阻塞队列 <code>LinkedBlockingQueue</code> 最大为 <code>Integer.MAX_VALUE</code></li><li>适合任务量已知，相对耗时的任务</li></ol><h3 id="2-带缓冲线程池"><a href="#2-带缓冲线程池" class="headerlink" title="2 带缓冲线程池"></a>2 带缓冲线程池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">return new ThreadPoolExecutor(0, Integer.MAX_VALUE, </span><br><span class="line">                                    60L, TimeUnit.SECONDS, </span><br><span class="line">                                    new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>核心线程数为 <code>0</code>，最大线程数为 <code>Integer.MAX_VALUE</code>，意味着全为救急线程，且超时时间为 <code>60s</code></li><li>阻塞队列 <code>SynchronousQueue</code> 没有容量，读写操作一一对应，意味着提交一个任务就必须马上执行</li><li>适合任务数比较密集，但每个任务耗时较短的情况</li></ol><h3 id="3-单线程线程池"><a href="#3-单线程线程池" class="headerlink" title="3 单线程线程池"></a>3 单线程线程池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService(</span><br><span class="line">    new ThreadPoolExecutor(1, 1, </span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS, </span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>核心线程数 = 最大线程数 = 1，即线程数固定为 1</li><li>适合多个任务排队执行</li><li>单线程线程池 &amp; 自己创建一个线程的区别<ol><li>自己创建一个线程，如果某个任务执行失败而终止，那么没有任何补救措施</li><li>单线程线程池会新创建一个线程，保证池中始终有一个工作线程，且线程池有任务阻塞队列</li></ol></li><li>单线程线程池 &amp; 数量为 1 的固定大小线程池的区别<ol><li>固定大小线程池对外暴漏的是 <code>ThreadPoolExecutor</code> 对象，所以可以使用其方法修改核心线程数</li><li>单线程线程池 <code>FinalizableDelegatedExecutorService</code> 使用的是装饰着模式，只对外暴漏了 <code>ExecutorService</code> 的方法，不能使用  <code>ThreadPoolExecutor</code> 的特有方法，无法修改</li></ol></li></ol><h3 id="4-任务调度线程池"><a href="#4-任务调度线程池" class="headerlink" title="4 任务调度线程池"></a>4 任务调度线程池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">super(corePoolSize, Integer.MAX_VALUE, </span><br><span class="line">DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>没有任务调度线程池之前，<code>java.util.Timer</code> 可以用来实现定时功能，缺点：<ol><li>所有任务由一个线程调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行</li><li>如果某一个任务出现异常，会影响到之后的任务</li></ol></li><li>任务调度线程池可以由不同的线程来执行任务，且某个任务出现异常也不会影响其它任务</li></ol><h2 id="12-7-ScheduledThreadPoolExecutor"><a href="#12-7-ScheduledThreadPoolExecutor" class="headerlink" title="12.7 ScheduledThreadPoolExecutor"></a>12.7 <code>ScheduledThreadPoolExecutor</code></h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>ScheduledFuture&lt;?&gt;</code></td><td><code>schedule(Runnable command, long delay, TimeUnit unit)</code></td><td>指定延迟后，执行 <code>Runnable</code> 任务</td></tr><tr><td><code>&lt;V&gt; ScheduledFuture&lt;V&gt;</code></td><td><code>schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code></td><td>指定延迟后，执行 <code>Callable</code> 任务</td></tr><tr><td><code>ScheduledFuture&lt;?&gt;</code></td><td><code>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code></td><td>初始延迟时间后开始执行任务，到达 <code>period</code> 间隔时间后，判断上一个任务是否执行完毕，若执行完毕则执行下一个任务，否则等待其执行完毕</td></tr><tr><td><code>ScheduledFuture&lt;?&gt;</code></td><td><code>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code></td><td>初始延迟时间后开始执行任务，上一个任务执行完毕后延迟指定时间再开始执行下一个任务</td></tr></tbody></table><h2 id="12-8-Fork-Join"><a href="#12-8-Fork-Join" class="headerlink" title="12.8 Fork/Join"></a>12.8 <code>Fork/Join</code></h2><h3 id="1-概述-11"><a href="#1-概述-11" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li><code>Fork/Join</code> 是 JDK 7 加入的新的线程池实现，体现的是一种分治思想，适用于能够进行任务拆分的 CPU 密集型运算</li><li>分支/合并框架的目的是以递归方式将可以并行的任务拆分成更小的任务，然后将每个子任务的结果合并起来生成整体结果</li><li><code>Fork/Join</code> 是 <code>ExecutorService</code> 接口的一个实现，它把子任务分配给线程池（称为 <code>ForkJoinPool</code> ）中的工作线程</li></ol><h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2 任务"></a>2 任务</h3><h4 id="1-概述-12"><a href="#1-概述-12" class="headerlink" title="1 概述"></a>1 概述</h4><ol><li><p>提交给 <code>Fork/Join</code> 线程池的任务需要继承 <code>ForkJoinTask&lt;V&gt;</code></p><ol><li><code>RecursiveTask&lt;V&gt;</code>：有返回值，<code>V</code>是并行化任务（以及所有子任务）产生的结果类型</li><li><code>RecursiveAction</code>：无返回值</li></ol></li><li><p>定义的任务， 只需实现它唯一的抽象方法 <code>V compute()</code>，此方法同时定义了：</p><ol><li>将任务拆分成子任务的逻辑</li><li>无法再拆分或不方便再拆分时，生成单个子任务结果的逻辑</li></ol></li><li><p><code>compute()</code> 伪代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (任务足够小或不可分) &#123;</span><br><span class="line">顺序计算该任务</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    将任务分成两个子任务</span><br><span class="line">    递归调用本方法，拆分每个子任务，等待所有子任务完成</span><br><span class="line">    合并每个子任务的结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-ForkJoinTask-lt-V-gt"><a href="#2-ForkJoinTask-lt-V-gt" class="headerlink" title="2 ForkJoinTask&lt;V&gt;"></a>2 <code>ForkJoinTask&lt;V&gt;</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinTask&lt;V&gt; fork()：使用 ForkJoinPool 中另一个线程异步执行子任务</span><br><span class="line">V join()：获取子任务结果，如果尚未完成就等待</span><br></pre></td></tr></table></figure><h3 id="3-工作窃取"><a href="#3-工作窃取" class="headerlink" title="3 工作窃取"></a>3 工作窃取</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96.png" alt=""></p><ol><li>理想情况下，划分并行任务时，应该让每个任务都用完全相同的时间完成，让所有的CPU内核都同样繁忙。不幸的是，实际中，每个子任务所花的时间可能天差地别</li><li>分支/合并框架工程用一种称为工作窃取（<code>work stealing</code>）的技术来解决这个问题</li><li>工作窃取算法用于在池中的工作线程之间重新分配和平衡任务<ol><li>每个线程都为分配给它的任务保存一个双向链式队列，每完成一个任务，就会从队列头上取出下一个任务开始执<br>行</li><li>某个线程可能早早完成了分配给它的所有任务，也就是它的队列已经空了，而其他的线程还很忙。这时，这个线程并没有闲下来，而是随机选了一个别的线程，从其队列的尾巴上“偷走”一个任务</li><li>这个过程一直继续下去，直到所有的任务都执行完毕，所有的队列都清空</li></ol></li></ol><h3 id="4-ForkJoinPool"><a href="#4-ForkJoinPool" class="headerlink" title="4 ForkJoinPool"></a>4 <code>ForkJoinPool</code></h3><h4 id="1-构造-4"><a href="#1-构造-4" class="headerlink" title="1 构造"></a>1 构造</h4><table><thead><tr><th>构造</th><th>说明</th></tr></thead><tbody><tr><td><code>ForkJoinPool()</code></td><td>默认会创建和 CPU 核心数相同大小的线程池</td></tr><tr><td><code>ForkJoinPool(int parallelism)</code></td><td>指定线程数</td></tr></tbody></table><h4 id="2-方法-3"><a href="#2-方法-3" class="headerlink" title="2 方法"></a>2 方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; T invoke(ForkJoinTask&lt;T&gt; task)</span><br><span class="line">void execute(ForkJoinTask&lt;?&gt; task)</span><br><span class="line">&lt;T&gt; ForkJoinTask&lt;T&gt; submit(ForkJoinTask&lt;T&gt; task)</span><br></pre></td></tr></table></figure><h1 id="十三-线程安全集合"><a href="#十三-线程安全集合" class="headerlink" title="十三 线程安全集合"></a>十三 线程安全集合</h1><h2 id="13-1-概述"><a href="#13-1-概述" class="headerlink" title="13.1 概述"></a>13.1 概述</h2><ol><li><p>遗留的线程安全集合如  <code>Hashtable</code> ， <code>Vector</code></p></li><li><p>使用 <code>Collections</code> 装饰的线程安全集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collections.synchronizedCollection</span><br><span class="line">Collections.synchronizedList</span><br><span class="line">Collections.synchronizedMap</span><br><span class="line">Collections.synchronizedSet</span><br><span class="line">Collections.synchronizedNavigableMap</span><br><span class="line">Collections.synchronizedNavigableSet</span><br><span class="line">Collections.synchronizedSortedMap</span><br><span class="line">Collections.synchronizedSortedSet</span><br></pre></td></tr></table></figure></li><li><p><code>java.util.concurrent.*</code></p><ol><li><code>Blocking</code>：大部分实现基于锁，并提供用来阻塞的方法</li><li><code>CopyOnWrite</code>：写开销相对较重</li><li><code>Concurrent</code>：<ol><li>内部很多操作使用 <code>CAS</code> 优化，一般可以提供较高吞吐量</li><li>弱一致性<ul><li>遍历时弱一致性：当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍<br>历，但这时内容是旧的（非安全容器会抛异常）</li><li>求大小弱一致性：size 操作未必是 100% 准确</li><li>读取弱一致性</li></ul></li></ol></li></ol></li></ol><h2 id="13-2-ConcurrentHashMap-lt-K-V-gt"><a href="#13-2-ConcurrentHashMap-lt-K-V-gt" class="headerlink" title="13.2 ConcurrentHashMap&lt;K,V&gt;"></a>13.2 <code>ConcurrentHashMap&lt;K,V&gt;</code></h2><h3 id="1-概述-13"><a href="#1-概述-13" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>JDK 7 中非线程安全的 Map 集合当元素下标相同时，会添加到链表的头部，而 JDK 8 则是添加到链表的尾部</li><li>JDK 7 中在多线程环境使用非线程安全的 Map 集合，当扩容时可能出现并发死链，JDK 8 虽然将扩容算法做了调整，但还是会出现其他问题，如扩容丢数据</li></ol><h3 id="2-重要属性和内部类"><a href="#2-重要属性和内部类" class="headerlink" title="2 重要属性和内部类"></a>2 重要属性和内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 默认为 0</span><br><span class="line">// 当初始化时, 为 -1</span><br><span class="line">// 当扩容时, 为 -(1 + 扩容线程数)</span><br><span class="line">// 当初始化或扩容完成后，为 下一次的扩容的阈值大小</span><br><span class="line">private transient volatile int sizeCtl;</span><br><span class="line"></span><br><span class="line">// 整个 ConcurrentHashMap 就是一个 Node[]</span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">// hash 表</span><br><span class="line">transient volatile Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">// 扩容时的 新 hash 表</span><br><span class="line">private transient volatile Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点</span><br><span class="line">static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node</span><br><span class="line">static final class ReservationNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 作为 treebin 的头节点, 存储 root 和 first</span><br><span class="line">static final class TreeBin&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 作为 treebin 的节点, 存储 parent, left, right</span><br><span class="line">static final class TreeNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-重要方法"><a href="#3-重要方法" class="headerlink" title="3 重要方法"></a>3 重要方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取 Node[] 中第 i 个 Node</span><br><span class="line">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i)</span><br><span class="line"></span><br><span class="line">// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值</span><br><span class="line">static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span><br><span class="line"></span><br><span class="line">// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值</span><br><span class="line">static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v)</span><br></pre></td></tr></table></figure><h2 id="13-3-CopyOnWriteArrayList"><a href="#13-3-CopyOnWriteArrayList" class="headerlink" title="13.3 CopyOnWriteArrayList"></a>13.3 <code>CopyOnWriteArrayList</code></h2><ol><li><code>ArrayList</code></li><li>每次写入时都会复制一个新的容器再写入</li><li>在迭代并添加时没有并发修改异常</li><li>每次写入都会复制，效率低，适合并发迭代</li></ol><h1 id="十四-java-lang-ThreadLocal-lt-T-gt"><a href="#十四-java-lang-ThreadLocal-lt-T-gt" class="headerlink" title="十四 java.lang.ThreadLocal&lt;T&gt;"></a>十四 <code>java.lang.ThreadLocal&lt;T&gt;</code></h1><h2 id="14-1-概述"><a href="#14-1-概述" class="headerlink" title="14.1 概述"></a>14.1 概述</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 ThreadLocal</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 Thread</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>ThreadLocal</code> 中有一个静态内部类 <code>ThreadLocalMap</code>，<code>ThreadLocalMap</code> 中有一个静态内部类 <code>Entry</code>，且维护了一个 <code>Entry</code> 类型的数组，其实数据最终存储在了 <code>Entry[]</code> 中</li><li><code>TheadLocalMap</code> 的键为 <code>ThreaLoal</code> 本身，值为自定义添加的值</li><li>一个 <code>ThreadLocalMap</code> 可以存储 <code>n</code> 个 <code>ThreadLocal</code>，所以存储时，会根据不同的  <code>ThreadLocal</code> 计算出不同的索引，此索引即存储到 <code>ThreadLocalMap</code> 中的 <code>Entry[]</code> 中的位置</li><li>每个线程对应一个 <code>ThreadLoaclMap</code> ，不同线程互不干扰</li><li>每个线程可以有多个不同的 <code>ThreadLocal</code>（如 <code>ThreadLocal&lt;A&gt;, ThreadLoacl&lt;B&gt;...</code>），所有 <code>ThreadLocal</code> 使用同一个 <code>ThreadLocalMap</code></li><li><code>Entry</code> 是一个弱引用<ol><li>如果是强引用，即使 <code>ThreadLocal tl = null</code> ，<code>Entry</code> 中的键依然指向 <code>ThreadLocal</code> ，会导致内存泄漏</li><li>弱引用还是有内存泄漏问题：当 <code>ThreadLocal</code> 为 <code>null</code> 被当成垃圾回收，但 <code>ThreadLocalMap</code> 生命周期和 <code>Thread</code> 一样，它不会回收，即 <code>Entry</code> 中的键为 <code>null</code> 了，而值还存在，但无法访问到了，所以使用完 <code>ThreadLocal</code> 后，执行 <code>remove()</code> 操作</li></ol></li></ol><h2 id="14-2-API"><a href="#14-2-API" class="headerlink" title="14.2 API"></a>14.2 API</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>set(T value)</code></td><td>此 <code>ThreadLocal</code> 作为键，<code>value</code> 作为值，存储到当前线程的 <code>ThreadLoaclMap</code> 中</td></tr><tr><td><code>T</code></td><td><code>get()</code></td><td>从当前线程的 <code>ThreadLoaclMap</code> 中，获取键 <code>ThreadLocal</code> 对应的值</td></tr><tr><td><code>void</code></td><td><code>remove()</code></td><td>从当前线程的 <code>ThreadLoaclMap</code> 中，移除此 <code>ThreadLocal</code> 的键值对</td></tr></tbody></table><h3 id="1-set"><a href="#1-set" class="headerlink" title="1 set"></a>1 <code>set</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的 ThreadLocalMap，如果已存在则直接使用，否则创建一个</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-get"><a href="#2-get" class="headerlink" title="2 get"></a>2 <code>get</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概念&quot;&gt;&lt;a href=&quot;#一-概念&quot; class=&quot;headerlink&quot; title=&quot;一 概念&quot;&gt;&lt;/a&gt;一 概念&lt;/h1&gt;&lt;h2 id=&quot;1-1-同步（Synchronous）-amp-异步（Asynchronous）&quot;&gt;&lt;a href=&quot;#1-1-同
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="Java" scheme="https://anyeansan.github.io/categories/CS/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-集合</title>
    <link href="https://anyeansan.github.io/2020/09/29/Java/Java-%E9%9B%86%E5%90%88/"/>
    <id>https://anyeansan.github.io/2020/09/29/Java/Java-%E9%9B%86%E5%90%88/</id>
    <published>2020-09-29T07:54:08.000Z</published>
    <updated>2020-09-29T07:54:24.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-java-util-Collection-lt-E-gt"><a href="#一-java-util-Collection-lt-E-gt" class="headerlink" title="一 java.util.Collection&lt;E&gt;"></a>一 <code>java.util.Collection&lt;E&gt;</code></h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/Collection.png" alt=""></p><h2 id="1-1-API"><a href="#1-1-API" class="headerlink" title="1.1 API"></a>1.1 API</h2><h3 id="1-增"><a href="#1-增" class="headerlink" title="1 增"></a>1 增</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>add(E e)</code></td><td>添加一个元素</td></tr><tr><td><code>boolean</code></td><td><code>addAll(Collection&lt;? extends E&gt; c)</code></td><td>添加一个集合的元素</td></tr></tbody></table><h3 id="2-删"><a href="#2-删" class="headerlink" title="2 删"></a>2 删</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>remove(Object o)</code></td><td>删除一个元素</td></tr><tr><td><code>boolean</code></td><td><code>removeAll(Collection&lt;?&gt; c)</code></td><td>删除交集</td></tr><tr><td><code>default boolean</code></td><td><code>removeIf(Predicate&lt;? super E&gt; filter)</code></td><td>删除符合条件的元素</td></tr><tr><td><code>void</code></td><td><code>clear()</code></td><td>清空集合</td></tr></tbody></table><h3 id="3-判断"><a href="#3-判断" class="headerlink" title="3 判断"></a>3 判断</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>contains(Object o)</code></td><td>判断是否包含指定元素</td></tr><tr><td><code>boolean</code></td><td><code>containsAll(Collection&lt;?&gt; c)</code></td><td>判断是否包含指定集合</td></tr><tr><td><code>boolean</code></td><td><code>isEmpty()</code></td><td>判断是否为空</td></tr></tbody></table><h3 id="4-获取"><a href="#4-获取" class="headerlink" title="4 获取"></a>4 获取</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>size()</code></td><td>获取元素个数</td></tr><tr><td><code>boolean</code></td><td><code>retainAll(Collection&lt;?&gt; c)</code></td><td>取交集</td></tr></tbody></table><h3 id="5-转换"><a href="#5-转换" class="headerlink" title="5 转换"></a>5 转换</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Object[]</code></td><td><code>toArray()</code></td><td>集合 → 数组</td></tr><tr><td><code>&lt;T&gt; T[]</code></td><td><code>toArray(T[] a)</code></td><td>集合 → 指定类型的数组（建议传入数组 <code>length = size</code>）</td></tr><tr><td><code>default &lt;T&gt; T[]</code></td><td><code>toArray(IntFunction&lt;T[]&gt; generator)</code></td><td>集合 → 指定类型的数组（由函数生成）</td></tr></tbody></table><h3 id="6-遍历"><a href="#6-遍历" class="headerlink" title="6 遍历"></a>6 遍历</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Iterator&lt;E&gt;</code></td><td><code>iterator()</code></td><td>获取迭代器</td></tr><tr><td><code>default Spliterator&lt;E&gt;</code></td><td><code>spliterator()</code></td><td>获取并行迭代器</td></tr></tbody></table><h3 id="7-流"><a href="#7-流" class="headerlink" title="7 流"></a>7 流</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>default Stream&lt;E&gt;</code></td><td><code>stream()</code></td><td>获取顺序流</td></tr><tr><td><code>default Stream&lt;E&gt;</code></td><td><code>parallelStream()</code></td><td>获取并行流</td></tr></tbody></table><h2 id="1-2-java-util-List-lt-E-gt"><a href="#1-2-java-util-List-lt-E-gt" class="headerlink" title="1.2 java.util.List&lt;E&gt;"></a>1.2 <code>java.util.List&lt;E&gt;</code></h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>元素有序（存取顺序一致）</li><li>元素有索引</li><li>元素可以重复</li></ol><h3 id="2-API"><a href="#2-API" class="headerlink" title="2 API"></a>2 API</h3><h4 id="1-增-1"><a href="#1-增-1" class="headerlink" title="1 增"></a>1 增</h4><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>add(int index, E element)</code></td><td>在指定位置插入元素</td></tr><tr><td><code>boolean</code></td><td><code>addAll(int index, Collection&lt;? extends E&gt; c)</code></td><td>在指定位置插入一个集合的元素</td></tr></tbody></table><h4 id="2-删-1"><a href="#2-删-1" class="headerlink" title="2 删"></a>2 删</h4><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>E</code></td><td><code>remove(int index)</code></td><td>删除指定位置的元素并返回</td></tr></tbody></table><h4 id="3-改"><a href="#3-改" class="headerlink" title="3 改"></a>3 改</h4><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>E</code></td><td><code>set(int index, E element)</code></td><td>修改指定位置的元素</td></tr></tbody></table><h4 id="4-查"><a href="#4-查" class="headerlink" title="4 查"></a>4 查</h4><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>indexOf(Object o)</code></td><td>从头开始查询元素第一次出现的索引</td></tr><tr><td><code>int</code></td><td><code>lastIndexOf(Object o)</code></td><td>从尾开始查询元素第一次出现的索引</td></tr></tbody></table><h4 id="5-获取"><a href="#5-获取" class="headerlink" title="5 获取"></a>5 获取</h4><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>E</code></td><td><code>get(int index)</code></td><td>获取指定位置的元素</td></tr><tr><td><code>List&lt;E&gt;</code></td><td><code>subList(int fromIndex, int toIndex)</code></td><td>截取集合 <code>[from, to)</code></td></tr><tr><td><code>static &lt;E&gt; List&lt;E&gt;</code></td><td><code>of(E... elements)</code></td><td>获取包含指定元素的不可修改（只读）的 <code>List</code> 集合</td></tr><tr><td><code>static &lt;E&gt; List&lt;E&gt;</code></td><td><code>copyOf(Collection&lt;? extends E&gt; coll)</code></td><td>如果传入的集合是不可变的则直接返回，否则通过 <code>of</code> 创建一个包含其元素的不可修改的 <code>List</code> 集合（顺序为指定集合元素的迭代顺序）</td></tr></tbody></table><h4 id="6-遍历-1"><a href="#6-遍历-1" class="headerlink" title="6 遍历"></a>6 遍历</h4><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>ListIterator&lt;E&gt;</code></td><td><code>listIterator()</code></td><td>获取 <code>ListIterator</code> 迭代器</td></tr><tr><td><code>ListIterator&lt;E&gt;</code></td><td><code>listIterator(int index)</code></td><td>获取 <code>ListIterator</code> 迭代器，从指定索引开始</td></tr></tbody></table><h3 id="3-ArrayList"><a href="#3-ArrayList" class="headerlink" title="3 ArrayList"></a>3 <code>ArrayList</code></h3><h4 id="1-构造"><a href="#1-构造" class="headerlink" title="1 构造"></a>1 构造</h4><table><thead><tr><th>构造</th><th>说明</th></tr></thead><tbody><tr><td><code>ArrayList()</code></td><td>默认容量为 <code>10</code>，每次扩容为原容量的 1.5 倍（JDK8以后，创建时 <code>{}</code>，第一次添加时才创建容量 10 的数组）</td></tr><tr><td><code>ArrayList(int initialCapacity)</code></td><td>指定容量</td></tr><tr><td><code>ArrayList(Collection&lt;? extends E&gt; c)</code></td><td>包含指定集合元素</td></tr></tbody></table><h4 id="2-ArrayList-VS-Vector"><a href="#2-ArrayList-VS-Vector" class="headerlink" title="2 ArrayList VS Vector"></a>2 <code>ArrayList VS Vector</code></h4><ol><li><code>ArrayList</code> 非同步，<code>Vector</code> 同步</li><li><code>ArrayList</code> 扩容是原来的 1.5 倍，<code>Vector</code> 扩容是原来的 2 倍</li><li><code>Vector</code> 支持 <code>Enumeration</code> </li></ol><h3 id="4-Stack"><a href="#4-Stack" class="headerlink" title="4 Stack"></a>4 <code>Stack</code></h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>empty()</code></td><td>判断是否为空</td></tr><tr><td><code>E</code></td><td><code>peek()</code></td><td>获取但不弹出栈顶元素</td></tr><tr><td><code>E</code></td><td><code>pop()</code></td><td>弹栈（获取并弹出栈顶元素）</td></tr><tr><td><code>E</code></td><td><code>push(E item)</code></td><td>压栈（将元素添加到栈顶）</td></tr><tr><td><code>int</code></td><td><code>serach(Object o)</code></td><td>返回指定元素的位置编号（栈顶为 1）</td></tr></tbody></table><h2 id="1-3-java-util-Set-lt-E-gt"><a href="#1-3-java-util-Set-lt-E-gt" class="headerlink" title="1.3 java.util.Set&lt;E&gt;"></a>1.3 <code>java.util.Set&lt;E&gt;</code></h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>元素唯一，不保证存取顺序<ul><li><code>HashSet</code>：元素存取无序</li><li><code>LinkedHashSet</code>：元素存取有序</li><li><code>TreeSet</code>：元素存取无序但会排序</li></ul></li><li><code>Set</code> 集合底层依赖于 <code>Map</code> 集合，添加到 <code>Set</code> 中的元素作为键，一个内部的共享对象作为值</li></ol><h3 id="2-API-1"><a href="#2-API-1" class="headerlink" title="2 API"></a>2 API</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static &lt;E&gt; Set&lt;E&gt;</code></td><td><code>of(E... elements)</code></td><td>获取包含指定元素的不可修改的 <code>Set</code> 集合</td></tr><tr><td><code>static &lt;E&gt; Set&lt;E&gt;</code></td><td><code>copyOf(Collection&lt;? extends E&gt; coll)</code></td><td>获取包含指定集合中所有元素的不可修改的 <code>Set</code> 集合</td></tr></tbody></table><h3 id="3-HashSet-amp-LinkedHashSet"><a href="#3-HashSet-amp-LinkedHashSet" class="headerlink" title="3 HashSet &amp; LinkedHashSet"></a>3 <code>HashSet</code> &amp; <code>LinkedHashSet</code></h3><ol><li>添加元素时，首先 <code>hashCode()</code> 获取元素的哈希值，然后根据某种算法，算出底层数组中的存放位置<ul><li>如果此位置上没有元素，则添加成功</li><li>如果此位置上有元素<ul><li>首先比较哈希值，如果哈希值不同，则添加成功</li><li>如果哈希值相同，则比较 <code>equals()</code></li></ul></li></ul></li><li>元素要存入 <code>HashSet</code> 需要重写 <code>hashCode()</code> 和 <code>equals()</code> 方法</li><li>一个位置多个元素以链表形式存储多个元素，七上八下：<ul><li>jdk7：新元素在上，指向旧元素</li><li>jdk8：新元素在下，旧元素指向新元素</li></ul></li></ol><h3 id="4-TreeSet"><a href="#4-TreeSet" class="headerlink" title="4 TreeSet"></a>4 <code>TreeSet</code></h3><ol><li>元素具有比较性，元素实现 <code>Comparable</code> 接口</li><li>集合具有比较性，集合传入一个实现了 <code>Comparator</code> 接口的比较器</li><li><code>TreeSet</code> 判断元素是否相同，就是看到比较结果</li></ol><h2 id="1-4-Queue-lt-E-gt"><a href="#1-4-Queue-lt-E-gt" class="headerlink" title="1.4 Queue&lt;E&gt;"></a>1.4 <code>Queue&lt;E&gt;</code></h2><h3 id="1-API"><a href="#1-API" class="headerlink" title="1 API"></a>1 API</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>add(E e)</code></td><td>向队列末尾添加元素，如果队列已满则抛异常 <code>IllegalStateException</code></td></tr><tr><td><code>boolean</code></td><td><code>offer(E e)</code></td><td>向队列末尾添加元素，如果队列已满则返回 <code>false</code></td></tr><tr><td><code>E</code></td><td><code>element()</code></td><td>获取但不移除队列第一个元素，如果队列为空则抛异常 <code>NoSuchElementEsxception</code></td></tr><tr><td><code>E</code></td><td><code>peek()</code></td><td>获取但不移除队列第一个元素，如果队列为空则返回 <code>null</code></td></tr><tr><td><code>E</code></td><td><code>remove()</code></td><td>获取并移除队列第一个元素，如果队列为空则则抛异常 <code>NoSuchElementEsxception</code></td></tr><tr><td><code>E</code></td><td><code>poll()</code></td><td>获取并移除队列第一个元素，如果队列为空则返回 <code>null</code></td></tr></tbody></table><h3 id="2-Deque-lt-E-gt"><a href="#2-Deque-lt-E-gt" class="headerlink" title="2 Deque&lt;E&gt;"></a>2 <code>Deque&lt;E&gt;</code></h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>addFirst(E e)</code></td><td>向队列首部添加元素，如果队列已满则抛异常 <code>IllegalStateException</code></td></tr><tr><td><code>boolean</code></td><td><code>offerFirst(E e)</code></td><td>向队列首部添加元素，如果队列已满则返回 <code>false</code></td></tr><tr><td><code>void</code></td><td><code>addLast(E e)</code></td><td>向队列尾部添加元素，如果队列已满则抛异常 <code>IllegalStateException</code></td></tr><tr><td><code>boolean</code></td><td><code>offerLast(E e)</code></td><td>向队列尾部添加元素，如果队列已满则返回 <code>false</code></td></tr><tr><td><code>E</code></td><td><code>getFirst()</code></td><td>获取但不移除队列第一个元素，如果队列为空则抛异常 <code>NoSuchElementEsxception</code></td></tr><tr><td><code>E</code></td><td><code>peekFirst()</code></td><td>获取但不移除队列第一个元素，如果队列为空则返回 <code>null</code></td></tr><tr><td><code>E</code></td><td><code>getLast()</code></td><td>获取但不移除队列最后一个元素，如果队列为空则抛异常 <code>NoSuchElementEsxception</code></td></tr><tr><td><code>E</code></td><td><code>peekLast()</code></td><td>获取但不移除队列最后一个元素，如果队列为空则返回 <code>null</code></td></tr><tr><td><code>E</code></td><td><code>removeFirst()</code></td><td>获取并移除队列第一个元素，如果队列为空则则抛异常 <code>NoSuchElementEsxception</code></td></tr><tr><td><code>E</code></td><td><code>pollFirst()</code></td><td>获取并移除队列第一个元素，如果队列为空则返回 <code>null</code></td></tr><tr><td><code>E</code></td><td><code>removeLast()</code></td><td>获取并移除队列最后一个元素，如果队列为空则则抛异常 <code>NoSuchElementEsxception</code></td></tr><tr><td><code>E</code></td><td><code>pollLast()</code></td><td>获取并移除队列最后一个元素，如果队列为空则返回 <code>null</code></td></tr></tbody></table><h3 id="3-BlockingQueue-lt-E-gt"><a href="#3-BlockingQueue-lt-E-gt" class="headerlink" title="3 BlockingQueue&lt;E&gt;"></a>3 <code>BlockingQueue&lt;E&gt;</code></h3><h4 id="1-API-1"><a href="#1-API-1" class="headerlink" title="1 API"></a>1 API</h4><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>add(E e)</code></td><td>向队列末尾添加元素，如果队列已满则抛异常 <code>IllegalStateException</code></td></tr><tr><td><code>boolean</code></td><td><code>offer(E e)</code></td><td>向队列末尾添加元素，如果队列已满则返回 <code>false</code></td></tr><tr><td><code>boolean</code></td><td><code>offer(E e, long timeout, TimeUnit unit)</code></td><td>向队列末尾添加元素，如果队列已满会尝试指定时间，超时则返回 <code>false</code></td></tr><tr><td><code>void</code></td><td><code>put(E e)</code></td><td>向队列末尾添加元素，如果队列已满则阻塞等待</td></tr><tr><td><code>E</code></td><td><code>remove()</code></td><td>获取并移除队列第一个元素，如果队列为空则则抛异常 <code>NoSuchElementEsxception</code></td></tr><tr><td><code>E</code></td><td><code>poll()</code></td><td>获取并移除队列第一个元素，如果队列为空则返回 <code>null</code></td></tr><tr><td><code>E</code></td><td><code>poll(long timeout, TimeUnit unit)</code></td><td>获取并移除队列第一个元素，如果队列为空会尝试指定时间，超时则返回 <code>null</code></td></tr><tr><td><code>E</code></td><td><code>take()</code></td><td>获取并移除队列第一个元素，如果队列为空则阻塞等待</td></tr><tr><td><code>E</code></td><td><code>element()</code></td><td>获取但不移除队列第一个元素，如果队列为空则抛异常 <code>NoSuchElementEsxception</code></td></tr><tr><td><code>E</code></td><td><code>peek()</code></td><td>获取但不移除队列第一个元素，如果队列为空则返回 <code>null</code></td></tr></tbody></table><table><thead><tr><th></th><th><code>Throws exception</code></th><th><code>Special value</code></th><th><code>Times out</code></th><th><code>Blocks</code></th></tr></thead><tbody><tr><td>增加</td><td><code>add(e)</code></td><td><code>offer(e)</code></td><td><code>offer(e, time, unit)</code></td><td><code>put(e)</code></td></tr><tr><td>删除</td><td><code>remove()</code></td><td><code>poll()</code></td><td><code>poll(time, unit)</code></td><td><code>take()</code></td></tr><tr><td>检测队首元素</td><td><code>element()</code></td><td><code>peek()</code></td><td></td><td></td></tr></tbody></table><h4 id="2-实现类"><a href="#2-实现类" class="headerlink" title="2 实现类"></a>2 实现类</h4><table><thead><tr><th>类</th><th>说明</th></tr></thead><tbody><tr><td><code>ArrayBlockingQueue</code></td><td>数组结构的有界阻塞队列</td></tr><tr><td><code>LinkedBlockingQueue</code></td><td>链表结构的有界阻塞队列（默认 <code>Integer.MAX_VALUE</code>，也可以看作是无界的）</td></tr><tr><td><code>SynchronousQueue</code></td><td>容量为 0，是一个不存储元素的阻塞队列，读写操作配对出现，只有一个时会阻塞等待</td></tr><tr><td><code>DelayQueue</code></td><td>优先级堆支持的，基于时间的调度队列（元素按阻塞程度排序，会先获取阻塞低的元素）</td></tr><tr><td><code>PriorityBlockingQueue</code></td><td>优先级堆支持的无界优先级队列（内部使用二叉树排好了序）</td></tr></tbody></table><h1 id="二-java-util-Map-lt-K-V-gt"><a href="#二-java-util-Map-lt-K-V-gt" class="headerlink" title="二 java.util.Map&lt;K,V&gt;"></a>二 <code>java.util.Map&lt;K,V&gt;</code></h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/Map.png" alt=""></p><table><thead><tr><th>类</th><th>说明</th></tr></thead><tbody><tr><td><code>HashMap</code></td><td>键唯一，存取无序，<code>null</code> 可以作为键和值，线程不安全（非同步）</td></tr><tr><td><code>HashTable</code></td><td>键唯一，存取无序，<code>null</code> 不能作为键和值，线程安全（同步）</td></tr><tr><td><code>LinkedHashMap</code></td><td>键唯一，存取有序</td></tr><tr><td><code>Properties</code></td><td>键唯一，存取无序，键值必须是字符串</td></tr><tr><td><code>TreeMap</code></td><td>键唯一，存取无序，元素根据键排序</td></tr></tbody></table><h2 id="2-2-键唯一性"><a href="#2-2-键唯一性" class="headerlink" title="2.2 键唯一性"></a>2.2 键唯一性</h2><h3 id="1-HashMap-HashTable-LinkedHashMap-Properties"><a href="#1-HashMap-HashTable-LinkedHashMap-Properties" class="headerlink" title="1 HashMap HashTable LinkedHashMap Properties"></a>1 <code>HashMap HashTable LinkedHashMap Properties</code></h3><ol><li><code>hashCode()</code></li><li><code>equals()</code></li></ol><h3 id="2-TreeMap"><a href="#2-TreeMap" class="headerlink" title="2 TreeMap"></a>2 <code>TreeMap</code></h3><ol><li>键具有比较性</li><li>集合传入比较器</li></ol><h2 id="2-3-API"><a href="#2-3-API" class="headerlink" title="2.3 API"></a>2.3 API</h2><h3 id="1-增-2"><a href="#1-增-2" class="headerlink" title="1 增"></a>1 增</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>V</code></td><td><code>put​(K key, V value)</code></td><td>添加键值对，若 key 已存在返回 value，否则返回 null</td></tr><tr><td><code>void</code></td><td><code>putAll(Map m)</code></td><td>添加一个集合的键值对</td></tr><tr><td><code>default V</code></td><td><code>putIfAbsent(K key, V value)</code></td><td>如果指定的 <code>key</code> 没有值或值为 <code>null</code>，则将其值设置为指定 <code>value</code>，否则返回已有的值</td></tr></tbody></table><h3 id="2-删-2"><a href="#2-删-2" class="headerlink" title="2 删"></a>2 删</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>V</code></td><td><code>remove(Object key)</code></td><td>根据指定 <code>key</code> 删除并返回 <code>value</code>，若不存在则返回 <code>null</code></td></tr><tr><td><code>default boolean</code></td><td><code>remove(Object key, Object value)</code></td><td>删除指定键值对</td></tr><tr><td><code>void</code></td><td><code>clear()</code></td><td>清空集合</td></tr></tbody></table><h3 id="3-获取"><a href="#3-获取" class="headerlink" title="3 获取"></a>3 获取</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>V</code></td><td><code>get(Object key)</code></td><td>根据指定 <code>key</code> 获取 <code>value</code>，若不存在则返回 <code>null</code></td></tr><tr><td><code>default V</code></td><td><code>getOrDefault(Object key, V defaultValue)</code></td><td>根据指定 <code>key</code> 获取 <code>value</code>，若不存在则返回 <code>defaultValue</code></td></tr><tr><td><code>int</code></td><td><code>size()</code></td><td>获取键值对个数</td></tr><tr><td><code>static &lt;K, V&gt; Map&lt;K, V&gt;</code></td><td><code>copyOf(Map&lt;? extends K, ? extends V&gt; map)</code></td><td>获取包含指定集合键值对的不可修改的 <code>Map</code> 集合</td></tr></tbody></table><h3 id="4-判断"><a href="#4-判断" class="headerlink" title="4 判断"></a>4 判断</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>isEmpty()</code></td><td>是否为空</td></tr><tr><td><code>boolean</code></td><td><code>containsKey(Object key)</code></td><td>是否包含指定 <code>key</code></td></tr><tr><td><code>boolean</code></td><td><code>containsValue(Object value)</code></td><td>是否包含指定 <code>value</code></td></tr></tbody></table><h3 id="5-遍历"><a href="#5-遍历" class="headerlink" title="5 遍历"></a>5 遍历</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Set&lt;K&gt;</code></td><td><code>keySet()</code></td><td>获取所有 <code>key</code> 的 <code>Set</code> 集合</td></tr><tr><td><code>Collection&lt;V&gt;</code></td><td><code>values()</code></td><td>获取所有 <code>value</code> 的集合</td></tr><tr><td><code>Set&lt;Map.Entry&lt;K, V&gt;&gt;</code></td><td><code>entrySet()</code></td><td>获取所有键值对映射关系的 <code>Set</code> 集合</td></tr><tr><td><code>default void</code></td><td><code>forEach(BiConsumer&lt;? super K, ? super V&gt; action)</code></td><td>遍历键值对并消费</td></tr></tbody></table><h2 id="2-4-HashMap"><a href="#2-4-HashMap" class="headerlink" title="2.4 HashMap"></a>2.4 <code>HashMap</code></h2><h3 id="1-JDK7：数组-链表"><a href="#1-JDK7：数组-链表" class="headerlink" title="1 JDK7：数组 + 链表"></a>1 JDK7：数组 + 链表</h3><h4 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1 相关概念"></a>1 相关概念</h4><ol><li><code>DEFAULT_INITIAL_CAPACITY = 16</code> <ul><li>默认初始容量</li></ul></li><li><code>DEFAULT_LOAD_FACTOR = 0.75f</code><ul><li>默认加载因子</li></ul></li><li><code>threshold = capacity * loadFactor</code><ul><li>阈值/临界值，到达此值数组需要扩容</li></ul></li></ol><h4 id="2-过程"><a href="#2-过程" class="headerlink" title="2 过程"></a>2 过程</h4><ol><li>构造时，初始化一个长度为 16 的 <code>Entry[]</code> 数组，并算出 <code>threshold</code> 阈值</li><li>每次 <code>put()</code>  添加时，先获取 <code>key</code> 的哈希值，然后根据某种算法计算出在 <code>Entry[]</code> 数组中的存放位置<ul><li>如果此位置没有数据，则将键值对构建为 <code>Entry</code> 对象添加成功</li><li>如果此位置有数据，则比较新加 <code>key</code> 与已存在 <code>key</code> 的哈希值<ul><li>如果不同，则添加成功</li><li>如果相同，则继续比较 <code>key</code> 的 <code>equals()</code><ul><li>如果不同，则添加成功</li><li>如果相同，则覆盖 <code>value</code></li></ul></li></ul></li></ul></li><li><code>key</code> 不重复时，当大于等于阈值且要存储的位置没有数据时需要扩容（默认变为原容量 2 倍），且集合元素重新计算位置</li><li>同一位置的多个数据以链表形式存在，新元素在上边，旧元素会作为新元素的 <code>next</code></li></ol><h3 id="2-JDK8：数组-链表-红黑树"><a href="#2-JDK8：数组-链表-红黑树" class="headerlink" title="2 JDK8：数组 + 链表/红黑树"></a>2 JDK8：数组 + 链表/红黑树</h3><h4 id="1-相关概念-1"><a href="#1-相关概念-1" class="headerlink" title="1 相关概念"></a>1 相关概念</h4><ol><li><code>DEFAULT_INITIAL_CAPACITY = 16</code> <ul><li>默认初始容量</li></ul></li><li><code>DEFAULT_LOAD_FACTOR = 0.75f</code><ul><li>默认加载因子</li></ul></li><li><code>MAXIMUM_CAPACITY = 1 &lt;&lt; 30</code><ul><li>最大容量</li></ul></li><li><code>TREEIFY_THRESHOLD = 8</code><ul><li>树化阈值，当链表长度达到此长度时，要考虑树化</li></ul></li><li><code>UNTREEIFY_THRESHOLD = 6</code><ul><li>反树化阈值，当树中的节点个数到达此值时，要考虑变为链表</li></ul></li><li><code>MIN_TREEIFY_CAPACITY = 64</code><ul><li>最小树化容量，当达到树化阈值且容量不小于次之时，才会树化</li></ul></li><li><code>threshold = capacity * loadFactor</code><ul><li>阈值/临界值，当已用容量到达此值数值时，要考虑扩容</li></ul></li></ol><h4 id="2-过程-1"><a href="#2-过程-1" class="headerlink" title="2 过程"></a>2 过程</h4><ol><li>构造时，没有初始化数组</li><li>第一次 <code>put()</code> 添加时，将数组初始化为长度为 16 的 <code>Node[]</code> 数组，并算出 <code>threshold</code> 阈值</li><li>添加时过程相同，区别在于链表存储时七上八下，jdk8新的元素在下边，旧元素的 <code>next</code> 指向新元素</li><li>添加时还需要判断该索引下是否已经是树结构<ol><li>如果不是，则判断是否需要树化，当达到树化阈值及树化容量时，会将链表变为红黑树</li><li>如果是，则添加</li></ol></li><li>添加时还需要判断扩容问题</li></ol><h2 id="2-5-Properties"><a href="#2-5-Properties" class="headerlink" title="2.5 Properties"></a>2.5 <code>Properties</code></h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>String</code></td><td><code>getProperty(String key)</code></td><td>根据 <code>key</code> 获取 <code>value</code>，若不存在则返回 <code>null</code></td></tr><tr><td><code>String</code></td><td><code>getProperty(String key, String defaultValue)</code></td><td>根据 <code>key</code> 获取 <code>value</code>，若不存在则返回 <code>defaultValue</code></td></tr><tr><td><code>Object</code></td><td><code>setProperty(String key, String value)</code></td><td>添加键值对，调用的 <code>HashTable</code> 的 <code>put</code> 方法</td></tr><tr><td><code>Set&lt;String&gt;</code></td><td><code>stringPropertyNames()</code></td><td>获取所有 <code>key</code> 的 <code>Set</code> 集合</td></tr><tr><td><code>Enumeration&lt;?&gt;</code></td><td><code>propertyNames()</code></td><td>获取所有 <code>key</code> 的枚举</td></tr><tr><td><code>void</code></td><td><code>load(InputStream inStream)</code></td><td>从字节输入流中读取键值对数据</td></tr><tr><td><code>void</code></td><td><code>load(Reader reader)</code></td><td>从字符输入流中读取键值对数据</td></tr><tr><td><code>void</code></td><td><code>store(OutputStream out, String comments)</code></td><td>将键值对数据写入字节输出流，<code>comment</code> 为描述信息</td></tr><tr><td><code>void</code></td><td><code>store(Writer writer, String comments)</code></td><td>将键值对数据写入字符输出流</td></tr></tbody></table><h1 id="三-集合遍历"><a href="#三-集合遍历" class="headerlink" title="三 集合遍历"></a>三 集合遍历</h1><h2 id="3-1-java-lang-Iterable-lt-T-gt"><a href="#3-1-java-lang-Iterable-lt-T-gt" class="headerlink" title="3.1 java.lang.Iterable&lt;T&gt;"></a>3.1 <code>java.lang.Iterable&lt;T&gt;</code></h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Iterator&lt;T&gt;</code></td><td><code>iterator()</code></td><td>获取迭代器</td></tr><tr><td><code>default Spliterator&lt;T&gt;</code></td><td><code>spliterator()</code></td><td>获取并行迭代器</td></tr><tr><td><code>default void</code></td><td><code>forEach(Consumer&lt;? super T&gt; action)</code></td><td>增强 for 循环</td></tr></tbody></table><h2 id="3-2-java-util-Iterator-lt-E-gt"><a href="#3-2-java-util-Iterator-lt-E-gt" class="headerlink" title="3.2 java.util.Iterator&lt;E&gt;"></a>3.2 <code>java.util.Iterator&lt;E&gt;</code></h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>hasNext()</code></td><td>判断是否有下一个元素</td></tr><tr><td><code>E</code></td><td><code>next()</code></td><td>获取下一个元素</td></tr><tr><td><code>default void</code></td><td><code>remove()</code></td><td>删除 <code>next()</code> 获取的元素，即删除之前要先获取</td></tr><tr><td><code>default void</code></td><td><code>forEachRemaining​(Consumer&lt;? super E&gt; action)</code></td><td>遍历并消费元素</td></tr></tbody></table><h2 id="3-3-java-util-ListIterator-lt-E-gt"><a href="#3-3-java-util-ListIterator-lt-E-gt" class="headerlink" title="3.3 java.util.ListIterator&lt;E&gt;"></a>3.3 <code>java.util.ListIterator&lt;E&gt;</code></h2><h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h3><ol><li><code>ListIterator</code> 是 <code>Iterator</code> 的子接口</li><li>在迭代时可以添加修改元素，且可以往回迭代</li></ol><h3 id="2-API-2"><a href="#2-API-2" class="headerlink" title="2 API"></a>2 API</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>hasNext()</code></td><td>判断是否有下一个元素</td></tr><tr><td><code>E</code></td><td><code>next()</code></td><td>获取下一个元素</td></tr><tr><td><code>int</code></td><td><code>nextIndex()</code></td><td>获取下一个元素的索引</td></tr><tr><td><code>boolean</code></td><td><code>hasPrevious()</code></td><td>判断是否有上一个元素</td></tr><tr><td><code>E</code></td><td><code>previous()</code></td><td>获取上一个元素</td></tr><tr><td><code>int</code></td><td><code>previousIndex()</code></td><td>获取上一个元素的索引</td></tr><tr><td><code>void</code></td><td><code>add(E e)</code></td><td>添加元素</td></tr><tr><td><code>void</code></td><td><code>remove()</code></td><td>删除 <code>next()</code> 或 <code>previous()</code> 获取的元素</td></tr><tr><td><code>void</code></td><td><code>set(E e)</code></td><td>修改 <code>next()</code> 或 <code>previous()</code> 获取的元素</td></tr></tbody></table><h2 id="3-4-集合遍历的方式"><a href="#3-4-集合遍历的方式" class="headerlink" title="3.4 集合遍历的方式"></a>3.4 集合遍历的方式</h2><h3 id="1-集合转为数组，使用普通-for-循环"><a href="#1-集合转为数组，使用普通-for-循环" class="headerlink" title="1 集合转为数组，使用普通 for 循环"></a>1 集合转为数组，使用普通 for 循环</h3><ul><li>遍历时可以增删，索引要相应变化</li></ul><h3 id="2-迭代器"><a href="#2-迭代器" class="headerlink" title="2 迭代器"></a>2 迭代器</h3><ol><li>遍历时如果增会发生并发修改异常 <code>ConcurrentModifyException</code></li><li>遍历时可以使用迭代器的删除方法进行删除</li></ol><h3 id="3-增强-for-循环"><a href="#3-增强-for-循环" class="headerlink" title="3 增强 for 循环"></a>3 增强 for 循环</h3><ol><li><code>Iterable</code> 接口的子类或子接口都可以使用 <code>foreach</code>，如数组，集合</li><li>遍历时不能增删，因为增强 for 循环底层还是迭代器，增删会发生并发修改异常</li></ol><h2 id="3-5-modCount"><a href="#3-5-modCount" class="headerlink" title="3.5 modCount"></a>3.5 <code>modCount</code></h2><ol><li>在 <code>ArrayList，LinkedList，HashMap...</code> 等集合中有此属性，用来记录集合被修改的次数（添加 删除）</li><li>使用迭代器或 <code>foreach</code> 遍历集合时，会记录遍历开始时的 <code>modCount</code><ol><li>遍历时使用迭代器自身的增删方法修改集合，不会改变 <code>modCount</code></li><li>遍历时使用集合的增删方法，会修改 <code>modCount</code>，前后 <code>modCount</code> 不一致，说明有两个线程在同时操作集合，这种操作有风险，为了保证安全性就会报异常</li></ol></li></ol><h1 id="四-泛型（Generics）"><a href="#四-泛型（Generics）" class="headerlink" title="四 泛型（Generics）"></a>四 泛型（Generics）</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ol><li>如果没有泛型，就意味着你并不知道集合中存储的是什么类型的数据，那就只能认为都是 Object，所以在使用时，你想要把数据当作某种具体的类型来使用<ol><li>需要强制类型转换</li><li>有可能 <code>ClassCastException</code> 异常</li></ol></li><li>泛型就是一种可以在使用时明确数据类型的功能（类似形参实参）<ol><li>定义时声明了泛型</li><li>使用时就可以使用泛型这种功能来明确数据类型</li></ol></li><li>泛型的好处<ol><li>明确了数据类型，使用时就不用再做类型转换</li><li>限定了数据类型，就意味着如果不合法，编译通不过，把运行期的错误提前到了编译期</li></ol></li><li>泛型：参数化类型 Parameterized type<ul><li><code>&lt;引用数据类型&gt;</code></li></ul></li></ol><h2 id="4-2-泛型定义"><a href="#4-2-泛型定义" class="headerlink" title="4.2 泛型定义"></a>4.2 泛型定义</h2><h3 id="1-定义语法"><a href="#1-定义语法" class="headerlink" title="1 定义语法"></a>1 定义语法</h3><table><thead><tr><th>目标</th><th>语法</th></tr></thead><tbody><tr><td><code>泛型类</code></td><td><code>修饰符 class 类名&lt;泛型形参列表&gt;{}</code></td></tr><tr><td><code>泛型接口</code></td><td><code>修饰符 interface 接口名&lt;泛型形参列表&gt;{}</code></td></tr><tr><td><code>泛型方法</code></td><td><code>修饰符 &lt;泛型形参列表&gt; 返回值类型 方法名(形参列表) {}</code></td></tr></tbody></table><ol><li>泛型形参可以为任意标识符，如 <code>E T K V ...</code></li><li>泛型定义时可以限定使用时的类型上下限<ol><li><code>T extends 上限</code></li><li><code>T super 下限</code></li></ol></li><li>类/接口上定义的泛型，内部非静态成员可以直接使用<ol><li>创建对象时指定具体类型</li><li>子类上指定具体类型</li><li>静态成员不能使用泛型，因为静态比泛型确定具体类型的时机要早</li></ol></li><li>方法上定义的泛型，可以在方法形参和内部使用<ol><li>调用方法时指定具体类型</li><li>泛型方法可以是静态的，因为是调用时确定的类型</li><li>方法上的泛型与类或接口没有关系</li></ol></li></ol><h3 id="2-泛型类-接口的子类"><a href="#2-泛型类-接口的子类" class="headerlink" title="2 泛型类/接口的子类"></a>2 泛型类/接口的子类</h3><h4 id="1-明确数据类型"><a href="#1-明确数据类型" class="headerlink" title="1 明确数据类型"></a>1 明确数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 子类名 extends 父类&lt;具体类型&gt; &#123;&#125;</span><br><span class="line">修饰符 class 子类名 implements 接口&lt;具体类型&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-不明确数据类型"><a href="#2-不明确数据类型" class="headerlink" title="2 不明确数据类型"></a>2 不明确数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 子类名&lt;泛型形参列表&gt; extends 父类&lt;泛型形参列表&gt; &#123;&#125;</span><br><span class="line">修饰符 class 子类名&lt;泛型形参列表&gt; implements 接口&lt;泛型形参列表&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-泛型通配符"><a href="#4-3-泛型通配符" class="headerlink" title="4.3 泛型通配符"></a>4.3 泛型通配符</h2><table><thead><tr><th>通配符</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;?&gt;</code></td><td>写入时只能添加 <code>null</code>，读取时读取的类型为 <code>Object</code></td></tr><tr><td><code>? extends E</code></td><td>设定上限，必须是 E 及其子类</td></tr><tr><td><code>? super E</code></td><td>设定下限，必须是 E 及其父类</td></tr></tbody></table><ul><li><p><code>A</code> 和 <code>B</code> 是子父类关系，<code>G&lt;A&gt;</code> 和 <code>G&lt;B&gt;</code> 没有关系，它们共同父类是 <code>G&lt;?&gt;</code></p></li><li><p>为什么使用 <code>?</code> 而不能用 <code>Object</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;&#125; <span class="comment">// 正确</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">因为使用时，ArrayList&lt;String&gt; 就意味着将通配符指定为 String</span></span><br><span class="line"><span class="comment">则 ArrayList&lt;String&gt; = new ArrayList&lt;String&gt;(); 没问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Collection&lt;Object&gt; c)</span> </span>&#123;&#125; <span class="comment">// 错误</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">因为使用时， ArrayList&lt;String&gt; = new ArrayList&lt;Number&gt;(); </span></span><br><span class="line"><span class="comment">由于接收的是 Object 所以理论上是没有问题的，但泛型前后必须一致，所以错误</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="五-java-util-Collections"><a href="#五-java-util-Collections" class="headerlink" title="五 java.util.Collections"></a>五 <code>java.util.Collections</code></h1><h2 id="1-1-增删改查"><a href="#1-1-增删改查" class="headerlink" title="1.1 增删改查"></a>1.1 增删改查</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static &lt;T&gt; boolean</code></td><td><code>addAll(Collection&lt;? super T&gt; c, T... elements)</code></td><td>添加多个元素到指定集合</td></tr><tr><td><code>static &lt;T&gt; void</code></td><td><code>copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</code></td><td>将 <code>List</code> 集合 <code>src</code> 中的元素拷贝到 <code>dest</code> 中</td></tr><tr><td><code>static &lt;T&gt; boolean</code></td><td><code>replaceAll(List&lt;T&gt; list, T oldVal, T newVal)</code></td><td>将 <code>List</code> 中所有的 <code>oldVal</code> 替换为 <code>newVal</code></td></tr><tr><td><code>static &lt;T&gt; int</code></td><td><code>binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)</code></td><td><code>List</code> 集合二分查找，要求 <code>List</code> 中的元素有比较性</td></tr><tr><td><code>static &lt;T&gt; int</code></td><td><code>binarySearch(List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c)</code></td><td><code>List</code> 集合二分查找，使用指定比较器</td></tr><tr><td><code>static int</code></td><td><code>frequency(Collection&lt;?&gt; c, Object o)</code></td><td>获取指定元素在集合中出现的次数</td></tr></tbody></table><h2 id="1-2-排序"><a href="#1-2-排序" class="headerlink" title="1.2 排序"></a>1.2 排序</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static &lt;T extends Comparable&lt;? super T&gt;&gt; void</code></td><td><code>sort(List&lt;T&gt; list)</code></td><td>按照元素自然顺序对 <code>List</code> 集合排序</td></tr><tr><td><code>static &lt;T&gt; void</code></td><td><code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code></td><td>使用指定比较器对 <code>List</code> 集合排序</td></tr><tr><td><code>static void</code></td><td><code>reverse(List&lt;?&gt; list)</code></td><td>反转 <code>LIst</code> 集合</td></tr><tr><td><code>static void</code></td><td><code>shuffle(List&lt;?&gt; list)</code></td><td>随机洗牌</td></tr><tr><td><code>static void</code></td><td><code>swap(List&lt;?&gt; list, int i, int j)</code></td><td>交换 <code>LIst</code> 集合指定索引的元素</td></tr></tbody></table><h2 id="1-3-获取集合"><a href="#1-3-获取集合" class="headerlink" title="1.3 获取集合"></a>1.3 获取集合</h2><h3 id="1-immutable"><a href="#1-immutable" class="headerlink" title="1 immutable"></a>1 <code>immutable</code></h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static &lt;T&gt; List&lt;T&gt;</code></td><td><code>singletonList(T o)</code></td><td>返回不可变的只包含一个元素的 <code>List</code> 集合</td></tr><tr><td><code>static &lt;T&gt; Set&lt;T&gt;</code></td><td><code>singleton(T o)</code></td><td>返回不可变的只包含一个元素的 <code>Set</code> 集合</td></tr><tr><td><code>static &lt;K, V&gt; Map&lt;K, V&gt;</code></td><td><code>singletonMap(K key, V value)</code></td><td>返回不可变的只包含一对键值的 <code>Map</code> 集合</td></tr></tbody></table><h3 id="2-synchronized"><a href="#2-synchronized" class="headerlink" title="2 synchronized"></a>2 <code>synchronized</code></h3><table><thead><tr><th>修饰</th><th>方法</th></tr></thead><tbody><tr><td><code>static &lt;T&gt; Collection&lt;T&gt;</code></td><td><code>synchronizedCollection(Collection&lt;T&gt; c)</code></td></tr><tr><td><code>static &lt;T&gt; List&lt;T&gt;</code></td><td><code>synchronizedList(List&lt;T&gt; list)</code></td></tr><tr><td><code>static &lt;T&gt; Set&lt;T&gt;</code></td><td><code>synchronizedSet(Set&lt;T&gt; s)</code></td></tr><tr><td><code>static &lt;T&gt; NavigableSet&lt;T&gt;</code></td><td><code>synchronizedNavigableSet(NavigableSet&lt;T&gt; s)</code></td></tr><tr><td><code>static &lt;T&gt; SortedSet&lt;T&gt;</code></td><td><code>synchronizedSortedSet(SortedSet&lt;T&gt; s)</code></td></tr><tr><td><code>static &lt;K, V&gt; Map&lt;K, V&gt;</code></td><td><code>synchronizedMap(Map&lt;K, V&gt; m)</code></td></tr><tr><td><code>static &lt;K, V&gt; NavigableMap&lt;K, V&gt;</code></td><td><code>synchronizedNavigableMap(NavigableMap&lt;K, V&gt; m)</code></td></tr><tr><td><code>static &lt;K, V&gt; SortedMap&lt;K, V&gt;</code></td><td><code>synchronizedSortedMap(SortedMap&lt;K, V&gt; m)</code></td></tr></tbody></table><h3 id="3-Unmodifiable（只读）"><a href="#3-Unmodifiable（只读）" class="headerlink" title="3 Unmodifiable（只读）"></a>3 <code>Unmodifiable</code>（只读）</h3><table><thead><tr><th>修饰</th><th>方法</th></tr></thead><tbody><tr><td><code>static &lt;T&gt; Collection&lt;T&gt;</code></td><td><code>unmodifiableCollection(Collection&lt;? extends T&gt; c)</code></td></tr><tr><td><code>static &lt;T&gt; List&lt;T&gt;</code></td><td><code>unmodifiableList(List&lt;? extends T&gt; list)</code></td></tr><tr><td><code>static &lt;T&gt; Set&lt;T&gt;</code></td><td><code>unmodifiableSet(Set&lt;? extends T&gt; s)</code></td></tr><tr><td><code>static &lt;T&gt; NavigableSet&lt;T&gt;</code></td><td><code>unmodifiableNavigableSet(NavigableSet&lt;T&gt; s)</code></td></tr><tr><td><code>static &lt;T&gt; SortedSet&lt;T&gt;</code></td><td><code>unmodifiableSortedSet(SortedSet&lt;T&gt; s)</code></td></tr><tr><td><code>static &lt;K, V&gt; Map&lt;K, V&gt;</code></td><td><code>unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></td></tr><tr><td><code>static &lt;K, V&gt; NavigableMap&lt;K, V&gt;</code></td><td><code>unmodifiableNavigableMap(NavigableMap&lt;K, ? extends V&gt; m)</code></td></tr><tr><td><code>static &lt;K, V&gt; SortedMap&lt;K, V&gt;</code></td><td><code>unmodifiableSortedMap(SortedMap&lt;K, ? extends V&gt; m)</code></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-java-util-Collection-lt-E-gt&quot;&gt;&lt;a href=&quot;#一-java-util-Collection-lt-E-gt&quot; class=&quot;headerlink&quot; title=&quot;一 java.util.Collection&amp;lt;E&amp;gt;&quot;
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="Java" scheme="https://anyeansan.github.io/categories/CS/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-IO</title>
    <link href="https://anyeansan.github.io/2020/09/29/Java/Java-IO/"/>
    <id>https://anyeansan.github.io/2020/09/29/Java/Java-IO/</id>
    <published>2020-09-29T07:52:03.000Z</published>
    <updated>2020-09-29T07:53:01.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-File"><a href="#一-File" class="headerlink" title="一 File"></a>一 <code>File</code></h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ol><li>File 类代表了一个文件或一个目录</li><li>File 类中涉及到的关于文件或目录的创建、删除、修改等方法，并未涉及到写入或读取文件内容的操作。如需读写文件内容，必须通过 IO 流来完成</li></ol><h2 id="1-2-属性"><a href="#1-2-属性" class="headerlink" title="1.2 属性"></a>1.2 属性</h2><table><thead><tr><th>修饰</th><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>static char</code></td><td><code>separatorChar</code></td><td>路径分隔符；<code>unix &#39;/&#39;</code>，<code>windows &#39;\\&#39;</code></td></tr><tr><td><code>static String</code></td><td><code>separator</code></td><td><code>&quot;&quot; + separatorChar</code></td></tr><tr><td><code>static char</code></td><td><code>pathSeparatorChar</code></td><td>多个路径之间的分隔符；<code>unix :</code> ，<code>windows  ;</code></td></tr><tr><td><code>static String</code></td><td><code>pathSeparator</code></td><td><code>&quot;&quot; + pathSeparatorChar</code></td></tr></tbody></table><h2 id="1-3-构造"><a href="#1-3-构造" class="headerlink" title="1.3 构造"></a>1.3 构造</h2><table><thead><tr><th>构造</th><th>说明</th></tr></thead><tbody><tr><td><code>File​(String pathname)</code></td><td>根据路径字符串构造 <code>File</code></td></tr><tr><td><code>File​(String parent, String child)</code></td><td>根据父路径字符串和子路径字符串构造 <code>File</code></td></tr><tr><td><code>File​(File parent, String child)</code></td><td>根据父 <code>File</code> 和 子路径字符串构造 <code>File</code></td></tr><tr><td><code>File(URI uri)</code></td><td>根据 <code>uri</code> 构造 <code>File</code></td></tr></tbody></table><h2 id="1-4-方法"><a href="#1-4-方法" class="headerlink" title="1.4 方法"></a>1.4 方法</h2><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1 创建"></a>1 创建</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>createNewFile()</code></td><td>创建文件，已存在则不创建</td></tr><tr><td><code>boolean</code></td><td><code>mkdir()</code></td><td>创建目录，已存在则不创建</td></tr><tr><td><code>boolean</code></td><td><code>mkdirs()</code></td><td>递归创建目录</td></tr></tbody></table><h3 id="2-删除"><a href="#2-删除" class="headerlink" title="2 删除"></a>2 删除</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>delete()</code></td><td>删除文件或空目录（不走回收站）</td></tr><tr><td><code>boolean</code></td><td><code>renameTo(File dest)</code></td><td>路径相同则重命名，路径不同则剪切</td></tr></tbody></table><h3 id="3-判断"><a href="#3-判断" class="headerlink" title="3 判断"></a>3 判断</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>exists()</code></td><td>是否存在</td></tr><tr><td><code>boolean</code></td><td><code>isDirectory()</code></td><td>是否是目录</td></tr><tr><td><code>boolean</code></td><td><code>isFile()</code></td><td>是否是文件</td></tr><tr><td><code>boolean</code></td><td><code>canRead()</code></td><td>是否可读</td></tr><tr><td><code>boolean</code></td><td><code>canWrite()</code></td><td>是否可写</td></tr><tr><td><code>boolean</code></td><td><code>isHidden()</code></td><td>是否是隐藏</td></tr><tr><td><code>boolean</code></td><td><code>isAbsolute()</code></td><td>是否是绝对路径</td></tr></tbody></table><h3 id="4-获取"><a href="#4-获取" class="headerlink" title="4 获取"></a>4 获取</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>String</code></td><td><code>getName()</code></td><td>获取文件名</td></tr><tr><td><code>String</code></td><td><code>getPath()</code></td><td>获取构造 File 对象时指定的路径</td></tr><tr><td><code>String</code></td><td><code>getAbsolutePath()</code></td><td>获取绝对路径</td></tr><tr><td><code>String</code></td><td><code>getCanonicalPath()</code></td><td>获取规范路径（自动解析 <code>. ..</code>）</td></tr><tr><td><code>long</code></td><td><code>length()</code></td><td>获取文件大小</td></tr><tr><td><code>long</code></td><td><code>lastModified()</code></td><td>获取文件最后修改时间</td></tr><tr><td><code>String</code></td><td><code>getParent()</code></td><td>获取父目录路径的字符串</td></tr><tr><td><code>File</code></td><td><code>getParentFile()</code></td><td>获取父目录路径的 File 对象</td></tr></tbody></table><h3 id="5-遍历目录"><a href="#5-遍历目录" class="headerlink" title="5 遍历目录"></a>5 遍历目录</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static File[]</code></td><td><code>listRoots()</code></td><td>获取系统可用盘符</td></tr><tr><td><code>String[]</code></td><td><code>list()</code></td><td>获取目录下所有文件和目录的字符串名称的数组</td></tr><tr><td><code>String[]</code></td><td><code>list(FilenameFilter filter)</code></td><td>文件名过滤器</td></tr><tr><td><code>File[]</code></td><td><code>listFiles()</code></td><td>获取目录下所有文件和目录的 File 对象的数组</td></tr><tr><td><code>File[]</code></td><td><code>listFiles(FileFilter filter)</code></td><td>文件过滤器</td></tr><tr><td><code>File[]</code></td><td><code>listFiles(FilenameFilter filter)</code></td><td>文件名过滤器</td></tr></tbody></table><h1 id="二-IO-流的异常处理"><a href="#二-IO-流的异常处理" class="headerlink" title="二 IO 流的异常处理"></a>二 IO 流的异常处理</h1><h2 id="2-1-JDK-7"><a href="#2-1-JDK-7" class="headerlink" title="2.1 JDK 7"></a>2.1 JDK 7</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">in = <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>);</span><br><span class="line">业务代码;</span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">异常处理;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(in!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">in.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-JDK-8"><a href="#2-2-JDK-8" class="headerlink" title="2.2 JDK 8"></a>2.2 JDK 8</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (</span><br><span class="line">需要关闭的资源;</span><br><span class="line">) &#123;</span><br><span class="line">业务代码;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">异常处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>实现了 <code>java.lang.AutoCloseble</code> 的资源可以使用此语法自动关闭（无论是否发生异常）</li><li>IO 流体系实现了此接口</li><li>JDK9 以后要关闭的资源可以在 <code>try</code> 外边初始化</li></ol><h1 id="三-基础流"><a href="#三-基础流" class="headerlink" title="三 基础流"></a>三 基础流</h1><h2 id="3-1-字节输入流"><a href="#3-1-字节输入流" class="headerlink" title="3.1 字节输入流"></a>3.1 字节输入流</h2><h3 id="1-体系"><a href="#1-体系" class="headerlink" title="1 体系"></a>1 体系</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81.png" alt=""></p><h3 id="2-InputStream"><a href="#2-InputStream" class="headerlink" title="2 InputStream"></a>2 <code>InputStream</code></h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>abstract int</code></td><td><code>read()</code></td><td>读取单个字节，返回字节的 <code>int</code> 值，流末尾返回 <code>-1</code></td></tr><tr><td><code>int</code></td><td><code>read​(byte[] b)</code></td><td>读取字节并存储到数组中，返回读取的字节个数，流末尾返回 <code>-1</code></td></tr><tr><td><code>int</code></td><td><code>read​(byte[] b, int off, int len)</code></td><td>读取字节并存储到数组指定位置，返回读取的字节个数，流末尾返回 <code>-1</code></td></tr><tr><td><code>byte[]</code></td><td><code>readAllBytes()</code></td><td>读取流中所有字节</td></tr><tr><td><code>long</code></td><td><code>transferTo(OutputStream out)</code></td><td>将当前输入流中所有数据传递给输出流，并返回传递字节数</td></tr><tr><td><code>void</code></td><td><code>close()</code></td><td>关闭流</td></tr></tbody></table><ul><li>字节流读取中文<ol><li>使用 <code>read()</code> 读取一个字节肯定乱码</li><li>使用 <code>read(byte[] b)</code> 缓存数组读取有可能乱码，因为数组长度与数据的字节个数未必恰好吻合，有可能会出现一个字符多个字节但只读取到部分的情况</li></ol></li></ul><h2 id="3-2-字节输出流"><a href="#3-2-字节输出流" class="headerlink" title="3.2 字节输出流"></a>3.2 字节输出流</h2><h3 id="1-体系-1"><a href="#1-体系-1" class="headerlink" title="1 体系"></a>1 体系</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81.png" alt=""></p><h3 id="2-OutputStream"><a href="#2-OutputStream" class="headerlink" title="2 OutputStream"></a>2 <code>OutputStream</code></h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>abstract void</code></td><td><code>write​(int b)</code></td><td>写单个字节</td></tr><tr><td><code>void</code></td><td><code>write(byte[] b)</code></td><td>写字节数组</td></tr><tr><td><code>void</code></td><td><code>write(byte[] b, int off, int len)</code></td><td>写字节数组的指定部分</td></tr><tr><td><code>void</code></td><td><code>flush()</code></td><td>刷新，即将缓冲区数据写到目的地，刷新后还可以继续写</td></tr><tr><td><code>void</code></td><td><code>close()</code></td><td>关闭前会自动刷新</td></tr></tbody></table><h2 id="3-3-字符输入流"><a href="#3-3-字符输入流" class="headerlink" title="3.3 字符输入流"></a>3.3 字符输入流</h2><h3 id="1-体系-2"><a href="#1-体系-2" class="headerlink" title="1 体系"></a>1 体系</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81.png" alt=""></p><h3 id="2-Reader"><a href="#2-Reader" class="headerlink" title="2 Reader"></a>2 <code>Reader</code></h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>read()</code></td><td>读取单个字符，返回 Unicode 码元（<code>0~65535</code>），流末尾返回 <code>-1</code></td></tr><tr><td><code>int</code></td><td><code>read(char[] cbuf)</code></td><td>读取字符并存储到数组中，返回读取的字符个数，流末尾返回 <code>-1</code></td></tr><tr><td><code>abstract int</code></td><td><code>read​(char[] cbuf, int off, int len)</code></td><td>读取字符并存储到数组指定位置，返回读取的字符个数，流末尾返回 <code>-1</code></td></tr><tr><td><code>abstract void</code></td><td><code>close()</code></td><td>关闭流</td></tr></tbody></table><ol><li>字符流一次读取一个字符，字符流怎么知道几个字节是一个字符呢？<ul><li>跟字符集有关，如GBK中中文都是1开头的</li></ul></li><li>字符流编码转换过程 <code>read()</code><ul><li>按照指定字符集读取 → 查询 <code>unicode</code> 中对应的码点（因为 java 为 <code>unicode</code>）</li><li>比如文件内容为一个字 “北”，假如使用的码表为GBK，字符流读取结果为 <code>十进制：21271</code>，转为十六进制为 <code>\u5317</code>，先读取文件根据GBK转成了 “北”，然后查“北”在 <code>Unicode</code> 中的码点</li></ul></li></ol><h2 id="3-4-字符输出流"><a href="#3-4-字符输出流" class="headerlink" title="3.4 字符输出流"></a>3.4 字符输出流</h2><h3 id="1-体系-3"><a href="#1-体系-3" class="headerlink" title="1 体系"></a>1 体系</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81.png" alt=""></p><h3 id="2-Writer"><a href="#2-Writer" class="headerlink" title="2 Writer"></a>2 <code>Writer</code></h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>write(int c)</code></td><td>写单个字符</td></tr><tr><td><code>void</code></td><td><code>write(String str)</code></td><td>写字符串</td></tr><tr><td><code>void</code></td><td><code>write(String str, int off, int len)</code></td><td>写字符串的指定部分</td></tr><tr><td><code>void</code></td><td><code>write(char[] cbuf)</code></td><td>写字符数组</td></tr><tr><td><code>abstract  void</code></td><td><code>write(char[] cbuf, int off, int len)</code></td><td>写字符数组的指定部分</td></tr><tr><td><code>abstract void</code></td><td><code>flush()</code></td><td>刷新</td></tr><tr><td><code>abstract void</code></td><td><code>close()</code></td><td>关闭前会自动刷新</td></tr></tbody></table><h1 id="四-文件流"><a href="#四-文件流" class="headerlink" title="四 文件流"></a>四 文件流</h1><h2 id="4-1-FileInputStream"><a href="#4-1-FileInputStream" class="headerlink" title="4.1 FileInputStream"></a>4.1 <code>FileInputStream</code></h2><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td><code>FileInputStream(File file)</code></td><td>根据 File 对象创建，文件必须存在</td></tr><tr><td><code>FileInputStream(String name)</code></td><td>根据文件路径创建，文件必须存在</td></tr></tbody></table><h2 id="4-2-FileOutputStream"><a href="#4-2-FileOutputStream" class="headerlink" title="4.2 FileOutputStream"></a>4.2 <code>FileOutputStream</code></h2><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td><code>FileOutputStream(File file [, boolean append])</code></td><td>文件不存在会创建，文件存在会清空</td></tr><tr><td><code>FileOutputStream(String name [, boolean append])</code></td><td>文件不存在会创建，文件存在会清空</td></tr></tbody></table><h1 id="五-缓冲流"><a href="#五-缓冲流" class="headerlink" title="五 缓冲流"></a>五 缓冲流</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol><li>缓存流和定义数组哪个快？<ul><li>定义数组快，因为读写操作的都是同一个数组，而缓存流分输入和输出，操作的是两个数组</li></ul></li><li>关闭流时，先关外层，再关内层，而关外层流时内层流会自动关闭</li></ol><h2 id="5-2-字节缓冲流"><a href="#5-2-字节缓冲流" class="headerlink" title="5.2 字节缓冲流"></a>5.2 字节缓冲流</h2><h3 id="1-BufferedInputStream"><a href="#1-BufferedInputStream" class="headerlink" title="1 BufferedInputStream"></a>1 <code>BufferedInputStream</code></h3><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td><code>BufferedInputStream​(InputStream in [, int size])</code></td><td>默认缓存区大小为 <code>8192</code> 字节</td></tr></tbody></table><h3 id="2-BufferedOutputStream"><a href="#2-BufferedOutputStream" class="headerlink" title="2 BufferedOutputStream"></a>2 <code>BufferedOutputStream</code></h3><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td><code>BufferedOutputStream(OutputStream out, int size)</code></td><td>默认缓存区大小为 <code>8192</code> 字节</td></tr></tbody></table><h2 id="5-3-字符缓冲流"><a href="#5-3-字符缓冲流" class="headerlink" title="5.3 字符缓冲流"></a>5.3 字符缓冲流</h2><h3 id="1-BufferedReader"><a href="#1-BufferedReader" class="headerlink" title="1 BufferedReader"></a>1 <code>BufferedReader</code></h3><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td><code>BufferedReader​(Reader in [, int sz])</code></td><td>默认缓存区大小 <code>8192</code> 字符</td></tr></tbody></table><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>String</code></td><td><code>readLine()</code></td><td>读取一行并返回（不包括换行符），流末尾返回 <code>null</code></td></tr></tbody></table><h3 id="2-BufferedWriter"><a href="#2-BufferedWriter" class="headerlink" title="2 BufferedWriter"></a>2 <code>BufferedWriter</code></h3><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td><code>BufferedWriter​(Writer out [, int sz])</code></td><td>默认缓存区大小 <code>8192</code> 字符</td></tr></tbody></table><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>newLine()</code></td><td>写出换行符（可跨平台）</td></tr></tbody></table><h1 id="六-转换流"><a href="#六-转换流" class="headerlink" title="六 转换流"></a>六 转换流</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><ol><li><p>转换流属于字符流，提供了字节流和字符流之间的转换</p><ul><li><code>InputStreamReader</code>：<code>InputStream</code> → <code>Reader</code></li><li><code>OutputStreamWriter</code>：<code>Writer</code> → <code>OutputStream</code></li></ul></li><li><p>字符流原理就是转换流使用平台默认字符集将字节流转换成了字符流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"test.txt"</span>);</span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"test.txt"</span>),<span class="string">"utf-8"</span>);</span><br></pre></td></tr></table></figure><ul><li><p>字符流 = 转换流(字节流 + 默认字符集)</p></li><li><p>如果默认字符集是 <code>utf-8</code> ，则上述两句是等价的</p></li></ul></li></ol><h2 id="6-2-InputStreamReader"><a href="#6-2-InputStreamReader" class="headerlink" title="6.2 InputStreamReader"></a>6.2 <code>InputStreamReader</code></h2><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td><code>InputStreamReader​(InputStream in [, String charsetName)]</code></td><td>字节流到字符流的桥梁，使用指定字符集解码</td></tr></tbody></table><ol><li>使用字节流读取文本数据时，先读取字节数据，然后使用字符集解码</li><li><code>InputStreamReader</code>：读取字节数据并使用字符集解码</li></ol><h2 id="6-3-OutputStreamWriter"><a href="#6-3-OutputStreamWriter" class="headerlink" title="6.3 OutputStreamWriter"></a>6.3 <code>OutputStreamWriter</code></h2><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td><code>OutputStreamWriter​(OutputStream out [, String charsetName])</code></td><td>字符流到字节流的桥梁，使用指定字符集编码</td></tr></tbody></table><ol><li>使用字节流写出文本数据时，先使用字符集编码，然后写出字节数据</li><li><code>OutputStreamWriter</code>：使用字符集编码并写出字节数据</li></ol><h2 id="6-4-两种方法实现键盘录入"><a href="#6-4-两种方法实现键盘录入" class="headerlink" title="6.4 两种方法实现键盘录入"></a>6.4 两种方法实现键盘录入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in))</span><br><span class="line">BUfferedWriter bw=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out)) </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure><h1 id="七-打印流"><a href="#七-打印流" class="headerlink" title="七 打印流"></a>七 打印流</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ol><li>可以对多种数据类型进行打印，并<strong>保持数据的表示形式</strong><ol><li><code>write(int)</code> ：只会写出 1 个字节</li><li><code>print(int)</code> ：可以写出 4 个字节</li></ol></li><li>不抛出 <code>IOException</code></li><li>打印原理<ol><li>基本数据类型先变成字符串再打印</li><li>引用数据类型非 <code>null</code> 就调用对象的 <code>toString()</code>，<code>null</code> 就打印 <code>null</code></li></ol></li><li><code>PrintWriter &amp; printStream</code><ol><li><code>PrintStream</code> 能做的 <code>PrintWriter</code> 也都能实现且功能更强大，但 <code>PrintStream</code> 出现较早，<code>System.out</code> 使用的是 <code>PrintStream</code> 来实现的，所以为了兼容并没有废弃 <code>PrintStream</code></li><li>二者都提供了一系列重载的 <code>print println</code> 方法</li><li><code>PringtStream</code> 打印的所有字符都使用平台默认的字符集来编码为字节数据，打印字符时，建议使用 <code>PrintWriter</code></li><li><code>PrintWriter &amp; printStream</code> 都可以设置自动刷新<ul><li><code>printStream</code>：写入字节数组、任何重载版本的 <code>println()</code> 被调用、一个换行符（<code>char</code>）被写入、一个换行符的字节存储（<code>\n</code>）被写入</li><li><code>PrintWriter</code>： 自动刷新只对 <code>println() printf() format()</code> 这些方法有效</li></ul></li></ol></li></ol><h2 id="7-2-PrintStream"><a href="#7-2-PrintStream" class="headerlink" title="7.2 PrintStream"></a>7.2 <code>PrintStream</code></h2><table><thead><tr><th>构造</th><th>说明</th></tr></thead><tbody><tr><td><code>PrintStream​(File file [, String charsetName])</code></td><td>接收 File 对象</td></tr><tr><td><code>PrintStream​(String fileName [, String charsetName])</code></td><td>接收字符串路径</td></tr><tr><td><code>PrintStream​(OutputStream out [, boolean autoFlush [, String encoding]])</code></td><td>接收字节输出流</td></tr></tbody></table><h2 id="7-3-PrintWriter"><a href="#7-3-PrintWriter" class="headerlink" title="7.3 PrintWriter"></a>7.3 <code>PrintWriter</code></h2><table><thead><tr><th>构造</th><th>说明</th></tr></thead><tbody><tr><td><code>PrintWriter​(File file [, String charsetName])</code></td><td>接收 File 对象</td></tr><tr><td><code>PrintWriter​(String fileName [, String charsetName])</code></td><td>接收字符串路径</td></tr><tr><td><code>PrintWriter​(OutputStream out [, boolean autoFlush [, Charset charset]])</code></td><td>接收字节输出流</td></tr><tr><td><code>PrintWriter​(Writer out [, boolean autoFlush])</code></td><td>接收字符输出流</td></tr></tbody></table><h2 id="7-4-标准输入输出流"><a href="#7-4-标准输入输出流" class="headerlink" title="7.4 标准输入输出流"></a>7.4 标准输入输出流</h2><table><thead><tr><th>流</th><th>类型</th><th>说明</th><th>设备</th></tr></thead><tbody><tr><td><code>System.in</code></td><td><code>InputStream</code></td><td>标准输入</td><td>键盘</td></tr><tr><td><code>System.out</code></td><td><code>PrintStream</code></td><td>标准输出</td><td>显示器（控制台）</td></tr><tr><td><code>System.err</code></td><td><code>PrintStream</code></td><td>标准错误输出</td><td>显示器（控制台）</td></tr></tbody></table><h1 id="八-序列化流（对象流）"><a href="#八-序列化流（对象流）" class="headerlink" title="八 序列化流（对象流）"></a>八 序列化流（对象流）</h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><ol><li>序列化 &amp; 反序列化<ul><li>序列化：写出一个对象</li><li>反序列化：读取一个对象</li></ul></li><li>对象序列化机制：好处在于将对象转化为字节数据，使其在保存和传输时可被还原<ul><li>允许把内存中的 Java 对象转换成平台无关的二进制流，从而把这种二进制流持久的保存在磁盘上或通过网络进行传输</li><li>当其它程序获取这种二进制流，就可以恢复成原来的 Java 对象</li></ul></li><li>对象序列化的条件：<ol><li>对象必须实现序列化接口<ul><li><code>Serializable</code> ：序列化标记接口，对象序列化内容和顺序都是默认的</li><li><code>Externalizable</code> ：<code>Serializable</code> 的子接口，可定制序列号内容和顺序</li></ul></li><li>对象的所有属性也必须可序列化<ul><li>引用类型的属性也必须实现序列化接口</li><li>基本类型属性默认可序列化</li></ul></li><li>对象不会序列化的属性<ul><li><code>transient</code> 关键字修饰的属性</li><li><code>static</code> 关键字修饰的属性</li></ul></li></ol></li><li>序列化ID ：<code>serialVersionUID</code><ul><li>用于判断类和对象是否是同一个版本</li><li>建议实现序列化接口时就指定，否则每次重新编译类，序列化ID都会变化</li></ul></li></ol><h2 id="8-2-ObjectInputStream"><a href="#8-2-ObjectInputStream" class="headerlink" title="8.2 ObjectInputStream"></a>8.2 <code>ObjectInputStream</code></h2><h3 id="1-构造"><a href="#1-构造" class="headerlink" title="1 构造"></a>1 构造</h3><table><thead><tr><th>构造</th><th>说明</th></tr></thead><tbody><tr><td><code>ObjectInputStream​(InputStream in)</code></td><td>装饰字节输入流</td></tr></tbody></table><h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2 方法"></a>2 方法</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Object</code></td><td><code>readObject()</code></td><td>读取对象</td></tr></tbody></table><h2 id="8-3-ObjectOutputStream"><a href="#8-3-ObjectOutputStream" class="headerlink" title="8.3 ObjectOutputStream"></a>8.3 <code>ObjectOutputStream</code></h2><h3 id="1-构造-1"><a href="#1-构造-1" class="headerlink" title="1 构造"></a>1 构造</h3><table><thead><tr><th>构造</th><th>说明</th></tr></thead><tbody><tr><td><code>ObjectOutputStream(OutputStream out)</code></td><td>装饰字节输出流</td></tr></tbody></table><h3 id="2-方法-1"><a href="#2-方法-1" class="headerlink" title="2 方法"></a>2 方法</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>writeObject(Object obj)</code></td><td>写出对象</td></tr></tbody></table><h1 id="九-数据流"><a href="#九-数据流" class="headerlink" title="九 数据流"></a>九 数据流</h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><ol><li>数据流主要用来操作基本类型和 <code>String</code> 类型的数据，这些数据如果使用其它流读写，可能会出问题</li><li>以二进制形式读写数组，字符，字符串，布尔…</li></ol><h2 id="9-2-DataInputStream"><a href="#9-2-DataInputStream" class="headerlink" title="9.2 DataInputStream"></a>9.2 <code>DataInputStream</code></h2><h3 id="1-构造-2"><a href="#1-构造-2" class="headerlink" title="1 构造"></a>1 构造</h3><table><thead><tr><th>构造</th><th>说明</th></tr></thead><tbody><tr><td><code>DataInputStream​(InputStream in)</code></td><td>装饰字节输入流</td></tr></tbody></table><h3 id="2-方法-2"><a href="#2-方法-2" class="headerlink" title="2 方法"></a>2 方法</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>String</code></td><td><code>readUTF()</code></td><td>读字符串</td></tr><tr><td><code>T</code></td><td><code>readT()</code></td><td>读指定类型数据，<code>readInt() readDouble() ...</code></td></tr></tbody></table><h2 id="9-3-DataOutputStream"><a href="#9-3-DataOutputStream" class="headerlink" title="9.3 DataOutputStream"></a>9.3 <code>DataOutputStream</code></h2><h3 id="1-构造-3"><a href="#1-构造-3" class="headerlink" title="1 构造"></a>1 构造</h3><table><thead><tr><th>构造</th><th>说明</th></tr></thead><tbody><tr><td><code>DataOutputStream​(OutputStream out)</code></td><td>装饰字节输出流</td></tr></tbody></table><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>writeUTF​(String str)</code></td><td>写字符串</td></tr><tr><td><code>void</code></td><td><code>writeT(T t)</code></td><td>写指定类型数据，<code>writeInt(int i) writeDouble(double d) ...</code></td></tr></tbody></table><h1 id="十-内存流"><a href="#十-内存流" class="headerlink" title="十 内存流"></a>十 内存流</h1><h2 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h2><ol><li>操作字节数组</li><li>流关闭无效，不抛 <code>IOException</code></li><li>向内存中读写数组</li><li>字节流读取中文时，可能会乱码，可以使用内存输出流先写到内存中，然后一次性获取所有数据</li></ol><h2 id="10-2-ByteArrayInputStream"><a href="#10-2-ByteArrayInputStream" class="headerlink" title="10.2 ByteArrayInputStream"></a>10.2 <code>ByteArrayInputStream</code></h2><h3 id="1-构造-4"><a href="#1-构造-4" class="headerlink" title="1 构造"></a>1 构造</h3><table><thead><tr><th>构造</th><th>说明</th></tr></thead><tbody><tr><td><code>ByteArrayInputStream(byte[] buf [, int offset, int length])</code></td><td>把字节数组作为缓冲数组</td></tr></tbody></table><h3 id="2-方法-3"><a href="#2-方法-3" class="headerlink" title="2 方法"></a>2 方法</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>read()</code></td><td>读取一个字节</td></tr><tr><td><code>int</code></td><td><code>read(byte[] b, int off, int len)</code></td><td>读取字节并存储在数组中</td></tr></tbody></table><h2 id="10-3-ByteArrayOutputStream"><a href="#10-3-ByteArrayOutputStream" class="headerlink" title="10.3 ByteArrayOutputStream"></a>10.3 <code>ByteArrayOutputStream</code></h2><h3 id="1-构造-5"><a href="#1-构造-5" class="headerlink" title="1 构造"></a>1 构造</h3><table><thead><tr><th>构造</th><th>说明</th></tr></thead><tbody><tr><td><code>ByteArrayOutputStream([int size])</code></td><td>可以指定缓冲区大小</td></tr></tbody></table><h3 id="2-方法-4"><a href="#2-方法-4" class="headerlink" title="2 方法"></a>2 方法</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>write(int b)</code></td><td>写出一个字节</td></tr><tr><td><code>void</code></td><td><code>write(byte[] b, int off, int len)</code></td><td>写出数组指定数据</td></tr><tr><td><code>byte[]</code></td><td><code>toByteArray()</code></td><td>将缓冲区的数据全部取出，获取一个字节数组</td></tr><tr><td><code>String</code></td><td><code>toString()</code></td><td>将缓冲区的数据用平台默认编码转为字符串</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-File&quot;&gt;&lt;a href=&quot;#一-File&quot; class=&quot;headerlink&quot; title=&quot;一 File&quot;&gt;&lt;/a&gt;一 &lt;code&gt;File&lt;/code&gt;&lt;/h1&gt;&lt;h2 id=&quot;1-1-概述&quot;&gt;&lt;a href=&quot;#1-1-概述&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="Java" scheme="https://anyeansan.github.io/categories/CS/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-异常</title>
    <link href="https://anyeansan.github.io/2020/09/29/Java/Java-%E5%BC%82%E5%B8%B8/"/>
    <id>https://anyeansan.github.io/2020/09/29/Java/Java-%E5%BC%82%E5%B8%B8/</id>
    <published>2020-09-29T07:50:06.000Z</published>
    <updated>2020-09-29T07:52:42.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-异常体系"><a href="#一-异常体系" class="headerlink" title="一 异常体系"></a>一 异常体系</h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png" alt=""></p><ol><li>非受检异常： <code>Unchecked Exception</code><ol><li><code>Error</code><ul><li>在你的控制范围之外</li><li>一般指 JVM 系统内部错误或资源耗尽等严重问题，一般不编写针对性的代码进行处理</li></ul></li><li><code>RuntimeException</code><ul><li>一般是程序员所犯的错误，由于代码不够健壮引起的异常，<strong>如果出现 <code>RuntimeException</code> 那么一定是你的问题</strong></li><li>不应该处理，而是一开始就应该避免</li></ul></li></ol></li><li>受检异常：<code>Checked Exception</code><ul><li>非受检异常 <code>Error</code> 和 <code>RuntimeException</code> 外的所有异常都是受检异常，或叫编译时异常</li><li>编译时异常一般是由程序的运行环境导致的，程序可能被运行在各种未知的环境下，而程序员无法干预用户的使用环境</li><li>检查型异常需要处理：声明或捕获</li></ul></li></ol><h1 id="二-异常处理（抛抓模型）"><a href="#二-异常处理（抛抓模型）" class="headerlink" title="二 异常处理（抛抓模型）"></a>二 异常处理（抛抓模型）</h1><h2 id="2-1-“抛”-过程"><a href="#2-1-“抛”-过程" class="headerlink" title="2.1 “抛” 过程"></a>2.1 “抛” 过程</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><ol><li>程序出现异常时，会在异常代码处创建一个异常对象（包含内容，原因，位置 …），并将此对象抛出</li><li>一旦抛出异常对象后，其后的代码就不再执行</li><li>抛出异常有两种方式<ul><li>系统自动生成并抛出的异常</li><li>手动抛出异常 <code>throw</code></li></ul></li></ol><h3 id="2-throw"><a href="#2-throw" class="headerlink" title="2 throw"></a>2 <code>throw</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> 异常对象实例;</span><br></pre></td></tr></table></figure><ol><li><code>throw</code> 用在在方法中，抛出异常<ul><li>非受检异常 <code>throw</code> 后可以不用处理</li><li>受检异常 <code>throw</code> 后必须处理：<code>try-catch</code> 或 <code>throws</code></li></ul></li><li><code>throw</code> 会终止程序，代替 <code>return</code></li></ol><h2 id="2-2-“抓”-过程"><a href="#2-2-“抓”-过程" class="headerlink" title="2.2 “抓” 过程"></a>2.2 “抓” 过程</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>可以理解为异常的处理方式</li><li>共有两种：<ul><li><code>try-catch-finally</code></li><li><code>throws</code></li></ul></li></ol><h3 id="2-try-catch"><a href="#2-try-catch" class="headerlink" title="2 try-catch"></a>2 <code>try-catch</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(</span><br><span class="line"><span class="comment">// 可能出现异常的代码</span></span><br><span class="line">) <span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 异常处理;</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">// 异常处理;</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>) &#123;</span><br><span class="line"><span class="comment">// 异常处理;</span></span><br><span class="line">&#125;  </span><br><span class="line">...</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 可选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>try catch</code> 处理异常后，程序可以继续运行</li><li>多 <code>catch</code> 时，大的异常要放在后边，因为会依次匹配，匹配到就停止</li><li><code>try</code> 中的代码发生异常相当于创建了一个异常对象，然后赋值给 <code>catch</code> 后边括号中的变量</li></ol><h3 id="3-throws"><a href="#3-throws" class="headerlink" title="3 throws"></a>3 <code>throws</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> 异常1, 异常2, ... </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ol><li><code>throws</code> 用在方法上，声明此方法可能抛出的异常</li><li>可以声明多个，逗号分隔</li><li>一旦出现异常，把异常对象抛给此方法的调用者，若调用者也没有处理，则一直抛直到 <code>main</code> 函数，如果 <code>main</code> 函数也没有处理，则抛给 JVM 处理，JVM 默认异常处理机制：<code>printStackTrace()</code></li></ol><h1 id="三-java-lang-Throwable"><a href="#三-java-lang-Throwable" class="headerlink" title="三 java.lang.Throwable"></a>三 <code>java.lang.Throwable</code></h1><h2 id="3-1-构造"><a href="#3-1-构造" class="headerlink" title="3.1 构造"></a>3.1 构造</h2><table><thead><tr><th>构造</th></tr></thead><tbody><tr><td><code>Throwable()</code></td></tr><tr><td><code>Throwable(String message)</code></td></tr><tr><td><code>Throwable(Throwable cause)</code></td></tr><tr><td><code>Throwable(String message, Throwable cause)</code></td></tr></tbody></table><h2 id="3-2-方法"><a href="#3-2-方法" class="headerlink" title="3.2 方法"></a>3.2 方法</h2><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>String</code></td><td><code>toString()</code></td><td>返回异常类名和异常信息的字符串</td></tr><tr><td><code>String</code></td><td><code>getMessage()</code></td><td>获取异常信息</td></tr><tr><td><code>void</code></td><td><code>printStackTrace()</code></td><td>打印异常类名和异常信息，以及异常出现在程序中的位置</td></tr><tr><td><code>Throwable</code></td><td><code>getCause()</code></td><td>获取原因</td></tr><tr><td><code>Throwable</code></td><td><code>initCause(Throwable cause)</code></td><td>为异常对象设置原因，如果已有原因则抛出一个异常</td></tr><tr><td><code>StackTraceElement[]</code></td><td><code>getStackTrace()</code></td><td>获取构造异常对象时调用堆栈的轨迹</td></tr></tbody></table><h1 id="四-自定义异常"><a href="#四-自定义异常" class="headerlink" title="四 自定义异常"></a>四 自定义异常</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    statci <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = xxxxx;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>继承现有异常结构： <code>Exception</code> 或 <code>RuntimeException</code></li><li>提供重载构造器：建议保留无参构造和带 <code>message</code> 的有参构造</li><li>由于 <code>Throwable</code> 实现了 <code>Serializable</code> 接口，建议自定义异常时指定 <code>serialVersionUID</code></li></ol><h1 id="五-思考"><a href="#五-思考" class="headerlink" title="五 思考"></a>五 思考</h1><ul><li><code>return</code> 与 <code>finally</code> 混用<ol><li>执行到了 <code>return</code>，已经把要返回的结果准备好了。这时先去执行 <code>finally</code> 中的代码，然后再 <code>return</code></li><li>如果 <code>finally</code> 中改变了要 <code>return</code> 的值，最终返回结果也不会改变，因为 <code>return</code> 的值已经缓存好了，改变了也没用。</li><li>如果 <code>finally</code> 中也有 <code>return</code>，那么最后返回的是 <code>finally</code>中的返回值</li></ol></li></ul><h1 id="六-断言"><a href="#六-断言" class="headerlink" title="六 断言"></a>六 断言</h1><h2 id="6-1-语法"><a href="#6-1-语法" class="headerlink" title="6.1 语法"></a>6.1 语法</h2><ol><li><code>assert condition;</code><ul><li>如果 <code>condition</code> 为 <code>false</code> 则抛出 <code>AssertionError</code> 异常</li></ul></li><li><code>assert condition: expression;</code><ul><li>如果 <code>condition</code> 为 <code>false</code> 则抛出 <code>AssertionError</code> 异常，且 <code>expression</code> 会传入 <code>AssertionError</code> 构造器，并转为一个消息字符串</li></ul></li></ol><h2 id="6-2-启用-禁用断言"><a href="#6-2-启用-禁用断言" class="headerlink" title="6.2 启用/禁用断言"></a>6.2 启用/禁用断言</h2><ol><li><p>断言默认是禁用的</p></li><li><p>运行时使用 <code>-enableassertions</code> 或 <code>-ea</code> 启用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -ea Test 打开某个类的断言</span><br><span class="line">java -ea:xxx.xx.x Test 打开包下所有类的断言</span><br></pre></td></tr></table></figure></li><li><p><code>-disableassertions</code> 或 <code>-da</code> 禁用断言</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-异常体系&quot;&gt;&lt;a href=&quot;#一-异常体系&quot; class=&quot;headerlink&quot; title=&quot;一 异常体系&quot;&gt;&lt;/a&gt;一 异常体系&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/anyeansan/pics/raw/master
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="Java" scheme="https://anyeansan.github.io/categories/CS/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-面向对象</title>
    <link href="https://anyeansan.github.io/2020/09/29/Java/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://anyeansan.github.io/2020/09/29/Java/Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-09-29T07:45:40.000Z</published>
    <updated>2020-09-29T07:52:50.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-编程范式-programming-paradigm"><a href="#1-1-编程范式-programming-paradigm" class="headerlink" title="1.1 编程范式 programming paradigm"></a>1.1 编程范式 <code>programming paradigm</code></h2><table><thead><tr><th>术语</th><th>说明</th></tr></thead><tbody><tr><td><code>Procedural programming</code></td><td>面向过程</td></tr><tr><td><code>Object-Oriented Programming</code></td><td>面向对象</td></tr><tr><td><code>Functional Programming</code></td><td>函数式</td></tr><tr><td><code>Event-driven Programming</code></td><td>事件驱动</td></tr><tr><td><code>Aspect-oriented Programming</code></td><td>面向切面</td></tr><tr><td><code>Logic Programming</code></td><td>逻辑</td></tr></tbody></table><h2 id="1-2-面向对象和面向过程"><a href="#1-2-面向对象和面向过程" class="headerlink" title="1.2 面向对象和面向过程"></a>1.2 面向对象和面向过程</h2><ol><li>把大象装进冰箱<ul><li>面向过程 POP（<code>Process Oriented Programming</code>）<ol><li>打开冰箱门</li><li>把大象放进去</li><li>关上冰箱门</li></ol></li><li>面向对象 OOP（<code>Object Oriented Programming</code>）<ol><li>冰箱（开门，关门）</li><li>大象（进冰箱）</li><li>人（指挥冰箱开门，指挥大象进去，指挥冰箱关门）</li></ol></li></ul></li><li>区别<ol><li>面向过程<ul><li>强调的是功能行为，以函数为最小单位，考虑怎么做</li><li>性能相对较好，但耦合性搞，不易维护、复用和扩展</li></ul></li><li>面向对象<ul><li>强调具备了功能的对象，以类/对象为最小单位，考虑谁来做</li><li>耦合度低，易维护、易复用、易扩展</li></ul></li></ol></li></ol><h1 id="二-类"><a href="#二-类" class="headerlink" title="二 类"></a>二 类</h1><h2 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h2><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td><code>类 class</code></td><td>对一类事物的描述，模板</td></tr><tr><td><code>对象 object</code></td><td>某类事物的个体，也叫实例（<code>instance</code>）</td></tr><tr><td><code>属性 field</code></td><td>类的成员变量，也叫字段，域</td></tr><tr><td><code>方法 method</code></td><td>类的成员函数，也叫行为</td></tr></tbody></table><h2 id="2-2-类成员"><a href="#2-2-类成员" class="headerlink" title="2.2 类成员"></a>2.2 类成员</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">属性列表</span><br><span class="line">代码块</span><br><span class="line">构造器列表</span><br><span class="line">方法列表</span><br><span class="line">内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-构造器"><a href="#1-构造器" class="headerlink" title="1 构造器"></a>1 构造器</h3><ol><li>构造函数的名称必须与类名相同</li><li>一个类可以有多个构造器，彼此构成重载</li><li>若类中没有显式定义构造函数，则会有一个默认空参构造函数（修饰符与类一致 <code>public</code> 或 <code>default</code>）</li><li>构造函数第一行一定直接或间接调用父类构造函数，即如果在构造器首行没有显式的使用 <code>this(形参列表)</code> 或 <code>super(形参列表)</code> ，则默认调用了 <code>super()</code></li></ol><h3 id="2-属性"><a href="#2-属性" class="headerlink" title="2 属性"></a>2 属性</h3><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修饰符 数据类型 属性名; // 默认初始值</span><br><span class="line">修饰符 数据类型 属性名 = 值; // 显式初始值</span><br></pre></td></tr></table></figure><h4 id="2-成员变量（实例变量-静态变量）和局部变量"><a href="#2-成员变量（实例变量-静态变量）和局部变量" class="headerlink" title="2 成员变量（实例变量/静态变量）和局部变量"></a>2 成员变量（实例变量/静态变量）和局部变量</h4><table><thead><tr><th>变量</th><th>声明位置</th><th>初始值</th><th>存储位置</th></tr></thead><tbody><tr><td>实例变量</td><td>类中</td><td>有</td><td>堆</td></tr><tr><td>静态变量</td><td>类中</td><td>有</td><td>方法区</td></tr><tr><td>局部变量</td><td>方法形参、方法内、代码块内、构造形参、构造内</td><td>无</td><td>栈</td></tr></tbody></table><h3 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h3><h4 id="1-语法-1"><a href="#1-语法-1" class="headerlink" title="1 语法"></a>1 语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值 方法名(形参列表) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-形参列表"><a href="#2-形参列表" class="headerlink" title="2 形参列表"></a>2 形参列表</h4><ol><li><code>参数1, 参数2, ...</code></li><li><code>参数类型 ... 参数名</code> （可变参数）<ul><li>可以传递 0 到 多个参数</li><li>可变参数必须在形参的最后声明</li></ul></li></ol><h4 id="3-参数传递"><a href="#3-参数传递" class="headerlink" title="3 参数传递"></a>3 参数传递</h4><ol><li><p>Java 参数传递是<strong>值传递</strong></p><ul><li>基本数据类型实参赋值给形参的是实参真实存储的数据值</li><li>引用数据类型实参赋值给形参的是实参存储数据的地址值</li></ul></li><li><p><strong>java 在传递参数时，将实际参数的副本（拷贝一份）传入方法内，而参数本身不受影响</strong></p><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92.png" alt=""></p></li></ol><h4 id="4-方法的重载（Overload）"><a href="#4-方法的重载（Overload）" class="headerlink" title="4 方法的重载（Overload）"></a>4 方法的重载（Overload）</h4><ul><li>同一个类中，方法名相同，形参列表不同（个数、顺序或类型）即为重载</li></ul><h3 id="4-代码块"><a href="#4-代码块" class="headerlink" title="4 代码块"></a>4 代码块</h3><h4 id="1-构造代码块"><a href="#1-构造代码块" class="headerlink" title="1 构造代码块"></a>1 构造代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">构造代码块：</span><br><span class="line">        <span class="number">1</span> 每次创建类实例都会在构造器之前执行</span><br><span class="line">        <span class="number">2</span> 如果有多个，按照声明顺序执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-静态代码块"><a href="#2-静态代码块" class="headerlink" title="2 静态代码块"></a>2 静态代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">静态代码块：</span><br><span class="line">        <span class="number">1</span> 随着类的加载而执行，且仅在加载类字节码文件时执行一次</span><br><span class="line">        <span class="number">2</span> 如果有多个，按照声明顺序执行   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-内部类"><a href="#5-内部类" class="headerlink" title="5 内部类"></a>5 内部类</h3><h4 id="1-分类"><a href="#1-分类" class="headerlink" title="1 分类"></a>1 分类</h4><table><thead><tr><th>类型</th><th>分类</th><th>声明位置</th></tr></thead><tbody><tr><td>成员内部类</td><td>非静态成员内部类（成员内部类）<br>静态成员内部类（静态内部类）</td><td>类中</td></tr><tr><td>局部内部类</td><td>非匿名局部内部类（局部内部类）<br/>匿名局部内部类（匿名内部类）</td><td>方法中，代码块中，构造器中</td></tr></tbody></table><h4 id="2-成员内部类"><a href="#2-成员内部类" class="headerlink" title="2 成员内部类"></a>2 成员内部类</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h5><ol><li>当描述一个事物时，发现内部还有一个完整的结构需要一个类来描述，且此内部结构独立存在没有意义，必须依附外部类。就可以定义内部类。如身体和心脏。</li><li>内部类作为外部类的成员<ol><li>访问外部类<ul><li>内部类可以直接访问外部类的成员（包括私有），内部类持有一个外部类的引用 <code>外部类名.this</code></li><li>外部类要访问内部类的成员，必须创建对象</li></ul></li><li>可以被 4 种权限修饰符修饰</li><li>可以被 <code>static</code> 修饰：只要内部类不需要访问外部类对象，就应该使用静态内部类</li></ol></li><li>内部类作为一个类<ol><li>可以定义属性、方法、构造器等等</li><li>可以被 <code>abstract final</code> 修饰 </li></ol></li></ol><h5 id="2-非静态成员内部类（成员内部类）"><a href="#2-非静态成员内部类（成员内部类）" class="headerlink" title="2 非静态成员内部类（成员内部类）"></a>2 非静态成员内部类（成员内部类）</h5><ol><li><p>成员内部类中不能有任何 <code>static</code> 的定义</p></li><li><p>成员内部类的访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 首先要创建外部类对象</span></span><br><span class="line">Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line"><span class="comment">// 2 使用外部对象创建内部类对象</span></span><br><span class="line">Out.inner in = out.<span class="keyword">new</span> Inner()</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line">Outer.Inner in=<span class="keyword">new</span> Outer().<span class="keyword">new</span> Inner();</span><br></pre></td></tr></table></figure></li></ol><h5 id="3-静态成员内部类（静态内部类）"><a href="#3-静态成员内部类（静态内部类）" class="headerlink" title="3 静态成员内部类（静态内部类）"></a>3 静态成员内部类（静态内部类）</h5><ol><li><p>静态内部类可以定义所有普通类可以定义的内容</p></li><li><p>静态内部类不会随着外部类的加载而加载，只有使用时才会加载</p></li><li><p>静态内部类的访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建静态内部类对象</span></span><br><span class="line">Outer.Inner in=<span class="keyword">new</span> Outer.Inner()</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-局部内部类"><a href="#3-局部内部类" class="headerlink" title="3 局部内部类"></a>3 局部内部类</h4><h5 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h5><ol><li>局部内部类修饰符只能有 <code>final</code> 和 <code>abstract</code></li><li>局部内部类访问其所在方法的局部变量时，要求此局部变量必须是 <code>final</code><ol><li>因为当调用这个方法时，如果方法中的局部变量不是 <code>final</code> 的，那么方法弹栈此局部变量也就消失了，而此时局部内部类对象可能还存在，就会访问不到此局部变量</li><li>JDK 8 可以不加 <code>final</code>，但实际还是 <code>final</code> 的</li></ol></li></ol><h5 id="2-非匿名局部内部类（局部内部类）"><a href="#2-非匿名局部内部类（局部内部类）" class="headerlink" title="2 非匿名局部内部类（局部内部类）"></a>2 非匿名局部内部类（局部内部类）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-匿名局部内部类（匿名内部类）"><a href="#3-匿名局部内部类（匿名内部类）" class="headerlink" title="3 匿名局部内部类（匿名内部类）"></a>3 匿名局部内部类（匿名内部类）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> 父类/父接口() &#123;</span><br><span class="line">        重写方法;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-对象实例化过程"><a href="#2-3-对象实例化过程" class="headerlink" title="2.3 对象实例化过程"></a>2.3 对象实例化过程</h2><ol><li>加载 class 文件（有父类先加载父类）</li><li>静态变量和静态代码块（谁在前谁先执行，只执行一次）</li><li>属性默认初始化</li><li>构造函数第一行（调用父类构造）</li><li>属性显式初始化和构造代码块（谁在前谁先执行，每次创建对象都会执行）</li><li>构造函数剩余行</li></ol><h1 id="三-面向对象特征"><a href="#三-面向对象特征" class="headerlink" title="三 面向对象特征"></a>三 面向对象特征</h1><h2 id="3-1-权限修饰符"><a href="#3-1-权限修饰符" class="headerlink" title="3.1 权限修饰符"></a>3.1 权限修饰符</h2><table><thead><tr><th>修饰符</th><th>本类</th><th>同一个包(子类+无关类)</th><th>不同包(子类)</th><th>不同包(无关类)</th></tr></thead><tbody><tr><td><code>private</code></td><td>√</td><td>×</td><td>×</td><td>×</td></tr><tr><td><code>default</code></td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td><code>protected</code></td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td><code>public</code></td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><ol><li><p>权限修饰符是用来限定该类实例对象对该类成员的访问权限</p></li><li><p>在不同包的类中严格来说我认为只能访问 <code>public</code> 修饰的成员，特殊情况是不同包的子类中能使用子类实例访问到父类 <code>protected</code> 修饰的成员（使用父类实例是访问不到的），是因为继承的关系，在自己类中访问自己继承的东西当然可以访问到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在子类 A 中</span></span><br><span class="line"><span class="keyword">this</span>.clone() <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">new</span> A().clone() <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">new</span> Object().clone() <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">new</span> B().clone() <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="3-2-封装（Encapsulation）"><a href="#3-2-封装（Encapsulation）" class="headerlink" title="3.2 封装（Encapsulation）"></a>3.2 封装（<code>Encapsulation</code>）</h2><ol><li>封装即隐藏该隐藏的，暴露该暴露的</li><li>隐藏对象内部的复杂性，之对外公开简单接口，便于外界调用，提高维护性和扩展性</li><li>封装性的体现<ol><li><code>private</code> 私有化属性而提供公共的 <code>getter/setter</code> 方法</li><li>不对外暴漏的私有方法</li><li>单例…</li></ol></li></ol><h2 id="3-3-继承（Inheritance）"><a href="#3-3-继承（Inheritance）" class="headerlink" title="3.3 继承（Inheritance）"></a>3.3 继承（<code>Inheritance</code>）</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h3><ul><li>好处<ul><li>提高代码的复用性</li><li>便于功能的扩展</li><li>让类与类产生关系，是多态的前提</li></ul></li><li>弊端<ul><li>类的耦合性增强了</li></ul></li><li>开发原则：高内聚，低耦合<ul><li>耦合：类与类的关系</li><li>内聚：自己完成某件事的能力    </li></ul></li></ul><h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2 特点"></a>2 特点</h3><ol><li>子类会继承父类所有的属性和方法，私有的也会继承，只是不能直接访问</li><li>Java 是单继承，一个类只能有一个父类</li></ol><h3 id="3-重写（Override）"><a href="#3-重写（Override）" class="headerlink" title="3 重写（Override）"></a>3 重写（<code>Override</code>）</h3><ol><li>方法名一致</li><li>形参列表一致</li><li>返回值<ol><li>基本数据类型和 <code>void</code>，必须完全一致</li><li>引用数据类型，一致或者其子类</li></ol></li><li>权限修饰符<ul><li>子类重写方法访问权限不能小于父类方法</li></ul></li><li>异常<ol><li>子类重写方法抛出的异常只能是父类方法抛出的异常或者其子类</li><li>子类重写方法不能抛出父类方法没有抛出的异常</li></ol></li><li>不能被重写的方法<ol><li><code>final</code> 修饰的方法</li><li><code>static</code> 修饰的方法</li><li>子类不能访问的方法<ol><li><code>private</code> 修饰的方法</li><li>跨包时默认修饰权限的方法</li></ol></li></ol></li></ol><h3 id="4-类型转换"><a href="#4-类型转换" class="headerlink" title="4 类型转换"></a>4 类型转换</h3><ol><li><p>只能在继承层次内进行类型转换</p><ol><li>向上转型（<code>upcasting</code>）：子类转父类，多态，自动转换</li><li>向下转型（<code>downcasting</code>）：父类转子类，强制类型转换</li></ol></li><li><p>强制类型转换前，应使用 <code>instanceof</code> 检查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x <span class="keyword">instanceof</span> A</span><br><span class="line"><span class="comment">// 判断 x 对象所属类是否是 A 类或 A 类的子类</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="3-4-多态（Polymorphism）"><a href="#3-4-多态（Polymorphism）" class="headerlink" title="3.4 多态（Polymorphism）"></a>3.4 多态（<code>Polymorphism</code>）</h2><h3 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>一个对象变量可以指向多种实际类型的现象称为多态</li><li>编译时类型和运行时类型不一致，就出现了多态<ol><li>编译时类型由声明时的类型决定</li><li>运行时类型由实际对象类型决定</li></ol></li><li>虚拟方法调用：子类中定义了与父类同名同参的方法（重写），多态情况下，将父类方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法，这样的方法调用编译器是无法确定的</li><li>在运行时能自动的选择适当的方法称为动态绑定 <code>dynamic binding</code></li><li>如果是 <code>private static final</code> 方法或构造器，编译器可以准确的知道调用哪个方法，称为静态绑定 <code>static binding</code></li></ol><h3 id="2-多态前提"><a href="#2-多态前提" class="headerlink" title="2 多态前提"></a>2 多态前提</h3><ol><li>继承或实现</li><li>重写</li><li>父类引用指向了子类对象</li></ol><h3 id="3-多态性"><a href="#3-多态性" class="headerlink" title="3 多态性"></a>3 多态性</h3><table><thead><tr><th>成员</th><th>多态性</th><th>说明</th></tr></thead><tbody><tr><td>成员变量（属性）</td><td>无</td><td>编译运行都看左边</td></tr><tr><td>非静态成员方法</td><td>有</td><td>编译看左边，运行看右边（动态绑定）</td></tr><tr><td>静态成员方法</td><td>无</td><td>编译运行都看左边</td></tr></tbody></table><ol><li><p>对象的多态性只适用于方法，不适用于属性</p></li><li><p>非静态成员方法：虚拟方法调用</p><ul><li>编译时：查看声明类型所属类（父类）是否有此方法，有则编译通过，没有则报错</li><li>运行时：查看对象实例所属类（子类）是否有父类中此方法对应的重写方法，有则执行，没有则向上查找</li></ul></li><li><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eatFish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cat cat = <span class="keyword">new</span> SmallCat();</span><br><span class="line">        cat.eatFish(); <span class="comment">// 结果是 "猫吃鱼"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallCat</span> <span class="keyword">extends</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatFish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小猫吃奶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为父类是private，子类访问不到，所以并非是重写</span></span><br><span class="line"><span class="comment">// 成员方法运行时调用的是子类重写方法，没有则会调用父类方法，所以结果是调用的父类方法</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="四-关键字"><a href="#四-关键字" class="headerlink" title="四 关键字"></a>四 关键字</h1><h2 id="4-1-this"><a href="#4-1-this" class="headerlink" title="4.1 this"></a>4.1 this</h2><ol><li>方法中：代表调用该方法的对象</li><li>构造器中：代表正在初始化的对象</li><li>构造器中：调用本类其它构造器</li></ol><h2 id="4-2-super"><a href="#4-2-super" class="headerlink" title="4.2 super"></a>4.2 super</h2><ol><li>构造器或方法中：访问父类属性或方法</li><li>构造器中：调用父类构造</li></ol><h2 id="4-3-static"><a href="#4-3-static" class="headerlink" title="4.3 static"></a>4.3 static</h2><ol><li>随着类的加载而加载</li><li>优先于对象存在</li><li>被类的所有实例共享</li><li>直接使用类名调用</li><li>静态上下文只能访问静态，不能访问非静态，静态上下文中没有 <code>this super</code></li><li>非静态上下文可以访问静态和非静态</li></ol><h2 id="4-4-final"><a href="#4-4-final" class="headerlink" title="4.4 final"></a>4.4 final</h2><table><thead><tr><th>修饰对象</th><th>说明</th></tr></thead><tbody><tr><td>类</td><td>类不能被继承，一个类被声明为 <code>final</code> 则其方法自动变为 <code>final</code></td></tr><tr><td>变量</td><td>变量就变成了常量，必须初始化且只能被赋值一次，大写</td></tr><tr><td>方法</td><td>方法不能被重写</td></tr></tbody></table><h2 id="4-5-abstract"><a href="#4-5-abstract" class="headerlink" title="4.5 abstract"></a>4.5 abstract</h2><h4 id="1-只能修饰类和方法"><a href="#1-只能修饰类和方法" class="headerlink" title="1 只能修饰类和方法"></a>1 只能修饰类和方法</h4><ol><li>抽象类有构造方法，但不能实例化</li><li>抽象类可以有抽象方法也可以有一般方法（包括静态和非静态方法）</li><li>有抽象方法的一定是抽象类，抽象类不一定有抽象方法</li></ol><h4 id="2-abstract-不共存的关键字（抽象是为了重写）"><a href="#2-abstract-不共存的关键字（抽象是为了重写）" class="headerlink" title="2 abstract 不共存的关键字（抽象是为了重写）"></a>2 abstract 不共存的关键字（抽象是为了重写）</h4><ol><li><code>static</code><ul><li>类直接调用一个抽象方法没有意义</li></ul></li><li><code>private</code><ul><li><code>private</code> 修饰的方法子类无法访问，也就无法重写，一个不能被重写的抽象方法没有意义</li></ul></li><li><code>final</code><ul><li><code>final</code> 修饰的类无法继承，一个不能被继承的抽象类没有意义</li><li><code>final</code> 修饰方法无法重写，一个不能被重写的方法没有意义</li></ul></li><li><code>native</code><ul><li>因为 <code>native</code> 本身就没有方法体，不明确是什么情况</li></ul></li></ol><h2 id="4-6-native"><a href="#4-6-native" class="headerlink" title="4.6 native"></a>4.6 native</h2><ol><li><code>native</code> 修饰的方法，看不到方法体，不是 Java 语言实现的，而是调用了底层 C/C++ 的实现，存储在本地方法栈</li><li><code>native</code> 方法正常调用即可，且可以重写</li></ol><h2 id="4-7-包"><a href="#4-7-包" class="headerlink" title="4.7 包"></a>4.7 包</h2><h3 id="1-package"><a href="#1-package" class="headerlink" title="1 package"></a>1 package</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> x.x.x;</span><br></pre></td></tr></table></figure><ol><li>同一个包下类/接口不能重名</li><li>用于控制访问权限</li><li>用于划分项目的结构层次，通常将功能相近的类划分到同一个包中</li></ol><h3 id="2-import"><a href="#2-import" class="headerlink" title="2 import"></a>2 import</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*</span><br><span class="line">import static java.util.Math.*;</span><br></pre></td></tr></table></figure><ol><li>如果在源文件中，使用了不同包下的同名的类，则只有一个可以导入，其它需要使用全类名的方式</li><li><code>xxx.*</code> 表示可以使用 <code>xxx</code> 包下的所有结构，但其子包下还需要导入</li></ol><h3 id="3-JDK-主要包说明"><a href="#3-JDK-主要包说明" class="headerlink" title="3 JDK 主要包说明"></a>3 JDK 主要包说明</h3><table><thead><tr><th>包</th><th>说明</th></tr></thead><tbody><tr><td><code>java.lang</code></td><td>Java语言的核心类/接口</td></tr><tr><td><code>java.io</code></td><td>IO 功能相关类/接口</td></tr><tr><td><code>java.net</code></td><td>网络相关类/接口</td></tr><tr><td><code>java.util</code></td><td>实用工具类</td></tr><tr><td><code>java.text</code></td><td>格式化相关的类</td></tr><tr><td><code>java.sql</code></td><td>JDBC数据库编程的相关类/接口</td></tr><tr><td><code>java.awt</code></td><td>GUI 相关</td></tr><tr><td><code>java.applet</code></td><td>applet 运行所需的类</td></tr></tbody></table><h1 id="五-main-方法说明"><a href="#五-main-方法说明" class="headerlink" title="五 main() 方法说明"></a>五 <code>main()</code> 方法说明</h1><ol><li>作为程序的入口</li><li>可以当作普通的静态方法</li><li><code>String[] args</code> 可以用来接收控制台参数（以空格隔开）</li></ol><h1 id="六-接口-Interface"><a href="#六-接口-Interface" class="headerlink" title="六 接口 Interface"></a>六 接口 <code>Interface</code></h1><h2 id="6-1-语法"><a href="#6-1-语法" class="headerlink" title="6.1 语法"></a>6.1 语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">interface</span> 接口名 </span>&#123;</span><br><span class="line">接口属性列表;</span><br><span class="line">接口方法列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>接口没有构造器，不能创建对象</li><li>类可以多实现，接口可以继承接口</li><li>接口实现类必须实现所有的接口方法，否则仍是抽象类</li></ol><h2 id="6-2-成员"><a href="#6-2-成员" class="headerlink" title="6.2 成员"></a>6.2 成员</h2><table><thead><tr><th>接口成员</th><th>修饰符</th><th>说明</th></tr></thead><tbody><tr><td>全局常量</td><td><code>public static final</code></td><td>修饰符可以省略</td></tr><tr><td>抽象方法</td><td><code>public abstract</code></td><td>修饰符可以省略</td></tr><tr><td>静态方法</td><td><code>public static</code></td><td><code>public</code> 可以省略</td></tr><tr><td>默认方法</td><td><code>public default</code></td><td><code>public</code> 可以省略</td></tr><tr><td>私有方法</td><td><code>private</code></td><td>修饰符不能省略</td></tr></tbody></table><ol><li>JDK 8 以后接口为何新增静态方法?<ol><li>因为一般工具类中都是静态方法，而这些静态方法通常都是为某个接口服务的，如 <code>Collection Collections</code></li><li>把静态方法直接定义在接口中，可以避免增加额外的工具类</li></ol></li><li>JDK 8 以后接口为何新增默认方法?<ol><li>因为有时候，一个接口的多数实现类对接口的抽象方法的实现是一样的</li><li>把这样的抽象方法定义为默认方法，可以减少实现类的重复工作</li><li>如果实现类实现多个接口，出现了默认方法冲突（会报错）<ol><li>从其中选择一个，重写默认方法（去掉 <code>default</code>）</li><li>都不用，重写默认方法（去掉 <code>default</code>）</li></ol></li><li>如果实现类继承父类实现接口，出现了默认方法冲突（不会报错）<ol><li>默认使用父类</li><li>手动改选接口</li><li>完全重写</li></ol></li></ol></li><li>Java 9 中 接口中可以有 <code>private</code> 方法</li></ol><h1 id="七-枚举-Enum"><a href="#七-枚举-Enum" class="headerlink" title="七 枚举 Enum"></a>七 枚举 <code>Enum</code></h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ol><li>类的对象只有确定的有限个</li><li>枚举即将其所有可用对象直接在内部列出来</li><li>枚举不需要创建对象，构造函数默认即为私有的</li><li>当需要定义一组常量时，强烈建议使用枚举类</li><li>枚举也可以实现接口</li></ol><h2 id="7-2-自定义枚举"><a href="#7-2-自定义枚举" class="headerlink" title="7.2 自定义枚举"></a>7.2 自定义枚举</h2><h3 id="1-手动实现枚举（JDK5-之前）"><a href="#1-手动实现枚举（JDK5-之前）" class="headerlink" title="1 手动实现枚举（JDK5 之前）"></a>1 手动实现枚举（<code>JDK5</code> 之前）</h3><ol><li>私有化构造函数</li><li>在类中创建所有可用的实例对象，定义为公有静态常量 <code>public static final</code></li></ol><h3 id="2-enum-关键字"><a href="#2-enum-关键字" class="headerlink" title="2 enum 关键字"></a>2 <code>enum</code> 关键字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">enum</span> 枚举类名 &#123;</span><br><span class="line">枚举项列表;</span><br><span class="line">其它成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>默认继承 <code>java.lang.Enum</code> </p></li><li><p>枚举项必须定义在首行，以逗号分隔，最后一个以分号结束</p></li><li><p>枚举项即为枚举类的实例</p><ol><li><p>构造函数有参数，枚举项也要有参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Week&#123;</span><br><span class="line">MON(<span class="string">"星期一"</span>),TUS(<span class="string">"星期二"</span>),SUN(<span class="string">"星期日"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>枚举类有抽象方法，枚举项也要实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Week &#123;</span><br><span class="line">Mon(<span class="string">"星期一"</span>)&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="7-3-java-lang-Enum"><a href="#7-3-java-lang-Enum" class="headerlink" title="7.3 java.lang.Enum"></a>7.3 <code>java.lang.Enum</code></h2><h3 id="1-构造"><a href="#1-构造" class="headerlink" title="1 构造"></a>1 构造</h3><table><thead><tr><th>构造</th></tr></thead><tbody><tr><td><code>protected Enum(String name, int ordinal)</code></td></tr></tbody></table><ol><li>此构造方法不是程序员调用的，而是由编译器调用的</li><li>所以不能在枚举类中手动调用父类构造</li></ol><h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2 方法"></a>2 方法</h3><table><thead><tr><th>修饰</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>String</code></td><td><code>toString()</code></td><td>返回此枚举项的名称</td></tr><tr><td><code>int</code></td><td><code>ordinal()</code></td><td>返回枚举项的编号</td></tr><tr><td><code>String</code></td><td><code>name()</code></td><td>返回此枚举项的名称</td></tr><tr><td><code>int</code></td><td><code>compareTo(E o)</code></td><td>比较枚举项的编号</td></tr><tr><td><code>static &lt;T extends Enum&lt;T&gt;&gt;</code></td><td><code>valueOf(Class&lt;T&gt; enumType, String name)</code></td><td>返回指定类型中指定名称的枚举项</td></tr><tr><td><code>static T[]</code></td><td><code>values()</code></td><td><code>Enum</code> 没有，所有枚举类都有，获取所有枚举项</td></tr><tr><td><code>static T</code></td><td><code>valueOf(String name)</code></td><td><code>Enum</code> 没有，所有枚举类都有，返回指定名称的枚举项</td></tr></tbody></table><h1 id="八-注解-Annotation"><a href="#八-注解-Annotation" class="headerlink" title="八 注解 Annotation"></a>八 注解 <code>Annotation</code></h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><ol><li>注解是针对程序的注释，是给程序看的，用于描述程序如何运行及在什么阶段来运行。</li><li>注解在实际开发中，最大的功能是用于替换配置文件</li><li>一个完整的注解由三部分组成<ol><li>声明</li><li>使用</li><li>读取</li></ol></li><li>Java 把枚举看作类，把注解看作接口</li><li>所有注解都继承了 <code>java.lang.annotation.Annotation</code></li></ol><h2 id="8-2-JDK-中三个基本注解"><a href="#8-2-JDK-中三个基本注解" class="headerlink" title="8.2 JDK 中三个基本注解"></a>8.2 JDK 中三个基本注解</h2><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td><code>@Override</code></td><td>检查重写方法是否合法</td></tr><tr><td><code>@Deprecated</code></td><td>表示已过时</td></tr><tr><td><code>@SuppressWarnings({警告类型列表/all})</code></td><td>抑制警告</td></tr></tbody></table><h2 id="8-3-文档注释相关注解"><a href="#8-3-文档注释相关注解" class="headerlink" title="8.3 文档注释相关注解"></a>8.3 文档注释相关注解</h2><table><thead><tr><th>注解</th><th>说明</th><th>格式</th></tr></thead><tbody><tr><td><code>@author</code></td><td>作者</td><td><code>@author 作者名</code></td></tr><tr><td><code>@version</code></td><td>版本</td><td><code>@version 1.0</code></td></tr><tr><td><code>@see</code></td><td>另请参阅</td><td><code>@see 另请参阅信息</code></td></tr><tr><td><code>@since</code></td><td>从 xx 版本开始引入</td><td><code>@since xx</code></td></tr><tr><td><code>@param</code></td><td>参数信息，一对一</td><td><code>@param 形参名 形参类型 注释</code></td></tr><tr><td><code>@return</code></td><td>返回值信息</td><td><code>@return 返回值类型 注释</code></td></tr><tr><td><code>@throws</code></td><td>抛出异常信息</td><td><code>@throws 异常类型 注释</code></td></tr></tbody></table><h2 id="8-4-自定义注解"><a href="#8-4-自定义注解" class="headerlink" title="8.4 自定义注解"></a>8.4 自定义注解</h2><h3 id="1-声明"><a href="#1-声明" class="headerlink" title="1 声明"></a>1 声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">数据类型 属性名(); <span class="comment">// 注解的属性类似方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "haha"</span>; <span class="comment">// 可以设置默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>注解数据类型<ol><li>八种基本数据类型</li><li><code>String</code> 类型</li><li><code>enum</code> 枚举类型</li><li><code>Annotation</code> 注解类型</li><li><code>Class</code> 类型</li><li>以上类型的一维数组类型</li></ol></li><li>如果注解没有成员，通常是标识作用</li><li>如果注解只有一个成员，建议属性名 <code>value</code></li></ol><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Xxx</span>(name=<span class="string">""</span>) <span class="comment">//非数组类型注解赋值</span></span><br><span class="line"><span class="meta">@Xxx</span>(name=&#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>&#125;) <span class="comment">// 数组类型注解赋值</span></span><br></pre></td></tr></table></figure><ol><li>使用注解时注解中的所有属性都要赋值，有默认值的可以省略使用默认值</li><li>如果使用注解时最终配置的属性只有一个 <code>value</code>，则可以省略属性名</li></ol><h3 id="3-读取"><a href="#3-读取" class="headerlink" title="3 读取"></a>3 读取</h3><ul><li>使用<strong>反射</strong>读取注解</li></ul><h2 id="8-5-元注解（用在注解上的注解）"><a href="#8-5-元注解（用在注解上的注解）" class="headerlink" title="8.5 元注解（用在注解上的注解）"></a>8.5 元注解（用在注解上的注解）</h2><table><thead><tr><th>元注解</th><th>格式</th><th>说明</th></tr></thead><tbody><tr><td><code>@target</code></td><td><code>@target(ElementType.xxx)</code></td><td>标记此注解的使用位置</td></tr><tr><td><code>@Retention</code></td><td><code>@Retention(RetentionPolicy.xxx)</code></td><td>标记此注解的生命周期</td></tr><tr><td><code>@Documented</code></td><td><code>@Documented</code></td><td>标记此注解可以被 <code>javadoc.exe</code> 读取到 API</td></tr><tr><td><code>@Inherited</code></td><td><code>@Inherited</code></td><td>标记此注解可以被子类继承</td></tr></tbody></table><h3 id="1-ElementType"><a href="#1-ElementType" class="headerlink" title="1 ElementType"></a>1 <code>ElementType</code></h3><ul><li>是一个枚举类，用于枚举注解使用的位置</li></ul><table><thead><tr><th>枚举项</th><th>使用位置</th></tr></thead><tbody><tr><td><code>TYPE</code></td><td>类，接口（包括注解）或枚举</td></tr><tr><td><code>FIELD</code></td><td>属性</td></tr><tr><td><code>METHOD</code></td><td>方法</td></tr><tr><td><code>PARAMETER</code></td><td>形参</td></tr><tr><td><code>CONSTRUCTOR</code></td><td>构造函数</td></tr><tr><td><code>LOCAL_VARIABLE</code></td><td>局部变量</td></tr><tr><td><code>ANNOTATION_TYPE</code></td><td>注解</td></tr><tr><td><code>PACKAGE</code></td><td>包</td></tr><tr><td><code>TYPE_PARAMETER</code></td><td>类型变量的声明语句（如泛型声明）</td></tr><tr><td><code>TYPE_USE</code></td><td>使用类型的任何语句</td></tr></tbody></table><h3 id="2-RetentionPolicy"><a href="#2-RetentionPolicy" class="headerlink" title="2 RetentionPolicy"></a>2 <code>RetentionPolicy</code></h3><ul><li>是一个枚举类，用于枚举注解的存活阶段</li></ul><table><thead><tr><th>枚举项</th><th>说明</th></tr></thead><tbody><tr><td><code>SOURCE</code></td><td>源代码阶段有效（即<code>.java</code>源文件保留），会被编译器舍弃，即编译后的字节码文件不保留</td></tr><tr><td><code>CLASS</code>（默认）</td><td>字节码阶段有效（即 <code>.class</code> 文件保留），运行时不会保留</td></tr><tr><td><code>RUNTIME</code></td><td>运行阶段有效（即运行时保留），可通过反射获取</td></tr></tbody></table><h2 id="8-6-JDK8-新特新"><a href="#8-6-JDK8-新特新" class="headerlink" title="8.6 JDK8 新特新"></a>8.6 JDK8 新特新</h2><ol><li>可重复注解 <code>@Repeatable</code></li><li>类型注解</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-编程范式-programming-paradigm&quot;&gt;&lt;a href=&quot;#1-1-编程范式-program
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="Java" scheme="https://anyeansan.github.io/categories/CS/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-语法</title>
    <link href="https://anyeansan.github.io/2020/09/29/Java/Java-%E8%AF%AD%E6%B3%95/"/>
    <id>https://anyeansan.github.io/2020/09/29/Java/Java-%E8%AF%AD%E6%B3%95/</id>
    <published>2020-09-29T06:29:26.000Z</published>
    <updated>2020-09-29T07:52:46.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/java.png" alt=""></p><table><thead><tr><th>术语</th><th>缩写</th><th>说明</th></tr></thead><tbody><tr><td><code>Java Development Kit</code></td><td><code>JDK</code></td><td>Java 开发工具包，编写 Java 程序的程序员使用的软件</td></tr><tr><td><code>Java Runtime Environment</code></td><td><code>JRE</code></td><td>Java 运行时环境，运行 Java 程序的用户使用的软件</td></tr><tr><td><code>Standard Edition</code></td><td><code>SE</code></td><td>标准版，用于桌面或简单服务器应用的 Java 平台</td></tr><tr><td><code>Enterprise Edition</code></td><td><code>EE</code></td><td>企业版，用于复杂服务器应用的 Java 平台</td></tr><tr><td><code>Micro Edition</code></td><td><code>ME</code></td><td>微型版，用于小型设备的 Java 平台</td></tr><tr><td><code>Java Virtual Machine</code></td><td><code>JVM</code></td><td>Java 虚拟机，Java 程序运行在虚拟机上而非操作系统上</td></tr><tr><td><code>Oracle JDK</code></td><td><code>-</code></td><td>官方 <code>Java SE</code></td></tr><tr><td><code>Open JDK</code></td><td><code>-</code></td><td><code>Java SE</code> 的一个免费开源实现</td></tr><tr><td><code>Software Development Kit</code></td><td><code>SDK</code></td><td>过时，用于描述 1998 ~ 2006 年之间的 JDK</td></tr><tr><td><code>NetBeans</code></td><td><code>-</code></td><td>Oracle 公司的集成开发环境</td></tr><tr><td><code>path</code></td><td><code>-</code></td><td>为了在任意地方使用所配置路径下的命令</td></tr><tr><td><code>classpath</code></td><td><code>-</code></td><td>寻找 <code>.class</code> 文件的路径</td></tr></tbody></table><h2 id="1-2-编译-amp-运行"><a href="#1-2-编译-amp-运行" class="headerlink" title="1.2 编译 &amp; 运行"></a>1.2 编译 &amp; 运行</h2><h3 id="1-编译"><a href="#1-编译" class="headerlink" title="1 编译"></a>1 编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac a/b/c/test.java</span><br></pre></td></tr></table></figure><ul><li>执行 <code>javac.exe</code> 命令所在的目录 + 输入的 <code>.java</code> 文件路径 = <code>.java</code> 文件绝对路径</li><li><code>.java</code> 文件可以有多个类，但只能有零或一个 <code>public</code> 类且必须与文件名相同</li></ul><h3 id="2-运行"><a href="#2-运行" class="headerlink" title="2 运行"></a>2 运行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java 字节码文件名</span><br></pre></td></tr></table></figure><ul><li>必须在类的全限定名所在的路径下执行 <code>java.exe</code> 命令，因为 <code>classpath</code> 不设置时，默认在当前路径寻找 <code>.class</code> 文件</li></ul><h1 id="二-注释"><a href="#二-注释" class="headerlink" title="二 注释"></a>二 注释</h1><h2 id="2-1-单行注释"><a href="#2-1-单行注释" class="headerlink" title="2.1 单行注释"></a>2.1 单行注释</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br></pre></td></tr></table></figure><h2 id="2-2-多行注释"><a href="#2-2-多行注释" class="headerlink" title="2.2 多行注释"></a>2.2 多行注释</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 多行注释禁止嵌套</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="2-3-文档注释"><a href="#2-3-文档注释" class="headerlink" title="2.3 文档注释"></a>2.3 文档注释</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 作者</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> 另请参阅</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 从 xxx 版本开始引入</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> 参数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 返回值</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> 异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成文档</span></span><br><span class="line">javadoc -d 文件夹名称 -encoding UTF-<span class="number">8</span> -charset UTF-<span class="number">8</span> -author -version xxx.java</span><br></pre></td></tr></table></figure><h1 id="三-标识符"><a href="#三-标识符" class="headerlink" title="三 标识符"></a>三 标识符</h1><h2 id="3-1-定义规则"><a href="#3-1-定义规则" class="headerlink" title="3.1 定义规则"></a>3.1 定义规则</h2><ol><li>合法字符<ul><li><code>A~Za~z</code></li><li><code>0~9</code></li><li><code>_</code></li><li><code>$</code></li></ul></li><li>不能以数字开头，不能使用空格</li><li>不能使用关键字和保留字，但可以包含</li><li>严格区分大小写，长度无限制</li></ol><h2 id="3-2-命名规范"><a href="#3-2-命名规范" class="headerlink" title="3.2 命名规范"></a>3.2 命名规范</h2><table><thead><tr><th>对象</th><th>规范</th></tr></thead><tbody><tr><td><code>包名</code></td><td>所有单词小写</td></tr><tr><td><code>类名, 接口名</code></td><td>所有单词的首字母大写</td></tr><tr><td><code>变量名, 方法名</code></td><td>第一个单词首字母小写，后边首字母大写</td></tr><tr><td><code>常量名</code></td><td>所有单词大写，单词之间使用 <code>_</code> 连接</td></tr></tbody></table><h1 id="四-数据类型"><a href="#四-数据类型" class="headerlink" title="四 数据类型"></a>四 数据类型</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt=""></p><h2 id="4-2-基本数据类型"><a href="#4-2-基本数据类型" class="headerlink" title="4.2 基本数据类型"></a>4.2 基本数据类型</h2><h3 id="1-整型"><a href="#1-整型" class="headerlink" title="1 整型"></a>1 整型</h3><table><thead><tr><th>类型</th><th>大小</th><th>无符号范围</th><th>有符号范围</th><th>默认初始值</th></tr></thead><tbody><tr><td><code>byte</code></td><td>1 字节</td><td><code>0 ~ 255</code></td><td><code>-128 ~ 127</code></td><td><code>0</code></td></tr><tr><td><code>short</code></td><td>2 字节</td><td><code>0 ~ 65535</code></td><td><code>-2<sup>15</sup> ~ 2<sup>15</sup>-1</code></td><td><code>0</code></td></tr><tr><td><code>int（默认）</code></td><td>4 字节</td><td><code>0 ~ 2<sup>32</sup>-1</code></td><td><code>-2<sup>31</sup> ~ 2<sup>31</sup>-1</code></td><td><code>0</code></td></tr><tr><td><code>long</code></td><td>8 字节</td><td><code>0 ~ 2<sup>64</sup>-1</code></td><td><code>-2<sup>63</sup> ~ 2<sup>63</sup>-1</code></td><td><code>0L</code></td></tr></tbody></table><ol><li><p>Java 都是有符号的，整形默认为 <code>int</code>，<code>long</code> 类型声明时需要加 <code>l</code> 或 <code>L</code></p></li><li><p>长度计算公式（n 为字节数）</p><ul><li><p>有符号：-2<sup>8n-1</sup>~ 2<sup>8n-1</sup>-1</p></li><li><p>无符号：0~2<sup>8n</sup>-1</p></li></ul></li><li><p>进制表示：</p><ul><li>二进制：<code>0b</code> 开头</li><li>八进制：<code>0</code> 开头</li><li>十进制：<code>0x</code> 开头</li></ul></li><li><p>数字字面量可添加下划线，为了可读性，编译器会自动去除</p><ul><li><code>10_000_000</code></li></ul></li><li><p>常量优化机制：Java 中整数默认为 <code>int</code> 型，当把整数值赋值给非 <code>int</code> 的整型时，<code>JVM</code> 会判断整数值是否超过此类型的范围</p><ol><li>没有超过，则自动进行隐式转换，如 <code>byte b = 127</code></li><li>超过，则报错，如 <code>byte b = 128</code></li></ol></li></ol><h3 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="2 浮点型"></a>2 浮点型</h3><table><thead><tr><th>类型</th><th>大小</th><th>默认初始值</th></tr></thead><tbody><tr><td><code>float</code></td><td>4 字节</td><td><code>0.0F</code></td></tr><tr><td><code>double（默认）</code></td><td>8 字节</td><td><code>0.0D</code></td></tr></tbody></table><ol><li>浮点型默认为 <code>double</code> ，<code>float</code> 类型声明时需要加 <code>f</code> 或 <code>F</code></li><li>浮点型常量有两种表示形式<ul><li>十进制数形式，如 <code>3.14 3.14F .314</code></li><li>科学计数法形式，如 <code>3.14e2 314E2 100E-2</code></li></ul></li></ol><h3 id="3-布尔型"><a href="#3-布尔型" class="headerlink" title="3 布尔型"></a>3 布尔型</h3><table><thead><tr><th>类型</th><th>取值</th><th>默认初始值</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>true false</code></td><td><code>false</code></td></tr></tbody></table><h3 id="4-字符型"><a href="#4-字符型" class="headerlink" title="4 字符型"></a>4 字符型</h3><table><thead><tr><th>类型</th><th>大小</th><th>范围</th><th>默认初始值</th></tr></thead><tbody><tr><td><code>char</code></td><td>2 字节</td><td><code>\u0000 ~ \uffff</code>（ <code>0 ~ 65535</code> ）</td><td><code>\u0000</code>（空）</td></tr></tbody></table><ol><li>字符型：由单引号包裹的<strong>单个</strong>字符（汉字、字母、数字、符号）<ul><li><code>&#39;&#39;</code>：错误，不能是空单引号 </li><li><code>&#39; &#39;</code>：正确，空格字符</li></ul></li><li>字符型三种表现形式<ul><li>单引号包裹的单个字符</li><li>转义符转义的特殊字符，如 <code>&#39;\n&#39;</code></li><li>Unicode 值</li></ul></li><li>Java 中字符使用 <code>Unicode</code> 字符集，编码规则为 <code>UTF-16</code> ，表示形式为 <code>\u0000</code>：<ul><li><code>\u</code>：转义序列，表示是 <code>Unicode</code></li><li><code>0000</code>：字符在 <code>Unicode</code> 中的码点对应的十六进制数</li></ul></li></ol><h2 id="4-3-基本数据类型转换"><a href="#4-3-基本数据类型转换" class="headerlink" title="4.3 基本数据类型转换"></a>4.3 基本数据类型转换</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" alt=""></p><ol><li>自动类型转换（隐式转换）：<code>低容量类型 → 高容量类型</code></li><li>强制类型转换：<code>高容量类型 → 低容量类型</code>，可能损失精度</li><li><code>boolean</code> 类型与其他基本类型不能进行类型转换</li><li>运算时，会先将两个操作数转为同一类型<ol><li><code>byte short char</code> 都会先转为 <code>int</code></li><li><code>int → long → float → double</code>：碰到靠右的则先转为其类型</li></ol></li></ol><h2 id="4-4-大数"><a href="#4-4-大数" class="headerlink" title="4.4 大数"></a>4.4 大数</h2><ol><li><p>如果基本整数和浮点数精度不满足需求，可以使用 <code>java.math</code> 包下的类</p><ol><li><code>BigInteger</code>：可以实现任意精度的整数运算</li><li><code>BigDecimal</code>：可以实现任意精度的浮点数运算</li></ol></li><li><p>将数值转为大数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger.valueOf(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">new</span> BigInteger(String num)</span><br></pre></td></tr></table></figure></li></ol><h2 id="4-5-字符串"><a href="#4-5-字符串" class="headerlink" title="4.5 字符串"></a>4.5 字符串</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>Java 字符串即 <code>Unicode</code> 字符序列，如 <code>&quot;Java\u5B89&quot;</code> 由 5 个 <code>Unicode</code> 字符组成 <code>J a v a 安</code></li><li>字符串：由双引号包裹的 0 到 多个字符</li><li>每个字符串都是 <code>java.lang.String</code> 的一个实例</li></ol><h3 id="2-字符串常量池"><a href="#2-字符串常量池" class="headerlink" title="2 字符串常量池"></a>2 字符串常量池</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h4><ol><li>字符串常量池中不会存储相同内容的字符串</li><li><code>String pool</code> 是一个固定大小的 <code>Hashtable</code>，可通过 <code>-XX:StringTableSize</code> 设置长度<ol><li><code>JDK6</code> 默认长度是 <code>1009</code>，设置无要求</li><li><code>JDK7</code> 默认长度是 <code>60013</code>，设置无要求</li><li><code>JDK8</code> 开始默认长度是 <code>60013</code>，<code>1009</code> 是可设置的最小长度</li></ol></li></ol><h4 id="2-创建字符串"><a href="#2-创建字符串" class="headerlink" title="2 创建字符串"></a>2 创建字符串</h4><ol><li>字面量<ul><li>字符串存储在常量池中</li></ul></li><li><code>new</code><ol><li><code>new String(&quot;a&quot;)</code><ul><li>对象1：<code>new String(&quot;a&quot;)</code></li><li>对象2：常量池中的 <code>&quot;a&quot;</code></li></ul></li><li><code>new String(&quot;a&quot;) + new String(&quot;b&quot;)</code><ul><li>对象1：<code>new StringBuilder()</code></li><li>对象2：<code>new String(&quot;a&quot;)</code></li><li>对象3：常量池中的 <code>&quot;a&quot;</code></li><li>对象4：<code>new String(&quot;b&quot;)</code></li><li>对象5：常量池中的 <code>&quot;b&quot;</code></li><li>对象6：<code>new String(&quot;ab&quot;)</code><ol><li><code>StringBuilder.toString()</code> 的底层实际是 <code>new</code> 了一个字符串</li><li>注意：<code>&quot;ab&quot;</code> 并不会存入常量池中</li></ol></li></ul></li></ol></li><li><code>String</code> 类的 <code>intern()</code><ol><li>当调用的字符串在字符串常量池中已存在，则直接返回池中对象的地址引用</li><li>当调用的字符串在字符串常量池中不存在<ol><li><code>JDK6</code> 会复制一个新的字符串对象放入常量池中，并返回池中对象的地址引用</li><li><code>JDK7</code> 及以后，会将此字符串的地址放入常量池中，并返回池中对象的地址引用</li></ol></li></ol></li></ol><h4 id="3-拼接字符串"><a href="#3-拼接字符串" class="headerlink" title="3 拼接字符串"></a>3 拼接字符串</h4><ol><li>常量和常量拼接结果在常量池，原理是编译器优化</li><li>如果拼接中出现了变量，则相当于在堆中 <code>new String()</code>，结果就在堆中，原理是 <code>StringBuilder</code></li></ol><h3 id="3-java-lang-String"><a href="#3-java-lang-String" class="headerlink" title="3 java.lang.String"></a>3 <code>java.lang.String</code></h3><ol><li><p>不可变（immutable）的字符序列</p><ol><li><p>不可变性：指对字符串重新赋值，连接，替换等操作时，都不会改变原有字符串序列，就好比 3 永远是 3，”hello” 永远是 “hello”</p></li><li><p>对字符串的改变，其实是将变量指向了另一个字符串，而非改变原有字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;hello&quot;;</span><br><span class="line">s = &quot;hehe&quot;;</span><br><span class="line">// 改变了 s 的指向，而非改变字符串 &quot;hello&quot;</span><br></pre></td></tr></table></figure></li><li><p>不可变的优点：可以共享</p></li></ol></li><li><p><code>String</code> 类在<code>JDK8</code> 及之前内部定义了 <code>char[]</code> 用来存储数据，从 <code>JDK9</code> 开始：</p><ol><li>字符串全为单字节字符则使用 <code>byte[]</code> 实现，否则使用 <code>char[]</code> 实现</li><li>因为字符串实际使用的大部分字符只占一个字节，使用字符数组就占用了两个字节，浪费空间</li></ol></li></ol><h2 id="4-6-数组"><a href="#4-6-数组" class="headerlink" title="4.6 数组"></a>4.6 数组</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>数组是多个相同类型数据按一定顺序排列的集合</li><li>数组既可以存基本数据类型，也可以存引用数据类型</li><li>数组长度一旦确定，就不能修改</li><li>数组相关概念<ul><li>数组名</li><li>元素 <code>element</code>：数组中的每个数据</li><li>索引（角标/下标）<code>index</code>：从 0 开始</li><li>长度 <code>lenght</code>：数组中元素个数称为数组的元素</li></ul></li><li>数组的存储<ol><li>数组会在内存中（堆）开辟一块连续的空间，数组名引用的是这块连续空间的首地址</li><li>下标表示此元素距离首地址的偏移量</li></ol></li></ol><h3 id="2-声明数组"><a href="#2-声明数组" class="headerlink" title="2 声明数组"></a>2 声明数组</h3><h4 id="1-一维数组"><a href="#1-一维数组" class="headerlink" title="1 一维数组"></a>1 一维数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 静态初始化：数组的初始化和元素赋值同时进行</span></span><br><span class="line"><span class="comment">// 1.1</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.2</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 动态初始化：数组的初始化和元素赋值分别进行</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="2-多维数组"><a href="#2-多维数组" class="headerlink" title="2 多维数组"></a>2 多维数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 静态初始化</span></span><br><span class="line"><span class="comment">// 1.1</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">3</span>, <span class="number">6</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.2</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = &#123;&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">3</span>, <span class="number">6</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 动态初始化</span></span><br><span class="line"><span class="comment">// 2.1 二维数组中有 3 个元素（每个元素都是一维数组），每个一维数组中有 4 个元素，这种方式一维数组元素个数都一样</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.2 二维数组中有 3 个元素，没有指定一维数组中元素的个数，可以分别指定，这种方式一维数组元素个数可以不一样</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][]</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]</span><br><span class="line">arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>]</span><br></pre></td></tr></table></figure><h3 id="3-数组默认值"><a href="#3-数组默认值" class="headerlink" title="3 数组默认值"></a>3 数组默认值</h3><h4 id="1-一维数组-1"><a href="#1-一维数组-1" class="headerlink" title="1 一维数组"></a>1 一维数组</h4><table><thead><tr><th>元素类型</th><th>默认值</th></tr></thead><tbody><tr><td><code>byte short int long</code></td><td><code>0</code></td></tr><tr><td><code>char</code></td><td><code>0</code> 或 <code>\u0000</code>，并非是 <code>&#39;0&#39;</code></td></tr><tr><td><code>float double</code></td><td><code>0.0</code></td></tr><tr><td><code>boolean</code></td><td><code>false</code></td></tr><tr><td>引用类型</td><td><code>null</code></td></tr></tbody></table><h4 id="2-二维数组"><a href="#2-二维数组" class="headerlink" title="2 二维数组"></a>2 二维数组</h4><ul><li><code>int[][] arr = new int[3][4]</code><ul><li>外层初始值为内层数组元素的地址值</li><li>内层初始值为对应类型的初始值</li></ul></li><li><code>int[][] arr = new int[3][]</code><ul><li>外层初始值为 <code>null</code></li><li>内层还没有元素</li></ul></li></ul><h1 id="五-运算"><a href="#五-运算" class="headerlink" title="五 运算"></a>五 运算</h1><h2 id="5-1-运算符"><a href="#5-1-运算符" class="headerlink" title="5.1 运算符"></a>5.1 运算符</h2><h3 id="1-赋值运算符"><a href="#1-赋值运算符" class="headerlink" title="1 赋值运算符"></a>1 赋值运算符</h3><table><thead><tr><th>运算符</th><th>名称</th><th>运算式</th><th>等价于</th></tr></thead><tbody><tr><td><code>=</code></td><td>赋值</td><td><code>x = y</code></td><td><code>x = y</code></td></tr><tr><td><code>+=</code></td><td>加赋值</td><td><code>x += y</code></td><td><code>x = x + y</code></td></tr><tr><td><code>-=</code></td><td>减赋值</td><td><code>x -= y</code></td><td><code>x = x - y</code></td></tr><tr><td><code>*=</code></td><td>乘赋值</td><td><code>x *= y</code></td><td><code>x = x * y</code></td></tr><tr><td><code>/=</code></td><td>除赋值</td><td><code>x /= y</code></td><td><code>x = x / y</code></td></tr><tr><td><code>%=</code></td><td>模赋值</td><td><code>x %= y</code></td><td><code>x = x % y</code></td></tr></tbody></table><ul><li><p>支持连续赋值</p></li><li><p>在使用扩展赋值运算符（非 <code>=</code>）时，不会改变变量的数据类型，即会把结果强制转换为变量的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 ----------------------------------</span></span><br><span class="line"><span class="keyword">short</span> s = <span class="number">3</span>;</span><br><span class="line">s += <span class="number">1</span>;  <span class="comment">// 结果是 4</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">s = (<span class="keyword">short</span>)(s + <span class="number">1</span>); </span><br><span class="line"><span class="comment">// 2 ----------------------------------</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">i *= <span class="number">0.1</span>; <span class="comment">// 结果是 0</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">i = (<span class="keyword">int</span>)(i * <span class="number">0.1</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-算术运算符"><a href="#2-算术运算符" class="headerlink" title="2 算术运算符"></a>2 算术运算符</h3><table><thead><tr><th>运算符</th><th>名称</th><th>运算式</th></tr></thead><tbody><tr><td><code>+</code></td><td>加法</td><td><code>x + y</code></td></tr><tr><td><code>-</code></td><td>减法</td><td><code>x - y</code></td></tr><tr><td><code>*</code></td><td>乘法</td><td><code>x * y</code></td></tr><tr><td><code>/</code></td><td>除法</td><td><code>x / y</code></td></tr><tr><td><code>%</code></td><td>取模</td><td><code>x % y</code></td></tr><tr><td><code>++</code></td><td>自增</td><td><code>x++</code> 或 <code>++x</code></td></tr><tr><td><code>--</code></td><td>自减</td><td><code>x--</code> 或 <code>--x</code></td></tr></tbody></table><ul><li>自增和自减不会改变变量数据类型</li><li>负数的取模运算：只有被除数（左边的数）的负号才有影响</li></ul><h3 id="3-比较运算符"><a href="#3-比较运算符" class="headerlink" title="3 比较运算符"></a>3 比较运算符</h3><table><thead><tr><th>运算符</th><th>名称</th><th>运算式</th></tr></thead><tbody><tr><td><code>==</code></td><td>等于</td><td><code>x == y</code></td></tr><tr><td><code>!=</code></td><td>不等于</td><td><code>x != y</code></td></tr><tr><td><code>&gt;</code></td><td>大于</td><td><code>x &gt; y</code></td></tr><tr><td><code>&lt;</code></td><td>小于</td><td><code>x &lt; y</code></td></tr><tr><td><code>&gt;=</code></td><td>大于等于</td><td><code>x &gt;= y</code></td></tr><tr><td><code>&lt;=</code></td><td>小于等于</td><td><code>x &lt;= y</code></td></tr><tr><td><code>instanceof</code></td><td>是否是某类对象</td><td><code>obj instanceof Object</code></td></tr></tbody></table><h3 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4 逻辑运算符"></a>4 逻辑运算符</h3><table><thead><tr><th>运算符</th><th>名称</th><th>运算式</th><th>说明</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>逻辑与</td><td><code>expr1 &amp; expr2</code></td><td>有 <code>false</code> 则 <code>false</code>，且两个表达式都会计算</td></tr><tr><td><code>&amp;&amp;</code></td><td>短路与</td><td><code>expr1 &amp;&amp; expr2</code></td><td>有 <code>false</code> 则 <code>false</code>，且若前边表达式为 <code>false</code>，则不再计算后边表达式</td></tr><tr><td><code>&#124;</code></td><td>逻辑或</td><td><code>expr1 &#124; expr2</code></td><td>有 <code>true</code> 则 <code>true</code>，且两个表达式都会计算</td></tr><tr><td><code>&#124;&#124;</code></td><td>短路或</td><td><code>expr1 &#124;&#124; expr2</code></td><td>有 <code>true</code> 则 <code>true</code>，且若前边表达式为 <code>true</code>，则不再计算后边表达式</td></tr><tr><td><code>!</code></td><td>逻辑非</td><td><code>!expr</code></td><td><code>true</code> 变 <code>false</code>，<code>false</code> 变 <code>true</code></td></tr><tr><td><code>^</code></td><td>逻辑异或</td><td><code>expr1 ^ expr2</code></td><td>相同则 <code>false</code>，不同则 <code>true</code></td></tr></tbody></table><h3 id="5-位运算符"><a href="#5-位运算符" class="headerlink" title="5 位运算符"></a>5 位运算符</h3><table><thead><tr><th>运算符</th><th>名称</th><th>运算式</th><th>说明</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>按位与</td><td><code>x &amp; y</code></td><td>有 0 则 0</td></tr><tr><td><code>&#124;</code></td><td>按位或</td><td><code>x &#124; y</code></td><td>有 1 则 1</td></tr><tr><td><code>~</code></td><td>按位非</td><td><code>~x</code></td><td>1 变 0，0 变 1</td></tr><tr><td><code>^</code></td><td>按位异或</td><td><code>x ^ y</code></td><td>相同则 0，不同则 1</td></tr><tr><td><code>&lt;&lt;</code></td><td>左移</td><td><code>x &lt;&lt; y</code></td><td>舍去高位，低位补0，相当于<code>x * 2<sup>y</sup></code></td></tr><tr><td><code>&gt;&gt;</code></td><td>右移</td><td><code>x &gt;&gt; y</code></td><td>舍去低位，正数高位补 0，负数高位补 1，相当于<code>x / 2<sup>y</sup></code></td></tr><tr><td><code>&gt;&gt;&gt;</code></td><td>无符号右移</td><td><code>x &gt;&gt;&gt; y</code></td><td>舍去低位，高位补 0，相当于<code>x / 2<sup>y</sup></code></td></tr></tbody></table><h3 id="6-三元运算符"><a href="#6-三元运算符" class="headerlink" title="6 三元运算符"></a>6 三元运算符</h3><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td><code>条件表达式 ? exprIfTrue : exprIfFalse</code></td><td>最终执行的表达式必须有返回值</td></tr></tbody></table><ul><li><p>三元运算符编译时要求两个表达式是同一个类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object o = <span class="keyword">true</span> ? <span class="keyword">new</span> Integer(<span class="number">1</span>) : <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(o);</span><br><span class="line"><span class="comment">// 结果是 1.0</span></span><br><span class="line"><span class="comment">// 因为要求两个表达式类型一样，所以暗含一个类型提升</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="5-2-运算符优先级"><a href="#5-2-运算符优先级" class="headerlink" title="5.2 运算符优先级"></a>5.2 运算符优先级</h2><table><thead><tr><th>优先级</th><th>运算符</th><th>结合性</th></tr></thead><tbody><tr><td><code>1</code></td><td><code>() [] {}</code></td><td>左 → 右</td></tr><tr><td><code>2</code></td><td><code>! +(正) -(负) ~ ++ --</code></td><td>右 → 左</td></tr><tr><td><code>3</code></td><td><code>* / %</code></td><td>左 → 右</td></tr><tr><td><code>4</code></td><td><code>+(加) -(减)</code></td><td>左 → 右</td></tr><tr><td><code>5</code></td><td><code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code></td><td>左 → 右</td></tr><tr><td><code>6</code></td><td><code>&lt; &lt;= &gt; &gt;= instanceof</code></td><td>左 → 右</td></tr><tr><td><code>7</code></td><td><code>== !=</code></td><td>左 → 右</td></tr><tr><td><code>8</code></td><td><code>&amp;</code></td><td>左 → 右</td></tr><tr><td><code>9</code></td><td><code>^</code></td><td>左 → 右</td></tr><tr><td><code>10</code></td><td><code>&#124;</code></td><td>左 → 右</td></tr><tr><td><code>11</code></td><td><code>&amp;&amp;</code></td><td>左 → 右</td></tr><tr><td><code>12</code></td><td><code>&#124;&#124;</code></td><td>左 → 右</td></tr><tr><td><code>13</code></td><td><code>?:(三元)</code></td><td>右 → 左</td></tr><tr><td><code>14</code></td><td><code>= += -= *= /= ...</code></td><td>右 → 左</td></tr></tbody></table><ul><li>结合性：在几个操作符具有相同的优先级时决定先执行哪一个<ul><li><code>+=</code> 是右结合，从右到左运算，所以 <code>a += b += c</code> 等价于 <code>a += (b += c)</code></li></ul></li></ul><h1 id="六-语句"><a href="#六-语句" class="headerlink" title="六 语句"></a>六 语句</h1><h2 id="6-1-条件语句"><a href="#6-1-条件语句" class="headerlink" title="6.1 条件语句"></a>6.1 条件语句</h2><h3 id="1-if-else"><a href="#1-if-else" class="headerlink" title="1 if else"></a>1 if else</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"> statement;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition) &#123;</span><br><span class="line"> statement;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-switch"><a href="#2-switch" class="headerlink" title="2 switch"></a>2 switch</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式) &#123;</span><br><span class="line"><span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line"> code;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line"> code;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"> code;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>表达式</code><ol><li>基本类型（可以自动提升为 <code>int</code> 的）<ul><li><code>byte short char int</code></li></ul></li><li>引用数据类型<ul><li>枚举（<code>jdk5</code>） </li><li>字符串字面量（<code>jdk7</code>）</li></ul></li></ol></li><li><code>case</code><ul><li>后边必须是常量且不能相同，不能是变量</li></ul></li><li><code>default</code><ul><li>可以放到任意位置，但是总是最后当所有 <code>case</code> 都不匹配时才执行</li></ul></li><li><code>break</code><ul><li>如果省略，会出现 <code>case</code> 穿透现象，下一个 <code>case</code> 不再判断，直接执行</li><li>最后一个可以省略</li></ul></li></ol><h2 id="6-2-循环语句"><a href="#6-2-循环语句" class="headerlink" title="6.2 循环语句"></a>6.2 循环语句</h2><h3 id="1-for"><a href="#1-for" class="headerlink" title="1 for"></a>1 for</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化条件【可以有多个】; 循环条件【<span class="keyword">boolean</span>类型】; 循环迭代条件) &#123;</span><br><span class="line">循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-for-each"><a href="#2-for-each" class="headerlink" title="2 for each"></a>2 for each</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (variable: collection) &#123;</span><br><span class="line">statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-while"><a href="#3-while" class="headerlink" title="3 while"></a>3 while</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-do-while"><a href="#4-do-while" class="headerlink" title="4 do while"></a>4 do while</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">statement;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (condition)</span><br></pre></td></tr></table></figure><h2 id="6-3-中断语句"><a href="#6-3-中断语句" class="headerlink" title="6.3 中断语句"></a>6.3 中断语句</h2><table><thead><tr><th>语句</th><th>说明</th></tr></thead><tbody><tr><td><code>continue</code></td><td>用于循环：跳出当次循环，继续下一次循环</td></tr><tr><td><code>break</code></td><td>用于 <code>switch ... case</code>：结束 <code>switch</code><br>用于循环：跳出当前循环，继续下边代码</td></tr><tr><td><code>return</code></td><td>任意位置：结束</td></tr></tbody></table><ul><li><code>cntinue</code> 和 <code>break</code> 可以使用标签标记位置：<code>label:</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一 前言&quot;&gt;&lt;/a&gt;一 前言&lt;/h1&gt;&lt;h2 id=&quot;1-1-概述&quot;&gt;&lt;a href=&quot;#1-1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.1 概
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="Java" scheme="https://anyeansan.github.io/categories/CS/Java/"/>
    
    
  </entry>
  
</feed>
