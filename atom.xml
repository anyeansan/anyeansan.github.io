<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>安₃</title>
  
  <subtitle>我未成名君未嫁 可能俱是不如人</subtitle>
  <link href="/anyeansan.github.io/atom.xml" rel="self"/>
  
  <link href="https://anyeansan.github.io/"/>
  <updated>2020-11-08T13:15:48.422Z</updated>
  <id>https://anyeansan.github.io/</id>
  
  <author>
    <name>安₃</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql备份</title>
    <link href="https://anyeansan.github.io/2020/11/08/SQL/Mysql%E5%A4%87%E4%BB%BD/"/>
    <id>https://anyeansan.github.io/2020/11/08/SQL/Mysql%E5%A4%87%E4%BB%BD/</id>
    <published>2020-11-08T13:14:49.000Z</published>
    <updated>2020-11-08T13:15:48.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-备份策略"><a href="#一-备份策略" class="headerlink" title="一 备份策略"></a>一 备份策略</h1><h2 id="1-1备份策略"><a href="#1-1备份策略" class="headerlink" title="1.1备份策略"></a>1.1备份策略</h2><ol><li>全量备份<ul><li>完整备份所有数据</li></ul></li><li>增量备份<ul><li>做一次完全备份，以后每次只备份新增的数据</li></ul></li><li>差异备份<ul><li>做一次完全备份，以后每次只备份和第一次完全备份不同的数据</li></ul></li></ol><h2 id="1-2-备份周期"><a href="#1-2-备份周期" class="headerlink" title="1.2 备份周期"></a>1.2 备份周期</h2><ol><li>根据数据量</li><li>自动</li></ol><h2 id="1-3-备份类型"><a href="#1-3-备份类型" class="headerlink" title="1.3 备份类型"></a>1.3 备份类型</h2><ol><li>热备<ul><li>在数据库正常业务时,备份数据,并且能够一致性恢复（只能是innodb）</li></ul></li><li>温备<ul><li>锁表备份,只能查询不能修改（myisam）</li></ul></li><li>冷备<ul><li>关闭数据库业务,数据库没有任何变更的情况下,进行备份数据.</li></ul></li></ol><h2 id="1-4-备份工具"><a href="#1-4-备份工具" class="headerlink" title="1.4 备份工具"></a>1.4 备份工具</h2><ol><li><code>mysqldump</code></li><li><code>Xtrabackup</code><ul><li>percona 数据库默认</li></ul></li><li><code>mysqlbinlog</code></li></ol><h2 id="1-5-备份方式"><a href="#1-5-备份方式" class="headerlink" title="1.5 备份方式"></a>1.5 备份方式</h2><ol><li>逻辑（基于 SQL 语句备份）<ol><li>全备：<code>mysqldump</code></li><li>增量：<code>mysqlbinlog</code></li></ol></li><li>物理（基于磁盘数据文件备份）<ol><li>全备：<code>Xtrabackup</code></li><li>增量：<code>Xtrabackup</code></li></ol></li></ol><h1 id="二-mysqldump"><a href="#二-mysqldump" class="headerlink" title="二 mysqldump"></a>二 mysqldump</h1><h2 id="2-1-连接数据库"><a href="#2-1-连接数据库" class="headerlink" title="2.1 连接数据库"></a>2.1 连接数据库</h2><ul><li><code>mysqldupm OPTION</code><ul><li><code>OPTION</code><ul><li><code>-u</code></li><li><code>-p</code></li><li><code>-S</code></li><li><code>-h</code></li><li><code>-P</code></li></ul></li></ul></li></ul><h2 id="2-2-基础参数"><a href="#2-2-基础参数" class="headerlink" title="2.2 基础参数"></a>2.2 基础参数</h2><ol><li><code>-A</code><ul><li>全备</li></ul></li><li><code>-B db1 db2 ...</code><ul><li>备份多个数据库</li></ul></li><li><code>db t1 t2 ...</code><ul><li>备份指定数据的表</li></ul></li></ol><h2 id="2-3-特殊参数"><a href="#2-3-特殊参数" class="headerlink" title="2.3 特殊参数"></a>2.3 特殊参数</h2><ol><li><code>-R</code><ul><li>备份备份存储过程及函数</li></ul></li><li><code>-E</code><ul><li>备份事件</li></ul></li><li><code>--triggers</code><ul><li>备份触发器</li></ul></li><li><code>-F</code><ul><li>在备份开始时,刷新一个新 binlog 日志</li></ul></li><li><code>--master-data=2</code><ul><li>以注释的形式，保存备份开始时间点的 binlog 的状态信息</li></ul></li><li><code>--single-transaction</code><ol><li>不加 ，温备份，所有表都锁定</li><li>加上，对 innodb 表进行快照备份（不锁表），对非 innodb 表可以实现自动锁表功能</li></ol></li><li><code>--set-gtid-purged=auto/on/off</code></li><li><code>--max-allowed-packet=#</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-备份策略&quot;&gt;&lt;a href=&quot;#一-备份策略&quot; class=&quot;headerlink&quot; title=&quot;一 备份策略&quot;&gt;&lt;/a&gt;一 备份策略&lt;/h1&gt;&lt;h2 id=&quot;1-1备份策略&quot;&gt;&lt;a href=&quot;#1-1备份策略&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="SQL" scheme="https://anyeansan.github.io/categories/CS/SQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql日志</title>
    <link href="https://anyeansan.github.io/2020/11/08/SQL/Mysql%E6%97%A5%E5%BF%97/"/>
    <id>https://anyeansan.github.io/2020/11/08/SQL/Mysql%E6%97%A5%E5%BF%97/</id>
    <published>2020-11-08T13:14:44.000Z</published>
    <updated>2020-11-08T13:16:15.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-日志分类"><a href="#一-日志分类" class="headerlink" title="一 日志分类"></a>一 日志分类</h1><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>Error log</code></td><td>错误日志</td></tr><tr><td><code>Binary log</code></td><td>二进制日志</td></tr><tr><td><code>Slow query log</code></td><td>慢查询日志</td></tr><tr><td><code>General query log</code></td><td>常规日志</td></tr></tbody></table><h1 id="二-错误日志"><a href="#二-错误日志" class="headerlink" title="二 错误日志"></a>二 错误日志</h1><ol><li>默认开启</li><li>默认存储位置 <code>datadir/hostname.err</code></li><li><code>select @@log_error</code><ul><li>查看错误日志位置</li></ul></li><li>手动配置 <code>/etc/my.cnf</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log_error=路径</span><br></pre></td></tr></table></figure><h1 id="三-二进制日志"><a href="#三-二进制日志" class="headerlink" title="三 二进制日志"></a>三 二进制日志</h1><h2 id="3-1-作用"><a href="#3-1-作用" class="headerlink" title="3.1 作用"></a>3.1 作用</h2><ol><li>主从环境必须依赖二进制日志</li><li>备份恢复必须依赖二进制日志</li></ol><h2 id="3-2-配置"><a href="#3-2-配置" class="headerlink" title="3.2 配置"></a>3.2 配置</h2><ol><li>默认没有开启</li><li>手动配置 <code>/etc/my.cnf</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">1 server_id= </span><br><span class="line"># 服务ID号 0 ~ 65535</span><br><span class="line">2 log_bin=1</span><br><span class="line"># 开启二进制日志</span><br><span class="line">3 log_bin_basename=/目录/二进制日志文件名前缀</span><br><span class="line"># 设置存储目录及文件前缀</span><br><span class="line">4 log_bin=/目录/二进制日志文件名前缀</span><br><span class="line"># 等同于 2,3两步</span><br><span class="line">5 binlog_format=row</span><br><span class="line"># 二进制日志格式，5.7 默认配置，可以省略</span><br><span class="line">6 sync_binlog=1</span><br><span class="line"># 每次提交都立即刷写binlog到磁盘</span><br></pre></td></tr></table></figure><h2 id="3-3-二进制日志记录内容"><a href="#3-3-二进制日志记录内容" class="headerlink" title="3.3 二进制日志记录内容"></a>3.3 二进制日志记录内容</h2><h3 id="1-内容"><a href="#1-内容" class="headerlink" title="1 内容"></a>1 内容</h3><ul><li>记录了数据库所有变更类的操作日志<ol><li>DDL：原封不动的记录当前 DDL（statement 语句方式），即原样记录语句</li><li>DCL：原封不动的记录当前 DCL（statement 语句方式）</li><li>DML：只记录已经提交的事务 DML</li></ol></li></ul><h3 id="2-DML-记录模式"><a href="#2-DML-记录模式" class="headerlink" title="2 DML 记录模式"></a>2 DML 记录模式</h3><ol><li><code>statment</code><ul><li>SBR（statement based replication）模式</li><li>语句模式，原封不动的记录当前DML</li><li>可读性较高，日志量少，但是不够严谨</li></ul></li><li><code>row</code><ul><li>RBR（ROW based replication）模式</li><li>记录数据行的变化（用户看不懂，需要工具分析）</li><li>可读性很低，日志量大，足够严谨</li></ul></li><li><code>mixed</code><ul><li>MBR（mixed based replication）模式 </li><li>以上两种模式的混合</li></ul></li></ol><h2 id="3-4-二进制日记记录单元-event"><a href="#3-4-二进制日记记录单元-event" class="headerlink" title="3.4 二进制日记记录单元 event"></a>3.4 二进制日记记录单元 event</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>event 是二进制日志的最小记录单元</li><li>DDL DCL<ul><li>一个语句就是一个 event</li></ul></li><li>DML ：只记录已提交的事务<ol><li>begin 是一个 event</li><li>DML 语句的 event</li><li>commit 是一个 event</li></ol></li></ol><h3 id="2-event-组成"><a href="#2-event-组成" class="headerlink" title="2 event 组成"></a>2 event 组成</h3><ol><li>事件的开始标识：<code>position</code> 号</li><li>事件内容</li><li>事件的结束标识：<code>end_log_position</code> 号</li></ol><h2 id="3-5-二进制日志-操作"><a href="#3-5-二进制日志-操作" class="headerlink" title="3.5 二进制日志 操作"></a>3.5 二进制日志 操作</h2><h3 id="1-查看信息"><a href="#1-查看信息" class="headerlink" title="1 查看信息"></a>1 查看信息</h3><ol><li><code>show variables like &#39;%log_bin%&#39;</code><ul><li>查看二进制日志路径</li></ul></li><li><code>show binary logs</code><ul><li>查看所有二进制日志</li></ul></li><li><code>show master status</code><ul><li>查看当前使用的二进制日志</li></ul></li><li><code>show binlog events in &#39;log_name&#39; [from pos] [limit]</code><ul><li>查看二进制日志 event 信息</li></ul></li></ol><h3 id="2-查看内容-mysqlbinlog"><a href="#2-查看内容-mysqlbinlog" class="headerlink" title="2 查看内容 mysqlbinlog"></a>2 查看内容 mysqlbinlog</h3><ul><li><code>mysqlbinlog [OPTION] 日志路径</code><ul><li><code>--base64-output=decode-rows</code><ul><li>以指定格式输出</li></ul></li><li><code>-vvv</code><ul><li>更详细</li></ul></li><li><code>--start-position</code><ul><li>开始位置</li></ul></li><li><code>--stop-position</code><ul><li>结束位置</li></ul></li><li><code>-d db_name</code><ul><li>只查看指定库的日志</li></ul></li></ul></li></ul><h3 id="3-恢复"><a href="#3-恢复" class="headerlink" title="3 恢复"></a>3 恢复</h3><ol><li><code>mysqlbinlog --start-position= --stop--position= &gt;/tmp/log.sql</code><ul><li>将指定位置的二进制日志内容截取出来输出到一个文件，其实就是sql脚本，执行即可</li></ul></li><li><code>set sql_log_bin=0</code><ul><li>临时关闭二进制日志，因为恢复时也会产生二进制日志，没有必要</li></ul></li><li><code>source /tmp/log.sql</code></li><li><code>set sql_log_bin=1</code></li></ol><h2 id="3-6-GTID-模式管理二进制日志"><a href="#3-6-GTID-模式管理二进制日志" class="headerlink" title="3.6 GTID 模式管理二进制日志"></a>3.6 GTID 模式管理二进制日志</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>GTID <code>Global Transaction ID</code></li><li>对二进制日志中每一个事务，自动生成一个 GTID 号<ol><li>DDL DCL<ul><li>一个 event 就是一个事务，就有一个 GTID</li></ul></li><li>DML<ul><li>一个事务（从 begin 到 commit）一个 GTID</li></ul></li></ol></li><li>GTID 幂等性<ul><li>使用有 GTID 的二进制日志做恢复时，会检查当前系统是否有相同的 GTID，若有则跳过不再执行。</li><li>会影响恢复和主从复制</li></ul></li></ol><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2 配置"></a>2 配置</h3><ol><li>默认未开启</li><li><code>/etc/my.cnf</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">gtid-mode=on</span><br><span class="line">enforce-gtid-consistency=true</span><br></pre></td></tr></table></figure><h3 id="3-GTID-组成"><a href="#3-GTID-组成" class="headerlink" title="3 GTID 组成"></a>3 GTID 组成</h3><ul><li><code>server_uuid:transaction_id</code><ul><li><code>server_uuid</code><ul><li>启动 mysql 自动生成，存储在 <code>datadir/auto.cnf</code></li></ul></li><li><code>transaction_id</code><ul><li>从 1 开始，自增长</li></ul></li></ul></li></ul><h3 id="4-查看有-GTID-的日志内容"><a href="#4-查看有-GTID-的日志内容" class="headerlink" title="4 查看有 GTID 的日志内容"></a>4 查看有 GTID 的日志内容</h3><ul><li><code>mysqlbinlog [OPTION] 日志路径</code><ul><li><code>OPTION</code><ul><li><code>--incude-gtids</code><ul><li>包含指定 gtid，多个逗号隔开，连续可以 <code>server_uuid:1-8</code></li></ul></li><li><code>--exclude-gtids</code><ul><li>排除指定 gtid</li></ul></li><li><code>--skip-gtids</code><ul><li>由于 gtid 的幂等性，导出的 sql 执行时会报错，因为已经存在相同 gtid</li><li>此选项表示：导出时，忽略原有的 GTID 信息，恢复时当作新事务对待</li></ul></li></ul></li></ul></li></ul><h3 id="5-基于-GTID-的恢复"><a href="#5-基于-GTID-的恢复" class="headerlink" title="5  基于 GTID 的恢复"></a>5  基于 GTID 的恢复</h3><ol><li><code>mysqlbinlog --skip-gtids --include-gtids= 日志路径&gt;/tmp/log.sql</code></li><li><code>set sql_log_bin=0</code></li><li><code>source /tmp/log.sql</code></li><li><code>set sql_log_bin=1</code></li></ol><h2 id="3-7-二进制日志清理"><a href="#3-7-二进制日志清理" class="headerlink" title="3.7 二进制日志清理"></a>3.7 二进制日志清理</h2><h3 id="1-自动清理"><a href="#1-自动清理" class="headerlink" title="1 自动清理"></a>1 自动清理</h3><ul><li><code>expire_logs_days</code><ul><li>二进制日志过期天数，<code>0</code> 表示永不过期</li><li>建议至少保留两个全备周期 +1</li></ul></li></ul><h3 id="2-手动清理"><a href="#2-手动清理" class="headerlink" title="2 手动清理"></a>2 手动清理</h3><ol><li><code>purge binary logs to &#39;log_name&#39;</code><ul><li>删除指定日志之前的日志</li></ul></li><li><code>purge binary logs before &#39;time&#39;</code><ul><li>删除指定日期之前的日志</li></ul></li></ol><h2 id="3-8-日志滚动"><a href="#3-8-日志滚动" class="headerlink" title="3.8 日志滚动"></a>3.8 日志滚动</h2><ol><li><code>flush logs</code></li><li>重启 mysql 会自动滚动一个新的</li><li>日志文件达到 <code>max_binlog_size</code></li></ol><h1 id="四-慢查询日志"><a href="#四-慢查询日志" class="headerlink" title="四 慢查询日志"></a>四 慢查询日志</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ul><li>记录运行较慢的 SQL语句，优化常用</li></ul><h2 id="4-2-配置"><a href="#4-2-配置" class="headerlink" title="4.2 配置"></a>4.2 配置</h2><ol><li>默认未开启</li><li><code>/etc/my.cnf</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">1 slow_query_log=1 </span><br><span class="line"># 开启 </span><br><span class="line">2 slow_query_log_file=/目录/文件</span><br><span class="line"># 日志文件路径</span><br><span class="line">3 long_query_time=0.1</span><br><span class="line"># 设置慢查询时间，超过此时间就算慢，默认 10.000000 10秒，小数位表示粒度</span><br><span class="line">4 log_queries_not_using_indexes</span><br><span class="line"># 没走索引的语句也记录</span><br></pre></td></tr></table></figure><h2 id="4-3-分析"><a href="#4-3-分析" class="headerlink" title="4.3 分析"></a>4.3 分析</h2><ul><li><code>mysqldumpslow -s c -t N 日志路径</code><ul><li><code>-s c</code><ul><li>sort，按次数排序</li></ul></li><li><code>-t N</code><ul><li>top，取前多少个</li></ul></li></ul></li></ul><h2 id="4-4-相关参数"><a href="#4-4-相关参数" class="headerlink" title="4.4 相关参数"></a>4.4 相关参数</h2><ol><li><code>slow_query_log</code></li><li><code>long_query_time</code></li><li><code>log_throttle_queries_not_using_indexes</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-日志分类&quot;&gt;&lt;a href=&quot;#一-日志分类&quot; class=&quot;headerlink&quot; title=&quot;一 日志分类&quot;&gt;&lt;/a&gt;一 日志分类&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thea
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="SQL" scheme="https://anyeansan.github.io/categories/CS/SQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql触发器</title>
    <link href="https://anyeansan.github.io/2020/11/08/SQL/Mysql%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>https://anyeansan.github.io/2020/11/08/SQL/Mysql%E8%A7%A6%E5%8F%91%E5%99%A8/</id>
    <published>2020-11-08T13:14:39.000Z</published>
    <updated>2020-11-08T13:15:53.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol><li>事先为某张表绑定好一段代码 ,当表中的某些内容发生改变的时候（增删改）系统会自动触发代码执行</li><li>事件类型<ul><li>增 <code>insert</code></li><li>删 <code>delete</code></li><li>改 <code>update</code></li></ul></li><li>触发时间<ul><li>前 <code>before</code></li><li>后 <code>after</code></li></ul></li><li>一张表最多能有 6 种触发器（事件类型 + 触发事件）<ol><li><code>增 前/后</code></li><li><code>删 前/后</code></li><li><code>改 前/后</code></li></ol></li><li>触发对象<ul><li>表中的每一条记录（行）</li></ul></li><li><code>new/old</code><ul><li>可以用来获取新添加的或者删除的记录</li></ul></li></ol><h1 id="二-创建触发器"><a href="#二-创建触发器" class="headerlink" title="二 创建触发器"></a>二 创建触发器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 1 临时修改语句结束符</span><br><span class="line">Delimiter 自定义符号</span><br><span class="line">-- 2 </span><br><span class="line">Create trigger 触发器名字 触发时间 事件类型 on 表名 for each row</span><br><span class="line">-- 3 </span><br><span class="line">Begin</span><br><span class="line">触发器的内容</span><br><span class="line">End</span><br><span class="line">-- 4 语句结束符</span><br><span class="line">自定义符号</span><br><span class="line">-- 5 将临时修改修正过来</span><br><span class="line">Delimiter ;</span><br></pre></td></tr></table></figure><h1 id="三-触发器管理"><a href="#三-触发器管理" class="headerlink" title="三 触发器管理"></a>三 触发器管理</h1><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>show triggers</code></td><td>查看所有触发器</td></tr><tr><td><code>show create trigger 触发器名</code></td><td>查看触发器创建语句</td></tr><tr><td><code>drop trigger 触发器名</code></td><td>删除触发器</td></tr></tbody></table><ul><li><code>Information_schema.triggers</code><ul><li>所有的触发器信息都保存此表中</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;事先为某张表绑定好一段代码 ,当表中的某些内容发生改变的时候（增删改）系统会自动触发代码执行&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="SQL" scheme="https://anyeansan.github.io/categories/CS/SQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql存储过程</title>
    <link href="https://anyeansan.github.io/2020/11/08/SQL/Mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <id>https://anyeansan.github.io/2020/11/08/SQL/Mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2020-11-08T13:14:34.000Z</published>
    <updated>2020-11-08T13:15:59.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-Procedure概述"><a href="#一-Procedure概述" class="headerlink" title="一 Procedure概述"></a>一 Procedure概述</h1><ol><li>存储过程是一组为了完成特定功能的 sql 语句和流程控制语句的预编译集合，存储在数据库内，可以由应用程序调用。</li><li>存储过程的好处<ol><li>可复用</li><li>预编译：只在创建时编译一次，以后调用时不再编译，速度快</li><li>减少网络流量：存储过程存储在数据库服务器上，都在数据库服务器上运行，调用存储过程时只需要传递名称和参数即可。</li><li>安全：可防止sql注入</li></ol></li></ol><h1 id="二-存储过程和自定义函数的区别"><a href="#二-存储过程和自定义函数的区别" class="headerlink" title="二 存储过程和自定义函数的区别"></a>二 存储过程和自定义函数的区别</h1><ol><li>存储过程实现的功能更复杂，函数的针对性更强</li><li>存储过程可以返回多个值，函数只能返回一个值</li><li>存储过程一般单独执行，函数可以作为其它sql语句的组成部分。</li></ol><h1 id="三-语法"><a href="#三-语法" class="headerlink" title="三 语法"></a>三 语法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE</span><br><span class="line">[DEFINER = user]</span><br><span class="line">PROCEDURE sp_name ([proc_parameter[,...]])</span><br><span class="line">[characteristic ...]</span><br><span class="line">routine_body</span><br><span class="line"></span><br><span class="line">proc_parameter:</span><br><span class="line">    [ IN | OUT | INOUT ] param_name type</span><br></pre></td></tr></table></figure><h1 id="四-创建"><a href="#四-创建" class="headerlink" title="四 创建"></a>四 创建</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DROP PROCEDURE IF EXISTS 存储过程名;</span><br><span class="line">-- 1 修改结束符，自定义，如$$</span><br><span class="line">DELIMITER [结束标记]</span><br><span class="line">CREATE PROCEDURE 存储过程名([参数列表])</span><br><span class="line">BEGIN</span><br><span class="line">        [存储过程体(一组合法的SQL语句)]</span><br><span class="line">END [结束标记]</span><br><span class="line">-- 2 将结束符改回分号</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><ul><li>形参：参数名 参数类型<ul><li><code>in</code><ul><li>输入参数，调用存储过程时传入的值</li><li>可以省略</li></ul></li><li><code>out</code><ul><li>输出参数，可在存储过程内部被改变并返回。</li><li><code>into</code>：使用 <code>into</code> 为out参数赋值</li></ul></li><li><code>inout</code><ul><li>输入输出参数，调用存储过程时传入值，在存储过程内部可以改变并返回。</li></ul></li></ul></li><li>返回值<ul><li>存储过程可以有返回值也可以没有返回值。</li></ul></li></ul><h1 id="五-管理"><a href="#五-管理" class="headerlink" title="五 管理"></a>五 管理</h1><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>show procedure status</code></td><td>查看所有存储过程</td></tr><tr><td><code>show create procedure 存储过程名</code></td><td>查看存储过程创建语句</td></tr><tr><td><code>drop procedoure [if exists] 存储过程名</code></td><td>删除存储过程</td></tr></tbody></table><h1 id="六-调用"><a href="#六-调用" class="headerlink" title="六 调用"></a>六 调用</h1><ul><li><code>call 存储过程名(in参数, @out参数, @inout参数)</code><ol><li>存储过程没有返回值（通过out返回），不能用select调用。</li><li>实参<ol><li>in参数：直接传递即可</li><li>out参数：定义一个变量接收返回值<code>@变量名</code></li><li>inout参数：在外部定义一个变量，并设置值</li></ol></li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// in</span><br><span class="line">call inpr(3);</span><br><span class="line">// out</span><br><span class="line">call outpr(@name);</span><br><span class="line">select @name;</span><br><span class="line">// inout</span><br><span class="line">set @age = 10;</span><br><span class="line">call inoutpr(@age);</span><br><span class="line">select @age;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-Procedure概述&quot;&gt;&lt;a href=&quot;#一-Procedure概述&quot; class=&quot;headerlink&quot; title=&quot;一 Procedure概述&quot;&gt;&lt;/a&gt;一 Procedure概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;存储过程是一组为了完成特定功能的 sql
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="SQL" scheme="https://anyeansan.github.io/categories/CS/SQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql视图</title>
    <link href="https://anyeansan.github.io/2020/11/08/SQL/Mysql%E8%A7%86%E5%9B%BE/"/>
    <id>https://anyeansan.github.io/2020/11/08/SQL/Mysql%E8%A7%86%E5%9B%BE/</id>
    <published>2020-11-08T13:14:28.000Z</published>
    <updated>2020-11-08T13:16:25.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-View-概述"><a href="#一-View-概述" class="headerlink" title="一 View 概述"></a>一 View 概述</h1><ol><li>view可以看作是一张虚拟表，是表通过某种运算得到的一个投影。</li><li>视图中并没有真正存储数据。</li><li>表的改变会影响视图(视图就好像表的影子一样)</li><li>视图的改变也能影响表。(如果可以改变的话)</li><li>可以跟基本表一样，进行增删改查操作</li></ol><h1 id="二-数据操作"><a href="#二-数据操作" class="headerlink" title="二 数据操作"></a>二 数据操作</h1><ol><li>主要是用来查询</li><li>增删改操作有条件限制<ul><li>如果视图的数据与表的数据是一一对应出来的，改变不会影响其它数据，就可以增删改。</li><li>如果视图的数据是通过计算得来的，改变则会影响表中的其它数据，不可以增删改。</li></ul></li><li>可更新视图：没有以下语句<ul><li><code>distinct</code></li><li>聚合函数</li><li><code>group by / having</code></li><li><code>union</code></li></ul></li><li><code>with check option</code><ul><li>在视图的 <code>select</code> 语句后添加可以防止更新或删除已有的视图数据</li></ul></li></ol><h1 id="三-视图作用"><a href="#三-视图作用" class="headerlink" title="三 视图作用"></a>三 视图作用</h1><ol><li>方便操作，特别是查询操作，减少复杂的SQL语句<ul><li>将一条复杂的查询语句使用视图进行保存: 以后可以直接对视图进行操作</li></ul></li><li>数据安全<ul><li>视图操作是主要针对查询的, 如果对视图结构进行处理(删除), 不会影响基表数据(相对安全).</li><li>可以对外提供有用的数据, 但是隐藏关键(无用)的数据</li><li>数据库授权命令不能限定到特定行和特定列，但是通过合理创建视图，可以把权限限定到行列级别</li></ul></li><li>权限控制<ul><li>不希望用户访问表中某些含敏感信息的列,可以通过view开放某几个列</li></ul></li><li>数据过多时，分表用</li></ol><h1 id="四-视图管理"><a href="#四-视图管理" class="headerlink" title="四 视图管理"></a>四 视图管理</h1><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>create [or replace] view 视图名 as select语句</code></td><td>创建视图</td></tr><tr><td><code>show create view 视图名</code></td><td>查看视图</td></tr><tr><td><code>desc 视图名</code></td><td></td></tr><tr><td><code>drop view 视图名</code></td><td>删除视图</td></tr><tr><td><code>alter view 视图名 as 新的select语句</code></td><td>视图本身不可修改，但视图来源可以修改</td></tr></tbody></table><ul><li>视图是一张虚拟表，表的所有查看方式，视图都能用，且视图比表多一个关键字 <code>view</code> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-View-概述&quot;&gt;&lt;a href=&quot;#一-View-概述&quot; class=&quot;headerlink&quot; title=&quot;一 View 概述&quot;&gt;&lt;/a&gt;一 View 概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;view可以看作是一张虚拟表，是表通过某种运算得到的一个投影。&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="SQL" scheme="https://anyeansan.github.io/categories/CS/SQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql索引</title>
    <link href="https://anyeansan.github.io/2020/11/08/SQL/Mysql%E7%B4%A2%E5%BC%95/"/>
    <id>https://anyeansan.github.io/2020/11/08/SQL/Mysql%E7%B4%A2%E5%BC%95/</id>
    <published>2020-11-08T13:14:23.000Z</published>
    <updated>2020-11-08T13:16:30.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol><li>系统根据某种算法，将已有的数据（或未来可能新增的数据）单独建立一个文件，此文件能够实现快速的匹配数据，并且能够快速的找到对应表中的记录</li><li>几乎所有的索引都是建立在字段之上</li><li>索引本身会产生索引文件(有时候有可能比数据文件还大)，会占用磁盘空间.</li><li>索引类似书或字典前边的目录，提升查询速度，但是增删改时，索引也要动态的维护，降低了效率。</li><li>索引是在存储引擎中实现的，也就是说不同的存储引擎，会使用不同算法的索引<ol><li><code>B-tree</code></li><li><code>FullText</code></li><li><code>Hash</code></li><li><code>GIS</code></li><li><code>R-tree</code></li></ol></li></ol><h1 id="二-作用"><a href="#二-作用" class="headerlink" title="二 作用"></a>二 作用</h1><ol><li>优化查询<ul><li>如果某个字段需要作为查询的条件经常使用，那么可以使用索引</li></ul></li><li>约束数据的有效性<ul><li>如果某个字段需要进行数据的有效性约束, 也可能使用索引（主键,唯一键 …）</li></ul></li></ol><h1 id="三-索引分类"><a href="#三-索引分类" class="headerlink" title="三 索引分类"></a>三 索引分类</h1><ol><li>普通索引 <code>MUL</code><ol><li>单列索引</li><li>多列索引（联合索引）</li><li>前缀索引（建索引时，可以只索引列的一部分内容）</li></ol></li><li>唯一索引 <code>UNI</code></li><li>主键索引 <code>PRI</code>（也叫聚合索引，MySql 会自动将主键索引添加到所有从属索引中）</li><li>全文索引</li></ol><h1 id="四-索引管理"><a href="#四-索引管理" class="headerlink" title="四 索引管理"></a>四 索引管理</h1><h2 id="4-1-查"><a href="#4-1-查" class="headerlink" title="4.1 查"></a>4.1 查</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>desc 表名</code></td><td>通过表结构可以查看索引</td></tr><tr><td><code>show index in/from 表名</code></td><td>查看索引详细信息</td></tr></tbody></table><h2 id="4-2-增"><a href="#4-2-增" class="headerlink" title="4.2 增"></a>4.2 增</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>alter table 表名 add index 索引名(字段列表)</code></td><td>添加普通索引</td></tr><tr><td><code>create index 索引名 on 表名(字段列表)</code></td><td>添加普通索引</td></tr><tr><td><code>alter table 表名 add unique index 索引名(字段列表)</code></td><td>添加唯一索引</td></tr><tr><td><code>create unique index 索引名 on 表名(字段列表)</code></td><td>添加唯一索引</td></tr><tr><td><code>alter table 表名 add primary key(字段列表)</code></td><td>添加主键索引</td></tr></tbody></table><h2 id="4-3-删"><a href="#4-3-删" class="headerlink" title="4.3 删"></a>4.3 删</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>alter table 表名 drop index 索引名</code></td><td>删除索引</td></tr><tr><td><code>drop index 索引名 on 表名</code></td><td>删除索引</td></tr></tbody></table><h1 id="五-执行计划"><a href="#五-执行计划" class="headerlink" title="五 执行计划"></a>五 执行计划</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol><li>SQL 层解析器会生成多个执行计划，优化器会选择最优的执行计划</li><li>执行计划分析<ul><li>就是在执行前获取这个最优执行计划，查看其计划信息，可以有效的防止性能较差的语句带来的性能问题</li></ul></li></ol><h2 id="5-2-获取执行计划"><a href="#5-2-获取执行计划" class="headerlink" title="5.2 获取执行计划"></a>5.2 获取执行计划</h2><ol><li><code>desc sql语句</code></li><li><code>explain sql语句</code></li></ol><h2 id="5-3-执行计划分析"><a href="#5-3-执行计划分析" class="headerlink" title="5.3 执行计划分析"></a>5.3 执行计划分析</h2><ol><li><code>table</code><ul><li>查询所操作的表</li></ul></li><li><code>type</code><ol><li>全表扫描：<code>all</code><ul><li>不走索引<ol><li>没有查询条件，或者查询条件列无索引</li><li>查询结构集是原表中的大部分数据，一般25%以上</li><li><code>! not</code><ul><li>普通索引列</li></ul></li><li><code>like %xxx</code></li><li>联合索引有时只走部分索引</li></ol></li></ul></li><li>索引扫描（性能依次变好）<ol><li><code>index</code><ul><li>全索引扫描<ul><li>无条件查询索引列 <code>select id from t</code></li></ul></li></ul></li><li><code>range</code><ul><li>索引范围扫描<ol><li><code>&gt; &gt;= &lt; &lt;= between and or in()</code></li><li><code>like xxx%</code></li><li><code>! not</code><ul><li>主键索引或唯一索引列</li></ul></li></ol></li></ul></li><li><code>ref</code><ul><li>普通索引列的等值查询</li></ul></li><li><code>eq_ref</code><ul><li>在多表连接时，子表（被连接表）使用主键列或者唯一列作为连接条件</li></ul></li><li><code>consist(system)</code><ul><li>主键索引或唯一索引列的等值查询</li></ul></li><li><code>null</code></li></ol></li></ol></li><li><code>possible_key</code><ul><li>可能会用到的索引</li></ul></li><li><code>key</code><ul><li>真正使用的索引</li></ul></li><li><code>key_len</code><ul><li>索引最大预留长度</li></ul></li><li><code>extra</code><ul><li><code>using filesort</code><ul><li>说明查询中有关排序的条件列没有合理的应用索引，因为索引本身已经是有序的</li></ul></li></ul></li><li><code>rows</code><ul><li>扫描行数</li></ul></li></ol><h1 id="六-联合索引"><a href="#六-联合索引" class="headerlink" title="六 联合索引"></a>六 联合索引</h1><h2 id="6-1-联合索引说明"><a href="#6-1-联合索引说明" class="headerlink" title="6.1 联合索引说明"></a>6.1 联合索引说明</h2><ul><li>优化器会自动对查询条件按照索引创建时的顺序排序<ol><li>最终使用的索引列是排序后连续的等值比较查询</li><li>也就是说碰到不连续的或者非等值比较查询（&gt; &gt;= &lt; &lt;= like …）就会停止</li></ol></li><li>例：创建联合索引 <code>inx_haha(a,b,c,d)</code><ol><li>查询条件是 <code>b= c= a= d=</code>，排序后 <code>a= b= c= d=</code>，最终使用的索引列 <code>abcd</code></li><li>查询条件是 <code>b= a= d=</code>，排序后 <code>a= b= d=</code>，最终使用的索引列 <code>ab</code></li><li>查询条件是 <code>c= a= d=</code>，排序后 <code>a= c= d=</code>，最终使用的索引列 <code>a</code></li><li>查询条件是 <code>b&gt; a= c= d=</code>，排序后 <code>a= b&gt; c= d=</code>，最终使用的索引列 <code>ab</code></li></ol></li></ul><h2 id="6-2-联合索引优化"><a href="#6-2-联合索引优化" class="headerlink" title="6.2 联合索引优化"></a>6.2 联合索引优化</h2><ol><li>创建联合索引时唯一键多的列放在最左侧</li><li>创建联合索引时等值比较的列放在最左侧</li><li>如果查询中出现多种子句（where group by …），要按照子句的执行顺序建立索引</li></ol><h1 id="七-索引应用规范"><a href="#七-索引应用规范" class="headerlink" title="七 索引应用规范"></a>七 索引应用规范</h1><ol><li>建表必须有主键，一般是个无关列，自增值</li><li>经常需要where 、ORDER BY、GROUP BY,join on等操作的列建立索引，</li><li>值长度较长的列，建议使用前缀索引</li><li>索引不是越多越好，不要创建无用索引，不常使用的索引要清理</li><li>索引维护避开业务繁忙期</li><li>小表不建索引</li><li>联合索引优化</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;系统根据某种算法，将已有的数据（或未来可能新增的数据）单独建立一个文件，此文件能够实现快速的匹配数据，并且能够快
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="SQL" scheme="https://anyeansan.github.io/categories/CS/SQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql事务</title>
    <link href="https://anyeansan.github.io/2020/11/08/SQL/Mysql%E4%BA%8B%E5%8A%A1/"/>
    <id>https://anyeansan.github.io/2020/11/08/SQL/Mysql%E4%BA%8B%E5%8A%A1/</id>
    <published>2020-11-08T13:14:18.000Z</published>
    <updated>2020-11-08T13:16:21.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-ACID-特性"><a href="#一-ACID-特性" class="headerlink" title="一 ACID 特性"></a>一 ACID 特性</h1><table><thead><tr><th>特性</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><code>Atomicity</code></td><td>原子性</td><td>一个事务是一个不可分割的单元，事务中的操作要么都成功，要么都取消</td></tr><tr><td><code>Consistency</code></td><td>一致性</td><td>事务的执行不能破坏数据库数据的完整性和一致性</td></tr><tr><td><code>Isolation</code></td><td>隔离性</td><td>事务之间是互不干扰的</td></tr><tr><td><code>Durability</code></td><td>持久性</td><td>一个事务一旦被提交，它对数据库中数据的改变就是永久性的</td></tr></tbody></table><h1 id="二-事务的生命周期"><a href="#二-事务的生命周期" class="headerlink" title="二 事务的生命周期"></a>二 事务的生命周期</h1><h2 id="2-1-标准生命周期"><a href="#2-1-标准生命周期" class="headerlink" title="2.1 标准生命周期"></a>2.1 标准生命周期</h2><table><thead><tr><th>阶段</th><th>说明</th></tr></thead><tbody><tr><td><code>begin &#124; start transction &#124; set autocommit=0</code></td><td>开启事务</td></tr><tr><td><code>DML（insert update delete）</code></td><td>数据操作</td></tr><tr><td><code>commit &#124; rollback</code></td><td>结束事务</td></tr></tbody></table><ul><li>注意：开启事务后，在事务中执行一些语句会触发隐式提交（应避免）<ol><li>DDL（<code>alte</code> <code>create</code> <code>drop</code> <code>truncate</code>）</li><li>DCL（<code>grant</code> <code>revoke</code> <code>set password</code>）</li><li>锁（<code>lock tables</code> <code>unlock tables</code>）</li><li>…</li></ol></li></ul><h2 id="2-2-自动提交（atutocommit）"><a href="#2-2-自动提交（atutocommit）" class="headerlink" title="2.2 自动提交（atutocommit）"></a>2.2 自动提交（atutocommit）</h2><ol><li>默认 <code>atutocommit = 1</code> 即开启自动提交，执行 <code>DML</code> 时会自动开启事务并提交</li><li>关闭自动提交<ol><li><code>set autocommit = 0</code><ul><li>会话级别</li></ul></li><li><code>set global autocommit = 0</code><ul><li>全局级别，影响所有会话，重启失效</li></ul></li><li><code>vim /etc/my.cnf</code> 中添加 <code>autocommit=0</code><ul><li>永久生效</li></ul></li></ol></li></ol><h1 id="三-隔离级别"><a href="#三-隔离级别" class="headerlink" title="三 隔离级别"></a>三 隔离级别</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol><li>对于同时运行的多个事务（多线程并发）, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题</li><li>问题的本质就是线程安全问题，共享数据的问题</li></ol><h2 id="3-2-问题"><a href="#3-2-问题" class="headerlink" title="3.2 问题"></a>3.2 问题</h2><table><thead><tr><th>问题</th><th>说明</th></tr></thead><tbody><tr><td>脏读</td><td>事务 T1 读取到了事务 T2 未提交的数据，如果 T2 回滚，那么 T1 读取到的数据是临时且无效的</td></tr><tr><td>不可重复读</td><td>事务 T1 读取到了事务 T2 已提交的数据（update），导致 T1 多次读取同一个字段但是结果不同</td></tr><tr><td>幻读</td><td>事务 T1 读取到了事务 T2 已提交的数据（insert / delete），导致 T1 多次读取同一张表，但记录数不同</td></tr></tbody></table><h2 id="3-3-隔离级别分类"><a href="#3-3-隔离级别分类" class="headerlink" title="3.3 隔离级别分类"></a>3.3 隔离级别分类</h2><table><thead><tr><th>隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td><code>read uncommitted</code></td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td><code>read committed</code></td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td><code>repeatable read</code></td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td><code>serializable</code></td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><ul><li><code>repeatable read</code><ul><li>是 MySQl 默认 隔离级别，Mysql 5.0 之后此级别也可以避免幻读?</li></ul></li></ul><h2 id="3-4-隔离级别管理"><a href="#3-4-隔离级别管理" class="headerlink" title="3.4 隔离级别管理"></a>3.4 隔离级别管理</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>select @@tx_isolation</code></td><td>查看会话隔离级别</td></tr><tr><td><code>set tx_isolation=隔离级别</code></td><td>设置会话隔离级别，必须在开启事务之前</td></tr><tr><td><code>set [global/session] transaction isolation level 隔离级别</code></td><td>设置下次事务的隔离级别</td></tr><tr><td><code>tx_isolation=隔离级别</code></td><td>在 <code>/etc/my.cnf</code> 中添加，永久设置</td></tr></tbody></table><h1 id="四-锁"><a href="#四-锁" class="headerlink" title="四 锁"></a>四 锁</h1><h2 id="4-1-悲观锁"><a href="#4-1-悲观锁" class="headerlink" title="4.1 悲观锁"></a>4.1 悲观锁</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>数据库提供实现</li><li>悲观的认为别人一定会修改我使用的数据，我就未为我使用的数据加锁，防止别人修改</li></ol><h3 id="2-锁粒度划分"><a href="#2-锁粒度划分" class="headerlink" title="2 锁粒度划分"></a>2 锁粒度划分</h3><ol><li>表锁<ul><li>开销小，加锁快；不会出现死锁；但锁粒度大，锁冲突概率高，并发度低</li></ul></li><li>行锁<ul><li>开销大，加锁慢；会出现死锁；锁定粒度小，锁冲突概率低，并发度高。</li></ul></li></ol><h3 id="3-锁机制划分"><a href="#3-锁机制划分" class="headerlink" title="3 锁机制划分"></a>3 锁机制划分</h3><ol><li>读锁/共享锁<ul><li>其他事务可以读，但不能写</li></ul></li><li>写锁/排他锁<ul><li>其他事务不能读取，也不能写</li></ul></li></ol><h2 id="4-2-乐观锁"><a href="#4-2-乐观锁" class="headerlink" title="4.2 乐观锁"></a>4.2 乐观锁</h2><ol><li>需要自己实现</li><li>乐观的认为数据一般是不会造成冲突的。只有在提交数据的时候，才会对数据的冲突进行检测</li><li>类似与 版本控制（git / svn），会有一个版本号，在提交时会对比版本号，如果冲突则不能提交。</li><li>例：<ul><li><code>id=1 money=100 version=1</code>甲乙同时操作money-10</li><li>甲先提交<code>id=1 money=90 version=2</code>提交成功。</li><li>乙后提交<code>id=1 money=90 version=2</code>提交失败</li><li>乙需要从新查询，然后修改提交<code>id=1 money=80 version=3</code></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-ACID-特性&quot;&gt;&lt;a href=&quot;#一-ACID-特性&quot; class=&quot;headerlink&quot; title=&quot;一 ACID 特性&quot;&gt;&lt;/a&gt;一 ACID 特性&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;

      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="SQL" scheme="https://anyeansan.github.io/categories/CS/SQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql语句</title>
    <link href="https://anyeansan.github.io/2020/11/08/SQL/Mysql%E8%AF%AD%E5%8F%A5/"/>
    <id>https://anyeansan.github.io/2020/11/08/SQL/Mysql%E8%AF%AD%E5%8F%A5/</id>
    <published>2020-11-08T13:14:13.000Z</published>
    <updated>2020-11-08T13:16:42.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-SQL（Structure-Query-Language）"><a href="#1-1-SQL（Structure-Query-Language）" class="headerlink" title="1.1 SQL（Structure Query Language）"></a>1.1 SQL（Structure Query Language）</h2><ol><li>结构化查询语言，关系型数据库通用命令</li><li>遵循SQL92标准</li><li>注释<ol><li><code>-- 单行注释</code></li><li><code>#单行注释</code>（mysql 特有）</li><li><code>/* 多行注释 */</code></li></ol></li></ol><h2 id="1-2-严格模式（SQL-MODE）"><a href="#1-2-严格模式（SQL-MODE）" class="headerlink" title="1.2 严格模式（SQL_MODE）"></a>1.2 严格模式（SQL_MODE）</h2><ol><li><code>set sql_mode = &#39;traditional&#39;</code><ul><li>设置严格模式（默认）</li></ul></li><li><code>set sql_mode = &#39;&#39;</code><ul><li>关闭严格模式</li></ul></li></ol><h2 id="1-3-规范"><a href="#1-3-规范" class="headerlink" title="1.3 规范"></a>1.3 规范</h2><h3 id="1-SQL-规范"><a href="#1-SQL-规范" class="headerlink" title="1 SQL 规范"></a>1 SQL 规范</h3><ol><li>SQL 语句不区分大小写，关键字和函数名建议大写</li><li>值：除了数值类型外都使用单引号 <code>&#39;&#39;</code></li><li>别名建议使用双引号 <code>&quot;&quot;</code>，且不省略 <code>as</code> 关键字</li><li>数据库必须设置字符集，表必须设置字符集和存储引擎</li><li>列选择合适的数据类型及长度，且要有注释</li><li>每列设置 <code>NOT NULL + DEFAULT</code><ol><li>数值默认为 <code>0</code> 或其它有效数字</li><li>字符串默认为空格字符串 <code>&#39; &#39;</code> 或其它有效字符串</li></ol></li><li>enum 类型不要用于数值，只能用于字符串</li><li>主键列最好是无关数值列，且自增长</li></ol><h3 id="2-命名规范"><a href="#2-命名规范" class="headerlink" title="2 命名规范"></a>2 命名规范</h3><ol><li>库名和表名小写，只能使用 <code>A-Z a-z 0-9</code>，不能以数字开头</li><li>不能使用关键字和保留字</li></ol><h2 id="1-4-SQL-常用分类"><a href="#1-4-SQL-常用分类" class="headerlink" title="1.4 SQL 常用分类"></a>1.4 SQL 常用分类</h2><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>DDL（Data Definition Language）</code></td><td>数据定义语言，如 <code>create alter drop truncate</code></td></tr><tr><td><code>DML（Data Manipulation Language）</code></td><td>数据操作语言，如 <code>insert delete update</code></td></tr><tr><td><code>DQL（Data Query Language）</code></td><td>数据查询语言，如 <code>select show</code></td></tr><tr><td><code>DCL（Data Control Language）</code></td><td>数据控制语言，如 <code>grant revoke</code></td></tr></tbody></table><h1 id="二-库"><a href="#二-库" class="headerlink" title="二 库"></a>二 库</h1><h2 id="2-1-查"><a href="#2-1-查" class="headerlink" title="2.1 查"></a>2.1 查</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>show databases</code></td><td>查看所有库</td></tr><tr><td><code>use 库名</code></td><td>使用指定数据库</td></tr><tr><td><code>select database()</code></td><td>查看正在使用的数据库</td></tr><tr><td><code>show create database db_name</code></td><td>查看建库语句</td></tr><tr><td><code>show variables like &#39;character_set_database&#39;</code></td><td>查看当前数据库字符集</td></tr><tr><td><code>show variables like &#39;collation_database&#39;</code></td><td>查看当前数据库校对集</td></tr></tbody></table><h2 id="2-2-增"><a href="#2-2-增" class="headerlink" title="2.2 增"></a>2.2 增</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database [if not exists] 库名 [default character set 字符集 collate 校对集]</span><br></pre></td></tr></table></figure><ul><li><code>character set</code> 都可以简写为 <code>charset</code></li></ul><h2 id="2-3-删"><a href="#2-3-删" class="headerlink" title="2.3 删"></a>2.3 删</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database [if exists] 库名</span><br></pre></td></tr></table></figure><h2 id="2-4-改"><a href="#2-4-改" class="headerlink" title="2.4 改"></a>2.4 改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database 库名 [charset 字符集 collate 校对集]</span><br></pre></td></tr></table></figure><ol><li>库名不可修改</li><li>只能修改库属性（字符集和校对集）</li></ol><h1 id="三-表"><a href="#三-表" class="headerlink" title="三 表"></a>三 表</h1><h2 id="3-1-查"><a href="#3-1-查" class="headerlink" title="3.1 查"></a>3.1 查</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>show tables [from 库名]</code></td><td>查看库（默认为当前库）中的所有表</td></tr><tr><td><code>show create table 表名</code></td><td>查看建表语句</td></tr><tr><td><code>desc 表名</code></td><td>查看表结构</td></tr></tbody></table><h2 id="3-2-增"><a href="#3-2-增" class="headerlink" title="3.2 增"></a>3.2 增</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 1 </span><br><span class="line">create table [if not exists] 表名(</span><br><span class="line">列名 列属性,</span><br><span class="line">......</span><br><span class="line">列名 列属性</span><br><span class="line">)[engine=INNODB character set 字符集 collate 校对集]</span><br><span class="line"></span><br><span class="line">// 2 根据已有表结构创建新表</span><br><span class="line">create table 新表名 like 旧表名</span><br><span class="line"></span><br><span class="line">// 3 根据已有表创建新表并添加数据</span><br><span class="line">create table 新表名 AS 子查询</span><br></pre></td></tr></table></figure><h2 id="3-3-删"><a href="#3-3-删" class="headerlink" title="3.3 删"></a>3.3 删</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table [if exists] 表名</span><br></pre></td></tr></table></figure><h2 id="3-4-改"><a href="#3-4-改" class="headerlink" title="3.4 改"></a>3.4 改</h2><h3 id="1-表信息（表名-表属性）"><a href="#1-表信息（表名-表属性）" class="headerlink" title="1 表信息（表名 表属性）"></a>1 表信息（表名 表属性）</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>rename table 表名 to 新表名</code></td><td>修改表名</td></tr><tr><td><code>alter table 表名 rename 新表名</code></td><td>修改表名</td></tr><tr><td><code>alter table 表名 表属性</code></td><td>修改表属性</td></tr></tbody></table><h3 id="2-表结构（列信息）"><a href="#2-表结构（列信息）" class="headerlink" title="2 表结构（列信息）"></a>2 表结构（列信息）</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>alter table 表名 add [column] 列名 列属性 [位置]</code></td><td>默认在最后添加一列，可指定位置：<code>first</code> 或 <code>after 某列</code></td></tr><tr><td><code>alter table 表名 add [column] (列名 列属性, ...)</code></td><td>在最后添加多列</td></tr><tr><td><code>alter table 表名 drop [column] 列名</code></td><td>删除列</td></tr><tr><td><code>alter table 表名 modify 列名 列属性</code></td><td>修改列属性</td></tr><tr><td><code>alter table 表名 change 列名 新列名 列属性</code></td><td>修改列名和列属性</td></tr></tbody></table><h1 id="四-数据"><a href="#四-数据" class="headerlink" title="四 数据"></a>四 数据</h1><h2 id="4-1-增删改"><a href="#4-1-增删改" class="headerlink" title="4.1 增删改"></a>4.1 增删改</h2><h3 id="1-insert"><a href="#1-insert" class="headerlink" title="1 insert"></a>1 insert</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>insert [into] 表名 values(值列表)[, (值列表)]</code></td><td>向表所有列插入 1 或多条记录，列与值一一对应</td></tr><tr><td><code>insert [into] 表名(字段列表) values(值列表)[, (值列表)]</code></td><td>向表指定列插入 1 或多条记录，列与值一一对应</td></tr><tr><td><code>insert [into] 表名 set 列=值, ...</code></td><td>向表指定列插入 1 条记录，值可以使用子查询</td></tr></tbody></table><h3 id="2-update"><a href="#2-update" class="headerlink" title="2 update"></a>2 update</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>update 表名 set 列=值 [where 子句]</code></td><td>不加条件会更新所有行</td></tr></tbody></table><h3 id="3-delete"><a href="#3-delete" class="headerlink" title="3 delete"></a>3 delete</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>delete from 表名 [where 子句]</code></td><td>不加条件会删除所有行</td></tr><tr><td><code>truncate [table] 表名</code></td><td>清空表</td></tr></tbody></table><ul><li>truncate 和 delete 区别<ul><li>DELETE <ol><li>DML 操作，是逻辑性质删除，逐行删除速度慢</li><li>删除表中的数据，表结构还在，删除后的数据可以找回</li><li>自增长不会重置</li></ol></li><li>TRUNCATE <ol><li>DDL 操作，对表段中的数据页进行清空，速度快</li><li>相当于把表扔了又创建一个同样表结构的新表</li><li>自增长会重置</li></ol></li></ul></li></ul><h2 id="4-2-查"><a href="#4-2-查" class="headerlink" title="4.2 查"></a>4.2 查</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">select [选项] 表达式 [as 列别名] [, [选项] 表达式 [as 列别名], ...]</span><br><span class="line">[</span><br><span class="line">from 数据源 [as 表别名]</span><br><span class="line">[where 子句]</span><br><span class="line">[group by 子句]</span><br><span class="line">[having 子句]</span><br><span class="line">[order by 子句]</span><br><span class="line">[limit 子句]</span><br><span class="line">]</span><br><span class="line">[union | union all]</span><br><span class="line">select ...</span><br><span class="line"></span><br><span class="line">// 查询过程</span><br><span class="line">1. from</span><br><span class="line">   - 确定数据源</span><br><span class="line">2. where</span><br><span class="line">   - 从原表中筛选出符合条件的数据形成一个概念中的临时结果集，存入内存</span><br><span class="line">3. group by</span><br><span class="line">   - 按照指定列进行分组</span><br><span class="line">4. select</span><br><span class="line">   - 处理表达式（函数, 别名, 运算 ...），形成结果集</span><br><span class="line">5. having</span><br><span class="line">   - 对结果集进行过滤</span><br><span class="line">6. order by</span><br><span class="line">   - 对过滤后的结果集进行排序</span><br><span class="line">7. limit</span><br><span class="line">   - 对排序后的结果集进行条目限制，形成最终结果集</span><br></pre></td></tr></table></figure><h3 id="1-select-子句"><a href="#1-select-子句" class="headerlink" title="1 select 子句"></a>1 select 子句</h3><ol><li>选项<ul><li><code>all</code>：保留所有结果（默认）</li><li><code>distinct</code>：去除重复</li><li><code>distinct row</code></li><li><code>top</code></li></ul></li><li>表达式<ul><li>每一个表达式代表一列，可以是列名，*，变量，函数，…</li></ul></li><li>别名<ul><li>表别名可用于全局</li><li>列别名可用于 <code>having</code> 和 <code>order by</code> </li></ul></li></ol><h3 id="2-from-子句"><a href="#2-from-子句" class="headerlink" title="2 from 子句"></a>2 from 子句</h3><ul><li>本质上只要数据类似二维表，都可以作为数据源<ol><li>单表数据源</li><li>多表数据源</li><li>查询语句</li></ol></li></ul><h3 id="3-where-子句"><a href="#3-where-子句" class="headerlink" title="3 where 子句"></a>3 where 子句</h3><ol><li>从原表中的记录中进行筛选</li><li>where 是直接对表中数据进行判断，所以只能使用表中的列，且不能使用别名</li></ol><h3 id="4-group-by-子句"><a href="#4-group-by-子句" class="headerlink" title="4 group by 子句"></a>4 group by 子句</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h4><ol><li>通常配合聚合函数使用</li><li>可以有多个分组列，以逗号分隔</li><li>select 中可以查询的列：<ol><li>分组的列</li><li>聚合函数的列</li><li>与分组列一对一的列（不报错，但不推荐）</li></ol></li></ol><h4 id="2-group-by-原理"><a href="#2-group-by-原理" class="headerlink" title="2 group by 原理"></a>2 group by 原理</h4><ol><li>先按照分组列排序、去重，形成一张虚拟表</li><li>虚拟表的结构：分组列与其它列的对应关系<ol><li>分组列一对一的列可以直接查询（即与分组列对应的列只有一行记录）</li><li>分组列一对多的列不能直接查询（即与分组列对应的列有多行记录）<ol><li>使用聚合函数将多行记录统计为一行记录</li><li>使用 <code>group_concat()</code> 将多行记录合并连接为一行记录</li></ol></li></ol></li></ol><h4 id="3-聚合函数"><a href="#3-聚合函数" class="headerlink" title="3 聚合函数"></a>3 聚合函数</h4><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>max([distinct] expr)</code></td><td>返回 expr 最大值</td></tr><tr><td><code>min([distinct] expr)</code></td><td>返回 expr 最小值</td></tr><tr><td><code>count([distinct] expr)</code></td><td>返回 expr 记录总数</td></tr><tr><td><code>sum([distinct] expr)</code></td><td>返回 expr 总和</td></tr><tr><td><code>avg([distinct] expr)</code></td><td>返回 expr 平均值</td></tr><tr><td><code>group_concat()</code></td><td>将group by产生的同一个分组中的其它列的所有值连接成一个字符串（多行记录变一行）</td></tr></tbody></table><ul><li><code>count()</code><ol><li><code>count(*)</code> 和 <code>count(常量)</code><ul><li>记录总数（包含空行）</li><li>此类参数表示数数，有一行记录总数就+1，也就是说总数与记录内容无关</li><li><code>count(*)</code> 效率底不建议</li></ul></li><li><code>count(列名)</code><ul><li>记录总数（不包含空行）</li></ul></li></ol></li></ul><h4 id="4-with-rollup"><a href="#4-with-rollup" class="headerlink" title="4 with rollup"></a>4 with rollup</h4><ul><li>分组后跟 <code>with rollup</code> 会对分组进行统计</li><li>只有 mysql 支持</li></ul><h3 id="5-having-子句"><a href="#5-having-子句" class="headerlink" title="5 having 子句"></a>5 having 子句</h3><ul><li>having 是对其之前子句筛选出的数据进行条件过滤</li></ul><h3 id="6-order-by子句"><a href="#6-order-by子句" class="headerlink" title="6 order by子句"></a>6 order by子句</h3><table><thead><tr><th>语句</th><th>说明</th></tr></thead><tbody><tr><td><code>asc</code></td><td>升序（默认）</td></tr><tr><td><code>desc</code></td><td>降序</td></tr></tbody></table><ol><li>排序依赖校对集</li><li>可以有多个排序条件，前一个条件结果相同则比较下一个条件</li></ol><h3 id="7-limit-子句"><a href="#7-limit-子句" class="headerlink" title="7 limit 子句"></a>7 limit 子句</h3><table><thead><tr><th>语句</th><th>说明</th></tr></thead><tbody><tr><td><code>limit [startIndex, ]length</code></td><td>从指定索引（若省略，默认为 0）开始，取 <code>length</code> 条数据</td></tr><tr><td><code>limit length offset startIndex</code></td><td>同上，也可以把索引理解为偏移量（即跳过 <code>startIndex</code> 个）</td></tr></tbody></table><h3 id="8-union-amp-union-all"><a href="#8-union-amp-union-all" class="headerlink" title="8 union &amp; union all"></a>8 union &amp; union all</h3><table><thead><tr><th>语句</th><th>说明</th></tr></thead><tbody><tr><td><code>union all</code></td><td>合并多个查询结果集，保留所有</td></tr><tr><td><code>union</code></td><td>合并多个查询结果集，去除重复</td></tr></tbody></table><ul><li>要合并的查询结果列数必须相同，合并后结果集的列名取决于第一个要合并的查询</li><li>一般情况下,会将 <code>in()</code> 或者 <code>OR</code> 语句 改写成 <code>UNION ALL</code> ，来提高性能</li></ul><h1 id="五-关联查询（SQL-JOIN）"><a href="#五-关联查询（SQL-JOIN）" class="headerlink" title="五 关联查询（SQL JOIN）"></a>五 关联查询（SQL JOIN）</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><h3 id="1-关联查询结果"><a href="#1-关联查询结果" class="headerlink" title="1 关联查询结果"></a>1 关联查询结果</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/SQL/sql-join.png" alt=""></p><ol><li>关联查询有七种结果（行/记录）</li><li>关联查询的列都是两表组合在一起，即 A 表的列 + B 表的列</li></ol><h3 id="2-关联查询分类"><a href="#2-关联查询分类" class="headerlink" title="2 关联查询分类"></a>2 关联查询分类</h3><table><thead><tr><th>类型</th><th>名称</th><th>查询结果</th></tr></thead><tbody><tr><td><code>inner/cross join</code></td><td>内连接</td><td><code>A ∩ B</code></td></tr><tr><td><code>left [outer] join</code></td><td>左外连接</td><td><code>A</code>，<code>A - A ∩ B</code></td></tr><tr><td><code>right [outer] join</code></td><td>右外连接</td><td><code>B</code>，<code>B - A ∩ B</code></td></tr><tr><td><code>full [outer] join</code></td><td>全外连接</td><td><code>A ∪ B</code>，<code>A ∪ B - A ∩ B</code></td></tr></tbody></table><ol><li>如果连接的表是同一张表，又称为<strong>自连接</strong></li><li>mysql 不支持全外连接，可通过 <code>union</code> 实现</li></ol><h2 id="5-2-语法"><a href="#5-2-语法" class="headerlink" title="5.2 语法"></a>5.2 语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">表1 </span><br><span class="line">&#123;[inner | cross] | &#123;left | right&#125; [outer]&#125;  join</span><br><span class="line">表2</span><br><span class="line">on 条件表达式</span><br><span class="line">[</span><br><span class="line">&#123;[inner | cross] | &#123;left | right&#125; [outer]&#125;  join</span><br><span class="line">表3</span><br><span class="line">on 条件表达式</span><br><span class="line">......</span><br><span class="line">]</span><br><span class="line">[</span><br><span class="line">[where 子句]</span><br><span class="line">[group by 子句]</span><br><span class="line">[having 子句]</span><br><span class="line">[order by 子句]</span><br><span class="line">[limit 子句]</span><br><span class="line">]</span><br><span class="line">[union | union all]</span><br><span class="line">select ...</span><br></pre></td></tr></table></figure><h2 id="5-3-关联条件"><a href="#5-3-关联条件" class="headerlink" title="5.3 关联条件"></a>5.3 关联条件</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>内连接如果没有关联条件，会形成笛卡尔积</li><li>外连接如果没有关联条件，会报错</li></ol><h3 id="2-笛卡尔积"><a href="#2-笛卡尔积" class="headerlink" title="2 笛卡尔积"></a>2 笛卡尔积</h3><ol><li>笛卡儿积是元素相组合，不是数学相乘</li><li>数学中的笛卡儿积<ul><li>集合 A 有 <code>m</code> 个元素，集合 B 有 <code>n</code> 个元素，则笛卡尔积共 <code>m * n</code>个元素</li><li>集合 <code>A = {a, b}</code>，集合 <code>B = {0, 1, 2}</code>，笛卡尔积 = <code>{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}</code></li></ul></li><li>数据库中的笛卡儿积<ul><li>表 A 有 <code>m</code> 条记录，表 B 中有 n 条记录，则笛卡尔积共有 <code>m*n</code> 条记录</li></ul></li></ol><h3 id="3-关联条件的方式"><a href="#3-关联条件的方式" class="headerlink" title="3 关联条件的方式"></a>3 关联条件的方式</h3><ol><li><code>where</code><ul><li>用于所有关联查询</li></ul></li><li><code>join on</code><ul><li>只能写关联条件，虽然关联条件可以并到 <code>where</code> 中，但单独写可读性更好</li></ul></li><li><code>join using(列名列表)</code><ul><li>表示两个关联字段值相同，要求两个关联字段列名必须一致</li></ul></li></ol><h2 id="5-4-内连接"><a href="#5-4-内连接" class="headerlink" title="5.4 内连接"></a>5.4 内连接</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1 隐式</span><br><span class="line">from 表1, 表2 where 条件</span><br><span class="line"></span><br><span class="line">// 2 显式</span><br><span class="line">from 表1 [inner | cross] join 表2 on 关联条件</span><br></pre></td></tr></table></figure><h3 id="2-结果"><a href="#2-结果" class="headerlink" title="2 结果"></a>2 结果</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/SQL/INNER_JOIN.png" alt=""></p><h2 id="5-5-外连接"><a href="#5-5-外连接" class="headerlink" title="5.5 外连接"></a>5.5 外连接</h2><h3 id="1-左外连接"><a href="#1-左外连接" class="headerlink" title="1 左外连接"></a>1 左外连接</h3><h4 id="1-语法-1"><a href="#1-语法-1" class="headerlink" title="1 语法"></a>1 语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表1 left [outer] join 表2 on 条件</span><br></pre></td></tr></table></figure><h4 id="2-结果-1"><a href="#2-结果-1" class="headerlink" title="2 结果"></a>2 结果</h4><p><img src="https://github.com/anyeansan/pics/raw/master/CS/SQL/LEFT_JOIN.png" alt=""></p><ul><li>查出左表所有行，左表中的行在右表没有匹配则右表对应行返回空</li></ul><p><img src="https://github.com/anyeansan/pics/raw/master/CS/SQL/LEFT_EXCLUDING_JOIN.png" alt=""></p><ul><li>查出左表在右表中没有匹配的行，右表肯定都返回空</li></ul><h3 id="2-右外连接"><a href="#2-右外连接" class="headerlink" title="2 右外连接"></a>2 右外连接</h3><h4 id="1-语法-2"><a href="#1-语法-2" class="headerlink" title="1 语法"></a>1 语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表1 right [outer] join 表2 on 条件</span><br></pre></td></tr></table></figure><h4 id="2-结果-2"><a href="#2-结果-2" class="headerlink" title="2 结果"></a>2 结果</h4><p><img src="https://github.com/anyeansan/pics/raw/master/CS/SQL/RIGHT_JOIN.png" alt=""></p><ul><li>查出右表所有行，右表中的行在左表没有匹配则左表对应行返回空</li></ul><p><img src="https://github.com/anyeansan/pics/raw/master/CS/SQL/RIGHT_EXCLUDING_JOIN.png" alt=""></p><ul><li>查出右表在左表中没有匹配的行，左表肯定都返回空</li></ul><h3 id="3-全外连接"><a href="#3-全外连接" class="headerlink" title="3 全外连接"></a>3 全外连接</h3><h4 id="1-语法-3"><a href="#1-语法-3" class="headerlink" title="1 语法"></a>1 语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表1 full [outer] join 表2 on 条件</span><br></pre></td></tr></table></figure><h4 id="2-结果-3"><a href="#2-结果-3" class="headerlink" title="2 结果"></a>2 结果</h4><p><img src="https://github.com/anyeansan/pics/raw/master/CS/SQL/FULL_OUTER_JOIN.png" alt=""></p><ul><li>查出左表和右表的所有行，在彼此表中没有匹配的行则返回空</li></ul><p><img src="https://github.com/anyeansan/pics/raw/master/CS/SQL/OUTER_EXCLUDING_JOIN.png" alt=""></p><ul><li>查出在左表和右表中彼此没有匹配的行</li></ul><h2 id="5-6-例"><a href="#5-6-例" class="headerlink" title="5.6 例"></a>5.6 例</h2><h3 id="1-原始表-t1-和-t2"><a href="#1-原始表-t1-和-t2" class="headerlink" title="1 原始表 t1 和 t2"></a>1 原始表 t1 和 t2</h3><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>a</td></tr><tr><td>2</td><td>b</td></tr><tr><td>3</td><td>c</td></tr></tbody></table><table><thead><tr><th>id</th><th>age</th></tr></thead><tbody><tr><td>2</td><td>D</td></tr><tr><td>3</td><td>E</td></tr><tr><td>4</td><td>F</td></tr></tbody></table><h3 id="2-内连接"><a href="#2-内连接" class="headerlink" title="2 内连接"></a>2 内连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 inner join t2 on t1.id=t2.id;</span><br></pre></td></tr></table></figure><table><thead><tr><th>id</th><th>name</th><th>id</th><th>age</th></tr></thead><tbody><tr><td>2</td><td>a</td><td>2</td><td>D</td></tr><tr><td>3</td><td>c</td><td>3</td><td>E</td></tr></tbody></table><h3 id="3-左外连接"><a href="#3-左外连接" class="headerlink" title="3 左外连接"></a>3 左外连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 left join t2 on t1.id=t2.id;</span><br></pre></td></tr></table></figure><table><thead><tr><th>id</th><th>name</th><th>id</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>a</td><td>null</td><td>null</td></tr><tr><td>2</td><td>b</td><td>2</td><td>D</td></tr><tr><td>3</td><td>c</td><td>3</td><td>E</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 left join t2 on t1.id!=t2.id;</span><br></pre></td></tr></table></figure><table><thead><tr><th>id</th><th>name</th><th>id</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>a</td><td>null</td><td>null</td></tr></tbody></table><h3 id="4-右外连接"><a href="#4-右外连接" class="headerlink" title="4 右外连接"></a>4 右外连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 right join t2 on t1.id=t2.id;</span><br></pre></td></tr></table></figure><table><thead><tr><th>id</th><th>name</th><th>id</th><th>age</th></tr></thead><tbody><tr><td>2</td><td>b</td><td>2</td><td>D</td></tr><tr><td>3</td><td>c</td><td>3</td><td>E</td></tr><tr><td>null</td><td>null</td><td>4</td><td>F</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 right join t2 on t1.id!=t2.id;</span><br></pre></td></tr></table></figure><table><thead><tr><th>id</th><th>name</th><th>id</th><th>age</th></tr></thead><tbody><tr><td>null</td><td>null</td><td>4</td><td>F</td></tr></tbody></table><h3 id="5-全外连接"><a href="#5-全外连接" class="headerlink" title="5 全外连接"></a>5 全外连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 full join t2 on t1.id=t2.id;</span><br></pre></td></tr></table></figure><table><thead><tr><th>id</th><th>name</th><th>id</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>a</td><td>null</td><td>null</td></tr><tr><td>2</td><td>b</td><td>2</td><td>D</td></tr><tr><td>3</td><td>c</td><td>3</td><td>E</td></tr><tr><td>null</td><td>null</td><td>4</td><td>F</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 full join t2 on t1.id!=t2.id;</span><br></pre></td></tr></table></figure><table><thead><tr><th>id</th><th>name</th><th>id</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>a</td><td>null</td><td>null</td></tr><tr><td>null</td><td>null</td><td>4</td><td>F</td></tr></tbody></table><h1 id="六-子查询"><a href="#六-子查询" class="headerlink" title="六 子查询"></a>六 子查询</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><ul><li>一个查询需要的条件或数据是另一个查询的结果，即一个查询中嵌套了另一个查询，嵌套在里面的查询就是子查询</li></ul><h2 id="6-2-子查询根据位置分类"><a href="#6-2-子查询根据位置分类" class="headerlink" title="6.2 子查询根据位置分类"></a>6.2 子查询根据位置分类</h2><ol><li><p>from 型子查询：子查询必须有别名</p><ul><li><code>from (子查询) 别名</code></li></ul></li><li><p>where 型子查询</p><ul><li><code>where 字段 = (子查询)</code></li><li><code>where 字段 in (子查询)</code></li><li><code>...</code></li></ul></li><li><p>exists 型子查询</p><ul><li><code>where exists(子查询)</code><ol><li>子查询返回记录，则 <code>exists</code> 为 <code>true</code>，添加记录</li><li>子查询没有记录，则 <code>exists</code> 为 <code>false</code>，不添加记录</li></ol></li></ul></li><li><p>相关子查询：子查询和外部查询有关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM invoices i</span><br><span class="line">WHERE invoice_total &gt; (</span><br><span class="line">SELECT AVG(invoice_total)</span><br><span class="line">FROM invoices</span><br><span class="line">WHERE client_id = i.client_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>select 子查询</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-SQL（Structure-Query-Language）&quot;&gt;&lt;a href=&quot;#1-1-SQL（Stru
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="SQL" scheme="https://anyeansan.github.io/categories/CS/SQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql语法</title>
    <link href="https://anyeansan.github.io/2020/11/08/SQL/Mysql%E8%AF%AD%E6%B3%95/"/>
    <id>https://anyeansan.github.io/2020/11/08/SQL/Mysql%E8%AF%AD%E6%B3%95/</id>
    <published>2020-11-08T13:14:08.000Z</published>
    <updated>2020-11-08T13:16:37.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-元数据"><a href="#一-元数据" class="headerlink" title="一 元数据"></a>一 元数据</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ol><li>元数据可以简单理解为描述数据的数据，除了存储在数据库中的数据外，其它大多可以理解为元数据</li><li>元数据存储在“基表”中，不能直接访问<ol><li><code>infomation_schema</code> 数据库中保存了大量元数据查询的视图</li><li><code>show</code> 命令是封装好的，提供元数据查询的基础功能</li></ol></li></ol><h2 id="1-2-information-schema"><a href="#1-2-information-schema" class="headerlink" title="1.2 information_schema"></a>1.2 information_schema</h2><table><thead><tr><th>表</th><th>说明</th></tr></thead><tbody><tr><td><code>schemata</code></td><td>存储当前 mysql 实例中所有数据库的信息，<code>show databases</code> 命令从这个表获取数据</td></tr><tr><td><code>tables</code></td><td>存储数据库中的表信息（包括视图），<code>show tables [from db_name]</code> 命令从这个表获取结果</td></tr><tr><td><code>columns</code></td><td>存储数据库中每张表的列信息（如属于哪张表哪个库，属性信息…)</td></tr><tr><td><code>table_constraints</code></td><td>存储表约束信息</td></tr><tr><td><code>statistics</code></td><td>存储表索引信息</td></tr><tr><td><code>collations</code></td><td>存储了字符集和校对集对照信息</td></tr></tbody></table><h3 id="tables-表"><a href="#tables-表" class="headerlink" title="tables 表"></a>tables 表</h3><table><thead><tr><th>列</th><th>说明</th></tr></thead><tbody><tr><td><code>table_schema</code></td><td>表所在库名</td></tr><tr><td><code>table_name</code></td><td>表名</td></tr><tr><td><code>engine</code></td><td>存储引擎</td></tr><tr><td><code>table_rows</code></td><td>总行数</td></tr><tr><td><code>avg_row_length</code></td><td>行平均长度</td></tr><tr><td><code>index_length</code></td><td>索引长度</td></tr></tbody></table><ul><li><code>表大小 = avg_row_length * table_rows + index_length</code></li></ul><h2 id="1-3-show"><a href="#1-3-show" class="headerlink" title="1.3 show"></a>1.3 show</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>show databases</code></td><td>查看所有库名</td></tr><tr><td><code>show tables [from db_name]</code></td><td>查看库中所有表名</td></tr><tr><td><code>show create database db_name</code></td><td>查看建库语句</td></tr><tr><td><code>show create table t_name</code></td><td>查看建表语句</td></tr><tr><td><code>show processlist</code></td><td>查看数据库连接情况</td></tr><tr><td><code>show charset</code></td><td>查看支持的字符集</td></tr><tr><td><code>show collation</code></td><td>查看支持的校对集</td></tr><tr><td><code>show engines</code></td><td>查看支持的存储引擎</td></tr><tr><td><code>show grants for user_name</code></td><td>查看用户权限</td></tr><tr><td><code>shwo variables [like pattern]</code></td><td>查看变量信息</td></tr><tr><td><code>show index from t_name</code></td><td>查看表的索引信息</td></tr><tr><td><code>show engine innodb statsu\G</code></td><td>查看 innodb 引擎详细状态信息（横向）</td></tr><tr><td><code>show status [like pattern]</code></td><td>查看数据库状态信息</td></tr><tr><td><code>show binary logs</code></td><td>查看二进制日志的列表信息</td></tr><tr><td><code>show binlog events in log_name</code></td><td>查看二进制日志的事件信息</td></tr><tr><td><code>show master status</code></td><td>查看 mysql 当前使用的二进制日志信息</td></tr><tr><td><code>show relaylog events in log_name</code></td><td>查看中继日志的事件信息</td></tr></tbody></table><h1 id="二-运算符-和-语句"><a href="#二-运算符-和-语句" class="headerlink" title="二 运算符 和 语句"></a>二 运算符 和 语句</h1><h2 id="2-1-算术运算符"><a href="#2-1-算术运算符" class="headerlink" title="2.1 算术运算符"></a>2.1 算术运算符</h2><table><thead><tr><th align="left">运算符</th><th>说明</th></tr></thead><tbody><tr><td align="left"><code>+</code></td><td>加</td></tr><tr><td align="left"><code>-</code></td><td>减</td></tr><tr><td align="left"><code>*</code></td><td>乘</td></tr><tr><td align="left"><code>/</code></td><td>除</td></tr><tr><td align="left"><code>DIV</code></td><td>整除</td></tr><tr><td align="left"><code>%, MOD</code></td><td>模</td></tr></tbody></table><h2 id="2-2-比较运算符"><a href="#2-2-比较运算符" class="headerlink" title="2.2 比较运算符"></a>2.2 比较运算符</h2><table><thead><tr><th align="left">运算符</th><th>说明</th></tr></thead><tbody><tr><td align="left"><code>&gt;</code></td><td>大于</td></tr><tr><td align="left"><code>&gt;=</code></td><td>大于等于</td></tr><tr><td align="left"><code>&lt;</code></td><td>小于</td></tr><tr><td align="left"><code>&lt;=</code></td><td>小于等于</td></tr><tr><td align="left"><code>=</code></td><td>等于，<code>null = null</code> 返回 null</td></tr><tr><td align="left"><code>&lt;=&gt;</code></td><td>等于，<code>null = null</code> 返回 1</td></tr><tr><td align="left"><code>&lt;&gt;, !=</code></td><td>不等于</td></tr></tbody></table><h2 id="2-3-逻辑运算符"><a href="#2-3-逻辑运算符" class="headerlink" title="2.3 逻辑运算符"></a>2.3 逻辑运算符</h2><table><thead><tr><th align="left">运算符</th><th>说明</th></tr></thead><tbody><tr><td align="left"><code>and, &amp;&amp;</code></td><td>逻辑与</td></tr><tr><td align="left"><code>or, &#124;&#124;</code></td><td>逻辑或</td></tr><tr><td align="left"><code>not, !</code></td><td>逻辑非</td></tr><tr><td align="left"><code>xor</code></td><td>逻辑异或</td></tr></tbody></table><ul><li><code>and</code> 优先级高于 <code>or</code></li></ul><h2 id="2-4-正则"><a href="#2-4-正则" class="headerlink" title="2.4 正则"></a>2.4 正则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regexp pattern</span><br></pre></td></tr></table></figure><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td><code>^</code></td><td>开头</td></tr><tr><td><code>$</code></td><td>结尾</td></tr><tr><td>`</td><td>`</td></tr><tr><td><code>[abc] [a-z]</code></td><td>范围</td></tr><tr><td><code>{n} {m,} {m,n} * + ?</code></td><td>数量</td></tr></tbody></table><h2 id="2-5-语句"><a href="#2-5-语句" class="headerlink" title="2.5 语句"></a>2.5 语句</h2><table><thead><tr><th>语句</th><th>说明</th></tr></thead><tbody><tr><td><code>like pattern</code></td><td>模糊查询，<code>pattern</code> 中：<code>%</code> 匹配任意个任意字符，<code>_</code> 匹配一个任意字符</td></tr><tr><td><code>between ... and ...</code></td><td>在某个范围之间</td></tr><tr><td><code>is null</code></td><td>是否为空</td></tr><tr><td><code>is not null</code></td><td>是否不为空</td></tr><tr><td><code>in()</code></td><td>匹配其中任意一个值，则为 true，类似逻辑或</td></tr><tr><td><code>any()</code></td><td>必须配合比较运算符使用，代表（大于, 小于, …）其中任意一个值则为 true</td></tr><tr><td><code>some()</code></td><td>是 <code>any()</code> 的别名</td></tr><tr><td><code>all()</code></td><td>必须配合比较运算符使用，代表（大于, 小于, …）其中所有值则为 true</td></tr></tbody></table><h1 id="三-变量"><a href="#三-变量" class="headerlink" title="三 变量"></a>三 变量</h1><h2 id="3-1-分类"><a href="#3-1-分类" class="headerlink" title="3.1 分类"></a>3.1 分类</h2><table><thead><tr><th>类型</th><th>级别</th></tr></thead><tbody><tr><td>系统变量</td><td>全局级别，会话级别</td></tr><tr><td>自定义变量</td><td>会话级别</td></tr></tbody></table><h2 id="3-2-系统变量"><a href="#3-2-系统变量" class="headerlink" title="3.2 系统变量"></a>3.2 系统变量</h2><h3 id="1-查看系统变量"><a href="#1-查看系统变量" class="headerlink" title="1 查看系统变量"></a>1 查看系统变量</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>show global variables</code></td><td>查看全局级别所有系统变量的信息</td></tr><tr><td><code>show session variables</code></td><td>查看会话级别所有系统变量的信息</td></tr><tr><td><code>select @@global.变量名</code></td><td>查看全局级别的指定系统变量的信息</td></tr><tr><td><code>select @@session.变量名</code></td><td>查看会话级别的指定系统变量的信息</td></tr><tr><td><code>select @@变量名</code></td><td>查看会话级别的指定系统变量的信息</td></tr></tbody></table><h3 id="2-修改系统变量"><a href="#2-修改系统变量" class="headerlink" title="2 修改系统变量"></a>2 修改系统变量</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>set global 变量名=值</code></td><td>修改全局级别的系统变量，影响新会话，重启失效</td></tr><tr><td><code>set @@global.变量名=值</code></td><td>修改全局级别的系统变量，影响新会话，重启失效</td></tr><tr><td><code>set session 变量名=值</code></td><td>修改会话级别的系统变量</td></tr><tr><td><code>set @@session.变量名=值</code></td><td>修改会话级别的系统变量</td></tr></tbody></table><h2 id="3-3-自定义变量"><a href="#3-3-自定义变量" class="headerlink" title="3.3 自定义变量"></a>3.3 自定义变量</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>为了区分系统变量, 规定用户自定义变量必须使用一个 <code>@</code> 符号</li><li>所有自定义变量不区分数据库</li><li>所有自定义的变量都是会话级别，但根据作用域可以分为<ol><li>全局变量（user/session variable）: 作用域为当前会话</li><li>局部变量（local variable） ：作用域为所在的 <code>begin end</code></li></ol></li></ol><h3 id="2-全局变量"><a href="#2-全局变量" class="headerlink" title="2 全局变量"></a>2 全局变量</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>set @变量名=值</code></td><td>声明并赋值</td></tr><tr><td><code>set @变量名 := 值</code></td><td>声明并赋值</td></tr><tr><td><code>select @变量名 := 值</code></td><td>声明并赋值</td></tr><tr><td><code>select 字段 into @变量名 from t_name</code></td><td>声明并从表中查询数据赋值</td></tr><tr><td><code>select @变量名</code></td><td>查看变量值</td></tr></tbody></table><ul><li>全局变量可以不声明直接使用，默认值为 <code>null</code></li></ul><h3 id="3-局部变量"><a href="#3-局部变量" class="headerlink" title="3 局部变量"></a>3 局部变量</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>declare 变量名 类型</code></td><td>声明局部变量</td></tr><tr><td><code>declare 变量名 类型 default 默认值</code></td><td>声明局部变量并设置默认值</td></tr></tbody></table><ol><li>局部变量需要先声明后使用</li><li>局部变量的赋值与查看命令与全局变量完全一致</li></ol><h1 id="四-函数"><a href="#四-函数" class="headerlink" title="四 函数"></a>四 函数</h1><h2 id="4-1-信息函数"><a href="#4-1-信息函数" class="headerlink" title="4.1 信息函数"></a>4.1 信息函数</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>user()</code></td><td>返回当前用户及所在主机</td></tr><tr><td><code>database()</code></td><td>返回当前数据库名</td></tr><tr><td><code>version()</code></td><td>返回数据库的版本号</td></tr><tr><td><code>connection_id()</code></td><td>返回连接id</td></tr><tr><td><code>last_insert_id()</code></td><td>最后插入记录的id</td></tr></tbody></table><h2 id="4-2-数学函数"><a href="#4-2-数学函数" class="headerlink" title="4.2 数学函数"></a>4.2 数学函数</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>abs(X)</code></td><td>绝对值</td></tr><tr><td><code>ceil(X)</code></td><td>向上取整</td></tr><tr><td><code>floor(X)</code></td><td>向下取整</td></tr><tr><td><code>round(X, D)</code></td><td>四舍五入，保留D位小数</td></tr><tr><td><code>truncate(X, D)</code></td><td>数字截断，保留D位小数</td></tr><tr><td><code>rand(X)</code></td><td><code>0~1</code> 的随机数</td></tr><tr><td><code>mod(N, M)</code></td><td>等价于 <code>N % M</code> 或者 <code>N MOD M</code></td></tr><tr><td><code>sort(X)</code></td><td>平方</td></tr><tr><td><code>pow(X,Y)</code></td><td>Y次方</td></tr><tr><td><code>conv(X, from_base, to_base)</code></td><td>将X从进制 <code>from_base</code> 转为进制 <code>to_base</code> 的字符串</td></tr></tbody></table><h2 id="4-3-字符串函数"><a href="#4-3-字符串函数" class="headerlink" title="4.3 字符串函数"></a>4.3 字符串函数</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>md5(str)</code></td><td>返回字符串的 md5 加密版本</td></tr><tr><td><code>password(str)</code></td><td>返回字符串的加密版本，41位的字符串</td></tr><tr><td><code>concat(str1, str2, ...)</code></td><td>连接字符串，有一个参数为 <code>null</code>，则返回 <code>null</code></td></tr><tr><td><code>concat_ws(separator, str1, str2, ...)</code></td><td>使用指定分隔符连接字符串</td></tr><tr><td><code>length(str)</code></td><td>字节数</td></tr><tr><td><code>char_length(str)</code></td><td>字符数</td></tr><tr><td><code>lower(str)</code></td><td>转小写</td></tr><tr><td><code>upper(str)</code></td><td>转大写</td></tr><tr><td><code>format(X, D)</code></td><td>将数字 X 转为 <code>#,###,###.##</code> 形式的字符串，D为小数位数</td></tr><tr><td><code>trim([{both &#124; leading &#124; trailing}] [remstr from] str)</code></td><td>去除两端空格，<code>remstr</code> 默认空格可指定字符</td></tr><tr><td><code>ltrim(str)</code></td><td>去除左端空格</td></tr><tr><td><code>rtrim(str)</code></td><td>去除右端空格</td></tr><tr><td><code>reverse(str)</code></td><td>反转</td></tr><tr><td><code>left(str, len)</code></td><td>返回 str 从左开始 <code>len</code> 个字符的字符串</td></tr><tr><td><code>right(str, len)</code></td><td>返回 str 从右开始 <code>len</code> 个字符的字符串</td></tr><tr><td><code>substring(str, [from] pos, [[for] len])</code></td><td>返回 str 从 <code>pos</code> 开始的len个字符的字符串</td></tr><tr><td><code>substr()</code></td><td>等价于  <code>substring()</code></td></tr><tr><td><code>locate(substr, str[, pos])</code></td><td>返回子串在 str 中第一次出现的位置，默认从 1 开始，没有则返回 0</td></tr><tr><td><code>instr(str, substr)</code></td><td>等价于 <code>locate(substr, str)</code></td></tr><tr><td><code>insert(str, pos, len, newstr)</code></td><td>将 str 从 <code>pos</code> 开始的 <code>len</code> 个字符替换为 <code>newstr</code></td></tr><tr><td><code>replace(str, from_str, to_str)</code></td><td>替换 str 的子串</td></tr><tr><td><code>strcmp(expr1,expr2)</code></td><td>比较两个字符串</td></tr><tr><td><code>repeat(str, count)</code></td><td>返回 str 重复 count 次组成的字符串</td></tr><tr><td><code>isnull(expr)</code></td><td>判断表达式是否为空</td></tr></tbody></table><h2 id="4-4-日期函数"><a href="#4-4-日期函数" class="headerlink" title="4.4 日期函数"></a>4.4 日期函数</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>now()</code></td><td>返回当前日期和时间 <code>yyyy-MM--dd HH:mm:ss</code></td></tr><tr><td><code>curdate()</code></td><td>返回当前日期 <code>yyyy-MM-dd</code></td></tr><tr><td><code>curtime()</code></td><td>返回当前时间 <code>HH:mm:ss</code></td></tr><tr><td><code>date_format(date, format)</code></td><td>日期格式化</td></tr><tr><td><code>year(date)/month(date)/day(date)/hour(time)</code></td><td>返回指定项</td></tr><tr><td><code>extract(year/month/day from now())</code></td><td>提取日期中的年月日…</td></tr><tr><td><code>datediff(expr1, expr2)</code></td><td>返回 <code>expr1 - expr2</code> 的日期差值</td></tr><tr><td><code>dayofyear(date)</code></td><td>返回指定日期是当年的第几天</td></tr><tr><td><code>dayofmonth(date)</code></td><td>返回指定日期是当月的第几天</td></tr><tr><td><code>dayofweek(date)</code></td><td>返回指定日期是当周的第几天（周日是第一天）</td></tr><tr><td><code>date_add(date, INTERVAL expr unit)</code></td><td>给日期加上指定值，unit 用来指定日期项，expr 为值</td></tr><tr><td><code>date_sub(date, INTERVAL expr unit)</code></td><td>给日期减去指定值</td></tr></tbody></table><h2 id="4-4-JSON-函数"><a href="#4-4-JSON-函数" class="headerlink" title="4.4 JSON 函数"></a>4.4 JSON 函数</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>json_array([val[, val ...]])</code></td><td>返回由参数组成json数组</td></tr><tr><td><code>json_object([key, val[, key, val ...]])</code></td><td>返回由参数组成的 json 对象，奇数参数是 key，偶数参数是 value</td></tr><tr><td><code>json_pretty(json_val)</code></td><td>漂亮的打印 json</td></tr><tr><td><code>json_array_append(json_doc, path, val[, path, val ...])</code></td><td>在 <code>json_doc</code> 指定位置上的值后追加值</td></tr><tr><td><code>json_array_insert(json_doc, path, val[, path, val ...])</code></td><td>向 json 数组指定位置插入值，返回新数组，不改变原有数组</td></tr><tr><td><code>json_insert(json_doc, path, val[, path, val ...])</code></td><td>向 json 对象添加新的键值对，返回新对象，不改变原对象</td></tr><tr><td><code>json_set(json_doc, path, val[, path, val ...])</code></td><td>替换 <code>json_doc</code> 指定位置现有的值，如果不存在则添加</td></tr><tr><td><code>json_replace(json_doc, path, val[, path, val ...])</code></td><td>仅替换现有的值</td></tr><tr><td><code>json_remove(json_doc, path[, path...])</code></td><td>删除 <code>json_doc</code> 指定位置的值</td></tr><tr><td><code>json_extract(json_doc, path[, path...])</code></td><td>获取 <code>json_doc</code> 指定位置的值</td></tr><tr><td><code>json_contains_path(json_doc, one_or_all, path[, path...])</code></td><td>判断是否包含指定路径（索引或者key）</td></tr><tr><td><code>json_contains(target, candidate[, path])</code></td><td>判断是否包含指定值</td></tr><tr><td><code>json_length(json_doc[, path])</code></td><td>返回 <code>json_doc</code> 的长度</td></tr></tbody></table><h2 id="4-5-自定义函数"><a href="#4-5-自定义函数" class="headerlink" title="4.5 自定义函数"></a>4.5 自定义函数</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CREATE</span><br><span class="line">[DEFINER = user]</span><br><span class="line">FUNCTION sp_name ([func_parameter[,...]])</span><br><span class="line">RETURNS type</span><br><span class="line">[characteristic ...] </span><br><span class="line">routine_body</span><br><span class="line"></span><br><span class="line">func_parameter: </span><br><span class="line">param_name type</span><br><span class="line">type:</span><br><span class="line">Any valid MySQL data type</span><br><span class="line">characteristic:</span><br><span class="line">  COMMENT &apos;string&apos;</span><br><span class="line">| LANGUAGE SQL</span><br><span class="line">| [NOT] DETERMINISTIC</span><br><span class="line">| &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;</span><br><span class="line">| SQL SECURITY &#123; DEFINER | INVOKER &#125;</span><br></pre></td></tr></table></figure><h3 id="2-创建"><a href="#2-创建" class="headerlink" title="2 创建"></a>2 创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DROP FUNCTION IF EXISTS 函数名;</span><br><span class="line">DELIMITER 结束标记</span><br><span class="line">CREATE FUNCTION 函数名 ([参数列表]) RETURNS 返回值类型</span><br><span class="line">BEGIN </span><br><span class="line">    函数体</span><br><span class="line">    RETURN 返回值;</span><br><span class="line">END 结束标记</span><br><span class="line">DELIMITER ; -- 将结束标记改回默认分号</span><br></pre></td></tr></table></figure><ul><li>形参<ul><li><code>形参名 形参类型</code></li></ul></li><li>返回值<ul><li><code>{STRING | INTEGER | REAL | DECIMAL}</code></li><li>必须有返回值且只有一个</li></ul></li></ul><h3 id="3-查看"><a href="#3-查看" class="headerlink" title="3 查看"></a>3 查看</h3><ol><li><code>show function status [like pattern]</code><ul><li>查看所有函数</li></ul></li><li><code>show create function 函数名</code><ul><li>查看函数的创建语句</li></ul></li></ol><h3 id="4-修改-删除-函数"><a href="#4-修改-删除-函数" class="headerlink" title="4 修改/删除 函数"></a>4 修改/删除 函数</h3><ol><li>函数不能修改</li><li>删除<ul><li><code>drop function [if exists] 函数名</code></li></ul></li></ol><h1 id="五-流程控制语句"><a href="#五-流程控制语句" class="headerlink" title="五 流程控制语句"></a>五 流程控制语句</h1><h2 id="5-1-if"><a href="#5-1-if" class="headerlink" title="5.1 if"></a>5.1 if</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">If  条件判断  then</span><br><span class="line">-- 满足条件要执行的代码;</span><br><span class="line">Else</span><br><span class="line">-- 不满足条件要执行的代码;</span><br><span class="line">End if;</span><br></pre></td></tr></table></figure><h2 id="5-2-while"><a href="#5-2-while" class="headerlink" title="5.2 while"></a>5.2 while</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">While 条件判断 do</span><br><span class="line">-- 循环体</span><br><span class="line">End while;</span><br></pre></td></tr></table></figure><h2 id="5-3-Iterate-amp-Leave"><a href="#5-3-Iterate-amp-Leave" class="headerlink" title="5.3 Iterate &amp; Leave"></a>5.3 Iterate &amp; Leave</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">循环名:While 条件判断 do</span><br><span class="line">-- 循环体</span><br><span class="line">itrate/leave 循环名;</span><br><span class="line">End while;</span><br></pre></td></tr></table></figure><ol><li><code>Iterate</code> 类似 <code>continue</code></li><li><code>Leave</code> 类似 <code>break</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-元数据&quot;&gt;&lt;a href=&quot;#一-元数据&quot; class=&quot;headerlink&quot; title=&quot;一 元数据&quot;&gt;&lt;/a&gt;一 元数据&lt;/h1&gt;&lt;h2 id=&quot;1-1-概述&quot;&gt;&lt;a href=&quot;#1-1-概述&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="SQL" scheme="https://anyeansan.github.io/categories/CS/SQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql库表列属性</title>
    <link href="https://anyeansan.github.io/2020/11/08/SQL/Mysql%E5%BA%93%E8%A1%A8%E5%88%97%E5%B1%9E%E6%80%A7/"/>
    <id>https://anyeansan.github.io/2020/11/08/SQL/Mysql%E5%BA%93%E8%A1%A8%E5%88%97%E5%B1%9E%E6%80%A7/</id>
    <published>2020-11-08T13:14:02.000Z</published>
    <updated>2020-11-08T13:16:04.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-库表属性"><a href="#一-库表属性" class="headerlink" title="一 库表属性"></a>一 库表属性</h1><h2 id="1-1-字符集（charset）"><a href="#1-1-字符集（charset）" class="headerlink" title="1.1 字符集（charset）"></a>1.1 字符集（charset）</h2><h3 id="1-MySQL-的-UTF-8"><a href="#1-MySQL-的-UTF-8" class="headerlink" title="1 MySQL 的 UTF-8"></a>1 MySQL 的 UTF-8</h3><ol><li>MySQL 中的 <code>utf8mb4</code> 才是真正的 <code>UTF-8</code>，而 <code>utf8</code> 是 <code>utf8mb3</code> 的别名，是 MySQL 脑残的产物</li><li>MySQL 表示未来会删除 <code>utf8mb3</code>，然后 <code>utf8</code> 指代 <code>utf8mb4</code>（真是个小机灵鬼）</li></ol><h3 id="2-字符集说明"><a href="#2-字符集说明" class="headerlink" title="2 字符集说明"></a>2 字符集说明</h3><ol><li><code>show charset</code><ul><li>查看数据库支持的字符集</li></ul></li><li><code>show variables like &#39;character%&#39;</code><ul><li>查看数据库默认字符集设置</li></ul></li></ol><table><thead><tr><th>配置</th><th>说明</th></tr></thead><tbody><tr><td><code>character_set_database</code></td><td>数据库默认字符集，若没设置则使用 <code>character_set_server</code></td></tr><tr><td><code>character_set_client</code></td><td>客户端字符集</td></tr><tr><td><code>character_set_connection</code></td><td>客户端连接数据库使用的字符集</td></tr><tr><td><code>character_set_results</code></td><td>数据库给客户端返回数据使用的字符集</td></tr><tr><td><code>character_set_server</code></td><td>服务器字符集，建议由系统自己管理，不要人为定义</td></tr><tr><td><code>character_set_filesystem</code></td><td>用于将系统文件名转化成此字符集，默认 <code>binary</code> 不做转换（建议不改动）</td></tr><tr><td><code>character_set_system</code></td><td>数据库系统用来存储元数据的编码，通常是 <code>utf8</code>（不要改动）</td></tr><tr><td><code>character_sets_dir</code></td><td>字符集安装目录</td></tr></tbody></table><h3 id="3-乱码问题"><a href="#3-乱码问题" class="headerlink" title="3 乱码问题"></a>3 乱码问题</h3><h4 id="1-存"><a href="#1-存" class="headerlink" title="1 存"></a>1 存</h4><ul><li><code>数据本身字符集</code> → <code>客户端字符集</code> → <code>连接字符集</code> → <code>数据库字符集</code><ol><li><code>数据本身字符集 = 客户端字符集</code>，若不一致则会乱码</li><li>将数据从 <code>客户端字符集</code> 转为 <code>连接字符集</code>，若一致则不转换</li><li>将数据从 <code>连接字符集</code> 转为 <code>数据库字符集</code>，若一致则不转换</li><li>存数据最终是按照 <code>数据库字符集</code> 存储</li></ol></li><li>结论<ol><li>保证 <code>数据本身字符集 = 客户端字符集</code></li><li>连接字符集不要太小导致转换损失数据</li></ol></li></ul><h4 id="2-取"><a href="#2-取" class="headerlink" title="2 取"></a>2 取</h4><ul><li><code>数据库字符集</code> → <code>连接字符集</code> → <code>结果字符集</code> → <code>客户端字符集</code><ol><li>将数据从 <code>数据库字符集</code> 转为 <code>连接字符集</code> ，若一致则不转换</li><li>将数据从 <code>连接字符集</code> 转为 <code>结果字符集</code>，若一致则不转换</li><li>取数据最终是按照结果字符集返回给客户端</li><li>比较 <code>结果字符集</code> 与 <code>客户端字符集</code> 是否一致</li></ol></li><li>结论<ol><li>保证 <code>结果字符集 = 客户端字符集</code></li><li>连接字符集不要太小导致转换损失数据</li></ol></li></ul><h2 id="1-2-校对集（collation）"><a href="#1-2-校对集（collation）" class="headerlink" title="1.2 校对集（collation）"></a>1.2 校对集（collation）</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>校对集，就是数据的比较方式，或者排序规则</li><li>只有当数据产生比较的时候，校对集才会生效</li><li>必须在没有数据之前声明好校对集，如果有了数据再进行校对集修改，修改无效</li><li>校对集依赖字符集，每个字符集都对应 1 或 多个校对集，如 <code>utf8mb4</code> 默认校对集 <code>utf8mb4_general_ci</code></li></ol><h3 id="2-校对集格式"><a href="#2-校对集格式" class="headerlink" title="2 校对集格式"></a>2 校对集格式</h3><ul><li><code>show collation</code><ul><li>查看数据库支持的校对集</li></ul></li></ul><table><thead><tr><th>格式</th><th>说明</th></tr></thead><tbody><tr><td><code>_bin</code></td><td><code>binary</code>，二进制比较, 大小写敏感（适用比较特殊的数据，如拼音，日文…）</td></tr><tr><td><code>_ci</code></td><td><code>case insensitive</code>，大小写不敏感</td></tr><tr><td><code>_cs</code></td><td><code>case sensitive</code>，大小写敏感</td></tr></tbody></table><h2 id="1-3-存储引擎（engine）"><a href="#1-3-存储引擎（engine）" class="headerlink" title="1.3 存储引擎（engine）"></a>1.3 存储引擎（engine）</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>MySQL进行存储数据的方式。</li><li>每一种存储引擎使用不同的存储机制，索引技巧，锁定水平，最终提供广泛且不同的功能。</li></ol><h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2 分类"></a>2 分类</h3><ol><li><code>show engines</code><ul><li>查看支持的存储引擎</li></ul></li><li><code>select @@default_storage_engine</code><ul><li>查看默认的存储引擎</li></ul></li><li><code>alter table 表名 engine=存储引擎</code><ul><li>除了修改存储引擎外，还会做碎片整理</li></ul></li></ol><table><thead><tr><th>存储引擎</th><th>说明</th></tr></thead><tbody><tr><td><code>InnoDB</code></td><td>新版 MySQL 默认存储引擎</td></tr><tr><td><code>Myisam</code></td><td>速度快，不支持事务，安全性不够</td></tr><tr><td><code>Memory</code></td><td>数据存在内存中，不存在磁盘，一关闭服务器就消失。适合临时数据</td></tr><tr><td><code>XtraDB</code></td><td><code>PerconaDB</code> 默认存储引擎</td></tr><tr><td><code>TokuDB RocksDB MyRocks</code></td><td>第三方存储引擎：共同点是压缩比较高,数据插入性能极高</td></tr></tbody></table><h3 id="3-InnoDB"><a href="#3-InnoDB" class="headerlink" title="3 InnoDB"></a>3 InnoDB</h3><h4 id="1-特性"><a href="#1-特性" class="headerlink" title="1 特性"></a>1 特性</h4><ol><li>事务（Transaction）</li><li>行级锁（Row-level Lock）</li><li>多版本并发控制 MVCC（Multi-Version Concurrency Control）</li><li>自动故障安全恢复 ACSR（Auto Crash Safey Recovery）</li><li>热备份（Hot Backup）</li><li>外键</li><li>复制 Replication<ol><li>Group Commit</li><li>GTID (Global Transaction ID)</li><li>多线程（Multi-Threads-SQL）</li></ol></li></ol><h4 id="2-物理存储结构"><a href="#2-物理存储结构" class="headerlink" title="2 物理存储结构"></a>2 物理存储结构</h4><h5 id="1-共享表空间"><a href="#1-共享表空间" class="headerlink" title="1 共享表空间"></a>1 共享表空间</h5><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td><code>idbdata1</code></td><td>系统数据字典信息（统计信息），Undo 回滚日志等数据</td></tr><tr><td><code>ib_logfile0~ib_logfile1</code></td><td>Redo 重做日志文件，事务日志文件</td></tr><tr><td><code>ibtmp1</code></td><td>临时表空间，存储临时表（如 join union 等操作）</td></tr></tbody></table><h5 id="2-独立表空间"><a href="#2-独立表空间" class="headerlink" title="2 独立表空间"></a>2 独立表空间</h5><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td><code>.frm</code></td><td>存储表列信息（列名，列属性）</td></tr><tr><td><code>.ibd</code></td><td>存储表数据行和索引</td></tr><tr><td><code>opt</code></td><td>存储库属性</td></tr></tbody></table><ul><li>一张 InnoDB 表 = <code>ibdata1 + frm + ibd（段、区、页）</code></li></ul><h5 id="3-表空间（Tablespace）说明"><a href="#3-表空间（Tablespace）说明" class="headerlink" title="3 表空间（Tablespace）说明"></a>3 表空间（Tablespace）说明</h5><ol><li>共享表空间：将所有数据存储到同一个表空间中 ，管理比较混乱</li><li>独立表空间：一张表一个 <code>frm</code> 存储列信息，一个 <code>ibd</code> 存储数据行和索引</li><li>说明<ol><li>共享表空间是 5.5 版本出现的管理模式</li><li>5.6 版本开始默认使用独立表空间，保留共享表空间，只用来存储：数据字典信息，undo，临时表</li><li>5.7 版本临时表被独立出去，共享表空间只存储：数据字典信息，undo</li><li>8.0 版本undo也被独立出去，共享表空间只存储：数据字典信息</li></ol></li></ol><h3 id="4-核心参数"><a href="#4-核心参数" class="headerlink" title="4 核心参数"></a>4 核心参数</h3><h4 id="1-存储引擎"><a href="#1-存储引擎" class="headerlink" title="1 存储引擎"></a>1 存储引擎</h4><ol><li><code>default_storage_engine=innodb</code><ul><li>默认存储引擎</li></ul></li></ol><h4 id="2-表空间"><a href="#2-表空间" class="headerlink" title="2 表空间"></a>2 表空间</h4><ol><li><code>innobd_file_pre_table=1</code><ul><li>表空间模式，1 独立表空间</li></ul></li><li><code>innodb_data_file_path=ibdata1:512M:ibdata2:512M:autoextend</code><ul><li>共享表空间文件个数和大小</li></ul></li></ol><h4 id="3-缓冲区"><a href="#3-缓冲区" class="headerlink" title="3 缓冲区"></a>3 缓冲区</h4><ol><li><code>innodb_flush_log_at_trx_commit=1</code><ul><li>双一标准之一</li><li>控制了 innodb 将 <code>log buffer</code> 中的数据写入日志文件并 flush 磁盘的时间点，取值分别为 0、1、2 三个</li></ul></li><li><code>Innodb_flush_method=(O_DIRECT, fdatasync)</code><ul><li>双一标准之一</li><li>控制 <code>log buffer</code> 和 <code>data buffer</code> 刷写磁盘的时候是否经过文件系统缓存 <code>OS buffer</code></li></ul></li><li><code>innodb_max_dirty_pages_pct=75</code><ul><li>脏页刷写策略</li></ul></li></ol><h4 id="4-redo-日志"><a href="#4-redo-日志" class="headerlink" title="4 redo 日志"></a>4 redo 日志</h4><ol><li><code>innodb_log_buffer_size</code></li><li><code>innodb_log_file_size</code></li><li><code>innodb_log_files_in_group</code></li></ol><h1 id="二-列属性"><a href="#二-列属性" class="headerlink" title="二 列属性"></a>二 列属性</h1><h2 id="2-1-数据类型"><a href="#2-1-数据类型" class="headerlink" title="2.1 数据类型"></a>2.1 数据类型</h2><h3 id="1-数值类型"><a href="#1-数值类型" class="headerlink" title="1 数值类型"></a>1 数值类型</h3><h4 id="1-整型"><a href="#1-整型" class="headerlink" title="1 整型"></a>1 整型</h4><table><thead><tr><th>类型</th><th>大小</th><th>无符号范围</th><th>有符号范围</th></tr></thead><tbody><tr><td><strong>tinyint</strong></td><td>1 Byte</td><td><code>0 ~ 255</code></td><td><code>-128 ~ 127</code></td></tr><tr><td><code>smallint</code></td><td>2 Byte</td><td><code>0 ~ 65535</code></td><td><code>-2<sup>15</sup> ~ 2<sup>15</sup>-1</code></td></tr><tr><td><code>mediumint</code></td><td>3 Byte</td><td><code>0 ~ 2<sup>24</sup>-1</code>`</td><td><code>-2<sup>23</sup> ~ 2<sup>23</sup>-1</code></td></tr><tr><td><strong>int</strong></td><td>4 Byte</td><td><code>0 ~ 2<sup>32</sup>-1</code>`</td><td><code>-2<sup>31</sup> ~ 2<sup>31</sup>-1</code></td></tr><tr><td><code>bigint</code></td><td>8 Byte</td><td><code>0 ~ 2<sup>64</sup>-1</code>`</td><td><code>-2<sup>63</sup> ~ 2<sup>63</sup>-1</code></td></tr></tbody></table><ul><li><code>int(M)</code><ul><li><code>M</code> 与存储无关，只是标识显示长度，且要配合 <code>zerofill</code> 才有意义</li></ul></li></ul><h4 id="2-浮点型-amp-定点型"><a href="#2-浮点型-amp-定点型" class="headerlink" title="2 浮点型 &amp; 定点型"></a>2 浮点型 &amp; 定点型</h4><table><thead><tr><th>类型</th><th>名称</th><th>语法</th><th><code>M</code></th><th><code>D</code></th></tr></thead><tbody><tr><td><code>float</code></td><td>单精度浮点型 4 Byte</td><td><code>float(M,D)</code></td><td>总位数</td><td>小数点后的位数（不足用0补，超过则四舍五入）</td></tr><tr><td><code>double</code></td><td>双精度浮点型 8 Byte</td><td><code>double(M,D)</code></td><td>总位数</td><td>小数点后的位数（不足用0补，超过则四舍五入）</td></tr><tr><td><code>decimal</code></td><td>定点型，底层使用字符串存储</td><td><code>decimal(M,D)</code></td><td></td><td></td></tr></tbody></table><h3 id="2-字符串类型"><a href="#2-字符串类型" class="headerlink" title="2 字符串类型"></a>2 字符串类型</h3><table><thead><tr><th>类型</th><th>名称</th><th>语法</th><th><code>M</code></th><th>说明</th></tr></thead><tbody><tr><td><strong>char</strong></td><td>定长字符串</td><td><code>char(M)</code></td><td>字符数 <code>[1,255]</code></td><td>char 会立即分配 M 个字符长度的存储空间，未占满用空格填充</td></tr><tr><td><strong>varchar</strong></td><td>变长字符串</td><td><code>varchar(M)</code></td><td>最大字符数 <code>[1,65535]</code></td><td>varchar 存储前会先判断长度，按需分配空间</td></tr><tr><td><code>tinytext</code></td><td>短文本</td><td></td><td></td><td></td></tr><tr><td><code>text</code></td><td>文本</td><td></td><td></td><td></td></tr><tr><td><code>mediumtext</code></td><td>中长文本</td><td></td><td></td><td></td></tr><tr><td><code>longtext</code></td><td>长文本</td><td></td><td></td><td></td></tr></tbody></table><h4 id="1-char"><a href="#1-char" class="headerlink" title="1 char"></a>1 char</h4><ol><li>非空 char 的最大长度是 255【字节】</li><li>可空 char 的最大长度是 254【字节】，因为允许为空时，系统会自动从整个记录中保留一个字节来存储 NULL</li></ol><h4 id="2-varchar"><a href="#2-varchar" class="headerlink" title="2 varchar"></a>2 varchar</h4><ol><li>非空 varchar 的最大长度是 65532【字节】<ol><li>如果存储值小于 255 字节，则使用 1 个字节标记长度</li><li>如果存储值超过 255 字节，则使用 2 个字节标记长度</li><li>varchar是从第二个字节开始存储的</li></ol></li><li>可空 varchar 的最大长度是 65531【字节】</li></ol><h4 id="3-以-utf8-为例比较"><a href="#3-以-utf8-为例比较" class="headerlink" title="3 以 utf8 为例比较"></a>3 以 utf8 为例比较</h4><table><thead><tr><th>类型</th><th>可存字符</th><th>实存字符</th><th>实占字节</th><th>利用率</th></tr></thead><tbody><tr><td><code>char(M)</code></td><td>M</td><td>n</td><td><code>M * 3</code></td><td><code>n / M</code></td></tr><tr><td><code>varchar(M)</code></td><td>M</td><td>n</td><td><code>n * 3 + (1~2)</code></td><td><code>n * 3 / （n * 3 + (1~2)）</code></td></tr></tbody></table><h3 id="3-枚举-enum"><a href="#3-枚举-enum" class="headerlink" title="3 枚举 enum"></a>3 枚举 enum</h3><ul><li><code>enum(value1, value2, value3, ...)</code><ol><li>建表时在字段上定义枚举列表，按照定义顺序索引值从 1 开始编号<ul><li>空字符串 <code>&quot;&quot;</code> 索引为 0</li><li><code>null</code> 索引为 <code>null</code></li></ul></li><li>插入数据时（单选），可以使用索引值或者枚举值</li><li>数据库存储时存储索引，读取时再根据枚举列表将索引转为枚举值</li></ol></li></ul><h3 id="4-集合-set"><a href="#4-集合-set" class="headerlink" title="4 集合 set"></a>4 集合 set</h3><ul><li><code>set(value1, value2, value3, ...)</code><ol><li>建表时在字段上定义集合列表，集合中每个值对应一个二进制位<ul><li>第一个值对应 <code>1 = 1</code></li><li>第二个值对应 <code>10 = 2</code></li><li>第三个值对应 <code>100 = 4</code></li><li>第四个值对应 <code>1000 = 8</code></li><li>…</li><li>也就是说一个二进制数，从低位向高位依次对应集合从 1 开始的值</li></ul></li><li>插入数据时（多选），可以使用二进制对应的十进制数字，插入数字对应的二进制，相应位置为 1 代表插入该值，例如<ul><li>插入 <code>6</code>，转为二进制 <code>110</code>，即插入第二和第三个值</li><li>插入 <code>7</code>，转为二进制 <code>111</code>，即插入前三个值</li><li>插入 <code>8</code>，转为二进制 <code>1000</code>，即插入第四个值</li></ul></li></ol></li></ul><h3 id="5-日期类型"><a href="#5-日期类型" class="headerlink" title="5 日期类型"></a>5 日期类型</h3><table><thead><tr><th>类型</th><th>格式</th><th>大小</th><th>最小值</th><th>最大值</th><th>零值</th><th>说明</th></tr></thead><tbody><tr><td><strong>datetime</strong></td><td><code>yyyy-mm-dd hh:mm:ss</code></td><td>8 Byte</td><td><code>1000-01-01 00:00:00</code></td><td><code>9999-12-31 23:59:59</code></td><td><code>0000-00-00 00:00:00</code></td><td>表示日期时间</td></tr><tr><td><strong>timestamp</strong></td><td><code>yyyy-mm-dd hh:mm:ss</code></td><td>4 Byte</td><td><code>1970-01-01 00:00:00</code></td><td><code>2038-01-19 03:14:07</code></td><td><code>0000-00-00 00:00:00</code></td><td></td></tr><tr><td><code>date</code></td><td><code>yyyy-mm-dd</code></td><td>3 Byte</td><td><code>1000-01-01</code></td><td><code>9999-12-31</code></td><td><code>0000-00-00</code></td><td>表示日期</td></tr><tr><td><code>time</code></td><td><code>hh:mm:ss</code></td><td>3 Byte</td><td><code>-838:59:59</code></td><td><code>838:59:59</code></td><td><code>00:00:00</code></td><td>表示时间</td></tr></tbody></table><ol><li><code>datatime</code><ul><li>存储日期时间</li></ul></li><li><code>timestamp</code><ol><li>时间戳（从 <code>1970-01-01 00:00:00</code> 到指定时间的毫秒值）</li><li>存储毫秒值，显示时，根据毫秒值计算出一个本地化的日期时间（即可以自动根据时区显示）</li><li><code>timestamp</code> 因为存储的毫秒值，比较或计算时效率更高</li><li>插入时未指定值或插入 <code>null</code>，则会插入系统当前时间</li></ol></li><li>插入 Mysql 的日期时间格式为  <code>yyyy-MM-dd HH:mm:ss</code></li></ol><h3 id="6-二进制类型"><a href="#6-二进制类型" class="headerlink" title="6 二进制类型"></a>6 二进制类型</h3><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>tinyblob</code></td><td>最大长度为255B</td></tr><tr><td><code>blob</code></td><td>最大长度为64KB</td></tr><tr><td><code>mediumblob</code></td><td>最大长度为16MB</td></tr><tr><td><code>longblob</code></td><td>最大长度为4GB</td></tr></tbody></table><ul><li>二进制数据类型可存储任何数据（甚至包括二进制信息），如图像、多媒体、字处理文档等</li></ul><h2 id="2-2-注释"><a href="#2-2-注释" class="headerlink" title="2.2 注释"></a>2.2 注释</h2><ul><li><code>comment &#39;注释&#39;</code><ul><li>用于描述字段信息</li></ul></li></ul><h2 id="2-3-unsigned"><a href="#2-3-unsigned" class="headerlink" title="2.3 unsigned"></a>2.3 unsigned</h2><ul><li><code>unsigned</code><ol><li>将数值类型声明为无符号</li><li>MySQL 中的数值默认都是有符号的。</li></ol></li></ul><h2 id="2-4-zerofill"><a href="#2-4-zerofill" class="headerlink" title="2.4 zerofill"></a>2.4 zerofill</h2><ul><li><code>zerofill</code><ol><li>数值类型的列位数不足时用 0 补填充</li><li>如果声明 <code>zerofill</code>，则会自动声明为 <code>unsigned</code></li></ol></li></ul><h2 id="2-5-自增长"><a href="#2-5-自增长" class="headerlink" title="2.5 自增长"></a>2.5 自增长</h2><h3 id="1-添加自增长"><a href="#1-添加自增长" class="headerlink" title="1 添加自增长"></a>1 添加自增长</h3><ul><li><code>字段 auto_increment</code><ol><li>一张表只能有一个自增长，因为一张表只有一个维护自增长的变量</li><li>自增的列必须是整数列</li><li>自增的列必须是键列（主键，唯一键，外键）</li><li>建表后，增删自增长通过修改列属性来实现</li></ol></li></ul><h3 id="2-使用自增长"><a href="#2-使用自增长" class="headerlink" title="2 使用自增长"></a>2 使用自增长</h3><ol><li>自增列指定了值且非 <code>0 null</code>，则使用指定值<ol><li>如果指定值 &lt; 自增值，则表的自增值不变</li><li>如果指定值 &gt; 自增值，则表的自增值会变成指定值</li></ol></li><li>使用自增值<ol><li>自增列没有指定值</li><li>自增列指定值为 <code>0 null default</code></li></ol></li></ol><h3 id="3-自增长管理"><a href="#3-自增长管理" class="headerlink" title="3 自增长管理"></a>3 自增长管理</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>show variables like &#39;auto_increment%&#39;</code></td><td>查看自增长初始值和种子</td></tr><tr><td><code>select last_insert_id()</code></td><td>获取自增的最后一个值</td></tr><tr><td><code>show create database 库名</code></td><td>通过查看表创建语句查看下一次自增长的值</td></tr><tr><td><code>alter table 表名 auto_increment = 值</code></td><td>修改自增长的值，只能比当前自增长的最大值大，不能小（小则不生效）</td></tr></tbody></table><h2 id="2-6-约束（Constraint）"><a href="#2-6-约束（Constraint）" class="headerlink" title="2.6 约束（Constraint）"></a>2.6 约束（Constraint）</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h3><table><thead><tr><th>约束</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><code>Primary key</code></td><td>主键约束</td><td>唯一，非空，一张表只能有一个</td></tr><tr><td><code>Foreign key</code></td><td>外键约束</td><td>用于在两表之间建立关系，需指定引用主表的哪一列</td></tr><tr><td><code>Unique key</code></td><td>唯一键约束</td><td>唯一，非空，一张表可有多个唯一键</td></tr><tr><td><code>Not Null</code></td><td>非空约束</td><td>要求该列值不能为空</td></tr><tr><td><code>Default</code></td><td>默认约束</td><td>设置该列默认值</td></tr><tr><td><code>Check</code></td><td>检查约束（Mysql 不支持）</td><td>限制该列取值范围是否合适</td></tr></tbody></table><ul><li><code>select * from information_schema.table_constraints where table_name = &#39;表名&#39;</code><ul><li>查看某表的约束信息</li><li>表的约束信息存储在 <code>information_shcema</code> 数据库的 <code>table_constraints</code> 表中</li></ul></li></ul><h3 id="2-主键约束"><a href="#2-主键约束" class="headerlink" title="2 主键约束"></a>2 主键约束</h3><h4 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1 概述"></a>1 概述</h4><ol><li>主键列唯一，非空，一张表只能有一个主键</li><li>主键分为：<ol><li>单列主键（单列） </li><li>复合主键（多列）</li></ol></li><li>创建主键会自动创建对应的索引，删除主键会自动删除对应的索引</li><li>主键无法修改</li><li>主键约束名称为 <code>PRIMARY</code></li></ol><h4 id="2-添加主键约束"><a href="#2-添加主键约束" class="headerlink" title="2 添加主键约束"></a>2 添加主键约束</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>字段 primaray key</code></td><td>建表时，为当前列添加单列主键</td></tr><tr><td><code>primary key(字段列表)</code></td><td>建表时，单独一行，添加单列主键或复合主键</td></tr><tr><td><code>alter table 表名 add primary key(字段列表)</code></td><td>建表后，添加单列主键或复合主键</td></tr></tbody></table><h4 id="3-删除主键约束"><a href="#3-删除主键约束" class="headerlink" title="3 删除主键约束"></a>3 删除主键约束</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>alter table 表名 drop primary key</code></td><td>有自增长先要删除自增长，因为自增长的列必须有索引</td></tr></tbody></table><h3 id="3-唯一键约束"><a href="#3-唯一键约束" class="headerlink" title="3 唯一键约束"></a>3 唯一键约束</h3><h4 id="1-概述-4"><a href="#1-概述-4" class="headerlink" title="1 概述"></a>1 概述</h4><ol><li>唯一约束列唯一，可以为 <code>null</code>，且可以有多个 <code>null</code>，因为 <code>null = null -&gt; false</code></li><li>一张表可以有多个唯一约束 </li><li>唯一键分为：<ol><li>单列唯一键（约束名：列名）</li><li>复合唯一键（约束名：该多列组合的第一列的列名）</li></ol></li><li>创建唯一键约束会自动创建对应的索引，删除唯一键约束是通过删除对应索引来删除</li></ol><h4 id="2-添加唯一键约束"><a href="#2-添加唯一键约束" class="headerlink" title="2 添加唯一键约束"></a>2 添加唯一键约束</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>字段 unique key</code></td><td>建表时，为当前列添加单列唯一键</td></tr><tr><td><code>unique key(字段列表)</code></td><td>建表时，单独一行，添加单列唯一键或复合唯一键</td></tr><tr><td><code>alter table 表名 add unique key(字段列表)</code></td><td>建表后，添加单列唯一键或复合唯一键</td></tr></tbody></table><h4 id="3-删除唯一键约束"><a href="#3-删除唯一键约束" class="headerlink" title="3 删除唯一键约束"></a>3 删除唯一键约束</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>alter table 表名 drop [index/key] 唯一键约束名</code></td><td>通过删除索引删除唯一键约束</td></tr></tbody></table><h3 id="4-外键约束"><a href="#4-外键约束" class="headerlink" title="4 外键约束"></a>4 外键约束</h3><h4 id="1-概述-5"><a href="#1-概述-5" class="headerlink" title="1 概述"></a>1 概述</h4><ol><li>外键约束建立在从表之上，一个表可以有多个外键约束</li><li>主表和从表必须使用相同的存储引擎 <code>InnoDB</code>，且禁止使用临时表</li><li>从表的外键列和主表的被引用列的名称可以不同，列属性必须一致</li><li>主表被引用列必须是键列</li><li>从表添加外键约束时会自动创建索引，删除外键约束不会删除索引</li></ol><h4 id="2-外键约束模式"><a href="#2-外键约束模式" class="headerlink" title="2 外键约束模式"></a>2 外键约束模式</h4><h5 id="1-概述-6"><a href="#1-概述-6" class="headerlink" title="1 概述"></a>1 概述</h5><ol><li>外键约束同时约束双方行为<ul><li>主表：<code>update delete</code><ul><li>因为从表有可能引用了主表要更新或删除的数据</li></ul></li><li>从表：<code>insert update</code><ul><li>从表的数据必须存在于主表之中</li></ul></li></ul></li><li>建表时：先建主表再建从表，删表时：先删从表再删主表</li><li>删除和修改可以分别指定外键约束模式<ol><li><code>on update 模式</code></li><li><code>on delete 模式</code></li></ol></li></ol><h5 id="2-模式"><a href="#2-模式" class="headerlink" title="2 模式"></a>2 模式</h5><table><thead><tr><th>模式</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><code>restrict（默认）</code></td><td>严格模式</td><td>如果从表外键列有引用，则主表不能 <code>update/delete</code> 被引用列的值</td></tr><tr><td><code>no action</code></td><td>严格模式</td><td>标准 SQL 的关键字，在 MySQL 中同 <code>restrict</code></td></tr><tr><td><code>cascade</code></td><td>级联模式</td><td>主表被引用列的值<br>1. <code>update</code>，则从表外键列对应值 <code>update</code><br>2. <code>delete</code> ，则从表删除对应的整行记录</td></tr><tr><td><code>set null</code></td><td>置空模式</td><td>主表被引用列的值 <code>update/delete</code> 时， 从表外键列对应值设为 <code>null</code>（外键列要可以为空）</td></tr><tr><td><code>set default</code></td><td>默认值模式</td><td>Mysql Innodb不支持</td></tr></tbody></table><h4 id="3-添加外键约束"><a href="#3-添加外键约束" class="headerlink" title="3 添加外键约束"></a>3 添加外键约束</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>foreign key(从表外键列) references 主表名(被引用列) [on delete 模式 on update 模式]</code></td><td>建表时，单独一行，添加外键约束</td></tr><tr><td><code>alter table 从表名 add foreign key(从表外键列) references 主表名(被引用列) [on delete 模式 on update 模式]</code></td><td>建表后，添加外键约束</td></tr></tbody></table><h4 id="4-删除外键约束"><a href="#4-删除外键约束" class="headerlink" title="4 删除外键约束"></a>4 删除外键约束</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>alter table 表名 drop foreign key 外键约束名</code></td><td>外键约束名通过系统库 <code>information_schema</code> 的 <code>table_constraints</code> 获取</td></tr></tbody></table><h3 id="5-非空约束"><a href="#5-非空约束" class="headerlink" title="5 非空约束"></a>5 非空约束</h3><ul><li><code>not null</code><ol><li>列不能为 <code>null</code>，必须插入值，通常配合 <code>default</code> 使用</li><li>建表后，增删非空约束通过修改列属性来实现</li></ol></li></ul><h3 id="6-默认约束"><a href="#6-默认约束" class="headerlink" title="6 默认约束"></a>6 默认约束</h3><ul><li><code>字段 default 默认值</code><ol><li>使用默认值<ol><li>对应字段没有插入值</li><li>对应字段插入值为 <code>default</code></li></ol></li><li>建表后，增删默认约束通过修改列属性来实现</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-库表属性&quot;&gt;&lt;a href=&quot;#一-库表属性&quot; class=&quot;headerlink&quot; title=&quot;一 库表属性&quot;&gt;&lt;/a&gt;一 库表属性&lt;/h1&gt;&lt;h2 id=&quot;1-1-字符集（charset）&quot;&gt;&lt;a href=&quot;#1-1-字符集（charset）&quot; cla
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="SQL" scheme="https://anyeansan.github.io/categories/CS/SQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql前言</title>
    <link href="https://anyeansan.github.io/2020/11/08/SQL/Mysql%E5%89%8D%E8%A8%80/"/>
    <id>https://anyeansan.github.io/2020/11/08/SQL/Mysql%E5%89%8D%E8%A8%80/</id>
    <published>2020-11-08T13:13:54.000Z</published>
    <updated>2020-11-08T13:16:09.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><ol><li><code>DBMS（Database Management System）</code>：数据库管理系统<ol><li>RDBMS（Relational DBMS）<ul><li><code>Oracle DB2</code></li><li><code>Sql-Server Mysql</code></li><li><code>access</code></li><li><code>PG MSSQL</code></li></ul></li><li>NoSQL（Not Only SQL）<ul><li><code>MongoDB</code></li><li><code>Redis</code></li><li><code>ES（Elasticsearch）</code></li><li><code>memcached</code></li></ul></li><li>NewSQL（分布式）<ul><li><code>TiDB Spanner AliSQL OB PolarDB</code></li></ul></li></ol></li><li><code>DBA（Database Administrator）</code>：数据库管理员</li></ol><h2 id="1-2-Mysql-GA版本"><a href="#1-2-Mysql-GA版本" class="headerlink" title="1.2 Mysql GA版本"></a>1.2 Mysql GA版本</h2><ol><li><code>5.6</code><ul><li><code>5.6.38</code>（2017-09-13）</li></ul></li><li><code>5.7</code><ul><li><code>5.7.20</code>（2017-09-13）</li></ul></li></ol><h2 id="1-3-数据库设计三大范式"><a href="#1-3-数据库设计三大范式" class="headerlink" title="1.3 数据库设计三大范式"></a>1.3 数据库设计三大范式</h2><ol><li>每个单元格都应该是单一值，并且列不重复</li><li>每个表都应该是单一功能的，即一个表能且仅能表示一个实体类型，表中所有字段都是用来描述此实体的</li><li>一个表中的字段不该由表中其它字段推导而来</li></ol><h1 id="二-Mysql-安装与配置"><a href="#二-Mysql-安装与配置" class="headerlink" title="二 Mysql 安装与配置"></a>二 Mysql 安装与配置</h1><h2 id="2-1-Linux"><a href="#2-1-Linux" class="headerlink" title="2.1 Linux"></a>2.1 Linux</h2><h3 id="1-下载解压"><a href="#1-下载解压" class="headerlink" title="1 下载解压"></a>1 下载解压</h3><ol><li>下载 <code>linux-generic</code> 通用二进制包（类似绿色版）</li><li>上传到 linux 并解压</li></ol><h3 id="2-卸载-mariadb"><a href="#2-卸载-mariadb" class="headerlink" title="2 卸载 mariadb"></a>2 卸载 <code>mariadb</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 rpm -qa | grep mariadb</span><br><span class="line">2 yum remove -y xxx</span><br></pre></td></tr></table></figure><h3 id="3-创建用户并授权，用于管理mysql"><a href="#3-创建用户并授权，用于管理mysql" class="headerlink" title="3 创建用户并授权，用于管理mysql"></a>3 创建用户并授权，用于管理mysql</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 useradd -s /sbin/nologin mysql</span><br><span class="line">2 chown -R mysql.mysql basedir</span><br><span class="line">3 chown -R mysql.mysql datadir</span><br></pre></td></tr></table></figure><h3 id="4-设置环境变量"><a href="#4-设置环境变量" class="headerlink" title="4 设置环境变量"></a>4 设置环境变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 vim /etc/profile</span><br><span class="line">2 export PATH=basedir/bin:$PATH</span><br><span class="line">3 source /etc/profile</span><br><span class="line">4 mysql -V</span><br></pre></td></tr></table></figure><h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5 初始化"></a>5 初始化</h3><h4 id="1-无密码"><a href="#1-无密码" class="headerlink" title="1 无密码"></a>1 无密码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --initialize-insecure --user=mysql --basedir=xxx --datadir=xxx</span><br></pre></td></tr></table></figure><h4 id="2-有密码"><a href="#2-有密码" class="headerlink" title="2 有密码"></a>2 有密码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --initialize --user=mysql --basedir=xxx --datadir=xxx</span><br></pre></td></tr></table></figure><ol><li>可能会因为缺少 <code>libaio-devel</code> 依赖而报错</li><li><code>--initialize</code><ol><li>对密码复杂度进行定制：12位，4种</li><li>密码过期时间：180天</li><li>给 <code>root@localhost</code> 用户设置临时密码</li></ol></li></ol><h3 id="6-配置文件-etc-my-cnf"><a href="#6-配置文件-etc-my-cnf" class="headerlink" title="6 配置文件 /etc/my.cnf"></a>6 配置文件 <code>/etc/my.cnf</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[mysqld] </span><br><span class="line">user=mysql</span><br><span class="line">basedir=</span><br><span class="line">datadir=</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">port=3306</span><br><span class="line">server_id=6</span><br><span class="line">[mysql]</span><br><span class="line">socket=/tmp/mysql.sock</span><br></pre></td></tr></table></figure><h3 id="7-MySQL-服务"><a href="#7-MySQL-服务" class="headerlink" title="7 MySQL 服务"></a>7 MySQL 服务</h3><h4 id="1-服务启动配置"><a href="#1-服务启动配置" class="headerlink" title="1 服务启动配置"></a>1 服务启动配置</h4><h5 id="1-作用"><a href="#1-作用" class="headerlink" title="1 作用"></a>1 作用</h5><ol><li>影响数据库的启动</li><li>影响客户端的功能</li></ol><h5 id="2-配置方式"><a href="#2-配置方式" class="headerlink" title="2 配置方式"></a>2 配置方式</h5><ol><li>配置文件</li><li>命令行启动参数：如果参数冲突，命令行参数会优先级高于配置文件</li><li>编译安装时配置</li></ol><h5 id="3-配置文件"><a href="#3-配置文件" class="headerlink" title="3 配置文件"></a>3 配置文件</h5><h6 id="1-加载顺序"><a href="#1-加载顺序" class="headerlink" title="1 加载顺序"></a>1 加载顺序</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 默认情况下，MySQL启动时，会依序读取配置文件，如果有重复选项，会以最后一个文件设置的为准</span><br><span class="line">// 查看配置文件加载顺序</span><br><span class="line">mysqld --help --verbose | grep my.cnf</span><br><span class="line"></span><br><span class="line">// 如果启动时手动配置了配置文件，则默认配置文件都不再读取</span><br><span class="line">--defaults-file=</span><br></pre></td></tr></table></figure><h6 id="2-格式"><a href="#2-格式" class="headerlink" title="2 格式"></a>2 格式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[module]</span><br><span class="line">key=value</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">module</span><br><span class="line">1. 服务端</span><br><span class="line">1. [mysqld]</span><br><span class="line">2. [mysqld_safe]</span><br><span class="line">3. [server]</span><br><span class="line">* 包括服务端所有</span><br><span class="line">2. 客户端</span><br><span class="line">1. [mysql]</span><br><span class="line">2. [mysqladmin]</span><br><span class="line">3. [mysqldump]</span><br><span class="line">4. [client]</span><br><span class="line">* 包括客户端所有</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h6 id="3-样板"><a href="#3-样板" class="headerlink" title="3 样板"></a>3 样板</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># -----------------服务端配置-------------------------</span><br><span class="line">[mysqld]</span><br><span class="line"># 管理用户</span><br><span class="line">user=mysql</span><br><span class="line"># 软件安装目录</span><br><span class="line">basedir=/app/mysql</span><br><span class="line"># 数据目录</span><br><span class="line">datadir=/data/mysql/data</span><br><span class="line"># 服务端保存 socket 文件路径</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line"># 端口号</span><br><span class="line">port=3306</span><br><span class="line"># 服务器id号 1~65535</span><br><span class="line">server_id=6</span><br><span class="line"># -----------------客户端配置-------------------------</span><br><span class="line">[mysql]</span><br><span class="line"># 客户端登录时寻找 socket 文件路径 </span><br><span class="line">socket=/tmp/mysql.sock</span><br></pre></td></tr></table></figure><h4 id="2-服务启动方式"><a href="#2-服务启动方式" class="headerlink" title="2 服务启动方式"></a>2 服务启动方式</h4><h5 id="1-init"><a href="#1-init" class="headerlink" title="1 init"></a>1 <code>init</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1 配置</span><br><span class="line">cp basedir/support-files/mysql.server /etc/init.d/mysqld</span><br><span class="line"></span><br><span class="line">// 2 启动</span><br><span class="line">service mysqld start 或者 /etc/init.d/mysqld start</span><br></pre></td></tr></table></figure><ul><li>其实是调用了 <code>basedir/support-files/mysql.server</code> 脚本<ol><li>读取 <code>/etc/my.cnf</code> 配置文件<ol start="2"><li>调用 <code>basedir/bin/mysqld_safe</code> 来启动 <code>mysqld</code></li></ol></li></ol></li></ul><h5 id="2-systemd"><a href="#2-systemd" class="headerlink" title="2 systemd"></a>2 <code>systemd</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 1 配置 /etc/systemd/system/mysqld.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=MySQL Server</span><br><span class="line">Documentation=man:mysqld(8)</span><br><span class="line">Documentation=http://dev.mysql.com/doc/refman/en/using-systemd.html</span><br><span class="line">After=network.target</span><br><span class="line">After=syslog.target</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">[Service]</span><br><span class="line">User=mysql</span><br><span class="line">Group=mysql</span><br><span class="line">ExecStart=basedir/bin/mysqld --defaults-file=/etc/my.cnf</span><br><span class="line">LimitNOFILE = 5000</span><br><span class="line"></span><br><span class="line">// 2 启动</span><br><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure><ul><li>其实是加载了 <code>/etc/systemd/system/mysqld.service</code><ol><li>读取 <code>/etc/my.cnf</code> 配置文件</li><li>启动 <code>mysqld</code></li></ol></li></ul><h5 id="3-手动"><a href="#3-手动" class="headerlink" title="3 手动"></a>3 手动</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 维护模式启动</span><br><span class="line">mysqld_safe --skip-grant-tables --skip-networking &amp;</span><br></pre></td></tr></table></figure><h2 id="2-2-Windows"><a href="#2-2-Windows" class="headerlink" title="2.2 Windows"></a>2.2 Windows</h2><h3 id="1-配置环境变量"><a href="#1-配置环境变量" class="headerlink" title="1 配置环境变量"></a>1 配置环境变量</h3><h3 id="2-在MySql目录下创建-ini-配置文件"><a href="#2-在MySql目录下创建-ini-配置文件" class="headerlink" title="2 在MySql目录下创建 .ini 配置文件"></a>2 在MySql目录下创建 <code>.ini</code> 配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 服务端配置</span><br><span class="line">[mysqld] </span><br><span class="line">basedir =</span><br><span class="line">datadir =</span><br><span class="line">port = 3306</span><br><span class="line">character-set-server=utf8mb4 // 1</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8mb4 // 2</span><br></pre></td></tr></table></figure><ul><li>配置结果：12皆不配置/配置1/配置2<br><img src="https://github.com/anyeansan/pics/raw/master/CS/SQL/%E4%B8%8D%E9%85%8D%E7%BD%AE12%E7%BB%93%E6%9E%9C.png" alt=""><br><img src="https://github.com/anyeansan/pics/raw/master/CS/SQL/%E9%85%8D%E7%BD%AE1%E7%BB%93%E6%9E%9C.png" alt=""><br><img src="https://github.com/anyeansan/pics/raw/master/CS/SQL/%E9%85%8D%E7%BD%AE2%E7%BB%93%E6%9E%9C.png" alt=""></li></ul><h3 id="3-初始化：在-basedir-bin-下执行命令"><a href="#3-初始化：在-basedir-bin-下执行命令" class="headerlink" title="3 初始化：在 basedir/bin 下执行命令"></a>3 初始化：在 <code>basedir/bin</code> 下执行命令</h3><ol><li><code>mysqld --initialize --console</code><ul><li>随机密码，并在控制台显示密码</li></ul></li><li><code>mysqld --initialize-insecure</code><ul><li>无密码</li></ul></li></ol><h3 id="4-服务"><a href="#4-服务" class="headerlink" title="4 服务"></a>4 服务</h3><ol><li><code>mysqld --install</code><ul><li>安装服务</li></ul></li><li><code>net start mysql</code><ul><li>启动服务</li></ul></li><li><code>net stop mysql</code><ul><li>停止服务</li></ul></li><li><code>mysqld remove</code> / <code>sc delete mysql</code><ul><li>删除服务</li></ul></li></ol><h1 id="三-MySQL-的连接"><a href="#三-MySQL-的连接" class="headerlink" title="三 MySQL 的连接"></a>三 MySQL 的连接</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol><li>Mysql 是 C/S 模型</li><li>使用 Mysql 需要安装服务端，连接服务端需要通过客户端</li></ol><h2 id="3-2-客户端"><a href="#3-2-客户端" class="headerlink" title="3.2 客户端"></a>3.2 客户端</h2><h3 id="1-MySQL自带的命令行工具-mysql-exe"><a href="#1-MySQL自带的命令行工具-mysql-exe" class="headerlink" title="1 MySQL自带的命令行工具 mysql.exe"></a>1 MySQL自带的命令行工具 <code>mysql.exe</code></h3><h4 id="1-连接方式"><a href="#1-连接方式" class="headerlink" title="1 连接方式"></a>1 连接方式</h4><table><thead><tr><th>命令</th><th>方式</th><th>说明</th></tr></thead><tbody><tr><td><code>mysql [-h Host] [-Pport] -uuser -p[password]</code></td><td>TCP/IP 方式</td><td>本地、远程</td></tr><tr><td><code>mysql -uuser -p[password] [-S /tmp/mysql.sock]</code></td><td>Socket 方式</td><td>本地</td></tr></tbody></table><h4 id="2-mysql-OPTION-（mysql-命令）"><a href="#2-mysql-OPTION-（mysql-命令）" class="headerlink" title="2 mysql [OPTION] （mysql 命令）"></a>2 <code>mysql [OPTION]</code> （mysql 命令）</h4><table><thead><tr><th>OPTION</th><th>说明</th></tr></thead><tbody><tr><td><code>-u user</code></td><td>用户名</td></tr><tr><td><code>-ppassword</code></td><td>密码和 <code>p</code> 之间不能有空格</td></tr><tr><td><code>-h host</code></td><td>主机地址</td></tr><tr><td><code>-P port</code></td><td>端口</td></tr><tr><td><code>-S Socket</code></td><td>Socket 文件路径</td></tr><tr><td><code>-e &quot;sql&quot;</code></td><td>免交互执行命令（即不连接数据库）</td></tr><tr><td><code>&lt; 脚本路径</code></td><td>导入 sql 脚本</td></tr><tr><td><code>-prompt 提示符</code></td><td>定义 mysql 提示符，默认为 <code>mysql&gt;</code></td></tr></tbody></table><h4 id="3-mysqldump-命令"><a href="#3-mysqldump-命令" class="headerlink" title="3 mysqldump 命令"></a>3 mysqldump 命令</h4><ul><li><code>mysqldump -hhost -Pport -uuser -ppassword --databse 库名 &gt; .sql路径</code><ul><li>不登录，导出某个数据库的备份（导出 sql 脚本）</li></ul></li></ul><h3 id="2-图形化工具（GUI）"><a href="#2-图形化工具（GUI）" class="headerlink" title="2 图形化工具（GUI）"></a>2 图形化工具（GUI）</h3><table><thead><tr><th align="center">软件</th><th align="center">windows</th><th align="center">mac</th><th align="center">linux</th><th align="center">功能</th><th align="center">免费版</th></tr></thead><tbody><tr><td align="center"><code>sequelpro</code></td><td align="center">&nbsp;</td><td align="center">√</td><td align="center">&nbsp;</td><td align="center">&nbsp;</td><td align="center">有</td></tr><tr><td align="center"><code>dbeaver</code></td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">&nbsp;</td><td align="center">有</td></tr><tr><td align="center"><code>navicat</code></td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">强</td><td align="center">&nbsp;</td></tr><tr><td align="center"><code>SQLyog</code></td><td align="center">√</td><td align="center">&nbsp;</td><td align="center">&nbsp;</td><td align="center">强</td><td align="center">&nbsp;</td></tr><tr><td align="center"><code>dbForge</code></td><td align="center">√</td><td align="center">&nbsp;</td><td align="center">&nbsp;</td><td align="center">强</td><td align="center">有</td></tr><tr><td align="center"><code>heidisql</code></td><td align="center">√</td><td align="center">&nbsp;</td><td align="center">&nbsp;</td><td align="center">&nbsp;</td><td align="center">有</td></tr><tr><td align="center"><code>TablePlus</code></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="四-MySQL-体系结构"><a href="#四-MySQL-体系结构" class="headerlink" title="四 MySQL 体系结构"></a>四 MySQL 体系结构</h1><h2 id="4-1-mysql-实例"><a href="#4-1-mysql-实例" class="headerlink" title="4.1 mysql 实例"></a>4.1 mysql 实例</h2><ol><li><code>mysqld</code>（老板）</li><li><code>master thread</code>（经理）</li><li><code>other thread</code>（员工）</li><li><code>预分配内存</code>（办公区）</li></ol><h2 id="4-2-MySQL-逻辑架构"><a href="#4-2-MySQL-逻辑架构" class="headerlink" title="4.2 MySQL 逻辑架构"></a>4.2 MySQL 逻辑架构</h2><h3 id="1-连接层"><a href="#1-连接层" class="headerlink" title="1 连接层"></a>1 连接层</h3><ol><li>提供连接协议：TCP/IP 、SOCKET</li><li>提供验证：用户、密码、IP、Port、SOCKET …</li><li>提供专用连接线程：接收用户SQL，返回结果<ul><li><code>show processlist</code><ul><li>查看连接线程</li></ul></li></ul></li></ol><h3 id="2-SQL-层（服务层）"><a href="#2-SQL-层（服务层）" class="headerlink" title="2 SQL 层（服务层）"></a>2 SQL 层（服务层）</h3><ol><li>接收上层传送的SQL语句</li><li>语法验证模块：验证语句语法,是否满足SQL_MODE</li><li>语义检查：判断SQL语句的类型（DQL、DML …）</li><li>权限检查：用户对库表有没有权限</li><li>解析器：语句执行前进行预处理，生成解析树(执行计划)，说白了就是生成多种执行方案</li><li>优化器：根据解析器得出的多种执行计划，进行判断，选择最优的执行计划<ul><li>代价模型：资源（CPU IO MEM）的耗损评估性能好坏</li></ul></li><li>执行器：根据最优执行计划，执行SQL语句，产生执行结果（在磁盘上）</li><li>提供查询缓存（默认没开启）：会使用redis tair替代查询缓存功能</li><li>提供日志记录（默认没开启）：二进制日志 <code>binlog</code> 、审计日志、通用日志 …</li></ol><h3 id="3-存储引擎层"><a href="#3-存储引擎层" class="headerlink" title="3 存储引擎层"></a>3 存储引擎层</h3><ol><li>根据SQL层执行的结果，从磁盘上拿数据</li><li>将16进制的磁盘数据，返回给 SQL 层结构化成表</li><li>由连接层的专用线程返回给用户</li></ol><h2 id="4-3-MySQL-逻辑存储结构"><a href="#4-3-MySQL-逻辑存储结构" class="headerlink" title="4.3 MySQL 逻辑存储结构"></a>4.3 MySQL 逻辑存储结构</h2><ol><li>库（database）<ol><li>库名</li><li>库属性（字符集，校对集(排序规则)）</li></ol></li><li>表（table）<ol><li>表名</li><li>表属性（存储引擎，字符集，校对集(排序规则)）</li></ol></li><li>列（column）/ 字段（field） <ol><li>列名</li><li>列属性（数据类型，约束，…）</li></ol></li><li>行（row）/ 记录（record）</li></ol><h2 id="4-4-MySQL-物理存储结构"><a href="#4-4-MySQL-物理存储结构" class="headerlink" title="4.4 MySQL 物理存储结构"></a>4.4 MySQL 物理存储结构</h2><ol><li>库（目录）</li><li>表<ol><li><code>MyISAM</code><ul><li><code>.frm</code> ：存储表结构（列名，列属性）</li><li><code>.MYD</code> ：存储数据记录</li><li><code>.MYI</code> ：存储索引</li></ul></li><li><code>InnoDB</code><ul><li><code>.frm</code> ：存储表结构（列名，列属性）</li><li><code>.ibd</code> ：存储数据记录和索引</li><li><code>.opt</code> ：存储库属性</li><li><code>ibdata1</code> ：数据字段信息</li></ul></li></ol></li><li>InnoDB，一般情况下（非分区表）<ol><li>段：一个表就是一个段，一个段由多个区构成</li><li>区：一个区由64个连续的页构造，1M 大小（ <code>64*16=1024</code> ）</li><li>页：一个页大小为 16 kb</li></ol></li></ol><h1 id="五-用户-amp-权限"><a href="#五-用户-amp-权限" class="headerlink" title="五 用户 &amp; 权限"></a>五 用户 &amp; 权限</h1><h2 id="5-1-用户"><a href="#5-1-用户" class="headerlink" title="5.1 用户"></a>5.1 用户</h2><h3 id="1-用户定义"><a href="#1-用户定义" class="headerlink" title="1 用户定义"></a>1 用户定义</h3><ul><li><code>user@&#39;Host&#39;</code><ul><li><code>Host</code>：白名单，即此用户可以在哪个主机连接数据库</li></ul></li></ul><table><thead><tr><th>Host（例）</th><th>说明</th></tr></thead><tbody><tr><td><code>localhost</code></td><td>本地</td></tr><tr><td><code>127.0.0.1</code></td><td>本地</td></tr><tr><td><code>%</code></td><td>任意网段</td></tr><tr><td><code>10.0.0.%</code></td><td><code>10.0.0.0~10.0.0.255</code></td></tr><tr><td><code>10.0.0.5%</code></td><td><code>10.0.0.50~10.0.0.59</code></td></tr><tr><td><code>10.0.0.0/255.255.255.0</code></td><td><code>10.0.0.0~10.0.0.255</code></td></tr></tbody></table><h3 id="2-用户管理"><a href="#2-用户管理" class="headerlink" title="2 用户管理"></a>2 用户管理</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>select user,host,authentication_string from mysql.user</code></td><td>查询用户名，主机，密码（用户信息存储在数据库 <code>mysql</code> 中 的 <code>user</code> 表）</td></tr><tr><td><code>create user user@&#39;Host&#39; [identified by &#39;password&#39;]</code></td><td>创建用户</td></tr><tr><td><code>drop user user@&#39;Host&#39;</code></td><td>删除用户</td></tr></tbody></table><h3 id="3-修改用户密码"><a href="#3-修改用户密码" class="headerlink" title="3 修改用户密码"></a>3 修改用户密码</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>mysqladmin -u用户名 -p[旧密码] password 新密码</code></td><td>不需登录</td></tr><tr><td><code>alter user &#39;用户名&#39; @&#39;localhost&#39; identified by &#39;新密码&#39;</code></td><td>需要登录</td></tr><tr><td><code>set password for 用户名 = &#39;新密码&#39;</code></td><td>修改指定用户密码</td></tr><tr><td><code>set password = &#39;新密码&#39;</code></td><td>修改自己密码</td></tr></tbody></table><ul><li>忘记 root 密码<ol><li>关闭数据库</li><li>维护模式启动数据库<ul><li><code>mysqld_safe --skip-grant-tables --skip-networking &amp;</code></li></ul></li><li>登录并修改密码（如果修改密码报错，则刷新权限）<ul><li><code>flush privileges</code></li></ul></li></ol></li></ul><h2 id="5-2-权限"><a href="#5-2-权限" class="headerlink" title="5.2 权限"></a>5.2 权限</h2><h3 id="1-权限列表"><a href="#1-权限列表" class="headerlink" title="1 权限列表"></a>1 权限列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1 基本权限</span><br><span class="line">SELECT，INSERT，UPDATE，DELETE，CREATE，DROP，ALTER，SHOW DATABASES，CREATE USER，CREATE TEMPORARY TABLES，RELOAD，SHUTDOWN，PROCESS，FILE，REFERENCE，INDEX，SUPER，EXECUTE，REPLICATION，SLAVE，REPLICATION，CLIENT，EVENT，TRIGGER，LOCK TABLES，CREATE VIEW，SHOW VIEW，CREATE ROUTINE，ALTER ROUTINE，CREATE TABLESPACE，</span><br><span class="line"></span><br><span class="line">// 2 特殊权限</span><br><span class="line">// 2.1 所有权限</span><br><span class="line">ALL privileges</span><br><span class="line"></span><br><span class="line">// 2.2 可以给别的用户授权的权限，超级管理员才具备</span><br><span class="line">with grant option</span><br></pre></td></tr></table></figure><h3 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2 权限管理"></a>2 权限管理</h3><h4 id="1-查看权限"><a href="#1-查看权限" class="headerlink" title="1 查看权限"></a>1 查看权限</h4><ul><li><code>show grants [for user@&#39;Host&#39;]</code><ul><li>查看自己（或指定用户）的权限</li></ul></li></ul><h4 id="2-授权"><a href="#2-授权" class="headerlink" title="2 授权"></a>2 授权</h4><ul><li><code>grant 权限 on 目标 to 用户 [identified by &#39;password&#39;] [with grant option]</code><ul><li>权限<ol><li><code>ALL privileges</code></li><li>权限列表，以逗号分隔</li></ol></li><li>目标<ol><li><code>*.*</code><ul><li>所有数据库的所有表</li></ul></li><li><code>database.*</code><ul><li>指定数据库的所有表</li></ul></li><li><code>database.table</code><ul><li>指定数据库的指定表</li></ul></li></ol></li></ul></li></ul><h4 id="3-回收权限"><a href="#3-回收权限" class="headerlink" title="3 回收权限"></a>3 回收权限</h4><ul><li><code>revoke 权限 on 目标 from user@&#39;Host&#39;</code></li></ul><h1 id="六-MySQL-内置命令"><a href="#六-MySQL-内置命令" class="headerlink" title="六 MySQL 内置命令"></a>六 MySQL 内置命令</h1><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>help</code></td><td>打印帮助</td></tr><tr><td><code>\c</code></td><td>放弃本条语句，类似 <code>ctrl + c</code></td></tr><tr><td><code>quit</code> <code>exit</code> <code>ctrl+d</code> <code>\q</code></td><td>退出</td></tr><tr><td><code>\G</code></td><td>竖形显示数据</td></tr><tr><td><code>source 脚本路径</code></td><td>导入SQL脚本</td></tr><tr><td><code>tee 路径</code></td><td>将输入的sql语句存储到本地</td></tr><tr><td><code>prompt 提示符</code></td><td>定义 mysql 提示符，默认为 <code>mysql&gt;</code></td></tr><tr><td><code>delimiter 符号</code></td><td>定义结束符，默认为<code>;</code></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-概念&quot;&gt;&lt;a href=&quot;#1-1-概念&quot; class=&quot;headerlink&quot; title=&quot;1.1 概
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="SQL" scheme="https://anyeansan.github.io/categories/CS/SQL/"/>
    
    
  </entry>
  
  <entry>
    <title>jQuery</title>
    <link href="https://anyeansan.github.io/2020/11/08/UI/jQuery/"/>
    <id>https://anyeansan.github.io/2020/11/08/UI/jQuery/</id>
    <published>2020-11-08T13:12:55.000Z</published>
    <updated>2020-11-08T13:13:22.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-jQuery-概述"><a href="#一-jQuery-概述" class="headerlink" title="一 jQuery 概述"></a>一 jQuery 概述</h1><h2 id="1-1-jQuery-中的顶级对象"><a href="#1-1-jQuery-中的顶级对象" class="headerlink" title="1.1  jQuery 中的顶级对象 $"></a>1.1  jQuery 中的顶级对象 <code>$</code></h2><ol><li><code>$</code> 是 <code>jQuery</code> 的别称，在代码中可以使用 <code>jQuery</code> 代替</li><li><code>$</code> 是 jQuery 的顶级对象，相当于原生 JavaScript 中的 <code>window</code></li></ol><h2 id="1-2-jQuery-对象和-DOM-对象"><a href="#1-2-jQuery-对象和-DOM-对象" class="headerlink" title="1.2 jQuery 对象和 DOM 对象"></a>1.2 jQuery 对象和 DOM 对象</h2><ol><li>用原生 JS 获取的是 DOM 对象</li><li>jQuery 方法获取的是 jQuery 对象，本质是利用 <code>$</code> 对 DOM 对象包装后产生的对象，是一个类数组</li><li>隐式迭代：对 jQuery 对象执行操作时，会给内部所有 DOM 元素进行操作</li></ol><table><thead><tr><th>转换</th><th>方式</th></tr></thead><tbody><tr><td><strong>DOM → jQuery</strong></td><td><code>jQuery = $(DOM)</code></td></tr><tr><td><strong>jQuery → DOM</strong></td><td><code>DOM = jQuery[0]</code><br><code>DOM = jQuery.get(0)</code></td></tr></tbody></table><h2 id="1-3"><a href="#1-3" class="headerlink" title="1.3 $()"></a>1.3 <code>$()</code></h2><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td><code>$()</code></td><td>页面 DOM 加载事件，相当于原生 js 中的 <code>DOMContentLoaded</code> 事件</td></tr><tr><td><code>$(DOM)</code></td><td>将 DOM 对象转为 jQuery 对象</td></tr><tr><td><code>$(selector)</code></td><td>使用选择器获取 jQeury 对象</td></tr><tr><td><code>$(Html)</code></td><td>新建一个指定 Html 标签的 jQury 对象</td></tr></tbody></table><h1 id="二-选择器"><a href="#二-选择器" class="headerlink" title="二 选择器"></a>二 选择器</h1><h2 id="2-1-基础选择器"><a href="#2-1-基础选择器" class="headerlink" title="2.1 基础选择器"></a>2.1 基础选择器</h2><table><thead><tr><th>选择器</th><th>说明</th></tr></thead><tbody><tr><td><code>*</code></td><td>通配选择器</td></tr><tr><td><code>#id</code></td><td>ID 选择器</td></tr><tr><td><code>.class</code></td><td>类选择器</td></tr><tr><td><code>html</code></td><td>标签选择器</td></tr><tr><td><code>s1,s2,...</code></td><td>并集</td></tr><tr><td><code>s1.s2</code></td><td>交集</td></tr></tbody></table><h2 id="2-2-层级选择器"><a href="#2-2-层级选择器" class="headerlink" title="2.2 层级选择器"></a>2.2 层级选择器</h2><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td><code>A E</code></td><td>后代元素</td></tr><tr><td><code>A &gt; E</code></td><td>子元素</td></tr><tr><td><code>A ~ E</code></td><td>兄弟元素</td></tr><tr><td><code>A + E</code></td><td>下一个兄弟元素</td></tr></tbody></table><h2 id="2-3-属性选择器"><a href="#2-3-属性选择器" class="headerlink" title="2.3 属性选择器"></a>2.3 属性选择器</h2><table><thead><tr><th>属性选择器</th><th>说明</th></tr></thead><tbody><tr><td><code>[attr]</code></td><td>带有 <code>attr</code> 属性的元素</td></tr><tr><td><code>[attr=value]</code></td><td><code>attr</code> 属性值为 <code>value</code> 的元素</td></tr><tr><td><code>[attr!=value]</code></td><td><code>attr</code> 属性值不为 <code>value</code> 的元素</td></tr><tr><td><code>[attr^=value]</code></td><td><code>attr</code> 属性值以 <code>value</code> 开头的元素</td></tr><tr><td><code>[attr$=value]</code></td><td><code>attr</code> 属性值以 <code>value</code> 结尾的元素</td></tr><tr><td><code>[attr*=value]</code></td><td><code>attr</code> 属性值包含 <code>value</code> 的元素</td></tr><tr><td><code>[s1][s2][sN]</code></td><td>相当于 <code>&amp;&amp;</code></td></tr></tbody></table><h2 id="2-4-过滤选择器"><a href="#2-4-过滤选择器" class="headerlink" title="2.4 过滤选择器"></a>2.4 过滤选择器</h2><table><thead><tr><th>过滤选择器</th><th>说明</th></tr></thead><tbody><tr><td><code>:first</code></td><td>第一个</td></tr><tr><td><code>:last</code></td><td>最后一个</td></tr><tr><td><code>:not(s)</code></td><td>非</td></tr><tr><td><code>:odd</code></td><td>奇数索引</td></tr><tr><td><code>:even</code></td><td>偶数索引</td></tr><tr><td><code>:eq(index)</code></td><td>等于索引</td></tr><tr><td><code>:gt(index)</code></td><td>大于索引</td></tr><tr><td><code>:lt(index)</code></td><td>小于索引</td></tr></tbody></table><h2 id="2-5-子元素选择器"><a href="#2-5-子元素选择器" class="headerlink" title="2.5 子元素选择器"></a>2.5 子元素选择器</h2><table><thead><tr><th>子元素选择器</th><th>说明</th></tr></thead><tbody><tr><td><code>:first-child</code></td><td>第一个子元素</td></tr><tr><td><code>:last-child</code></td><td>最后一个子元素</td></tr><tr><td><code>:only-child</code></td><td>唯一的子元素</td></tr><tr><td><code>:nth-child(expr)</code></td><td><code>expr</code> 可以是 <code>an+b, odd, even</code></td></tr></tbody></table><h2 id="2-6-内容选择器"><a href="#2-6-内容选择器" class="headerlink" title="2.6 内容选择器"></a>2.6 内容选择器</h2><table><thead><tr><th>内容选择器</th><th>说明</th></tr></thead><tbody><tr><td><code>:empty</code></td><td>不包含子元素或者文本的元素</td></tr><tr><td><code>:contains(text)</code></td><td>包含指定文本的元素</td></tr><tr><td><code>:has(selector)</code></td><td>包含选择器所匹配元素的元素</td></tr><tr><td><code>:parent</code></td><td>含有子元素或者文本的元素</td></tr></tbody></table><h2 id="2-7-可见性选择器"><a href="#2-7-可见性选择器" class="headerlink" title="2.7 可见性选择器"></a>2.7 可见性选择器</h2><table><thead><tr><th>可见性选择器</th><th>说明</th></tr></thead><tbody><tr><td><code>:hidden</code></td><td>所有不可见元素，<code>display:none, type=hidden ...</code></td></tr><tr><td><code>:visible</code></td><td>所有可见元素</td></tr></tbody></table><h2 id="2-8-表单选择器"><a href="#2-8-表单选择器" class="headerlink" title="2.8 表单选择器"></a>2.8 表单选择器</h2><table><thead><tr><th>表单选择器</th><th>说明</th></tr></thead><tbody><tr><td><code>:input</code></td><td>匹配所有 <code>input textarea select button</code> 元素</td></tr><tr><td><code>:Type</code></td><td>匹配 <code>input</code> 指定类型的元素，如 <code>:text :radio ...</code></td></tr></tbody></table><h2 id="2-9-表单属性选择器"><a href="#2-9-表单属性选择器" class="headerlink" title="2.9 表单属性选择器"></a>2.9 表单属性选择器</h2><table><thead><tr><th>表单属性选择器</th><th>说明</th></tr></thead><tbody><tr><td><code>:enabled</code></td><td>所有可用元素</td></tr><tr><td><code>:disabled</code></td><td>所有不可用元素</td></tr><tr><td><code>:checked</code></td><td>单/复选框的所有选中元素</td></tr><tr><td><code>:selected</code></td><td>下拉框所有选中的 <code>option</code> 元素</td></tr></tbody></table><h2 id="2-10-筛选方法"><a href="#2-10-筛选方法" class="headerlink" title="2.10 筛选方法"></a>2.10 筛选方法</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>选择器能完成的，筛选提供相同方法也能完成</li><li>区别在于选择器直接获取筛选后的结果，方法先获取原结果，然后再筛选<ol><li><code>$(&quot;div:first&quot;)</code>：直接获取第一个 <code>div</code></li><li><code>$(&quot;div&quot;).first()</code>：先获取所有 <code>div</code>，之后筛选出第一个</li></ol></li></ol><h3 id="2-查找"><a href="#2-查找" class="headerlink" title="2 查找"></a>2 查找</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>parent()</code></td><td>父元素</td></tr><tr><td>childre([selector])</td><td>所有匹配子元素</td></tr><tr><td><code>find(selector)</code></td><td>查找匹配的元素</td></tr><tr><td><code>siblings([selector])</code></td><td>所有兄弟元素</td></tr><tr><td><code>next([selector])</code></td><td>下一个兄弟元素</td></tr><tr><td><code>nextAll([selector])</code></td><td>之后的所有兄弟元素</td></tr><tr><td><code>prev([selector])</code></td><td>上一个兄弟元素</td></tr><tr><td><code>prevAll([selector])</code></td><td>之前的所有兄弟元素</td></tr></tbody></table><h3 id="3-过滤"><a href="#3-过滤" class="headerlink" title="3 过滤"></a>3 过滤</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>eq(index)</code></td><td>获取指定索引元素</td></tr><tr><td><code>first()</code></td><td>第一个</td></tr><tr><td><code>last()</code></td><td>最后一个</td></tr><tr><td><code>filter(expr)</code></td><td>获取匹配的元素</td></tr></tbody></table><h1 id="三-文档处理"><a href="#三-文档处理" class="headerlink" title="三 文档处理"></a>三 文档处理</h1><h2 id="3-1-元素遍历"><a href="#3-1-元素遍历" class="headerlink" title="3,1 元素遍历"></a>3,1 元素遍历</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>$(Selector).each(callback)</code></td><td>遍历 jQuery 对象</td></tr><tr><td><code>$.each(obj, callback)</code></td><td>遍历任意对象</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">callback:</span><br><span class="line">function(index, domEle) &#123;</span><br><span class="line">index：元素的索引</span><br><span class="line">domEle：遍历的元素，相当于 this，是 DOM 对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-添删改"><a href="#3-2-添删改" class="headerlink" title="3.2 添删改"></a>3.2 添删改</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>append(ele)</code></td><td>追加到元素内尾部，父子关系</td></tr><tr><td><code>prepend(ele)</code></td><td>追加到元素内首部，父子关系</td></tr><tr><td><code>after(ele)</code></td><td>添加到元素后面，兄弟关系</td></tr><tr><td><code>before(ele)</code></td><td>添加到元素前面，兄弟关系</td></tr><tr><td><code>remove()</code></td><td>删除自已及后代节点，移除绑定事件和绑定数据</td></tr><tr><td><code>detach()</code></td><td>删除自已及后代节点，保留绑定事件和绑定数据</td></tr><tr><td><code>empty()</code></td><td>删除所有后代节点</td></tr><tr><td><code>replaceWith(content)</code></td><td>将所有匹配的元素替换成指定的 HTML 或 DOM 元素</td></tr><tr><td><code>replaceAll(selector)</code></td><td>替换所有匹配的元素</td></tr></tbody></table><h2 id="3-3-复制"><a href="#3-3-复制" class="headerlink" title="3.3 复制"></a>3.3 复制</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>clone()</code></td><td>只复制样式，不复制行为</td></tr><tr><td><code>clone(true)</code></td><td>既复制样式，又复制行为</td></tr></tbody></table><h1 id="四-文本"><a href="#四-文本" class="headerlink" title="四 文本"></a>四 文本</h1><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>html([value])</code></td><td>获取或设置元素内容，对应 <code>innerHTML</code></td></tr><tr><td><code>text([value])</code></td><td>获取或设置元素内容，对应 <code>innerText</code></td></tr><tr><td><code>val([value])</code></td><td>获取或设置元素 <code>value</code> 属性的值</td></tr></tbody></table><h1 id="五-数据缓存"><a href="#五-数据缓存" class="headerlink" title="五 数据缓存"></a>五 数据缓存</h1><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>data(key)</code></td><td>获取绑定数据</td></tr><tr><td><code>data(key,value)</code></td><td>绑定数据，页面刷新移除</td></tr><tr><td><code>removeData(key)</code></td><td>移除绑定数据</td></tr></tbody></table><h1 id="六-属性"><a href="#六-属性" class="headerlink" title="六 属性"></a>六 属性</h1><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>attr(key)</code></td><td>获取属性的值（自定义属性和标准属性）</td></tr><tr><td><code>attr(key,value)</code></td><td>设置属性的值</td></tr><tr><td><code>removeAttr(key)</code></td><td>删除属性</td></tr><tr><td><code>prop(key)</code></td><td>获取属性的值（Html 标准属性）</td></tr><tr><td><code>prop(key,value)</code></td><td>设置属性的值</td></tr><tr><td><code>removeProp(key)</code></td><td>删除属性</td></tr></tbody></table><h1 id="七-CSS"><a href="#七-CSS" class="headerlink" title="七 CSS"></a>七 CSS</h1><h2 id="7-1-样式"><a href="#7-1-样式" class="headerlink" title="7.1 样式"></a>7.1 样式</h2><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td><code>css(key, value)</code></td><td>添加属性和值</td></tr><tr><td>css({key:value, key:value, …})</td><td>以对象形式添加多组属性和值</td></tr><tr><td><code>addClass(class)</code></td><td>添加类</td></tr><tr><td><code>removeClass(class)</code></td><td>删除类</td></tr><tr><td><code>toggleClass(class)</code></td><td>切换，有类则删除，无类则添加</td></tr><tr><td><code>hasClass(class)</code></td><td>判断是否有指定类</td></tr></tbody></table><h2 id="7-2-位置"><a href="#7-2-位置" class="headerlink" title="7.2 位置"></a>7.2 位置</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>offset()</code></td><td>获取元素相对于文档的偏移，返回 JSON 对象，有两个属性 <code>top left</code></td></tr><tr><td><code>offset({top:value, left:value})</code></td><td>设置元素相对于文档的偏移</td></tr><tr><td><code>position()</code></td><td>获取元素相对于有定位祖先元素的偏移，没有则相对于文档偏移，返回 JSON 对象：<code>top left</code></td></tr><tr><td><code>scrollTop([value])</code></td><td>获取或设置元素上边被卷去的距离</td></tr><tr><td><code>scrollLeft([value])</code></td><td>获取或设置元素左边被卷去的距离</td></tr></tbody></table><h2 id="7-3-尺寸"><a href="#7-3-尺寸" class="headerlink" title="7.3 尺寸"></a>7.3 尺寸</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>width([value])</code></td><td>获取或设置元素宽度，<code>content-box</code></td></tr><tr><td><code>height([value])</code></td><td>获取或设置元素高度，<code>content-box</code></td></tr><tr><td><code>innerWidth()</code></td><td>获取 <code>padding-box</code> 宽度</td></tr><tr><td><code>innerHeight()</code></td><td>获取 <code>padding-box</code> 高度</td></tr><tr><td><code>outerWidth()</code></td><td>获取 <code>border-box</code> 宽度</td></tr><tr><td><code>outerHeight()</code></td><td>获取 <code>border-box</code> 高度</td></tr><tr><td><code>outerWidth(true)</code></td><td>获取 <code>margin-box</code> 宽度</td></tr><tr><td><code>outerHeight(true)</code></td><td>获取 <code>margin-box</code> 高度</td></tr></tbody></table><h1 id="八-效果"><a href="#八-效果" class="headerlink" title="八 效果"></a>八 效果</h1><h2 id="8-1-显示隐藏"><a href="#8-1-显示隐藏" class="headerlink" title="8.1 显示隐藏"></a>8.1 显示隐藏</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>show([speed], [easing], [callback])</code></td><td>显示元素</td></tr><tr><td><code>hide([speed], [easing], [callback])</code></td><td>隐藏元素</td></tr></tbody></table><ol><li><code>speed</code><ol><li><code>slow normal fast</code></li><li>毫秒值</li></ol></li><li><code>easing</code><ol><li><code>swing</code> ：默认，慢 → 快 → 慢</li><li><code>linear</code>：匀速</li></ol></li></ol><h2 id="8-2-滑动"><a href="#8-2-滑动" class="headerlink" title="8.2 滑动"></a>8.2 滑动</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>slideDown([speed], [easing], [callback])</code></td><td>向下滑动</td></tr><tr><td><code>slideUp([speed], [easing], [callback])</code></td><td>向上滑动</td></tr><tr><td><code>slideToggle([speed], [easing], [callback])</code></td><td>滑动切换</td></tr></tbody></table><h2 id="8-3-淡入淡出"><a href="#8-3-淡入淡出" class="headerlink" title="8.3 淡入淡出"></a>8.3 淡入淡出</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>fadeIn([speed], [easing], [callback])</code></td><td>淡入显示</td></tr><tr><td><code>fadeOut([speed], [easing], [callback])</code></td><td>淡出隐藏</td></tr><tr><td><code>fadeToggle([speed], [easing], [callback])</code></td><td>淡入淡出切换</td></tr><tr><td><code>fadeTo([speed], opacity, [easing], [callback])</code></td><td>调整到指定透明度，<code>opacity</code>：0~1，必须</td></tr></tbody></table><h2 id="8-4-自定义动画"><a href="#8-4-自定义动画" class="headerlink" title="8.4 自定义动画"></a>8.4 自定义动画</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>animate(params, [speed], [easing], [callback])</code></td><td>创建动画，<code>params</code>：对象形式的样式属性和值</td></tr><tr><td><code>stop([clearQueue], [gotoEnd])</code></td><td>停止所有在指定元素上正在运行的动画</td></tr><tr><td><code>delay(duration, [queueName])</code></td><td>动画延迟时间</td></tr></tbody></table><h1 id="九-事件"><a href="#九-事件" class="headerlink" title="九 事件"></a>九 事件</h1><h2 id="9-1-页面加载"><a href="#9-1-页面加载" class="headerlink" title="9.1 页面加载"></a>9.1 页面加载</h2><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td><code>$(document).ready(fn)</code></td><td>标准 API，相当于原生 js 中的 <code>DOMContentLoaded</code> 事件</td></tr><tr><td><code>$(fn)</code></td><td>简化版</td></tr></tbody></table><h2 id="9-2-事件绑定"><a href="#9-2-事件绑定" class="headerlink" title="9.2 事件绑定"></a>9.2 事件绑定</h2><h3 id="1-普通方式"><a href="#1-普通方式" class="headerlink" title="1 普通方式"></a>1 普通方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).type(fn);</span><br></pre></td></tr></table></figure><h3 id="2-on"><a href="#2-on" class="headerlink" title="2 on"></a>2 on</h3><ol><li><p>一个事件对应一个处理函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(selector).on(</span><br><span class="line">    &#123;</span><br><span class="line">type: fn,</span><br><span class="line">type: fn,</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>多个事件对应一个处理函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).on(&quot;type type type ...&quot;, fn);</span><br></pre></td></tr></table></figure></li><li><p>事件委托</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(selector).on(types, childSelector, fn);</span><br><span class="line">// 事件绑定在父元素上，但由子元素触发</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-off"><a href="#3-off" class="headerlink" title="3 off"></a>3 off</h3><ol><li><p>解绑元素所有事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).off()</span><br></pre></td></tr></table></figure></li><li><p>解绑元素指定事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).off(type)</span><br></pre></td></tr></table></figure></li><li><p>解绑委托事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).off(type, childSelector)</span><br></pre></td></tr></table></figure></li></ol><h2 id="9-3-事件处理"><a href="#9-3-事件处理" class="headerlink" title="9.3 事件处理"></a>9.3 事件处理</h2><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td><code>$(selector).hover(over, [out])</code></td><td><code>mouseenter</code> 触发第一个函数，<code>mouseleave</code> 触发第二个函数，如果只有一个函数，则都触发它</td></tr><tr><td><code>$(selector).trigger(type)</code></td><td>自动触发指定事件</td></tr><tr><td><code>$(selector).triggerHandler(type)</code></td><td>自动触发指定事件，不会触发元素默认行为</td></tr></tbody></table><h1 id="十-工具"><a href="#十-工具" class="headerlink" title="十 工具"></a>十 工具</h1><h2 id="10-1-拷贝对象"><a href="#10-1-拷贝对象" class="headerlink" title="10.1 拷贝对象"></a>10.1 拷贝对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.extend([deep], target, srcObj1, srcOjb2, ...)</span><br></pre></td></tr></table></figure><h2 id="10-2-字符串去空格"><a href="#10-2-字符串去空格" class="headerlink" title="10.2 字符串去空格"></a>10.2 字符串去空格</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.trim(str)</span><br></pre></td></tr></table></figure><h2 id="10-3-多库共存"><a href="#10-3-多库共存" class="headerlink" title="10.3 多库共存"></a>10.3 多库共存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 修改 $ 为自定义变量</span><br><span class="line">let newSymbol = $.noConflict()</span><br></pre></td></tr></table></figure><h1 id="十一-AJAX"><a href="#十一-AJAX" class="headerlink" title="十一 AJAX"></a>十一 AJAX</h1><h2 id="11-1-Ajax-请求"><a href="#11-1-Ajax-请求" class="headerlink" title="11.1 Ajax 请求"></a>11.1 Ajax 请求</h2><h3 id="1-ajax"><a href="#1-ajax" class="headerlink" title="1 $.ajax()"></a>1 <code>$.ajax()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">url: &quot;&quot;,</span><br><span class="line">type: &quot;&quot;,</span><br><span class="line">data: &quot;&quot;,</span><br><span class="line">async: true,</span><br><span class="line">dataType: &quot;&quot;,</span><br><span class="line">contentType: &quot;&quot;,</span><br><span class="line">beforeSend: function(XHR) &#123;</span><br><span class="line">XHR：XMLHttpRequest 对象</span><br><span class="line">&#125;,</span><br><span class="line">success: function(data,textStatus,XHR)&#123;</span><br><span class="line">data：响应数据</span><br><span class="line">textStatus：描述状态的字符串</span><br><span class="line">&#125;,</span><br><span class="line">error: function(XHR,textStatus,errorThrown)&#123;</span><br><span class="line">textStatus：错误信息</span><br><span class="line">errorThrown：异常对象</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>type</code></td><td>请求方式，默认 <code>GET</code></td></tr><tr><td><code>url</code></td><td>请求地址</td></tr><tr><td><code>data</code></td><td>请求参数，<code>key=value&amp;key=value</code> 字符串或者 JSON</td></tr><tr><td><code>dataType</code></td><td>响应数据类型，<code>xml html json text script jsonp ...</code></td></tr><tr><td><code>async</code></td><td>是否异步，默认 <code>true</code></td></tr><tr><td><code>contentType</code></td><td>请求参数编码类型，默认 <code>application/x-www-form-urlencoded</code></td></tr><tr><td><code>beforeSend</code></td><td>发送请求前修改 <code>XMLHttpRequest</code> 对象的函数</td></tr><tr><td><code>success</code></td><td>请求成功后的回调函数</td></tr><tr><td><code>error</code></td><td>请求失败时调用此函数</td></tr></tbody></table><h3 id="2-get"><a href="#2-get" class="headerlink" title="2 $.get()"></a>2 <code>$.get()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.get(url, [data], [callback], [dataType])</span><br></pre></td></tr></table></figure><h3 id="3-post"><a href="#3-post" class="headerlink" title="3 $.post()"></a>3 <code>$.post()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.get(post, [data], [callback], [dataType])</span><br></pre></td></tr></table></figure><h2 id="11-2-表单序列化"><a href="#11-2-表单序列化" class="headerlink" title="11.2 表单序列化"></a>11.2 表单序列化</h2><h3 id="1-serialize"><a href="#1-serialize" class="headerlink" title="1 serialize()"></a>1 <code>serialize()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;form&quot;).serialize()</span><br></pre></td></tr></table></figure><ol><li>必须使用 <code>&lt;form&gt;</code> 元素</li><li>表单项必须有 <code>name</code> 属性</li><li>将表单中所有项拼凑成一个字符串，格式为 <code>key=value&amp;key=value</code></li></ol><h3 id="2-serializeArray"><a href="#2-serializeArray" class="headerlink" title="2 serializeArray()"></a>2 <code>serializeArray()</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;form&quot;).serializeArray()</span><br></pre></td></tr></table></figure><ol><li>必须使用 <code>&lt;form&gt;</code> 元素</li><li>表单项必须有 <code>name</code> 属性</li><li>将表单中所有项拼凑成一个 <code>json</code> 数组，格式 <code>[{key:value}, {key:value}]</code></li></ol><h2 id="11-3-Ajax-事件"><a href="#11-3-Ajax-事件" class="headerlink" title="11.3 Ajax 事件"></a>11.3 Ajax 事件</h2><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td><code>ajaxStart</code></td><td>AJAX 请求开始时触发</td></tr><tr><td><code>ajaxComplete</code></td><td>AJAX 请求完成时触发</td></tr><tr><td><code>ajaxSuccess</code></td><td>AJAX 请求成功时触发</td></tr><tr><td><code>ajaxError</code></td><td>AJAX 请求失败时触发</td></tr></tbody></table><h2 id="11-4-跨域"><a href="#11-4-跨域" class="headerlink" title="11.4 跨域"></a>11.4 跨域</h2><ol><li><code>$.getJSON()</code></li><li><code>$.getScript()</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-jQuery-概述&quot;&gt;&lt;a href=&quot;#一-jQuery-概述&quot; class=&quot;headerlink&quot; title=&quot;一 jQuery 概述&quot;&gt;&lt;/a&gt;一 jQuery 概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-jQuery-中的顶级对象&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="UI" scheme="https://anyeansan.github.io/categories/CS/UI/"/>
    
    
  </entry>
  
  <entry>
    <title>AJAX</title>
    <link href="https://anyeansan.github.io/2020/11/08/UI/AJAX/"/>
    <id>https://anyeansan.github.io/2020/11/08/UI/AJAX/</id>
    <published>2020-11-08T13:12:47.000Z</published>
    <updated>2020-11-08T13:13:12.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-AJAX-概述"><a href="#一-AJAX-概述" class="headerlink" title="一 AJAX 概述"></a>一 AJAX 概述</h1><ol><li><code>Asynchronous JavaScript And XML</code><ul><li>AJAX 不是一个技术，是多个技术联合实现的产物，且无论服务端编程语言是哪一种都可以，AJAX 只负责发送请求和接收响应</li><li>异步提交下 <code>form</code> 标签的 <code>action</code> 和 <code>method</code> 没有意义</li><li>服务端不能使用转发或重定向，因为会让浏览器全面刷新，只能以流的方式响应给浏览器</li></ul></li><li>一个页面可以同时发送多个 AJAX 请求</li><li>传统的网页（不使用 AJAX）都是同步的，如果需要更新内容，必需重载整个网页面<ul><li><code>客户端 → 请求 → 服务端</code></li><li><code>服务端 → 响应 → 客户端</code></li></ul></li><li>Ajax：可以使网页实现异步更新，即在不重新加载整个网页的情况下，对网页的某部分进行更新<ul><li><code>客户端 → 请求 → ajax engine → 服务端</code></li><li><code>服务端 → 响应 → ajax engine → 客户端</code></li></ul></li><li>Ajax 应用场景<ol><li>页面向下加载更多数据</li><li>列表数据无刷新分页</li><li>表单项失去焦点验证</li><li>输入框的自动补全（下拉提示）</li><li>地图</li><li>…</li></ol></li></ol><h1 id="二-XMLHttpRequest"><a href="#二-XMLHttpRequest" class="headerlink" title="二 XMLHttpRequest"></a>二 <code>XMLHttpRequest</code></h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol><li>异步通讯对象</li><li>老版本的 IE 中是 <code>ActiveXObject</code></li></ol><h2 id="2-2-构造"><a href="#2-2-构造" class="headerlink" title="2.2 构造"></a>2.2 构造</h2><table><thead><tr><th>构造函数</th><th>说明</th></tr></thead><tbody><tr><td><code>XMLHttpRequest()</code></td><td>创建 <code>XMLHttpRequest</code> 对象</td></tr></tbody></table><h2 id="2-3-属性"><a href="#2-3-属性" class="headerlink" title="2.3 属性"></a>2.3 属性</h2><table><thead><tr><th>属性</th><th>权限</th><th>说明</th></tr></thead><tbody><tr><td><code>readyState</code></td><td>只读</td><td><code>XMLHttpRequest</code> 状态码（<code>0-4</code>）</td></tr><tr><td><code>status</code></td><td>只读</td><td>响应状态码（<code>200 302 404 500 ...</code>）</td></tr><tr><td><code>responseType</code></td><td>读写</td><td>在<code>open()</code>之后<code>send()</code>之前设置，告诉服务器返回指定类型的数据，默认 <code>text</code></td></tr><tr><td><code>responseText</code></td><td>只读</td><td>字符串形式的响应数据</td></tr><tr><td><code>responseXML</code></td><td>只读</td><td>XML 形式的响应数据</td></tr><tr><td><code>withCredentials</code></td><td>读写</td><td>跨域请求是否携带 <code>cookie</code>，默认 <code>false</code></td></tr></tbody></table><h3 id="1-readyState"><a href="#1-readyState" class="headerlink" title="1 readyState"></a>1 readyState</h3><table><thead><tr><th>状态码</th><th>状态</th><th>说明</th></tr></thead><tbody><tr><td><code>0</code></td><td><code>unsent</code></td><td>请求未初始化</td></tr><tr><td><code>1</code></td><td><code>opened</code></td><td>服务器连接已建立</td></tr><tr><td><code>2</code></td><td><code>headers_received</code></td><td>请求已接收</td></tr><tr><td><code>3</code></td><td><code>loading</code></td><td>请求处理中</td></tr><tr><td><code>4</code></td><td><code>done</code></td><td>请求已完成，且响应已就绪</td></tr></tbody></table><h3 id="2-responseType"><a href="#2-responseType" class="headerlink" title="2 responseType"></a>2 responseType</h3><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td><code>&quot;&quot;</code></td><td>同 <code>text</code></td></tr><tr><td><code>&quot;text&quot;</code>（默认）</td><td>表示服务器返回文本数据</td></tr><tr><td><code>&quot;json&quot;</code></td><td>表示服务器返回 JSON 数据</td></tr><tr><td><code>&quot;blob&quot;</code></td><td>表示服务器返回二进制对象</td></tr><tr><td><code>&quot;document&quot;</code></td><td>表示服务器返回一个文档对象，HTML 或 XML</td></tr><tr><td><code>&quot;arraybuffer&quot;</code></td><td>表示服务器返回二进制数组</td></tr></tbody></table><h2 id="2-4-方法"><a href="#2-4-方法" class="headerlink" title="2.4 方法"></a>2.4 方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>open(method, url, [async], [user], [password])</code></td><td>初始化一个请求</td></tr><tr><td><code>send([data])</code></td><td>发送请求</td></tr><tr><td><code>setRequestHeader(key, value)</code></td><td>设置请求头</td></tr><tr><td><code>getResponseHeader(key)</code></td><td>获取响应头信息</td></tr><tr><td><code>getAllResponseHeaders()</code></td><td>获取一个包含所有响应头信息的字符串</td></tr><tr><td><code>overrideMimeType(mimeType)</code></td><td>指定一个MIME类型用于替代服务器指定的类型，必须在 <code>send()</code> 之前调用</td></tr></tbody></table><h3 id="1-open"><a href="#1-open" class="headerlink" title="1 open()"></a>1 <code>open()</code></h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>method</code></td><td>请求方法，<code>GET POST PUT DELETE...</code></td></tr><tr><td><code>url</code></td><td>请求地址</td></tr><tr><td><code>async</code></td><td>是否异步，默认 <code>true</code></td></tr><tr><td><code>user</code></td><td>用于认证的用户名，默认为 <code>null</code></td></tr><tr><td><code>password</code></td><td>用于认证的密码，默认为 <code>null</code></td></tr></tbody></table><h2 id="2-5-事件及对应属性"><a href="#2-5-事件及对应属性" class="headerlink" title="2.5 事件及对应属性"></a>2.5 事件及对应属性</h2><table><thead><tr><th>事件</th><th>说明</th><th>对应属性</th></tr></thead><tbody><tr><td><code>readyStateChange</code></td><td>当 <code>readyState</code> 属性改变时，就会触发此事件</td><td><code>onreadystatechange</code></td></tr><tr><td><code>load</code></td><td>请求成功完成时触发</td><td><code>onload</code></td></tr><tr><td><code>error</code></td><td>请求出错时触发</td><td><code>onerror</code></td></tr><tr><td><code>abort</code></td><td>请求中止时触发</td><td><code>onabort</code></td></tr><tr><td><code>loadend</code></td><td>请求结束时触发，无论成功失败或中止</td><td><code>onloadend</code></td></tr><tr><td><code>timeout</code></td><td>请求超时时触发</td><td><code>ontimeout</code></td></tr><tr><td><code>loadstart</code></td><td>接收到响应数据时触发</td><td><code>onloadstart</code></td></tr><tr><td><code>progress</code></td><td>接收数据开始周期触发，进度条</td><td><code>onprogress</code></td></tr></tbody></table><ul><li>事件对应属性指向一个函数，是对应事件触发时的处理函数</li></ul><h1 id="三-AJAX-使用步骤"><a href="#三-AJAX-使用步骤" class="headerlink" title="三 AJAX 使用步骤"></a>三 AJAX 使用步骤</h1><h2 id="3-1-创建-XMLHttpRequest-对象"><a href="#3-1-创建-XMLHttpRequest-对象" class="headerlink" title="3.1 创建 XMLHttpRequest 对象"></a>3.1 创建 XMLHttpRequest 对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ajax;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">ajax=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">ajax=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ajax;</span><br></pre></td></tr></table></figure><h2 id="3-2-初始化请求并发送"><a href="#3-2-初始化请求并发送" class="headerlink" title="3.2 初始化请求并发送"></a>3.2 初始化请求并发送</h2><h3 id="1-GET"><a href="#1-GET" class="headerlink" title="1 GET"></a>1 GET</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 初始化请求</span></span><br><span class="line">ajax.open(<span class="string">"GET"</span>,<span class="string">"url?name=xxx&amp;age=18"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 发送请求</span></span><br><span class="line">ajax.send();</span><br></pre></td></tr></table></figure><h3 id="2-POST"><a href="#2-POST" class="headerlink" title="2 POST"></a>2 POST</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 初始化请求</span></span><br><span class="line">ajax.open(<span class="string">"POST"</span>,<span class="string">"url"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 设置请求头并发送请求（POST 请求需要使用表单）</span></span><br><span class="line"><span class="comment">// 2.1 请求参数格式为 application/x-www-form-urlencoded</span></span><br><span class="line">ajax.setRequestHeader(<span class="string">"content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">ajax.send(<span class="string">"name=xxx&amp;age=18"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.2 请求参数格式为  application/json</span></span><br><span class="line">ajax.setRequestHeader(<span class="string">"content-type"</span>,<span class="string">"application/json"</span>);</span><br><span class="line"><span class="comment">// 请求参数必须是字符串，所以需要把 JSON 对象转为字符串</span></span><br><span class="line">ajax.send(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">name</span>:<span class="string">"xxx"</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;));</span><br></pre></td></tr></table></figure><h2 id="3-3-注册回调函数接收服务器响应数据"><a href="#3-3-注册回调函数接收服务器响应数据" class="headerlink" title="3.3 注册回调函数接收服务器响应数据"></a>3.3 注册回调函数接收服务器响应数据</h2><table><thead><tr><th>方式</th><th>说明</th></tr></thead><tbody><tr><td><code>onload</code>（推荐）</td><td>不兼容旧 IE，不需要判断状态码，被调用一次</td></tr><tr><td><code>onreadystatechange</code></td><td>兼容旧 IE，需要判断状态码，被调用多次</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 onreadystatechange</span></span><br><span class="line">ajax.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> res=ajax.responseText;</span><br><span class="line"><span class="keyword">let</span> res=ajax.responseXml;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 onload</span></span><br><span class="line">ajax.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ajax.readyState==<span class="number">4</span> &amp;&amp; ajax.status==<span class="number">200</span>)&#123;</span><br><span class="line"><span class="keyword">let</span> res=ajax.responseText;</span><br><span class="line"><span class="keyword">let</span> res=ajax.responseXml;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-低版本-IE-浏览器缓存问题"><a href="#3-4-低版本-IE-浏览器缓存问题" class="headerlink" title="3.4 低版本 IE 浏览器缓存问题"></a>3.4 低版本 IE 浏览器缓存问题</h2><ol><li>问题：在请求地址不变的情况下，只有第一次请求真正发送到服务器，后续请求都从浏览器缓存中获取结果，导致拿到的都是旧数据</li><li>解决：发送请求时，添加一个每次都不同的请求参数，如时间戳，随机数</li></ol><h1 id="四-FormData"><a href="#四-FormData" class="headerlink" title="四 FormData"></a>四 FormData</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ol><li>将表单数据的键值对组合，实现表单数据的序列化，减少表单元素拼接</li><li>可以通过 <code>send(formData)</code> 发送</li></ol><h2 id="4-2-构造"><a href="#4-2-构造" class="headerlink" title="4.2 构造"></a>4.2 构造</h2><table><thead><tr><th>构造函数</th><th>说明</th></tr></thead><tbody><tr><td><code>FormData(form)</code></td><td>将表单元素构造为 <code>FormData</code> 对象</td></tr></tbody></table><h2 id="4-3-方法"><a href="#4-3-方法" class="headerlink" title="4.3 方法"></a>4.3 方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>get(key)</code></td><td>返回 <code>FormData</code> 对象中与给定键关联的第一个值</td></tr><tr><td><code>getAll(key)</code></td><td>返回 <code>FormData</code> 对象中与给定键关联的所有值的数组</td></tr><tr><td><code>set(key, value)</code></td><td>给 <code>FormData</code> 设置键值对，键不存在则添加，存在则覆盖</td></tr><tr><td><code>append(key, value,[fileName])</code></td><td>给 <code>formData</code> 追加键值对，键存在也不会覆盖，如果是文件，可以添加文件名</td></tr><tr><td><code>delete(key)</code></td><td>从 <code>FormData</code> 对象里面删除一个键值对</td></tr><tr><td><code>has(key)</code></td><td>判断 <code>FormData</code> 对象是否包含指定键</td></tr><tr><td><code>kes()</code></td><td>返回一个包含所有键的迭代器对象</td></tr><tr><td><code>values()</code></td><td>返回一个包含所有值的迭代器对象</td></tr><tr><td><code>entries()</code></td><td>返回一个包含所有键值对的迭代器对象</td></tr></tbody></table><h1 id="五-跨域"><a href="#五-跨域" class="headerlink" title="五 跨域"></a>五 跨域</h1><h2 id="5-1-同源政策"><a href="#5-1-同源政策" class="headerlink" title="5.1 同源政策"></a>5.1 同源政策</h2><ol><li>同源：协议、域名和端口都相同</li><li>Ajax 只能向同源服务器发送HTTP 请求，如果发出跨域请求，就会报错</li><li>同源政策是为了用户信息安全，防止恶意窃取数据</li><li>解决同源的方式有许多，如 <code>JSONP</code></li></ol><h2 id="5-2-JSONP"><a href="#5-2-JSONP" class="headerlink" title="5.2 JSONP"></a>5.2 JSONP</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li><code>json with padding</code></li><li>JSONP 不属于 Ajax 请求，但可以模拟 Ajax 请求</li><li>是 <code>json</code> 的一种 “使用模式”，可以从别的域请求资源</li></ol><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h3><ol><li>在客户端全局作用域定义一个函数</li><li>客户端 <code>&lt;script src=&quot;&quot;&gt;</code> 是不受同源限制的，非同源请求地址写在<code>src</code> 中</li><li>在请求地址中将函数名发送给服务器</li><li>服务器响应数据必须是客户端所定义函数的调用，真正发给客户端的数据作为函数调用的参数</li><li>客户端接收到实参，执行函数</li></ol><h3 id="3-动态请求"><a href="#3-动态请求" class="headerlink" title="3 动态请求"></a>3 动态请求</h3><ol><li><code>&lt;script&gt;</code> 标签可以不写死，而是用 JS 动态生成</li><li>添加监听事件 <code>onload</code>，在请求完成后，删除 <code>&lt;script src=&quot;&quot;&gt;</code> ，避免多次请求产生多个 <code>&lt;script src=&quot;&quot;&gt;</code></li></ol><h3 id="4-跨域-Cookie"><a href="#4-跨域-Cookie" class="headerlink" title="4 跨域 Cookie"></a>4 跨域 Cookie</h3><ol><li><code>withCredentials</code> 设置为 <code>true</code></li><li><code>Access-Control-Allow-Credentials</code> 设置为 <code>true</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-AJAX-概述&quot;&gt;&lt;a href=&quot;#一-AJAX-概述&quot; class=&quot;headerlink&quot; title=&quot;一 AJAX 概述&quot;&gt;&lt;/a&gt;一 AJAX 概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Asynchronous JavaScript And XM
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="UI" scheme="https://anyeansan.github.io/categories/CS/UI/"/>
    
    
  </entry>
  
  <entry>
    <title>DOM</title>
    <link href="https://anyeansan.github.io/2020/11/08/UI/DOM/"/>
    <id>https://anyeansan.github.io/2020/11/08/UI/DOM/</id>
    <published>2020-11-08T13:09:31.000Z</published>
    <updated>2020-11-08T13:10:45.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-DOM-概述"><a href="#一-DOM-概述" class="headerlink" title="一 DOM 概述"></a>一 DOM 概述</h1><ol><li><code>Document Object Model</code> 文档对象模型</li><li>DOM 是 HTML 和 XML 文档的编程接口，用于改变文档的结构，样式和内容</li><li>DOM 的最小组成单位叫做节点（node），DOM 树由各种不同类型的节点组成</li><li>页面中所有内容都是节点（标签，属性，文本，注释等）</li></ol><h1 id="二-NodeList-amp-HTMLCollection"><a href="#二-NodeList-amp-HTMLCollection" class="headerlink" title="二 NodeList &amp; HTMLCollection"></a>二 NodeList &amp; HTMLCollection</h1><h2 id="2-1-NodeList"><a href="#2-1-NodeList" class="headerlink" title="2.1 NodeList"></a>2.1 NodeList</h2><ol><li><code>NodeList</code> 是节点的集合，是类数组对象</li><li><code>Node.childNodes</code> 返回的是一个动态集合，即文档中的节点树发生变化，<code>NodeList</code> 也会随之变化</li><li>其他的 <code>NodeList</code> 都是静态集合</li><li><code>NodeList</code> 的 <code>length</code> 属性表示其包含的节点数量</li><li><code>NodeList</code> 的遍历<ol><li><code>item(index)</code><ul><li>获取指定索引的值，可以用 <code>nodeList[index]</code> 代替</li></ul></li><li><code>for</code> 循环<ul><li>因为是类数组对象，有索引</li></ul></li><li><code>forEach()</code></li><li><code>keys()</code></li><li><code>values()</code></li><li><code>entries()</code></li></ol></li></ol><h2 id="2-2-HTMLCollection"><a href="#2-2-HTMLCollection" class="headerlink" title="2.2 HTMLCollection"></a>2.2 HTMLCollection</h2><ol><li><code>HTMLCollection</code> 元素节点的集合，是类数组对象</li><li><code>HTMLCollection</code> 都是动态集合</li><li><code>HTMLCollection</code> 的 <code>length</code> 属性表示其包含的节点数量</li><li><code>HTMLCollection</code> 不能使用 <code>foreach</code> 遍历</li></ol><h1 id="三-Node"><a href="#三-Node" class="headerlink" title="三 Node"></a>三 Node</h1><h2 id="3-1-分类"><a href="#3-1-分类" class="headerlink" title="3.1 分类"></a>3.1 分类</h2><table><thead><tr><th>类型</th><th>名称</th><th>说明</th><th align="center"><code>nodeType</code></th><th><code>nodeName</code></th><th><code>nodeValue</code></th></tr></thead><tbody><tr><td><code>Document</code></td><td>文档节点</td><td>整个页面</td><td align="center"><code>9</code></td><td><code>#document</code></td><td><code>null</code></td></tr><tr><td><code>Element</code></td><td>元素节点</td><td>页面 HTML 标签</td><td align="center"><code>1</code></td><td>大写的标签名</td><td><code>null</code></td></tr><tr><td><code>Attr</code></td><td>属性节点</td><td>页面标签的属性</td><td align="center"><code>2</code></td><td>属性名</td><td>属性值</td></tr><tr><td><code>Text</code></td><td>文本节点</td><td>页面中的文本</td><td align="center"><code>3</code></td><td><code>#text</code></td><td>文本内容</td></tr><tr><td><code>Comment</code></td><td>注释节点</td><td>注释</td><td align="center"><code>8</code></td><td><code>#comment</code></td><td>注释内容</td></tr><tr><td><code>DocumentType</code></td><td>文档类型节点</td><td><code>&lt;!DOCTYPE html&gt;</code></td><td align="center"><code>10</code></td><td>文档的类型</td><td><code>null</code></td></tr><tr><td><code>DocumentFragment</code></td><td>文档片段节点</td><td>一个没有父级文件的最小文档对象</td><td align="center"><code>11</code></td><td><code>#document-fragment</code></td><td><code>null</code></td></tr></tbody></table><h2 id="3-2-属性"><a href="#3-2-属性" class="headerlink" title="3.2 属性"></a>3.2 属性</h2><h3 id="1-节点信息"><a href="#1-节点信息" class="headerlink" title="1 节点信息"></a>1 节点信息</h3><table><thead><tr><th>属性</th><th>权限</th><th>说明</th></tr></thead><tbody><tr><td><code>nodeType</code></td><td>只读</td><td>节点类型（整数值）</td></tr><tr><td><code>nodeName</code></td><td>只读</td><td>节点名</td></tr><tr><td><code>nodeValue</code></td><td>读写</td><td>获取或设置当前节点的值</td></tr><tr><td><code>baseURI</code></td><td>只读</td><td>当前网页的绝对路径 URI</td></tr></tbody></table><h3 id="2-节点结构"><a href="#2-节点结构" class="headerlink" title="2 节点结构"></a>2 节点结构</h3><table><thead><tr><th>属性</th><th>权限</th><th>说明</th></tr></thead><tbody><tr><td><code>parentNode</code></td><td>只读</td><td>父节点</td></tr><tr><td><code>childNodes</code></td><td>只读</td><td>所有子节点的 <code>NodeList</code> 集合</td></tr><tr><td><code>firstChild</code></td><td>只读</td><td>第一个子节点</td></tr><tr><td><code>lastChild</code></td><td>只读</td><td>最后一个子节点</td></tr><tr><td><code>nextSibling</code></td><td>只读</td><td>弟节点</td></tr><tr><td><code>previousSibling</code></td><td>只读</td><td>兄节点</td></tr></tbody></table><h3 id="3-元素节点结构"><a href="#3-元素节点结构" class="headerlink" title="3 元素节点结构"></a>3 元素节点结构</h3><table><thead><tr><th>属性</th><th>权限</th><th>说明</th></tr></thead><tbody><tr><td><code>parentElement</code></td><td>只读</td><td>父元素节点，若没有父节点或父节点不是元素节点则返回 <code>null</code></td></tr><tr><td><code>children</code></td><td>只读</td><td>所有子元素节点，非标准，但推荐使用</td></tr><tr><td><code>firstElementChild</code></td><td>只读</td><td>第一个子元素节点，有兼容问题，推荐 <code>children[0]</code></td></tr><tr><td><code>lastElementChild</code></td><td>只读</td><td>最后一个子元素节点，有兼容问题，推荐 <code>children[children.length-1]</code></td></tr><tr><td><code>nextElementSibling</code></td><td>只读</td><td>弟元素节点，有兼容问题</td></tr><tr><td><code>previousElementSibling</code></td><td>只读</td><td>兄元素节点，有兼容问题</td></tr></tbody></table><h2 id="3-3-方法"><a href="#3-3-方法" class="headerlink" title="3.3 方法"></a>3.3 方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>parentNode.appendChild(childNode)</code></td><td>追加子节点</td></tr><tr><td><code>parentNode.removeChild(childNode)</code></td><td>删除子节点</td></tr><tr><td><code>parentNode.replaceChild(newNode, oldNode)</code></td><td>替换子节点</td></tr><tr><td><code>parentNode.insertBefore(childNode, targetNode)</code></td><td>将子节点插入到目标节点之前</td></tr><tr><td><code>node.cloneNode([flag])</code></td><td>克隆节点，无参或 <code>false</code> 为浅拷贝，<code>true</code> 为深拷贝</td></tr><tr><td><code>node.hasChildNodes()</code></td><td>判断是否有子节点</td></tr><tr><td><code>node.contains(node)</code></td><td>判断是否是其自己或后代节点</td></tr></tbody></table><h1 id="四-Document"><a href="#四-Document" class="headerlink" title="四 Document"></a>四 Document</h1><h2 id="4-1-属性"><a href="#4-1-属性" class="headerlink" title="4.1 属性"></a>4.1 属性</h2><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>forms</code></td><td>返回所有 <code>&lt;form&gt;</code> 表单节点的  <code>HTMLCollection</code> 集合</td></tr><tr><td><code>documentURI</code></td><td>文档的 URI</td></tr><tr><td><code>location</code></td><td>浏览器地址栏对象</td></tr><tr><td><code>body</code></td><td>获取 <code>&lt;body&gt;</code> 元素节点</td></tr><tr><td><code>documentElement</code></td><td>获取 <code>&lt;html&gt;</code> 元素节点</td></tr></tbody></table><h2 id="4-2-方法"><a href="#4-2-方法" class="headerlink" title="4.2 方法"></a>4.2 方法</h2><h3 id="1-获取"><a href="#1-获取" class="headerlink" title="1 获取"></a>1 获取</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>getElementById(id)</code></td><td>根据元素 ID 获取 <code>Element</code> 对象</td></tr><tr><td><code>getElementsByTagName(tagName)</code></td><td>根据标签名获取元素节点的 <code>HTMLCollection</code> 集合</td></tr><tr><td><code>getElementsByClassName(class)</code></td><td>根据 <code>class</code> 属性值获取元素节点的 <code>HTMLCollection</code> 集合</td></tr><tr><td><code>getElementsByName(name)</code></td><td>根据元素 <code>name</code> 属性的值获取节点的 <code>NodeList</code> 集合</td></tr><tr><td><code>querySelector(selector)</code></td><td>返回第一个匹配的节点</td></tr><tr><td><code>querySelectorAll(selector)</code></td><td>返回所有匹配节点的 <code>NodeList</code> 集合</td></tr></tbody></table><h3 id="2-创建"><a href="#2-创建" class="headerlink" title="2 创建"></a>2 创建</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>createElement(tageName)</code></td><td>创建元素节点</td></tr><tr><td><code>createAttribute(attrName)</code></td><td>创建属性节点</td></tr><tr><td><code>createTextNode(text)</code></td><td>创建文本节点</td></tr><tr><td><code>createComment(comment)</code></td><td>创建注释节点</td></tr></tbody></table><ul><li>另外两种创建节点的方式<ol><li><code>document.write()</code><ul><li>是直接将内容写入页面，如果文档流加载完毕才执行，会导致页面重绘（仍掉原页面，创建新页面且只有写出的内容）</li></ul></li><li><code>innerHTML</code><ul><li>创建多个元素通过拼接字符串创建，效率底</li><li>创建多个元素通过数组形式拼接，效率高，但复杂</li></ul></li></ol></li></ul><h1 id="五-Element"><a href="#五-Element" class="headerlink" title="五 Element"></a>五 Element</h1><h2 id="5-1-属性"><a href="#5-1-属性" class="headerlink" title="5.1 属性"></a>5.1 属性</h2><h3 id="1-信息属性"><a href="#1-信息属性" class="headerlink" title="1 信息属性"></a>1 信息属性</h3><table><thead><tr><th>属性</th><th>权限</th><th>说明</th></tr></thead><tbody><tr><td><code>id</code></td><td>读写</td><td>元素 id</td></tr><tr><td><code>tagName</code></td><td>只读</td><td>元素标签名</td></tr><tr><td><code>className</code></td><td>读写</td><td>返回 class 属性的字符串，多个用空格分隔</td></tr><tr><td><code>classList</code></td><td>只读</td><td>返回 class 属性的类数组对象</td></tr><tr><td><code>innerHTML</code></td><td>读写</td><td>识别 Html 标签，保留Html 标签、空格和换行，w3c 标准</td></tr><tr><td><code>innerText</code></td><td>读写</td><td>不识别 Html 标签，会去除 Html标签以及空格和换行，非标准</td></tr><tr><td><code>dataset</code></td><td>只读</td><td>存放了所有以 <code>data-</code> 开头的自定义属性的集合</td></tr><tr><td><code>hiddent</code></td><td>读写</td><td>元素是否隐藏</td></tr><tr><td><code>style</code></td><td>读写</td><td>元素的行内样式信息，带单位</td></tr></tbody></table><h3 id="2-offset-系列属性"><a href="#2-offset-系列属性" class="headerlink" title="2 offset 系列属性"></a>2 offset 系列属性</h3><table><thead><tr><th>属性</th><th>权限</th><th>说明</th></tr></thead><tbody><tr><td><code>offsetParent</code></td><td>只读</td><td>返回该元素带有定位的祖先元素，如果没有则返回 <code>body</code></td></tr><tr><td><code>offsetTop</code></td><td>只读</td><td>返回元素相对定位祖先元素上方的偏移量，不带单位</td></tr><tr><td><code>offsetLeft</code></td><td>只读</td><td>返回元素相对定位祖先元素左方的偏移量，不带单位</td></tr><tr><td><code>offsetWidth</code></td><td>只读</td><td>返回 <code>boder-box</code> 的宽度，不带单位</td></tr><tr><td><code>offsetHeight</code></td><td>只读</td><td>返回 <code>boder-box</code> 的高度，不带单位</td></tr></tbody></table><h4 id="offset-amp-style-的区别"><a href="#offset-amp-style-的区别" class="headerlink" title="offset &amp; style 的区别"></a>offset &amp; style 的区别</h4><table><thead><tr><th><code>offset</code></th><th><code>style</code></th></tr></thead><tbody><tr><td>获取任意样式表的值</td><td>获取行内样式表的值</td></tr><tr><td>获取的值没有单位</td><td>获取的值有单位</td></tr><tr><td><code>offsetWidth = width + padding + border</code></td><td><code>style.width = width</code></td></tr><tr><td>只读</td><td>读写</td></tr></tbody></table><h3 id="3-client-系列属性"><a href="#3-client-系列属性" class="headerlink" title="3 client 系列属性"></a>3 client 系列属性</h3><table><thead><tr><th>属性</th><th>权限</th><th>说明</th></tr></thead><tbody><tr><td><code>clientTop</code></td><td>只读</td><td>元素上边框大小</td></tr><tr><td><code>clientLeft</code></td><td>只读</td><td>元素左边框大小</td></tr><tr><td><code>clientWidth</code></td><td>只读</td><td><code>padding-box</code> 的可视宽度，不带单位</td></tr><tr><td><code>clientHeight</code></td><td>只读</td><td><code>padding-box</code> 的可视高度，不带单位</td></tr></tbody></table><h3 id="4-scroll-系列属性"><a href="#4-scroll-系列属性" class="headerlink" title="4 scroll 系列属性"></a>4 scroll 系列属性</h3><table><thead><tr><th>属性</th><th>权限</th><th>说明</th></tr></thead><tbody><tr><td><code>scrollLeft</code></td><td>被卷去的上侧距离，不带单位</td><td></td></tr><tr><td><code>scrollTop</code></td><td>被卷去的左侧距离，不带单位</td><td></td></tr><tr><td><code>scrollWidth</code></td><td><code>padding-box</code> 的实际宽度，不带单位</td><td></td></tr><tr><td><code>scrollHeight</code></td><td><code>padding-box</code> 的实际高度，不带单位</td><td></td></tr></tbody></table><h2 id="5-2-方法"><a href="#5-2-方法" class="headerlink" title="5.2 方法"></a>5.2 方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>getAttribute(key)</code></td><td>获取属性的值</td></tr><tr><td><code>setAttribute(key, value)</code></td><td>设置属性的值</td></tr><tr><td><code>removeAttribute(key)</code></td><td>删除属性</td></tr><tr><td><code>getAttributeNames()</code></td><td>返回当前元素所有属性名</td></tr><tr><td><code>hasAttribute(key)</code></td><td>某个属性是否存在</td></tr><tr><td><code>hasAttributes()</code></td><td>当前元素是否有属性</td></tr><tr><td><code>click()</code></td><td>模拟鼠标左键单击一个元素</td></tr></tbody></table><ul><li><code>Document</code> 中用来获取元素节点的方法，<code>Element</code> 也能用，只是匹配范围是当前元素而非整个文档</li></ul><h1 id="六-事件"><a href="#六-事件" class="headerlink" title="六 事件"></a>六 事件</h1><h2 id="6-1-EventTarget"><a href="#6-1-EventTarget" class="headerlink" title="6.1 EventTarget"></a>6.1 EventTarget</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ul><li>DOM 的事件操作（监听和触发），都定义在 <code>EventTarget</code> 接口</li></ul><h3 id="2-API"><a href="#2-API" class="headerlink" title="2 API"></a>2 API</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>addEventListener(type, listener [,useCapture])</code></td><td>添加事件监听</td></tr><tr><td><code>removeEventListener(type, listener [,useCapture])</code></td><td>移除事件监听</td></tr><tr><td><code>dispatchEvent(event)</code></td><td>触发指定事件</td></tr></tbody></table><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>type</code></td><td>事件类型字符串，大小写敏感，如 click focus …</td></tr><tr><td><code>listener</code></td><td>监听函数</td></tr><tr><td><code>useCapture</code></td><td>默认 <code>false</code>：冒泡阶段触发，<code>true</code>：捕获阶段触发</td></tr></tbody></table><h2 id="6-2-事件绑定和解绑"><a href="#6-2-事件绑定和解绑" class="headerlink" title="6.2 事件绑定和解绑"></a>6.2 事件绑定和解绑</h2><h3 id="1-传统注册方式"><a href="#1-传统注册方式" class="headerlink" title="1 传统注册方式"></a>1 传统注册方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 绑定事件</span><br><span class="line">element.onEventType = function()&#123;&#125; </span><br><span class="line"># 解绑事件</span><br><span class="line">element.onclick=null;</span><br></pre></td></tr></table></figure><ol><li>利用 <code>on</code> 开头的事件</li><li>只在冒泡阶段触发</li><li>注册事件的唯一性：同一个元素同一个事件只能定义一个监听函数，多次定义会覆盖</li></ol><h3 id="2-方法监听注册方式"><a href="#2-方法监听注册方式" class="headerlink" title="2 方法监听注册方式"></a>2 方法监听注册方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 绑定事件</span><br><span class="line">element.addEventListener(type, listener [,useCapture]) </span><br><span class="line"># 解绑事件</span><br><span class="line">element.removeEventListener(type, listener [,useCapture])</span><br></pre></td></tr></table></figure><ol><li>同一个元素同一个事件可以添加多个监听函数</li><li>能够指定在哪个阶段（捕获阶段 or 冒泡阶段）触发监听函数</li><li>是整个 JavaScript 统一的监听函数接口</li></ol><h2 id="6-3-DOM-事件流"><a href="#6-3-DOM-事件流" class="headerlink" title="6.3 DOM 事件流"></a>6.3 DOM 事件流</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>事件流描述的是从页面中接收事件的顺序</li><li>事件发生时会在元素节点之间按照特定的顺序传播，此传播过程即 DOM 事件流</li><li>JS 代码中只能执行捕获或者冒泡中的一个阶段</li><li>冒泡阶段更常用，但某些事件没有冒泡阶段，如 <code>focus blur mouseenter mouseleave</code></li></ol><h3 id="2-事件流三个阶段"><a href="#2-事件流三个阶段" class="headerlink" title="2 事件流三个阶段"></a>2 事件流三个阶段</h3><p><img src="https://gitee.com/anis5/pic/raw/master/UI/JS/%E4%BA%8B%E4%BB%B6%E6%B5%81.png" alt=""></p><table><thead><tr><th>阶段</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><code>capture phase</code></td><td>捕获阶段</td><td>从 window 对象传导到目标节点（上层传到底层）</td></tr><tr><td><code>target phase</code></td><td>目标阶段</td><td>在目标节点上触发</td></tr><tr><td><code>bubbling phase</code></td><td>冒泡阶段</td><td>从目标节点传导回 window 对象（从底层传回上层）</td></tr></tbody></table><h3 id="3-事件委托（代理-委派）"><a href="#3-事件委托（代理-委派）" class="headerlink" title="3 事件委托（代理/委派）"></a>3 事件委托（代理/委派）</h3><ol><li>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件</li><li>优点：只操作一次DOM，性能更高</li><li>如果希望事件到某个节点为止，不再传播，<code>event.stopPropagation()</code> 阻止冒泡</li><li>获取触发事件的对象 <code>event.target</code></li><li>获取绑定事件的对象 <code>this</code> </li></ol><h2 id="6-4-Event"><a href="#6-4-Event" class="headerlink" title="6.4 Event"></a>6.4 Event</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h3><ol><li>事件发生以后，系统会自动创建一个事件对象 <code>Event</code>，作为参数传给监听函数</li><li>事件对象是一系列与事件相关的数据的集合</li><li><code>Event</code> 有许多字类，如 <code>MouseEvent, KeyboardEvent, TouchEvent...</code> </li></ol><h3 id="2-属性"><a href="#2-属性" class="headerlink" title="2 属性"></a>2 属性</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>target</code></td><td>触发事件的对象，<code>this</code> ：绑定事件的对象</td></tr><tr><td><code>type</code></td><td>事件类型（名称）</td></tr><tr><td><code>returnValue</code></td><td>阻止事件的默认行为，低版本浏览器使用</td></tr></tbody></table><h3 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>preventDefault()</code></td><td>阻止事件的默认行为（如跳转，提交…）</td></tr><tr><td><code>stopPropagation()</code></td><td>阻止事件传播（捕获和冒泡）</td></tr></tbody></table><h3 id="4-阻止事件的默认行为方式"><a href="#4-阻止事件的默认行为方式" class="headerlink" title="4 阻止事件的默认行为方式"></a>4 阻止事件的默认行为方式</h3><table><thead><tr><th>方式</th><th>说明</th></tr></thead><tbody><tr><td><code>returnValue</code></td><td>低版本浏览器 IE678 使用</td></tr><tr><td><code>return false</code></td><td>没有兼容性问题，但是会结束代码，且只限于传统事件注册方式</td></tr><tr><td><code>preventDefault()</code></td><td>W3C 标准，低版本可能不支持</td></tr></tbody></table><h2 id="6-5-鼠标事件"><a href="#6-5-鼠标事件" class="headerlink" title="6.5 鼠标事件"></a>6.5 鼠标事件</h2><h3 id="1-事件"><a href="#1-事件" class="headerlink" title="1 事件"></a>1 事件</h3><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td><code>click</code></td><td>单击</td></tr><tr><td><code>dblclick</code></td><td>双击</td></tr><tr><td><code>focus</code></td><td>获取焦点，该事件不会冒泡</td></tr><tr><td><code>blur</code></td><td>失去焦点，该事件不会冒泡</td></tr><tr><td><code>mousedown</code></td><td>鼠标键按下</td></tr><tr><td><code>mouseup</code></td><td>鼠标键弹起</td></tr><tr><td><code>mousemove</code></td><td>鼠标移动</td></tr><tr><td><code>mouseenter</code></td><td>鼠标经过，该事件不会冒泡</td></tr><tr><td><code>mouseleave</code></td><td>鼠标离开，该事件不会冒泡</td></tr><tr><td><code>mouseover</code></td><td>鼠标经过</td></tr><tr><td><code>mouseout</code></td><td>鼠标离开</td></tr><tr><td><code>contextmenu</code></td><td>右键菜单，常使用 <code>event.preventDefault()</code> 来禁止右键菜单</td></tr><tr><td><code>selectstart</code></td><td>选中文字，常使用 <code>event.preventDefault()</code> 来禁止选中文字</td></tr></tbody></table><h3 id="2-MouseEvent"><a href="#2-MouseEvent" class="headerlink" title="2 MouseEvent"></a>2 MouseEvent</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>clientX</code></td><td>鼠标相对于浏览器窗口可视区的 X 坐标</td></tr><tr><td><code>clientY</code></td><td>鼠标相对于浏览器窗口可视区的 Y 坐标</td></tr><tr><td><code>pageX</code></td><td>鼠标相对于文档页面的 X 坐标</td></tr><tr><td><code>pageY</code></td><td>鼠标相对于文档页面的 Y 坐标</td></tr><tr><td><code>screenX</code></td><td>鼠标相对于电脑屏幕的 X 坐标</td></tr><tr><td><code>screenY</code></td><td>鼠标相对于电脑屏幕的 Y 坐标</td></tr></tbody></table><h2 id="6-6-键盘事件"><a href="#6-6-键盘事件" class="headerlink" title="6.6 键盘事件"></a>6.6 键盘事件</h2><h3 id="1-事件-1"><a href="#1-事件-1" class="headerlink" title="1 事件"></a>1 事件</h3><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td><code>keydown</code></td><td>按下键盘按键之后文字未输入之前触发，顺序在 <code>keypress</code> 之前，不区分大小写</td></tr><tr><td><code>keypress</code></td><td>按下有值的键之后文字未输入之前触发触发，区分大小写，不识别功能键如 <code>→ ← ctrl alt shift...</code></td></tr><tr><td><code>keyup</code></td><td>弹起键盘按键触发，不区分大小写</td></tr></tbody></table><h3 id="2-KeyboardEvent"><a href="#2-KeyboardEvent" class="headerlink" title="2 KeyboardEvent"></a>2 KeyboardEvent</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>keyCode</code></td><td>按键对应的 ASCII 码值</td></tr></tbody></table><h2 id="6-7-触屏事件"><a href="#6-7-触屏事件" class="headerlink" title="6.7 触屏事件"></a>6.7 触屏事件</h2><h3 id="1-事件-2"><a href="#1-事件-2" class="headerlink" title="1 事件"></a>1 事件</h3><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td><code>touchstart</code></td><td>触摸到一个 DOM 元素时触发</td></tr><tr><td><code>touchmove</code></td><td>在一个 DOM 元素上滑动时触发</td></tr><tr><td><code>touchend</code></td><td>从一个 DOM 元素上移开时触发</td></tr></tbody></table><h3 id="2-概念"><a href="#2-概念" class="headerlink" title="2 概念"></a>2 概念</h3><table><thead><tr><th>对象</th><th>说明</th></tr></thead><tbody><tr><td><code>Touch</code></td><td>单个触摸点。触摸点可能是一根手指，也可能是一根触摸笔</td></tr><tr><td><code>TouchList</code></td><td>多个触摸点的集合</td></tr><tr><td><code>TouchEvent</code></td><td>触摸引发的事件实例</td></tr></tbody></table><h3 id="3-TouchEvent"><a href="#3-TouchEvent" class="headerlink" title="3 TouchEvent"></a>3 TouchEvent</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>touches</code></td><td><code>TouchList</code>，正在触摸屏幕的触点的列表</td></tr><tr><td><code>targetTouches</code></td><td><code>TouchList</code>，正在触摸当前 DOM 元素的触点的列表</td></tr><tr><td><code>changedTouches</code></td><td><code>TouchList</code>，状态发生改变的触点的列表</td></tr></tbody></table><h3 id="4-TouchList"><a href="#4-TouchList" class="headerlink" title="4 TouchList"></a>4 TouchList</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>length</code></td><td>节点数量</td></tr><tr><td><code>item(index)</code></td><td>获取指定索引的节点，可以用 <code>list[index]</code> 代替</td></tr></tbody></table><h3 id="5-Touch"><a href="#5-Touch" class="headerlink" title="5 Touch"></a>5 Touch</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>identifier</code></td><td>返回一个整数，表示触摸点的唯一 ID</td></tr><tr><td><code>target</code></td><td>触摸的节点</td></tr><tr><td><code>clientX</code></td><td>触点相对于可见视区左边沿的的 X 坐标</td></tr><tr><td><code>clientY</code></td><td>触点相对于可见视区上边沿的的 Y 坐标.</td></tr><tr><td><code>pageX</code></td><td>触点相对于 HTML 文档左边沿的的 X 坐标</td></tr><tr><td><code>pageY</code></td><td>触点相对于 HTML 文档上边沿的的 Y 坐标</td></tr><tr><td><code>screenX</code></td><td>触点相对于屏幕左边沿的的 X 坐标</td></tr><tr><td><code>screenY</code></td><td>触点相对于屏幕上边沿的的 Y 坐标</td></tr></tbody></table><h2 id="6-8-表单事件"><a href="#6-8-表单事件" class="headerlink" title="6.8 表单事件"></a>6.8 表单事件</h2><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td><code>input</code></td><td>当 <code>&lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;</code> 的值发生变化时触发</td></tr><tr><td><code>change</code></td><td>同 <code>input</code> 区别是如果有连续变化，<code>input</code> 事件会触发多次，而 <code>change</code> 事件只在失去焦点时触发一次</td></tr><tr><td><code>select</code></td><td>在<code>&lt;input&gt;、&lt;textarea&gt;</code> 里面选中文本时触发</td></tr><tr><td><code>invalid</code></td><td>提交表单时，如果表单元素的值不满足校验条件时触发</td></tr><tr><td><code>reset</code></td><td>重置表单时触发</td></tr><tr><td><code>submit</code></td><td>提交表单时触发</td></tr></tbody></table><h1 id="七-元素的属性操作"><a href="#七-元素的属性操作" class="headerlink" title="七 元素的属性操作"></a>七 元素的属性操作</h1><h2 id="7-1-attribute-amp-property"><a href="#7-1-attribute-amp-property" class="headerlink" title="7.1 attribute &amp; property"></a>7.1 attribute &amp; property</h2><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>attribute</code></td><td>HTML 标准属性和自定义属性</td></tr><tr><td><code>property</code></td><td>DOM 属性（HTML 元素的标准属性会自动成为元素节点对象的属性）</td></tr></tbody></table><h2 id="7-2-操作方式"><a href="#7-2-操作方式" class="headerlink" title="7.2 操作方式"></a>7.2 操作方式</h2><h3 id="1-attribute"><a href="#1-attribute" class="headerlink" title="1 attribute"></a>1 attribute</h3><table><thead><tr><th>操作</th><th>原生 DOM</th><th>jQuery</th></tr></thead><tbody><tr><td>读</td><td><code>element.getAttribute(name)</code></td><td><code>$element.attr(name)</code></td></tr><tr><td>写</td><td><code>element.setAttribute(name, value)</code></td><td><code>$element.attr(name, value)</code></td></tr><tr><td>删</td><td><code>element.removeAttribute(name)</code></td><td><code>$element.removeAttr(name)</code></td></tr></tbody></table><h3 id="2-property"><a href="#2-property" class="headerlink" title="2 property"></a>2 property</h3><table><thead><tr><th>操作</th><th>原生 DOM</th><th>jQuery</th></tr></thead><tbody><tr><td>读</td><td><code>element.name</code></td><td><code>$element.prop(name)</code></td></tr><tr><td>写</td><td><code>element.name=value</code></td><td><code>$element.prop(name, value)</code></td></tr><tr><td>删</td><td><code>delete element.name</code></td><td><code>$element.removeProp(name)</code></td></tr></tbody></table><h2 id="7-3-总结"><a href="#7-3-总结" class="headerlink" title="7.3 总结"></a>7.3 总结</h2><h3 id="1-HTML-标准属性"><a href="#1-HTML-标准属性" class="headerlink" title="1 HTML 标准属性"></a>1 HTML 标准属性</h3><ol><li><code>attribute</code></li><li><code>property</code></li></ol><h3 id="2-自定义属性"><a href="#2-自定义属性" class="headerlink" title="2 自定义属性"></a>2 自定义属性</h3><ol><li><code>attribute</code><ul><li>能够操作，但是不符合标准，导致网页代码通不过校验</li></ul></li></ol><h3 id="3-HTML5-自定义属性规范"><a href="#3-HTML5-自定义属性规范" class="headerlink" title="3 HTML5 自定义属性规范"></a>3 HTML5 自定义属性规范</h3><ol><li>自定义属性名以 <code>data-</code> 开头，如 <code>data-test</code></li><li>获取标准自定义属性有两种方式<ol><li>如：<code>data-test</code><ol><li><code>getAttribute(&#39;data-test&#39;)</code></li><li><code>element.dataset.test</code></li></ol></li><li>如：<code>data-test-name</code><ol><li><code>getAttribute(&#39;data-test-name&#39;)</code> </li><li><code>element.dataset.testName</code><ul><li>如果名称有多个以 <code>-</code> 连接的单词，使用驼峰</li></ul></li></ol></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-DOM-概述&quot;&gt;&lt;a href=&quot;#一-DOM-概述&quot; class=&quot;headerlink&quot; title=&quot;一 DOM 概述&quot;&gt;&lt;/a&gt;一 DOM 概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Document Object Model&lt;/code&gt; 文档对象模
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="UI" scheme="https://anyeansan.github.io/categories/CS/UI/"/>
    
    
  </entry>
  
  <entry>
    <title>BOM</title>
    <link href="https://anyeansan.github.io/2020/11/08/UI/BOM/"/>
    <id>https://anyeansan.github.io/2020/11/08/UI/BOM/</id>
    <published>2020-11-08T13:09:25.000Z</published>
    <updated>2020-11-08T13:10:39.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-BOM-概述"><a href="#一-BOM-概述" class="headerlink" title="一 BOM 概述"></a>一 BOM 概述</h1><ol><li><code>Browser Object Model</code> 浏览器对象模型，提供了独立于内容而与浏览器窗口进行交互的对象</li><li>BOM 由浏览器厂商各自定义，兼容性较差</li><li>BOM 包含 DOM</li><li>BOM 都有一个顶级对象，不同的环境顶级对象也不同，浏览器环境是 <code>window</code></li></ol><h1 id="二-window"><a href="#二-window" class="headerlink" title="二 window"></a>二 window</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol><li><code>window</code> 是浏览器的顶级对象，是 JS 访问浏览器窗口的一个接口</li><li><code>window</code> 是一个全局对象，定义在全局作用域的变量、函数都会变成 <code>window</code> 对象的属性和方法</li></ol><h2 id="2-2-属性"><a href="#2-2-属性" class="headerlink" title="2.2 属性"></a>2.2 属性</h2><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>name</code></td><td>窗口名</td></tr><tr><td><code>innerWidth</code></td><td>窗口可视宽度</td></tr><tr><td><code>innerHeight</code></td><td>窗口可视高度</td></tr><tr><td><code>pageXOffset</code></td><td>页面的水平滚动距离</td></tr><tr><td><code>pageYOffset</code></td><td>页面的垂直滚动距离</td></tr><tr><td><code>document</code></td><td>返回 Document 对象</td></tr><tr><td><code>location</code></td><td>返回 Location 对象</td></tr><tr><td><code>navigator</code></td><td>返回 Navigator 对象</td></tr><tr><td><code>history</code></td><td>返回 History 对象</td></tr><tr><td><code>console</code></td><td>返回 Console 对象</td></tr><tr><td><code>screen</code></td><td>返回 Screen 对象</td></tr><tr><td><code>localStorage</code></td><td>本地储存的 <code>localStorage</code> 数据</td></tr><tr><td><code>sessionStorage</code></td><td>本地储存的 <code>sessionStorage</code> 数据</td></tr></tbody></table><h2 id="2-3-方法"><a href="#2-3-方法" class="headerlink" title="2.3 方法"></a>2.3 方法</h2><h3 id="1-弹窗"><a href="#1-弹窗" class="headerlink" title="1 弹窗"></a>1 弹窗</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>alert(message)</code></td><td>提示框</td></tr><tr><td><code>confirm(message)</code></td><td>确认框</td></tr><tr><td><code>prompt([message,] value)</code></td><td>输入框</td></tr></tbody></table><h3 id="2-定时器"><a href="#2-定时器" class="headerlink" title="2 定时器"></a>2 定时器</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>setTimeout(function [, time])</code></td><td>指定时间后调用一次函数，<code>time</code>：毫秒值，默认为 <code>0</code> 即立即执行；通常会给定时器一个标识符，用于清除</td></tr><tr><td><code>clearTimeout(定时器标识符)</code></td><td>清除定时器</td></tr><tr><td><code>setInterval(function [, time])</code></td><td>每隔指定时间调用一此函数</td></tr><tr><td><code>clearInterval(定时器标识符)</code></td><td>清除定时器</td></tr></tbody></table><h3 id="3-滚动"><a href="#3-滚动" class="headerlink" title="3 滚动"></a>3 滚动</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>scrollTo(x-coord, y-coord )</code></td><td>滚动到指定位置</td></tr><tr><td><code>scrollBy(x-coord, y-coord)</code></td><td>滚动指定距离</td></tr></tbody></table><h2 id="2-4-窗口-window-事件"><a href="#2-4-窗口-window-事件" class="headerlink" title="2.4 窗口 window 事件"></a>2.4 窗口 window 事件</h2><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td><code>beforeunload</code></td><td>窗口关闭前</td></tr><tr><td><code>unload</code></td><td>窗口关闭</td></tr><tr><td><code>load</code></td><td>窗口加载完毕，包含 dom 元素，图片，flash，css …</td></tr><tr><td><code>DOMContentLoaded</code></td><td>DOM 加载完毕，不包含其它，事件源为 <code>document</code></td></tr><tr><td><code>error</code></td><td>窗口加载失败</td></tr><tr><td><code>resize</code></td><td>窗口大小改变</td></tr><tr><td><code>scroll</code></td><td>滚动条滚动</td></tr></tbody></table><h1 id="三-Location"><a href="#三-Location" class="headerlink" title="三 Location"></a>三 Location</h1><h2 id="3-1-属性"><a href="#3-1-属性" class="headerlink" title="3.1 属性"></a>3.1 属性</h2><table><thead><tr><th>属性</th><th>权限</th><th>说明</th></tr></thead><tbody><tr><td><code>href</code></td><td>读写</td><td>URL，格式 <code>protocal://host[:port]/path/[?query] # fragment</code></td></tr><tr><td><code>protocal</code></td><td>读写</td><td>协议</td></tr><tr><td><code>host</code></td><td>读写</td><td>主机，如果端口不是默认 <code>80 433</code>，则包含端口</td></tr><tr><td><code>hostname</code></td><td>读写</td><td>主机，不含端口</td></tr><tr><td><code>port</code></td><td>读写</td><td>端口</td></tr><tr><td><code>pathname</code></td><td>读写</td><td>资源路径</td></tr><tr><td><code>search</code></td><td>读写</td><td>参数，<code>?key=value&amp;key=value</code></td></tr><tr><td><code>hash</code></td><td>读写</td><td>片段，<code>#</code> 后面的内容，如链接 锚点</td></tr></tbody></table><h2 id="3-2-方法"><a href="#3-2-方法" class="headerlink" title="3.2 方法"></a>3.2 方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>assign(url)</code></td><td>重定向，记录浏览历史，可以回退，效果同 <code>href</code> 属性</td></tr><tr><td><code>replace(url)</code></td><td>重定向，不记录浏览历史，不能回退</td></tr><tr><td><code>reload([flag])</code></td><td>无参或 <code>false</code> 表示刷新 <code>F5</code>，<code>true</code> 表示强制刷新 <code>ctrl + F5</code></td></tr></tbody></table><h1 id="四-Navigator"><a href="#四-Navigator" class="headerlink" title="四 Navigator"></a>四 Navigator</h1><table><thead><tr><th>属性</th><th>权限</th><th>说明</th></tr></thead><tbody><tr><td><code>userAgent</code></td><td>只读</td><td>客户端发送给服务器的 <code>user-agent</code> 头部的值</td></tr></tbody></table><h1 id="五-History"><a href="#五-History" class="headerlink" title="五 History"></a>五 History</h1><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>back()</code></td><td>后退</td></tr><tr><td><code>forward()</code></td><td>前进</td></tr><tr><td><code>go(n)</code></td><td><code>0</code> 表示刷新，正数表示前进 n 个页面，负数表示后退 n 个页面</td></tr></tbody></table><h1 id="六-本地存储（Storage）"><a href="#六-本地存储（Storage）" class="headerlink" title="六 本地存储（Storage）"></a>六 本地存储（Storage）</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><ol><li>数据存储在用户浏览器中，只能存字符串，以键值对的形式存储</li><li><code>Storage</code> 下有两个子接口 <code>localStorage</code> 和 <code>sessionStorage</code></li></ol><h2 id="6-2-属性"><a href="#6-2-属性" class="headerlink" title="6.2 属性"></a>6.2 属性</h2><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>length</code></td><td>保存的数据项个数</td></tr></tbody></table><h2 id="6-3-方法"><a href="#6-3-方法" class="headerlink" title="6.3 方法"></a>6.3 方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>setItem(key, value)</code></td><td>存储数据</td></tr><tr><td><code>getItem(key)</code></td><td>获取数据</td></tr><tr><td><code>removeItem(key)</code></td><td>移除数据</td></tr><tr><td><code>clear()</code></td><td>清空</td></tr><tr><td><code>key(index)</code></td><td>返回指定索引的键，从 0 开始</td></tr></tbody></table><h2 id="6-4-sessionStorage-amp-localStorage"><a href="#6-4-sessionStorage-amp-localStorage" class="headerlink" title="6.4 sessionStorage &amp; localStorage"></a>6.4 sessionStorage &amp; localStorage</h2><table><thead><tr><th>对象</th><th>生命周期</th><th>数据共享</th><th>容量</th></tr></thead><tbody><tr><td><code>sessionStorage</code></td><td>一次会话（窗口关闭结束）</td><td>本页面</td><td><code>≈ 5M</code></td></tr><tr><td><code>localStorage</code></td><td>长期</td><td>本页面和其它页面</td><td><code>≈ 20M</code></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-BOM-概述&quot;&gt;&lt;a href=&quot;#一-BOM-概述&quot; class=&quot;headerlink&quot; title=&quot;一 BOM 概述&quot;&gt;&lt;/a&gt;一 BOM 概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Browser Object Model&lt;/code&gt; 浏览器对象模
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="UI" scheme="https://anyeansan.github.io/categories/CS/UI/"/>
    
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://anyeansan.github.io/2020/11/08/UI/Promise/"/>
    <id>https://anyeansan.github.io/2020/11/08/UI/Promise/</id>
    <published>2020-11-08T13:09:19.000Z</published>
    <updated>2020-11-08T13:12:15.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二-promise"><a href="#二-promise" class="headerlink" title="二 promise"></a>二 promise</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol><li>Promise 对象本质上表示的是一系列操作的中间状态，或者说是未来某时刻一个操作完成或失败后返回的结果。</li><li>Promise 的回调函数不是正常的异步任务（宏任务），而是微任务（microtask）<ul><li>正常异步任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常异步任务</li></ul></li></ol><h2 id="2-2-promise-状态"><a href="#2-2-promise-状态" class="headerlink" title="2.2 promise 状态"></a>2.2 promise 状态</h2><h3 id="1-三种状态"><a href="#1-三种状态" class="headerlink" title="1 三种状态"></a>1 三种状态</h3><ol><li><code>pending</code> ：初始状态，初始化 promise 时的状态</li><li><code>fulfilled</code>：异步操作成功</li><li><code>rejected</code>：异步操作失败</li></ol><h3 id="2-说明"><a href="#2-说明" class="headerlink" title="2 说明"></a>2 说明</h3><ol><li><code>fulfilled</code> 和 <code>rejected</code> 统称 <code>settled</code> </li><li><code>resolved</code><ol><li>promise 已经 <code>settled</code></li><li>promise 已经使用另一个promise（B）来resolve <ul><li>此时promise的状态由B来决定，可能是<code>pending fulfilled rejected</code> 的任何一种</li></ul></li></ol></li><li><code>unresolved</code> &amp; <code>resolved</code><ul><li><code>unresolved</code> ：promise的状态只能是pending</li><li><code>resolved</code>：promise的状态可能是pending、fulfilled、rejected 的任何一种</li></ul></li></ol><h2 id="2-3-Promise-API"><a href="#2-3-Promise-API" class="headerlink" title="2.3 Promise API"></a>2.3 Promise API</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Promise(executor)</span><br><span class="line">// executor</span><br><span class="line">function(resolve, reject) &#123;&#125;</span><br><span class="line">// 或</span><br><span class="line">(resolve, reject) =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>executor</code><ol><li>指带有 resolve 和 reject 两个参数的函数</li><li>Promise构造函数执行时立即调用executor 函数</li><li>resolve 和 reject 是JavaScript 提供提供的两个函数<ol><li>resolve被调用时，将promise的状态改为<code>fulfilled</code></li><li>reject被调用时，将promise的状态改为<code>rejected</code></li></ol></li><li>如果executor内部出错，将promise的状态改为<code>rejected</code>，且忽略executor返回值</li></ol></li></ul><h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2 静态方法"></a>2 静态方法</h3><ol><li><p><code>Promise.resolve(value)</code></p><ul><li>返回一个以给定值解析后的Promise 对象。</li><li>value<ol><li>如果该value值为promise，返回这个promise；</li><li>如果该value值是thenable（即带有”then” 方法），会将thenable对象包装为promise并返回;</li><li>否则，返回的promise将以此value值完成，即此promise的成功值是value，也就是then方法中第一个函数的参数。</li></ol></li></ul></li><li><p><code>Promise.reject(reason)</code></p><ul><li>返回一个带有拒绝原因的Promise对象</li><li>reason<ul><li>拒绝的原因，通常是一个Error对象，也就是then方法中第二个函数的参数</li></ul></li></ul></li><li><p><code>Promise.all(iterable)</code><br>// TODO</p><ul><li>注：iterable中非promise元素会被转为promise</li></ul><ol><li>如果参数是一个空的可迭代对象<ol><li>返回一个已完成（already resolved）的 Promise。</li><li>此promise会调用成功回调函数，成功值是空数组</li></ol></li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promis.all([]).then(</span><br><span class="line">value =&gt; console.log(value), // []</span><br><span class="line">reason =&gt; console.log(reason)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><pre><code>2. 如果iterable参数不包含任何 promise    1. 返回一个异步完成（asynchronously resolved） Promise    2. 此promise会调用成功回调函数，成功值是由参数的元素构成的数组</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promis.all(&quot;abc&quot;).then(</span><br><span class="line">value =&gt; console.log(value), // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class="line">reason =&gt; console.log(reason)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><pre><code>3. 其它情况下返回一个处理中（pending）的Promise    1. 如果iterable参数中包含的所有promise都成功，则此返回的promise调用成功函数，成功值为一个数组，数组元素为所有promise的成功值和非promise的值</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">resolve(&apos;p1-success&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">Promis.all([p1, 3, 4, &apos;abc&apos;]).then(</span><br><span class="line">value =&gt; console.log(value), // [&apos;p1-success&apos;,3,4,&apos;abc&apos;]</span><br><span class="line">reason =&gt; console.log(reason)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><pre><code>2. 如果iterable参数中 包含的promise 有一个失败，则此返回的promise调用失败函数，失败原因是第一个失败的promise的原因</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">reject(&apos;p1-fail&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">Promis.all([p1, 3, 4, &apos;abc&apos;]).then(</span><br><span class="line">value =&gt; console.log(value), </span><br><span class="line">reason =&gt; console.log(reason) // p1-fail</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="4"><li><code>Promise.allSettled(iterable)</code><ul><li>返回一个fulfilled状态的promise，成功值为一个对象数组，每个对象包含两个属性，表示对应的iterable元素的结果</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;status: &quot;fulfilled&quot;, value: ...&#125;</span><br><span class="line">&#123;status: &quot;rejected&quot;, reason: ...&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><code>Promise.race(iterable)</code><ul><li>返回一个promise，此返回promise的状态取决于iterable参数中promise 成功/失败的最快的那个。 </li></ul></li></ol><h3 id="3-原型方法"><a href="#3-原型方法" class="headerlink" title="3 原型方法"></a>3 原型方法</h3><h4 id="1-then"><a href="#1-then" class="headerlink" title="1 then"></a>1 then</h4><h5 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">then(onFulfilled[, onRejected])</span><br><span class="line"></span><br><span class="line">then(value =&gt; &#123;</span><br><span class="line">// fulfillment</span><br><span class="line">&#125;, reason =&gt; &#123;</span><br><span class="line">// rejection</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="2-参数"><a href="#2-参数" class="headerlink" title="2 参数"></a>2 参数</h5><ul><li>onFulfilled    ，可选<ul><li>当 Promise 变成fulfilled状态时调用的函数，参数为 <code>fulfillment  value</code>，表示成功的值</li><li>如果onFulfilled不是一个函数，会被忽略，内部变成<code>(value) =&gt; value</code>，即将<code>fulfillment  value</code>原样返回</li></ul></li><li>onRejected，可选<ul><li>当 Promise 变成rejected状态时调用的函数，参数为<code>rejection reason</code>，表示失败原因</li><li>如果onRejected不是函数，则会在内部被替换为一个 “Thrower” 函数，抛出失败原因</li></ul></li></ul><h5 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3 返回值"></a>3 返回值</h5><ol><li>如果then没有参数，或者要执行的回调函数对应的参数不是一个函数，则返回的promise与原promise状态相同，且成功值和失败原因也相同。</li><li>如果then没有返回值，则返回的promise，状态为fulfilled，成功值为undefined</li><li>如果then返回一个值，则返回的promise，状态为fulfilled，成功值为返回的值</li><li>如果then抛出错误，则返回的promise，状态为rejected，失败原因为抛出的错误</li><li>如果then返回一个promise（三种状态都有可能），则可以当作是最终返回的promise，即状态，成功值或者失败原因都是一样的</li></ol><table><thead><tr><th>内部返回值</th><th>最终返回promise状态</th><th>成功的值</th><th>失败原因</th></tr></thead><tbody><tr><td>错误</td><td>rejected</td><td>-</td><td>错误</td></tr><tr><td>无</td><td>fulfilled</td><td>undefined</td><td>-</td></tr><tr><td>非promise的值</td><td>fulfilled</td><td>非promise的值</td><td>-</td></tr><tr><td>promise值</td><td>同promise值</td><td>同promise值</td><td>同promise值</td></tr></tbody></table><h4 id="2-catch"><a href="#2-catch" class="headerlink" title="2 catch"></a>2 catch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">catch(onRejected)</span><br><span class="line"></span><br><span class="line">catch(reason =&gt; &#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>等同于 <code>then(undefined, onRejected)</code></li><li>catch之前任一promise状态变为rejected，如果此promise自己没有处理，则会被catch捕获 </li><li>catch返回一个promise，其状态取决于catch内部onRejected函数<ol><li>如果onRejected返回一个rejected状态的Promise或着抛出一个错误，则catch返回的promise状态为rejected</li><li>否则，catch返回的promise状态为fulfilled</li></ol></li></ol><h4 id="3-finally"><a href="#3-finally" class="headerlink" title="3 finally"></a>3 finally</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">finally(onFinally)</span><br><span class="line"></span><br><span class="line">finally(() =&gt; &#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>onFinally<ul><li>Promise 结束后，无论结果是fulfilled或者是rejected，都会执行onFinally回调函数</li></ul></li><li>返回一个设置了 finally 回调函数的Promise对象</li></ul><h1 id="三-async-await"><a href="#三-async-await" class="headerlink" title="三 async / await"></a>三 async / await</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol><li>async/await 是promise 的语法糖</li><li>async用来声明一个异步函数（async function），await操作符只能用在异步函数中</li></ol><h2 id="3-2-async"><a href="#3-2-async" class="headerlink" title="3.2 async"></a>3.2 async</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function show()&#123;&#125;</span><br><span class="line"></span><br><span class="line">let show = async function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">async show()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class xxx&#123;</span><br><span class="line">async show() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>异步函数返回一个promise<ol><li>如果异步函数正常执行，则返回的promise会调用成功函数，成功值为异步函数内部返回值。</li><li>如果异步函数抛出异常，则返回的promise会调用失败函数，失败原因是抛出异常</li></ol></li><li>错误处理<ul><li>async返回一个promise，可以调用catch来处理错误</li></ul></li></ol><h2 id="3-3-await"><a href="#3-3-await" class="headerlink" title="3.3 await"></a>3.3 await</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[return_value] = await expression;</span><br></pre></td></tr></table></figure><ol><li>await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成<ol><li>如果表达式是一个promise，则返回值为promise的处理结果</li><li>如果表达式不是一个promise，则返回该值本身</li></ol></li><li>错误处理<ol><li>await后边的promise出错，相当于async函数返回的promise为reject，所以可以在外部调用catch方法处理</li><li>可以在内部用try…catch…处理</li></ol></li><li>await的并行<ol><li>让promise先执行后再使用await处理结果</li><li>使用 Promise.all() 处理多个promise并行执行</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二-promise&quot;&gt;&lt;a href=&quot;#二-promise&quot; class=&quot;headerlink&quot; title=&quot;二 promise&quot;&gt;&lt;/a&gt;二 promise&lt;/h1&gt;&lt;h2 id=&quot;2-1-概述&quot;&gt;&lt;a href=&quot;#2-1-概述&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="UI" scheme="https://anyeansan.github.io/categories/CS/UI/"/>
    
    
  </entry>
  
  <entry>
    <title>JS执行机制</title>
    <link href="https://anyeansan.github.io/2020/11/08/UI/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>https://anyeansan.github.io/2020/11/08/UI/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</id>
    <published>2020-11-08T13:09:13.000Z</published>
    <updated>2020-11-08T13:12:00.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol><li>JavaScript 是单线程语言</li><li>单线程意味着，所有任务都需要排队，前一个任务结束，才会执行后一个任务</li><li>HTML 5 提出 Web Worker 标准，允许 JavaScript 创建多线程，于是 JS 中出现了同步和异步</li></ol><h1 id="二-JS-任务"><a href="#二-JS-任务" class="headerlink" title="二 JS 任务"></a>二 JS 任务</h1><h2 id="2-1-任务分类（类型）"><a href="#2-1-任务分类（类型）" class="headerlink" title="2.1 任务分类（类型）"></a>2.1 任务分类（类型）</h2><h3 id="1-同步任务"><a href="#1-同步任务" class="headerlink" title="1 同步任务"></a>1 同步任务</h3><ol><li>在主线程上排队执行的任务，形成一个执行栈</li><li>前一个任务执行完毕，才能执行后一个任务</li></ol><h3 id="2-异步任务"><a href="#2-异步任务" class="headerlink" title="2 异步任务"></a>2 异步任务</h3><ol><li>JS 的异步是通过回调函数实现的</li><li>异步任务相关回调函数会进入任务队列（消息队列）</li><li>异步任务不具有“堵塞”效应</li><li>异步任务通常有三种<ol><li>普通事件，如 <code>click resize ...</code></li><li>资源加载，如 <code>load, error ...</code></li><li>定时器</li></ol></li></ol><h2 id="2-2-任务分类（机制）"><a href="#2-2-任务分类（机制）" class="headerlink" title="2.2 任务分类（机制）"></a>2.2 任务分类（机制）</h2><h3 id="1-宏任务（macrotask）"><a href="#1-宏任务（macrotask）" class="headerlink" title="1 宏任务（macrotask）"></a>1 宏任务（macrotask）</h3><ol><li>整个脚本代码（第一个宏任务）</li><li>定时器（setTimeout setInterval ..）</li><li>事件 I/O</li><li>UI 渲染</li><li>…</li></ol><h3 id="2-微任务（microtask）"><a href="#2-微任务（microtask）" class="headerlink" title="2 微任务（microtask）"></a>2 微任务（microtask）</h3><ol><li><code>promise.then</code></li><li>…</li></ol><h1 id="三-JS-执行机制"><a href="#三-JS-执行机制" class="headerlink" title="三 JS 执行机制"></a>三 JS 执行机制</h1><h2 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h2><ol><li>任务队列（task queue）<ul><li>用于存放异步任务</li><li>根据异步任务的类型，可以存在多个任务队列</li></ul></li><li>事件循环（Event Loop）<ul><li>同步任务执行完毕后，引擎会在任务队列循环检查，如果有可以执行的异步任务，则结束等待状态，进入主线程开始执行</li></ul></li></ol><h2 id="3-2-步骤"><a href="#3-2-步骤" class="headerlink" title="3.2 步骤"></a>3.2 步骤</h2><p><img src="https://gitee.com/anis5/pic/raw/master/UI/JS/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.png" alt=""></p><ol><li>脚本代码作为第一个宏任务开始执行，同步任务进入主线程执行栈</li><li>异步任务（宏任务和微任务）交给各自异步处理进程，当满足条件时（如 事件触发，定时器到时…）<ol><li>宏任务进入宏任务队列 <code>macrotask queue</code></li><li>微任务进入微任务队列 <code>microtask queue</code></li></ol></li><li>同步任务执行完毕后，事件循环微任务队列，依次读入主线程执行栈并执行</li><li>微任务队列完毕后，事件循环宏任务队列，每个宏任务与第一个宏任务一样重复以上步骤</li></ol><h2 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 有点类似递归的感觉</span><br><span class="line">* 宏任务</span><br><span class="line">* 同步任务</span><br><span class="line">* 异步任务</span><br><span class="line">* 微任务</span><br><span class="line">* 宏任务</span><br><span class="line">* 同步任务</span><br><span class="line">* 异步任务</span><br><span class="line">* 微任务</span><br><span class="line">* 宏任务</span><br><span class="line">* ...</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;JavaScript 是单线程语言&lt;/li&gt;
&lt;li&gt;单线程意味着，所有任务都需要排队，前一个任务结束，才会执行
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="UI" scheme="https://anyeansan.github.io/categories/CS/UI/"/>
    
    
  </entry>
  
  <entry>
    <title>JS模块</title>
    <link href="https://anyeansan.github.io/2020/11/08/UI/JS%E6%A8%A1%E5%9D%97/"/>
    <id>https://anyeansan.github.io/2020/11/08/UI/JS%E6%A8%A1%E5%9D%97/</id>
    <published>2020-11-08T13:09:06.000Z</published>
    <updated>2020-11-08T13:11:08.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol><li><a href="https://segmentfault.com/a/1190000015302578" target="_blank" rel="noopener">网上概述</a></li><li>ES6 之前有许多方式来实现模块<ul><li><code>AMD</code>：用于浏览器</li><li><code>CommonJS</code>：用于 Node.js</li><li><code>UMD</code>：浏览器/Node.js</li></ul></li><li>ES6 JS有了模块</li><li>模块就是一个独立的文件，文件内部的变量，函数，类…外部无法获取</li><li>使用模块可以解决全局变量冲突</li><li>模块需要隐藏内部实现，只对外开发接口</li><li>模块可以避免滥用全局变量，造成代码不可控</li><li>模块可以被不同的应用使用，提高编码效率</li><li>模块默认运行在严格模式</li><li>模块都有独立的顶级作用域，不同模块间不能相互访问，类似函数作用域</li><li>模块在导入时只执行一次解析，之后的导入不会再执行模块代码，而使用第一次解析结果，并共享数据</li></ol><h1 id="三-加载"><a href="#三-加载" class="headerlink" title="三 加载"></a>三 加载</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>异步加载，即模块总是会在所有html解析后才执行</li></ul><h1 id="四-export"><a href="#四-export" class="headerlink" title="四 export"></a>四 export</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ul><li>模块中的功能默认外部无法使用，使用<code>export</code>命令规定模块的对面接口，即将指定功能导出供外部使用。</li></ul><h2 id="4-2-导出单个"><a href="#4-2-导出单个" class="headerlink" title="4.2 导出单个"></a>4.2 导出单个</h2><ul><li><code>export 声明语句</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export let name = &apos;xiaoqiang&apos;;</span><br><span class="line">export let obj = &#123;&#125;;</span><br><span class="line">export function show() &#123;&#125;;</span><br><span class="line">export class User &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-导出列表"><a href="#4-3-导出列表" class="headerlink" title="4.3 导出列表"></a>4.3 导出列表</h2><ul><li><code>export { name1, name2, …, nameN };</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export let name = &apos;xiaoqiang&apos;;</span><br><span class="line">export let obj = &#123;&#125;;</span><br><span class="line">export function show() &#123;&#125;;</span><br><span class="line">export class User &#123;&#125;</span><br><span class="line">export &#123;name, obj, show, User&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-4-别名"><a href="#4-4-别名" class="headerlink" title="4.4 别名"></a>4.4 别名</h2><ul><li><code>export { variable1 as name1, variable2 as name2, …, nameN };</code></li></ul><h2 id="4-5-默认导出"><a href="#4-5-默认导出" class="headerlink" title="4.5 默认导出"></a>4.5 默认导出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default expression;</span><br><span class="line">export default function (…) &#123; … &#125; // also class, function*</span><br><span class="line">export default function name1(…) &#123; … &#125; // also class, function*</span><br><span class="line">export &#123; name1 as default, … &#125;;</span><br></pre></td></tr></table></figure><ul><li>默认导出接口只能有一个，但默认导出可以与普通导出共存</li><li>本质上，<code>export default</code>就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字</li><li>默认导出时，函数和类可以具名也可以匿名，变量不能具名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default let a = 1; // 错误</span><br><span class="line">let a = 1;</span><br><span class="line">export default a; // 正确，相当于把a的值赋予default</span><br><span class="line">export default 1; // 正确，相当于直接把值赋予default</span><br></pre></td></tr></table></figure><h1 id="五-import（静态导入）"><a href="#五-import（静态导入）" class="headerlink" title="五 import（静态导入）"></a>五 import（静态导入）</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol><li>import用于导入其它模块提供的功能。</li><li>import导入的变量名要与export导出的一致</li><li>import导入的变量是只读的</li><li>import命令具有提升效果，会提升到整个模块的头部，首先执行 </li><li>import是静态导入，不能使用表达式和变量</li><li>在浏览器中引用模块必须添加路径，但在打包工具如webpack中则不需要，因为他们有自己的存放方式。</li></ol><h2 id="5-2-导入所有导出接口"><a href="#5-2-导入所有导出接口" class="headerlink" title="5.2 导入所有导出接口"></a>5.2 导入所有导出接口</h2><ul><li><code>import * as name from &quot;module-name&quot;;</code><ul><li><code>name</code><ul><li>导入模块的命名空间</li></ul></li><li><code>module-name</code><ul><li>要导入的模块。通常是包含目标模块的.js文件的相对或绝对路径名，可以不包括.js扩展名。</li></ul></li><li>使用<code>default</code>获取默认导出</li></ul></li></ul><h2 id="5-3-导入指定导出接口"><a href="#5-3-导入指定导出接口" class="headerlink" title="5.3 导入指定导出接口"></a>5.3 导入指定导出接口</h2><ul><li><code>import { export1, export2, ..., exportN } from &quot;module-name&quot;;</code></li></ul><h2 id="5-4-别名"><a href="#5-4-别名" class="headerlink" title="5.4 别名"></a>5.4 别名</h2><ul><li><code>import { export1 as alias1, export2, ..., exportN } from &quot;module-name&quot;;</code></li></ul><h2 id="5-5-导入默认导出"><a href="#5-5-导入默认导出" class="headerlink" title="5.5 导入默认导出"></a>5.5 导入默认导出</h2><ul><li><code>import defaultExport from &quot;module-name&quot;;</code><ol><li>导入默认导出时名称任意</li><li>由于默认导出只有一个，所以不需要<code>{}</code></li></ol></li></ul><h2 id="5-6-混合导入"><a href="#5-6-混合导入" class="headerlink" title="5.6 混合导入"></a>5.6 混合导入</h2><ul><li><code>import defaultExport, { export1, export2, ..., exportN} from &quot;module-name&quot;;</code></li></ul><h1 id="六-export-default"><a href="#六-export-default" class="headerlink" title="六 export default"></a>六 export default</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><ol><li>使用<code>import</code>命令时，需要知道<code>export</code>导出的变量名。</li><li><code>export default</code> 本质是导出一个名为<code>defualt</code>的变量，使用<code>import</code>导入时可以以任意名称导入。</li><li>一个模块只能有一个默认输出，可以与普通导出共存</li></ol><h2 id="6-2-语法"><a href="#6-2-语法" class="headerlink" title="6.2 语法"></a>6.2 语法</h2><ol><li><code>export default expression</code><ul><li>将<code>expression</code>表达式的值赋给<code>default</code>导出</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = 1;</span><br><span class="line">export default a; // 将a的值1赋给default</span><br><span class="line">export default 1; // 将1赋给default</span><br><span class="line">export default let a = 1; // 错误 因为let a = 1不能计算出一个值</span><br></pre></td></tr></table></figure><ol start="2"><li><code>export default function(){}  // also class, function*</code><ul><li>导出匿名函数/类，名称为<code>default</code></li></ul></li><li><code>export default function name(…) { … } // also class, function*</code><ul><li>导出具名函数/类，名称为<code>default</code>，原有名称会被忽略</li></ul></li><li><code>export { name1 as default, … };</code><ul><li>由于 <code>export default</code> 本质是导出一个名为<code>default</code>的变量</li><li>可以使用<code>export</code>导出一个别名为<code>default</code>的变量</li></ul></li></ol><h1 id="七-export-import"><a href="#七-export-import" class="headerlink" title="七 export + import"></a>七 export + import</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ol><li>可以将导入的模块再次导出</li><li>如果<code>export</code>和<code>import</code>结合在一起，其实就相当于一个转发，并没有导入到当前模块，即当前模块不能使用导入导出的功能。</li></ol><h2 id="7-2-语法"><a href="#7-2-语法" class="headerlink" title="7.2 语法"></a>7.2 语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export * from …;</span><br><span class="line">export &#123; name1, name2, …, nameN &#125; from …;</span><br><span class="line">export &#123; import1 as name1, import2 as name2, …, nameN &#125; from …;</span><br><span class="line">export &#123; default &#125; from …;</span><br></pre></td></tr></table></figure><h1 id="八-import-（动态导入）"><a href="#八-import-（动态导入）" class="headerlink" title="八 import()（动态导入）"></a>八 import()（动态导入）</h1><ol><li>接收参数与静态导入一致 </li><li>使用<code>import()</code> 函数可以动态导入模块，它返回一个 promise 对象，可以按需加载</li><li><code>import()</code> 函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块</li></ol><h1 id="九-工具"><a href="#九-工具" class="headerlink" title="九 工具"></a>九 工具</h1><ol><li>转译器 Transpiler：将现代 JS 代码翻译成所有浏览器都能看懂的代码<ul><li>Babel</li></ul></li><li>打包器 Bundler<ul><li>WebPack</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000015302578&quot; ta
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="UI" scheme="https://anyeansan.github.io/categories/CS/UI/"/>
    
    
  </entry>
  
  <entry>
    <title>JS类</title>
    <link href="https://anyeansan.github.io/2020/11/08/UI/JS%E7%B1%BB/"/>
    <id>https://anyeansan.github.io/2020/11/08/UI/JS%E7%B1%BB/</id>
    <published>2020-11-08T13:09:01.000Z</published>
    <updated>2020-11-08T13:11:03.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol><li>class 只是语法糖，为了让类的声明与继承更加简洁清晰，底层实现机制依然是原型继承，与其它语言的 class 不一样</li><li>class 其实就是函数，<code>typeof 类 -&gt; function</code></li><li>class 内部代码始终以严格模式执行</li><li>class 不存在变量提升</li><li>class 中的属性名可以采用表达式<code>[]</code></li><li>class 中定义的属性都是实例属性，定义的方法都是原型方法且不可枚举</li></ol><h1 id="二-语法"><a href="#二-语法" class="headerlink" title="二 语法"></a>二 语法</h1><h2 id="2-1-类"><a href="#2-1-类" class="headerlink" title="2.1 类"></a>2.1 类</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 类声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名 </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 类表达式</span></span><br><span class="line"><span class="keyword">let</span> 类名= <span class="class"><span class="keyword">class</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种方式都不会提升</span></span><br></pre></td></tr></table></figure><h2 id="2-2-构造函数"><a href="#2-2-构造函数" class="headerlink" title="2.2 构造函数"></a>2.2 构造函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数语法</span></span><br><span class="line"><span class="keyword">constructor</span>(参数列表) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类默认构造函数</span></span><br><span class="line"><span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类默认构造函数</span></span><br><span class="line"><span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line"><span class="keyword">super</span>(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用类 <code>new</code> 一个对象时会自动调用构造函数</li><li>如果省略，则会有默认构造函数</li><li><code>constructor</code> 默认返回实例对象（即 <code>this</code>），可以改为返回另一个对象</li><li>类的原型的 <code>constructor</code> 属性指向类本身：<code>类.prototype.constructor = 类</code></li></ol><h2 id="2-3-属性-amp-方法"><a href="#2-3-属性-amp-方法" class="headerlink" title="2.3 属性 &amp; 方法"></a>2.3 属性 &amp; 方法</h2><h3 id="1-实例属性"><a href="#1-实例属性" class="headerlink" title="1 实例属性"></a>1 实例属性</h3><ol><li><p>使用<code>this.</code> 定义在<code>constructor</code>中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(age) &#123;</span><br><span class="line"><span class="keyword">this</span>.age = age; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在类中直接定义的属性就是实例属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">age = <span class="number">18</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-原型方法"><a href="#2-原型方法" class="headerlink" title="2 原型方法"></a>2 原型方法</h3><ol><li><p>在类的原型上定义方法，是可枚举的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>在类中直接定义的方法就是原型方法，且不可枚举（non-enumerable）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">show()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-静态属性-方法"><a href="#3-静态属性-方法" class="headerlink" title="3 静态属性/方法"></a>3 静态属性/方法</h3><ol><li><p>定义在类上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User.age = <span class="number">10</span>;</span><br><span class="line">User.show() = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在类中定义的属性/方法前加<code>static</code>关键字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 静态方法可以包含 this 关键字，this 指的是类本身，而不是实例对象 </span></span><br><span class="line"><span class="keyword">static</span> show() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-私有属性-方法"><a href="#4-私有属性-方法" class="headerlink" title="4 私有属性 / 方法"></a>4 私有属性 / 方法</h3><h4 id="1-利用-Symbol"><a href="#1-利用-Symbol" class="headerlink" title="1 利用 Symbol"></a>1 利用 Symbol</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _name = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> _show = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>[_name] = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [_show]()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-利用集合"><a href="#2-利用集合" class="headerlink" title="2 利用集合"></a>2 利用集合</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _name = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> _show = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        _name.set(<span class="keyword">this</span>, name);</span><br><span class="line">        _show.set(<span class="keyword">this</span>, () =&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-约定"><a href="#3-约定" class="headerlink" title="3 约定"></a>3 约定</h4><ol><li><p>私有属性：在属性名前加 <code>#</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">#phone = '13800000000';   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>私有方法：以表达式形式定义方法并在方法前加<code>#</code> ，可以理解为就是定义私有属性，不过属性的值是一个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">#say = function() &#123;&#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-受保护属性-方法"><a href="#5-受保护属性-方法" class="headerlink" title="5 受保护属性 / 方法"></a>5 受保护属性 / 方法</h3><ul><li>在属性/方法名前加 <code>_</code>，这只是约定不是语法也不是规范</li><li>可以通过 <code>symbol weakmap ...</code> 人为实现保护</li></ul><h2 id="2-4-访问器-getter-setter"><a href="#2-4-访问器-getter-setter" class="headerlink" title="2.4 访问器 getter/setter"></a>2.4 访问器 getter/setter</h2><ul><li>类中同样可以使用访问器，且访问器也是定义在属性的属性描述符上</li></ul><h1 id="三-class-的继承"><a href="#三-class-的继承" class="headerlink" title="三 class 的继承"></a>三 class 的继承</h1><h2 id="3-1-extends"><a href="#3-1-extends" class="headerlink" title="3.1 extends"></a>3.1 extends</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 子类构造函数第一行必须先调用父类构造函数</span></span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-super"><a href="#3-2-super" class="headerlink" title="3.2 super"></a>3.2 super</h2><h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1 问题"></a>1 问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 子 父：在子类中调用父类方法</span></span><br><span class="line">子：<span class="keyword">this</span>.__proto__.__proto__</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 子 父 爷：在子类中调用父类方法，父类方法中又调用了父类的父类的方法</span></span><br><span class="line">子：<span class="keyword">this</span>.__proto__.__proto__</span><br><span class="line">父：<span class="keyword">this</span>.__proto__</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 父 爷：直接在父类中调用父类的父类的方法</span></span><br><span class="line">父：<span class="keyword">this</span>.__proto__.__proto__</span><br></pre></td></tr></table></figure><ul><li>如果只有双层继承，使用 <code>this</code>是可以的，如果有多重继承，同一个类中的代码不同情况是不一样的</li></ul><h3 id="2-用法"><a href="#2-用法" class="headerlink" title="2 用法"></a>2 用法</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h4><ol><li><p>super 只能在类或对象的方法中使用，而不能在函数中使用</p></li><li><p>使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误，无法看出是函数还是对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">super</span>);</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-调用父类构造"><a href="#2-调用父类构造" class="headerlink" title="2 调用父类构造"></a>2 调用父类构造</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此时 super 代表父类的构造函数</span></span><br><span class="line"><span class="keyword">super</span>([<span class="built_in">arguments</span>]);</span><br></pre></td></tr></table></figure><h4 id="3-调用父类方法"><a href="#3-调用父类方法" class="headerlink" title="3 调用父类方法"></a>3 调用父类方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此时 super 代表父类原型对象，如果是静态方法则 super 代表父类本身</span></span><br><span class="line"><span class="keyword">super</span>.functionOnParent([<span class="built_in">arguments</span>]);</span><br></pre></td></tr></table></figure><h2 id="3-3-原生构造函数的继承"><a href="#3-3-原生构造函数的继承" class="headerlink" title="3.3 原生构造函数的继承"></a>3.3 原生构造函数的继承</h2><ol><li>之前，这些内置的构造函数如<code>Object() Array() ...</code> 是无法继承的</li><li>ES6 允许继承</li></ol><h2 id="3-4-mixin"><a href="#3-4-mixin" class="headerlink" title="3.4 mixin"></a>3.4 mixin</h2><ol><li>创建一个 mixin 类，包含许多供其它类使用的方法</li><li>将 mixin 类合并到要使用功能的类的原型上</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;class 只是语法糖，为了让类的声明与继承更加简洁清晰，底层实现机制依然是原型继承，与其它语言的 class 
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="UI" scheme="https://anyeansan.github.io/categories/CS/UI/"/>
    
    
  </entry>
  
  <entry>
    <title>JS原型</title>
    <link href="https://anyeansan.github.io/2020/11/08/UI/JS%E5%8E%9F%E5%9E%8B/"/>
    <id>https://anyeansan.github.io/2020/11/08/UI/JS%E5%8E%9F%E5%9E%8B/</id>
    <published>2020-11-08T13:08:56.000Z</published>
    <updated>2020-11-08T13:11:55.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-原型"><a href="#1-1-原型" class="headerlink" title="1.1 原型"></a>1.1 原型</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/JS/%E5%8E%9F%E5%9E%8B.png" alt=""></p><h3 id="1-proto"><a href="#1-proto" class="headerlink" title="1 __proto__"></a>1 <code>__proto__</code></h3><ol><li><p><code>__proto__</code> 是浏览器实现的非 JavaScript 标准的属性，在ES6写入了附录，用于获取或设置对象的原型，由于非标准，浏览器有这个属性，其它环境未必有。建议使用 Object中 的方法 替代<code>__proto__</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- <span class="built_in">Object</span>.getPrototypeOf(obj)</span><br><span class="line">- <span class="built_in">Object</span>.setPrototypeOf(obj, prototype)</span><br><span class="line">- <span class="built_in">Object</span>.create(proto[, propertiesObject])</span><br></pre></td></tr></table></figure></li><li><p><code>obj.__proto__</code> 并非是普通的属性访问方式，而是通过 <code>getter/setter</code> 访问器，可以理解为 <code>prototype</code> 属性的 <code>getter/setter</code> 实现</p></li><li><p>每个对象都有 <code>__proto__</code> 属性，指向它的构造函数的原型对象，即如果A对象是由B函数构造的，则 <code>A.__proto__ === B.prototype</code></p><ol><li>普通对象的构造函数是其对应的构造函数，原型对象也是普通对象，其默认构造函数是 Object，则<ul><li><code>对象.__proto__ === 构造函数.prototype</code></li><li><code>原型对象.__proto__ === Object.prototype</code></li></ul></li><li>原型对象中有两个特殊<ol><li><code>Object.prototype</code>：它是原型链的顶端，<code>Object.prototype.__proto__ === null</code></li><li><code>Function.prototype</code><ul><li>它是原型对象，但不属于普通对象而属于函数对象</li><li>它是函数对象，但它没有 <code>prototype</code> 属性</li></ul></li></ol></li><li>函数对象（包括 Function 自身）的构造函数是 Function，则 <ul><li><code>函数.__proto__ === Function.prototype</code></li><li><code>Function.__proto__ === Function.prototype</code></li></ul></li></ol></li></ol><h3 id="2-prototype"><a href="#2-prototype" class="headerlink" title="2 prototype"></a>2 <code>prototype</code></h3><ol><li>每个构造函数都有 <code>prototype</code> 属性，指向其原型对象，原型对象用于所有实例共享属性和方法</li><li>函数作为对象有 <code>__proto__</code> 属性，又可以作为构造函数有<code>prototype</code> 属性</li><li>原型的作用是让该构造函数所实例化的对象们都可以找到公用的属性和方法，所以 JS 的继承是通过 <code>prototype</code> 实现的</li></ol><h3 id="3-constructor"><a href="#3-constructor" class="headerlink" title="3 constructor"></a>3 <code>constructor</code></h3><ul><li>只有原型对象才有 <code>constructor</code> 属性，指向对应构造函数<ul><li><code>实例对象.__proto__ === 原型对象</code></li><li><code>构造函数.prototype === 原型对象</code></li><li><code>原型对象.constructor === 构造函数</code></li></ul></li></ul><h2 id="1-2-原型链"><a href="#1-2-原型链" class="headerlink" title="1.2 原型链"></a>1.2 原型链</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/JS/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt=""></p><ul><li>对象有自己的原型对象，而对象又可以充当其他对象的原型，就会形成一个“原型链”（prototype chain）</li></ul><h2 id="1-3-new"><a href="#1-3-new" class="headerlink" title="1.3 new"></a>1.3 new</h2><h3 id="1-new的执行过程"><a href="#1-new的执行过程" class="headerlink" title="1 new的执行过程"></a>1 new的执行过程</h3><ol><li>创建一个空对象 <code>let obj = {};</code></li><li>将新建对象的 <code>__proto__</code> 指向构造函数的原型对象，<code>obj.__proto__ = 构造函数.prototype</code></li><li>将新建对象作为构造函数执行的上下文，即将构造函数内部的 <code>this</code> 指向新建对象</li><li>执行构造函数，如果构造函数没有返回引用类型的值，则返回新建对象</li></ol><h3 id="2-自定义-new"><a href="#2-自定义-new" class="headerlink" title="2 自定义 new"></a>2 自定义 new</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myNew = <span class="function"><span class="keyword">function</span>(<span class="params">cons, args</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;; <span class="comment">// 步骤1</span></span><br><span class="line">obj.__proto__ = cons.prototype; <span class="comment">// 步骤2</span></span><br><span class="line"><span class="comment">// let obj = Object.create(cons.prototype); 步骤1，2合在一起</span></span><br><span class="line"><span class="keyword">let</span> result = cons.apply(obj, args); <span class="comment">// 步骤3</span></span><br><span class="line"><span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj; <span class="comment">// 步骤4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-new-target-属性"><a href="#3-new-target-属性" class="headerlink" title="3 new.target 属性"></a>3 <code>new.target</code> 属性</h3><ul><li>用来检测函数是否通过<code>new</code>或者<code>Reflect.construct()</code>调用的<ol><li>如果在普通函数中使用，返回 <code>undefined</code></li><li>在构造函数中使用指向被 new 调用的构造函数</li><li>在 <code>class</code> 的 <code>constructor</code> 函数中使用指向被 new 调用的 <code>class</code></li></ol></li></ul><h1 id="二-构造函数中的属性和方法"><a href="#二-构造函数中的属性和方法" class="headerlink" title="二 构造函数中的属性和方法"></a>二 构造函数中的属性和方法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>; <span class="comment">// 私有属性</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// 私有方法</span></span><br><span class="line"><span class="keyword">this</span>.name = name; <span class="comment">// 实例属性</span></span><br><span class="line"><span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;<span class="comment">// 实例方法</span></span><br><span class="line">&#125;</span><br><span class="line">User.country = <span class="string">'中国'</span>; <span class="comment">// 静态属性</span></span><br><span class="line">User.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// 静态方法</span></span><br><span class="line">User.prototype.gender = <span class="string">'男'</span>; <span class="comment">// 原型属性</span></span><br><span class="line">User.prototype.change = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// 原型方法</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td>私有属性 / 方法</td><td>在对象内部使用 <code>var/let/const</code>声明的属性/方法（严格来说只是内部的局部变量不属于对象）</td></tr><tr><td>实例属性 / 方法</td><td>在对象内部使用<code>this.</code>声明的属性/方法</td></tr><tr><td>静态属性 / 方法</td><td>定义在构造函数上的属性/方法</td></tr><tr><td>原型属性 / 方法</td><td>定义在构造函数原型上的属性/方法 ，<strong>原型方法默认可枚举</strong></td></tr></tbody></table><h1 id="三-继承"><a href="#三-继承" class="headerlink" title="三 继承"></a>三 继承</h1><h2 id="3-1-继承原理"><a href="#3-1-继承原理" class="headerlink" title="3.1 继承原理"></a>3.1 继承原理</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/JS/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF.png" alt=""></p><ul><li><code>1 -&gt; 2</code>：将子类构造函数的原型对象的原型指向父类构造函数的原型对象</li></ul><h2 id="3-2-设置原型方式"><a href="#3-2-设置原型方式" class="headerlink" title="3.2 设置原型方式"></a>3.2 设置原型方式</h2><ol><li><p>设置构造函数原型，使用函数的 <code>prototype</code> 属性</p></li><li><p>设置对象的原型</p><ol><li><p>Object 的方法，创建对象时指定原型（只是定义无法获取）：<code>Object.create(proto[, propertiesObject])</code> </p></li><li><p>使用对象的属性<code>__proto__</code> 获取或设置原型，在浏览器之外的环境可能不行。</p></li><li><p>Object 的方法，与<code>__proto__</code>效果一样，但是是 JS 标准</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj)</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, prototype)</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="3-3-实现继承的方式"><a href="#3-3-实现继承的方式" class="headerlink" title="3.3 实现继承的方式"></a>3.3 实现继承的方式</h2><h3 id="1-原型链-1"><a href="#1-原型链-1" class="headerlink" title="1 原型链-1"></a>1 原型链-1</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/JS/%E7%BB%A7%E6%89%BF1.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.prototype.__proto__ = B.prototype;</span><br></pre></td></tr></table></figure><ul><li>将子类构造函数的原型对象的原型直接指向父类构造函数的原型</li><li>好处<ul><li>父类原型在子类原型链上，则子类可以继承父类的原型属性/方法</li></ul></li><li>弊端<ul><li>创建子类时不会调用父类构造函数，无法继承父类的实例属性/方法</li></ul></li></ul><h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2 构造函数"></a>2 构造函数</h3><ul><li><p>在子类构造函数中通过<code>call/apply</code>调用父类构造函数，并指定this为子类对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fu</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Zi</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">Fu(name,age); <span class="comment">// 不行，因为直接调用时，父类构造函数this是指向window的</span></span><br><span class="line">Fu.call(<span class="keyword">this</span>, name, age); </span><br><span class="line">Fu.apply(<span class="keyword">this</span>, [name, age])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>好处</p><ul><li>创建的子类实例具备父类实例属性/方法</li></ul></li><li><p>弊端</p><ol><li>只是子类的实例，不是父类的实例（只是通过调用父类构造函数模拟继承）</li><li>无法继承父类原型属性/方法</li></ol></li></ul><h3 id="3-原型链-2"><a href="#3-原型链-2" class="headerlink" title="3 原型链-2"></a>3 原型链-2</h3><h4 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h4><p><img src="https://github.com/anyeansan/pics/raw/master/CS/UI/JS/%E7%BB%A7%E6%89%BF2.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.prototype = new B();</span><br></pre></td></tr></table></figure><ul><li>将子类构造函数的原型对象修改为一个父类实例（舍弃原有原型对象）</li><li>好处<ul><li>父类实例对象具有父类的实例属性/方法，父类实例对象的原型又指向父类构造函数原型，所以父类的实例属性/方法 和 原型属性/方法，子类都可以继承</li></ul></li><li>弊端<ol><li>父类的实例属性/方法是在子类原型对象上，这就导致父类的实例属性/方法实际上变成了子类的原型属性/方法。</li><li>需要手动为新的子类原型对象添加 <code>constructor</code>属性</li></ol></li></ul><h4 id="2-对新增对象的影响"><a href="#2-对新增对象的影响" class="headerlink" title="2 对新增对象的影响"></a>2 对新增对象的影响</h4><ul><li>如果新增对象在修改原型操作之前，那就意味着，新增对象指向的原型还是原来被舍弃的原型，所以这种方式只对修改原型操作之后新增的对象有效 </li></ul><h4 id="3-对constructor的影响"><a href="#3-对constructor的影响" class="headerlink" title="3 对constructor的影响"></a>3 对constructor的影响</h4><ul><li><p>由于这种方式是将子类原型修改成了一个新的对象，而这个新对象中是没有<code>constructor</code>属性的，所以需要手动为新对象添加<code>constructor</code>属性，并指向子类构造函数</p><ol><li><p>直接添加（有一个弊端，就是<code>constructor</code>属性默认可遍历）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.prototype.constructor = A;</span><br></pre></td></tr></table></figure></li><li><p>使用Object的 <code>defineProperty()</code> 添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(A.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">value: A,</span><br><span class="line">enumerable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="4-组合继承1（构造函数-原型链2）"><a href="#4-组合继承1（构造函数-原型链2）" class="headerlink" title="4 组合继承1（构造函数+原型链2）"></a>4 组合继承1（构造函数+原型链2）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.gender = <span class="string">'nan'</span>;</span><br><span class="line">B.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">B.call(<span class="keyword">this</span>, <span class="string">'小猫'</span>); <span class="comment">// 第一次调用</span></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype = <span class="keyword">new</span> B(<span class="string">'小狗'</span>); <span class="comment">// 第二次调用</span></span><br><span class="line">A.prototype.constructor = A;</span><br></pre></td></tr></table></figure><ul><li>好处<ul><li>通过构造函数方式可以继承到父类的实例属性/方法</li><li>通过原型链方式可以继承到父类的原型属性/方法</li></ul></li><li>弊端<ol><li>父类的实例属性会在子类实例和子类原型上都定义一份，不过不影响，因为会先使用实例自己的属性</li><li>会调用两次父类构造函数</li><li>需要手动为新的子类原型对象添加 <code>constructor</code>属性</li><li>子类原有的原型对象上的属性和方法没有了</li></ol></li></ul><h3 id="5-组合继承2（构造函数-原型链1）"><a href="#5-组合继承2（构造函数-原型链1）" class="headerlink" title="5 组合继承2（构造函数+原型链1）"></a>5 组合继承2（构造函数+原型链1）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.gender = <span class="string">'nan'</span>;</span><br><span class="line">B.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">B.call(<span class="keyword">this</span>, <span class="string">'小猫'</span>); </span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.__proto__ = B.prototype</span><br></pre></td></tr></table></figure><ul><li>好处<ul><li>通过构造函数方式可以继承到父类的实例属性/方法</li><li>通过原型链方式可以继承到父类的原型属性/方法</li></ul></li><li>弊端<ul><li><code>__proto__</code> 在浏览器之外的环境可能不行。</li><li><code>B.prototype</code> 中的 <code>constructor</code> 指向的是父类构造函数</li></ul></li></ul><h3 id="6-最终方式"><a href="#6-最终方式" class="headerlink" title="6 最终方式"></a>6 最终方式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.gender = <span class="string">'nan'</span>;</span><br><span class="line">B.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1 继承父类实例属性/方法</span></span><br><span class="line">B.call(<span class="keyword">this</span>, <span class="string">'小猫'</span>); </span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 设置子类原型对象</span></span><br><span class="line">A.prototype = <span class="built_in">Object</span>.create(B.prototype);</span><br><span class="line"><span class="comment">// 3 为子类原型对象添加 constructor</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(A.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">value: A,</span><br><span class="line">enumerable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-4-对象工厂"><a href="#3-4-对象工厂" class="headerlink" title="3.4 对象工厂"></a>3.4 对象工厂</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fu</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(Fu.prototype);</span><br><span class="line">Fu.call(obj, ...args); <span class="comment">//通过调用父类</span></span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>与继承方式类似，只是通过对象工厂创建子类对象，不需要子类构造函数<ol><li>创建一个以父类原型为原型的对象，相当于继承了父类原型属性/方法</li><li>调用父类构造函数，并设置this为新建对象，即相当于继承了父类实例属性</li><li>返回新建对象</li></ol></li></ul><h2 id="3-5-静态属性-方法的继承"><a href="#3-5-静态属性-方法的继承" class="headerlink" title="3.5 静态属性/方法的继承"></a>3.5 静态属性/方法的继承</h2><ul><li><p>静态属性/方法即在构造函数上定义的属性/方法，继承原理都是一样的，函数也是对象，把子类构造函数看作对象，设置其原型为父类构造函数，即可继承静态属性/方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fu</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Fu.haha = <span class="string">"wangcai"</span>;</span><br><span class="line">Fu.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fu static show'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Zi</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Zi.__proto__ = Fu;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-6-Mixin-模式"><a href="#3-6-Mixin-模式" class="headerlink" title="3.6 Mixin 模式"></a>3.6 Mixin 模式</h2><ol><li><p>JS 不支持多继承，也没有接口实现，如果要使用多个类的方法时可以使用 mixin 混合模式来完成</p></li><li><p>Mixin模式 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口</p></li><li><p>Mixin 可以看作是一个包含许多功能的对象，使用时将这些功能合并到要使用功能的对象原型上即可</p></li><li><p>例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myMix = &#123;</span><br><span class="line">sayHi() &#123;&#125;,</span><br><span class="line">sayBye() &#123;&#125;,</span><br><span class="line">eat()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 合并之后，User的实例就有了myMix的所有功能了</span></span><br><span class="line"><span class="built_in">Object</span>.assign(User.prototype, myMix);</span><br><span class="line"><span class="comment">// 手动添加某个功能</span></span><br><span class="line">User.prototype.eat = myHix.eat;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-原型&quot;&gt;&lt;a href=&quot;#1-1-原型&quot; class=&quot;headerlink&quot; title=&quot;1.1 原
      
    
    </summary>
    
    
      <category term="CS" scheme="https://anyeansan.github.io/categories/CS/"/>
    
      <category term="UI" scheme="https://anyeansan.github.io/categories/CS/UI/"/>
    
    
  </entry>
  
</feed>
