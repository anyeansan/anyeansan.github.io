<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/anyeansan.github.io/images/an-apple-180.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/anyeansan.github.io/images/an-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/anyeansan.github.io/images/an-16.png">
  <link rel="mask-icon" href="/anyeansan.github.io/images/an.svg" color="#222">
  <link rel="alternate" href="/anyeansan.github.io/atom.xml" title="安₃" type="application/atom+xml">

<link rel="stylesheet" href="/anyeansan.github.io/css/main.css">


<link rel="stylesheet" href="/anyeansan.github.io/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/anyeansan.github.io/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"hide","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="一蓑烟雨任平生">
<meta property="og:type" content="website">
<meta property="og:title" content="安₃">
<meta property="og:url" content="https:&#x2F;&#x2F;anyeansan.github.io&#x2F;">
<meta property="og:site_name" content="安₃">
<meta property="og:description" content="一蓑烟雨任平生">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://anyeansan.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>安₃</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/anyeansan.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">安₃</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">我未成名君未嫁 可能俱是不如人</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/anyeansan.github.io/" rel="section"><i class="fa fa-fw fa-home"></i>安府</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/anyeansan.github.io/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>书斋</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/anyeansan.github.io/categories/" rel="section"><i class="fa fa-fw fa-th"></i>门派</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/anyeansan" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/03/30/Javascript-%E5%BC%82%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/03/30/Javascript-%E5%BC%82%E6%AD%A5/" class="post-title-link" itemprop="url">Javascript 异步</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-03-30 22:33:35 / 修改时间：22:35:57" itemprop="dateCreated datePublished" datetime="2020-03-30T22:33:35+08:00">2020-03-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/UI/Javascript/" itemprop="url" rel="index">
                    <span itemprop="name">Javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-JavaScript是单线程的。"><a href="#1-1-JavaScript是单线程的。" class="headerlink" title="1.1 JavaScript是单线程的。"></a>1.1 JavaScript是单线程的。</h2><ul>
<li>注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合</li>
</ul>
<h2 id="1-2-同步任务和异步任务"><a href="#1-2-同步任务和异步任务" class="headerlink" title="1.2 同步任务和异步任务"></a>1.2 同步任务和异步任务</h2><ul>
<li>同步任务<ul>
<li>在主线程上排队执行的任务。</li>
<li>只有前一个任务执行完毕，才能执行后一个任务</li>
</ul>
</li>
<li>异步任务<ul>
<li>不进入主线程而进入任务队列的任务</li>
<li>只有引擎认为某个异步任务可以执行了，该任务才会进入主线程执行</li>
<li>异步任务不具有“堵塞”效应，即异步任务后的代码不用等待异步任务结束。</li>
</ul>
</li>
</ul>
<h2 id="1-3-任务队列和事件循环"><a href="#1-3-任务队列和事件循环" class="headerlink" title="1.3 任务队列和事件循环"></a>1.3 任务队列和事件循环</h2><ul>
<li>任务队列（task queue）<ul>
<li>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供任务队列，里面是各种需要当前程序处理的异步任务。（根据异步任务的类型，可以存在多个任务队列。）</li>
</ul>
</li>
<li>事件循环（Event Loop）<ul>
<li>同步任务执行完毕后，引擎会在任务队列循环检查，如果有可以执行的异步任务，则结束等待状态，进入主线程开始执行。</li>
</ul>
</li>
<li>执行步骤<ol>
<li>首先，主线程会去执行所有的同步任务，异步任务会进入任务队列。</li>
<li>同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。</li>
<li>直到任务队列清空，程序结束执行。</li>
</ol>
</li>
</ul>
<h2 id="1-4-异步操作模式"><a href="#1-4-异步操作模式" class="headerlink" title="1.4 异步操作模式"></a>1.4 异步操作模式</h2><ol>
<li>回调函数callback<ul>
<li>定时器，ajax……</li>
<li>缺点<ol>
<li>高耦合，维护困难，回调地狱，当多个异步任务多级依赖时，回调函数会形成多级嵌套</li>
<li>每个任务只能指定一个回调函数</li>
<li>如果多个异步操作没有顺序之分，同样需要等待上一个操作执行结束再进行下一个操作</li>
</ol>
</li>
</ul>
</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>promise</li>
<li>generators</li>
<li>async/await</li>
</ol>
<h1 id="二-promise"><a href="#二-promise" class="headerlink" title="二 promise"></a>二 promise</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol>
<li>Promise 对象本质上表示的是一系列操作的中间状态，或者说是未来某时刻一个操作完成或失败后返回的结果。</li>
<li>Promise 的回调函数不是正常的异步任务（宏任务），而是微任务（microtask）<ul>
<li>正常异步任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常异步任务</li>
</ul>
</li>
</ol>
<h2 id="2-2-promise-状态"><a href="#2-2-promise-状态" class="headerlink" title="2.2 promise 状态"></a>2.2 promise 状态</h2><h3 id="1-三种状态"><a href="#1-三种状态" class="headerlink" title="1 三种状态"></a>1 三种状态</h3><ol>
<li><code>pending</code> ：初始状态，初始化 promise 时的状态</li>
<li><code>fulfilled</code>：异步操作成功</li>
<li><code>rejected</code>：异步操作失败</li>
</ol>
<h3 id="2-说明"><a href="#2-说明" class="headerlink" title="2 说明"></a>2 说明</h3><ol>
<li><code>fulfilled</code> 和 <code>rejected</code> 统称 <code>settled</code> </li>
<li><code>resolved</code><ol>
<li>promise 已经 <code>settled</code></li>
<li>promise 已经使用另一个promise（B）来resolve <ul>
<li>此时promise的状态由B来决定，可能是<code>pending fulfilled rejected</code> 的任何一种</li>
</ul>
</li>
</ol>
</li>
<li><code>unresolved</code> &amp; <code>resolved</code><ul>
<li><code>unresolved</code> ：promise的状态只能是pending</li>
<li><code>resolved</code>：promise的状态可能是pending、fulfilled、rejected 的任何一种</li>
</ul>
</li>
</ol>
<h2 id="2-3-Promise-API"><a href="#2-3-Promise-API" class="headerlink" title="2.3 Promise API"></a>2.3 Promise API</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Promise(executor)</span><br><span class="line">// executor</span><br><span class="line">function(resolve, reject) &#123;&#125;</span><br><span class="line">// 或</span><br><span class="line">(resolve, reject) =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>executor</code><ol>
<li>指带有 resolve 和 reject 两个参数的函数</li>
<li>Promise构造函数执行时立即调用executor 函数</li>
<li>resolve 和 reject 是JavaScript 提供提供的两个函数<ol>
<li>resolve被调用时，将promise的状态改为<code>fulfilled</code></li>
<li>reject被调用时，将promise的状态改为<code>rejected</code></li>
</ol>
</li>
<li>如果executor内部出错，将promise的状态改为<code>rejected</code>，且忽略executor返回值</li>
</ol>
</li>
</ul>
<h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2 静态方法"></a>2 静态方法</h3><ol>
<li><p><code>Promise.resolve(value)</code></p>
<ul>
<li>返回一个以给定值解析后的Promise 对象。</li>
<li>value<ol>
<li>如果该value值为promise，返回这个promise；</li>
<li>如果该value值是thenable（即带有”then” 方法），会将thenable对象包装为promise并返回;</li>
<li>否则，返回的promise将以此value值完成，即此promise的成功值是value，也就是then方法中第一个函数的参数。</li>
</ol>
</li>
</ul>
</li>
<li><p><code>Promise.reject(reason)</code></p>
<ul>
<li>返回一个带有拒绝原因的Promise对象</li>
<li>reason<ul>
<li>拒绝的原因，通常是一个Error对象，也就是then方法中第二个函数的参数</li>
</ul>
</li>
</ul>
</li>
<li><p><code>Promise.all(iterable)</code><br> // TODO</p>
<ul>
<li>注：iterable中非promise元素会被转为promise</li>
</ul>
<ol>
<li>如果参数是一个空的可迭代对象<ol>
<li>返回一个已完成（already resolved）的 Promise。</li>
<li>此promise会调用成功回调函数，成功值是空数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promis.all([]).then(</span><br><span class="line">	value =&gt; console.log(value), // []</span><br><span class="line">	reason =&gt; console.log(reason)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>如果iterable参数不包含任何 promise<ol>
<li>返回一个异步完成（asynchronously resolved） Promise</li>
<li>此promise会调用成功回调函数，成功值是由参数的元素构成的数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promis.all(&quot;abc&quot;).then(</span><br><span class="line">	value =&gt; console.log(value), // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class="line">	reason =&gt; console.log(reason)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>其它情况下返回一个处理中（pending）的Promise<ol>
<li>如果iterable参数中包含的所有promise都成功，则此返回的promise调用成功函数，成功值为一个数组，数组元素为所有promise的成功值和非promise的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">	resolve(&apos;p1-success&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">Promis.all([p1, 3, 4, &apos;abc&apos;]).then(</span><br><span class="line">	value =&gt; console.log(value), // [&apos;p1-success&apos;,3,4,&apos;abc&apos;]</span><br><span class="line">	reason =&gt; console.log(reason)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>如果iterable参数中 包含的promise 有一个失败，则此返回的promise调用失败函数，失败原因是第一个失败的promise的原因<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">	reject(&apos;p1-fail&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">Promis.all([p1, 3, 4, &apos;abc&apos;]).then(</span><br><span class="line">	value =&gt; console.log(value), </span><br><span class="line">	reason =&gt; console.log(reason) // p1-fail</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p><code>Promise.allSettled(iterable)</code></p>
<ul>
<li>返回一个fulfilled状态的promise，成功值为一个对象数组，每个对象包含两个属性，表示对应的iterable元素的结果<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;status: &quot;fulfilled&quot;, value: ...&#125;</span><br><span class="line">&#123;status: &quot;rejected&quot;, reason: ...&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>Promise.race(iterable)</code></p>
<ul>
<li>返回一个promise，此返回promise的状态取决于iterable参数中promise 成功/失败的最快的那个。 </li>
</ul>
</li>
</ol>
<h3 id="3-原型方法"><a href="#3-原型方法" class="headerlink" title="3 原型方法"></a>3 原型方法</h3><h4 id="1-then"><a href="#1-then" class="headerlink" title="1 then"></a>1 then</h4><h5 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">then(onFulfilled[, onRejected])</span><br><span class="line"></span><br><span class="line">then(value =&gt; &#123;</span><br><span class="line">	// fulfillment</span><br><span class="line">&#125;, reason =&gt; &#123;</span><br><span class="line">	// rejection</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="2-参数"><a href="#2-参数" class="headerlink" title="2 参数"></a>2 参数</h5><ul>
<li>onFulfilled    ，可选<ul>
<li>当 Promise 变成fulfilled状态时调用的函数，参数为 <code>fulfillment  value</code>，表示成功的值</li>
<li>如果onFulfilled不是一个函数，会被忽略，内部变成<code>(value) =&gt; value</code>，即将<code>fulfillment  value</code>原样返回</li>
</ul>
</li>
<li>onRejected，可选<ul>
<li>当 Promise 变成rejected状态时调用的函数，参数为<code>rejection reason</code>，表示失败原因</li>
<li>如果onRejected不是函数，则会在内部被替换为一个 “Thrower” 函数，抛出失败原因</li>
</ul>
</li>
</ul>
<h5 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3 返回值"></a>3 返回值</h5><ol>
<li>如果then没有参数，或者要执行的回调函数对应的参数不是一个函数，则返回的promise与原promise状态相同，且成功值和失败原因也相同。</li>
<li>如果then没有返回值，则返回的promise，状态为fulfilled，成功值为undefined</li>
<li>如果then返回一个值，则返回的promise，状态为fulfilled，成功值为返回的值</li>
<li>如果then抛出错误，则返回的promise，状态为rejected，失败原因为抛出的错误</li>
<li>如果then返回一个promise（三种状态都有可能），则可以当作是最终返回的promise，即状态，成功值或者失败原因都是一样的</li>
</ol>
<table>
<thead>
<tr>
<th>内部返回值</th>
<th>最终返回promise状态</th>
<th>成功的值</th>
<th>失败原因</th>
</tr>
</thead>
<tbody><tr>
<td>错误</td>
<td>rejected</td>
<td>-</td>
<td>错误</td>
</tr>
<tr>
<td>无</td>
<td>fulfilled</td>
<td>undefined</td>
<td>-</td>
</tr>
<tr>
<td>非promise的值</td>
<td>fulfilled</td>
<td>非promise的值</td>
<td>-</td>
</tr>
<tr>
<td>promise值</td>
<td>同promise值</td>
<td>同promise值</td>
<td>同promise值</td>
</tr>
</tbody></table>
<h4 id="2-catch"><a href="#2-catch" class="headerlink" title="2 catch"></a>2 catch</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">catch(onRejected)</span><br><span class="line"></span><br><span class="line">catch(reason =&gt; &#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li>等同于 <code>then(undefined, onRejected)</code></li>
<li>catch之前任一promise状态变为rejected，如果此promise自己没有处理，则会被catch捕获 </li>
<li>catch返回一个promise，其状态取决于catch内部onRejected函数<ol>
<li>如果onRejected返回一个rejected状态的Promise或着抛出一个错误，则catch返回的promise状态为rejected</li>
<li>否则，catch返回的promise状态为fulfilled</li>
</ol>
</li>
</ol>
<h4 id="3-finally"><a href="#3-finally" class="headerlink" title="3 finally"></a>3 finally</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">finally(onFinally)</span><br><span class="line"></span><br><span class="line">finally(() =&gt; &#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>onFinally<ul>
<li>Promise 结束后，无论结果是fulfilled或者是rejected，都会执行onFinally回调函数</li>
</ul>
</li>
<li>返回一个设置了 finally 回调函数的Promise对象</li>
</ul>
<h1 id="三-async-await"><a href="#三-async-await" class="headerlink" title="三 async / await"></a>三 async / await</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol>
<li>async/await 是promise 的语法糖</li>
<li>async用来声明一个异步函数（async function），await操作符只能用在异步函数中</li>
</ol>
<h2 id="3-2-async"><a href="#3-2-async" class="headerlink" title="3.2 async"></a>3.2 async</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function show()&#123;&#125;</span><br><span class="line"></span><br><span class="line">let show = async function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">	async show()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class xxx&#123;</span><br><span class="line">	async show() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>异步函数返回一个promise<ol>
<li>如果异步函数正常执行，则返回的promise会调用成功函数，成功值为异步函数内部返回值。</li>
<li>如果异步函数抛出异常，则返回的promise会调用失败函数，失败原因是抛出异常</li>
</ol>
</li>
<li>错误处理<ul>
<li>async返回一个promise，可以调用catch来处理错误</li>
</ul>
</li>
</ol>
<h2 id="3-3-await"><a href="#3-3-await" class="headerlink" title="3.3 await"></a>3.3 await</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[return_value] = await expression;</span><br></pre></td></tr></table></figure>
<ol>
<li>await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成<ol>
<li>如果表达式是一个promise，则返回值为promise的处理结果</li>
<li>如果表达式不是一个promise，则返回该值本身</li>
</ol>
</li>
<li>错误处理<ol>
<li>await后边的promise出错，相当于async函数返回的promise为reject，所以可以在外部调用catch方法处理</li>
<li>可以在内部用try…catch…处理</li>
</ol>
</li>
<li>await的并行<ol>
<li>让promise先执行后再使用await处理结果</li>
<li>使用 Promise.all() 处理多个promise并行执行</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/03/30/Javascript-%E6%A8%A1%E5%9D%97%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/03/30/Javascript-%E6%A8%A1%E5%9D%97%E5%8C%96/" class="post-title-link" itemprop="url">Javascript 模块化</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-03-30 22:31:03 / 修改时间：22:33:19" itemprop="dateCreated datePublished" datetime="2020-03-30T22:31:03+08:00">2020-03-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/UI/Javascript/" itemprop="url" rel="index">
                    <span itemprop="name">Javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-网上概述"><a href="#一-网上概述" class="headerlink" title="一 网上概述"></a>一 网上概述</h1><p><a href="https://segmentfault.com/a/1190000015302578" target="_blank" rel="noopener">网上概述</a></p>
<h1 id="二-概述"><a href="#二-概述" class="headerlink" title="二 概述"></a>二 概述</h1><ol>
<li>模块就是一个独立的文件，文件内部的变量，函数，类…外部无法获取</li>
<li>使用模块可以解决全局变量冲突</li>
<li>模块需要隐藏内部实现，只对外开发接口</li>
<li>模块可以避免滥用全局变量，造成代码不可控</li>
<li>模块可以被不同的应用使用，提高编码效率</li>
<li>模块默认运行在严格模式</li>
<li>模块都有独立的顶级作用域，不同模块间不能相互访问，类似函数作用域</li>
<li>模块在导入时只执行一次解析，之后的导入不会再执行模块代码，而使用第一次解析结果，并共享数据</li>
</ol>
<h1 id="三-加载"><a href="#三-加载" class="headerlink" title="三 加载"></a>三 加载</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>异步加载，即模块总是会在所有html解析后才执行</li>
</ul>
<h1 id="四-export"><a href="#四-export" class="headerlink" title="四 export"></a>四 export</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ul>
<li>模块中的功能默认外部无法使用，使用<code>export</code>命令规定模块的对面接口，即将指定功能导出供外部使用。</li>
</ul>
<h2 id="4-2-导出单个"><a href="#4-2-导出单个" class="headerlink" title="4.2 导出单个"></a>4.2 导出单个</h2><ul>
<li><code>export 声明语句</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export let name = &apos;xiaoqiang&apos;;</span><br><span class="line">export let obj = &#123;&#125;;</span><br><span class="line">export function show() &#123;&#125;;</span><br><span class="line">export class User &#123;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-3-导出列表"><a href="#4-3-导出列表" class="headerlink" title="4.3 导出列表"></a>4.3 导出列表</h2><ul>
<li><code>export { name1, name2, …, nameN };</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export let name = &apos;xiaoqiang&apos;;</span><br><span class="line">export let obj = &#123;&#125;;</span><br><span class="line">export function show() &#123;&#125;;</span><br><span class="line">export class User &#123;&#125;</span><br><span class="line">export &#123;name, obj, show, User&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-4-别名"><a href="#4-4-别名" class="headerlink" title="4.4 别名"></a>4.4 别名</h2><ul>
<li><code>export { variable1 as name1, variable2 as name2, …, nameN };</code></li>
</ul>
<h2 id="4-5-默认导出"><a href="#4-5-默认导出" class="headerlink" title="4.5 默认导出"></a>4.5 默认导出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default expression;</span><br><span class="line">export default function (…) &#123; … &#125; // also class, function*</span><br><span class="line">export default function name1(…) &#123; … &#125; // also class, function*</span><br><span class="line">export &#123; name1 as default, … &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>默认导出接口只能有一个，但默认导出可以与普通导出共存</li>
<li>本质上，<code>export default</code>就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字</li>
<li>默认导出时，函数和类可以具名也可以匿名，变量不能具名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default let a = 1; // 错误</span><br><span class="line">let a = 1;</span><br><span class="line">export default a; // 正确，相当于把a的值赋予default</span><br><span class="line">export default 1; // 正确，相当于直接把值赋予default</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="五-import（静态导入）"><a href="#五-import（静态导入）" class="headerlink" title="五 import（静态导入）"></a>五 import（静态导入）</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol>
<li>import用于导入其它模块提供的功能。</li>
<li>import导入的变量名要与export导出的一致</li>
<li>import导入的变量是只读的</li>
<li>import命令具有提升效果，会提升到整个模块的头部，首先执行 </li>
<li>import是静态导入，不能使用表达式和变量</li>
<li>在浏览器中引用模块必须添加路径，但在打包工具如webpack中则不需要，因为他们有自己的存放方式。</li>
</ol>
<h2 id="5-2-导入所有导出接口"><a href="#5-2-导入所有导出接口" class="headerlink" title="5.2 导入所有导出接口"></a>5.2 导入所有导出接口</h2><ul>
<li><code>import * as name from &quot;module-name&quot;;</code><ul>
<li><code>name</code><ul>
<li>导入模块的命名空间</li>
</ul>
</li>
<li><code>module-name</code><ul>
<li>要导入的模块。通常是包含目标模块的.js文件的相对或绝对路径名，可以不包括.js扩展名。</li>
</ul>
</li>
<li>使用<code>default</code>获取默认导出</li>
</ul>
</li>
</ul>
<h2 id="5-3-导入指定导出接口"><a href="#5-3-导入指定导出接口" class="headerlink" title="5.3 导入指定导出接口"></a>5.3 导入指定导出接口</h2><ul>
<li><code>import { export1, export2, ..., exportN } from &quot;module-name&quot;;</code></li>
</ul>
<h2 id="5-4-别名"><a href="#5-4-别名" class="headerlink" title="5.4 别名"></a>5.4 别名</h2><ul>
<li><code>import { export1 as alias1, export2, ..., exportN } from &quot;module-name&quot;;</code></li>
</ul>
<h2 id="5-5-导入默认导出"><a href="#5-5-导入默认导出" class="headerlink" title="5.5 导入默认导出"></a>5.5 导入默认导出</h2><ul>
<li><code>import defaultExport from &quot;module-name&quot;;</code><ol>
<li>导入默认导出时名称任意</li>
<li>由于默认导出只有一个，所以不需要<code>{}</code></li>
</ol>
</li>
</ul>
<h2 id="5-6-混合导入"><a href="#5-6-混合导入" class="headerlink" title="5.6 混合导入"></a>5.6 混合导入</h2><ul>
<li><code>import defaultExport, { export1, export2, ..., exportN} from &quot;module-name&quot;;</code></li>
</ul>
<h1 id="六-export-default"><a href="#六-export-default" class="headerlink" title="六 export default"></a>六 export default</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><ol>
<li>使用<code>import</code>命令时，需要知道<code>export</code>导出的变量名。</li>
<li><code>export default</code> 本质是导出一个名为<code>defualt</code>的变量，使用<code>import</code>导入时可以以任意名称导入。</li>
<li>一个模块只能有一个默认输出，可以与普通导出共存</li>
</ol>
<h2 id="6-2-语法"><a href="#6-2-语法" class="headerlink" title="6.2 语法"></a>6.2 语法</h2><ol>
<li><code>export default expression</code><ul>
<li>将<code>expression</code>表达式的值赋给<code>default</code>导出<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = 1;</span><br><span class="line">export default a; // 将a的值1赋给default</span><br><span class="line">export default 1; // 将1赋给default</span><br><span class="line">export default let a = 1; // 错误 因为let a = 1不能计算出一个值</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>export default function(){}  // also class, function*</code><ul>
<li>导出匿名函数/类，名称为<code>default</code></li>
</ul>
</li>
<li><code>export default function name(…) { … } // also class, function*</code><ul>
<li>导出具名函数/类，名称为<code>default</code>，原有名称会被忽略</li>
</ul>
</li>
<li><code>export { name1 as default, … };</code><ul>
<li>由于 <code>export default</code> 本质是导出一个名为<code>default</code>的变量</li>
<li>可以使用<code>export</code>导出一个别名为<code>default</code>的变量</li>
</ul>
</li>
</ol>
<h1 id="七-export-import"><a href="#七-export-import" class="headerlink" title="七 export + import"></a>七 export + import</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ol>
<li>可以将导入的模块再次导出</li>
<li>如果<code>export</code>和<code>import</code>结合在一起，其实就相当于一个转发，并没有导入到当前模块，即当前模块不能使用导入导出的功能。</li>
</ol>
<h2 id="7-2-语法"><a href="#7-2-语法" class="headerlink" title="7.2 语法"></a>7.2 语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export * from …;</span><br><span class="line">export &#123; name1, name2, …, nameN &#125; from …;</span><br><span class="line">export &#123; import1 as name1, import2 as name2, …, nameN &#125; from …;</span><br><span class="line">export &#123; default &#125; from …;</span><br></pre></td></tr></table></figure>

<h1 id="八-import-（动态导入）"><a href="#八-import-（动态导入）" class="headerlink" title="八 import()（动态导入）"></a>八 import()（动态导入）</h1><ol>
<li>接收参数与静态导入一致 </li>
<li>使用<code>import()</code> 函数可以动态导入模块，它返回一个 promise 对象，可以按需加载</li>
<li><code>import()</code> 函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块</li>
</ol>
<h1 id="九-打包工具-webpack"><a href="#九-打包工具-webpack" class="headerlink" title="九 打包工具 webpack"></a>九 打包工具 webpack</h1>
      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/03/30/Javascript-Class/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/03/30/Javascript-Class/" class="post-title-link" itemprop="url">Javascript Class</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-03-30 22:28:26 / 修改时间：22:30:42" itemprop="dateCreated datePublished" datetime="2020-03-30T22:28:26+08:00">2020-03-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/UI/Javascript/" itemprop="url" rel="index">
                    <span itemprop="name">Javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>JavaScript 中，生成实例对象的传统方法是通过构造函数</li>
<li>为了和其他语言继承形态一致，JS提供了class 关键词用于模拟传统的class ，但底层实现机制依然是原型继承</li>
<li>class 只是语法糖，为了让类的声明与继承更加简洁清晰</li>
<li>class 其实就是函数，<code>typeof 类</code>返回<code>function</code></li>
<li>class 内部代码始终以严格模式执行</li>
<li>class 不存在变量提升</li>
<li>class 中的属性名可以采用表达式<code>[]</code></li>
<li>class 中定义的属性都是实例属性，定义的方法都是原型方法且不可枚举</li>
</ol>
<h1 id="二-语法"><a href="#二-语法" class="headerlink" title="二 语法"></a>二 语法</h1><ol>
<li>类声明<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 类名 &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>类表达式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let 类名= class&#123;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="三-构造函数-constructor"><a href="#三-构造函数-constructor" class="headerlink" title="三 构造函数 constructor"></a>三 构造函数 constructor</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 基类默认构造函数</span><br><span class="line">constructor() &#123;&#125;</span><br><span class="line">// 派生类默认构造函数</span><br><span class="line">constructor(...args) &#123;</span><br><span class="line">	super(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用类new一个对象时会自动调用构造函数</li>
<li>如果省略，则会有默认构造函数</li>
<li><code>constructor</code> 默认返回实例对象（即this），可以改为返回另一个对象</li>
<li>类的原型的constructor属性指向类本身<ul>
<li><code>类.prototype.constructor = 类</code></li>
</ul>
</li>
</ol>
<h1 id="四-属性-amp-方法"><a href="#四-属性-amp-方法" class="headerlink" title="四 属性 &amp; 方法"></a>四 属性 &amp; 方法</h1><h2 id="4-1-实例属性"><a href="#4-1-实例属性" class="headerlink" title="4.1 实例属性"></a>4.1 实例属性</h2><ol>
<li>旧：使用<code>this.</code> 定义在<code>constructor</code>中</li>
<li>新：在类中直接定义的属性就是实例属性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">	name = &apos;haha&apos;; </span><br><span class="line">	constructor(age) &#123;</span><br><span class="line">		this.age = age; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-原型方法"><a href="#4-2-原型方法" class="headerlink" title="4.2 原型方法"></a>4.2 原型方法</h2><ol>
<li>旧：在类的原型上定义方法，是可以枚举的</li>
<li>新：在类中直接定义的方法就是原型方法，且不可枚举（non-enumerable）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">	show()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">User.prototype.show = function()&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-静态属性-方法"><a href="#4-3-静态属性-方法" class="headerlink" title="4.3 静态属性/方法"></a>4.3 静态属性/方法</h2><ol>
<li>定义在类上</li>
<li>在类中定义的属性/方法前加<code>static</code>关键字</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">	static age = 10;</span><br><span class="line">	static show() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">User.age = 10;</span><br><span class="line">User.show() = function()&#123;&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：如果静态方法包含this关键字，这个this指的是类本身，而不是实例对象</li>
</ul>
<h2 id="4-4-私有属性-方法"><a href="#4-4-私有属性-方法" class="headerlink" title="4.4 私有属性 / 方法"></a>4.4 私有属性 / 方法</h2><ul>
<li>私有属性：在属性名前加 <code>#</code></li>
<li>私有方法：以表达式形式定义方法并在方法前加<code>#</code> ，可以理解为就是定义私有属性，不过属性的值是一个函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">	#phone = &apos;13800000000&apos;; // 私有属性</span><br><span class="line">	#say = function() &#123;&#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-5-受保护属性-方法"><a href="#4-5-受保护属性-方法" class="headerlink" title="4.5 受保护属性 / 方法"></a>4.5 受保护属性 / 方法</h2><ul>
<li>在属性/方法名前加 <code>_</code>，这只是约定不是语法，不是规范</li>
<li>可以通过<code>symbol weakmap ...</code> 人为实现保护</li>
</ul>
<h1 id="五-访问器-getter-setter"><a href="#五-访问器-getter-setter" class="headerlink" title="五 访问器 getter/setter"></a>五 访问器 getter/setter</h1><ul>
<li>类中同样可以使用访问器，且访问器也是定义在属性的属性描述符上</li>
</ul>
<h1 id="六-class的继承"><a href="#六-class的继承" class="headerlink" title="六 class的继承"></a>六 class的继承</h1><h2 id="6-1-extends"><a href="#6-1-extends" class="headerlink" title="6.1 extends"></a>6.1 extends</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Fu &#123;</span><br><span class="line">	constructor() &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Zi extends Fu &#123;</span><br><span class="line">	constructor() &#123;</span><br><span class="line">		super();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>子类构造函数第一行必须先调用父类构造函数</li>
<li>class的继承做了两件事<ol>
<li>与ES5的 继承一样<ol>
<li>在子类构造函数中调用父类构造</li>
<li>子类的原型对象的原型指向父类的原型对象</li>
</ol>
</li>
<li><code>子类.__proto__ = 父类</code><ul>
<li>用于继承静态属性/方法</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="6-2-super"><a href="#6-2-super" class="headerlink" title="6.2 super"></a>6.2 super</h2><h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1 问题"></a>1 问题</h3><ol>
<li><code>子 父</code>：在子类中调用父类方法<ul>
<li>子：<code>this.__proto__.__proto__</code><ul>
<li>this代表子类实例，<code>this.__proto__.__proto__</code>就代表父类原型，就可以调用到父类的方法。</li>
</ul>
</li>
</ul>
</li>
<li><code>子 父 爷</code>：在子类中调用父类方法，父类方法中又调用了父类的父类的方法<ul>
<li>子：<code>this.__proto__.__proto__</code></li>
<li>父：<code>this.__proto__</code><ul>
<li>因为子类中调用父类方法的是父类原型对象，所以父类中的this代表的是父类原型，所以用<code>this.__proto__</code>获取爷爷的原型，就可以调用爷爷的方法</li>
</ul>
</li>
</ul>
</li>
<li><code>父 爷</code><ul>
<li>父：<code>this.__proto__.__proto__</code><ul>
<li>如果直接使用父类调用爷爷的方法，此时父类就是子，爷爷就是父类，就跟1<code>子 父</code>是一样的。</li>
<li>父类扮演不同角色时，代码是矛盾的。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>如果只有双层继承，使用<code>this</code>是可以的，如果有多重继承，是行不通的。</li>
<li>使用call/apply指定this，在多重继承中也是行不通的。</li>
</ul>
<h3 id="2-用法"><a href="#2-用法" class="headerlink" title="2 用法"></a>2 用法</h3><ol>
<li>super 只能在类或对象的方法中使用，而不能在函数中使用</li>
<li>使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。<ul>
<li><code>console.log(super)</code> 无法看出是函数还是对象，错误</li>
</ul>
</li>
</ol>
<h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super([arguments]);</span><br></pre></td></tr></table></figure>
<ol>
<li>调用 父对象/父类 的构造函数</li>
<li>此时super代表父对象/父类的构造函数</li>
</ol>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super.functionOnParent([arguments]);</span><br></pre></td></tr></table></figure>
<ol>
<li>调用 父对象/父类 上的方法</li>
<li>此时super代表父类原型对象</li>
<li>如果是静态方法则super代表父类本身</li>
</ol>
<h3 id="3-原生构造函数的继承"><a href="#3-原生构造函数的继承" class="headerlink" title="3 原生构造函数的继承"></a>3 原生构造函数的继承</h3><ol>
<li>之前，这些内置的构造函数如<code>Object() Array() ...</code> 是无法继承的</li>
<li>ES6 允许继承</li>
</ol>
<h3 id="4-mixin"><a href="#4-mixin" class="headerlink" title="4 mixin"></a>4 mixin</h3><ol>
<li>创建一个mixin类，包含许多供其它类使用的方法</li>
<li>将mixin类 合并到要使用功能的类的原型上</li>
</ol>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/03/30/Javascript-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/03/30/Javascript-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B/" class="post-title-link" itemprop="url">Javascript 继承和原型</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>

              <time title="创建时间：2020-03-30 22:24:38" itemprop="dateCreated datePublished" datetime="2020-03-30T22:24:38+08:00">2020-03-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-31 09:30:54" itemprop="dateModified" datetime="2020-03-31T09:30:54+08:00">2020-03-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/UI/Javascript/" itemprop="url" rel="index">
                    <span itemprop="name">Javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-原型"><a href="#一-原型" class="headerlink" title="一 原型"></a>一 原型</h1><p><img src="https://gitee.com/3noanswer/npics/raw/master/UI/JavaScript/js%E5%8E%9F%E5%9E%8B.png" alt=""></p>
<h2 id="1-1-原型链"><a href="#1-1-原型链" class="headerlink" title="1.1 原型链"></a>1.1 原型链</h2><p><img src="https://gitee.com/3noanswer/npics/raw/master/UI/JavaScript/js%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt=""></p>
<ul>
<li>对象有自己的原型对象，而原型对象也是对象，所以原型对象也有自己的原型对象，就会形成一个“原型链”（prototype chain）</li>
<li>对象有自己的原型对象，而对象又可以充当其他对象的原型；</li>
</ul>
<h2 id="1-2-proto"><a href="#1-2-proto" class="headerlink" title="1.2 __proto__"></a>1.2 <code>__proto__</code></h2><ol>
<li>是浏览器实现的非JavaScript标准的属性，在ES6写入了附录，用于获取或设置对象的原型</li>
<li><code>obj.__proto__</code><ol>
<li>并非是普通的属性访问方式，而是通过getter/setter访问器</li>
<li><code>__proto__</code>理解为<code>prototype</code> 属性的 getter/setter 实现</li>
</ol>
</li>
<li>每个对象都有<code>__proto__</code>属性，指向它的构造函数的原型对象，即如果A对象是由B函数构造的，则 <code>A.__proto__ === B.prototype</code><ol>
<li>普通对象的构造函数是其对应的构造函数，则<code>对象.__proto__ === 构造函数.prototype</code></li>
<li>函数（包括Function自身）的构造函数是Function，则 <code>函数.__proto__ === Function.prototype</code></li>
<li>原型对象默认的构造函数是Object，则<code>原型对象.__proto__ === Object.prototype</code></li>
<li>原型对象中<code>Object.prototype</code>比较特殊，它是原型链的顶端，<code>Object.prototype.__proto__ === null</code></li>
</ol>
</li>
<li>由于非标准，浏览器有这个属性，其它环境未必有。建议使用Object中的方法 替代<code>__proto__</code><ul>
<li><code>Object.getPrototypeOf(obj)</code></li>
<li><code>Object.setPrototypeOf(obj, prototype)</code></li>
<li><code>Object.create(proto[, propertiesObject])</code></li>
</ul>
</li>
</ol>
<h2 id="1-3-prototype"><a href="#1-3-prototype" class="headerlink" title="1.3 prototype"></a>1.3 prototype</h2><ol>
<li>函数作为对象有<code>__proto__</code>，又可以作为构造函数有<code>prototype</code></li>
<li>每个函数都有一个<code>prototype</code>属性，指向函数的原型对象，且函数的原型对象是普通对象。<ul>
<li><code>Function.prototype</code>是个例外<ol>
<li>它是Function函数的原型对象但它是个函数对象</li>
<li>它是函数对象但是没有<code>prototype</code>属性</li>
</ol>
</li>
</ul>
</li>
<li>实例对象的<code>__proto__</code>和其构造函数的<code>prototype</code>都指向构造函数的原型对象</li>
<li><code>prototype</code>的作用是让该函数所实例化的对象们都可以找到公用的属性和方法，即js的继承是通过<code>prototype</code>实现的</li>
</ol>
<h3 id="4-constructor"><a href="#4-constructor" class="headerlink" title="4 constructor"></a>4 constructor</h3><ol>
<li>只有原型对象才有<code>constructor</code>属性，此属性指向函数本身，即<ol>
<li><code>函数.prototype.constructor = 函数</code></li>
<li><code>实例对象.__proto__.constructor = 函数</code></li>
</ol>
</li>
</ol>
<h1 id="二-new"><a href="#二-new" class="headerlink" title="二 new"></a>二 new</h1><h2 id="2-1-new的执行过程"><a href="#2-1-new的执行过程" class="headerlink" title="2.1 new的执行过程"></a>2.1 new的执行过程</h2><ol>
<li>创建一个空对象 <code>let obj = {};</code></li>
<li>将新建对象的<code>__proto__</code>指向构造函数的原型对象，<code>obj.__proto__ = 构造函数.prototype</code></li>
<li>将新建对象作为构造函数执行的上下文，即将构造函数内部的this指向新建对象</li>
<li>执行构造函数，如果构造函数没有返回引用类型的值，则返回新建对象</li>
</ol>
<h2 id="2-2-自定义new"><a href="#2-2-自定义new" class="headerlink" title="2.2 自定义new"></a>2.2 自定义new</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let myNew = function(cons, args) &#123;</span><br><span class="line">	let obj = &#123;&#125;; // 步骤1</span><br><span class="line">	obj.__proto__ = cons.prototype; // 步骤2</span><br><span class="line">	// let obj = Object.create(cons.prototype); 步骤1，2合在一起</span><br><span class="line">	let result = cons.apply(obj, args); // 步骤3</span><br><span class="line">	return result instanceof Object ? result : obj; // 步骤4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-new-target-属性"><a href="#2-3-new-target-属性" class="headerlink" title="2.3 new.target 属性"></a>2.3 new.target 属性</h2><ul>
<li>用来检测函数是否通过<code>new</code>或者<code>Reflect.construct()</code>调用的<ol>
<li>如果在普通函数中使用，返回undefined</li>
<li>在构造函数中使用指向被new调用的构造函数</li>
<li>在class的constructor函数中使用指向被new调用的class</li>
</ol>
</li>
</ul>
<h1 id="三-构造函数中的属性和方法"><a href="#三-构造函数中的属性和方法" class="headerlink" title="三 构造函数中的属性和方法"></a>三 构造函数中的属性和方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function User(name) &#123;</span><br><span class="line">	let age = 18; // 私有属性</span><br><span class="line">	let test = function()&#123;&#125;; // 私有方法</span><br><span class="line">	this.name = name; // 实例属性</span><br><span class="line">	this.show = function()&#123;&#125;// 实例方法</span><br><span class="line">&#125;</span><br><span class="line">User.country = &apos;中国&apos;; // 静态属性</span><br><span class="line">User.sayHello = function()&#123;&#125;; // 静态方法</span><br><span class="line">User.prototype.gender = &apos;男&apos;; // 原型属性</span><br><span class="line">User.prototype.change = function()&#123;&#125;; // 原型方法</span><br></pre></td></tr></table></figure>
<ol>
<li>私有实例属性 / 方法（private）<ul>
<li>在构造函数内部使用<code>var/let/const</code>声明的属性/方法</li>
</ul>
</li>
<li>公有实例属性 / 方法（public）<ul>
<li>在构造函数内部使用<code>this.</code>声明的属性/方法</li>
</ul>
</li>
<li>静态属性 / 方法（static）<ul>
<li>定义在构造函数上的属性/方法</li>
</ul>
</li>
<li>原型属性 / 方法（prototype）<ul>
<li>定义在构造函数原型上的属性/方法 ，<strong>原型方法默认可枚举</strong></li>
</ul>
</li>
</ol>
<h1 id="四-继承"><a href="#四-继承" class="headerlink" title="四 继承"></a>四 继承</h1><h2 id="4-1-设置原型方式"><a href="#4-1-设置原型方式" class="headerlink" title="4.1 设置原型方式"></a>4.1 设置原型方式</h2><ol>
<li>设置构造函数原型，使用函数的<code>prototype</code>属性</li>
<li>设置对象的原型<ol>
<li><code>Object.create(proto[, propertiesObject])</code> <ul>
<li>创建对象时指定原型（只是定义无法获取）</li>
</ul>
</li>
<li>使用对象的属性<code>__proto__</code> 获取或设置原型，在浏览器之外的环境可能不行。</li>
<li>Object的方法，与<code>__proto__</code>效果一样，但是是js标准<ul>
<li><code>Object.getPrototypeOf(obj)</code><ul>
<li>获取对象的原型，即<code>__proto__</code></li>
</ul>
</li>
<li><code>Object.setPrototypeOf(obj, prototype)</code><ul>
<li>设置对象的原型</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="4-2-继承原理"><a href="#4-2-继承原理" class="headerlink" title="4.2 继承原理"></a>4.2 继承原理</h2><p><img src="https://gitee.com/3noanswer/npics/raw/master/UI/JavaScript/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF.png" alt=""></p>
<ul>
<li>将子类构造函数的原型对象的原型指向父类构造函数的原型对象</li>
</ul>
<h2 id="4-3-实现继承的方式"><a href="#4-3-实现继承的方式" class="headerlink" title="4.3 实现继承的方式"></a>4.3 实现继承的方式</h2><h3 id="1-原型链-1"><a href="#1-原型链-1" class="headerlink" title="1 原型链-1"></a>1 原型链-1</h3><p><img src="https://gitee.com/3noanswer/npics/raw/master/UI/JavaScript/%E7%BB%A7%E6%89%BF1.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.prototype.__proto__ = B.prototype;</span><br></pre></td></tr></table></figure>
<ul>
<li>将子类构造函数的原型对象的原型直接指向父类构造函数的原型</li>
<li>好处<ul>
<li>父类原型在子类原型链上，则子类可以继承父类的原型属性/方法</li>
</ul>
</li>
<li>弊端<ul>
<li>创建子类时不会调用父类构造函数，无法继承父类的实例属性/方法</li>
</ul>
</li>
</ul>
<h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2 构造函数"></a>2 构造函数</h3><ul>
<li>在子类构造函数中通过<code>call/apply</code>调用父类构造函数，并指定this为子类对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Fu(name, age) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.age = age;</span><br><span class="line">	this.show = function()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">function Zi(name, age) &#123;</span><br><span class="line">	Fu(name,age); // 不行，因为直接调用时，父类构造函数this是指向window的</span><br><span class="line">	Fu.call(this, name, age); </span><br><span class="line">	Fu.apply(this, [name, age])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>好处<ul>
<li>创建的子类实例具备父类实例属性/方法</li>
</ul>
</li>
<li>弊端<ol>
<li>只是子类的实例，不是父类的实例（只是通过调用父类构造函数模拟继承）</li>
<li>无法继承父类原型属性/方法</li>
</ol>
</li>
</ul>
<h3 id="3-原型链-2"><a href="#3-原型链-2" class="headerlink" title="3 原型链-2"></a>3 原型链-2</h3><p><img src="https://gitee.com/3noanswer/npics/raw/master/UI/JavaScript/%E7%BB%A7%E6%89%BF2.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.prototype = new B();</span><br></pre></td></tr></table></figure>
<ul>
<li>将子类构造函数的原型对象修改为一个父类实例（舍弃原有原型对象）</li>
<li>好处<ul>
<li>父类实例对象具有父类的实例属性/方法，父类实例对象的原型又指向父类构造函数原型，所以父类的实例属性/方法 和 原型属性/方法，子类都可以继承</li>
</ul>
</li>
<li>弊端<ol>
<li>父类的实例属性/方法是在子类原型对象上，这就导致父类的实例属性/方法实际上变成了子类的原型属性/方法。</li>
<li>需要手动为新的子类原型对象添加 <code>constructor</code>属性</li>
</ol>
</li>
</ul>
<h4 id="1-对新增对象的影响"><a href="#1-对新增对象的影响" class="headerlink" title="1 对新增对象的影响"></a>1 对新增对象的影响</h4><ul>
<li>如果新增对象在修改原型操作之前，那就意味着，新增对象指向的原型还是原来被舍弃的原型，所以这种方式只对修改原型操作之后新增的对象有效 </li>
</ul>
<h4 id="2-对constructor的影响"><a href="#2-对constructor的影响" class="headerlink" title="2 对constructor的影响"></a>2 对constructor的影响</h4><ul>
<li>由于这种方式是将子类原型修改成了一个新的对象，而这个新对象中是没有<code>constructor</code>属性的，所以需要手动为新对象添加<code>constructor</code>属性，并指向子类构造函数</li>
</ul>
<ol>
<li>直接添加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.prototype.constructor = A;</span><br></pre></td></tr></table></figure>
<ul>
<li>直接添加的方式有一个弊端，就是<code>constructor</code>属性默认可遍历</li>
</ul>
</li>
<li>使用Object的<code>defineProperty()</code> 添加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(A.prototype, &quot;constructor&quot;, &#123;</span><br><span class="line">	value: A,</span><br><span class="line">	enumerable: false</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="4-组合继承1（构造函数-原型链2）"><a href="#4-组合继承1（构造函数-原型链2）" class="headerlink" title="4 组合继承1（构造函数+原型链2）"></a>4 组合继承1（构造函数+原型链2）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function B(name) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.gender = &apos;nan&apos;;</span><br><span class="line">B.prototype.eat = function() &#123;&#125;;</span><br><span class="line">function A(age) &#123;</span><br><span class="line">	B.call(this, &apos;小猫&apos;); // 第一次调用</span><br><span class="line">	this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype = new B(&apos;小狗&apos;); // 第二次调用</span><br><span class="line">A.prototype.constructor = A;</span><br></pre></td></tr></table></figure>
<ul>
<li>好处<ul>
<li>通过构造函数方式可以继承到父类的实例属性/方法</li>
<li>通过原型链方式可以继承到父类的原型属性/方法</li>
</ul>
</li>
<li>弊端<ol>
<li>父类的实例属性会在子类实例和子类原型上都定义一份，不过不影响，因为会先使用实例自己的属性</li>
<li>会调用两次父类构造函数</li>
<li>需要手动为新的子类原型对象添加 <code>constructor</code>属性</li>
</ol>
</li>
</ul>
<h3 id="5-组合继承2（构造函数-原型链1）"><a href="#5-组合继承2（构造函数-原型链1）" class="headerlink" title="5 组合继承2（构造函数+原型链1）"></a>5 组合继承2（构造函数+原型链1）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function B(name) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.gender = &apos;nan&apos;;</span><br><span class="line">B.prototype.eat = function() &#123;&#125;;</span><br><span class="line">function A(age) &#123;</span><br><span class="line">	B.call(this, &apos;小猫&apos;); </span><br><span class="line">	this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.__proto__ = B.prototype</span><br></pre></td></tr></table></figure>
<ul>
<li>好处<ul>
<li>通过构造函数方式可以继承到父类的实例属性/方法</li>
<li>通过原型链方式可以继承到父类的原型属性/方法</li>
</ul>
</li>
<li>弊端<ul>
<li><code>__proto__</code> 在浏览器之外的环境可能不行。</li>
</ul>
</li>
</ul>
<h3 id="6-最终方式"><a href="#6-最终方式" class="headerlink" title="6 最终方式"></a>6 最终方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function B(name) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.gender = &apos;nan&apos;;</span><br><span class="line">B.prototype.eat = function() &#123;&#125;;</span><br><span class="line">function A(age) &#123;</span><br><span class="line">	B.call(this, &apos;小猫&apos;); </span><br><span class="line">	this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype = Object.create(B.prototype);</span><br><span class="line">Object.defineProperty(A.prototype, &quot;constructor&quot;, &#123;</span><br><span class="line">	value: A,</span><br><span class="line">	enumerable: false</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>将<code>__proto__</code> 方式改为<code>Object.create()</code></li>
<li><code>A.prototype = Object.create(B.prototype);</code><ul>
<li>以父类的原型创建一个对象作为子类原型对象，此新建对象没有调用父类构造函数，没有父类实例属性/方法</li>
</ul>
</li>
</ul>
<h2 id="4-4-对象工厂"><a href="#4-4-对象工厂" class="headerlink" title="4.4 对象工厂"></a>4.4 对象工厂</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Fu(name)&#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">function createObj(...args) &#123;</span><br><span class="line">	const obj = Object.create(Fu.prototype);</span><br><span class="line">	Fu.call(obj, ...args); //通过调用父类</span><br><span class="line">	return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>与继承方式类似，只是通过对象工厂创建子类对象，不需要子类构造函数<ol>
<li>创建一个以父类原型为原型的对象，相当于继承了父类原型属性/方法</li>
<li>调用父类构造函数，并设置this为新建对象，即相当于继承了父类实例属性</li>
<li>返回新建对象</li>
</ol>
</li>
</ul>
<h2 id="4-5-静态属性-方法的继承"><a href="#4-5-静态属性-方法的继承" class="headerlink" title="4.5 静态属性/方法的继承"></a>4.5 静态属性/方法的继承</h2><ul>
<li>静态属性/方法即在构造函数上定义的属性/方法，继承原理都是一样的，函数也是对象，把子类构造函数看作对象，设置其原型为父类构造函数，即可继承静态属性/方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Fu() &#123;&#125;</span><br><span class="line">Fu.haha = &quot;wangcai&quot;;</span><br><span class="line">Fu.show = function() &#123;</span><br><span class="line">	console.log(&apos;fu static show&apos;)</span><br><span class="line">&#125;</span><br><span class="line">function Zi() &#123;&#125;</span><br><span class="line">Zi.__proto__ = Fu;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-6-多继承"><a href="#4-6-多继承" class="headerlink" title="4.6 多继承"></a>4.6 多继承</h2><ul>
<li>js不支持多继承，也没有接口实现，如果要使用多个类的方法时可以使用mixin混合模式来完成</li>
</ul>
<h3 id="Mixin模式"><a href="#Mixin模式" class="headerlink" title="Mixin模式"></a>Mixin模式</h3><ol>
<li>Mixin模式 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口</li>
<li>mixin 可以看作是一个包含许多功能的对象，使用时将这些功能合并到要使用功能的对象原型上即可</li>
</ol>
<ul>
<li>例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let myMix = &#123;</span><br><span class="line">	sayHi() &#123;&#125;,</span><br><span class="line">	sayBye() &#123;&#125;,</span><br><span class="line">	eat()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">function User() &#123;&#125;</span><br><span class="line">// 合并之后，User的实例就有了myMix的功能了</span><br><span class="line">Object.assign(User.prototype, myMix);</span><br><span class="line">// 手动添加某个功能</span><br><span class="line">User.prototype.eat = myHix.eat;</span><br></pre></td></tr></table></figure>

</li>
</ul>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/03/30/Javascript-%E9%97%AD%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/03/30/Javascript-%E9%97%AD%E5%8C%85/" class="post-title-link" itemprop="url">Javascript 闭包</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-03-30 22:24:25 / 修改时间：22:24:50" itemprop="dateCreated datePublished" datetime="2020-03-30T22:24:25+08:00">2020-03-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/UI/Javascript/" itemprop="url" rel="index">
                    <span itemprop="name">Javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>通常情况下，函数执行时（入栈）创建一个单独的作用域，函数执行完毕（弹栈），此作用域销毁，函数内部的变量也就销毁了，无法再访问。</li>
<li>闭包则会添加一个对函数的引用，使得函数作用域一直保存到闭包不存在为止。</li>
</ol>
<h1 id="二-概念及现象"><a href="#二-概念及现象" class="headerlink" title="二 概念及现象"></a>二 概念及现象</h1><ul>
<li>闭包是由函数以及创建该函数的词法环境组合而成。在此词法环境外调用函数时，可以访问到词法环境中的变量。</li>
<li>通俗来说就是：<ol>
<li>有一个单独的作用域，此作用域中定义一个函数，则这个函数与它能在此作用域中所有能访问的变量构成了闭包。</li>
<li>在此作用域外调用函数时，函数能够使用作用域中的变量。</li>
</ol>
</li>
</ul>
<h1 id="三-如何形成闭包"><a href="#三-如何形成闭包" class="headerlink" title="三 如何形成闭包"></a>三 如何形成闭包</h1><h2 id="3-1-条件"><a href="#3-1-条件" class="headerlink" title="3.1 条件"></a>3.1 条件</h2><ol>
<li>单独的作用域：为了创建局部变量</li>
<li>内部定义一个函数：形成闭包</li>
<li>将函数暴漏给外部：为了能在外部访问到函数</li>
</ol>
<h2 id="3-2-方式"><a href="#3-2-方式" class="headerlink" title="3.2 方式"></a>3.2 方式</h2><ol>
<li>函数嵌套<ol>
<li>外部函数是一个单独的函数作用域</li>
<li>定义一个内部函数，此内部函数与外部函数中的变量构成了闭包</li>
<li>把内部函数return, 或者添加到window对象上，暴漏给外部。</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function outer() &#123;</span><br><span class="line">	let i = 0;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		console.log(i++);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let inner = outer(); </span><br><span class="line">inner(); // 外部函数执行完毕后，依然可以访问到外部函数中的变量</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/03/30/Javascript-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/03/30/Javascript-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">Javascript 引用数据类型</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-03-30 22:13:52 / 修改时间：22:21:56" itemprop="dateCreated datePublished" datetime="2020-03-30T22:13:52+08:00">2020-03-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/UI/Javascript/" itemprop="url" rel="index">
                    <span itemprop="name">Javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-属性描述符"><a href="#一-属性描述符" class="headerlink" title="一 属性描述符"></a>一 属性描述符</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ol>
<li>JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为属性描述符（property descriptor），或者叫属性描述对象</li>
<li>属性描述符有两种主要形式，且只能取其一<ol>
<li>数据描述符可以具有的属性<ul>
<li><code>configurable enumerable value writable</code></li>
</ul>
</li>
<li>存取描述符可以具有的属性<ul>
<li><code>configurable enumerable get set</code></li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="1-2-元属性（属性描述对象中用来描述属性元信息的属性）"><a href="#1-2-元属性（属性描述对象中用来描述属性元信息的属性）" class="headerlink" title="1.2 元属性（属性描述对象中用来描述属性元信息的属性）"></a>1.2 元属性（属性描述对象中用来描述属性元信息的属性）</h2><table>
<thead>
<tr>
<th>元属性</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>value</code></td>
<td>表示该属性的值</td>
<td><code>undefined</code></td>
</tr>
<tr>
<td><code>writable</code></td>
<td>表示该属性是否可写</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>enumerable</code></td>
<td>表示该属性是否可遍历</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>configurable</code></td>
<td>1 该属性是否可删除<br>2 该属性的属性描述符是否可修改</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>get</code></td>
<td>表示该属性的取值函数getter</td>
<td><code>undefined</code></td>
</tr>
<tr>
<td><code>set</code></td>
<td>表示该属性的存值函数setter</td>
<td><code>undefined</code></td>
</tr>
</tbody></table>
<h1 id="二-对象"><a href="#二-对象" class="headerlink" title="二 对象"></a>二 对象</h1><h2 id="2-1-Object"><a href="#2-1-Object" class="headerlink" title="2.1 Object"></a>2.1 Object</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><ol>
<li><code>Object([value])</code><ol>
<li>普通函数，作用是类型转换，将value转成一个对象</li>
<li>用法与构造函数相同，只是语义上的区别</li>
</ol>
</li>
<li><code>new Object([value])</code><ol>
<li>构造函数，创建一个对象，值为value转成的对象</li>
<li>如果参数value<ol>
<li>为空或者是<code>undefined null</code>，返回一个空对象</li>
<li>是基本类型的值则返回其包装对象</li>
<li>是引用类型则直接返回</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2 静态方法"></a>2 静态方法</h3><h4 id="1-获取"><a href="#1-获取" class="headerlink" title="1 获取"></a>1 获取</h4><ol>
<li><code>Object.keys(obj)</code><ul>
<li>返回对象自身可枚举属性键的数组</li>
</ul>
</li>
<li><code>Object.values(obj)</code><ul>
<li>返回对象自身可枚举属性值的数组</li>
</ul>
</li>
<li><code>Object.entries(obj)</code><ul>
<li>返回对象自身可枚举属性键值对的数组</li>
<li>以上三个方法与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）</li>
</ul>
</li>
<li><code>Object.getOwnPropertyNames(obj)</code><ul>
<li>返回对象自身的所有属性（包含可枚举和不可枚举属性，不包含Symbol属性）键的数组</li>
</ul>
</li>
<li><code>Object.getOwnPropertySymbols(obj)</code><ul>
<li>返回对象自身的所有 Symbol 属性的数组</li>
</ul>
</li>
</ol>
<h4 id="2-属性描述符"><a href="#2-属性描述符" class="headerlink" title="2 属性描述符"></a>2 属性描述符</h4><ol>
<li><code>Object.getOwnPropertyDescriptor(obj, prop)</code><ul>
<li>获取对象自身某个属性的属性描述对象</li>
</ul>
</li>
<li><code>Object.getOwnPropertyDescriptors(obj)</code><ul>
<li>获取对象自身所有属性的属性描述对像</li>
</ul>
</li>
<li><code>Object.defineProperty(obj, prop, descriptor)</code><ul>
<li>如果对象自身存在指定属性，则修改它的属性描述对象，否则为对象添加指定属性并定义属性描述对象。返回该对象</li>
<li>通过这种方式定义属性描述法时的默认值<ul>
<li><code>configurable enumerable writable</code> 均为false</li>
<li><code>value get set</code> 均为undefined</li>
</ul>
</li>
</ul>
</li>
<li><code>Object.defineProperties(obj, props)</code><ul>
<li>修改或添加对象多个属性的属性描述对象，返回该对象</li>
</ul>
</li>
</ol>
<h4 id="3-创建对象"><a href="#3-创建对象" class="headerlink" title="3 创建对象"></a>3 创建对象</h4><ol>
<li><code>Object.create(proto[, propertiesObject])</code><ul>
<li>指定原型对象和属性（使用属性描述符定义），返回一个新的对象</li>
<li><code>propertiesObject</code> 同 <code>Object.defineProperties(obj, props)</code> 的<code>props</code></li>
</ul>
</li>
<li><code>Object.assign(target, ...sources)</code><ul>
<li>将一个或多个源对象的所有可枚举属性复制到目标对象。并返回目标对象<ol>
<li>如果目标对象与源对象有同名属性，或多个源对象有同名属性，后边覆盖前边</li>
<li><code>Object.assign</code> 方法实行的是浅拷贝</li>
<li>数组会被当作对象，即相同索引会覆盖</li>
<li>如果属性值是取值函数，会计算后再复制</li>
</ol>
</li>
</ul>
</li>
<li><code>Object.fromEntries(iterable)</code><ul>
<li>把键值对列表转换为一个对象</li>
<li>是 <code>Object.entries()</code> 的反转</li>
</ul>
</li>
</ol>
<h4 id="4-原型"><a href="#4-原型" class="headerlink" title="4 原型"></a>4 原型</h4><ol>
<li><code>Object.getPrototypeOf(obj)</code><ul>
<li>获取对象的Prototype对象，即<code>__proto__</code></li>
</ul>
</li>
<li><code>Object.setPrototypeOf(obj, prototype)</code><ul>
<li>修改对象的prototype对象</li>
</ul>
</li>
</ol>
<h4 id="5-状态"><a href="#5-状态" class="headerlink" title="5 状态"></a>5 状态</h4><ol>
<li><code>Object.preventExtensions(obj)</code><ul>
<li>让一个对象变的不可扩展，也就是永远不能再添加新的属性</li>
</ul>
</li>
<li><code>Object.isExtensible(obj)</code><ul>
<li>判断一个对象是否可扩展</li>
</ul>
</li>
<li><code>Object.seal(obj)</code><ul>
<li>封闭一个对象，此对象不可扩展且对象所有自身属性<code>configurable</code>标记为false </li>
<li>不能添加、删除属性，属性修饰符不可配置</li>
</ul>
</li>
<li><code>Object.isSealed(obj)</code><ul>
<li>判断一个对象是否被封闭</li>
</ul>
</li>
<li><code>Object.freeze(obj)</code><ul>
<li>冻结一个对象，此对象不可扩展且对象所有自身属性 <code>writable configurable</code> 标记为false</li>
<li>不能添加、修改和删除属性，属性修饰符不可配置</li>
</ul>
</li>
<li><code>Object.isFrozen(obj)</code><ul>
<li>判断一个对象是否被冻结</li>
</ul>
</li>
</ol>
<h4 id="6-判断"><a href="#6-判断" class="headerlink" title="6 判断"></a>6 判断</h4><ol>
<li><code>Object.is(value1, value2)</code><ul>
<li>判断两个值是否相等，不会作类型转换</li>
<li>与<code>===</code>的区别<ol>
<li><code>===</code> 认为<code>-0</code>和<code>+0</code>相等，此方法认为不相等</li>
<li><code>===</code> 认为<code>NaN</code>和<code>NaN</code>不相等，此方法认为相等</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="3-原型方法"><a href="#3-原型方法" class="headerlink" title="3 原型方法"></a>3 原型方法</h3><ol>
<li><code>valueOf()</code><ul>
<li>返回对象原始值，若没有原始值，返回对象本身，通常会覆盖</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>对象</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td><code>Number</code></td>
<td>数值</td>
</tr>
<tr>
<td><code>Boolean</code></td>
<td>布尔值</td>
</tr>
<tr>
<td><code>String</code></td>
<td>字符串值</td>
</tr>
<tr>
<td><code>Object</code></td>
<td>对象本身</td>
</tr>
<tr>
<td><code>Array</code></td>
<td>数组本身</td>
</tr>
<tr>
<td><code>Function</code></td>
<td>函数本身</td>
</tr>
<tr>
<td><code>Date</code></td>
<td>距离1970-01-01 00:00:00 的毫秒数</td>
</tr>
</tbody></table>
<ol start="2">
<li><code>toString()</code><ul>
<li>默认返回 <code>[object type]</code>，通常会覆盖</li>
</ul>
</li>
<li><code>toLocaleString()</code><ul>
<li>默认返回调用 <code>toString()</code> 的结果，可以覆盖</li>
</ul>
</li>
<li><code>hasOwnProperty(prop)</code><ul>
<li>判断对象自身是否含有某个属性</li>
</ul>
</li>
<li><code>propertyIsEnumerable(prop)</code><ul>
<li>判断某个属性是否可枚举</li>
</ul>
</li>
<li><code>isPrototypeOf(object)</code><ul>
<li>判断调用对象是否在另一个对象的原型链上</li>
<li>和 <code>instanceof</code> 的区别<ul>
<li><code>A instanceof B</code> ：判断 <code>B.prototype</code>是否在A的原型链上</li>
<li><code>B.isPrototypeOf(A)</code>：判断B是否在A的原型链上</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="2-2-创建对象方式"><a href="#2-2-创建对象方式" class="headerlink" title="2.2 创建对象方式"></a>2.2 创建对象方式</h2><ol>
<li>Object构造函数</li>
<li>对象字面量<ul>
<li>对象字面量内部调用了Object的构造函数</li>
</ul>
</li>
<li><code>Object.create(proto, [propertiesObject])</code><ul>
<li>这种方式可以指定原型</li>
</ul>
</li>
</ol>
<h2 id="2-3-对象字面量"><a href="#2-3-对象字面量" class="headerlink" title="2.3 对象字面量"></a>2.3 对象字面量</h2><ol>
<li>标准形式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let obj =&#123;</span><br><span class="line">	key:value,</span><br><span class="line">	key:function()&#123;&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>如果属性值是方法，可以简写<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key:function()&#123;&#125; </span><br><span class="line"> //简写</span><br><span class="line">key()&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果属性名是一个表达式，使用<code>[]</code>包裹，意思是取表达式的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = &apos;haha&apos;;</span><br><span class="line">let obj = &#123; [a]:a &#125;; </span><br><span class="line">console.log(obj); // &#123;haha:&apos;haha&apos;&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果属性值是外部变量的值，属性名与变量名相同时可以简写（其实就是将变量作为对象属性）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a = &apos;haha&apos;；</span><br><span class="line">let obj = &#123; a:a &#125;;</span><br><span class="line">// 简写</span><br><span class="line">let obj = &#123;a&#125;; </span><br><span class="line">console.log(obj); // &#123;a:&apos;haha&apos;&#125;</span><br></pre></td></tr></table></figure></li>
<li>与json的区别<ol>
<li>json只允许<code>&quot;property&quot;:value</code>，属性名必须用双引号括起来</li>
<li>json值仅允许字符串，数字，数组，true，false，null或其他（JSON）对象，值不能是函数</li>
</ol>
</li>
</ol>
<h2 id="2-4-自定义构造函数"><a href="#2-4-自定义构造函数" class="headerlink" title="2.4 自定义构造函数"></a>2.4 自定义构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 可以空参</span><br><span class="line">function Person(name,age)&#123;</span><br><span class="line">		this.name=name;</span><br><span class="line">		this.age=age;</span><br><span class="line">		this.show=function()&#123;code...&#125;</span><br><span class="line">&#125;</span><br><span class="line">let person=new Person(&quot;xq&quot;,8);</span><br></pre></td></tr></table></figure>
<h2 id="2-5-工厂函数"><a href="#2-5-工厂函数" class="headerlink" title="2.5 工厂函数"></a>2.5 工厂函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function userFactory(name) &#123;</span><br><span class="line">	let obj = &#123;&#125;;</span><br><span class="line">	obj.name = name;</span><br><span class="line">	obj.show = function()&#123;&#125;;</span><br><span class="line">	return obj;</span><br><span class="line">	// 或者简写</span><br><span class="line">	return &#123;</span><br><span class="line">		name,</span><br><span class="line">		show()&#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在函数内部根据传入的参数创建一个对象（可以使用字面量或Object构造等等方式），然后将对象返回，为了复用</li>
<li>与自定义构造函数方式的区别<ul>
<li>工厂函数是函数调用，自定义构造是new</li>
<li>工厂函数是函数名称小写，自定义构造名称大写</li>
<li>工厂函数内部需要显式创建一个对象，然后根据参数赋值后再显式返回</li>
<li>自定义构造根据参数自动创建一个对象并返回</li>
</ul>
</li>
</ul>
<h2 id="2-6-属性管理"><a href="#2-6-属性管理" class="headerlink" title="2.6 属性管理"></a>2.6 属性管理</h2><h3 id="1-属性的访问"><a href="#1-属性的访问" class="headerlink" title="1 属性的访问"></a>1 属性的访问</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 obj.property</span><br><span class="line">2 obj[&apos;property&apos;]</span><br></pre></td></tr></table></figure>
<ol>
<li>点后边只能是属性名，中括号中可以是一个表达式</li>
<li>当属性名称比较特殊时，如数字,空格…，只能用中括号</li>
<li>当属性名称是变量时，如遍历时，只能用中括号</li>
</ol>
<h3 id="2-属性的删除"><a href="#2-属性的删除" class="headerlink" title="2 属性的删除"></a>2 属性的删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 delete object.property </span><br><span class="line">2 delete object[&apos;property&apos;]</span><br></pre></td></tr></table></figure>
<ol>
<li>删除自身属性，返回布尔值</li>
<li>如果要删除的属性不存在，返回true</li>
</ol>
<h2 id="2-7-访问器（get-set）"><a href="#2-7-访问器（get-set）" class="headerlink" title="2.7 访问器（get/set）"></a>2.7 访问器（get/set）</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// getter</span><br><span class="line">1 get prop() &#123; ... &#125;</span><br><span class="line">2 get [expression]() &#123; ... &#125;</span><br><span class="line">// setter</span><br><span class="line">1 set prop(val) &#123; . . . &#125;</span><br><span class="line">2 set [expression](val) &#123; . . . &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>函数名可以是一个表达式</li>
<li>访问器函数调用方式与访问对象属性一样，其实是调用访问器函数<ol>
<li><code>obj.访问器名</code></li>
<li><code>obj[&#39;访问器名&#39;]</code></li>
</ol>
</li>
<li>访问器跟属性同名时，如果访问器方法内部访问属性会造成无限循环。</li>
</ol>
<h3 id="2-定义方式"><a href="#2-定义方式" class="headerlink" title="2 定义方式"></a>2 定义方式</h3><ol>
<li>通过配置属性描述符对象定义访问器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">	name : &apos;小明&apos;;</span><br><span class="line">&#125;</span><br><span class="line">Object.defineProperty(obj, &apos;name&apos;, &#123;</span><br><span class="line">	get() &#123;</span><br><span class="line">		return obj.name; // 跟取值方式一样，也会调用get，会无限循环</span><br><span class="line">	&#125;,</span><br><span class="line">	set(value) &#123;</span><br><span class="line">		obj.name = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.name; // 调用get取值</span><br><span class="line">obj.name = &apos;旺财&apos;; // 调用set设置值</span><br></pre></td></tr></table></figure></li>
<li>对象字面量中直接定义<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">	_name: &apos;小明&apos;,</span><br><span class="line">	get name() &#123;</span><br><span class="line">		return this._name;</span><br><span class="line">	&#125;,</span><br><span class="line">	set name(value) &#123;</span><br><span class="line">		this._name = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="2-8-对象拷贝"><a href="#2-8-对象拷贝" class="headerlink" title="2.8 对象拷贝"></a>2.8 对象拷贝</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h3><ul>
<li>浅拷贝<ul>
<li>如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 </li>
<li>一个对象修改可能会影响到另一个对象</li>
</ul>
</li>
<li>深拷贝<ul>
<li>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象</li>
<li>一个对象修改不会影响到另一个对象</li>
</ul>
</li>
</ul>
<h3 id="2-浅拷贝方式"><a href="#2-浅拷贝方式" class="headerlink" title="2 浅拷贝方式"></a>2 浅拷贝方式</h3><ol>
<li>创建新对象，然后使用<code>for...in</code>遍历原对象属性并一个一个连值一起添加到新对象上<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let source = &#123;name:&apos;an3&apos;, age:18&#125;;</span><br><span class="line">let cp = &#123;&#125;;</span><br><span class="line">for (const key in source)&#123;</span><br><span class="line">	if(source.hasOwnProperty(key)&#123;</span><br><span class="line">		cp[key] = source[key];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用<code>Object.assign(目标对象, 原对象列表)</code>，并将目标对象设为空对象，就相当于返回了对原对象的浅拷贝<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let source = &#123;name:&apos;an3&apos;, age:18&#125;;</span><br><span class="line">let cp = Object.assign(&#123;&#125;, source);</span><br></pre></td></tr></table></figure></li>
<li>展开语法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let source = &#123;name:&apos;an3&apos;, age:18&#125;;</span><br><span class="line">let cp = &#123;...source&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="3-深拷贝方式"><a href="#3-深拷贝方式" class="headerlink" title="3 深拷贝方式"></a>3 深拷贝方式</h3><ol>
<li>使用JSON<ol>
<li>步骤<ol>
<li><code>JSON.stringify()</code>：将一个对象序列成一个字符串</li>
<li><code>JSON.parse()</code>：将字符串反序列化生成深拷贝对象</li>
</ol>
</li>
<li>注意<ol>
<li>拷贝的对象的值中如果有函数,undefined,symbol则经过JSON.stringify()序列化后的JSON字符串中这个键值对会消失</li>
<li>无法拷贝不可枚举的属性，无法拷贝对象的原型链</li>
<li>拷贝Date引用类型会变成字符串</li>
<li>拷贝RegExp引用类型会变成空对象</li>
<li>对象中含有NaN、Infinity和-Infinity，则序列化的结果会变成null</li>
<li>无法拷贝对象的循环应用(即obj[key] = obj)</li>
</ol>
</li>
</ol>
</li>
<li>递归<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy(obj) &#123;</span><br><span class="line">	// 对象的属性值有可能是数组，判断一下防止递归时把数组变成了对象</span><br><span class="line">	let cpObj = obj instanceof Array ? [] : &#123;&#125;;</span><br><span class="line">	// 我用for in 也可以，但for in 不推荐用来遍历数组，Object.entries()方法对于对象和数组返回结果形式是一样的</span><br><span class="line">	for(const [k, v] of Object.entries(obj)) &#123;</span><br><span class="line">		// 判断对象属性如果是引用类型就递归拷贝，最终就是深拷贝</span><br><span class="line">		cpObj[k] = typeof v == &apos;object&apos; ? deepCopy(v) : v;</span><br><span class="line">	&#125;  </span><br><span class="line">	return cpObj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>原理就是浅拷贝只拷贝一层，那我们就递归，如果这一层属性的值是引用类型，就再拷贝一层……</li>
</ul>
</li>
</ol>
<h2 id="2-9-代理"><a href="#2-9-代理" class="headerlink" title="2.9 代理"></a>2.9 代理</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>代理（拦截器）是对象的访问控制，setter/getter 访问器是对对象单个属性的控制</li>
</ol>
<h3 id="2-Proxy"><a href="#2-Proxy" class="headerlink" title="2 Proxy"></a>2 Proxy</h3><h4 id="1-构造函数-1"><a href="#1-构造函数-1" class="headerlink" title="1 构造函数"></a>1 构造函数</h4><ul>
<li><code>new Proxy(target, handler)</code><ul>
<li>返回一个Proxy实例</li>
<li><code>target</code><ul>
<li>用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）</li>
</ul>
</li>
<li><code>handler</code><ul>
<li>处理器对象，有许多拦截相应操作的函数，如果没有配置，则执行默认操作</li>
<li>注意：处理操作都是针对代理对象的，目标对象无效。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-handler"><a href="#2-handler" class="headerlink" title="2 handler"></a>2 handler</h4><ol>
<li><code>get(target, property, receiver)</code><ul>
<li>参数<ul>
<li><code>target</code><ul>
<li>目标对象</li>
</ul>
</li>
<li><code>property</code><ul>
<li>获取的属性名</li>
</ul>
</li>
<li><code>reveiver</code><ul>
<li>Proxy或者继承Proxy的对象</li>
</ul>
</li>
</ul>
</li>
<li>说明<ul>
<li>get 方法拦截属性的获取，可以返回任何值</li>
</ul>
</li>
</ul>
</li>
<li><code>set(target, property, value, receiver)</code><ul>
<li>参数<ul>
<li><code>value</code><ul>
<li>被设置的新值</li>
</ul>
</li>
</ul>
</li>
<li>说明<ul>
<li>set 方法拦截属性的设置</li>
<li>严格模式下 set 必须返回布尔值，且如果返回false会报错</li>
</ul>
</li>
</ul>
</li>
<li><code>apply(target, thisArg, argumentsList)</code><ul>
<li>参数<ul>
<li><code>target</code><ul>
<li>目标函数</li>
</ul>
</li>
<li><code>thisArg</code><ul>
<li>被调用时的上下文对象</li>
</ul>
</li>
<li><code>argumentsList</code><ul>
<li>被调用时的参数数组</li>
</ul>
</li>
</ul>
</li>
<li>说明<ul>
<li>apply 方法拦截函数调用，可以返回任何值<ol>
<li>直接调用</li>
<li><code>Function.prototype.call()</code> 方式调用</li>
<li><code>Function.prototype.apply()</code> 方式调用</li>
<li><code>Reflet.apply()</code> 方式调用</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><code>has(target, prop)</code><ul>
<li>参数<ul>
<li><code>target</code><ul>
<li>目标对象</li>
</ul>
</li>
<li><code>prop</code><ul>
<li>需要检查是否存在的属性.</li>
</ul>
</li>
</ul>
</li>
<li>说明<ul>
<li>拦截 <code>prop in object</code> 语句，返回布尔值</li>
</ul>
</li>
</ul>
</li>
<li><code>construct(target, argumentsList, newTarget)</code><ul>
<li>参数<ul>
<li><code>target</code><ul>
<li>目标构造函数</li>
</ul>
</li>
<li><code>argumentsList</code><ul>
<li>constructor的参数列表</li>
</ul>
</li>
<li><code>newTarget</code><ul>
<li>生成的代理对象（即代理构造函数）</li>
</ul>
</li>
</ul>
</li>
<li>说明<ul>
<li>拦截new操作，必须返回一个对象</li>
</ul>
</li>
</ul>
</li>
<li><code>deleteProperty(target, prop)</code><ul>
<li>拦截<code>delete</code> 操作，必须返回布尔值</li>
</ul>
</li>
<li><code>defineProperty(target, property, descriptor)</code><ul>
<li>拦截<code>Object.defineProperty()</code>，必须返回布尔值</li>
</ul>
</li>
<li><code>getOwnPropertyDescriptor(target, prop)</code><ul>
<li>拦截 <code>Object.getOwnPropertyDescriptor()</code>，必须返回一个对象或undefined</li>
</ul>
</li>
<li><code>getPrototypeOf(target)</code><ul>
<li>拦截获取原型操作</li>
</ul>
</li>
<li><code>setPrototypeOf(target, prototype)</code><ul>
<li>拦截设置原型操作，返回布尔值</li>
</ul>
</li>
<li><code>preventExtensions(target)</code><ul>
<li>拦截<code>Object.preventExtensions()</code>，返回一个布尔值</li>
</ul>
</li>
<li><code>isExtensible(target)</code><ul>
<li>拦截<code>Object.isExtensible()</code>，必须返回布尔值</li>
</ul>
</li>
<li><code>ownKeys(target)</code><ul>
<li>拦截对象获取自身属性的操作</li>
</ul>
</li>
</ol>
<h2 id="2-10-Reflect"><a href="#2-10-Reflect" class="headerlink" title="2.10 Reflect"></a>2.10 Reflect</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>Reflect不是一个构造函数，不能new，Reflect的所有属性和方法都是静态的（就像Math对象）。</li>
<li>将Object对象的一些明显属于语言内部的方法（如Object.defineProperty），放到Reflect对象上</li>
<li>修改某些Object方法的返回结果，让其变得更合理<ul>
<li>如Object.defineProperty无法定义属性时，会抛出错误，而Reflect.defineProperty会返回false</li>
</ul>
</li>
<li>让Object操作都变成函数行为<ul>
<li>如 <code>prop in object</code> ，对应<code>Reflect.has(obj, prop)</code></li>
<li><code>delete obj.prop</code>，对应<code>Reflect.deleteProperty(obj, prop)</code></li>
</ul>
</li>
<li>Reflect对象与Proxy的handler 方法完全一致，在使用代理拦截某些操作时，使用Reflect的方法可以保证原生行为能正常执行。</li>
</ol>
<h3 id="2-静态方法-1"><a href="#2-静态方法-1" class="headerlink" title="2 静态方法"></a>2 静态方法</h3><ul>
<li>见Proxy handler</li>
</ul>
<h2 id="2-11-this-amp-super"><a href="#2-11-this-amp-super" class="headerlink" title="2.11 this &amp; super"></a>2.11 this &amp; super</h2><h3 id="1-this"><a href="#1-this" class="headerlink" title="1 this"></a>1 this</h3><ol>
<li>在全局环境中 或者 在函数中<ol>
<li>非严格模式：this指向顶层对象window</li>
<li>严格模式：this为undefined</li>
</ol>
</li>
<li>在对象中，this代表当前对象的引用</li>
<li>在对象方法（对象的属性是函数则称为方法）中，this指向调用该方法的对象</li>
<li>在箭头函数中，this与定义箭头函数时所在的环境指向同一个this</li>
<li>在构造函数中，this指向正在构造的新对象</li>
<li>在DOM事件处理函数中，this指向触发事件的元素</li>
<li>在内联事件处理函数中，this指向监听器所在的DOM元素</li>
</ol>
<h3 id="2-super"><a href="#2-super" class="headerlink" title="2 super"></a>2 super</h3><ul>
<li>super指向当前对象的原型对象</li>
</ul>
<h1 id="三-数组"><a href="#三-数组" class="headerlink" title="三 数组"></a>三 数组</h1><h2 id="3-1-Array"><a href="#3-1-Array" class="headerlink" title="3.1 Array"></a>3.1 Array</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>数组都是Array对象的实例</li>
<li>数组可以存任意类型的数据</li>
<li>数组长度可变</li>
<li>ES6 明确数组中空位值为undefined</li>
<li>数组字面量<ul>
<li><code>[ele0, ele1, ..., eleN]</code></li>
</ul>
</li>
</ol>
<h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2 构造函数"></a>2 构造函数</h3><ol>
<li><code>Array()</code> 和 <code>new Array()</code> 是等同的</li>
<li><code>new Array(arrayLength)</code><ul>
<li>如果参数只有一个且是 0-2<sup>32</sup>-1 之间的整数，则创建一个指定长度的数组</li>
</ul>
</li>
<li><code>new Array(element0, element1[, ...[, elementN]])</code><ul>
<li>创建一个指定元素的数组</li>
</ul>
</li>
</ol>
<h3 id="3-静态属性"><a href="#3-静态属性" class="headerlink" title="3 静态属性"></a>3 静态属性</h3><ul>
<li><code>length</code></li>
</ul>
<h3 id="4-静态方法"><a href="#4-静态方法" class="headerlink" title="4  静态方法"></a>4  静态方法</h3><ol>
<li><code>Array.isArray(obj)</code><ul>
<li>如果值是 Array，则返回true，否则返回false</li>
<li>用来弥补<code>typeof</code>，因为<code>typeof 数组</code> 返回的是<code>object</code></li>
</ul>
</li>
<li><code>Array.of(element0[, element1[, ...[, elementN]]])</code><ul>
<li>将一组值转换为数组</li>
<li>用来弥补构造函数，构造函数参数个数不同会导致结果不同。</li>
</ul>
</li>
<li><code>Array.from(arrayLike[, mapFn[, thisArg]])</code><ul>
<li>从一个类数组对象或可迭代对象创建一个新的浅拷贝的数组实例并返回</li>
<li><code>mapFn</code><ul>
<li>如果指定了该参数，新数组中的每个元素都会执行该回调函数</li>
</ul>
</li>
<li><code>thisArg</code><ul>
<li>执行回调函数 mapFn 时的 this 对象</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="5-原型方法"><a href="#5-原型方法" class="headerlink" title="5 原型方法"></a>5 原型方法</h3><h4 id="1-获取-1"><a href="#1-获取-1" class="headerlink" title="1 获取"></a>1 获取</h4><ol>
<li><code>valueOf()</code><ul>
<li>返回数组本身</li>
</ul>
</li>
<li><code>toString()</code><ul>
<li>返回数组的字符串形式</li>
</ul>
</li>
<li><code>join([separator])</code><ul>
<li>以指定分隔符（默认为逗号）将所有数组成员连接为一个字符串返回</li>
</ul>
</li>
</ol>
<h4 id="2-增删改"><a href="#2-增删改" class="headerlink" title="2 增删改"></a>2 增删改</h4><ol>
<li><code>push(element1, ..., elementN)</code><ul>
<li>将一个或多个元素添加到数组的末尾，并返回该数组的新长度，改变原数组</li>
<li>如果参数为数组，把数组作为元素添加到数组中。(二维数组)</li>
</ul>
</li>
<li><code>pop()</code><ul>
<li>删除并返回最后一个元素，改变原数组</li>
</ul>
</li>
<li><code>unshift(element1, ..., elementN)</code><ul>
<li>将一个或多个元素添加到数组的开头，并返回该数组的新长度，改变原数组</li>
<li>参数可以是数组（二维数组）</li>
</ul>
</li>
<li><code>shift()</code><ul>
<li>删除并返回第一个元素，改变原数组</li>
</ul>
</li>
<li><code>fill(value[, start[, end]])</code><ul>
<li>使用指定值填充数组，可指定开始结束索引，返回修改后的数组</li>
</ul>
</li>
<li><code>slice([begin[, end]])</code><ul>
<li>提取目标数组的一部分，返回一个浅拷贝新数组，原数组不变</li>
</ul>
</li>
<li><code>splice(start[, deleteCount[, item1[, item2[, ...]]]])</code><ul>
<li>删除目标数组的一部分成员，并可以在删除的位置添加新的数组成员，返回被删除的元素组成的数组，改变原数组</li>
</ul>
</li>
<li><code>concat(value1, value2, ..., valueN)</code><ul>
<li>将一个或多个值合并到数组中，返回新数组，不改变原数组</li>
</ul>
</li>
<li><code>copyWithin(target[, start[, end]])</code><ul>
<li>复制数组的一部分到数组指定位置（覆盖原有成员），并返回数组，改变原数组但不改变数组长度（因为会覆盖原有成员）</li>
<li><code>target</code><ul>
<li>目标位置</li>
</ul>
</li>
<li><code>start</code><ul>
<li>复制的起始索引，默认为0</li>
</ul>
</li>
<li><code>end</code><ul>
<li>复制的终止索引（不含），默认为尾部</li>
</ul>
</li>
</ul>
</li>
<li><code>flat([depth])</code><ul>
<li>将数组降维，返回新数组，不改变原数组</li>
<li><code>depth</code><ul>
<li>指定结构深度，默认值为 1，即只可以将二维数组合并成一维数组</li>
</ul>
</li>
</ul>
</li>
<li><code>flatMap(callback[, thisArg])</code><ul>
<li>对数组中每一个元素执行回调函数，然后对返回值组成的数组执行flat()方法，结构深度 depth 值为1，返回新数组</li>
<li><code>callback(currentValue[, index[, array]])</code><ul>
<li><code>currentValue</code>：当前遍历的元素</li>
<li><code>index</code>：当前遍历到的索引</li>
<li><code>array</code>：当前数组</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="3-查"><a href="#3-查" class="headerlink" title="3 查"></a>3 查</h4><ol>
<li><code>indexOf(searchElement[, fromIndex])</code><ul>
<li>返回第一个匹配索引，如果不存在，则返回-1</li>
</ul>
</li>
<li><code>lastIndexOf(searchElement[, fromIndex])</code><ul>
<li>返回从后往前的第一个匹配索引，如果不存在，则返回-1</li>
</ul>
</li>
<li><code>includes(valueToFind[, fromIndex])</code><ul>
<li>判断数组是否包含指定元素</li>
</ul>
</li>
<li><code>find(callback[, thisArg])</code><ul>
<li>返回数组中第一个满足所提供测试函数（返回true）的元素的值，否则返回 undefined</li>
<li><code>callback(element[, index[, array]])</code><ul>
<li><code>element</code>：当前遍历的元素</li>
<li><code>index</code>：当前遍历到的索引</li>
<li><code>array</code>：当前数组</li>
</ul>
</li>
<li><code>thisArg</code><ul>
<li>执行回调时函数时this 指向的对象。</li>
</ul>
</li>
</ul>
</li>
<li><code>findIndex(callback[, thisArg])</code><ul>
<li>返回数组中第一个满足所提供测试函数（返回true）的元素的索引，否则返回 -1</li>
</ul>
</li>
</ol>
<h4 id="4-排序"><a href="#4-排序" class="headerlink" title="4 排序"></a>4 排序</h4><ol>
<li><code>reverse()</code><ul>
<li>反转数组并返回，改变原数组</li>
</ul>
</li>
<li><code>sort([compareFunction])</code><ul>
<li>默认是按照字典顺序排序，返回排序后的数组，改变原数组</li>
<li><code>compareFunction(value1, value2)</code><ul>
<li>返回一个数字，如果小于0则value1排在value2之前</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="5-循环遍历"><a href="#5-循环遍历" class="headerlink" title="5 循环遍历"></a>5 循环遍历</h4><ol>
<li><code>forEach(callback[, thisArg])</code><ul>
<li><code>callback(currentValue[, index[, array]])</code><ul>
<li><code>currentValue</code>：当前遍历的元素</li>
<li><code>index</code>：当前遍历到的索引</li>
<li><code>array</code>：当前数组</li>
</ul>
</li>
</ul>
</li>
<li><code>keys()</code><ul>
<li>返回数组元素键的迭代器对象</li>
</ul>
</li>
<li><code>values()</code><ul>
<li>返回数组元素值的迭代器对象</li>
</ul>
</li>
<li><code>entries()</code><ul>
<li>返回数组元素键值对的迭代器对象</li>
</ul>
</li>
</ol>
<h4 id="6-扩展方法"><a href="#6-扩展方法" class="headerlink" title="6 扩展方法"></a>6 扩展方法</h4><ol>
<li><code>every(callback[, thisArg])</code><ul>
<li>判断数组元素是否全部能通过指定测试函数，返回布尔值，碰到一个元素返回false，则every立即返回false</li>
<li><code>callback(element[, index[, array]])</code><ul>
<li><code>element</code>：当前遍历的元素</li>
<li><code>index</code>：当前遍历到的索引</li>
<li><code>array</code>：当前数组</li>
</ul>
</li>
</ul>
</li>
<li><code>some(callback[, thisArg])</code><ul>
<li>数组中有至少一个元素通过回调函数的测试就会返回true；</li>
</ul>
</li>
<li><code>filter(callback[, thisArg])</code><ul>
<li>返回一个新的由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组</li>
</ul>
</li>
<li><code>map(callback[, thisArg])</code><ul>
<li>对数组中每一个元素执行回调函数，返回每一个回调函数结果组成的新数组</li>
</ul>
</li>
<li><code>reduce(callback[, initialValue])</code><ul>
<li>返回回调函数累计处理的结果</li>
<li><code>callback(accumulator, currentValue[, index[, array]])</code><ul>
<li><code>accumulator</code><ul>
<li>第一次循环<ol>
<li>有<code>initialValue</code>，则为<code>initialValue</code></li>
<li>无<code>initialValue</code>，则为数组第一个元素</li>
</ol>
</li>
<li>从第二次循环往后为回调函数返回值</li>
</ul>
</li>
<li><code>currentValue</code><ul>
<li>数组中当前循环的元素</li>
<li>第一次循环时，如果没有<code>initialValue</code>，由于<code>accumulator</code>是数组第一个元素，则<code>currentValue</code>会从第二个元素开始循环</li>
</ul>
</li>
<li><code>index</code><ul>
<li>数组中当前循环的元素的索引</li>
</ul>
</li>
<li><code>array</code><ul>
<li>当前数组</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>reduceRight(callback[, initialValue])</code><ul>
<li>与<code>reduce()</code>相似，只是从右向左遍历数组</li>
</ul>
</li>
</ol>
<h1 id="四-函数"><a href="#四-函数" class="headerlink" title="四 函数"></a>四 函数</h1><h2 id="4-1-Function"><a href="#4-1-Function" class="headerlink" title="4.1 Function"></a>4.1 Function</h2><h3 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1 概述"></a>1 概述</h3><ul>
<li>每个 JavaScript 函数都是一个 Function 对象</li>
</ul>
<h3 id="2-构造函数-1"><a href="#2-构造函数-1" class="headerlink" title="2 构造函数"></a>2 构造函数</h3><ul>
<li><code>new Function ([arg1[, arg2[, ...argN]],] functionBody)</code><ul>
<li><code>arg1, arg2, ... argN</code><ul>
<li>字符串，字符串中多个参数用逗号分隔</li>
</ul>
</li>
<li><code>functionBody</code><ul>
<li>函数体的字符串</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-静态属性-1"><a href="#3-静态属性-1" class="headerlink" title="3 静态属性"></a>3 静态属性</h3><ol>
<li><code>Function.length</code><ul>
<li>函数的形参个数</li>
</ul>
</li>
<li><code>Function.name</code><ul>
<li>函数的名称</li>
</ul>
</li>
</ol>
<h3 id="4-原型方法"><a href="#4-原型方法" class="headerlink" title="4 原型方法"></a>4 原型方法</h3><ol>
<li><code>call(thisArg, arg1, arg2, ...)</code><ul>
<li>使用指定的 this 值和参数列表来调用此函数</li>
<li><code>thisArg</code><ul>
<li>函数运行时this的值</li>
</ul>
</li>
<li>与 bind 不同 call/apply 会立即执行函数</li>
</ul>
</li>
<li><code>apply(thisArg, [argsArray])</code><ul>
<li>同<code>call()</code>，不同的是接受的是一个参数数组</li>
</ul>
</li>
<li><code>bind(thisArg[, arg1[, arg2[, ...]]])</code><ul>
<li>使用指定的this和参数列表创建一个原函数的拷贝并返回</li>
<li>call() 和 apply() 用来执行函数，bind()用来创建函数，即不会立即执行</li>
<li>bind设置的参数优先级高（即调用时设置的相应参数无效）</li>
</ul>
</li>
<li><code>toString()</code><ul>
<li>返回表示函数源代码的字符串</li>
</ul>
</li>
</ol>
<h2 id="4-2-立即执行函数（IIFE-Imdiately-Invoked-Function-Expression）"><a href="#4-2-立即执行函数（IIFE-Imdiately-Invoked-Function-Expression）" class="headerlink" title="4.2 立即执行函数（IIFE Imdiately Invoked Function Expression）"></a>4.2 立即执行函数（IIFE Imdiately Invoked Function Expression）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 (function()&#123;...&#125;())</span><br><span class="line">2 (function()&#123;...&#125;)()</span><br></pre></td></tr></table></figure>
<ol>
<li>不必为函数命名</li>
<li>形成单独的作用域，封装遍历，避免重名…</li>
</ol>
<h2 id="4-3-定义函数"><a href="#4-3-定义函数" class="headerlink" title="4.3 定义函数"></a>4.3 定义函数</h2><h3 id="1-函数声明"><a href="#1-函数声明" class="headerlink" title="1 函数声明"></a>1 函数声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 函数名(参数列表) &#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>函数提升，提升优先级高于var变量提升</li>
<li>函数会添加到window对象中</li>
<li>优先级高于函数表达式</li>
</ol>
<h3 id="2-函数表达式"><a href="#2-函数表达式" class="headerlink" title="2 函数表达式"></a>2 函数表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var/let/const 函数名 = function (参数列表) &#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>函数不会提升</li>
<li>var声明的函数会添加到window对象中，但let/const则不会</li>
</ol>
<h3 id="3-Function构造函数"><a href="#3-Function构造函数" class="headerlink" title="3 Function构造函数"></a>3 Function构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var/let/const 函数名 = new Function(&quot;参数列表&quot;,&quot;函数体&quot;);</span><br></pre></td></tr></table></figure>
<ol>
<li>函数不会提升</li>
<li>var声明的函数会添加到window对象中，但let/const则不会</li>
</ol>
<h2 id="4-4-参数"><a href="#4-4-参数" class="headerlink" title="4.4 参数"></a>4.4 参数</h2><h3 id="1-形参-amp-实参"><a href="#1-形参-amp-实参" class="headerlink" title="1 形参 &amp; 实参"></a>1 形参 &amp; 实参</h3><ul>
<li>形参是默认声明的，不用var/let/const修饰</li>
<li>实参数量小于形参时，没有传递的形参值为 undefined</li>
<li>实参数量大于形参时，多余的实参将忽略并不会报错</li>
</ul>
<h3 id="2-参数默认值"><a href="#2-参数默认值" class="headerlink" title="2 参数默认值"></a>2 参数默认值</h3><ul>
<li>在形参上可以直接定义参数默认值，如果传递对应参数则使用传递值，否则使用默认值</li>
</ul>
<h3 id="3-arguments"><a href="#3-arguments" class="headerlink" title="3 arguments"></a>3 arguments</h3><ul>
<li>arguments 对象是所有（非箭头）函数中都可用的局部变量，是一个类数组对象，存储了传递的实参</li>
</ul>
<h2 id="4-5-箭头函数"><a href="#4-5-箭头函数" class="headerlink" title="4.5 箭头函数"></a>4.5 箭头函数</h2><h3 id="1-概述-4"><a href="#1-概述-4" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>箭头函数内部的<code>this</code> 是固定的，指向定义时所在的环境的this</li>
<li>箭头函数不可以当作构造函数，也就是说，不可以使用new命令</li>
<li>箭头函数内部不存在<code>arguments</code> 对象</li>
<li>箭头函数不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数</li>
</ol>
<h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2 语法"></a>2 语法</h3><ol>
<li>基础语法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(param1, param2, …, paramN) =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure></li>
<li>没有参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure></li>
<li>只有一个参数，小括号可以省略<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">singleParam =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure></li>
<li>函数体只有一句，return、分号和大括号都可以省略<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(param1, param2, …, paramN) =&gt; expression</span><br><span class="line">//相当于</span><br><span class="line">(param1, param2, …, paramN) =&gt;&#123; return expression; &#125;</span><br><span class="line">// 返回对象</span><br><span class="line">(param1, param2, …, paramN) =&gt; (&#123;name: &apos;xiaoming&apos;&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：如果返回的是一个对象，要用<code>()</code>包括，因为<code>{}</code>会被认为是一个代码块</li>
</ul>
</li>
</ol>
<h1 id="五-集合"><a href="#五-集合" class="headerlink" title="五 集合"></a>五 集合</h1><h2 id="5-1-Set"><a href="#5-1-Set" class="headerlink" title="5.1 Set"></a>5.1 Set</h2><h3 id="1-概述-5"><a href="#1-概述-5" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>Set中的元素有序（存取顺序一致） 唯一</li>
<li>基本数据类型和引用数据类型都可以存储（包括NaN，undefined和null）</li>
<li>元素相等 基于 <code>sameValueZero</code> 算法<ul>
<li>类似<code>===</code>，除了NaN不同，<code>NaN === NaN</code>返回false，但是在Set中看作相等</li>
</ul>
</li>
</ol>
<h3 id="2-构造函数-2"><a href="#2-构造函数-2" class="headerlink" title="2 构造函数"></a>2 构造函数</h3><ul>
<li><code>new Set([iterable])</code><ul>
<li><code>iterable</code><ul>
<li>可迭代对象，它的所有元素将不重复地被添加到 Set中。</li>
<li>如果省略或其值为null，则新的 Set为空</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-原型属性"><a href="#3-原型属性" class="headerlink" title="3 原型属性"></a>3 原型属性</h3><ol>
<li><code>size</code><ul>
<li>返回Set对象中元素的个数</li>
</ul>
</li>
</ol>
<h3 id="4-原型方法-1"><a href="#4-原型方法-1" class="headerlink" title="4 原型方法"></a>4 原型方法</h3><ol>
<li><code>add(value)</code><ul>
<li>向Set末尾添加元素，返回Set</li>
</ul>
</li>
<li><code>delete(value)</code><ul>
<li>从Set 中删除指定元素，成功删除返回 true，否则返回 false</li>
</ul>
</li>
<li><code>has(value)</code><ul>
<li>判断Set中是否有指定的元素</li>
</ul>
</li>
<li><code>clear()</code><ul>
<li>清空Set</li>
</ul>
</li>
<li><code>keys()</code><ul>
<li>由于 Set 结构没有键，只有值，keys() 与 values() 完全一样</li>
</ul>
</li>
<li><code>values()</code><ul>
<li>返回值的迭代器对象</li>
</ul>
</li>
<li><code>entries()</code><ul>
<li>返回键值对的迭代器对象</li>
<li>键值对形式为<code>[value, value]</code>，即Set中的元素即是键也是值</li>
</ul>
</li>
<li><code>forEach(callback[, thisArg])</code> <ul>
<li>根据集合中元素的插入顺序，依次执行提供的回调函数</li>
<li><code>callback([currentValue[, currentKey[, set]]])</code><ul>
<li><code>currentValue</code><ul>
<li>当前元素</li>
</ul>
</li>
<li><code>currentKey</code><ul>
<li>由于Set没有键，currentKey与currentValue永远都一样，即也是当前元素</li>
</ul>
</li>
<li><code>set</code><ul>
<li>当前Set</li>
</ul>
</li>
</ul>
</li>
<li><code>thisArg</code><ul>
<li>回调函数执行过程中的 this 值</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="6-Set转数组"><a href="#6-Set转数组" class="headerlink" title="6 Set转数组"></a>6 Set转数组</h3><ol>
<li>展开语法<ul>
<li><code>...set</code></li>
</ul>
</li>
<li><code>Array.from(set)</code></li>
</ol>
<h2 id="5-2-WeakSet"><a href="#5-2-WeakSet" class="headerlink" title="5.2 WeakSet"></a>5.2 WeakSet</h2><ol>
<li>用法同Set大致相同</li>
<li>与Set的区别<ol>
<li>WeakSet只能存引用数据类型</li>
<li>WeakSet是弱引用<ul>
<li>当对象引用数量为0时，会被垃圾回收掉，弱引用的意思就是不会增加对象的引用数量。</li>
</ul>
</li>
<li>WeakSet 不可遍历<ul>
<li>因为WeakSet弱引用，其中的对象随时有可能别垃圾回收掉</li>
</ul>
</li>
<li>没有<code>size</code> 属性</li>
<li>原型方法只有 <code>add() delete() has()</code></li>
</ol>
</li>
</ol>
<h2 id="5-3-Map"><a href="#5-3-Map" class="headerlink" title="5.3 Map"></a>5.3 Map</h2><h3 id="1-概述-6"><a href="#1-概述-6" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>Map是键值对的集合，且键有序（存取一致）</li>
<li>对象的键只能是字符串，Map的键可以是任何值</li>
<li>如果键相等，后边的值回覆盖前边，键相等 基于 <code>sameValueZero</code> 算法<ul>
<li>类似<code>===</code>，除了NaN不同，<code>NaN === NaN</code>返回false，但是在Map中看作相等</li>
</ul>
</li>
</ol>
<h3 id="2-构造函数-3"><a href="#2-构造函数-3" class="headerlink" title="2 构造函数"></a>2 构造函数</h3><ul>
<li><code>new Map([iterable])</code><ul>
<li><code>iterable</code><ul>
<li>可迭代对象，其元素为键值对。</li>
<li>如数组为 <code>[[&#39;name&#39;,&#39;xiaoming&#39;],[&#39;age&#39;,18]]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-原型属性-1"><a href="#3-原型属性-1" class="headerlink" title="3 原型属性"></a>3 原型属性</h3><ol>
<li><code>size</code><ul>
<li>返回Map中键值对的个数</li>
</ul>
</li>
</ol>
<h3 id="4-原型方法-2"><a href="#4-原型方法-2" class="headerlink" title="4 原型方法"></a>4 原型方法</h3><ol>
<li><code>set(key, value)</code><ul>
<li>向Map添加元素，返回Map</li>
</ul>
</li>
<li><code>get(key)</code><ul>
<li>根据key获取value，没有返回undefined</li>
</ul>
</li>
<li><code>delete(key)</code><ul>
<li>根据key删除元素，删除成功返回true，否则返回false</li>
</ul>
</li>
<li><code>clear()</code><ul>
<li>清空Map</li>
</ul>
</li>
<li><code>has(key)</code><ul>
<li>判断指定key的元素是否存在</li>
</ul>
</li>
<li><code>keys()</code><ul>
<li>返回键的迭代器对象</li>
</ul>
</li>
<li><code>values()</code><ul>
<li>返回值的迭代器对象</li>
</ul>
</li>
<li><code>entries()</code><ul>
<li>返回键值对<code>[key, value]</code>的迭代器对象</li>
</ul>
</li>
<li><code>forEach(callback[, thisArg])</code><ul>
<li>根据集合中元素的插入顺序，依次执行提供的回调函数</li>
<li><code>callback([value[, key[, map]]])</code></li>
</ul>
</li>
</ol>
<h3 id="5-Map转数组"><a href="#5-Map转数组" class="headerlink" title="5 Map转数组"></a>5 Map转数组</h3><ul>
<li>展开语法<ul>
<li><code>...map</code></li>
</ul>
</li>
</ul>
<h2 id="5-4-WeakMap"><a href="#5-4-WeakMap" class="headerlink" title="5.4 WeakMap"></a>5.4 WeakMap</h2><ol>
<li>用法同Map大致相同</li>
<li>与Map的区别<ol>
<li>WeakMap的键只能是引用数据类型（不能为null）</li>
<li>WeakMap的键是弱引用</li>
<li>WeakMap不能遍历</li>
<li>WeakMap没有<code>size</code>属性</li>
<li>WeakMap原型方法只有 <code>set() get() delete() has()</code></li>
</ol>
</li>
</ol>
<h1 id="六-Date"><a href="#六-Date" class="headerlink" title="六 Date"></a>六 Date</h1><h2 id="6-1-构造函数"><a href="#6-1-构造函数" class="headerlink" title="6.1 构造函数"></a>6.1 构造函数</h2><ol>
<li><code>Date([value])</code><ul>
<li>普通函数，无论有没有参数，都返回当前日期和时间的字符串</li>
</ul>
</li>
<li><code>new Date()</code><ol>
<li><code>new Date()</code><ul>
<li>创建一个当前日期和时间的Date对象</li>
</ul>
</li>
<li><code>new Date(value)</code><ul>
<li><code>value</code><ul>
<li>Unix 时间戳，是一个整数值，表示自1970年1月1日00:00:00 UTC（the Unix epoch）以来的毫秒数</li>
</ul>
</li>
</ul>
</li>
<li><code>new Date(dateString)</code><ul>
<li><code>dateString</code><ul>
<li>表示日期的字符串。该字符串能被 <code>Date.parse()</code>正确识别</li>
</ul>
</li>
</ul>
</li>
<li><code>new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]])</code><ul>
<li>分别指定年月日时分秒毫秒</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="6-2-静态方法"><a href="#6-2-静态方法" class="headerlink" title="6.2 静态方法"></a>6.2 静态方法</h2><ol>
<li><code>Date.now()</code><ul>
<li>返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数</li>
</ul>
</li>
<li><code>Date.parse(dateString)</code><ul>
<li>解析日期字符串，返回该时间距离时间零点的毫秒数。</li>
</ul>
</li>
<li><code>Date.UTC(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]])</code><ul>
<li>返回该时间距离时间零点的毫秒数</li>
</ul>
</li>
</ol>
<h2 id="6-3-原型方法"><a href="#6-3-原型方法" class="headerlink" title="6.3 原型方法"></a>6.3 原型方法</h2><h3 id="1-to"><a href="#1-to" class="headerlink" title="1 to"></a>1 to</h3><ol>
<li><code>valueOf()</code><ul>
<li>返回实例对象距离时间零点对应的毫秒数，同<code>getTime()</code></li>
</ul>
</li>
<li><code>toString()</code> / <code>toDateString()</code> / <code>toTimeString()</code><ul>
<li>返回一个日期时间字符串 / 日期字符串 / 时间字符串</li>
</ul>
</li>
<li><code>toLocaleString()</code> / <code>toLocaleDateString()</code> / <code>toLocaleTimeString()</code><ul>
<li>返回一个本地日期时间字符串 / 本地日期字符串 / 本地时间字符串</li>
</ul>
</li>
<li><code>toUTCString()</code><ul>
<li>返回使用UTC时区表示给定日期的字符串，比北京时间晚8个小时</li>
</ul>
</li>
<li><code>toISOString()</code><ul>
<li>返回对应时间的 ISO8601 写法的字符串</li>
</ul>
</li>
<li><code>toJSON()</code><ul>
<li>返回一个符合 JSON 格式的 ISO 日期字符串，与<code>toISOString()</code>方法的返回结果完全相同</li>
</ul>
</li>
</ol>
<h3 id="2-get"><a href="#2-get" class="headerlink" title="2 get"></a>2 get</h3><ol>
<li><code>getTime()</code><ul>
<li>返回Date实例距离事件元点的毫秒数</li>
</ul>
</li>
<li><code>getFullYear</code><ul>
<li>四位数的年份</li>
</ul>
</li>
<li><code>getMonth()</code><ul>
<li>月 0-11</li>
</ul>
</li>
<li><code>getDate()</code><ul>
<li>日 1-31</li>
</ul>
</li>
<li><code>getDay()</code><ul>
<li>星期 0-6</li>
</ul>
</li>
<li><code>getHours()</code><ul>
<li>时 0-23</li>
</ul>
</li>
<li><code>getMinutes()</code><ul>
<li>分 0-59</li>
</ul>
</li>
<li><code>getSeconds()</code><ul>
<li>秒 0-59</li>
</ul>
</li>
<li><code>getMilliseconds</code><ul>
<li>毫秒 0-999</li>
</ul>
</li>
</ol>
<h3 id="3-set"><a href="#3-set" class="headerlink" title="3 set"></a>3 set</h3><ul>
<li>set 与 get 一一相对应，除了没有 <code>setDay()</code>，因为星期是算的</li>
</ul>
<h1 id="七-RegExp"><a href="#七-RegExp" class="headerlink" title="七 RegExp"></a>七 RegExp</h1><h2 id="7-1-构造函数"><a href="#7-1-构造函数" class="headerlink" title="7.1 构造函数"></a>7.1 构造函数</h2><ol>
<li><code>RegExp()</code> 和 <code>new RegExp()</code> 一样，返回正则对象</li>
<li><code>new RegExp(pattern [, flags])</code> <ul>
<li><code>pattern</code><ul>
<li>正则表达式的文本</li>
</ul>
</li>
<li><code>flags</code><ul>
<li>修饰符，可以是<code>g i m u y s</code>的任意组合</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="7-2-字面量"><a href="#7-2-字面量" class="headerlink" title="7.2 字面量"></a>7.2 字面量</h2><ul>
<li><code>/pattern/flags</code><ul>
<li><code>/</code> 斜杠表示开始和结束</li>
</ul>
</li>
</ul>
<h2 id="7-3-原型属性"><a href="#7-3-原型属性" class="headerlink" title="7.3 原型属性"></a>7.3 原型属性</h2><ol>
<li><code>global</code><ul>
<li>只读，返回一个布尔值，判断是否设置了修饰符<code>g</code></li>
</ul>
</li>
<li><code>ignoreCase</code><ul>
<li>只读，返回一个布尔值，判断是否设置了修饰符<code>i</code></li>
</ul>
</li>
<li><code>multiline</code><ul>
<li>只读，返回一个布尔值，判断是否设置了修饰符<code>m</code></li>
</ul>
</li>
<li><code>unicode</code><ul>
<li>只读，返回一个布尔值，判断是否设置了修饰符<code>u</code></li>
</ul>
</li>
<li><code>sticky</code><ul>
<li>只读，返回一个布尔值，判断是否设置了修饰符<code>y</code></li>
</ul>
</li>
<li><code>dotAll</code><ul>
<li>只读，返回一个布尔值，判断是否设置了修饰符<code>s</code></li>
</ul>
</li>
<li><code>flags</code><ul>
<li>只读，返回一个字符串，包含已经设置的所有修饰符，按字母排序</li>
</ul>
</li>
<li><code>source</code><ul>
<li>只读，返回正则表达式文本字符串，该字符串不包含正则字面量两边的斜杠以及任何的标志字符    </li>
</ul>
</li>
<li><code>lastIndex</code><ul>
<li>可读写，用来指定下一次匹配的起始索引。只有正则表达式使用了表示全局检索的 “g” 标志时，该属性才会起作用</li>
</ul>
</li>
</ol>
<h2 id="7-4-原型方法"><a href="#7-4-原型方法" class="headerlink" title="7.4 原型方法"></a>7.4 原型方法</h2><ol>
<li><code>test(str)</code><ul>
<li>如果正则表达式与指定的字符串匹配 ，返回true；否则false</li>
<li>更新正则对象的<code>lastIndex</code>属性</li>
</ul>
</li>
<li><code>exec(str)</code><ul>
<li>如果匹配成功，返回一个数组且具有详细信息，并更新正则表达式对象的 lastIndex 属性。<ul>
<li>当正则有g标志时，可以多次执行 exec 方法来查找同一个字符串中的成功匹配，且查找将从正则表达式的 lastIndex 属性指定的位置开始</li>
</ul>
</li>
<li>如果匹配失败，返回 null，并将 lastIndex 重置为 0 </li>
</ul>
</li>
</ol>
<h1 id="八-JSON"><a href="#八-JSON" class="headerlink" title="八 JSON"></a>八 JSON</h1><h2 id="8-1-语法"><a href="#8-1-语法" class="headerlink" title="8.1 语法"></a>8.1 语法</h2><ol>
<li>属性名称必须是双引号括起来的字符串；最后一个属性后不能有逗号</li>
<li>基本类型的值<ol>
<li>字符串</li>
<li>数值（必须十进制，NaN不行）</li>
<li>布尔值</li>
<li>null（undefined不行）</li>
</ol>
</li>
<li>引用类型的值<ol>
<li>数组</li>
<li>对象</li>
</ol>
</li>
</ol>
<h2 id="8-2-静态方法"><a href="#8-2-静态方法" class="headerlink" title="8.2 静态方法"></a>8.2 静态方法</h2><ol>
<li><code>JSON.stringify(value[, replacer [, space]])</code><ul>
<li>将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被<code>parse()</code>方法还原。</li>
<li><code>value</code><ul>
<li>要被序列化的对象</li>
<li>如果对象有自定义的<code>toJSON()</code>方法，那么<code>JSON.stringify()</code>会使用<code>toJSON()</code>方法的返回值作为参数</li>
</ul>
</li>
<li><code>replacer</code><ol>
<li>如果是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的处理</li>
<li>如果是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中</li>
</ol>
</li>
<li><code>space</code>：<ul>
<li>指定缩进用的空白字符串，用于美化输出（pretty-print）增加可读性。<ol>
<li>如果是数字，表示每个属性前面添加的空格（不超过10个）</li>
<li>如果是字符串（不超过10个字符），则该字符串会添加在每行前面</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><code>JSON.parse(text[, reviver])</code><ul>
<li>将 JSON 字符串转换成对应的对象</li>
<li><code>reviver(currentKey, currentValue)</code><ul>
<li>转换器，此函数调用时机在parse 函数返回之前，用于在返回之前对所得到的对象执行操作  </li>
<li>转成的对象的所有属性都会调用reviver 函数，并且会将reviver返回值作为新的属性值，如果reviver返回undefined，会删除当前属性</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="九-Error"><a href="#九-Error" class="headerlink" title="九 Error"></a>九 Error</h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><ul>
<li>当代码运行时的发生错误，会创建新的Error 对象，并将其抛出</li>
</ul>
<h2 id="9-2-构造函数"><a href="#9-2-构造函数" class="headerlink" title="9.2 构造函数"></a>9.2 构造函数</h2><ul>
<li><code>new Error([message])</code></li>
</ul>
<h2 id="9-3-原型属性"><a href="#9-3-原型属性" class="headerlink" title="9.3 原型属性"></a>9.3 原型属性</h2><ol>
<li><code>message</code><ul>
<li>错误信息</li>
</ul>
</li>
<li><code>name</code><ul>
<li>error类型的名称.初始值为<code>Error</code></li>
</ul>
</li>
</ol>
<h2 id="9-4-其它类型的错误构造函数"><a href="#9-4-其它类型的错误构造函数" class="headerlink" title="9.4 其它类型的错误构造函数"></a>9.4 其它类型的错误构造函数</h2><ol>
<li><code>EvalError</code><ul>
<li>错误原因：与 eval() 有关</li>
</ul>
</li>
<li><code>RangeError</code><ul>
<li>错误原因：数值变量或参数超出其有效范围</li>
</ul>
</li>
<li><code>ReferenceError</code><ul>
<li>错误原因：无效引用</li>
</ul>
</li>
<li><code>SyntaxError</code><ul>
<li>错误原因：语法错误</li>
</ul>
</li>
<li><code>TypeError</code><ul>
<li>错误原因：变量或参数不属于有效类型</li>
</ul>
</li>
<li><code>URIError</code><ul>
<li>错误原因：给 encodeURI()或  decodeURl()传递的参数无效</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/03/30/Javascript-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/03/30/Javascript-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">Javascript 基本数据类型</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-03-30 22:10:22 / 修改时间：22:13:41" itemprop="dateCreated datePublished" datetime="2020-03-30T22:10:22+08:00">2020-03-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/UI/Javascript/" itemprop="url" rel="index">
                    <span itemprop="name">Javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-number"><a href="#一-number" class="headerlink" title="一 number"></a>一 number</h1><h2 id="1-1-数值"><a href="#1-1-数值" class="headerlink" title="1.1 数值"></a>1.1 数值</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>任意数字</code></td>
<td>整数或者浮点数</td>
</tr>
<tr>
<td><code>+Infinity</code></td>
<td>正无穷</td>
</tr>
<tr>
<td><code>-Infinity</code></td>
<td>负无穷</td>
</tr>
<tr>
<td><code>NaN</code></td>
<td>not a number 一个不是数字的数字类型</td>
</tr>
<tr>
<td>1. JavaScript的number类型为双精度IEEE 754 64位浮点类型。范围（-2<sup>53</sup>- 2<sup>53</sup>）</td>
<td></td>
</tr>
<tr>
<td>2. JavaScript 内部，整数和浮点数采用的是同样的储存方法。所以<code>1===1.0</code> 为true</td>
<td></td>
</tr>
<tr>
<td>3. 进制</td>
<td></td>
</tr>
<tr>
<td>* 十进制</td>
<td></td>
</tr>
<tr>
<td>* 二进制：以<code>0b</code>开头</td>
<td></td>
</tr>
<tr>
<td>* 八进制：以<code>0o</code>开头</td>
<td></td>
</tr>
<tr>
<td>* 十六进制：以<code>0x</code>开头</td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-2-Number（包装类）"><a href="#1-2-Number（包装类）" class="headerlink" title="1.2 Number（包装类）"></a>1.2 Number（包装类）</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><ol>
<li><code>Number([value])</code><ul>
<li>普通函数，作用是类型转换，将value转成一个数值number<ol>
<li>如果参数为空，返回<code>0</code></li>
<li>如果参数无法被转换为数字，则返回 <code>NaN</code></li>
</ol>
</li>
</ul>
</li>
<li><code>new Number([value])</code><ul>
<li>构造函数，创建一个Number对象，值为value转换成的数值</li>
</ul>
</li>
</ol>
<h3 id="2-静态属性"><a href="#2-静态属性" class="headerlink" title="2 静态属性"></a>2 静态属性</h3><ol>
<li><code>Number.POSITIVE_INFINITY</code><ul>
<li>正的无限，指向 <code>+Infinity</code></li>
</ul>
</li>
<li><code>Number.NEGATIVE_INFINITY</code><ul>
<li>负的无限，指向 <code>-Infinity</code></li>
</ul>
</li>
<li><code>Number.NaN</code><ul>
<li>表示<code>NaN</code></li>
</ul>
</li>
<li><code>Number.MIN_VALUE</code><ul>
<li>表示在 JavaScript 中所能表示的最小的正值</li>
</ul>
</li>
<li><code>Number.MAX_VALUE</code><ul>
<li>表示在 JavaScript 里所能表示的最大数值</li>
</ul>
</li>
<li><code>Number.MIN_SAFE_INTEGER</code><ul>
<li>表示在 JavaScript 中能够准确表示的整数范围下限（-(2<sup>53</sup> - 1)）</li>
</ul>
</li>
<li><code>Number.MAX_SAFE_INTEGER</code><ul>
<li>表示在 JavaScript 中能够准确表示的整数范围上限（2<sup>53</sup> - 1）</li>
</ul>
</li>
<li><code>Number.EPSILON</code><ul>
<li>表示 1 与大于 1 的最小的浮点数之间的差值</li>
<li>实际上是 JavaScript 能够表示的最小精度</li>
</ul>
</li>
</ol>
<h3 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="3 静态方法"></a>3 静态方法</h3><ol>
<li><code>Number.isNaN(value)</code><ul>
<li>判断给定的值是否是 NaN。</li>
<li>和全局函数<code>isNaN()</code> 的区别<ul>
<li>全局函数 <code>isNaN()</code> 会先将非数值转换为数值，再进行判断</li>
<li><code>Number.isNaN()</code> 只对数值有效，非数值直接返回false</li>
</ul>
</li>
</ul>
</li>
<li><code>Number.isFinite(value)</code><ul>
<li>判断给定的值是否是有穷数</li>
<li>和全局函数<code>isFinite()</code> 函数的区别<ul>
<li>全局函数 <code>isFinite()</code> 会先将非数值转换为数值，再进行判断</li>
<li><code>Number.isFinite()</code> 只对数值有效，非数值直接返回false</li>
</ul>
</li>
</ul>
</li>
<li><code>Number.isInteger(value)</code><ul>
<li>判断给定值是否是整数</li>
</ul>
</li>
<li><code>Number.parseInt(string[, radix])</code><ul>
<li>将一个字符串转换成指定进制的整数</li>
<li><code>radix</code><ul>
<li>指定进制（2-36），默认10</li>
</ul>
</li>
<li>同 全局函数 <code>parseInt()</code>，移植到Number上，目的是逐步减少全局性方法，使得语言逐步模块化</li>
</ul>
</li>
<li><code>Number.parseFloat(string)</code><ul>
<li>把一个字符串解析成浮点数</li>
<li>同 全局函数<code>parseFloat()</code>，移植到Number上，目的是逐步减少全局性方法，使得语言逐步模块化</li>
</ul>
</li>
</ol>
<h3 id="4-原型方法"><a href="#4-原型方法" class="headerlink" title="4 原型方法"></a>4 原型方法</h3><ol>
<li><code>valueOf()</code><ul>
<li>返回基本类型的值</li>
</ul>
</li>
<li><code>toString([radix])</code><ul>
<li>返回字符串形式</li>
</ul>
</li>
<li><code>toFixed([digits])</code><ul>
<li>返回保留指定位数浮点数的字符串</li>
<li><code>digits</code><ul>
<li>小数点后数字的个数，默认为0</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="1-3-Math"><a href="#1-3-Math" class="headerlink" title="1.3 Math"></a>1.3 Math</h2><h3 id="1-静态属性"><a href="#1-静态属性" class="headerlink" title="1 静态属性"></a>1 静态属性</h3><ol>
<li><code>Math.E</code><ul>
<li>欧拉常数 <code>e</code></li>
</ul>
</li>
<li><code>Math.PI</code><ul>
<li>常数 <code>π</code></li>
</ul>
</li>
</ol>
<h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2 静态方法"></a>2 静态方法</h3><ol>
<li><code>Math.abs(x)</code><ul>
<li>绝对值</li>
</ul>
</li>
<li><code>Math.ceil(x)</code><ul>
<li>向上取整</li>
</ul>
</li>
<li><code>Math.floor(x)</code><ul>
<li>向下取整</li>
</ul>
</li>
<li><code>Math.pow(x, y)</code><ul>
<li>返回 x 的 y 次幂</li>
</ul>
</li>
<li><code>Math.random()</code><ul>
<li>返回0-1之间的伪随机数(含0不含1)</li>
</ul>
</li>
<li><code>Math.round(x)</code><ul>
<li>四舍五入</li>
</ul>
</li>
<li><code>Math.sqrt(x)</code><ul>
<li>平方</li>
</ul>
</li>
<li><code>Math.log(x)</code><ul>
<li>对数</li>
</ul>
</li>
<li><code>Math.exp(x)</code><ul>
<li><code>e</code> 的指数（e的x次方）</li>
</ul>
</li>
<li><code>Math.min([value1[,value2, ...]])</code><ul>
<li>返回给定的一组数字中的最小值。如果任一参数不能转换为数值，则返回NaN。</li>
</ul>
</li>
<li><code>Math.max(value1[,value2, ...])</code><ul>
<li>返回给定的一组数字中的最大值。如果任一参数不能转换为数值，则返回NaN。</li>
</ul>
</li>
<li><code>Math.sin(x)</code><ul>
<li>正弦</li>
</ul>
</li>
<li><code>Math.cos(x)</code><ul>
<li>余弦</li>
</ul>
</li>
<li><code>Math.tan(x)</code><ul>
<li>正切    </li>
</ul>
</li>
</ol>
<h1 id="二-boolean"><a href="#二-boolean" class="headerlink" title="二 boolean"></a>二 boolean</h1><h2 id="2-1-布尔值"><a href="#2-1-布尔值" class="headerlink" title="2.1 布尔值"></a>2.1 布尔值</h2><ul>
<li><code>true</code></li>
<li><code>false</code></li>
</ul>
<h2 id="2-2-类型转换"><a href="#2-2-类型转换" class="headerlink" title="2.2 类型转换"></a>2.2 类型转换</h2><h3 id="1-类型转换规则"><a href="#1-类型转换规则" class="headerlink" title="1 类型转换规则"></a>1 类型转换规则</h3><table>
<thead>
<tr>
<th>值</th>
<th>转换结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>0</code></td>
<td>false</td>
</tr>
<tr>
<td><code>NaN</code></td>
<td>false</td>
</tr>
<tr>
<td><code>&quot;&quot;</code></td>
<td>false</td>
</tr>
<tr>
<td><code>false</code></td>
<td>false</td>
</tr>
<tr>
<td><code>null</code></td>
<td>false</td>
</tr>
<tr>
<td><code>undefined</code></td>
<td>false</td>
</tr>
<tr>
<td>其它</td>
<td>true</td>
</tr>
</tbody></table>
<ol>
<li>隐式转换<ul>
<li>基本上所有类型都可以隐式转换为 boolean类型。</li>
<li>注意：值和布尔值是不同的概念</li>
</ul>
</li>
<li>显式转换<ol>
<li><code>Boolean()</code></li>
<li><code>!!</code></li>
<li><code>new Boolean()</code><ul>
<li>不太好，因为返回一个对象，而将对象转换成布尔值必为true</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="2-3-Boolean（包装类）"><a href="#2-3-Boolean（包装类）" class="headerlink" title="2.3 Boolean（包装类）"></a>2.3 Boolean（包装类）</h2><h3 id="1-构造函数-1"><a href="#1-构造函数-1" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><ol>
<li><code>Boolean([value])</code><ul>
<li>普通函数，作用是类型转换，将value转成一个布尔值boolean</li>
</ul>
</li>
<li><code>new Boolean([value])</code><ul>
<li>构造函数，创建一个Boolean对象<ol>
<li>如果省略参数，则Boolean对象值为false</li>
<li>如果value不是布尔值，则先转成布尔值</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="2-原型方法"><a href="#2-原型方法" class="headerlink" title="2 原型方法"></a>2 原型方法</h3><ol>
<li><code>valueOf()</code><ul>
<li>返回基本类型的值<code>true/false</code></li>
</ul>
</li>
<li><code>toString()</code><ul>
<li>返回字符串形式 <code>&#39;true&#39;/&#39;false&#39;</code></li>
</ul>
</li>
</ol>
<h1 id="三-string"><a href="#三-string" class="headerlink" title="三 string"></a>三 string</h1><h2 id="3-1-字符串字面量"><a href="#3-1-字符串字面量" class="headerlink" title="3.1 字符串字面量"></a>3.1 字符串字面量</h2><ol>
<li>单/双引号（特殊字符使用<code>\</code>转义）</li>
<li>反引号（模板字面量，特殊字符直接使用，反引号需要使用<code>\</code>转义）</li>
</ol>
<h2 id="3-2-字符的-Unicode表示法"><a href="#3-2-字符的-Unicode表示法" class="headerlink" title="3.2 字符的 Unicode表示法"></a>3.2 字符的 Unicode表示法</h2><ol>
<li><code>\uxxxx</code><ul>
<li>只限于Unicode编码在<code>\u0000~\uFFFF</code>（0-65535）之间的字符</li>
</ul>
</li>
<li><code>\u{}</code><ul>
<li>使用<code>{}</code>，大于<code>\uFFFF</code>的字符也能正确表示</li>
</ul>
</li>
</ol>
<h2 id="3-3-字符串换行"><a href="#3-3-字符串换行" class="headerlink" title="3.3 字符串换行"></a>3.3 字符串换行</h2><ol>
<li>末尾加<code>\</code></li>
<li>加号连接</li>
<li>反引号</li>
</ol>
<h2 id="3-4-模板字面量"><a href="#3-4-模板字面量" class="headerlink" title="3.4 模板字面量"></a>3.4 模板字面量</h2><ol>
<li>模板字面量是增强版的字符串，它用反引号标识</li>
<li>空格换行等都会原样输出</li>
<li><code>${表达式}</code> <ul>
<li>占位符就如同一个普通字符串一样，可以插入到字符串中的任意位置</li>
<li>作用是取表达式的值</li>
</ul>
</li>
<li>反引号可以嵌套</li>
</ol>
<h2 id="3-5-模板字面量标签"><a href="#3-5-模板字面量标签" class="headerlink" title="3.5 模板字面量标签"></a>3.5 模板字面量标签</h2><ol>
<li>模板字面量标签通常是一个函数</li>
<li>调用标签函数，将它放在模板字面量前即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert`hello`;</span><br><span class="line">function myTag (strings, ...values)&#123;&#125;</span><br><span class="line">myTag`hello`</span><br></pre></td></tr></table></figure></li>
<li>调用标签函数时，会将模板字面量处理成参数，传递给函数<ol>
<li>第一个参数是数组，存储模板字面量中占位符<code>${}</code>两侧的字符串</li>
<li>第二个参数是可变参数，存储占位符<code>${}</code>的返回值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let name = &apos;xiaoming&apos;, age = 18;</span><br><span class="line">alert`hello$&#123;name&#125;,ni$&#123;18&#125;了吗`; </span><br><span class="line">// 相当于</span><br><span class="line">alert ([&apos;hello&apos;, &apos;,ni&apos;, &apos;了吗&apos;], &apos;xiaoming&apos;, 18);</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h2 id="3-6-String（包装类）"><a href="#3-6-String（包装类）" class="headerlink" title="3.6 String（包装类）"></a>3.6 String（包装类）</h2><h3 id="1-构造函数-2"><a href="#1-构造函数-2" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><ol>
<li><code>String([value])</code><ul>
<li>普通函数，作用是类型转换，将value转成一个字符串string<ol>
<li>如果参数为空，则返回空字符串<code>&#39;&#39;</code></li>
<li>如果参数是基本类型，则返回基本类型的字符串形式</li>
<li>如果参数是引用类型，相当于调用其<code>toString()</code></li>
</ol>
</li>
</ul>
</li>
<li><code>new String([value])</code><ul>
<li>构造函数，创建一个String对象，值为value转成的字符串</li>
</ul>
</li>
</ol>
<h3 id="2-实例属性"><a href="#2-实例属性" class="headerlink" title="2 实例属性"></a>2 实例属性</h3><ul>
<li><code>length</code></li>
</ul>
<h3 id="3-静态方法-1"><a href="#3-静态方法-1" class="headerlink" title="3 静态方法"></a>3 静态方法</h3><ol>
<li><code>String.fromCharCode(num1, ..., numN)</code><ul>
<li>返回使用指定的 Unicode 编码创建的字符串（不能识别大于<code>0xFFFF</code>的字符）</li>
<li><code>num1, ..., numN</code><ul>
<li>一串 Unicode 编码</li>
</ul>
</li>
</ul>
</li>
<li><code>String.fromCodePoint(num1[, ...[, numN]])</code><ul>
<li>返回使用指定的 Unicode 编码创建的字符串（可以识别大于<code>0xFFFF</code>的字符）</li>
</ul>
</li>
<li><code>String.raw&#96;templateString&#96;</code><ul>
<li>返回模板字符串的原始字符串</li>
<li>是唯一一个内置的模板字符串标签函数</li>
</ul>
</li>
</ol>
<h3 id="4-原型方法-1"><a href="#4-原型方法-1" class="headerlink" title="4 原型方法"></a>4 原型方法</h3><h4 id="1-获取"><a href="#1-获取" class="headerlink" title="1 获取"></a>1 获取</h4><ol>
<li><code>valueOf()</code><ul>
<li>返回字符串对象的原始字符串</li>
</ul>
</li>
<li><code>repeat(count)</code><ul>
<li>当前字符串重复count次组成新字符串并返回</li>
</ul>
</li>
<li><code>concat(str1, str2[, ..., strN])</code><ul>
<li>将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回，不改变原字符串</li>
</ul>
</li>
<li><code>slice(beginIndex[, endIndex])</code><ul>
<li>提取从开始索引到结束索引之间（含头不含尾）的字符串并返回，不改变原字符串</li>
<li>索引可以为负，则索引为负时表示从后开始（-1, -2 …）</li>
<li>索引超过字符串长度时，会被当作末尾</li>
</ul>
</li>
<li><code>substring(beginIndex[, endIndex])</code><ul>
<li>提取从开始索引到结束索引之间（含头不含尾）的字符串并返回，不改变原字符串</li>
<li>索引为负时或为 NaN，则被当作 0</li>
<li>索引超过字符串长度时，会被当作末尾</li>
</ul>
</li>
<li><code>substr(beginIndex, length)</code>（    已过时）<ul>
<li>提取从起始索引号指定数目的字符串并返回，不改变原字符串</li>
</ul>
</li>
</ol>
<h4 id="2-改"><a href="#2-改" class="headerlink" title="2 改"></a>2 改</h4><ol>
<li><code>toLowerCase() / toUpperCase()</code><ul>
<li>将一个字符串转小/大写，返回一个新字符串，不改变原字符串</li>
</ul>
</li>
<li><code>trim()</code><ul>
<li>去除字符串两端的空格，返回一个新字符串，不改变原字符串</li>
</ul>
</li>
<li><code>trimStart() / trimEnd()</code><ul>
<li><code>trimLeft()</code>是 <code>trimStart()</code> 的别名，<code>trimRight()</code> 是<code>trimEnd()</code>的别名</li>
</ul>
</li>
<li><code>padStart(targetLength [, padString])</code><ul>
<li>以指定字符串<code>padString</code>在原字符串开头补充，以达到目标长度<code>targetLength</code></li>
<li><code>targetLength</code><ul>
<li>当前字符串需要填充到的目标长度，如果小于等于当前字符串长度，则返回当前字符串</li>
</ul>
</li>
<li><code>padString</code><ul>
<li>填充字符串，如果省略则使用空格</li>
</ul>
</li>
</ul>
</li>
<li><code>padEnd(targetLength [, padString])</code></li>
</ol>
<h4 id="3-查"><a href="#3-查" class="headerlink" title="3 查"></a>3 查</h4><ol>
<li><code>charAt(index)</code><ul>
<li>返回指定位置的字符</li>
</ul>
</li>
<li><code>charCodeAt(index)</code><ul>
<li>返回指定位置的字符Unicode 值（十进制）</li>
<li>只能获取2个字节表示的字符，对于4个字节表示的字符会认为是两个字符</li>
</ul>
</li>
<li><code>codePointAt(index)</code><ul>
<li>返回指定位置的字符Unicode 值（十进制）</li>
<li>可以正确获取4个字节表示的字符</li>
<li>javaScript内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。（<code>0-65535</code> 或 <code>0x0000-0xFFFF</code>）</li>
</ul>
</li>
<li><code>indexOf(searchValue[, fromIndex])</code><ul>
<li>返回一个字符串在另一个字符串中第一次出现的索引，未找到返回-1</li>
<li>默认从0索引开始往后找</li>
</ul>
</li>
<li><code>lastIndexOf(searchValue[, fromIndex])</code><ul>
<li>返回一个字符串在另一个字符串中从后往前第一次出现的索引，未找到返回-1</li>
</ul>
</li>
</ol>
<h4 id="4-判断"><a href="#4-判断" class="headerlink" title="4 判断"></a>4 判断</h4><ol>
<li><code>includes(searchString[, fromIndex])</code><ul>
<li>判断是否包含指定字符串</li>
</ul>
</li>
<li><code>startsWith(searchString[, fromIndex])</code><ul>
<li>判断是否以指定字符串开头</li>
</ul>
</li>
<li><code>endsWith(searchString[, length])</code><ul>
<li>判断是否以指定字符串结尾</li>
<li><code>length</code><ul>
<li>表示只判断当前字符串指定长度的子串，如3，则表示只判断前三个字符是否以指定字符串结尾</li>
<li>默认为当前字符串的length大小</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="5-正则"><a href="#5-正则" class="headerlink" title="5 正则"></a>5 正则</h4><ol>
<li><code>split([separator[, limit]])</code><ul>
<li>按照给定规则分割字符串，返回一个由分割出来的子字符串以指定分隔符组成的数组</li>
<li><code>separator</code><ul>
<li>可以是一个字符串或正则表达式</li>
</ul>
</li>
<li><code>limit</code><ul>
<li>限定返回的分割片段数量</li>
</ul>
</li>
</ul>
</li>
<li><code>search(regexp)</code><ul>
<li>返回正则表达式在字符串中首次匹配项的索引;否则，返回 -1</li>
<li><code>regexp</code><ul>
<li>正则对象，如果传入一个非正则对象，则会先转成正则对象</li>
</ul>
</li>
</ul>
</li>
<li><code>match(regexp)</code><ul>
<li>如果正则没有g标志，则返回包含第一个匹配结果的数组，且有附加属性（index, input, groups,…）</li>
<li>如果正则有g标志，则返回包含所有匹配结果的数组，没有附加属性</li>
<li>如果没有匹配，返回null</li>
</ul>
</li>
<li><code>matchAll(regexp)</code><ul>
<li>返回一个包含所有匹配正则表达式的结果（包含附加属性）的迭代器</li>
<li>没有<code>matchAll</code>之前，使用while循环加exec方式（且正则表达式需使用g标志），来获取所有匹配项</li>
</ul>
</li>
<li><code>replace(regexp|substr, newSubStr|function)</code><ul>
<li><code>regexp|substr</code><ul>
<li>正则匹配的内容或者指定的内容</li>
</ul>
</li>
<li><code>newSubStr</code><ul>
<li>使用新的字符串替换，替换时可以插入特殊变量</li>
</ul>
</li>
<li><code>function</code><ul>
<li>使用函数返回的字符串替换</li>
</ul>
</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">特殊变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>$$</code></td>
<td>插入一个 “$”</td>
</tr>
<tr>
<td align="center"><code>$&amp;</code></td>
<td>插入匹配的子串</td>
</tr>
<tr>
<td align="center">$`</td>
<td>插入当前匹配的子串左边的内容</td>
</tr>
<tr>
<td align="center"><code>$&#39;</code></td>
<td>插入当前匹配的子串右边的内容</td>
</tr>
<tr>
<td align="center"><code>$n</code></td>
<td>如果第一个参数是RegExp对象，表示插入第n组的内容</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">函数参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>match</code></td>
<td>匹配的子串。（对应<code>$&amp;</code>。）</td>
</tr>
<tr>
<td align="center"><code>p1,p2,...</code></td>
<td>如果第一个参数是RegExp对象，表示第n组的内容（对应<code>$n</code>）</td>
</tr>
<tr>
<td align="center"><code>offset</code></td>
<td>匹配到的子字符串在原字符串中起始索引</td>
</tr>
<tr>
<td align="center"><code>string</code></td>
<td>被匹配的原字符串</td>
</tr>
<tr>
<td align="center"><code>NamedCaptureGroup</code></td>
<td>命名捕获组匹配的对象</td>
</tr>
</tbody></table>
<h1 id="四-null-amp-undefined"><a href="#四-null-amp-undefined" class="headerlink" title="四 null &amp; undefined"></a>四 null &amp; undefined</h1><ol>
<li>一个没有赋值的变量默认值为undefined<ul>
<li>基本类型：初始化推荐undefined（惯例，其实默认就是undefined，null也可以）</li>
<li>引用类型：初始化推荐null（惯例，undefined也可以）</li>
</ul>
</li>
<li>值为undefined的情况<ol>
<li>变量或者对象属性没有赋值，则默认值undefined</li>
<li>调用函数时，没有传值的参数则默认为undefined</li>
<li>函数没有返回值时，默认返回 undefined </li>
</ol>
</li>
</ol>
<h1 id="五-symbol"><a href="#五-symbol" class="headerlink" title="五 symbol"></a>五 symbol</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol>
<li>symbol 的值是唯一的，独一无二的不会重复的</li>
<li>symbol 值作为对象属性名时，不能用点运算符，只能使用<code>[]</code><ol>
<li>不会被<code>for...in for... of</code>遍历到</li>
<li>不会被<code>Object.keys() Object.getOwnPropertyNames() JSON.stringify()</code>返回</li>
<li>使用<code>Object.getOwnPropertySymbols()</code>可以获取</li>
</ol>
</li>
<li>symbol 值不能与其他类型的值进行运算，可以转为字符串和布尔值</li>
</ol>
<h2 id="5-2-Symbol（包装类）"><a href="#5-2-Symbol（包装类）" class="headerlink" title="5.2 Symbol（包装类）"></a>5.2 Symbol（包装类）</h2><h3 id="1-构造函数-3"><a href="#1-构造函数-3" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><ol>
<li><code>Symbol([description])</code><ol>
<li>返回一个symbole类型的值，且是唯一的</li>
<li>不会放入全局symbol注册表</li>
<li><code>description</code><ul>
<li>字符串类型。仅仅是对symbol的描述，为了控制台显示时或者转为字符串时比较容易区分，不会影响symbol的值（即使用相同描述创建的symbol也不同）</li>
<li>如果传入的不是字符串，会先转成字符串</li>
</ul>
</li>
</ol>
</li>
<li><code>new Symbol()</code><ul>
<li>不支持此语法</li>
</ul>
</li>
</ol>
<h3 id="2-静态属性-1"><a href="#2-静态属性-1" class="headerlink" title="2 静态属性"></a>2 静态属性</h3><ul>
<li>ES6 提供了 11 个内置的 Symbol 值，指向语言内部使用的方法</li>
</ul>
<ol>
<li><code>Symbol.hasInstance</code><ul>
<li><code>A instanceof B</code> 实际调用的是 <code>B[Symbol.hasInstance](A)</code></li>
</ul>
</li>
<li><code>Symbol.iterator</code><ul>
<li><code>for(let a of A)</code> 会调用 <code>A[Symbol.iterator]()</code> 返回对象的迭代器</li>
</ul>
</li>
</ol>
<h3 id="3-实例属性"><a href="#3-实例属性" class="headerlink" title="3 实例属性"></a>3 实例属性</h3><ol>
<li><code>description</code><ul>
<li>只读属性，返回 Symbol 对象的可选的描述字符串</li>
</ul>
</li>
</ol>
<h3 id="4-静态方法"><a href="#4-静态方法" class="headerlink" title="4 静态方法"></a>4 静态方法</h3><ol>
<li><code>Symbol.for(key)</code><ul>
<li>根据键 key 从全局symbol注册表中查询，如果找到则返回，否则创建一个与key关联的symbol，放入全局 symbol 注册表中，并返回</li>
<li><code>key</code><ul>
<li>一个字符串，作为 symbol 注册表中与某 symbol 关联的键（同时也会作为该 symbol 的描述）</li>
</ul>
</li>
</ul>
</li>
<li><code>Symbol.keyFor(sym)</code><ul>
<li>获取全局symbol 注册表中与某个 symbol 关联的键，若存在则返回字符串key，否则返回undefined</li>
</ul>
</li>
</ol>
<h1 id="六-bigInt"><a href="#六-bigInt" class="headerlink" title="六 bigInt"></a>六 bigInt</h1><ul>
<li>用任意精度表示整数</li>
</ul>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/03/30/Javascript-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/03/30/Javascript-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">Javascript 数据类型概述</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-03-30 22:07:41 / 修改时间：22:10:07" itemprop="dateCreated datePublished" datetime="2020-03-30T22:07:41+08:00">2020-03-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/UI/Javascript/" itemprop="url" rel="index">
                    <span itemprop="name">Javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-数据类型判断"><a href="#一-数据类型判断" class="headerlink" title="一 数据类型判断"></a>一 数据类型判断</h1><h2 id="1-1-typeof"><a href="#1-1-typeof" class="headerlink" title="1.1 typeof"></a>1.1 typeof</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof operand  // operand：表示对象或基本值的表达式</span><br><span class="line">typeof(operand)</span><br></pre></td></tr></table></figure>
<ul>
<li>判断数据类型并返回字符串形式</li>
</ul>
<h3 id="2-返回值"><a href="#2-返回值" class="headerlink" title="2 返回值"></a>2 返回值</h3><table>
<thead>
<tr>
<th>type</th>
<th>typeof Result</th>
</tr>
</thead>
<tbody><tr>
<td>number</td>
<td>“number”</td>
</tr>
<tr>
<td>bigint</td>
<td>“bigint”</td>
</tr>
<tr>
<td>string</td>
<td>“string”</td>
</tr>
<tr>
<td>boolean</td>
<td>“boolean”</td>
</tr>
<tr>
<td>undefined</td>
<td>“undefined”</td>
</tr>
<tr>
<td>null</td>
<td>“object”</td>
</tr>
<tr>
<td>symbol</td>
<td>“symbol”</td>
</tr>
<tr>
<td>function object (implements [[Call]])</td>
<td>“function”</td>
</tr>
<tr>
<td>any other object</td>
<td>“object”</td>
</tr>
<tr>
<td>* <code>typeof null</code>返回<code>object</code>是历史原因</td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-2-instanseof"><a href="#1-2-instanseof" class="headerlink" title="1.2 instanseof"></a>1.2 instanseof</h2><ul>
<li><code>object instanceof constructor</code><ul>
<li>用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</li>
</ul>
</li>
</ul>
<h1 id="二-数据类型分类"><a href="#二-数据类型分类" class="headerlink" title="二 数据类型分类"></a>二 数据类型分类</h1><h2 id="2-1-基本数据类型"><a href="#2-1-基本数据类型" class="headerlink" title="2.1 基本数据类型"></a>2.1 基本数据类型</h2><ol>
<li>number</li>
<li>boolean</li>
<li>string</li>
<li>null</li>
<li>undefined</li>
<li>symbol</li>
<li>bigInt</li>
</ol>
<h2 id="2-2-引用数据类型"><a href="#2-2-引用数据类型" class="headerlink" title="2.2 引用数据类型"></a>2.2 引用数据类型</h2><ul>
<li>object<ol>
<li>内置对象<ol>
<li>对象 （Object）</li>
<li>数组 （Array）</li>
<li>集合 （Map Set WeakMap WeakSet）</li>
<li>函数（Function）</li>
<li>基本类型包装对象（Number Boolean String Symbol BigInt）</li>
<li>数学（Math）</li>
<li>日期（Date）</li>
<li>Json（JSON）</li>
<li>正则（RegExp）</li>
<li>错误（Error）</li>
<li>……</li>
</ol>
</li>
<li>自定义对象</li>
</ol>
</li>
</ul>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/03/30/Javascript-%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/03/30/Javascript-%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">Javascript 语法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-03-30 22:02:03 / 修改时间：22:23:03" itemprop="dateCreated datePublished" datetime="2020-03-30T22:02:03+08:00">2020-03-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/UI/Javascript/" itemprop="url" rel="index">
                    <span itemprop="name">Javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-严格模式"><a href="#一-严格模式" class="headerlink" title="一 严格模式"></a>一 严格模式</h1><h2 id="1-1-启用"><a href="#1-1-启用" class="headerlink" title="1.1 启用"></a>1.1 启用</h2><ul>
<li><code>&quot;use strict;&quot;</code><ol>
<li>放在脚本文件的第一行，整个脚本都将以严格模式运行。</li>
<li>放在函数体的第一行，则整个函数以严格模式运行。</li>
</ol>
</li>
</ul>
<h2 id="1-2-严格模式中的变化"><a href="#1-2-严格模式中的变化" class="headerlink" title="1.2 严格模式中的变化"></a>1.2 严格模式中的变化</h2><h3 id="1-显式报错"><a href="#1-显式报错" class="headerlink" title="1 显式报错"></a>1 显式报错</h3><ol>
<li>严格模式会使引起静默失败(silently fail，不报错也没有任何效果)的赋值操作抛出异常<ul>
<li>只读属性的写操作，不可扩展对象扩展操作，</li>
</ul>
</li>
<li>严格模式下，试图删除不可删除的属性时会抛出异常</li>
<li>严格模式下禁止对象属性重名</li>
<li>严格模式下禁止函数参数重名</li>
<li>严格模式禁止八进制数字语法</li>
</ol>
<h3 id="2-安全措施"><a href="#2-安全措施" class="headerlink" title="2 安全措施"></a>2 安全措施</h3><ol>
<li>严格模式下，变量必须先声明，然后再使用</li>
<li>禁止 this 关键字指向全局对象window</li>
<li>严格模式禁止删除声明变量</li>
</ol>
<h3 id="3-静态绑定"><a href="#3-静态绑定" class="headerlink" title="3 静态绑定"></a>3 静态绑定</h3><ul>
<li>js允许动态绑定，即属性或方法属于哪个对象不是编译时确定的，而是在运行时确定</li>
<li>严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定，即编译时就确定属性或方法属于哪个对象。</li>
</ul>
<ol>
<li>严格模式禁用 <code>with</code>语句</li>
<li>创设 eval 作用域<ul>
<li>正常模式下，eval语句的作用域，取决于它处于全局作用域，还是函数作用域。</li>
<li>严格模式下，eval语句本身就是一个作用域，即eval所生成的变量只能用于eval内部</li>
</ul>
</li>
<li>arguments 不再追踪参数的变化<ul>
<li>变量arguments代表函数的参数。</li>
<li>严格模式下，函数内部改变参数与arguments的联系被切断了，两者不再存在联动关系</li>
</ul>
</li>
</ol>
<h1 id="二-顶层对象"><a href="#二-顶层对象" class="headerlink" title="二 顶层对象"></a>二 顶层对象</h1><ol>
<li>JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。</li>
<li>顶层对象在各种实现里面是不统一的</li>
<li>ES2020标准中，引入<code>globalThis</code>作为顶层对象。也就是说，任何环境下，<code>globalThis</code>都是存在的</li>
</ol>
<table>
<thead>
<tr>
<th>环境</th>
<th>顶层对象</th>
<th>ES2020</th>
</tr>
</thead>
<tbody><tr>
<td>浏览器</td>
<td>window，self</td>
<td>globalThis</td>
</tr>
<tr>
<td>Web Worker</td>
<td>self</td>
<td>globalThis</td>
</tr>
<tr>
<td>Node</td>
<td>global</td>
<td>globalThis</td>
</tr>
</tbody></table>
<h1 id="三-注释"><a href="#三-注释" class="headerlink" title="三 注释"></a>三 注释</h1><ol>
<li><code>//</code></li>
<li><code>/* */</code><ul>
<li>不能嵌套</li>
</ul>
</li>
</ol>
<h1 id="四-作用域"><a href="#四-作用域" class="headerlink" title="四 作用域"></a>四 作用域</h1><ol>
<li>全局作用域</li>
<li>块作用域</li>
<li>函数作用域</li>
</ol>
<h1 id="五-声明关键字"><a href="#五-声明关键字" class="headerlink" title="五 声明关键字"></a>五 声明关键字</h1><p>关键字|初始化|变量提升|块作用域|window|同一作用域重复声明<br>:-:|-|-|-|-<br><code>var</code>|可选|有|无|全局变量会成为window对象属性|可以，后者覆盖前者<br><code>let</code>|可选|无|有|全局变量不属于window属性|不能<br><code>const</code>|必须|无|有|全局变量不属于window属性|不能</p>
<ol>
<li>变量提升<ul>
<li>变量的声明语句，被提升到代码的头部</li>
</ul>
</li>
<li>暂时性死区（temporal dead zone，简称 TDZ<ul>
<li>let和const没有变量提升，所以必须先声明后使用</li>
<li>从作用域开始到声明语句的区域，如果使用声明的变量就会会导致 ReferenceError，这块区域称为暂时性死区。</li>
</ul>
</li>
<li>const 常量指向的内存地址不能改变<ol>
<li>基本类型值不能改变</li>
<li>引用类型地址值不能修改</li>
</ol>
</li>
</ol>
<h1 id="六-变量"><a href="#六-变量" class="headerlink" title="六 变量"></a>六 变量</h1><ol>
<li>变量的声明和赋值，是分开的两个步骤<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = 1;  // 其实是下边两步</span><br><span class="line">let a;</span><br><span class="line">a = 1;</span><br></pre></td></tr></table></figure></li>
<li>同一条声明语句中可以声明多个变量</li>
<li>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</li>
<li>变量标识符命名规则<ol>
<li>不能用数字开头</li>
<li>可以用中文</li>
<li>不能使用js保留字</li>
</ol>
</li>
</ol>
<h1 id="七-运算符"><a href="#七-运算符" class="headerlink" title="七 运算符"></a>七 运算符</h1><h2 id="7-1-赋值运算符"><a href="#7-1-赋值运算符" class="headerlink" title="7.1 赋值运算符"></a>7.1 赋值运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
<th>等价于</th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td>赋值</td>
<td><code>x = y</code></td>
<td><code>x = y</code></td>
</tr>
<tr>
<td><code>+=</code></td>
<td>加赋值</td>
<td><code>x += y</code></td>
<td><code>x = x + y</code></td>
</tr>
<tr>
<td><code>-=</code></td>
<td>减赋值</td>
<td><code>x -= y</code></td>
<td><code>x = x - y</code></td>
</tr>
<tr>
<td><code>*=</code></td>
<td>乘赋值</td>
<td><code>x *= y</code></td>
<td><code>x = x * y</code></td>
</tr>
<tr>
<td><code>/=</code></td>
<td>除赋值</td>
<td><code>x /= y</code></td>
<td><code>x = x / y</code></td>
</tr>
<tr>
<td><code>%=</code></td>
<td>模赋值</td>
<td><code>x %= y</code></td>
<td><code>x = x % y</code></td>
</tr>
<tr>
<td><code>**=</code></td>
<td>指数赋值</td>
<td><code>x **= y</code></td>
<td><code>x = x ** y</code></td>
</tr>
<tr>
<td><code>&lt;&lt;=</code></td>
<td>左移赋值</td>
<td><code>x &lt;&lt;= y</code></td>
<td><code>x = x &lt;&lt; y</code></td>
</tr>
<tr>
<td><code>&gt;&gt;=</code></td>
<td>右移赋值</td>
<td><code>x &gt;&gt;= y</code></td>
<td><code>x = x &gt;&gt; y</code></td>
</tr>
<tr>
<td><code>&gt;&gt;&gt;=</code></td>
<td>无符号右移赋值</td>
<td><code>x &gt;&gt;&gt;= y</code></td>
<td><code>x = x &gt;&gt;&gt; y</code></td>
</tr>
<tr>
<td><code>&amp;=</code></td>
<td>按位与赋值</td>
<td><code>x &amp;= y</code></td>
<td><code>x = x &amp; y</code></td>
</tr>
<tr>
<td><code>&#124;=</code></td>
<td>按位或赋值</td>
<td><code>x &#124;= y</code></td>
<td><code>x = x &#124; y</code></td>
</tr>
<tr>
<td><code>^=</code></td>
<td>按位异或赋值</td>
<td><code>x ^= y</code></td>
<td><code>x = x ^ y</code></td>
</tr>
</tbody></table>
<h2 id="7-2-算术运算符"><a href="#7-2-算术运算符" class="headerlink" title="7.2 算术运算符"></a>7.2 算术运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>加法</td>
<td><code>x + y</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td>减法</td>
<td><code>x - y</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘法</td>
<td><code>x * y</code></td>
</tr>
<tr>
<td><code>/</code></td>
<td>除法</td>
<td><code>x / y</code></td>
</tr>
<tr>
<td><code>%</code></td>
<td>求余</td>
<td><code>x % y</code></td>
</tr>
<tr>
<td><code>**</code></td>
<td>幂</td>
<td><code>x ** y</code></td>
</tr>
<tr>
<td><code>++</code></td>
<td>自增</td>
<td><code>x++</code> 或 <code>++x</code></td>
</tr>
<tr>
<td><code>--</code></td>
<td>自减</td>
<td><code>x--</code> 或 <code>--x</code></td>
</tr>
<tr>
<td><code>+</code></td>
<td>一元正号</td>
<td><code>+x</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td>一元负号</td>
<td><code>-x</code></td>
</tr>
</tbody></table>
<h3 id="1-加法"><a href="#1-加法" class="headerlink" title="1 加法"></a>1 加法</h3><ol>
<li>允许非数值的相加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true + true = 2</span><br><span class="line">1 + true = 2</span><br></pre></td></tr></table></figure></li>
<li>遇到字符串会变成连接</li>
<li>对象相加，必须先转成原始类型的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: 1 &#125;;</span><br><span class="line">obj + 2 // &quot;[object Object]2&quot;</span><br><span class="line">// obj.valueOf() 结果为&#123;p:1&#125;</span><br><span class="line">// obj.valueOf().toString() 结果为&quot;[object object]&quot;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 2 一元加号/减号</span><br><span class="line">* 一元加号/减号运算符的作用在于可以将任何值转为数值</span><br></pre></td></tr></table></figure></li>
</ol>
<p>+true // 1<br>+[] // 0<br>+{} // NaN</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3 幂运算符</span><br><span class="line">1. 前一个运算子是底数，后一个运算子是指数</span><br><span class="line">2. 幂运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算。</span><br></pre></td></tr></table></figure>
<p>2 ** 4 // 16 即2的4次方<br>2 ** 3 ** 2// 512 相当于2** (3 ** 2) 即先求3的2次方=9 再求2的9次方</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 7.3 比较运算符</span><br><span class="line">### 1 非相等比较</span><br><span class="line">运算符|名称|运算式</span><br><span class="line">-|-|-</span><br><span class="line">`&gt;`|大于|`x &gt; y`</span><br><span class="line">`&lt;`|小于|`x &lt; y`</span><br><span class="line">`&gt;=`|大于等于|`x &gt;= y`</span><br><span class="line">`&lt;=`|小于等于|`x &lt;= y`</span><br><span class="line">1. 基本类型</span><br><span class="line">	1. 非字符串：先转成数值再比较</span><br><span class="line">	2. 字符串：按照字典顺序比较（实际上是比较 Unicode 码点）</span><br><span class="line">2. 引用类型</span><br><span class="line">	* 先转为基本类型的值，再进行比较</span><br><span class="line"></span><br><span class="line">### 2 相等比较</span><br><span class="line">运算符|名称|运算式</span><br><span class="line">-|-|-</span><br><span class="line">`==`|相等|` x == y`</span><br><span class="line">`===`|严格相等|`x === y`</span><br><span class="line">`!=`|不相等|`x != y`</span><br><span class="line">`!==`|严格不相等|`x !== y`</span><br><span class="line">1. `===`</span><br><span class="line">	1. 先比较类型，类型相同再比较值</span><br><span class="line">	2. 引用类型比较地址值</span><br><span class="line">	3. `NaN`与任何值都不严格相等（包括自己）</span><br><span class="line">	4. `undefined`和`null`与自身严格相等</span><br><span class="line">	5. `+0` 与 `-0` 严格相等 </span><br><span class="line">	6. `!==`</span><br><span class="line">		* 先求`===`的结果，然后返回相反值。</span><br><span class="line">2. `==`</span><br><span class="line">	1. 比较不同类型的数据时，会先将数据进行类型转换，然后再用`===`比较。</span><br><span class="line">	2.  `NaN`与任何值都不相等（包括自己）</span><br><span class="line">	3. `undefined`和`null`与其他类型的值比较时，结果都为false， 它们之间比较为true</span><br><span class="line">	4. `!=`</span><br><span class="line">		* 先求`==`的结果，然后返回相反值。</span><br><span class="line"></span><br><span class="line">## 7.4 逻辑运算符</span><br><span class="line">运算符|名称|运算式|说明</span><br><span class="line">-|-|-|-</span><br><span class="line">`&amp;&amp;`|逻辑与|`expr1 &amp;&amp; expr2`|若`expr1`为true，则返回`expr2`的值，否则，返回`expr1`的值，且不再计算`expr2`</span><br><span class="line">&lt;code&gt;&amp;#124;&amp;#124;&lt;/code&gt;|逻辑或|&lt;code&gt;expr1 &amp;#124;&amp;#124; expr2&lt;/code&gt;|若`expr1`为false，则返回`expr2`的值，否则，返回`expr1`的值，且不再计算`expr2`</span><br><span class="line">`!`|逻辑非|`!expr`|若`expr` 为 true，则返回 `false`，否则，返回`true`</span><br><span class="line">`!!`|双重非|`!!expr`|显式地将任意值强制转换为其对应的布尔值</span><br><span class="line">1. 表达式的布尔值与值不是一个概念，如`1 - 1` 返回的值是0，返回的布尔值是false</span><br><span class="line">2. 逻辑与和逻辑或存在短路计算，即整个表达式的值在第一个表达式计算后已经确定了，就不再计算第二个。</span><br><span class="line">3. 逻辑与的优先级高于逻辑或</span><br><span class="line"></span><br><span class="line">## 7.5 按位运算符</span><br><span class="line">运算符|名称|运算式|说明</span><br><span class="line">-|-|-|-</span><br><span class="line">`&amp;`|按位与|`x &amp; y`|有0则0</span><br><span class="line">&lt;code&gt;&amp;#124;&lt;/code&gt;|按位或|&lt;code&gt;x &amp;#124; y&lt;/code&gt;|有1则1</span><br><span class="line">`~`|按位非|`~x`|1变0，0变1</span><br><span class="line">`^`|按位异或|`x ^ y`|相同则0，不同则1</span><br><span class="line">`&lt;&lt;`|左移|`x &lt;&lt; y`|低位补0，相当于&lt;code&gt;x * 2&lt;sup&gt;y&lt;/sup&gt;&lt;/code&gt;</span><br><span class="line">`&gt;&gt;`|右移|`x &gt;&gt; y`|舍去低位，正数高位补0，负数高位补1，相当于&lt;code&gt;x / 2&lt;sup&gt;y&lt;/sup&gt;&lt;/code&gt;</span><br><span class="line">`&gt;&gt;&gt;`|无符号右移|`x &gt;&gt;&gt; y`|舍去低位，高位补0，相当于&lt;code&gt;x / 2&lt;sup&gt;y&lt;/sup&gt;&lt;/code&gt;</span><br><span class="line"></span><br><span class="line">## 7.6 三元运算符</span><br><span class="line">* `condition ? exprIfTrue : exprIfFalse`</span><br><span class="line">	1. 若`condition` 为true，返回`exprIfTrue`的值，否则，返回`exprIfFalse`的值</span><br><span class="line">	2. 和 `if else` 的区别：if...else是语句，没有返回值；三元运算符是表达式，具有返回值。</span><br><span class="line"></span><br><span class="line">## 7.7 void运算符</span><br><span class="line">* `void expression`</span><br><span class="line">	* 对给定的表达式进行求值，然后返回 undefined</span><br><span class="line">	* void 运算符通常只用于获取 undefined的原始值，一般使用`void(0)`（等同于`void 0`）</span><br><span class="line">* 应用</span><br><span class="line">	1. JavaScript URIs</span><br><span class="line">		* 当url使用`javascript:`协议，点击时，会执行URI中的代码，然后用返回的值替换页面内容，除非返回的值是undefined。</span><br><span class="line">		* void运算符可用于返回undefined。</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0);" target="_blank" rel="noopener">xxx</a> // 不会跳转。<br><a href="#">xxx</a> // 会跳转只是跳向本页面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2. 在箭头函数中避免泄漏</span><br><span class="line">	* 箭头函数标准中，允许在函数体不使用括号来直接返回值。 如果右侧调用了一个原本没有返回值的函数，其返回值改变后，则会导致非预期的副作用</span><br><span class="line">	* 应该使用 void 运算符，来确保返回 undefined</span><br></pre></td></tr></table></figure>
<p>() =&gt; void doSomething();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 7.8 逗号运算符</span><br><span class="line">* `expr1, expr2, expr3...`</span><br><span class="line">	* 从左到右依次计算每个表达式，并返回最后一个表达式的值</span><br></pre></td></tr></table></figure>
<p>‘a’, ‘b’ // “b”<br>var x = 0;<br>var y = (x++, 10);  // x=1 y=10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 八 展开语法(Spread syntax)</span><br><span class="line">## 8.1 概述</span><br><span class="line">1. 展开语法用  `...` 进行表示</span><br><span class="line">2. 展开语法在函数调用或构造字面量数组时, 将**可迭代对象**（如数组, string, ...）在语法层面展开；</span><br><span class="line">3. 展开语法在构造字面量对象时, 将对象表达式按key-value的方式展开</span><br><span class="line"> </span><br><span class="line">## 8.2 应用</span><br><span class="line">### 1 函数调用</span><br></pre></td></tr></table></figure>
<p>function show(x, y, z) { }<br>let args = [0, 1, 2];<br>show(…args); // &lt;=&gt; show(0, 1, 2)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 2 字面量数组</span><br></pre></td></tr></table></figure>
<p>let arr1 = [0, 1, 2];<br>let arr2 = [3, 4, 5];<br>let arr3 = […arr1, …arr2]; // [0,1,2,3,4,5]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3 字面量对象</span><br></pre></td></tr></table></figure>
<p>let obj1 = { foo: ‘bar’, x: 42 };<br>let obj2 = { foo: ‘baz’, y: 13 };<br>let clonedObj = { …obj1 };<br>// 克隆后的对象: { foo: “bar”, x: 42 }<br>let mergedObj = { …obj1, …obj2 };<br>// 合并后的对象: { foo: “baz”, x: 42, y: 13 }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 九 剩余参数</span><br><span class="line">## 9.1 概述</span><br><span class="line">1. 剩余参数是一个数组，用于接收形参外的所有参数</span><br><span class="line">2. 剩余参数必须是最后一个参数</span><br><span class="line"></span><br><span class="line">## 9.2 语法</span><br></pre></td></tr></table></figure>
<p>function(a, b, …theArgs) {<br>    // …<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 9.3 剩余参数和 arguments对象的区别</span><br><span class="line">1. 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。</span><br><span class="line">2. arguments对象不是一个真正的数组，而剩余参数是真正的 Array实例，即剩余参数可以使用所有的数组方法</span><br><span class="line"></span><br><span class="line"># 十 解构赋值</span><br><span class="line">## 10.1 概述</span><br><span class="line">1. 解构赋值：从数组和对象中提取值，对变量进行赋值</span><br><span class="line">2. 解构对象时会查找原型链（如果属性不在对象自身，将从原型链中查找）</span><br><span class="line"></span><br><span class="line">## 10.2 解构数组</span><br><span class="line">1. 先声明后赋值的解构</span><br></pre></td></tr></table></figure>
<p>let a, b;<br>[a, b] = [10, 20]; // a=10 b=20</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 声明并赋值的解构</span><br></pre></td></tr></table></figure>
<p>let [a,b] = [10, 20]; // a=10 b=20</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 默认值</span><br></pre></td></tr></table></figure>
<p>let [a = 3, b = 4] = [1]; // a=1 b=4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4. 变量数量小于值数量时，忽略多余值</span><br></pre></td></tr></table></figure>
<p>let [a, b] = [1, 2, 3, 4]; // a =1 b = 2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5. 可用于交换变量</span><br></pre></td></tr></table></figure>
<p>let a =1;<br>let b = 2;<br>[a, b] = [b, a]; // a=2 b=1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6. 剩余参数</span><br></pre></td></tr></table></figure>
<p>let [a, …b] = [1, 2, 3]; // a=1 b=[2,3]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 10.3 解构对象</span><br><span class="line">1. 基本语法</span><br></pre></td></tr></table></figure>
<p>let {key:变量} = {key:value};</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	* `&#123;key:变量&#125;`</span><br><span class="line">		* 将对象中属性key的值赋值给变量</span><br><span class="line">2. 变量名与属性名相同可以简写</span><br></pre></td></tr></table></figure>
<p>let {key:key} = {key:value};<br>let {key} = {key:value}; // 简写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 先声明后赋值的解构</span><br></pre></td></tr></table></figure>
<p>let name, age;<br>{name,age} =  {name:’an3’, age:18}); // 错误<br>({name, age} = {name:’an3’, age:18}); // name=’an3’ age=18</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">	* 赋值时必须使用()包括，因为左边`&#123;name, age&#125;`会被认为是块而不是对象字面量</span><br><span class="line">4. 默认值</span><br></pre></td></tr></table></figure>
<p>let {name=’haha’, age=10} = {name:’an3’}; // name=’an3’ age=10<br>let {name:n=’haha’ age:a=10} = {name:’an3’}; // n=’an3’ a=10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5. 变量数量小于值数量时，忽略多余值</span><br></pre></td></tr></table></figure>
<p>let {name=’haha’, age=10} = {name:’an3’,age:10,sex:1}; // name=’an3’ age=18</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6. 解构嵌套</span><br></pre></td></tr></table></figure>
<p>let user = {<br>    name:’xiaoming’,<br>    lesson:{<br>        title:’js’,<br>        score:90<br>    }<br>};<br>let {name,lesson:{title,score}} = user;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 十一 语句</span><br><span class="line">## 11.1 &#123;&#125;</span><br><span class="line">* `&#123; StatementList &#125;`</span><br><span class="line">	* 声明块作用域</span><br><span class="line"></span><br><span class="line">## 11.2 if...else</span><br><span class="line">## 11.3 switch</span><br></pre></td></tr></table></figure>
<p>switch (expression) {<br>    case value1:<br>    // 当 expression 的结果与 value1 匹配时，执行此处语句<br>    [break;]<br>    case value2:<br>    // 当 expression 的结果与 value2 匹配时，执行此处语句<br>    [break;]<br>    …<br>    case valueN:<br>    // 当 expression 的结果与 valueN 匹配时，执行此处语句<br>    [break;]<br>    [default:<br>    // 如果 expression 与上面的 value 值都不匹配，执行此处语句<br>    [break;]]<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* switch内部采用严格相等</span><br><span class="line">* 省略break：会继续运行下一个case语句无论值是否匹配</span><br><span class="line"></span><br><span class="line">## 11.4 for</span><br></pre></td></tr></table></figure>
<p>for ([initialization]; [condition]; [final-expression]){<br>    statement<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* for循环每次循环都是一个单独的函数作用域</span><br><span class="line">	1. 在 for 循环中使用let/const 会在每一次循环重新生成不同的变量</span><br><span class="line">	2. 在 for 循环中使用var声明的变量是全局共享的</span><br><span class="line"></span><br><span class="line">## 11.5 while / do...while</span><br><span class="line">## 11.6 label</span><br></pre></td></tr></table></figure>
<p>label :<br>    statement</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* 相当于定位符，用于跳转到程序的任意位置，通常与break语句和continue语句配合使用，break 可用于任何标记语句，而 continue 用于循环标记语句</span><br><span class="line">	* `break [label]` 或 `continue [label]`</span><br><span class="line">* label ：任何不属于保留关键字的 JavaScript 标识符</span><br><span class="line"></span><br><span class="line">## 11.7 in</span><br><span class="line">* `prop in object`</span><br><span class="line">	* 判断对象自身或其原型链上是否包含某个属性</span><br><span class="line"></span><br><span class="line">## 11.8 for...in</span><br></pre></td></tr></table></figure>
<p>for (let/const key in object){<br>    // statements<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 遍历对象</span><br><span class="line">	1. 遍历对象的所有可枚举属性（包括它的原型链上的可枚举属性），属性是否可枚举由属性描述符的`enumerable`决定</span><br><span class="line">	2. 每次循环获取的是属性名</span><br><span class="line">2. 遍历数组（不推荐）</span><br><span class="line">	1. 数组键名是数字，但每次循环获取的是索引的字符串</span><br><span class="line">	2. 除了遍历数组元素外，数组本身以及原型链上的可枚举属性也会被遍历到</span><br><span class="line">	3. 某些情况下，不能保证按顺序返回索引</span><br><span class="line"></span><br><span class="line">## 11.9 for...of</span><br></pre></td></tr></table></figure>
<p>for (let/const value of iterable) {<br>    //statements<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1. 用来遍历可迭代对象（Array，Map，Set，String，TypedArray，arguments对象，DOM NodeList对象，Generator对象...）</span><br><span class="line">2. 每次循环取出的是值</span><br><span class="line"></span><br><span class="line"># 十二 概念</span><br><span class="line">1. 可枚举属性：属性描述符 `enumerable: true` 的属性</span><br><span class="line">2. 普通对象：没有数字键和length属性的对象</span><br><span class="line">3. 类数组对象：存在数值键名和length属性的对象</span><br><span class="line"></span><br><span class="line">## 十三 Iterator</span><br><span class="line">## 13.1 迭代器</span><br><span class="line">* 迭代器就是具有`next()`方法的对象</span><br><span class="line">* `next()` </span><br><span class="line">	* 返回一个对象，返回对象拥有两个属性</span><br><span class="line">		1. `value`：当前迭代的值</span><br><span class="line">		1. `done`：布尔值，迭代是否结束。</span><br><span class="line">			* false表示没结束，`done:false` 可以省略</span><br><span class="line">			* true表示结束，此时value为undefined，`value:undefined` 可以省略</span><br><span class="line"></span><br><span class="line">## 13.2 Iterator 接口</span><br><span class="line">1. 一个数据结构只要具有 `Symbol.iterator` 属性，就认为是实现了Iterator接口</span><br><span class="line">2. 对象（或者其原型链）上拥有 `Symbol.iterator` 属性，就是可迭代对象</span><br><span class="line"></span><br><span class="line">## 13.3 Symbol.iterator</span><br><span class="line">1. `Symbol.iterator` 本身是一个函数，就是当前数据结构默认的迭代器生成函数。执行这个函数，就会返回一个迭代器</span><br><span class="line">2. `Symbol.iterator` 要放在方括号中，因为它作为属性名是一个表达式，返回Symbole对象的iterator属性。</span><br><span class="line"></span><br><span class="line">## 13.4 for... of</span><br><span class="line">1. for... of 内部就是调用了可迭代对象的 `Symbol.iterator` 生成了迭代器</span><br><span class="line">2. 自定义for... of</span><br></pre></td></tr></table></figure>
<p>function myForOf(arr) {<br>    let it = arr<a href="">Symbol.iterator</a>;<br>    let res = it.next();<br>    while(!res.done) {<br>        console.log(res.value);<br>        res = it.next();<br>    }<br>}</p>
<p>```</p>
<h1 id="十四-全局函数"><a href="#十四-全局函数" class="headerlink" title="十四 全局函数"></a>十四 全局函数</h1><ol>
<li><code>encodeURI(URI)</code><ul>
<li>使用UTF-8进行URL编码，编码后的格式为UTF-8编码的每个字节前加<code>%</code></li>
<li>不会编码的字符<ol>
<li><code>; , / ? : @ &amp; = + $</code></li>
<li><code>字母 数字 - _ . ! ~ * &#39; ( )</code></li>
<li><code>#</code></li>
</ol>
</li>
</ul>
</li>
<li><code>decodeURI(encodedURI)</code><ul>
<li><code>encodeURI()</code>对应的解码函数</li>
</ul>
</li>
<li><code>encodeURIComponent(str)</code><ul>
<li>类似<code>encodeURI()</code>，区别在于不会编码的字符。</li>
<li>不会编码的字符<ul>
<li><code>字母 数字 - _ . ! ~ * &#39; ( )</code></li>
</ul>
</li>
</ul>
</li>
<li><code>decodeURIComponent(encodedURI)</code><ul>
<li><code>encodeURIComponent()</code>对应的解码函数</li>
</ul>
</li>
<li><code>isFinite(value)</code><ul>
<li>见 <code>Number.isFinite(value)</code></li>
</ul>
</li>
<li><code>isNaN(value)</code><ul>
<li>见 <code>Number.isNaN(value)</code></li>
</ul>
</li>
<li><code>parseInt(string[, radix])</code><ul>
<li>见 <code>Number.parseInt(string[, radix])</code></li>
</ul>
</li>
<li><code>parseFloat(string)</code><ul>
<li>见 <code>Number.parseFloat(string)</code></li>
</ul>
</li>
<li><code>eval(string)</code>（永远不要使用!）<ul>
<li>将传入的字符串当做 JavaScript 代码进行执行</li>
<li><code>string</code><ol>
<li>如果是表达式，则对表达式进行求值</li>
<li>如果是一个或多个 JavaScript 语句，则执行这些语句</li>
</ol>
</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/03/30/Javascript-%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/03/30/Javascript-%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">Javascript 概述</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-03-30 22:01:05 / 修改时间：22:01:39" itemprop="dateCreated datePublished" datetime="2020-03-30T22:01:05+08:00">2020-03-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/UI/" itemprop="url" rel="index">
                    <span itemprop="name">UI</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/UI/Javascript/" itemprop="url" rel="index">
                    <span itemprop="name">Javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ol>
<li>跨平台的解释性脚本语言 </li>
<li>ECMAScript是规范，JavaScript是实现</li>
</ol>
<h2 id="1-2-组成"><a href="#1-2-组成" class="headerlink" title="1.2 组成"></a>1.2 组成</h2><ol>
<li>ECMAScript<ul>
<li>根据MCMA-262标准，实现的通用脚本语言规范</li>
</ul>
</li>
<li>DOM<ul>
<li><code>document object model</code></li>
<li>文档对象模型</li>
</ul>
</li>
<li>BOM<ul>
<li><code>browser object moel</code></li>
<li>浏览器对象模型</li>
</ul>
</li>
</ol>
<h2 id="1-3-JavaScript处理引擎"><a href="#1-3-JavaScript处理引擎" class="headerlink" title="1.3 JavaScript处理引擎"></a>1.3 JavaScript处理引擎</h2><ul>
<li>专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器之中</li>
<li>主要浏览器引擎<ol>
<li><code>chrome v8</code></li>
<li><code>firefox SpiderMonkey</code></li>
<li><code>edge chakra</code></li>
<li><code>Opera Carakan</code></li>
<li>……</li>
</ol>
</li>
</ul>
<h2 id="1-4-网页加载流程-前端"><a href="#1-4-网页加载流程-前端" class="headerlink" title="1.4 网页加载流程 - 前端"></a>1.4 网页加载流程 - 前端</h2><ol>
<li>浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。</li>
<li>css 和 html 是并行加载的，过程中如果遇到css 或者 img，则会向浏览器返回一个请求，待资源返回后，将其添加到dom的相应位置中</li>
<li>解析过程中，浏览器发现<code>&lt;script&gt;</code>元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎（原因是 JavaScript 代码可以修改 DOM，所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题。）</li>
<li>如果<code>&lt;script&gt;</code>元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</li>
<li>JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页</li>
</ol>
<h1 id="二-引入JavaScript脚本"><a href="#二-引入JavaScript脚本" class="headerlink" title="二  引入JavaScript脚本"></a>二  引入JavaScript脚本</h1><h2 id="2-1-JavaScript脚本位置"><a href="#2-1-JavaScript脚本位置" class="headerlink" title="2.1 JavaScript脚本位置"></a>2.1 JavaScript脚本位置</h2><ol>
<li>浏览器加载 JavaScript 脚本，主要通过<code>&lt;script&gt;</code>元素完成</li>
<li>如果外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。所以<code>&lt;script&gt;</code> 最好放在页面底部<ol>
<li>即使遇到脚本失去响应，网页主体的渲染也已经完成了，用户至少可以看到内容</li>
<li>在 DOM 结构生成之前就调用 DOM 节点，JavaScript 会报错，如果脚本都在网页尾部加载，就不存在这个问题，因为这时 DOM 肯定已经生成了。</li>
</ol>
</li>
</ol>
<h2 id="2-2-javascript-协议"><a href="#2-2-javascript-协议" class="headerlink" title="2.2 javascript: 协议"></a>2.2 <code>javascript:</code> 协议</h2><ul>
<li>URL 支持<code>javascript:</code>协议，即在 URL 的位置写入代码，使用这个 URL 的时候就会执行 JavaScript 代码。</li>
</ul>
<h2 id="2-3-JavaScript-脚本引入方式"><a href="#2-3-JavaScript-脚本引入方式" class="headerlink" title="2.3 JavaScript 脚本引入方式"></a>2.3 JavaScript 脚本引入方式</h2><h3 id="1-内联脚本"><a href="#1-内联脚本" class="headerlink" title="1 内联脚本"></a>1 内联脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;alert(&apos;xxx&apos;)&quot;&gt;第一种直接写方法体&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;button onclick=&quot;fn()&quot;&gt;第二种传递方法&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	function fn() &#123;</span><br><span class="line">		alert(&apos;xxx&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-内部脚本"><a href="#2-内部脚本" class="headerlink" title="2 内部脚本"></a>2 内部脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;button&gt;点我&lt;/button&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">	document.querySelector(&apos;button&apos;).addEventListener(&apos;click&apos;,() =&gt; alert(&apos;xxx&apos;));</span><br><span class="line">&lt;script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>type可以省略 默认<code>text/javascript</code>，新的浏览器可以写<code>application/javascript</code></li>
</ul>
<h3 id="3-外部脚本"><a href="#3-外部脚本" class="headerlink" title="3 外部脚本"></a>3 外部脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;xxx.js&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>标签体不能有内容，<code>&lt;/script&gt;</code>不能省略</li>
<li><code>src</code> 默认是http协议</li>
<li>外部的js文件中不能包含<code>&lt;script&gt;</code>标签。</li>
</ol>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/anyeansan.github.io/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/anyeansan.github.io/page/6/">6</a><a class="extend next" rel="next" href="/anyeansan.github.io/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          秘笈
        </li>
        <li class="sidebar-nav-overview">
          安₃
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="安₃"
      src="/anyeansan.github.io/images/an3.png">
  <p class="site-author-name" itemprop="name">安₃</p>
  <div class="site-description" itemprop="description">一蓑烟雨任平生</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/anyeansan.github.io/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">书斋</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/anyeansan.github.io/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">门派</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/anyeansan.github.io/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-star-half-full"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">安₃</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/anyeansan.github.io/lib/anime.min.js"></script>
  <script src="/anyeansan.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/anyeansan.github.io/lib/velocity/velocity.ui.min.js"></script>
<script src="/anyeansan.github.io/js/utils.js"></script><script src="/anyeansan.github.io/js/motion.js"></script>
<script src="/anyeansan.github.io/js/schemes/pisces.js"></script>
<script src="/anyeansan.github.io/js/next-boot.js"></script>



  




  <script src="/anyeansan.github.io/js/local-search.js"></script>













  

  

</body>
</html>
