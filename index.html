<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/anyeansan.github.io/images/an-apple-180.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/anyeansan.github.io/images/an-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/anyeansan.github.io/images/an-16.png">
  <link rel="mask-icon" href="/anyeansan.github.io/images/an.svg" color="#222">
  <link rel="alternate" href="/anyeansan.github.io/atom.xml" title="安₃" type="application/atom+xml">

<link rel="stylesheet" href="/anyeansan.github.io/css/main.css">


<link rel="stylesheet" href="/anyeansan.github.io/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/anyeansan.github.io/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"hide","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="一蓑烟雨任平生">
<meta property="og:type" content="website">
<meta property="og:title" content="安₃">
<meta property="og:url" content="https:&#x2F;&#x2F;anyeansan.github.io&#x2F;">
<meta property="og:site_name" content="安₃">
<meta property="og:description" content="一蓑烟雨任平生">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://anyeansan.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>安₃</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/anyeansan.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">安₃</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">我未成名君未嫁 可能俱是不如人</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/anyeansan.github.io/" rel="section"><i class="fa fa-fw fa-home"></i>安府</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/anyeansan.github.io/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>琅嬛福地</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/anyeansan.github.io/categories/" rel="section"><i class="fa fa-fw fa-th"></i>门派</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/anyeansan" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/09/29/Java/Java-%E6%97%A5%E5%BF%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/09/29/Java/Java-%E6%97%A5%E5%BF%97/" class="post-title-link" itemprop="url">Java-日志</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-09-29 16:04:53 / 修改时间：16:05:08" itemprop="dateCreated datePublished" datetime="2020-09-29T16:04:53+08:00">2020-09-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li><p>日志门面（接口）：</p>
<ol>
<li><code>JCL（jakarta commons logging）</code></li>
<li><code>slf4j（simple logging facade for java）</code> </li>
</ol>
</li>
<li><p>日志实现</p>
<ol>
<li><code>JUL（Java util Logging）</code></li>
<li><code>logback</code></li>
<li><code>log4j</code></li>
<li><code>log4j2</code></li>
</ol>
</li>
</ol>
<h1 id="二-日志门面"><a href="#二-日志门面" class="headerlink" title="二 日志门面"></a>二 日志门面</h1><h2 id="2-1-JCL"><a href="#2-1-JCL" class="headerlink" title="2.1 JCL"></a>2.1 <code>JCL</code></h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>Jakarta Commons Logging</code></li>
<li>包： <code>commons-looging.jar</code></li>
<li>Apache 提供的一个通用日志接口，它是为 “所有的 Java 日志实现”提供一个统一的接口，它自身也提供一个日志的实现 <code>SimpleLog</code>，但是功能非常弱</li>
<li>通过动态查找的机制，在程序运行时自动找出真正使用的日志库，如果未提供任何第三方实现，则默认使用 <code>JUL</code></li>
</ol>
<h3 id="2-API"><a href="#2-API" class="headerlink" title="2 API"></a>2 API</h3><ol>
<li><code>Log</code>：日志记录器</li>
<li><code>LogFactory</code>：负责创建 <code>Log</code></li>
</ol>
<h2 id="2-2-slf4j"><a href="#2-2-slf4j" class="headerlink" title="2.2 slf4j"></a>2.2 <code>slf4j</code></h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><p><code>Simple Logging Facade For Java</code></p>
</li>
<li><p>SLF4J 主要是为了给 Java 日志访问提供一套标准、规范的 API 框架，其主要意义在于提供接口，具体的实现可以交由其他日志框架</p>
</li>
<li><p>slf4j 内置一个简单的日志实现 <code>slf4j-simple</code> ，不过很少使用</p>
</li>
<li><p>通常 slf4j 作为门面，配上具体的实现框架，中接使用桥接器完成桥接</p>
</li>
<li><p>主要功能：</p>
<ol>
<li>日志框架的绑定</li>
<li>日志框架的桥接</li>
</ol>
</li>
<li><p><code>slf4j-api.jar</code> 核心 API 包</p>
</li>
<li><p>日志级别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-绑定日志实现"><a href="#2-绑定日志实现" class="headerlink" title="2 绑定日志实现"></a>2 绑定日志实现</h3><h4 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1 步骤"></a>1 步骤</h4><ol>
<li>添加 slf4j 的依赖包 <code>slf4j-api.jar</code></li>
<li>绑定具体的日志实现框架<ol>
<li>已经实现 slf4j 的日志框架，如 <code>logback</code>，直接添加其依赖即可</li>
<li>没有实现 slf4j 的日志框架，如 <code>JUL log4j log4j2</code>，除了日志框架的依赖包外，还需要适配器（包）</li>
</ol>
</li>
<li>如果绑定了多个实现，默认使用第一个</li>
</ol>
<h4 id="2-包"><a href="#2-包" class="headerlink" title="2 包"></a>2 包</h4><h5 id="1-slf4j-JUL"><a href="#1-slf4j-JUL" class="headerlink" title="1 slf4j + JUL"></a>1 slf4j + JUL</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slf4j-api.jar</span><br><span class="line">slf4j-jdk14.jar</span><br></pre></td></tr></table></figure>

<h5 id="2-slf4j-log4j"><a href="#2-slf4j-log4j" class="headerlink" title="2 slf4j + log4j"></a>2 slf4j + log4j</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slf4j-api.jar</span><br><span class="line">log4j.jar</span><br><span class="line">slf4j-log4j12.jar</span><br></pre></td></tr></table></figure>

<h5 id="3-slf4j-log4j2"><a href="#3-slf4j-log4j2" class="headerlink" title="3 slf4j + log4j2"></a>3 slf4j + log4j2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slf4j-api.jar</span><br><span class="line">log4j-api.jar</span><br><span class="line">log4j-core.jar</span><br><span class="line">log4j-slf4j-impl.jar</span><br></pre></td></tr></table></figure>

<h5 id="4-slf4j-logback"><a href="#4-slf4j-logback" class="headerlink" title="4 slf4j + logback"></a>4 slf4j + logback</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slf4j-api.jar</span><br><span class="line">logback-core.jar</span><br><span class="line">logback-classic.jar</span><br></pre></td></tr></table></figure>

<h3 id="3-桥接旧的日志框架"><a href="#3-桥接旧的日志框架" class="headerlink" title="3 桥接旧的日志框架"></a>3 桥接旧的日志框架</h3><h4 id="1-步骤-1"><a href="#1-步骤-1" class="headerlink" title="1 步骤"></a>1 步骤</h4><ol>
<li>去除旧的日志依赖</li>
<li>配置桥接器（包）</li>
<li>绑定新的日志实现</li>
</ol>
<h4 id="2-桥接器"><a href="#2-桥接器" class="headerlink" title="2 桥接器"></a>2 桥接器</h4><ol>
<li><code>jul-to-slf4j.jar</code><ul>
<li>将 JUL 的日志桥接到 slf4j ，即不再使用 JUL，而使用新的日志实现</li>
</ul>
</li>
<li><code>log4j-over-slf4j.jar</code><ul>
<li>将 log4j 的日志桥接到 slf4j</li>
</ul>
</li>
<li><code>jcl-over-slf4j.jar</code><ul>
<li>将 JCL 的日志桥接到 slf4j</li>
</ul>
</li>
</ol>
<h3 id="4-API"><a href="#4-API" class="headerlink" title="4 API"></a>4 API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Logger LoggerFactory.getLogger(字节码文件)</span><br><span class="line">Logger LoggerFactory.getLogger(全限定类名)</span><br></pre></td></tr></table></figure>

<h1 id="三-日志实现"><a href="#三-日志实现" class="headerlink" title="三 日志实现"></a>三 日志实现</h1><h2 id="3-1-log4j2"><a href="#3-1-log4j2" class="headerlink" title="3.1 log4j2"></a>3.1 <code>log4j2</code></h2><h3 id="1-配置"><a href="#1-配置" class="headerlink" title="1 配置"></a>1 配置</h3><ul>
<li>默认加载类路径下 <code>log4j2.xml</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	日志级别： </span></span><br><span class="line"><span class="comment">		OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL</span></span><br><span class="line"><span class="comment">    日期格式：</span></span><br><span class="line"><span class="comment">        %d 输出的时间</span></span><br><span class="line"><span class="comment">        %t 输出当前线程名称</span></span><br><span class="line"><span class="comment">        %F 输出所在的类文件名</span></span><br><span class="line"><span class="comment">        %L 输出行号</span></span><br><span class="line"><span class="comment">        %M 输出所在方法名</span></span><br><span class="line"><span class="comment">        %n 换行</span></span><br><span class="line"><span class="comment">        %-5level 输出日志级别，-5表示左对齐并且固定输出5个字符，如果不足在右边补0</span></span><br><span class="line"><span class="comment">        %logger 输出logger名称，Root Logger没有名称</span></span><br><span class="line"><span class="comment">        %l 输出语句所在的行数, 包括类名、方法名、文件名、行数</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">status：设置log4j2自身内部的信息输出，可以不设置</span></span><br><span class="line"><span class="comment">monitorInterval：指定每隔多久重新读取配置文件，可以不重启应用的情况下修改配置</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span> <span class="attr">monitorInterval</span>=<span class="string">"30"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1 定义属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 2 配置 appender--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 2.1 console--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!--输出日志格式--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 2.2 file--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">fileName</span>=<span class="string">"文件路径"</span> <span class="attr">append</span>=<span class="string">"是否追加"</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!--输出日志格式--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 2.3 rollingFile--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">fileName</span>=<span class="string">""</span> <span class="attr">filePattern</span>=<span class="string">"指定当发生Rolling时，文件的转移和重命名规则"</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!--输出日志格式--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 过滤器--&gt;</span>      </span><br><span class="line">			<span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">""</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 日志拆分规则--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">            	<span class="comment">&lt;!-- 系统启动就触发拆分规则，产生一个新的日志文件--&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">OnStartupTriggeringPolicy</span>/&gt;</span></span><br><span class="line">            	<span class="comment">&lt;!-- 按照时间节点拆分，根据 filePattern 的配置，如最小时间粒度是HH，则表示每小时产生一个新的日志文件--&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- 按照文件大小拆分，超过大小就产生一个新的--&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!--同一目录最多保存的文件个数，超过则覆盖--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 3 logger 只有定义了logger并引入的appender，appender才会生效--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--3.1 root--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!--3.2 自定义 logger--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">level</span>=<span class="string">""</span> <span class="attr">additivity</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-异步日志"><a href="#2-异步日志" class="headerlink" title="2 异步日志"></a>2 异步日志</h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>异步日志需要添加依赖 <code>com.lmax.disruptor</code></li>
<li>有两种实现方式<ol>
<li><code>AsyncLogger</code>（官方推荐）：全局+混合</li>
<li><code>AsyncAppender</code></li>
</ol>
</li>
<li>注意三种方式不要同时使用</li>
</ol>
<h4 id="2-AsyncLogger"><a href="#2-AsyncLogger" class="headerlink" title="2 AsyncLogger"></a>2 <code>AsyncLogger</code></h4><h5 id="1-全局异步"><a href="#1-全局异步" class="headerlink" title="1 全局异步"></a>1 全局异步</h5><ol>
<li><p>所有的日志都异步的记录，在配置文件上不用做任何改动，只需要添加一个 <code>log4j2.component.properties</code> 配置</p>
</li>
<li><p><code>log4j2.component.properties</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Log4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="2-混合异步"><a href="#2-混合异步" class="headerlink" title="2 混合异步"></a>2 混合异步</h5><ol>
<li><p>同时使用同步日志和异步日志，通过配置指定哪些同步哪些异步</p>
</li>
<li><p>配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">		自定义异步 logger</span></span><br><span class="line"><span class="comment">		includeLocation：是否包含日志记录的行号信息，要关闭</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">AsyncLogger</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">level</span>=<span class="string">""</span> <span class="attr">includeLocation</span>=<span class="string">"false"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">AsyncLogger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="3-AsyncAppender"><a href="#3-AsyncAppender" class="headerlink" title="3 AsyncAppender"></a>3 <code>AsyncAppender</code></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 定义异步 appender ，之后引入 logger 即可</span><br><span class="line"><span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Async</span> <span class="attr">name</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Async</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-logback"><a href="#3-2-logback" class="headerlink" title="3.2 logback"></a>3.2 <code>logback</code></h2><h3 id="1-模块"><a href="#1-模块" class="headerlink" title="1 模块"></a>1 模块</h3><ol>
<li><code>logback-core</code>：其它两个模块的基础模块</li>
<li><code>logback-classic</code>：它是 log4j 的一个改良版本，同时它完整实现了slf4j API</li>
<li><code>logback-access</code>：访问模块与 Servlet 容器集成提供通过 Http 来访问日志的功能</li>
</ol>
<h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2 配置"></a>2 配置</h3><h4 id="1-依次读取"><a href="#1-依次读取" class="headerlink" title="1 依次读取"></a>1 依次读取</h4><ol>
<li><code>logback.groovy</code></li>
<li><code>logback-test.xml</code></li>
<li><code>logback.xml</code></li>
</ol>
<h4 id="2-详解"><a href="#2-详解" class="headerlink" title="2 详解"></a>2 详解</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 1 配置集中管理属性，获取value语法 $&#123;name&#125; --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 2 Appdender 配置 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 2.1 console --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--输出流对象 默认 System.out--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">target</span>&gt;</span><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--日志输出格式--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">pattern</span>&gt;</span><span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span>	</span><br><span class="line">	<span class="comment">&lt;!-- 2.2 file --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.FileAppender"</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--日志输出路径--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">file</span>&gt;</span><span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--日志输出格式--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">pattern</span>&gt;</span><span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">&lt;!-- 2.3 htmlFile --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.FileAppender"</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--日志输出路径--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">file</span>&gt;</span><span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--日志输出格式--&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.encoder.LayoutWrappingEncoder"</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.html.HTMLLayout"</span>&gt;</span></span><br><span class="line">    			<span class="tag">&lt;<span class="name">pattern</span>&gt;</span><span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">&lt;!-- 2.4 rollingFile --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--日志输出路径--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">file</span>&gt;</span><span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--日志输出格式--&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">pattern</span>&gt;</span><span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--指定日志文件拆分和压缩规则--&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">    		<span class="comment">&lt;!--按照时间和压缩格式声明拆分的文件名--&gt;</span></span><br><span class="line">   		 	<span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span><span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">    		<span class="comment">&lt;!--按照文件大小拆分--&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span><span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--日志级别过滤器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">      		<span class="comment">&lt;!--过滤规则--&gt;</span></span><br><span class="line">      		<span class="tag">&lt;<span class="name">level</span>&gt;</span><span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">      		// 超过指定级别放行还是拦截</span><br><span class="line">      		<span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">      		// 低于指定级别放行还是拦截</span><br><span class="line">      		<span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 2.5 异步 async --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.AsyncAppender"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 3 root Logger 配置--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"默认debug"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"console"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--4 自定义 logger --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.itheima"</span> <span class="attr">level</span>=<span class="string">"debug"</span> <span class="attr">additivity</span>=<span class="string">"是否继承rootLogger，默认true"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-JUL"><a href="#3-3-JUL" class="headerlink" title="3.3 JUL"></a>3.3 <code>JUL</code></h2><h3 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>Java util Logging</code></li>
<li>是 Java 原生的日志框架，使用时不需要另外引用第三方类库</li>
<li>配置文件：<code>$JAVA_HOME\conf\logging.properties</code></li>
<li>所在包：<code>java.util.logging</code> </li>
</ol>
<h3 id="2-架构"><a href="#2-架构" class="headerlink" title="2 架构"></a>2 架构</h3><table>
<thead>
<tr>
<th>对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Logger</code></td>
<td>日志记录器，程序通过此对象的 API 来发布日志，每个 <code>Logger</code> 可以关联多个 <code>Appender / Handler</code></td>
</tr>
<tr>
<td><code>Appender / Handler</code></td>
<td>日志处理器，决定日志记录的位置，如 控制台、文件…</td>
</tr>
<tr>
<td><code>Layout / Formatter</code></td>
<td>负责日志记录的数据转换和格式化</td>
</tr>
<tr>
<td><code>Level</code></td>
<td>日志级别</td>
</tr>
</tbody></table>
<h3 id="2-API-1"><a href="#2-API-1" class="headerlink" title="2 API"></a>2 API</h3><h4 id="1-Logger"><a href="#1-Logger" class="headerlink" title="1 Logger"></a>1 Logger</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Logger</code></td>
<td><code>getLogger(String name)</code></td>
<td>获取或创建 <code>Logger</code> 对象</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>log(Level, String msg)</code></td>
<td>输出指定级别的信息</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>info(String msg)</code></td>
<td>输出指定级别的信息，还有其它级别方法</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addHandler(Handler handler)</code></td>
<td>关联 <code>Handler</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setUseParentHandlers(Boolean useParentHandlers)</code></td>
<td>是否会输出到父 <code>Logger</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setLevel(Level newLevel)</code></td>
<td>设置日志级别</td>
</tr>
</tbody></table>
<ol>
<li><code>Logger</code> 之间存在父子关系，根据名称会自动继承，如 <code>com.cn.an 和 com.cn 和 com</code></li>
<li>最顶层是一个 <code>RootLogger</code></li>
<li>子 <code>Logger</code> 输出会同时传递给父 <code>Logger</code> 输出</li>
</ol>
<h4 id="2-Lever"><a href="#2-Lever" class="headerlink" title="2 Lever"></a>2 Lever</h4><table>
<thead>
<tr>
<th>静态属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ALL</code></td>
<td>启用所有级别信息</td>
</tr>
<tr>
<td><code>OFF</code></td>
<td>关闭日志</td>
</tr>
<tr>
<td><code>SEVERE</code></td>
<td>错误</td>
</tr>
<tr>
<td><code>WARNING</code></td>
<td>警告</td>
</tr>
<tr>
<td><code>INFO</code>（默认）</td>
<td>信息</td>
</tr>
<tr>
<td><code>CONFIG</code></td>
<td>配置</td>
</tr>
<tr>
<td><code>FINE FINER FINEST</code></td>
<td>debug <code>详细 较详细 非常详细</code></td>
</tr>
</tbody></table>
<h4 id="3-Handler"><a href="#3-Handler" class="headerlink" title="3 Handler"></a>3 Handler</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>setLevel(Level newLevel)</code></td>
<td>设置日志级别</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setForMatter(Formater newFormatter)</code></td>
<td>关联  <code>Formatter</code></td>
</tr>
</tbody></table>
<h2 id="3-4-Log4j"><a href="#3-4-Log4j" class="headerlink" title="3.4 Log4j"></a>3.4 <code>Log4j</code></h2><h3 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1 配置文件"></a>1 配置文件</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定日志级别和使用的输出端appender：console为自定义名称</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">INFO,console</span></span><br><span class="line"><span class="comment"># 控制台输出配置</span></span><br><span class="line"><span class="meta">log4j.appender.console</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="string">%d [%t] %-5p [%c] - %m%n</span></span><br></pre></td></tr></table></figure>

<ol>
<li>名称：<code>log4j.properties</code></li>
<li>将配置文件放在类路径下，会自动读取</li>
</ol>
<h3 id="2-组件"><a href="#2-组件" class="headerlink" title="2 组件"></a>2 组件</h3><h4 id="1-Looger"><a href="#1-Looger" class="headerlink" title="1 Looger"></a>1 Looger</h4><ol>
<li>Log4j 有一个根 <code>Logger</code>：<code>root</code></li>
<li>其它所有的 <code>Logger</code> 都会直接或间接继承 <code>root</code></li>
</ol>
<h4 id="2-Appender"><a href="#2-Appender" class="headerlink" title="2 Appender"></a>2 Appender</h4><ol>
<li><code>ConsoleAppender</code></li>
<li><code>FileAppender</code></li>
<li><code>DailyRollingFileAppender</code></li>
<li><code>RollingFileAppender</code></li>
<li><code>JDBCAppender</code></li>
</ol>
<h4 id="3-Layout"><a href="#3-Layout" class="headerlink" title="3 Layout"></a>3 Layout</h4><ol>
<li><code>HTMLLayout</code></li>
<li><code>SimpleLayout</code></li>
<li><code>PatternLayout</code></li>
</ol>
<ul>
<li><h1 id="配置文件log4j2-xml"><a href="#配置文件log4j2-xml" class="headerlink" title="配置文件log4j2.xml"></a><strong>配置文件<code>log4j2.xml</code></strong></h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span> <span class="attr">monitorInterval</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n"</span> /&gt;</span></span><br><span class="line">        	<span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">   	 <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span> /&gt;</span></span><br><span class="line">        	<span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>log4j2默认会在classpath目录下寻找log4j.json、log4j.jsn、log4j2.xml等名称的文件，如果都没有找到，则会按默认配置输出，也就是输出到控制台。</li>
<li><code>status</code><ul>
<li>表示log4j2本身的日志信息打印级别</li>
<li>用于设置log4j2自身内部的信息输出,可以不设置,当设置成trace时,会看到log4j2内部各种详细输出</li>
</ul>
</li>
<li><code>monitorInterval</code><ul>
<li>Log4j能够自动检测修改配置文件和重新配置本身, 设置间隔秒数。</li>
</ul>
</li>
<li><code>Appender</code><ul>
<li>定义日志的输出目的地</li>
<li><code>Console</code><ul>
<li>定义输出到控制台的Appender</li>
<li><code>name</code><ul>
<li>指定Appender的名字</li>
</ul>
</li>
<li><code>target</code><ul>
<li>SYSTEM_OUT 或 SYSTEM_ERR,一般只设置默认:SYSTEM_OUT.</li>
</ul>
</li>
<li><code>PatternLayout</code><ul>
<li>输出格式，不设置默认为:%m%n.</li>
</ul>
</li>
</ul>
</li>
<li><code>File</code><ul>
<li>定义输出到指定位置的文件的Appender</li>
<li><code>name</code><ul>
<li>指定Appender的名字</li>
</ul>
</li>
<li><code>fileName</code><ul>
<li>指定输出日志的目的文件带全路径的文件名</li>
</ul>
</li>
<li><code>PatternLayout</code><ul>
<li>输出格式，不设置默认为:%m%n.</li>
</ul>
</li>
</ul>
</li>
<li><code>RollingFile</code><ul>
<li>定义超过指定大小自动删除旧的创建新的的Appender.</li>
<li><code>name</code><ul>
<li>指定Appender的名字</li>
</ul>
</li>
<li><code>fileName</code><ul>
<li>指定输出日志的目的文件带全路径的文件名</li>
</ul>
</li>
<li><code>PatternLayout</code><ul>
<li>输出格式，不设置默认为:%m%n.</li>
</ul>
</li>
<li><code>filePattern</code><ul>
<li>指定新建日志文件的名称格式.</li>
</ul>
</li>
<li><code>Policies</code><ul>
<li>指定滚动日志的策略，就是什么时候进行新建日志文件输出日志</li>
<li><code>TimeBasedTriggeringPolicy</code><ul>
<li>基于时间的滚动策略</li>
<li><code>interval</code><ul>
<li>指定多久滚动一次，默认是1 hour</li>
</ul>
</li>
<li><code>modulate</code><ul>
<li>=true用来调整时间</li>
<li>比如现在是早上3am，interval是4，那么第一次滚动是在4am，接着是8am，12am…而不是7am</li>
</ul>
</li>
</ul>
</li>
<li><code>SizeBasedTriggeringPolicy</code><ul>
<li>基于指定文件大小的滚动策略</li>
<li><code>size</code><ul>
<li>定义每个日志文件的大小</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>DefaultRolloverStrategy</code><ul>
<li>指定同一个文件夹下最多有几个日志文件时开始删除最旧的，创建新的</li>
<li><code>max</code><ul>
<li>配置最多日志文件数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>Loggers</code><ul>
<li><code>Root</code><ul>
<li>指定项目的根日志，如果没有单独指定Logger，那么就会默认使用该Root日志输出</li>
<li><code>level</code><ul>
<li>日志输出级别，共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF</li>
</ul>
</li>
<li><code>AppenderRef</code><ul>
<li>指定该日志输出到哪个Appender</li>
</ul>
</li>
</ul>
</li>
<li><code>Logger</code><ul>
<li>单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等</li>
<li><code>level</code></li>
<li><code>name</code><ul>
<li>指定该Logger所适用的类或者类所在的包全路径,继承自Root节点</li>
</ul>
</li>
<li><code>AppenderRef</code><ul>
<li>指定该日志输出到哪个Appender,如果没有指定，就会默认继承自Root.如果指定了，那么会在指定的这个Appender和Root的Appender中都会输出。<ul>
<li>若设置Logger的additivity=”false”只在自定义的Appender中进行输出。        </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/09/29/Java/Java-%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/09/29/Java/Java-%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F/" class="post-title-link" itemprop="url">Java-时间日期</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-09-29 16:04:17 / 修改时间：16:04:27" itemprop="dateCreated datePublished" datetime="2020-09-29T16:04:17+08:00">2020-09-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-JDK8-之前的日期时间"><a href="#一-JDK8-之前的日期时间" class="headerlink" title="一 JDK8 之前的日期时间"></a>一 JDK8 之前的日期时间</h1><h2 id="1-1-java-util-Date"><a href="#1-1-java-util-Date" class="headerlink" title="1.1 java.util.Date"></a>1.1 <code>java.util.Date</code></h2><h3 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1 构造方法"></a>1 构造方法</h3><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Date()</code></td>
<td>当前时间，使用的是当前时间到 <code>1970-01-01 00:00:00</code> 的毫秒值创建</td>
</tr>
<tr>
<td><code>Date​(long date)</code></td>
<td>使用指定毫秒值</td>
</tr>
</tbody></table>
<h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2 方法"></a>2 方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>long getTime()</code></td>
<td>获取 <code>1970-01-01 00:00:00</code> 到此时间的毫秒值</td>
</tr>
</tbody></table>
<h2 id="1-2-java-util-Calendar"><a href="#1-2-java-util-Calendar" class="headerlink" title="1.2 java.util.Calendar"></a>1.2 <code>java.util.Calendar</code></h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>Calendar</code> 类是一个抽象类，提供了很多关于日期时间计算的方法</li>
<li><code>GregorianCalendar</code>（公历）是 <code>Calendar</code> 的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统</li>
</ol>
<h3 id="2-方法-1"><a href="#2-方法-1" class="headerlink" title="2 方法"></a>2 方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Calendar getInstance()</code></td>
<td>使用默认时区和语言环境获得一个日历</td>
</tr>
<tr>
<td><code>static Calendar getInstance​(TimeZone zone, Locale aLocale)</code></td>
<td>使用指定时区和语言环境获得一个日历</td>
</tr>
</tbody></table>
<h2 id="1-3-java-text-SimpleDateFormat"><a href="#1-3-java-text-SimpleDateFormat" class="headerlink" title="1.3 java.text.SimpleDateFormat"></a>1.3 <code>java.text.SimpleDateFormat</code></h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>SimpleDateFormat​(String pattern)</code></td>
<td>指定格式创建对象</td>
</tr>
<tr>
<td><code>String format​(Date date)</code></td>
<td>日期 → 字符串</td>
</tr>
<tr>
<td><code>Date parse​(String source)</code></td>
<td>字符串 → 日期</td>
</tr>
</tbody></table>
<h1 id="二-JDK8-的日期时间"><a href="#二-JDK8-的日期时间" class="headerlink" title="二 JDK8 的日期时间"></a>二 JDK8 的日期时间</h1><table>
<thead>
<tr>
<th>包</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>java.time</code></td>
<td>基础包，使用标准的 <code>iso-8601</code> 历法（公历）</td>
</tr>
<tr>
<td><code>java.time.format</code></td>
<td>格式化和解析日期时间</td>
</tr>
<tr>
<td><code>java.time.temporal</code></td>
<td>包括底层框架和扩展特性</td>
</tr>
<tr>
<td><code>java.time.chrono</code></td>
<td>提供对不同的日历系统的访问</td>
</tr>
<tr>
<td><code>java.time.zone</code></td>
<td>包含支持不同时区以及相关规定的类</td>
</tr>
</tbody></table>
<h1 id="三-java-time-包"><a href="#三-java-time-包" class="headerlink" title="三 java.time 包"></a>三 <code>java.time</code> 包</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>LocalDateTime</code></td>
<td>本地日期时间（不包含时区）</td>
</tr>
<tr>
<td><code>LocalDate</code></td>
<td>本地日期</td>
</tr>
<tr>
<td><code>LocalTime</code></td>
<td>本地时间</td>
</tr>
<tr>
<td><code>Instant</code></td>
<td>瞬时（时间戳），是 UTC 时间，没有时区概念</td>
</tr>
<tr>
<td><code>Period</code></td>
<td>日期间隔</td>
</tr>
<tr>
<td><code>Duration</code></td>
<td>时间间隔</td>
</tr>
<tr>
<td><code>ZoneOffset</code></td>
<td>时区偏移量</td>
</tr>
<tr>
<td><code>ZonedDateTime</code></td>
<td>指定时区的日期时间</td>
</tr>
<tr>
<td><code>ZoneId</code></td>
<td>包含了所有的时区信息，格式 <code>区域/城市</code></td>
</tr>
<tr>
<td><code>Clock</code></td>
<td>时钟</td>
</tr>
</tbody></table>
<h2 id="3-2-LocalDateTime-amp-LocalDate-amp-LocalTime"><a href="#3-2-LocalDateTime-amp-LocalDate-amp-LocalTime" class="headerlink" title="3.2 LocalDateTime &amp; LocalDate &amp; LocalTime"></a>3.2 <code>LocalDateTime &amp; LocalDate &amp; LocalTime</code></h2><h3 id="1-创建（now，of）"><a href="#1-创建（now，of）" class="headerlink" title="1 创建（now，of）"></a>1 创建（<code>now，of</code>）</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static LocalDateTime</code></td>
<td><code>now()</code></td>
<td>获取当前日期时间（默认时区）</td>
</tr>
<tr>
<td><code>static LocalDateTime</code></td>
<td><code>now​(ZoneId zone)</code></td>
<td>获取当前日期时间（指定时区）</td>
</tr>
<tr>
<td><code>static LocalDateTime</code></td>
<td><code>of(xxx)</code></td>
<td>获取指定日期时间（一系列重载）</td>
</tr>
</tbody></table>
<h3 id="2-获取（get）"><a href="#2-获取（get）" class="headerlink" title="2 获取（get）"></a>2 获取（<code>get</code>）</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>getYear()</code></td>
<td>获取年份</td>
</tr>
<tr>
<td><code>Month</code></td>
<td><code>getMonth()</code></td>
<td>获取月份（<code>Month</code> 是枚举类）</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getMonthValue()</code></td>
<td>获取一年中的第几个月 <code>1 ~ 12</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getDayOfYear()</code></td>
<td>获取一年中的第几天 <code>1 ~ 365/366</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getDayOfMonth()</code></td>
<td>获取一月中的第几天 <code>1 ~ 31</code></td>
</tr>
<tr>
<td><code>DayOfWeek</code></td>
<td><code>getDayOfWeek()</code></td>
<td>获取星期几（<code>DayOfWeek</code> 是枚举类）</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getHour()</code></td>
<td>获取时</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getMinute()</code></td>
<td>获取分</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getSecond()</code></td>
<td>获取秒</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getNano()</code></td>
<td>获取纳秒</td>
</tr>
</tbody></table>
<h3 id="3-格式化和解析（format，parse）"><a href="#3-格式化和解析（format，parse）" class="headerlink" title="3 格式化和解析（format，parse）"></a>3 格式化和解析（<code>format，parse</code>）</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>format​(DateTimeFormatter formatter)</code></td>
<td>日期时间转成指定格式的字符串</td>
</tr>
<tr>
<td><code>static LocalDateTime</code></td>
<td><code>parse​(CharSequence text)</code></td>
<td>解析默认格式字序列</td>
</tr>
<tr>
<td><code>static LocalDateTime</code></td>
<td><code>parse​(CharSequence text, DateTimeFormatter formatter)</code></td>
<td>解析指定格式字符序列</td>
</tr>
</tbody></table>
<h3 id="4-判断（is）"><a href="#4-判断（is）" class="headerlink" title="4 判断（is）"></a>4 判断（<code>is</code>）</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>isAfter​(ChronoLocalDate other)</code></td>
<td>是否在之后</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isBefore(ChronoLocalDate other)</code></td>
<td>是否在之前</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isEqual(ChronoLocalDate other)</code></td>
<td>是否相等</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isLeapYear()</code></td>
<td>是否是闰年</td>
</tr>
</tbody></table>
<h3 id="5-修改（with）"><a href="#5-修改（with）" class="headerlink" title="5 修改（with）"></a>5 修改（<code>with</code>）</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>LocalDateTime</code></td>
<td><code>with​(TemporalAdjuster adjuster)</code></td>
<td>将当前日期时间设置为校对器指定的日期时间</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>withYear(int year)</code></td>
<td>修改年</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>withMonth(int month)</code></td>
<td>修改月</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>withDayOfYear(int dayOfYear)</code></td>
<td>修改年第几天</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>withDayOfMonth(int dayOfMonth)</code></td>
<td>修改月第几天</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>withHour(int hour)</code></td>
<td>修改时</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>withMinute(int minute)</code></td>
<td>修改分</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>withSecond(int second)</code></td>
<td>修改秒</td>
</tr>
</tbody></table>
<h3 id="6-计算-plus，minus"><a href="#6-计算-plus，minus" class="headerlink" title="6 计算 plus，minus"></a>6 计算 <code>plus，minus</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>LocalDateTime</code></td>
<td><code>minus(TemporalAmount amountToSubtract)</code></td>
<td>减去一个 <code>Duration</code> 或 <code>Period</code></td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>plus(TemporalAmount amountToAdd)</code></td>
<td>添加一个 <code>Duration</code> 或 <code>Period</code></td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>plusYears(long years)</code></td>
<td>当前日期时间加指定年</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>plusMonths(long months)</code></td>
<td>当前日期时间加指定月</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>plusDays(long days)</code></td>
<td>当前日期时间加指定日</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>plusWeeks(long weeks)</code></td>
<td>当前日期时间加指定周</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>plusHours(long hours)</code></td>
<td>当前日期时间加指定时</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>plusMinutes(long minutes)</code></td>
<td>当前日期时间加指定分</td>
</tr>
<tr>
<td><code>LocalDateTime</code></td>
<td><code>plusSeconds(long seconds)</code></td>
<td>当前日期时间加指定秒</td>
</tr>
</tbody></table>
<h3 id="7-转换（to）"><a href="#7-转换（to）" class="headerlink" title="7 转换（to）"></a>7 转换（<code>to</code>）</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>toString()</code></td>
<td>获取字符串</td>
</tr>
<tr>
<td><code>LocalDate</code></td>
<td><code>toLocalDate()</code></td>
<td>获取日期</td>
</tr>
<tr>
<td><code>LocalTime</code></td>
<td><code>toLocalTime()</code></td>
<td>获取时间</td>
</tr>
</tbody></table>
<h2 id="3-3-Instant"><a href="#3-3-Instant" class="headerlink" title="3.3 Instant"></a>3.3 <code>Instant</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Instant</code></td>
<td><code>now()</code></td>
<td>获取当前UTC时间的时间戳</td>
</tr>
<tr>
<td><code>static Instant</code></td>
<td><code>ofEpochMilli​(long epochMilli)</code></td>
<td>获取指定毫秒值距元时间的时间戳</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toEpochMilli()</code></td>
<td>获取距元时间的毫秒数</td>
</tr>
<tr>
<td><code>OffsetDateTime</code></td>
<td><code>atOffset​(ZoneOffset offset)</code></td>
<td>结合时区偏移创建 <code>OffsetDateTime</code></td>
</tr>
</tbody></table>
<h2 id="3-4-Period"><a href="#3-4-Period" class="headerlink" title="3.4 Period"></a>3.4 <code>Period</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Period</code></td>
<td><code>between​(LocalDate startDateInclusive, LocalDate endDateExclusive)</code></td>
<td>获取两个日期的间隔对象  <code>Period</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getYears()</code></td>
<td>相隔年份</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getMonths()</code></td>
<td>相隔月份（只比较月字段）</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getDays()</code></td>
<td>相隔天数（只比较日字段）</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toTotalMonths()</code></td>
<td>相隔总月份</td>
</tr>
</tbody></table>
<h2 id="3-5-Duration"><a href="#3-5-Duration" class="headerlink" title="3.5 Duration"></a>3.5 <code>Duration</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Duration</code></td>
<td><code>between​(Temporal startInclusive, Temporal endExclusive)</code></td>
<td>获取两个时间的间隔对象  <code>Duration</code></td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toDays()</code></td>
<td>相隔总天数</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toHours()</code></td>
<td>相隔总小时数</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toMinutes()</code></td>
<td>相隔总分钟数</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toSeconds()</code></td>
<td>相隔总秒数</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toMillis()</code></td>
<td>相隔总毫秒数</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toNanos()</code></td>
<td>相隔总纳秒数</td>
</tr>
</tbody></table>
<h2 id="3-6-ZoneId"><a href="#3-6-ZoneId" class="headerlink" title="3.6 ZoneId"></a>3.6 <code>ZoneId</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Set&lt;String&gt;</code></td>
<td><code>getAvailableZoneIds()</code></td>
<td>获取所有时区ID，格式<code>区域/城市</code></td>
</tr>
<tr>
<td><code>static ZoneId</code></td>
<td><code>systemDefault()</code></td>
<td>获取系统默认时区</td>
</tr>
<tr>
<td><code>static ZoneId</code></td>
<td><code>of​(String zoneId)</code></td>
<td>根据时区ID获取时区</td>
</tr>
</tbody></table>
<h1 id="四-DateTimeFormatter"><a href="#四-DateTimeFormatter" class="headerlink" title="四 DateTimeFormatter"></a>四 <code>DateTimeFormatter</code></h1><h2 id="4-1-预定义标准格式"><a href="#4-1-预定义标准格式" class="headerlink" title="4.1 预定义标准格式"></a>4.1 预定义标准格式</h2><table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ISO_LOCAL_DATE_TIME</code></td>
<td><code>YYYY-MM-DD HH:MM:SS</code></td>
</tr>
<tr>
<td><code>ISO_LOCAL_DATE</code></td>
<td><code>YYYY-MM-DD</code></td>
</tr>
<tr>
<td><code>ISO_LOCAL_TIME</code></td>
<td><code>HH:MM:SS</code></td>
</tr>
<tr>
<td><code>...</code></td>
<td><code>...</code></td>
</tr>
</tbody></table>
<h2 id="4-2-本地化相关格式"><a href="#4-2-本地化相关格式" class="headerlink" title="4.2 本地化相关格式"></a>4.2 本地化相关格式</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static DateTimeFormatter</code></td>
<td><code>ofLocalizedDateTime​(FormatStyle dateTimeStyle)</code></td>
<td><code>FormatStyle</code> 是枚举类，其中 <code>FULL，LONG</code>适用于 <code>DateTime</code></td>
</tr>
<tr>
<td><code>static DateTimeFormatter</code></td>
<td><code>ofLocalizedDate​(FormatStyle dateStyle)</code></td>
<td><code>MEDIUM，SHORT</code> 适用于 <code>Date</code></td>
</tr>
<tr>
<td><code>static DateTimeFormatter</code></td>
<td><code>ofLocalizedTime​(FormatStyle timeStyle)</code></td>
<td><code>MEDIUM，SHORT</code> 适用于 <code>Time</code></td>
</tr>
</tbody></table>
<h2 id="4-3-自定义格式"><a href="#4-3-自定义格式" class="headerlink" title="4.3 自定义格式"></a>4.3 自定义格式</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static DateTimeFormatter</code></td>
<td><code>ofPattern​(String pattern)</code></td>
<td>使用自定义格式和默认地区</td>
</tr>
<tr>
<td><code>static DateTimeFormatter</code></td>
<td><code>ofPattern​(String pattern, Locale locale)</code></td>
<td>使用自定义格式和指定地区</td>
</tr>
</tbody></table>
<h1 id="五-TemporalAdjusters"><a href="#五-TemporalAdjusters" class="headerlink" title="五 TemporalAdjusters"></a>五 <code>TemporalAdjusters</code></h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol>
<li>时间校正器工具类</li>
<li>获取时间校正器对象，之后可以通过日期时间对象的 <code>with</code> 方法来调整</li>
</ol>
<h2 id="5-2-API"><a href="#5-2-API" class="headerlink" title="5.2 API"></a>5.2 API</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> TemporalAdjuster <span class="title">firstXxx</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> TemporalAdjuster <span class="title">lastXxx</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> TemporalAdjuster <span class="title">nextXxx</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> TemporalAdjuster <span class="title">previousXxx</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h1 id="六-新旧日期时间的转换"><a href="#六-新旧日期时间的转换" class="headerlink" title="六 新旧日期时间的转换"></a>六 新旧日期时间的转换</h1><table>
<thead>
<tr>
<th>旧类</th>
<th>新类</th>
<th>旧 → 新</th>
<th>新 → 旧</th>
</tr>
</thead>
<tbody><tr>
<td><code>java.util.Date</code></td>
<td><code>java.time.Instant</code></td>
<td><code>date.toInstant()</code></td>
<td><code>Date.from(instant)</code></td>
</tr>
<tr>
<td><code>java.sql.Timestamp</code></td>
<td><code>java.time.Instant</code></td>
<td><code>timestamp.toInstant()</code></td>
<td><code>Timestamp.from(instant)</code></td>
</tr>
<tr>
<td><code>java.sql.Timestamp</code></td>
<td><code>java.time.LocalDateTime</code></td>
<td><code>timestamp.toLocalDateTime()</code></td>
<td><code>Timestamp.valueOf(localDateTIme)</code></td>
</tr>
<tr>
<td><code>java.sql.Date</code></td>
<td><code>java.time.LocalDate</code></td>
<td><code>date.toLocalDate()</code></td>
<td><code>Date.valueOf(LocalDate)</code></td>
</tr>
<tr>
<td><code>java.sql.Time</code></td>
<td><code>java.time.LocalTime</code></td>
<td><code>time.toLocalTime()</code></td>
<td><code>TIme.valueOf(LocalTime)</code></td>
</tr>
</tbody></table>
<ol>
<li>旧转为新 <code>to</code></li>
<li>新转为旧 <code>from，valueOf</code></li>
</ol>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/09/29/Java/Java-%E5%B8%B8%E7%94%A8API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/09/29/Java/Java-%E5%B8%B8%E7%94%A8API/" class="post-title-link" itemprop="url">Java-常用API</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-09-29 16:03:31 / 修改时间：16:03:47" itemprop="dateCreated datePublished" datetime="2020-09-29T16:03:31+08:00">2020-09-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-java-lang-Object"><a href="#一-java-lang-Object" class="headerlink" title="一 java.lang.Object"></a>一 <code>java.lang.Object</code></h1><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>hashCode()</code></td>
<td>返回该对象的哈希码值</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>equals(Object obj)</code></td>
<td>默认比较对象的地址值</td>
</tr>
<tr>
<td><code>Class&lt;?&gt;</code></td>
<td><code>getClass()</code></td>
<td>返回此对象的字节码对象</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>toString()</code></td>
<td><code>getClass().getName() + &#39;@&#39; + Integer.toHexString(hashCode())</code></td>
</tr>
<tr>
<td><code>protected Object</code></td>
<td><code>clone()</code></td>
<td>浅拷贝</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>wait()</code></td>
<td>无限等待直到被唤醒，相当于 <code>wait(0)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>wait(long timeoutMillis)</code></td>
<td>等待指定时间或被唤醒</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>wait(long timeoutMillis, int nanos)</code></td>
<td>等待指定时间或被唤醒</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>notify()</code></td>
<td>唤醒一个</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>notifyAll()</code></td>
<td>唤醒所有</td>
</tr>
</tbody></table>
<h2 id="1-1-和-equals"><a href="#1-1-和-equals" class="headerlink" title="1.1 ==  和  equals()"></a>1.1 <code>==</code>  和  <code>equals()</code></h2><table>
<thead>
<tr>
<th>比较符</th>
<th>基本数据类型</th>
<th>引用数据类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>==</code></td>
<td>比较值，<code>==</code> 是运算符所以同样适用基本类型运算时的类型转换 <code>byte short char -&gt; int -&gt; long -&gt; float -&gt; double</code></td>
<td>比较地址值</td>
</tr>
<tr>
<td><code>equals()</code></td>
<td>&nbsp;</td>
<td>比较地址值</td>
</tr>
</tbody></table>
<h2 id="1-2-重写-equals-时也要重写-hashCode"><a href="#1-2-重写-equals-时也要重写-hashCode" class="headerlink" title="1.2 重写 equals() 时也要重写 hashCode()"></a>1.2 重写 <code>equals()</code> 时也要重写 <code>hashCode()</code></h2><ol>
<li>判断元素是否相同：<ol>
<li>判断两个元素哈希值是否相同（判断的是对象的 <code>hashCode()</code></li>
<li>如果哈希值相同判断内容是否相同（判断的是对象的 <code>equals()</code>）</li>
</ol>
</li>
<li>两个对象相同则哈希值一定相同，如果只重写 <code>equals()</code> 方法，结果返回 <code>true</code> 时，<code>hashCode()</code> 返回值可能不一样</li>
</ol>
<h1 id="二-java-util-Objects"><a href="#二-java-util-Objects" class="headerlink" title="二 java.util.Objects"></a>二 <code>java.util.Objects</code></h1><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static boolean</code></td>
<td><code>equals​(Object a, Object b)</code></td>
<td>判断是否是同一对象</td>
</tr>
<tr>
<td><code>static boolean</code></td>
<td><code>isNull​(Object obj)</code></td>
<td>判断对象是否为空</td>
</tr>
<tr>
<td><code>static boolean</code></td>
<td><code>nonNull​(Object obj)</code></td>
<td>判断对象是否不为空</td>
</tr>
<tr>
<td><code>static &lt;T&gt; T</code></td>
<td><code>requireNonNull​(T obj [, String message])</code></td>
<td>如果对象不为空则返回，为空则抛空指针异常（可指定异常信息）</td>
</tr>
<tr>
<td><code>static &lt;T&gt; int</code></td>
<td><code>compare​(T a, T b, Comparator&lt;? super T&gt; c)</code></td>
<td>如果 <code>a==b</code> 返回 0，否则使用比较器比较</td>
</tr>
<tr>
<td><code>static String</code></td>
<td><code>toString​(Object o)</code></td>
<td>如果对象不为空则调用 <code>toString()</code>，为空则返回 <code>&quot;null&quot;</code></td>
</tr>
</tbody></table>
<h1 id="三-基本类型包装类"><a href="#三-基本类型包装类" class="headerlink" title="三 基本类型包装类"></a>三 基本类型包装类</h1><h2 id="3-1-包装类"><a href="#3-1-包装类" class="headerlink" title="3.1 包装类"></a>3.1 包装类</h2><table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类（<code>java.lang</code>）</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte</code></td>
<td><code>Byte</code></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>Short</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>Integer</code></td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>Long</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>Float</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>Double</code></td>
</tr>
<tr>
<td><code>char</code></td>
<td><code>Character</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>Boolean</code></td>
</tr>
</tbody></table>
<ul>
<li>除了 <code>Character</code> 和 <code>Boolean</code> 外，都是 <code>Number</code> 类的子类</li>
</ul>
<h2 id="3-2-自动装箱和拆箱"><a href="#3-2-自动装箱和拆箱" class="headerlink" title="3.2 自动装箱和拆箱"></a>3.2 自动装箱和拆箱</h2><ul>
<li>装箱：<code>基本数据类型 → 包装类对象</code></li>
<li>拆箱：<code>包装类对象 → 基本数据类型</code></li>
</ul>
<h2 id="3-3-包装类的缓存"><a href="#3-3-包装类的缓存" class="headerlink" title="3.3 包装类的缓存"></a>3.3 包装类的缓存</h2><table>
<thead>
<tr>
<th>包装类</th>
<th>缓存范围</th>
</tr>
</thead>
<tbody><tr>
<td><code>Boolean</code></td>
<td><code>true false</code></td>
</tr>
<tr>
<td><code>Byte Short Long</code></td>
<td><code>-128~127</code></td>
</tr>
<tr>
<td><code>Integer</code></td>
<td><code>-128~127</code>（上限可以调整）</td>
</tr>
<tr>
<td><code>Character</code></td>
<td><code>0~127</code> （最早的 ASCII 码的128个字符）</td>
</tr>
<tr>
<td><code>Double Float</code></td>
<td>没有缓存</td>
</tr>
</tbody></table>
<ul>
<li><p>自动装箱时，如果在缓存范围内，则不会创建新对象，而是使用缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">i1 == i2;	 <span class="comment">// false ，因为不是同一个对象</span></span><br><span class="line">i1.equals(i2); <span class="comment">// true ，Integer重写了equals方法，比较的是数值</span></span><br><span class="line"></span><br><span class="line">Integer i1 = <span class="number">127</span>;</span><br><span class="line">Integer i2 = <span class="number">127</span>;</span><br><span class="line">i1 == i2;	 <span class="comment">// true ，因为缓存，指向同一个地址</span></span><br><span class="line">i1.equals(i2); <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line">Integer i1 = <span class="number">128</span>;</span><br><span class="line">Integer i2 = <span class="number">128</span>;</span><br><span class="line">i1 == i2; <span class="comment">// false ，不在缓存范围，则需要重新 new 是两个不同的地址</span></span><br><span class="line">i1.equals(i2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-4-基本类型及其包装类与字符串的转换"><a href="#3-4-基本类型及其包装类与字符串的转换" class="headerlink" title="3.4 基本类型及其包装类与字符串的转换"></a>3.4 基本类型及其包装类与字符串的转换</h2><ol>
<li><code>int/Integer -&gt; string</code><ol>
<li><code>+ &quot;&quot;</code></li>
<li><code>toString()</code></li>
<li><code>String.valueOf()</code></li>
</ol>
</li>
<li><code>String -&gt; int/Integer</code><ol>
<li><code>Integer.parseInt(String s)</code></li>
</ol>
</li>
</ol>
<h1 id="四-比较器"><a href="#四-比较器" class="headerlink" title="四 比较器"></a>四 比较器</h1><h2 id="4-1-java-lang-Comparable"><a href="#4-1-java-lang-Comparable" class="headerlink" title="4.1 java.lang.Comparable"></a>4.1 <code>java.lang.Comparable</code></h2><ol>
<li>实现此接口的类具有比较性</li>
<li>实现 <code>int compareTo(T o)</code> 方法<ul>
<li>如果当前对象大于形参对象则返回正整数</li>
<li>如果当前对象等于形参对象则返回 0</li>
<li>如果当前对象小于形参对象则返回负整数</li>
</ul>
</li>
</ol>
<h2 id="4-2-java-util-Comparator"><a href="#4-2-java-util-Comparator" class="headerlink" title="4.2 java.util.Comparator"></a>4.2 <code>java.util.Comparator</code></h2><ol>
<li>比较器接口，实现此接口创建新的比较器</li>
<li>实现 <code>int compare(T o1, T o2)</code> 方法<ul>
<li><code>o1 &gt; o2</code> 返回正整数</li>
<li><code>o1 == o2</code> 返回 0</li>
<li><code>o1 &lt; o2</code> 返回负整数</li>
</ul>
</li>
</ol>
<h1 id="五-java-lang-System"><a href="#五-java-lang-System" class="headerlink" title="五 java.lang.System"></a>五 <code>java.lang.System</code></h1><h2 id="5-1-属性"><a href="#5-1-属性" class="headerlink" title="5.1 属性"></a>5.1 属性</h2><table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>in</code></td>
<td>标准输入</td>
</tr>
<tr>
<td><code>out</code></td>
<td>标准输出</td>
</tr>
<tr>
<td><code>err</code></td>
<td>标准错误输出</td>
</tr>
</tbody></table>
<h2 id="5-2-方法"><a href="#5-2-方法" class="headerlink" title="5.2 方法"></a>5.2 方法</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static long</code></td>
<td><code>currentTimeMillis()</code></td>
<td><code>1970-01-01 00:00:00</code> 到当前时间的毫秒值</td>
</tr>
<tr>
<td><code>static Properties</code></td>
<td><code>getProperties()</code></td>
<td>获取系统属性值</td>
</tr>
<tr>
<td><code>static String</code></td>
<td><code>getProperty(String key)</code></td>
<td>获取系统指定属性的值</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>gc()</code></td>
<td>运行垃圾回收器</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>exit(int status)</code></td>
<td>终止当前正在运行的 Java 虚拟机， <code>0</code> 表示正常终止，非 <code>0</code> 异常退出</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code></td>
<td>拷贝数组</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>setIn​(InputStream in)</code></td>
<td>重新分配标准输入</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>setOut​(PrintStream out)</code></td>
<td>重新分配标准输出</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>setErr​(PrintStream err)</code></td>
<td>重新分配标准错误输出</td>
</tr>
</tbody></table>
<h1 id="六-java-util-Scanner"><a href="#六-java-util-Scanner" class="headerlink" title="六 java.util.Scanner"></a>六 <code>java.util.Scanner</code></h1><h2 id="6-1-构造"><a href="#6-1-构造" class="headerlink" title="6.1 构造"></a>6.1 构造</h2><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Scanner(File source [, String charsetName])</code></td>
<td>扫描文件</td>
</tr>
<tr>
<td><code>Scanner​(InputStream source [, String charsetName])</code></td>
<td>扫描字节输入流</td>
</tr>
<tr>
<td><code>Scanner​(String source)</code></td>
<td>扫描字符串</td>
</tr>
</tbody></table>
<h2 id="6-2-方法"><a href="#6-2-方法" class="headerlink" title="6.2 方法"></a>6.2 方法</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>hasNext()</code></td>
<td>是否有下一个字符串</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>next()</code></td>
<td>获取下一个字符串，遇到空白符结束（空格 制表符 回车）</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>nextLine()</code></td>
<td>获取下一个字符串，遇到换行符结束</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>hasNextXxx()</code></td>
<td>是否有下一个指定类型的数据，<code>hasNextInt ()hasNextDouble() ...</code></td>
</tr>
<tr>
<td><code>Xxx</code></td>
<td><code>nextXxx()</code></td>
<td>获取下一个指定类型的数据，<code>nextInt() nextDouble() ...</code></td>
</tr>
</tbody></table>
<ul>
<li>当 <code>nextXxx()</code> 和 <code>nextLine()</code> 连用时的问题<ul>
<li>比如输入 <code>8</code> ，实际输入的是 <code>8\r\n</code>，而 <code>nextInt()</code> 读到 <code>8</code> 就结束了，下一个使用 <code>nextLine()</code> 读到 <code>\r\n</code> 直接就结束了</li>
</ul>
</li>
<li>解决<ol>
<li>在语句之后加一个 <code>nextLine()</code> 语句用来读取没有读到的 <code>\r\n</code></li>
<li>都使用 <code>nextLine()</code>，输入字符串，需要数字就转换。</li>
</ol>
</li>
</ul>
<h1 id="七-java-util-Random"><a href="#七-java-util-Random" class="headerlink" title="七 java.util.Random"></a>七 <code>java.util.Random</code></h1><h2 id="7-1-构造"><a href="#7-1-构造" class="headerlink" title="7.1 构造"></a>7.1 构造</h2><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Random()</code></td>
<td>默认种子是系统时间的纳秒值</td>
</tr>
<tr>
<td><code>Random​(long seed)</code></td>
<td>指定种子，种子相同，多次执行获得的随机数是一样的</td>
</tr>
</tbody></table>
<h2 id="7-2-方法"><a href="#7-2-方法" class="headerlink" title="7.2 方法"></a>7.2 方法</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>nextInt()</code></td>
<td>获取 int 范围内的随机数</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>nextInt(int bound)</code></td>
<td>获取 <code>0&lt; x &lt; bound</code> 的随机数</td>
</tr>
</tbody></table>
<h1 id="八-Arrays"><a href="#八-Arrays" class="headerlink" title="八 Arrays"></a>八 <code>Arrays</code></h1><h2 id="8-1-数组-→-集合"><a href="#8-1-数组-→-集合" class="headerlink" title="8.1 数组 → 集合"></a>8.1 数组 → 集合</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static &lt;T&gt; List&lt;T&gt;</code></td>
<td><code>asList(T... a)</code></td>
<td>数组 → <code>List</code></td>
</tr>
</tbody></table>
<ol>
<li>数组长度固定，所以转成的集合的增删方法不能使用</li>
<li>集合中只能存储引用数据类型，所以：<ul>
<li>如果数组中的元素是引用类型，则直接作为集合元素</li>
<li>如果数组中的元素是基本类型，则将数组作为集合元素</li>
</ul>
</li>
</ol>
<h2 id="8-2-二分查找"><a href="#8-2-二分查找" class="headerlink" title="8.2 二分查找"></a>8.2 二分查找</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static int</code></td>
<td><code>binarySearch(T[] a, T key)</code></td>
<td>找到则返回索引，没找到返回 <code>-插入点-1</code></td>
</tr>
<tr>
<td><code>static int</code></td>
<td><code>binarySearch(T[] a, int fromIndex, int toIndex, T key)</code></td>
<td>指定范围 <code>[from, to)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; int</code></td>
<td><code>binarySearch(T[] a, T key, Comparator&lt;? super T&gt; c)</code></td>
<td>指定比较器</td>
</tr>
<tr>
<td><code>static &lt;T&gt; int</code></td>
<td><code>binarySearch(T[] a, int fromIndex, int toIndex, T key, Comparator&lt;? super T&gt; c)</code></td>
<td>指定比较器，并指定范围 <code>[from, to)</code></td>
</tr>
</tbody></table>
<h2 id="8-3-排序"><a href="#8-3-排序" class="headerlink" title="8.3 排序"></a>8.3 排序</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static void</code></td>
<td><code>sort(T[] a)</code></td>
<td>数组排序</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>sort(T[] a, int fromIndex, int toIndex)</code></td>
<td>指定范围 <code>[from, to)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; void</code></td>
<td><code>sort(T[] a, Comparator&lt;? super T&gt; c)</code></td>
<td>指定比较器</td>
</tr>
<tr>
<td><code>static &lt;T&gt; void</code></td>
<td><code>sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; c)</code></td>
<td>指定比较器，并指定范围 <code>[from, to)</code></td>
</tr>
</tbody></table>
<h2 id="8-4-复制"><a href="#8-4-复制" class="headerlink" title="8.4 复制"></a>8.4 复制</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static &lt;T&gt; T[]</code></td>
<td><code>copyOf(T[] original, int newLength)</code></td>
<td>将原数组复制到新数组并指定新数组长度，新数组长度大的话根据类型使用 <code>0 false null</code> 填充</td>
</tr>
<tr>
<td><code>static &lt;T&gt; T[]</code></td>
<td><code>copyOfRange(T[] original, int from, int to)</code></td>
<td>复制原数组指定内容到新数组</td>
</tr>
</tbody></table>
<h2 id="8-5-填充"><a href="#8-5-填充" class="headerlink" title="8.5 填充"></a>8.5 填充</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static void</code></td>
<td><code>fill(T[], T val)</code></td>
<td>将数组所有元素用 <code>val</code> 替换</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>fill(T[], int fromIndex, int toIndex, T val)</code></td>
<td>将数组 <code>[from, to)</code> 范围的元素用 <code>val</code> 替换</td>
</tr>
</tbody></table>
<h2 id="8-6-相等比较"><a href="#8-6-相等比较" class="headerlink" title="8.6 相等比较"></a>8.6 相等比较</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static boolean</code></td>
<td><code>equals(T[] a1, T[] a2)</code></td>
<td>比较两个数组的长度和元素是否相等</td>
</tr>
<tr>
<td><code>static boolean</code></td>
<td><code>deepEquals(Object[] a1, Object[] a2)</code></td>
<td>深度相等比较</td>
</tr>
</tbody></table>
<h2 id="8-7-toString"><a href="#8-7-toString" class="headerlink" title="8.7 toString"></a>8.7 <code>toString</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static String</code></td>
<td><code>toString(T[] arr)</code></td>
<td>将数组元素以 <code>[元素1, 元素2 ...]</code> 格式拼接成一个字符串</td>
</tr>
</tbody></table>
<h2 id="8-8-流"><a href="#8-8-流" class="headerlink" title="8.8 流"></a>8.8 流</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>static IntStream</code></td>
<td><code>stream(int[] array)</code></td>
</tr>
<tr>
<td><code>static IntStream</code></td>
<td><code>stream(int[] array, int startInclusive, int endExclusive)</code></td>
</tr>
<tr>
<td><code>static LongStream</code></td>
<td><code>stream(long[] array)</code></td>
</tr>
<tr>
<td><code>static LongStream</code></td>
<td><code>stream(long[] array, int startInclusive, int endExclusive)</code></td>
</tr>
<tr>
<td><code>static DoubleStream</code></td>
<td><code>stream(double[] array)</code></td>
</tr>
<tr>
<td><code>static DoubleStream</code></td>
<td><code>stream(double[] array, int startInclusive, int endExclusive)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td>
<td><code>stream(T[] array)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td>
<td><code>stream(T[] array, int startInclusive, int endExclusive)</code></td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/09/29/Java/Java-Stream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/09/29/Java/Java-Stream/" class="post-title-link" itemprop="url">Java-Stream</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-09-29 16:02:42 / 修改时间：16:02:54" itemprop="dateCreated datePublished" datetime="2020-09-29T16:02:42+08:00">2020-09-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li><code>java.util.stream</code> 包</li>
<li>流：从支持数据处理操作的源生成的元素序列<ol>
<li>流不存储元素，只是对数据进行处理</li>
<li>流的操作不会修改数据源，而是返回一个持有结果的新流</li>
<li>惰性求值：流的中间操作形成一条流水线，但不会真正执行，只有在执行终端操作时才会一次性全部处理</li>
<li>流只能消费一次</li>
</ol>
</li>
<li>集合关注的是数据存储，与内存打交道</li>
<li>流关注的是数据运算，与CPU打交道</li>
</ol>
<h1 id="二-流的操作"><a href="#二-流的操作" class="headerlink" title="二 流的操作"></a>二 流的操作</h1><h2 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h2><ol>
<li>流水线</li>
<li>内部迭代<ul>
<li>使用集合：需要用户去做迭代，这称为外部迭代</li>
<li>使用流：数据处理完全是在库内部进行的，这称为内部迭代</li>
</ul>
</li>
</ol>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%86%85%E9%83%A8-%E5%A4%96%E9%83%A8%E8%BF%AD%E4%BB%A3.png" alt=""></p>
<h2 id="2-2-流程"><a href="#2-2-流程" class="headerlink" title="2.2 流程"></a>2.2 流程</h2><table>
<thead>
<tr>
<th>流程</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1 创建流</td>
<td>通过一个数据源（如：集合、数组），获取一个流</td>
</tr>
<tr>
<td>2 中间操作</td>
<td>对数据源的数据进行 n 次处理，多个中间操作形成操作链（在终端操作前，并不会真正执行中间操作链）</td>
</tr>
<tr>
<td>3 终端操作</td>
<td>一旦执行终端操作，就执行中间操作链，最终产生结果并结束流</td>
</tr>
</tbody></table>
<h1 id="三-创建流"><a href="#三-创建流" class="headerlink" title="三 创建流"></a>三 创建流</h1><h2 id="3-1-由值创建流：java-util-stream-Stream"><a href="#3-1-由值创建流：java-util-stream-Stream" class="headerlink" title="3.1 由值创建流：java.util.stream.Stream"></a>3.1 由值创建流：<code>java.util.stream.Stream</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td>
<td><code>ofNullable(T t)</code></td>
<td>若 <code>t</code> 为 <code>null</code> ，则返回空流，否则返回包含 <code>t</code> 的流</td>
</tr>
<tr>
<td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td>
<td><code>empty()</code></td>
<td>获取一个不包含任何元素的空流</td>
</tr>
<tr>
<td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td>
<td><code>of(T... values)</code></td>
<td>获取一个有限流，元素固定</td>
</tr>
<tr>
<td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td>
<td><code>generate(Supplier&lt;? extends T&gt; s)</code></td>
<td>获取一个无限流，元素通过反复调用 <code>s</code> 生成</td>
</tr>
<tr>
<td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td>
<td><code>iterate(T seed, UnaryOperator&lt;T&gt; f)</code></td>
<td>获取一个无限流，元素： <code>seed</code> 为初始值，之后依次由上一个值通过 <code>f</code> 生成下一个值</td>
</tr>
<tr>
<td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td>
<td><code>iterate(T seed, Predicate&lt;? super T&gt; hasNext, UnaryOperator&lt;T&gt; f)</code></td>
<td>获取一个有限流，和无限流的区别是会在某个元素不满足 <code>hasNext</code> 时停止</td>
</tr>
</tbody></table>
<h2 id="3-2-由集合创建流：-java-util-Collection-lt-E-gt"><a href="#3-2-由集合创建流：-java-util-Collection-lt-E-gt" class="headerlink" title="3.2 由集合创建流： java.util.Collection&lt;E&gt;"></a>3.2 由集合创建流： <code>java.util.Collection&lt;E&gt;</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>default Stream&lt;E&gt;</code></td>
<td><code>stream()</code></td>
<td>获取一个顺序流</td>
</tr>
<tr>
<td><code>default Stream&lt;E&gt;</code></td>
<td><code>parallelStream()</code></td>
<td>获取一个并行流</td>
</tr>
</tbody></table>
<h2 id="3-3-由数组创建流：java-util-Arrays"><a href="#3-3-由数组创建流：java-util-Arrays" class="headerlink" title="3.3 由数组创建流：java.util.Arrays"></a>3.3 由数组创建流：<code>java.util.Arrays</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td>
<td><code>stream(T[] array[, int start, int end])</code></td>
<td>获取 <code>Stream</code> 流，可指定范围 <code>[start, end)</code></td>
</tr>
<tr>
<td><code>static IntStream</code></td>
<td><code>stream(int[] array[, int start, int end])</code></td>
<td>获取 <code>IntStream</code> 流，可指定范围 <code>[start, end)</code></td>
</tr>
<tr>
<td><code>static LongStream</code></td>
<td><code>stream(long[] array[, int start, int end])</code></td>
<td>获取 <code>LongStream</code> 流，可指定范围 <code>[start, end)</code></td>
</tr>
<tr>
<td><code>static DoubleStream</code></td>
<td><code>stream(double[] array[, int start, int end])</code></td>
<td>获取 <code>DoubleStream</code> 流，可指定范围 <code>[start, end)</code></td>
</tr>
</tbody></table>
<h2 id="3-4-由文件生成流：java-nio-file-Files"><a href="#3-4-由文件生成流：java-nio-file-Files" class="headerlink" title="3.4 由文件生成流：java.nio.file.Files"></a>3.4 由文件生成流：<code>java.nio.file.Files</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Stream&lt;String&gt;</code></td>
<td><code>lines(Path path)</code></td>
<td>流元素为文件中的行，字符集默认为 <code>UTF-8</code></td>
</tr>
<tr>
<td><code>static Stream&lt;String&gt;</code></td>
<td><code>lines(Path path, Charset cs)</code></td>
<td>流元素为文件中的行，可指定字符集</td>
</tr>
</tbody></table>
<h1 id="四-中间操作"><a href="#四-中间操作" class="headerlink" title="四 中间操作"></a>四 中间操作</h1><h2 id="4-1-筛选和切片"><a href="#4-1-筛选和切片" class="headerlink" title="4.1 筛选和切片"></a>4.1 筛选和切片</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Stream&lt;T&gt;</code></td>
<td><code>filter(Predicate&lt;? super T&gt; predicate)</code></td>
<td>由所有符合条件的元素构成一个流</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt;</code></td>
<td><code>takeWhile(Predicate&lt;? super T&gt; predicate)</code></td>
<td>从第一个元素开始匹配，遇到不匹配就停止，由所有筛选出的元素构成一个流</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt;</code></td>
<td><code>dropWhile(Predicate&lt;? super T&gt; predicate)</code></td>
<td>从第一个元素开始匹配，由第一个不匹配的元素及其之后的所有元素构成一个流</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt;</code></td>
<td><code>distinct()</code></td>
<td>去重</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt;</code></td>
<td><code>limit(long maxSize)</code></td>
<td>限制数量</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt;</code></td>
<td><code>skip(long n)</code></td>
<td>跳过前 n 个元素，若数量不够则返回空流</td>
</tr>
</tbody></table>
<h2 id="4-2-排序"><a href="#4-2-排序" class="headerlink" title="4.2 排序"></a>4.2 排序</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Stream&lt;T&gt;</code></td>
<td><code>sorted()</code></td>
<td>自然排序</td>
</tr>
<tr>
<td><code>Stream&lt;T&gt;</code></td>
<td><code>sorted​(Comparator&lt;? super T&gt; comparator)</code></td>
<td>定制排序</td>
</tr>
</tbody></table>
<h2 id="4-3-映射"><a href="#4-3-映射" class="headerlink" title="4.3 映射"></a>4.3 映射</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;R&gt; Stream&lt;R&gt;</code></td>
<td><code>map​(Function&lt;? super T,​? extends R&gt; mapper)</code></td>
<td>流中每个元素映射为一个新元素，所有新元素组成流，新旧流元素个数相同</td>
</tr>
<tr>
<td><code>&lt;R&gt; Stream&lt;R&gt;</code></td>
<td><code>flatMap​(Function&lt;? super T,​? extends Stream&lt;? extends R&gt;&gt; mapper)</code></td>
<td>流中每个元素都映射为一个流，所有流连接为一个新流（即映射成的每个流中的元素组成新流），新旧流元素个数可能不同</td>
</tr>
</tbody></table>
<h2 id="4-4-操作"><a href="#4-4-操作" class="headerlink" title="4.4 操作"></a>4.4 操作</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Stream&lt;T&gt;</code></td>
<td><code>peek​(Consumer&lt;? super T&gt; action)</code></td>
<td>流中元素不变，对每个元素进行一些操作</td>
</tr>
<tr>
<td><code>static &lt;T&gt; Stream&lt;T&gt;</code></td>
<td><code>concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</code></td>
<td>由流 <code>a</code> 的一个元素后跟流 <code>b</code> 的一个元素组成的元素构成一个流</td>
</tr>
</tbody></table>
<h1 id="五-终止操作"><a href="#五-终止操作" class="headerlink" title="五 终止操作"></a>五 终止操作</h1><h2 id="5-1-迭代"><a href="#5-1-迭代" class="headerlink" title="5.1 迭代"></a>5.1 迭代</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>forEach​(Consumer&lt;? super T&gt; action)</code></td>
<td>迭代流中元素</td>
</tr>
<tr>
<td><code>Iterator&lt;T&gt;</code></td>
<td><code>iterator()</code></td>
<td>旧式迭代器</td>
</tr>
</tbody></table>
<h2 id="5-2-统计"><a href="#5-2-统计" class="headerlink" title="5.2 统计"></a>5.2 统计</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>long</code></td>
<td><code>count()</code></td>
<td>统计流中元素个数</td>
</tr>
</tbody></table>
<h2 id="5-3-匹配"><a href="#5-3-匹配" class="headerlink" title="5.3 匹配"></a>5.3 匹配</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>anyMatch​(Predicate&lt;? super T&gt; predicate)</code></td>
<td>是否有任意元素匹配</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>allMatch​(Predicate&lt;? super T&gt; predicate)</code></td>
<td>是否全部元素都匹配</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>noneMatch​(Predicate&lt;? super T&gt; predicate)</code></td>
<td>是否没有元素匹配</td>
</tr>
</tbody></table>
<h2 id="5-4-查找"><a href="#5-4-查找" class="headerlink" title="5.4 查找"></a>5.4 查找</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Optional&lt;T&gt;</code></td>
<td><code>findFirst()</code></td>
<td>返回流中第一个元素</td>
</tr>
<tr>
<td><code>Optional&lt;T&gt;</code></td>
<td><code>findAny()</code></td>
<td>返回流中任意一个元素（如果是稳定流，也返回第一个元素）</td>
</tr>
<tr>
<td><code>Optional&lt;T&gt;</code></td>
<td><code>max​(Comparator&lt;? super T&gt; comparator)</code></td>
<td>返回流中最大元素，使用给定比较器定义的排序规则</td>
</tr>
<tr>
<td><code>Optional&lt;T&gt;</code></td>
<td><code>min​(Comparator&lt;? super T&gt; comparator)</code></td>
<td>返回流中最小元素</td>
</tr>
</tbody></table>
<h2 id="5-5-归约"><a href="#5-5-归约" class="headerlink" title="5.5 归约"></a>5.5 归约</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Optional&lt;T&gt;</code></td>
<td><code>reduce​(BinaryOperator&lt;T&gt; accumulator)</code></td>
<td>元素1和元素2运算获取累计结果，结果再和下一个元素运算获取累计结果…，直到获取最终结果，由于流可能没有元素，所以返回 <code>Optional</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>reduce​(T identity, BinaryOperator&lt;T&gt; accumulator)</code></td>
<td>同上，只是指定一个初始元素，由于肯定有值，所以不用返回 <code>Optional</code></td>
</tr>
</tbody></table>
<h2 id="5-6-收集"><a href="#5-6-收集" class="headerlink" title="5.6 收集"></a>5.6 收集</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;R,A&gt; R</code></td>
<td><code>collect​(Collector&lt;? super T,​A,​R&gt; collector)</code></td>
<td>使用指定收集器收集流中元素</td>
</tr>
<tr>
<td><code>Object[]</code></td>
<td><code>toArray[]</code></td>
<td>收集到对象数组中</td>
</tr>
<tr>
<td><code>&lt;A&gt; A[]</code></td>
<td><code>toArray(IntFunction&lt;A[]&gt; generator)</code></td>
<td>传入 <code>A[]::new</code> 收集到 <code>A[]</code> 类型数组中</td>
</tr>
</tbody></table>
<h1 id="六-流收集器"><a href="#六-流收集器" class="headerlink" title="六 流收集器"></a>六 流收集器</h1><h2 id="6-1-收集器接口：Collector-lt-T-A-R-gt"><a href="#6-1-收集器接口：Collector-lt-T-A-R-gt" class="headerlink" title="6.1 收集器接口：Collector&lt;T,A,R&gt;"></a>6.1 收集器接口：<code>Collector&lt;T,A,R&gt;</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Supplier&lt;A&gt; <span class="title">supplier</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">BiConsumer&lt;A, T&gt; <span class="title">accumulator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Function&lt;A, R&gt; <span class="title">finisher</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">BinaryOperator&lt;A&gt; <span class="title">combiner</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span></span>;</span><br><span class="line">T：是流中要收集的元素的泛型。</span><br><span class="line">A：是累加器的类型，累加器是在收集过程中用于累积部分结果的对象。</span><br><span class="line">R 是收集操作得到的对象（通常但并不一定是集合）的类型</span><br></pre></td></tr></table></figure>

<h3 id="1-supplier：建立新的结果容器"><a href="#1-supplier：建立新的结果容器" class="headerlink" title="1 supplier：建立新的结果容器"></a>1 <code>supplier</code>：建立新的结果容器</h3><ol>
<li><code>supplier</code> 方法必须返回一个结果为空的 <code>Supplier</code> ，调用此 <code>Supplier</code> 时创建一个空的累加器实例（结果容器），供数据收集过程使用</li>
<li>累加器类型为 <code>A</code></li>
</ol>
<h3 id="2-accumulator：将元素添加到结果容器"><a href="#2-accumulator：将元素添加到结果容器" class="headerlink" title="2 accumulator：将元素添加到结果容器"></a>2 <code>accumulator</code>：将元素添加到结果容器</h3><ol>
<li><code>accumulator</code> 方法会返回执行归约操作的函数</li>
<li>返回的函数有两个参数（假设遍历到流中第 <code>n</code> 个元素）<ol>
<li>保存归约结果的累加器（已收集了流中的前 <code>n - 1</code> 个项目）</li>
<li>第 <code>n</code> 个元素本身</li>
</ol>
</li>
</ol>
<h3 id="3-finisher：对结果容器应用最终转换"><a href="#3-finisher：对结果容器应用最终转换" class="headerlink" title="3 finisher：对结果容器应用最终转换"></a>3 <code>finisher</code>：对结果容器应用最终转换</h3><ol>
<li>在遍历完流后， <code>finisher</code> 方法必须返回在累积过程的最后要调用的一个函数，以便将累加器对象转换为整个集合操作的最终结果</li>
<li>如果累加器对象恰好符合预期的最终结果，则无需进行转换，只需返回 <code>Function.identity()</code></li>
</ol>
<h3 id="4-combiner：合并两个结果容器"><a href="#4-combiner：合并两个结果容器" class="headerlink" title="4 combiner：合并两个结果容器"></a>4 <code>combiner</code>：合并两个结果容器</h3><ol>
<li><code>combiner</code> 方法会返回一个供归约操作使用的函数，它定义了对流的各个子部分进行并行处理时，各个子部分归约所得的累加器要如何合并</li>
<li>并行流使用，将多个线程产生的结果容器合并</li>
</ol>
<h3 id="5-characteristics"><a href="#5-characteristics" class="headerlink" title="5 characteristics"></a>5 <code>characteristics</code></h3><ol>
<li><code>characteristics</code> 会返回一个不可变的 <code>Characteristics</code> 集合，它定义了收集器的行为——尤其是关于流是否可以并行归约，以及可以使用哪些优化的提示</li>
<li><code>Characteristics</code> 是一个包含三个项目的枚举<ul>
<li><code>UNORDERED</code><ul>
<li>归约结果不受流中元素的遍历和累积顺序的影响</li>
</ul>
</li>
<li><code>CONCURRENT</code><ul>
<li><code>accumulator</code> 函数可以从多个线程同时调用，且该收集器可以并行归约流</li>
<li>如果收集器没有标为 <code>UNORDERED</code> ，那它仅在用于无序数据源时才可以并行归约</li>
</ul>
</li>
<li><code>IDENTITY_FINISH</code><ul>
<li>表明完成器方法返回的函数是一个恒等函数，可以跳过。</li>
<li>这种情况下，累加器对象将会直接用作归约过程的最终结果。这也意味着，将累加器 <code>A</code> 不加检查地转换为结果 <code>R</code> 是安全的</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="6-2-预定于收集器：Collectors"><a href="#6-2-预定于收集器：Collectors" class="headerlink" title="6.2 预定于收集器：Collectors"></a>6.2 预定于收集器：<code>Collectors</code></h2><h3 id="1-收集"><a href="#1-收集" class="headerlink" title="1 收集"></a>1 收集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()</span><br><span class="line">toMap()</span><br><span class="line">toConcurrentMap()</span><br><span class="line"><span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt; Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>toList</code></td>
<td><code>List&lt;T&gt;</code></td>
<td>把流中所有项目收集到一个 List（类型不确定）</td>
</tr>
<tr>
<td><code>toSet</code></td>
<td><code>Set&lt;T&gt;</code></td>
<td>把流中所有项目收集到一个 Set（类型不确定），删除重复项</td>
</tr>
<tr>
<td><code>toCollection</code></td>
<td><code>Collection&lt;T&gt;</code></td>
<td>把流中所有项目收集到给定的供应源创建的集合，既可以指定集合具体类型</td>
</tr>
</tbody></table>
<h3 id="2-归约和汇总"><a href="#2-归约和汇总" class="headerlink" title="2 归约和汇总"></a>2 归约和汇总</h3><h4 id="1-统计个数，最小-大值"><a href="#1-统计个数，最小-大值" class="headerlink" title="1 统计个数，最小/大值"></a>1 统计个数，最小/大值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Long&gt; counting()</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; minBy(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>counting</code></td>
<td><code>Long</code></td>
<td>计算流中元素的个数</td>
</tr>
<tr>
<td><code>minBy</code></td>
<td><code>Optional&lt;T&gt;</code></td>
<td>一个包裹了流中按照给定比较器选出的最小元素的 <code>Optional</code> ，或如果流为空则为 <code>Optional.empty()</code></td>
</tr>
<tr>
<td><code>maxBy</code></td>
<td><code>Optional&lt;T&gt;</code></td>
<td>一个包裹了流中按照给定比较器选出的最大元素的 <code>Optional</code> ，或如果流为空则为 <code>Optional.empty()</code></td>
</tr>
</tbody></table>
<h4 id="2-和-平均值"><a href="#2-和-平均值" class="headerlink" title="2 和/平均值"></a>2 和/平均值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Long&gt; summingLong(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; summingDouble(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingLong(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>summingInt</code></td>
<td><code>Integer</code></td>
<td>对流中元素的一个整数属性求和</td>
</tr>
<tr>
<td><code>summingLong</code></td>
<td><code>Long</code></td>
<td>对流中元素的一个长整型属性求和</td>
</tr>
<tr>
<td><code>summingDouble</code></td>
<td><code>Double</code></td>
<td>对流中元素的一个浮点型属性求和</td>
</tr>
<tr>
<td><code>averagingInt</code></td>
<td><code>Double</code></td>
<td>对流中元素的一个整数属性求平均值</td>
</tr>
<tr>
<td><code>averagingLong</code></td>
<td><code>Double</code></td>
<td>对流中元素的一个长整型属性求平均值</td>
</tr>
<tr>
<td><code>averagingDouble</code></td>
<td><code>Double</code></td>
<td>对流中元素的一个浮点型属性求平均值</td>
</tr>
</tbody></table>
<h4 id="3-统计个数-最小-大值-和-平均值"><a href="#3-统计个数-最小-大值-和-平均值" class="headerlink" title="3 统计个数 + 最小/大值 + 和/平均值"></a>3 统计个数 + 最小/大值 + 和/平均值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, LongSummaryStatistics&gt; summarizingLong(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, DoubleSummaryStatistics&gt; summarizingDouble(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>summarizingInt</code></td>
<td><code>IntSummaryStatistics</code></td>
<td>收集流中元素统计个数 + 最小/大值 + 和/平均值</td>
</tr>
<tr>
<td><code>summarizingLong</code></td>
<td><code>LongSummaryStatistics</code></td>
<td>收集流中元素统计个数 + 最小/大值 + 和/平均值</td>
</tr>
<tr>
<td><code>summarizingDouble</code></td>
<td><code>DoubleSummaryStatistics</code></td>
<td>收集流中元素统计个数 + 最小/大值 + 和/平均值</td>
</tr>
</tbody></table>
<ul>
<li><p>返回类型中提供了相应的 <code>getter</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getCount()</span><br><span class="line">getMin()</span><br><span class="line">getMax()</span><br><span class="line">getSum()</span><br><span class="line">getAverage()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="4-连接字符串"><a href="#4-连接字符串" class="headerlink" title="4 连接字符串"></a>4 连接字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static Collector&lt;CharSequence, ?, String&gt; joining()</span><br><span class="line">static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter)</span><br><span class="line">static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>joining</code></td>
<td><code>String</code></td>
<td>连接对流中每个元素调用 <code>toString</code> 方法所生成的字符串，可指定分隔符、前缀、后缀</td>
</tr>
</tbody></table>
<h4 id="5-广义的归约汇总"><a href="#5-广义的归约汇总" class="headerlink" title="5 广义的归约汇总"></a>5 广义的归约汇总</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; reducing(BinaryOperator&lt;T&gt; op)</span><br><span class="line">static &lt;T&gt; Collector&lt;T, ?, T&gt; reducing(T identity, BinaryOperator&lt;T&gt; op)</span><br><span class="line">static &lt;T, U&gt; Collector&lt;T, ?, U&gt; reducing(U identity, Function&lt;? super T, ? extends U&gt; mapper, BinaryOperator&lt;U&gt; op)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>reducing</code></td>
<td>归约操作产生的类型</td>
<td>从一个作为累加器的初始值开始，利用 <code>BinaryOperator</code> 与流中的元素逐个结合，从而将流归约为单个值</td>
</tr>
</tbody></table>
<ol>
<li>以上所有归约和汇总收集器都是 <code>reducing</code> 工厂方法定义的归约过程的特殊情况而已，仅仅是为了方便程序员使用而已</li>
<li>三个参数<ul>
<li>初始值</li>
<li>转换函数</li>
<li>累计函数</li>
</ul>
</li>
</ol>
<h3 id="3-分组"><a href="#3-分组" class="headerlink" title="3 分组"></a>3 分组</h3><h4 id="1-分组"><a href="#1-分组" class="headerlink" title="1 分组"></a>1 分组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一级分组：根据 T 的某个属性 K 分组，返回 Map&lt;K, list&lt;T&gt;&gt;</span></span><br><span class="line"><span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier)</span><br><span class="line"><span class="comment">// 多级分组：根据 T 的某个属性 K 分组，返回 Map&lt;K, list&lt;T&gt;&gt;，之后使用第三个参数队属性 K 收集，返回 Map&lt;K, D&gt;</span></span><br><span class="line"><span class="keyword">static</span> &lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier, Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream)</span><br><span class="line"><span class="comment">// 多级分组：可以自己提供 Map 类型</span></span><br><span class="line"><span class="keyword">static</span> &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt; Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier, Supplier&lt;M&gt; mapFactory, Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>groupingBy</code></td>
<td><code>Map&lt;K, List&lt;T&gt;&gt;</code></td>
<td>根据元素某个属性映射的值分组，并作为键，元素收集到 <code>List</code> 中作为值（单参数的 <code>groupingBy</code> 其实第二个参数省略了 <code>Collectors.toList()</code>）</td>
</tr>
<tr>
<td><code>groupingBy</code></td>
<td><code>Map&lt;K, D&gt;</code></td>
<td>根据元素某个属性映射的值分组，并作为键，第二个收集器返回值作为值</td>
</tr>
</tbody></table>
<ul>
<li><code>groupingByConcurrent</code> 返回的是 <code>ConcurrentMap</code></li>
</ul>
<h4 id="2-常与分组联合使用的收集器"><a href="#2-常与分组联合使用的收集器" class="headerlink" title="2 常与分组联合使用的收集器"></a>2 常与分组联合使用的收集器</h4><h5 id="1-collectingAndThen"><a href="#1-collectingAndThen" class="headerlink" title="1 collectingAndThen"></a>1 <code>collectingAndThen</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将第一个参数（旧收集器）的结果传入第二个参数（转换函数）返回新的类型</span><br><span class="line">static &lt;T, A, R, RR&gt; Collector&lt;T, A, RR&gt; collectingAndThen(Collector&lt;T, A, R&gt; downstream, Function&lt;R, RR&gt; finisher)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>collectingAndThen</code></td>
<td>转换函数返回的类型</td>
<td>包裹另一个收集器，对其结果应用转换函数</td>
</tr>
</tbody></table>
<h5 id="2-mapping"><a href="#2-mapping" class="headerlink" title="2 mapping"></a>2 <code>mapping</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T, U, A, R&gt; Collector&lt;T, ?, R&gt; mapping(Function&lt;? super T, ? extends U&gt; mapper, Collector&lt;? super U, A, R&gt; downstream)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>mapping</code></td>
<td>转换函数返回的类型</td>
<td>原收集器中的每个元素映射为一个新值，并使用一个新收集器收集</td>
</tr>
</tbody></table>
<h3 id="4-分区"><a href="#4-分区" class="headerlink" title="4 分区"></a>4 分区</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一级分区</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span><br><span class="line"><span class="comment">// 多级分区</span></span><br><span class="line"><span class="keyword">static</span> &lt;T, D, A&gt; Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate, Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>partitioningBy</code></td>
<td><code>Map&lt;Boolean,List&lt;T&gt;&gt;</code></td>
<td>根据对流中每个元素应用谓词的结果来对元素进行分区</td>
</tr>
</tbody></table>
<ol>
<li>分区是分组的特殊情况：由一个谓词（返回一个布尔值的函数）作为分类函数，它称分区函数</li>
<li>分区函数返回一个布尔值，这意味着得到的分组 Map 的键类型是 <code>Boolean</code> ，即最多可以分为两组—— <code>true</code> 是一组， <code>false</code> 是一组</li>
</ol>
<h1 id="七-基本类型流"><a href="#七-基本类型流" class="headerlink" title="七 基本类型流"></a>七 基本类型流</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ol>
<li>流操作基本类型时暗含装箱操作，Java8 提供了基本类型流来解决<ol>
<li><code>IntStream</code>：<code>byte short char int boolean</code></li>
<li><code>DoubleStream</code>：<code>float double</code></li>
<li><code>LongStream</code>：<code>long</code></li>
</ol>
</li>
<li><code>IntStream DoubleStream LongStream</code> 分别将流中的元素转为 <code>int double long</code> ，从而避免了暗含的装箱成本，且每个接口有新的常用数值归约方法以及转回对象流的方法</li>
</ol>
<h2 id="7-2-对象流与基本类型流的转换"><a href="#7-2-对象流与基本类型流的转换" class="headerlink" title="7.2 对象流与基本类型流的转换"></a>7.2 对象流与基本类型流的转换</h2><h3 id="1-对象流-→-基本类型流"><a href="#1-对象流-→-基本类型流" class="headerlink" title="1 对象流 → 基本类型流"></a>1 对象流 → 基本类型流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IntStream <span class="title">mapToInt</span><span class="params">(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span></span><br><span class="line"><span class="function">DoubleStream <span class="title">mapToDouble</span><span class="params">(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span></span><br><span class="line"><span class="function">LongStream <span class="title">mapToLong</span><span class="params">(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-基本类型流-→-对象流"><a href="#2-基本类型流-→-对象流" class="headerlink" title="2 基本类型流 → 对象流"></a>2 基本类型流 → 对象流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;Integer&gt; <span class="title">boxed</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Stream&lt;Double&gt; <span class="title">boxed</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Stream&lt;Long&gt; <span class="title">boxed</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&lt;U&gt; Stream&lt;U&gt; <span class="title">mapToObj</span><span class="params">(IntFunction&lt;? extends U&gt; mapper)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="7-3-IntStream"><a href="#7-3-IntStream" class="headerlink" title="7.3 IntStream"></a>7.3 <code>IntStream</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static IntStream</code></td>
<td><code>range(int start, int end)</code></td>
<td><code>[start, end)</code> 范围内数值构成流</td>
</tr>
<tr>
<td><code>static IntStream</code></td>
<td><code>rangeClosed(int start, int end)</code></td>
<td><code>[start, end]</code> 范围内数值构成流</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>sum()</code></td>
<td>求和</td>
</tr>
<tr>
<td><code>OptionalInt</code></td>
<td><code>max()</code></td>
<td>求最大值</td>
</tr>
<tr>
<td><code>OptionalInt</code></td>
<td><code>min()</code></td>
<td>求最小值</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>count()</code></td>
<td>统计个数</td>
</tr>
</tbody></table>
<h1 id="八-并行流"><a href="#八-并行流" class="headerlink" title="八 并行流"></a>八 并行流</h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><ol>
<li>并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流</li>
<li>并行流背后使用的基础架构是 Java 7 中引入的分支/合并框架（<code>Fork/Join</code>）</li>
</ol>
<h2 id="8-2-转换"><a href="#8-2-转换" class="headerlink" title="8.2 转换"></a>8.2 转换</h2><ol>
<li><code>parallel()</code>：顺序流 → 并行流</li>
<li><code>sequential()</code>：并行流 → 顺序流</li>
</ol>
<h2 id="8-3-Spliterator-lt-T-gt"><a href="#8-3-Spliterator-lt-T-gt" class="headerlink" title="8.3 Spliterator&lt;T&gt;"></a>8.3 <code>Spliterator&lt;T&gt;</code></h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/spliterator.png" alt=""></p>
<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>Spliterator</code> 是 Java 8中加入的一个新接口；这个名字代表“可分迭代器”（<code>splitable iterator</code>）</li>
<li>和 <code>Iterator</code> 一样， <code>Spliterator</code> 也用于遍历数据源中的元素，但它是为了并行执行而设计的</li>
<li>Java 8 为集合框架中包含的所有数据结构提供了一个默认的 <code>Spliterator</code> 实现</li>
</ol>
<h3 id="2-API"><a href="#2-API" class="headerlink" title="2 API"></a>2 API</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>tryAdvance(Consumer&lt;? super T&gt; action)</code></td>
<td>按顺序一个一个使用 <code>Spliterator</code> 中的元素，并且如果还有元素要遍历就返回 <code>true</code></td>
</tr>
<tr>
<td><code>Spliterator&lt;T&gt;</code></td>
<td><code>trySplit()</code></td>
<td>把一些元素划出去分给第二个 <code>Spliterator</code> （由该方法返回），让它们两个并行处理。当返回 <code>null</code> 时 ，表明它处理的数据结构不能再分割</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>estimateSize()</code></td>
<td>估计还剩下多少元素要遍历</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>characteristics()</code></td>
<td>返回一个 <code>int</code> ，代表 <code>Spliterator</code> 本身特性集的编码</td>
</tr>
</tbody></table>
<h3 id="3-特性"><a href="#3-特性" class="headerlink" title="3 特性"></a>3 特性</h3><table>
<thead>
<tr>
<th>特性 <code>int</code></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ORDERED</code></td>
<td>元素有既定的顺序（例如 <code>List</code> ），因此 <code>Spliterator</code> 在遍历和划分时也会遵循这一顺序</td>
</tr>
<tr>
<td><code>DISTINCT</code></td>
<td>对于任意一对遍历过的元素 x 和 y ， <code>x.equals(y)</code> 返回 <code>false</code></td>
</tr>
<tr>
<td><code>SORTED</code></td>
<td>遍历的元素按照一个预定义的顺序排序</td>
</tr>
<tr>
<td><code>SIZED</code></td>
<td>该 <code>Spliterator</code> 由一个已知大小的源建立（例如 <code>Set</code> ），因此 <code>estimatedSize()</code> 返回的是准确值</td>
</tr>
<tr>
<td><code>NONNULL</code></td>
<td>保证遍历的元素不会为 <code>null</code></td>
</tr>
<tr>
<td><code>IMMUTABLE</code></td>
<td><code>Spliterator</code> 的数据源不能修改。这意味着在遍历时不能添加、删除或修改任何元素</td>
</tr>
<tr>
<td><code>CONCURRENT</code></td>
<td>该 <code>Spliterator</code> 的数据源可以被其他线程同时修改而无需同步</td>
</tr>
<tr>
<td><code>SUBSIZED</code></td>
<td>该 <code>Spliterator</code> 和所有从它拆分出来的 <code>Spliterator</code> 都是 <code>SIZED</code></td>
</tr>
</tbody></table>
<h1 id="九-java-util-Optional-lt-T-gt"><a href="#九-java-util-Optional-lt-T-gt" class="headerlink" title="九 java.util.Optional&lt;T&gt;"></a>九 <code>java.util.Optional&lt;T&gt;</code></h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><ol>
<li><code>Optional&lt;T&gt;</code> 是一种包装器对象，且只包装一个对象：<code>T</code> 或 <code>null</code><ul>
<li>对象存在时，则返回封装对象的 <code>Optional</code></li>
<li>对象不存在时，由方法 <code>Optional.empty()</code> 返回一个空的 <code>Optional</code></li>
</ul>
</li>
<li>使用原则<ul>
<li>不能为 <code>null</code> 的属性正常声明 <code>T</code></li>
<li>可能为 <code>null</code> 的属性声明为 <code>Optional&lt;T&gt;</code></li>
</ul>
</li>
<li><code>Optional&lt;T&gt;</code> 也有三个基本类型版本：<code>OptionalInt、OptionalDouble、OptionalLong</code></li>
</ol>
<h2 id="9-2-API"><a href="#9-2-API" class="headerlink" title="9.2 API"></a>9.2 API</h2><h3 id="1-创建-Optional"><a href="#1-创建-Optional" class="headerlink" title="1 创建 Optional"></a>1 创建 <code>Optional</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static &lt;T&gt; Optional&lt;T&gt;</code></td>
<td><code>empty()</code></td>
<td>返回空的 <code>Optional</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; Optional&lt;T&gt;</code></td>
<td><code>of​(T t)</code></td>
<td>将指定值用 <code>Optional</code> 封装之后返回，如果该值为 <code>null</code> ，则抛出一个 <code>NullPointerException</code> 异常</td>
</tr>
<tr>
<td><code>static &lt;T&gt; Optional&lt;T&gt;</code></td>
<td><code>ofNullable​(T t)</code></td>
<td>将指定值用 <code>Optional</code> 封装之后返回，如果该值为 <code>null</code> ，则返回一个空的 <code>Optional</code> 对象</td>
</tr>
</tbody></table>
<h3 id="2-获取-Optional-容器中的值"><a href="#2-获取-Optional-容器中的值" class="headerlink" title="2 获取 Optional 容器中的值"></a>2 获取 <code>Optional</code> 容器中的值</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>T</code></td>
<td><code>get()</code></td>
<td>如果值存在则返回，否则抛 <code>NoSuchElementException</code> 异常</td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>orElse​(T other)</code></td>
<td>如果值存在则返回，否则返回 <code>other</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>orElseGet​(Supplier&lt;? extends T&gt; supplier)</code></td>
<td>如果值存在则返回，否则返回由 <code>Supplier</code> 提供的值</td>
</tr>
<tr>
<td><code>&lt;X extends Throwable&gt; T</code></td>
<td><code>orElseThrow​(Supplier&lt;? extends X&gt; exceptionSupplier)</code></td>
<td>如果值存在则返回，否则抛出由 <code>Supplier</code> 提供的异常</td>
</tr>
</tbody></table>
<h3 id="3-操作-Optional-中的值"><a href="#3-操作-Optional-中的值" class="headerlink" title="3 操作 Optional 中的值"></a>3 操作 <code>Optional</code> 中的值</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>isPresent()</code></td>
<td>如果值存在就返回 <code>true</code> ，否则返回 <code>false</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>ifPresent​(Consumer&lt;? super T&gt; action)</code></td>
<td>如果值存在则传递给 <code>action</code> 执行；否则就不进行任何操作</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)</code></td>
<td>如果值存在则传递给 <code>action</code> 执行；否则调用 <code>emptyAction</code></td>
</tr>
<tr>
<td><code>&lt;U&gt; Optional&lt;U&gt;</code></td>
<td><code>map​(Function&lt;? super T,​? extends U&gt; mapper)</code></td>
<td>如果值存在则映射一个新值（如果映射值为 <code>null</code> 会空指针异常），然后返回存储新值的 <code>Optional</code>；否则返回空的 <code>Optional</code></td>
</tr>
<tr>
<td><code>&lt;U&gt; Optional&lt;U&gt;</code></td>
<td><code>flatMap​(Function&lt;? super T,​? extends Optional&lt;? extends U&gt;&gt; mapper)</code></td>
<td><code>map</code> 方法的问题在于如果映射成的值还是一个 <code>Optional</code>，会形成多层 <code>Optional&lt;Optional&lt;T&gt;&gt;</code>，此方法能将多层的 <code>Optional</code> 合并为一个</td>
</tr>
<tr>
<td><code>Optional&lt;T&gt;</code></td>
<td><code>filter​(Predicate&lt;? super T&gt; predicate)</code></td>
<td>如果值存在并且满足提供的谓词，就返回包含该值的 <code>Optional</code> 对象；否则返回空的 <code>Optional</code> 对象</td>
</tr>
<tr>
<td><code>Optional&lt;T&gt;</code></td>
<td><code>or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</code></td>
<td>如果值存在，则返回存储此值的 <code>Optional</code>，否则返回由 <code>Supplier</code> 提供的 <code>Optional</code></td>
</tr>
</tbody></table>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/flatmap.png" alt=""></p>
<h3 id="4-其它"><a href="#4-其它" class="headerlink" title="4 其它"></a>4 其它</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Stream&lt;T&gt;</code></td>
<td><code>stream()</code></td>
<td>如果值存在则获取只包含此元素的流，否则获取空流</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/09/29/Java/Java-Lambda/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/09/29/Java/Java-Lambda/" class="post-title-link" itemprop="url">Java-Lambda</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-09-29 16:01:27 / 修改时间：16:01:40" itemprop="dateCreated datePublished" datetime="2020-09-29T16:01:27+08:00">2020-09-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-Lambda-概述"><a href="#一-Lambda-概述" class="headerlink" title="一 Lambda 概述"></a>一 Lambda 概述</h1><ol>
<li>Lambda 是一个匿名函数，但在 Java 中 Lambda 表达式的本质是函数式接口的一个实例，也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用 Lambda 表达式来表示</li>
<li>Lambda 需要函数式接口的支持</li>
<li>闭包<ol>
<li>在 Lambda 表达式中引用了局部变量，会形成闭包，延长局部变量声明周期</li>
<li>此被引用的局部变量会变成 <code>final</code> 的</li>
</ol>
</li>
</ol>
<h1 id="二-Lambda-语法"><a href="#二-Lambda-语法" class="headerlink" title="二 Lambda 语法"></a>二 Lambda 语法</h1><h2 id="2-1-基础语法"><a href="#2-1-基础语法" class="headerlink" title="2.1 基础语法"></a>2.1 基础语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(形参列表) -&gt; &#123;方法体&#125;</span><br><span class="line"><span class="comment">// 形参列表：对应函数式接口中抽象方法的形参列表</span></span><br><span class="line"><span class="comment">// 方法体：即重写的函数式接口中抽象方法的方法体</span></span><br></pre></td></tr></table></figure>

<ol>
<li>参数类型可以省略（类型推断）</li>
<li>当且仅当参数只有一个时，可以省略小括号</li>
<li>如果方法体只有一句，可以省略大括号</li>
<li>如果方法体只有一句且是返回语句，大括号和 <code>return</code> 要一致<ul>
<li>省略大括号的同时必须省略 <code>return</code> 关键字</li>
<li>不省略大括号那么也不能省略 <code>return</code> 关键字</li>
</ul>
</li>
</ol>
<h2 id="2-2-方法引用"><a href="#2-2-方法引用" class="headerlink" title="2.2 方法引用"></a>2.2 方法引用</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><p>方法引用即将 Lambda 表达式的实现指向一个已经实现的方法，也就是说通过调用一个现有的方法来完成功能</p>
</li>
<li><p>方法引用其实返回的就是一个函数式接口的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只要符合条件就能当成对应函数式接口的实例</span></span><br><span class="line"><span class="comment">// 所谓的符合条件：引用的方法与函数式接口的抽象方法有着相同形参和返回值，比如接收一个类型的参数，返回另一个类型...</span></span><br><span class="line">Consumer consumer = System.out::println;</span><br><span class="line">Runable runable = System.out::println;</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件</p>
<ol>
<li>引用方法的形参列表（数量、顺序和类型）必须与接口中的方法一致<ul>
<li>特殊情况：接口中方法的第一个形参是方法的调用者，剩余形参与引用方法一致（即指向类的实例方法的方法引用）</li>
</ul>
</li>
<li>引用方法的返回值必须和接口中的方法一致</li>
</ol>
</li>
</ol>
<h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2 语法"></a>2 语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line">方法隶属者::方法名</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有三种使用情况</span></span><br><span class="line">对象::实例方法名</span><br><span class="line">类::静态方法名</span><br><span class="line">类::实例方法名</span><br></pre></td></tr></table></figure>

<ol>
<li><p>指向对象的实例方法的方法引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(args) -&gt; expr.instanceMethod(args)</span><br><span class="line">expr::instanceMethod</span><br></pre></td></tr></table></figure>
</li>
<li><p>指向类的静态方法的方法引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(args) -&gt; ClassName.staticMethod(args)</span><br><span class="line">CLassName::staticMethod</span><br></pre></td></tr></table></figure>
</li>
<li><p>指向类的实例方法的方法引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(arg0, rest) -&gt; arg0.instanceMethod(rest)</span><br><span class="line">CLassName::instanceMethod</span><br><span class="line"><span class="comment">// arg0 是 ClassName 类型的实例，即是实例方法的调用者又是方法的第一个参数</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="2-3-构造器引用"><a href="#2-3-构造器引用" class="headerlink" title="2.3 构造器引用"></a>2.3 构造器引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类::<span class="keyword">new</span></span><br></pre></td></tr></table></figure>

<ol>
<li>构造器形参列表要与函数式接口中抽象方法的形参列表一致</li>
<li>新创建的对象与函数式接口中抽象方法的返回值一致</li>
</ol>
<h2 id="2-4-数组引用"><a href="#2-4-数组引用" class="headerlink" title="2.4 数组引用"></a>2.4 数组引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组类型[]::<span class="keyword">new</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以把数组看作一个构造器</li>
</ul>
<h1 id="三-函数式接口"><a href="#三-函数式接口" class="headerlink" title="三 函数式接口"></a>三 函数式接口</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol>
<li><code>SAM：Simple Abstract Method</code></li>
<li>有且仅有一个抽象方法的接口就是函数式接口，可以有其它方法（静态，默认…）</li>
<li><code>@FunctionalInterface</code>：此注解用来标识函数式接口</li>
<li><code>java.lang.util.function</code> 包下定义了许多函数式接口</li>
</ol>
<h2 id="3-2-常用函数式接口"><a href="#3-2-常用函数式接口" class="headerlink" title="3.2 常用函数式接口"></a>3.2 常用函数式接口</h2><table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>接口方法</th>
<th>说明</th>
<th>原始类型特化</th>
</tr>
</thead>
<tbody><tr>
<td><code>Predicate&lt;T&gt;</code></td>
<td><code>T</code></td>
<td><code>boolean</code></td>
<td><code>boolean test(T t)</code></td>
<td>传入 <code>T</code>，返回布尔值</td>
<td><code>IntPredicate</code><br><code>LongPredicate</code><br/><code>DoublePredicate</code></td>
</tr>
<tr>
<td><code>BiPredicate&lt;T, U&gt;</code></td>
<td><code>T, U</code></td>
<td><code>boolean</code></td>
<td><code>boolean test(T t, U u)</code></td>
<td>传入 <code>T U</code>，返回布尔值</td>
<td></td>
</tr>
<tr>
<td><code>Consumer&lt;T&gt;</code></td>
<td><code>T</code></td>
<td><code>void</code></td>
<td><code>void accept(T t)</code></td>
<td>传入 <code>T</code>，无返回</td>
<td><code>IntConsumer</code><br><code>LongConsumer</code><br/><code>DoubleConsumer</code></td>
</tr>
<tr>
<td><code>BiConsumer&lt;T, U&gt;</code></td>
<td><code>T, U</code></td>
<td><code>void</code></td>
<td><code>void accept(T t, U u)</code></td>
<td>传入 <code>T U</code>，无返回</td>
<td><code>ObjIntConsumer&lt;T&gt;</code><br><code>ObjLongConsumer&lt;T&gt;</code><br><code>ObjDoubleConsumer&lt;T&gt;</code></td>
</tr>
<tr>
<td><code>Supplier&lt;T&gt;</code></td>
<td><code>无</code></td>
<td><code>T</code></td>
<td><code>T get()</code></td>
<td>无传入，返回 <code>T</code></td>
<td><code>IntSupplier</code><br><code>BooleanSupplier</code><br/><code>LongSupplier</code><br/><code>DoubleSupplier</code></td>
</tr>
<tr>
<td><code>Function&lt;T, R&gt;</code></td>
<td><code>T</code></td>
<td><code>R</code></td>
<td><code>R apply(T t)</code></td>
<td>传入 <code>T</code>，返回 <code>R</code></td>
<td><code>IntFunction&lt;R&gt;</code><br><code>LongFunction&lt;R&gt;</code><br/><code>DoubleFunction&lt;R&gt;</code><br><code>ToIntFunction&lt;T&gt;</code><br><code>ToLongFunction&lt;T&gt;</code><br/><code>ToDoubleFunction&lt;T&gt;</code><br><code>IntToLongFunction</code><br><code>IntToDoubleFunction</code><br/><code>LongToIntFunction</code><br/><code>LongToDoubleFunction</code></td>
</tr>
<tr>
<td><code>UnaryOperator&lt;T&gt;</code></td>
<td><code>T</code></td>
<td><code>T</code></td>
<td><code>T apply(T t)</code></td>
<td>传入 <code>T</code>，返回 <code>T</code>，继承 <code>Function&lt;T, T&gt;</code> 接口</td>
<td><code>IntUnaryOperator</code><br><code>LongUnaryOperator</code><br><code>DoubleUnaryOperator</code></td>
</tr>
<tr>
<td><code>BiFunction&lt;T, U, R&gt;</code></td>
<td><code>T, U</code></td>
<td><code>R</code></td>
<td><code>R apply(T t, U u)</code></td>
<td>传入 <code>T U</code> ，返回 <code>R</code></td>
<td><code>ToIntBiFunction&lt;T,U&gt;</code><br><code>ToLongBiFunction&lt;T,U&gt;</code><br><code>ToDoubleBiFunction&lt;T,U&gt;</code></td>
</tr>
<tr>
<td><code>BinaryOperator&lt;T&gt;</code></td>
<td><code>T, T</code></td>
<td><code>T</code></td>
<td><code>T apply(T t1, T t2)</code></td>
<td>传入 <code>T T</code> ，返回 <code>T</code>，继承 <code>BiFunction&lt;T, T, T&gt;</code> 接口</td>
<td><code>IntBinaryOperator</code><br><code>LongBinaryOperator</code><br><code>DoubleBinaryOperator</code></td>
</tr>
<tr>
<td><code>Runnable</code></td>
<td><code>无</code></td>
<td><code>void</code></td>
<td><code>void run()</code></td>
<td>无传入，无返回</td>
<td></td>
</tr>
<tr>
<td><code>Comparator&lt;T&gt;</code></td>
<td><code>T, T</code></td>
<td><code>int</code></td>
<td><code>int compare(T t1, T t2)</code></td>
<td>传入 <code>T T</code>，返回 <code>int</code></td>
<td></td>
</tr>
</tbody></table>
<h2 id="3-3-复合-Lambda-表达式的有用方法"><a href="#3-3-复合-Lambda-表达式的有用方法" class="headerlink" title="3.3 复合 Lambda 表达式的有用方法"></a>3.3 复合 Lambda 表达式的有用方法</h2><h3 id="1-比较器复合"><a href="#1-比较器复合" class="headerlink" title="1 比较器复合"></a>1 比较器复合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">逆序：reversed</span><br><span class="line">比较器链：thenComparing</span><br></pre></td></tr></table></figure>

<h3 id="2-谓词复合"><a href="#2-谓词复合" class="headerlink" title="2 谓词复合"></a>2 谓词复合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">非：negate</span><br><span class="line">与：and</span><br><span class="line">或：or</span><br></pre></td></tr></table></figure>

<h3 id="3-函数复合"><a href="#3-函数复合" class="headerlink" title="3 函数复合"></a>3 函数复合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">andThen</span><br><span class="line">	f.anThen(g)：先执行 f 后 执行 g，即 g(f(x))</span><br><span class="line">compose</span><br><span class="line">	f.compose(g)：先执行 g 后 执行 f，即 f(g(x))</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/09/29/Java/Java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/09/29/Java/Java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Java-网络编程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-09-29 16:00:45 / 修改时间：16:01:02" itemprop="dateCreated datePublished" datetime="2020-09-29T16:00:45+08:00">2020-09-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-网络模型"><a href="#1-1-网络模型" class="headerlink" title="1.1 网络模型"></a>1.1 网络模型</h2><h3 id="1-OSI（Open-System-Interconnection）"><a href="#1-OSI（Open-System-Interconnection）" class="headerlink" title="1 OSI（Open System Interconnection）"></a>1 OSI（<code>Open System Interconnection</code>）</h3><table>
<thead>
<tr>
<th>层</th>
<th>说明</th>
<th>相关协议</th>
</tr>
</thead>
<tbody><tr>
<td><code>应用层</code></td>
<td>网络服务和最终用户的接口</td>
<td><code>HTTP HTTPS FTP SMTP POP3 DNS ...</code></td>
</tr>
<tr>
<td><code>表示层</code></td>
<td>数据的表示、安全、压缩</td>
<td></td>
</tr>
<tr>
<td><code>会话层</code></td>
<td>建立、管理和终止会话</td>
<td></td>
</tr>
<tr>
<td><code>传输层</code></td>
<td>定义传输数据的协议端口号，以及流量控制和差错校验</td>
<td><code>TCP UDP</code></td>
</tr>
<tr>
<td><code>网络层</code></td>
<td>进行逻辑地址寻找，实现不同网络间的路径选择</td>
<td><code>IP ARP RARP ICMP IGMP ...</code></td>
</tr>
<tr>
<td><code>数据链路层</code></td>
<td>建立逻辑连接、进行硬件地址寻址、差错校验等功能</td>
<td><code>MAC</code> 地址</td>
</tr>
<tr>
<td><code>物理层</code></td>
<td>建立，维护，断开物理连接</td>
<td></td>
</tr>
</tbody></table>
<h3 id="2-TCP-IP-分层模型"><a href="#2-TCP-IP-分层模型" class="headerlink" title="2 TCP/IP 分层模型"></a>2 TCP/IP 分层模型</h3><table>
<thead>
<tr>
<th>层</th>
<th>相关协议</th>
</tr>
</thead>
<tbody><tr>
<td><code>应用层</code></td>
<td><code>HTTP HTTPS FTP DNS ...</code></td>
</tr>
<tr>
<td><code>传输层</code></td>
<td><code>TCP UDP</code></td>
</tr>
<tr>
<td><code>网络层</code></td>
<td><code>IP ARP ICMP...</code></td>
</tr>
<tr>
<td><code>物理+数据链路层</code></td>
<td>硬件层面</td>
</tr>
</tbody></table>
<h2 id="1-2-网络编程"><a href="#1-2-网络编程" class="headerlink" title="1.2 网络编程"></a>1.2 网络编程</h2><ol>
<li>目的：直接或间接的通过网络协议与其它计算机通信，进行数据交换</li>
<li>两个问题：<ul>
<li>如何准确定位网络上的一台或多台主机，以及如果定位主机上特定的应用</li>
<li>定位后，如何可靠高速的进行数据传输</li>
</ul>
</li>
</ol>
<h2 id="1-3-网络通信三要素"><a href="#1-3-网络通信三要素" class="headerlink" title="1.3 网络通信三要素"></a>1.3 网络通信三要素</h2><ol>
<li>IP 地址：确定设备</li>
<li>端口：确定设备上的程序</li>
<li>网络协议</li>
</ol>
<h2 id="1-4-常见端口"><a href="#1-4-常见端口" class="headerlink" title="1.4 常见端口"></a>1.4 常见端口</h2><table>
<thead>
<tr>
<th>服务</th>
<th>端口</th>
</tr>
</thead>
<tbody><tr>
<td><code>HTTP</code></td>
<td><code>80</code></td>
</tr>
<tr>
<td><code>HTTPS</code></td>
<td><code>443</code></td>
</tr>
<tr>
<td><code>SSH</code></td>
<td><code>22</code></td>
</tr>
<tr>
<td><code>Tomcat</code></td>
<td><code>8080</code></td>
</tr>
<tr>
<td><code>MySQL</code></td>
<td><code>3306</code></td>
</tr>
<tr>
<td><code>Oracle</code></td>
<td><code>1521</code></td>
</tr>
<tr>
<td><code>SMTP</code></td>
<td><code>25</code></td>
</tr>
<tr>
<td><code>POP3</code></td>
<td><code>110</code></td>
</tr>
</tbody></table>
<h1 id="二-java-net-InetAddress"><a href="#二-java-net-InetAddress" class="headerlink" title="二 java.net.InetAddress"></a>二 <code>java.net.InetAddress</code></h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol>
<li>用来包装 IP 地址对象</li>
<li>子类<ol>
<li><code>Inet4Address</code></li>
<li><code>Inet6Address</code></li>
</ol>
</li>
</ol>
<h2 id="2-2-方法"><a href="#2-2-方法" class="headerlink" title="2.2 方法"></a>2.2 方法</h2><h3 id="1-获取-IP-对象"><a href="#1-获取-IP-对象" class="headerlink" title="1 获取 IP 对象"></a>1 获取 IP 对象</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static InetAddress</code></td>
<td><code>getLocalHost()</code></td>
<td>获取本地主机 IP 对象，等价于 <code>getByName(&quot;127.0.0.1&quot;)</code></td>
</tr>
<tr>
<td><code>static InetAddress</code></td>
<td><code>getByName​(String host)</code></td>
<td>根据主机名（<code>ip</code> 或 域名）获取 IP 对象</td>
</tr>
</tbody></table>
<h3 id="2-获取主机信息"><a href="#2-获取主机信息" class="headerlink" title="2 获取主机信息"></a>2 获取主机信息</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>getHostName()</code></td>
<td>获取主机名（域名）</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getHostAddress()</code></td>
<td>获取主机 IP 地址</td>
</tr>
</tbody></table>
<h1 id="三-Socket"><a href="#三-Socket" class="headerlink" title="三 Socket"></a>三 <code>Socket</code></h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol>
<li>IP 和端口组合得出一个网络套接字：<code>Socket</code></li>
<li><code>Socket</code> 是网络通信的一种机制，是两台机器间通信的端点</li>
<li>分类<ol>
<li>流套接字（TCP）</li>
<li>数据报套接字（UDP）</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>java.net.Socket</code></td>
<td>TCP 客户端 Socket</td>
</tr>
<tr>
<td><code>java.net.ServerSocket</code></td>
<td>TCP 服务端 Socket</td>
</tr>
<tr>
<td><code>java.net.DatagramSocket</code></td>
<td>UDP Socket</td>
</tr>
<tr>
<td><code>java.net.DatagramPacket</code></td>
<td>UDP 数据包</td>
</tr>
</tbody></table>
<h2 id="3-2-TCP"><a href="#3-2-TCP" class="headerlink" title="3.2 TCP"></a>3.2 TCP</h2><h3 id="1-java-net-Socket（客户端）"><a href="#1-java-net-Socket（客户端）" class="headerlink" title="1 java.net.Socket（客户端）"></a>1 <code>java.net.Socket</code>（客户端）</h3><h4 id="1-构造"><a href="#1-构造" class="headerlink" title="1 构造"></a>1 构造</h4><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Socket​(String host, int port)</code></td>
<td>指定服务端主机地址，以及要连接的服务端口</td>
</tr>
<tr>
<td><code>Socket​(InetAddress address, int port)</code></td>
<td>指定服务端主机 IP 地址对象，以及要连接的服务端口</td>
</tr>
</tbody></table>
<h4 id="2-方法"><a href="#2-方法" class="headerlink" title="2 方法"></a>2 方法</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>InputStream</code></td>
<td><code>getInputStream()</code></td>
<td>获取字节输入流</td>
</tr>
<tr>
<td><code>OutputStream</code></td>
<td><code>getOutputStream()</code></td>
<td>获取字节输出流</td>
</tr>
<tr>
<td><code>InetAddress</code></td>
<td><code>getLocalAddress()</code></td>
<td>获取 <code>Socket</code> 绑定的本地主机 IP 对象</td>
</tr>
<tr>
<td><code>InetAddress</code></td>
<td><code>getInetAddress()</code></td>
<td>获取 <code>Socket</code> 连接的主机 IP 对象</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>shutdownInput()</code></td>
<td>关闭 Socket 输入通道</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>shutdownOutput()</code></td>
<td>关闭 Socket 输出通道</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>close()</code></td>
<td>关闭 <code>Socket</code>，会自动关闭流</td>
</tr>
</tbody></table>
<h3 id="2-java-net-ServerSocket（服务端）"><a href="#2-java-net-ServerSocket（服务端）" class="headerlink" title="2 java.net.ServerSocket（服务端）"></a>2 <code>java.net.ServerSocket</code>（服务端）</h3><h4 id="1-构造-1"><a href="#1-构造-1" class="headerlink" title="1 构造"></a>1 构造</h4><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ServerSocket​(int port)</code></td>
<td>指定服务监听端口</td>
</tr>
</tbody></table>
<h4 id="2-方法-1"><a href="#2-方法-1" class="headerlink" title="2 方法"></a>2 方法</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Socket</code></td>
<td><code>accept()</code></td>
<td>等待并接收客户端连接，阻塞方法</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>close()</code></td>
<td>关闭 Socket，会自动关闭流</td>
</tr>
</tbody></table>
<h3 id="3-应用"><a href="#3-应用" class="headerlink" title="3 应用"></a>3 应用</h3><h4 id="1-客户端"><a href="#1-客户端" class="headerlink" title="1 客户端"></a>1 客户端</h4><ol>
<li>创建 <code>Socket</code> 对象</li>
<li>使用 <code>Socket</code> 对象获取输入输出流来读写</li>
<li>关闭 <code>Socket</code></li>
</ol>
<h4 id="2-服务端"><a href="#2-服务端" class="headerlink" title="2 服务端"></a>2 服务端</h4><ol>
<li>创建 <code>ServerSocket</code> 对象，指定监听端口</li>
<li>使用 <code>ServerSokcet</code> 接收客户端 <code>Socket</code></li>
<li>使用 <code>Socket</code> 对象获取输入输出流来读写</li>
<li>关闭 <code>Socket</code></li>
</ol>
<h3 id="4-注意：如果服务端和客户端都等待"><a href="#4-注意：如果服务端和客户端都等待" class="headerlink" title="4 注意：如果服务端和客户端都等待"></a>4 注意：如果服务端和客户端都等待</h3><ol>
<li>数据没有刷新，使用 <code>BufferedReader</code> 包装字节输入流时，<code>readLIne()</code> 结束标记是换行符<ol>
<li>使用 <code>PrintStream</code> 包装字节输出流，可以自动刷新，如使用 <code>println()</code> </li>
<li>使用 <code>PrintWrter</code> 包装字节输出流，使用 <code>println()</code> 需要手动刷新或者构造函数中设置自动刷新</li>
<li>使用 <code>BufferedWriter</code> 包装字节输出流，输出后需要 <code>newLine()</code></li>
</ol>
</li>
<li>阻塞式方法没有结束标记<ul>
<li><code>void shutdownInput()</code></li>
<li>``void shutdownOutput()`</li>
</ul>
</li>
</ol>
<h3 id="5-服务端接收多个客户端连接"><a href="#5-服务端接收多个客户端连接" class="headerlink" title="5 服务端接收多个客户端连接"></a>5 服务端接收多个客户端连接</h3><ol>
<li><p>将每个客户端的业务封装为线程任务</p>
</li>
<li><p>使用多线程实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket ss=<span class="keyword">new</span> ServerSocket(<span class="number">8866</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">	Socket socket = ss.accept();</span><br><span class="line">	<span class="keyword">new</span> ClientTask(socket).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="3-3-UDP"><a href="#3-3-UDP" class="headerlink" title="3.3 UDP"></a>3.3 UDP</h2><h3 id="1-java-net-DatagramSocket"><a href="#1-java-net-DatagramSocket" class="headerlink" title="1 java.net.DatagramSocket"></a>1 <code>java.net.DatagramSocket</code></h3><h4 id="1-构造-2"><a href="#1-构造-2" class="headerlink" title="1 构造"></a>1 构造</h4><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>DatagramSocket()</code></td>
<td>发送端不用指定端口</td>
</tr>
<tr>
<td><code>DatagramSocket(int port)</code></td>
<td>接收端需要指定端口</td>
</tr>
</tbody></table>
<h4 id="2-方法-2"><a href="#2-方法-2" class="headerlink" title="2 方法"></a>2 方法</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>send(DatagramPacket p)</code></td>
<td>发送数据包</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>receive(DatagramPacket p)</code></td>
<td>接收数据包</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>close()</code></td>
<td>关闭 Socket，会自动关闭流</td>
</tr>
</tbody></table>
<h3 id="2-java-net-DatagramPacket"><a href="#2-java-net-DatagramPacket" class="headerlink" title="2 java.net.DatagramPacket"></a>2 <code>java.net.DatagramPacket</code></h3><h4 id="1-构造-3"><a href="#1-构造-3" class="headerlink" title="1 构造"></a>1 构造</h4><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>DatagramPacket​(byte[] buf, int length)</code></td>
<td>接收端接收数据包</td>
</tr>
<tr>
<td><code>DatagramPacket​(byte[] buf, int length, InetAddress address, int port)</code></td>
<td>发送端打包需要指定接收端 IP 和 Port</td>
</tr>
</tbody></table>
<h4 id="2-方法-3"><a href="#2-方法-3" class="headerlink" title="2 方法"></a>2 方法</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte[]</code></td>
<td><code>getData()</code></td>
<td>接收的数据</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getLength()</code></td>
<td>接收的数据实际长度</td>
</tr>
</tbody></table>
<h3 id="3-应用-1"><a href="#3-应用-1" class="headerlink" title="3 应用"></a>3 应用</h3><h4 id="1-发送端"><a href="#1-发送端" class="headerlink" title="1 发送端"></a>1 发送端</h4><ol>
<li>创建 <code>DatagramSocket</code>，不需端口</li>
<li>创建 <code>DatagramPacket</code> 数据包，指定数据存储数组，长度，接收端 IP 和 Port</li>
<li>发送数据包</li>
<li>关闭 <code>DatagramSocket</code></li>
</ol>
<h4 id="2-接收端"><a href="#2-接收端" class="headerlink" title="2 接收端"></a>2 接收端</h4><ol>
<li>创建 <code>DatagramSocket</code>，指定端口</li>
<li>创建 <code>DatagramPacket</code>，指定数据存储数组，长度</li>
<li>接收数据包</li>
<li>从数据包提取数据</li>
<li>关闭 <code>DatagramSocket</code></li>
</ol>
<h1 id="四-java-net-URL"><a href="#四-java-net-URL" class="headerlink" title="四 java.net.URL"></a>四 <code>java.net.URL</code></h1><h2 id="4-1-构造"><a href="#4-1-构造" class="headerlink" title="4.1 构造"></a>4.1 构造</h2><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>URL​(String spec)</code></td>
<td>根据 URL 地址字符串构造 URL 对象</td>
</tr>
<tr>
<td><code>URL​(String protocol, String host, int port, String file)</code></td>
<td>根据指定 protocol、host、port 号和 file 创建 URL 对象</td>
</tr>
</tbody></table>
<h2 id="4-2-方法"><a href="#4-2-方法" class="headerlink" title="4.2 方法"></a>4.2 方法</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>getProtocol()</code></td>
<td>获取此 URL 的协议名称</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getHost()</code></td>
<td>获取此 URL 的主机地址</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getPort()</code></td>
<td>获取此 URL 的端口号</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getFile()</code></td>
<td>获取此 URL 的文件资源路径（完整 URI）</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getPath()</code></td>
<td>获取此 URL 的路径部分（URI不带参数）</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getQuery()</code></td>
<td>获取此 URL 的查询部分（参数）</td>
</tr>
<tr>
<td><code>URLConnection</code></td>
<td><code>openConnection()</code></td>
<td>返回一个 <code>URLConnection</code> 对象，它表示到 URL 所引用的远程对象的连接</td>
</tr>
<tr>
<td><code>InputStream</code></td>
<td><code>openStream()</code></td>
<td>打开到此 URL 的连接并返回一个用于从该连接读入的 <code>InputStream</code></td>
</tr>
</tbody></table>
<h1 id="五-java-net-URLConnection"><a href="#五-java-net-URLConnection" class="headerlink" title="五 java.net.URLConnection"></a>五 <code>java.net.URLConnection</code></h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol>
<li>URL 连接器对象</li>
<li>表示与 URL 建立的通信连接</li>
</ol>
<h2 id="5-2-方法"><a href="#5-2-方法" class="headerlink" title="5.2 方法"></a>5.2 方法</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>URL</code></td>
<td><code>getURL()</code></td>
<td>获取此链接的 URL 对象</td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code>connect()</code></td>
<td>连接</td>
</tr>
<tr>
<td><code>InputStream</code></td>
<td><code>getInputStream()</code></td>
<td>获取此链接的字节输入流</td>
</tr>
<tr>
<td><code>OutputStream</code></td>
<td><code>getOutputStream()</code></td>
<td>获取此连接的字节输出流</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/09/29/Java/Java-%E5%8F%8D%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/09/29/Java/Java-%E5%8F%8D%E5%B0%84/" class="post-title-link" itemprop="url">Java-反射</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-09-29 15:59:44 / 修改时间：16:00:02" itemprop="dateCreated datePublished" datetime="2020-09-29T15:59:44+08:00">2020-09-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-反射"><a href="#一-反射" class="headerlink" title="一 反射"></a>一 反射</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ol>
<li>反射 <code>Reflection</code> 允许程序在运行期间：<ul>
<li>获取任意类型的详细信息</li>
<li>创建任意类型的对象</li>
<li>读写任意对象的任意属性</li>
<li>调用任意对象的任意方法</li>
<li>读取某个注解信息</li>
<li>读取某个类的泛型信息</li>
<li>生成动态代理</li>
<li>。。。</li>
</ul>
</li>
<li>加载完类之后，在方法区中旧产生了一个 <code>Class</code> 对象（一个类对应一个），此对象包含了类的完整结构信息</li>
</ol>
<h2 id="1-2-动态语言-amp-静态语言"><a href="#1-2-动态语言-amp-静态语言" class="headerlink" title="1.2 动态语言 &amp; 静态语言"></a>1.2 动态语言 &amp; 静态语言</h2><ol>
<li>动态语言：<ul>
<li>运行时可以根据某些条件改变自身结构</li>
<li><code>Object-C、C#、JavaScript、PHP、Python、Erlang</code></li>
</ul>
</li>
<li>静态语言：<ul>
<li>运行时结构不可变</li>
<li><code>Java、C、C++</code></li>
<li>Java 不是动态语言，但有一定的动态性（利用反射）</li>
</ul>
</li>
</ol>
<h1 id="二-Java-类型"><a href="#二-Java-类型" class="headerlink" title="二 Java 类型"></a>二 Java 类型</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/Java%E7%B1%BB%E5%9E%8B.png" alt=""></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>例</th>
</tr>
</thead>
<tbody><tr>
<td><code>Type</code></td>
<td>Java 中所有类型的公共高级接口</td>
<td></td>
</tr>
<tr>
<td><code>Class</code></td>
<td>普通类型（类，接口，数组，枚举，注解，基本数据类型，<code>void</code>），没有泛型信息</td>
<td><code>Person</code></td>
</tr>
<tr>
<td><code>ParameterizedType</code></td>
<td>参数化类型（即泛型）</td>
<td><code>Map&lt;String, Integer&gt;</code>，<code>List&lt;T&gt;</code></td>
</tr>
<tr>
<td><code>GenericArrayType</code></td>
<td>泛型数组类型</td>
<td><code>T[]</code>，<code>List&lt;T&gt;[]</code></td>
</tr>
<tr>
<td><code>TypeVariable&lt;D&gt;</code></td>
<td>类型变量（即泛型中的变量）</td>
<td><code>T K V</code></td>
</tr>
<tr>
<td><code>WildcardType</code></td>
<td>带通配符 <code>?</code> 的类型</td>
<td><code>List&lt;?&gt;</code>，<code>List&lt;? extends Object&gt;</code></td>
</tr>
</tbody></table>
<h2 id="2-2-ParameterizedType"><a href="#2-2-ParameterizedType" class="headerlink" title="2.2 ParameterizedType"></a>2.2 <code>ParameterizedType</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Type[]</code></td>
<td><code>getActualTypeArguments()</code></td>
<td>获取泛型的实际类型，泛型可能有多个，所以返回数组（<strong>该方法只返回最外层的<code>&lt;&gt;</code>中的类型，无论该<code>&lt;&gt;</code>内有多少个<code>&lt;&gt;</code></strong>）</td>
</tr>
<tr>
<td><code>Type</code></td>
<td><code>getRawType()</code></td>
<td>获取声明泛型的类或者接口，也就是泛型中<code>&lt;&gt;</code>前面的那个值</td>
</tr>
<tr>
<td><code>Type</code></td>
<td><code>getOwnerType()</code></td>
<td>获取泛型的拥有者，例如： <code>Map</code> 就是 <code>Map.Entry&lt;String,String&gt;</code> 的拥有者</td>
</tr>
</tbody></table>
<h1 id="三-java-lang-ClassLoader"><a href="#三-java-lang-ClassLoader" class="headerlink" title="三 java.lang.ClassLoader"></a>三 <code>java.lang.ClassLoader</code></h1><h2 id="3-1-获取-ClassLoader"><a href="#3-1-获取-ClassLoader" class="headerlink" title="3.1 获取 ClassLoader"></a>3.1 获取 ClassLoader</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 获取当前类的 ClassLoader</span></span><br><span class="line">clazz.getClassLoader()</span><br><span class="line"><span class="comment">// 2 获取当前线程上下文的 ClassLoader</span></span><br><span class="line">Thread.currentThread().getContextClassLoader()</span><br><span class="line"><span class="comment">// 3 获取系统的 ClassLoader</span></span><br><span class="line">ClassLoader.getSystemClassLoader()</span><br><span class="line"><span class="comment">// 4 获取调用者的 ClassLoader</span></span><br><span class="line">DriverManager.getCallClassLoader()</span><br><span class="line">Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br></pre></td></tr></table></figure>

<h2 id="3-2-API"><a href="#3-2-API" class="headerlink" title="3.2 API"></a>3.2 API</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Class&lt;?&gt;</code></td>
<td><code>loadClass​(String name)</code></td>
<td>加载指定全限定名的类，返回 <code>Class</code> 对象</td>
</tr>
<tr>
<td><code>protected Class&lt;?&gt;</code></td>
<td><code>findClass(String name)</code></td>
<td>查找指定全限定名的类，返回 <code>Class</code> 对象</td>
</tr>
<tr>
<td><code>protected Class&lt;?&gt;</code></td>
<td><code>defineClass(String name, byte[] b, int off, int len)</code></td>
<td>将字节数组转为一个 <code>Class</code> 对象</td>
</tr>
<tr>
<td><code>InputStream</code></td>
<td><code>getResourceAsStream​(String name)</code></td>
<td>获取指定资源文件的流</td>
</tr>
<tr>
<td><code>URL</code></td>
<td><code>getResource​(String name)</code></td>
<td>获取指定资源文件的 URL 对象</td>
</tr>
<tr>
<td><code>ClassLoader</code></td>
<td><code>getParent()</code></td>
<td>获取父加载器</td>
</tr>
</tbody></table>
<h2 id="3-3-Class-和-ClassLoader-获取资源"><a href="#3-3-Class-和-ClassLoader-获取资源" class="headerlink" title="3.3 Class 和 ClassLoader 获取资源"></a>3.3 <code>Class</code> 和 <code>ClassLoader</code> 获取资源</h2><h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line">App</span><br><span class="line">	src</span><br><span class="line">		a</span><br><span class="line">			b</span><br><span class="line">				Test.java</span><br><span class="line">				hello.xml</span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line">App</span><br><span class="line">	WEB-INF</span><br><span class="line">		classes</span><br><span class="line">			a</span><br><span class="line">				b</span><br><span class="line">					Test<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">					<span class="title">hello</span>.<span class="title">xml</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>Class</code> 和 <code>ClassLoader</code> 资源路径都是相对于编译后的工程结构来说</li>
<li><code>getResource()</code> 和 <code>getResourceAsStream()</code> 两个方法路径用法是一样的</li>
</ol>
<h3 id="2-Class"><a href="#2-Class" class="headerlink" title="2 Class"></a>2 <code>Class</code></h3><ol>
<li><p>相对路径：相对于当前类的 <code>.class</code> 文件路径</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class.getResouce("hello.xml")</span><br></pre></td></tr></table></figure>
</li>
<li><p>绝对路径：<code>/</code> 代表 <code>classpath</code> 根路径，即 <code>classes</code> 目录</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class.getResource("/a/b/hello.xml")</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="3-ClassLoader"><a href="#3-ClassLoader" class="headerlink" title="3 ClassLoader"></a>3 <code>ClassLoader</code></h3><ul>
<li><p>默认就是从 <code>classpath</code> 下寻找资源，所以不能写 <code>/</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classLoader.getResource(<span class="string">"a/b/hello.xml"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-文件流"><a href="#4-文件流" class="headerlink" title="4 文件流"></a>4 文件流</h3><ul>
<li>文件流是相对于当前工程</li>
</ul>
<h1 id="四-java-lang-Class"><a href="#四-java-lang-Class" class="headerlink" title="四 java.lang.Class"></a>四 <code>java.lang.Class</code></h1><h2 id="4-1-获取-Class-对象的方式"><a href="#4-1-获取-Class-对象的方式" class="headerlink" title="4.1 获取 Class 对象的方式"></a>4.1 获取 <code>Class</code> 对象的方式</h2><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>类.class</code></td>
<td>编译期这个类型就要存在</td>
</tr>
<tr>
<td><code>类对象.getClass()</code></td>
<td>需要先创建对象</td>
</tr>
<tr>
<td><code>Class.forName(&quot;全限定类名&quot;)</code></td>
<td>类型可以在编译期未知，类名可以在代码中或配置文件中等等</td>
</tr>
<tr>
<td><code>类加载器对象.loadClass(&quot;全限定类名&quot;)</code></td>
<td>一般用在自定义类加载器去加载指定路径的类</td>
</tr>
</tbody></table>
<h2 id="4-2-API"><a href="#4-2-API" class="headerlink" title="4.2 API"></a>4.2 API</h2><h3 id="1-获取-Class-和-ClassLoader"><a href="#1-获取-Class-和-ClassLoader" class="headerlink" title="1 获取 Class 和 ClassLoader"></a>1 获取 <code>Class</code> 和 <code>ClassLoader</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Class&lt;?&gt;</code></td>
<td><code>forName​(String className)</code></td>
<td>根据全限定类名获取 <code>Class</code> 对象</td>
</tr>
<tr>
<td><code>ClassLoader</code></td>
<td><code>getClassLoader()</code></td>
<td>获取类加载器对象</td>
</tr>
</tbody></table>
<h3 id="2-获取类信息"><a href="#2-获取类信息" class="headerlink" title="2 获取类信息"></a>2 获取类信息</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Package</code></td>
<td><code>getPackage()</code></td>
<td>获取包</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getPackageName()</code></td>
<td>获取包名</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getName()</code></td>
<td>获取类名</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getModifiers()</code></td>
<td>获取类修饰符编号 <code>mod</code></td>
</tr>
<tr>
<td><code>Class&lt;? super T&gt;</code></td>
<td><code>getSuperclass()</code></td>
<td>获取父类（不带泛型）</td>
</tr>
<tr>
<td><code>Type</code></td>
<td><code>getGenericSuperclass()</code></td>
<td>获取带泛型的父类</td>
</tr>
<tr>
<td><code>Class&lt;?&gt;[]</code></td>
<td><code>getInterfaces()</code></td>
<td>获取所有实现的接口（不带泛型）</td>
</tr>
<tr>
<td><code>Type[]</code></td>
<td><code>getGenericInterfaces()</code></td>
<td>获取所有实现接口（带泛型）</td>
</tr>
</tbody></table>
<h3 id="3-获取构造器-Constructor"><a href="#3-获取构造器-Constructor" class="headerlink" title="3 获取构造器  Constructor"></a>3 获取构造器  <code>Constructor</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Constructor&lt;?&gt;[]</code></td>
<td><code>getConstructors()</code></td>
<td>获取本类所有 <code>public</code> 构造器</td>
</tr>
<tr>
<td><code>Constructor&lt;?&gt;[]</code></td>
<td><code>getDeclaredConstructors()</code></td>
<td>获取本类所有构造器</td>
</tr>
<tr>
<td><code>Constructor&lt;T&gt;</code></td>
<td><code>getConstructor(Class&lt;?&gt;... parameterTypes)</code></td>
<td>获取本类指定参数类型的 <code>public</code> 构造器</td>
</tr>
<tr>
<td><code>Constructor&lt;T&gt;</code></td>
<td><code>getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code></td>
<td>获取本类指定参数类型的构造器</td>
</tr>
</tbody></table>
<h3 id="4-获取属性-Field"><a href="#4-获取属性-Field" class="headerlink" title="4 获取属性 Field"></a>4 获取属性 <code>Field</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Field[]</code></td>
<td><code>getFields()</code></td>
<td>获取本类及父类的所有 <code>public</code> 属性</td>
</tr>
<tr>
<td><code>Field[]</code></td>
<td><code>getDeclaredFields()</code></td>
<td>获取本类的所有属性</td>
</tr>
<tr>
<td><code>Field</code></td>
<td><code>getField​(String name)</code></td>
<td>获取本类及父类中指定名称的 <code>public</code> 属性</td>
</tr>
<tr>
<td><code>Field</code></td>
<td><code>getDeclaredField​(String name)</code></td>
<td>获取本类中指定名称的属性</td>
</tr>
</tbody></table>
<h3 id="5-获取方法-Method"><a href="#5-获取方法-Method" class="headerlink" title="5 获取方法 Method"></a>5 获取方法 <code>Method</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Method[]</code></td>
<td><code>getMethods()</code></td>
<td>获取本类及父类的所有 <code>public</code> 方法</td>
</tr>
<tr>
<td><code>Method[]</code></td>
<td><code>getDeclaredMethods()</code></td>
<td>获取本类的所有方法</td>
</tr>
<tr>
<td><code>Method</code></td>
<td><code>getMethod​(String name, Class&lt;?&gt;... parameterTypes)</code></td>
<td>获取本类及父类中指定方法名和参数类型的 <code>public</code> 方法</td>
</tr>
<tr>
<td><code>Method</code></td>
<td><code>getDeclaredMethod​(String name, Class&lt;?&gt;... parameterTypes)</code></td>
<td>获取本类中指定方法名和参数类型的方法</td>
</tr>
</tbody></table>
<h3 id="6-获取注解-Annotation"><a href="#6-获取注解-Annotation" class="headerlink" title="6 获取注解 Annotation"></a>6 获取注解 <code>Annotation</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Annotation[]</code></td>
<td><code>getAnnotations()</code></td>
<td>获取类上的所有注解</td>
</tr>
<tr>
<td><code>&lt;A extends Annotation&gt; A</code></td>
<td><code>getAnnotation​(Class&lt;A&gt; annotationClass)</code></td>
<td>获取类上指定注解类型的注解</td>
</tr>
</tbody></table>
<h1 id="五-java-lang-reflect-包"><a href="#五-java-lang-reflect-包" class="headerlink" title="五 java.lang.reflect 包"></a>五 <code>java.lang.reflect</code> 包</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%8F%8D%E5%B0%84%E5%8C%85.png" alt=""></p>
<table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>AccessibleObject</code></td>
<td>访问修饰符控制</td>
</tr>
<tr>
<td><code>Modifier</code></td>
<td>修饰符</td>
</tr>
<tr>
<td><code>Constructor&lt;T&gt;</code></td>
<td>构造器</td>
</tr>
<tr>
<td><code>Field</code></td>
<td>属性</td>
</tr>
<tr>
<td><code>Method</code></td>
<td>方法</td>
</tr>
<tr>
<td><code>Proxy</code></td>
<td>代理</td>
</tr>
</tbody></table>
<h2 id="5-2-Modifier"><a href="#5-2-Modifier" class="headerlink" title="5.2 Modifier"></a>5.2 <code>Modifier</code></h2><h3 id="1-属性"><a href="#1-属性" class="headerlink" title="1 属性"></a>1 属性</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>属性</th>
</tr>
</thead>
<tbody><tr>
<td><code>static int</code></td>
<td><code>PUBLIC</code></td>
</tr>
<tr>
<td><code>static int</code></td>
<td><code>PRIVATE</code></td>
</tr>
<tr>
<td><code>...</code></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>此类为修饰符定义了常量值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PUBLIC = <span class="number">0x00000001</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRIVATE = <span class="number">0x00000002</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2 方法"></a>2 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static String</code></td>
<td><code>toString(int mod)</code></td>
<td>获取编号对应的修饰符</td>
</tr>
</tbody></table>
<h2 id="5-3-AccessibleObject"><a href="#5-3-AccessibleObject" class="headerlink" title="5.3 AccessibleObject"></a>5.3 <code>AccessibleObject</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Annotation[]</code></td>
<td><code>getAnnotations()</code></td>
<td>获取当前元素（构造、属性、方法）上的所有注解</td>
</tr>
<tr>
<td><code>&lt;T extends Annotation&gt; T</code></td>
<td><code>getAnnotation(Class&lt;T&gt; annotationClass)</code></td>
<td>获取当前元素上的指定类型的注解</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setAccessible​(boolean flag)</code></td>
<td><code>true</code> 表示不启用 Java 访问修饰符的检查，可以访问非 <code>public</code> 修饰的成员</td>
</tr>
</tbody></table>
<h2 id="5-4-Constructor"><a href="#5-4-Constructor" class="headerlink" title="5.4 Constructor"></a>5.4 <code>Constructor</code></h2><h3 id="1-构造器信息"><a href="#1-构造器信息" class="headerlink" title="1 构造器信息"></a>1 构造器信息</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>getModifiers()</code></td>
<td>获取构造方法修饰符</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getName()</code></td>
<td>获取构造方法名</td>
</tr>
<tr>
<td><code>Class&lt;?&gt;[]</code></td>
<td><code>getParameterTypes()</code></td>
<td>获取构造方法形参类型列表</td>
</tr>
</tbody></table>
<h3 id="2-构造器操作"><a href="#2-构造器操作" class="headerlink" title="2 构造器操作"></a>2 构造器操作</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>T</code></td>
<td><code>newInstance​(Object... initargs)</code></td>
<td>使用构造器创建对象</td>
</tr>
</tbody></table>
<h2 id="5-4-Field"><a href="#5-4-Field" class="headerlink" title="5.4 Field"></a>5.4 <code>Field</code></h2><h3 id="1-属性信息"><a href="#1-属性信息" class="headerlink" title="1 属性信息"></a>1 属性信息</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>getModifiers()</code></td>
<td>获取属性修饰符</td>
</tr>
<tr>
<td><code>Class&lt;?&gt;</code></td>
<td><code>getType()</code></td>
<td>获取属性类型</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getName()</code></td>
<td>获取属性名</td>
</tr>
</tbody></table>
<h3 id="2-属性操作"><a href="#2-属性操作" class="headerlink" title="2 属性操作"></a>2 属性操作</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object</code></td>
<td><code>get​(Object obj)</code></td>
<td>获取指定对象此属性的值</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>set​(Object obj, Object value)</code></td>
<td>为指定对象设置此属性的值</td>
</tr>
</tbody></table>
<h2 id="5-5-Method"><a href="#5-5-Method" class="headerlink" title="5.5 Method"></a>5.5 <code>Method</code></h2><h3 id="1-方法信息"><a href="#1-方法信息" class="headerlink" title="1 方法信息"></a>1 方法信息</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>getModifiers()</code></td>
<td>获取方法修饰符</td>
</tr>
<tr>
<td><code>Class&lt;?&gt;</code></td>
<td><code>getReturnType()</code></td>
<td>获取返回值类型</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getName()</code></td>
<td>获取方法名</td>
</tr>
<tr>
<td><code>Class&lt;?&gt;[]</code></td>
<td><code>getParameterTypes()</code></td>
<td>获取方法形参类型列表</td>
</tr>
<tr>
<td><code>Class&lt;?&gt;[]</code></td>
<td><code>getExceptionTypes()</code></td>
<td>获取抛出异常类型列表</td>
</tr>
</tbody></table>
<h3 id="2-方法操作"><a href="#2-方法操作" class="headerlink" title="2 方法操作"></a>2 方法操作</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object</code></td>
<td><code>invoke​(Object obj, Object... args)</code></td>
<td>调用非静态方法传入指定对象，调用静态方法传入 <code>null</code> 或 <code>类.class</code></td>
</tr>
</tbody></table>
<h2 id="5-6-Proxy"><a href="#5-6-Proxy" class="headerlink" title="5.6 Proxy"></a>5.6 <code>Proxy</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Object</code></td>
<td><code>newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code></td>
<td>创建代理对象</td>
</tr>
</tbody></table>
<h1 id="六-应用"><a href="#六-应用" class="headerlink" title="六 应用"></a>六 应用</h1><ol>
<li><p><code>List&lt;Integer&gt;</code> 中添加字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型只在编译期，在运行期通过反射即可实现</span></span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"java.util.ArrayList"</span>);</span><br><span class="line">Method method = clazz.getMethod(<span class="string">"add"</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">method.invoke(list, <span class="string">"哈哈哈"</span>);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

</li>
</ol>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/09/29/Java/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/09/29/Java/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">Java-多线程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-09-29 15:57:44 / 修改时间：15:57:58" itemprop="dateCreated datePublished" datetime="2020-09-29T15:57:44+08:00">2020-09-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-概念"><a href="#一-概念" class="headerlink" title="一 概念"></a>一 概念</h1><h2 id="1-1-同步（Synchronous）-amp-异步（Asynchronous）"><a href="#1-1-同步（Synchronous）-amp-异步（Asynchronous）" class="headerlink" title="1.1 同步（Synchronous）&amp; 异步（Asynchronous）"></a>1.1 同步（Synchronous）&amp; 异步（Asynchronous）</h2><ol>
<li>同步和异步都用来形容一次方法调用</li>
<li>同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为</li>
<li>异步方法调用一旦开始，方法调用会立即返回，调用者可以继续后续操作，而异步方法通常会在另一个线程中 “真实” 的执行。异步调用的整个过程不会阻碍调用者的工作，如果异步调用需要返回结果，那么当此异步调用真正完成时，会通知调用者。</li>
</ol>
<h2 id="1-2-并发（Concurrency）-amp-并行（Parallelism）"><a href="#1-2-并发（Concurrency）-amp-并行（Parallelism）" class="headerlink" title="1.2 并发（Concurrency）&amp; 并行（Parallelism）"></a>1.2 并发（Concurrency）&amp; 并行（Parallelism）</h2><ol>
<li>并发：<ul>
<li>同一时间多个任务交替执行，只是切换速度较快，看起来是同时执行而并非真正同时执行</li>
<li>同一时间应对多件事情的能力</li>
</ul>
</li>
<li>并行：<ul>
<li>同一时间多个任务真正的同时执行</li>
<li>同一时间做多件事情的能力</li>
</ul>
</li>
</ol>
<h2 id="1-3-进程（Process）-amp-线程（Thread）"><a href="#1-3-进程（Process）-amp-线程（Thread）" class="headerlink" title="1.3 进程（Process）&amp; 线程（Thread）"></a>1.3 进程（Process）&amp; 线程（Thread）</h2><ol>
<li><p>进程：</p>
<ul>
<li>正在运行的程序的实例，是系统进行资源分配的基本单位</li>
<li>进程是容纳线程的容器</li>
</ul>
</li>
<li><p>线程：</p>
<ul>
<li><p>线程是调度 CPU 的基本单位</p>
</li>
<li><p>进程中的一条执行路径，一个进程至少有一个线程</p>
</li>
<li><p>线程是程序执行的最小单位</p>
</li>
</ul>
</li>
</ol>
<h1 id="二-体系"><a href="#二-体系" class="headerlink" title="二 体系"></a>二 体系</h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E7%BA%BF%E7%A8%8B%E4%BD%93%E7%B3%BB.png" alt=""></p>
<ol>
<li><code>Runnable</code> 和 <code>Callable</code> 都可以作为线程的任务<ul>
<li><code>Runnable</code> 没有返回值，不能抛异常</li>
<li><code>Callable</code> 有返回值，能抛异常，主要用于线程池</li>
</ul>
</li>
<li><code>Future</code> 用来存储将会产生的结果</li>
<li><code>FutureTask</code> 技能存储结果也能作为任务，相当于 <code>Future + Runnable</code></li>
</ol>
<h1 id="三-Thread"><a href="#三-Thread" class="headerlink" title="三 Thread"></a>三 <code>Thread</code></h1><h2 id="3-1-创建线程"><a href="#3-1-创建线程" class="headerlink" title="3.1 创建线程"></a>3.1 创建线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 使用 Thread 自身的任务</span></span><br><span class="line">Thread()</span><br><span class="line">Thread(String name)</span><br><span class="line">Thread(ThreadGroup group, String name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 使用 Runnable 任务</span></span><br><span class="line">Thread(Runnable target)</span><br><span class="line">Thread(Runnable target, String name)</span><br><span class="line">Thread(ThreadGroup group, Runnable target)</span><br><span class="line">Thread(ThreadGroup group, Runnable target, String name)</span><br></pre></td></tr></table></figure>

<ol>
<li>若不指定线程名称，默认为  <code>Thread-0,1,2...</code></li>
<li>若不指定线程组，默认为父线程（创建此线程的线程）的线程组</li>
<li>构造函数中的 <code>statcksize</code> 代表该线程占用的栈大小，如果未指定，默认为 0，0 代表忽略该参数，该参数会被 JNI 函数去使用。（该参数有些平台有效，有些则无效）</li>
</ol>
<h2 id="3-2-启动线程"><a href="#3-2-启动线程" class="headerlink" title="3.2 启动线程"></a>3.2 启动线程</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>start()</code></td>
<td>启动线程</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>run()</code></td>
<td>子类必须重写，任务方法</td>
</tr>
<tr>
<td><code>static void</code></td>
<td>sleep(long millis)`</td>
<td>控制线程休眠若干毫秒</td>
</tr>
</tbody></table>
<h2 id="3-3-线程信息"><a href="#3-3-线程信息" class="headerlink" title="3.3 线程信息"></a>3.3 线程信息</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>getName()</code></td>
<td>获取线程名称</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setName(String name)</code></td>
<td>设置线程名字</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>getId()</code></td>
<td>获取线程 ID</td>
</tr>
<tr>
<td><code>Thread.state</code></td>
<td><code>getState()</code></td>
<td>获取线程状态</td>
</tr>
<tr>
<td><code>static Thread</code></td>
<td><code>currentThread()</code></td>
<td>获取当前线程对象</td>
</tr>
</tbody></table>
<h2 id="3-4-加入线程"><a href="#3-4-加入线程" class="headerlink" title="3.4 加入线程"></a>3.4 加入线程</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>join()</code></td>
<td>当前线程阻塞，等待插入线程执行完毕</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>join(long millis)</code></td>
<td>当前线程阻塞，等待插入线程执行完毕，但最多只等待指定时间</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>join(long millis, int nanos)</code></td>
<td>时间更精确一点</td>
</tr>
</tbody></table>
<h2 id="3-5-中断线程"><a href="#3-5-中断线程" class="headerlink" title="3.5 中断线程"></a>3.5 中断线程</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>interrupt()</code></td>
<td>1 运行线程： 设置中断标志位，不代表会退出线程<br/>2 阻塞线程（ <code>wait join sleep</code>）：终止阻塞状态并抛出 <code>InterruptedException</code> 异常，且清除中断标志位</td>
</tr>
<tr>
<td><code>static boolean</code></td>
<td><code>interrupted()</code></td>
<td>判断当前线程是否被中断，会清除中断标志位</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isInterrupted()</code></td>
<td>判断此线程是否中断，不会清除中断标志位</td>
</tr>
</tbody></table>
<ol>
<li>每个线程都有一个表示 <code>中断状态</code> 的 <code>boolean</code> 标记</li>
<li>每个线程都应该不时检查此标记，以判断线程是否被中断</li>
</ol>
<h2 id="3-6-守护线程"><a href="#3-6-守护线程" class="headerlink" title="3.6 守护线程"></a>3.6 守护线程</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>setDaemon(boolean on)</code></td>
<td>是否将线程设置为守护线程，必须在线程启动前调用</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isDaemon</code></td>
<td>判断是否是守护线程</td>
</tr>
</tbody></table>
<h2 id="3-7-礼让线程"><a href="#3-7-礼让线程" class="headerlink" title="3.7 礼让线程"></a>3.7 礼让线程</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static void</code></td>
<td><code>yield()</code></td>
<td>让出本次 CPU 执行权，加入下一次的抢夺中，效果不明显</td>
</tr>
</tbody></table>
<h2 id="3-8-线程组"><a href="#3-8-线程组" class="headerlink" title="3.8 线程组"></a>3.8 线程组</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ThreadGroup</code></td>
<td><code>getThreadGroup()</code></td>
<td>获取线程所在线程组</td>
</tr>
</tbody></table>
<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>线程组可以对一批线程进行分类管理，Java 允许程序直接对线程组进行控制</li>
<li>创建线程对象时，如果未指定线程组，则默认为父线程的线程组</li>
<li>主线程的线程组为 <code>main</code></li>
</ol>
<h3 id="2-ThreadGroup"><a href="#2-ThreadGroup" class="headerlink" title="2 ThreadGroup"></a>2 <code>ThreadGroup</code></h3><h4 id="1-构造"><a href="#1-构造" class="headerlink" title="1 构造"></a>1 构造</h4><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ThreadGroup(String name)</code></td>
<td>创建线程组并指定名称</td>
</tr>
<tr>
<td><code>ThreadGroup(ThreadGroup parent, String name)</code></td>
<td>创建线程组并指定父线程组及名称</td>
</tr>
</tbody></table>
<h4 id="2-方法"><a href="#2-方法" class="headerlink" title="2 方法"></a>2 方法</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>getName()</code></td>
<td>获取线程组名称</td>
</tr>
<tr>
<td><code>ThreadGroup</code></td>
<td><code>getParent()</code></td>
<td>获取线程组的父线程组</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>activeCount()</code></td>
<td>获取线程组中活动线程数</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>enumerate(Thread[] list)</code></td>
<td>枚举线程组中的活动线程</td>
</tr>
</tbody></table>
<h2 id="3-9-线程优先级"><a href="#3-9-线程优先级" class="headerlink" title="3.9 线程优先级"></a>3.9 线程优先级</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>getPriority()</code></td>
<td>获取线程优先级</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>setPriority(int newPriority)</code></td>
<td>设置线程优先级 <code>1-10</code>，仅仅是概率增加了，玄不改命</td>
</tr>
<tr>
<td></td>
<td><code>Thread.MIN_PRIORITY</code></td>
<td>最小优先级 <code>1</code></td>
</tr>
<tr>
<td></td>
<td><code>Thread.NORM_PRIORITY</code></td>
<td>默认优先级 <code>5</code></td>
</tr>
<tr>
<td></td>
<td><code>Thread.MAX_PRIORITY</code></td>
<td>最大优先级 <code>10</code></td>
</tr>
</tbody></table>
<h1 id="四-线程状态"><a href="#四-线程状态" class="headerlink" title="四 线程状态"></a>四 线程状态</h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt=""></p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>New</code></td>
<td>新建状态</td>
</tr>
<tr>
<td><code>Runnable</code></td>
<td>可运行状态：一个线程可能正在运行也可能没有运行</td>
</tr>
<tr>
<td><code>Blocked</code></td>
<td>阻塞状态</td>
</tr>
<tr>
<td><code>Waiting</code></td>
<td>无限等待</td>
</tr>
<tr>
<td><code>Timed waiting</code></td>
<td>限时等待</td>
</tr>
<tr>
<td><code>Terminated</code></td>
<td>终止状态：正常结束或异常意外终止</td>
</tr>
</tbody></table>
<h1 id="五-终止线程"><a href="#五-终止线程" class="headerlink" title="五 终止线程"></a>五 终止线程</h1><ol>
<li><p><code>stop()</code></p>
<ol>
<li>已过时</li>
<li><code>stop()</code> 方法过于暴力，会强行把执行到一半的线程终止，可能会引起一些数据不一致的问题</li>
</ol>
</li>
<li><p><code>suspend() resume()</code></p>
<ol>
<li>已过时</li>
<li>挂起和恢复线程这两个方法同样会破坏同步</li>
</ol>
</li>
<li><p>定义标记，自行决定线程何时退出</p>
</li>
<li><p><code>Two Phase Termination</code>：两阶段终止模式</p>
<p><img src="https://gitee.com/anis5/pic/raw/master/Java/%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B.png" alt=""></p>
<ol>
<li>通过中断标记实现</li>
<li><code>volatile</code> 实现</li>
</ol>
</li>
</ol>
<h1 id="六-JMM"><a href="#六-JMM" class="headerlink" title="六 JMM"></a>六 JMM</h1><h2 id="6-1-CPU-缓存"><a href="#6-1-CPU-缓存" class="headerlink" title="6.1 CPU 缓存"></a>6.1 CPU 缓存</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7.png" alt=""></p>
<ol>
<li>读写速度（离 CPU 越近，速度越快）：<code>寄存器 &gt; cache L1 &gt; cache L2 &gt; cache L3 &gt; 内存 &gt; 硬盘</code></li>
<li><code>cache line</code> 是 <code>cache</code> 的最小存储单元</li>
<li>在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，这就有了<strong>缓存一致性（CacheCoherence）</strong>问题</li>
<li>为了解决一致性的问题，有许多协议，如 MSI、<br>MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol，等等</li>
</ol>
<h3 id="2-MESI-缓存一致性协议"><a href="#2-MESI-缓存一致性协议" class="headerlink" title="2 MESI 缓存一致性协议"></a>2 <code>MESI</code> 缓存一致性协议</h3><table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>M（Modified）</code></td>
<td>该 <code>cache line</code> 有效，数据被修改了，和内存中的数据不一致，数据只存在于本 <code>Cache</code> 中</td>
</tr>
<tr>
<td><code>E（Exclusive）</code></td>
<td>该 <code>cache line</code> 有效，数据和内存中的数据一致，数据只存在于本 <code>Cache</code> 中</td>
</tr>
<tr>
<td><code>S（Shared）</code></td>
<td>该 <code>cache line</code> 有效，数据和内存中的数据一致，数据存在于多个 <code>Cache</code> 中</td>
</tr>
<tr>
<td><code>I（Invalid）</code></td>
<td>该 <code>cache line</code> 无效</td>
</tr>
</tbody></table>
<ol>
<li>内存中数据，只有一个  <code>cache</code> 中有，则为独占状态 <code>E</code></li>
<li>当不止一个 <code>cache</code> 中有时，则全为共享状态 <code>S</code></li>
<li>当某个 <code>cache</code> 修改了数据，则其变为修改状态 <code>M</code>，且其它 <code>cache</code> 变为无效状态 <code>I</code></li>
<li>多个 CPU 从主内存读取同一个数据到各自的高速缓存，当其中某个 CPU 修改了缓存里的数据，该数据会马上同步回主内存，其它 CPU 通过 <strong>总线嗅探机制</strong> （类似于事件监听）可以感知到数据的变化从而将自己缓存里的数据失效</li>
<li>底层实现通过汇编 <code>lock</code> 指令<ol>
<li>锁定这块内存区域的缓存（缓存行锁定），并立即将修改数据写回系统内存</li>
<li>这个写回内存的操作会引起在其它 CPU 里缓存了该内存地址的数据无效</li>
</ol>
</li>
</ol>
<h2 id="6-2-JMM-概述"><a href="#6-2-JMM-概述" class="headerlink" title="6.2 JMM 概述"></a>6.2 JMM 概述</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/JMM.png" alt=""></p>
<ol>
<li><p><code>Java Memory Model</code> </p>
</li>
<li><p>Java内存模型是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p>
<ul>
<li>实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享，受到内存模型控制</li>
<li>局部变量，方法参数，异常处理参数不会在线程之间共享，不受内存模型影响</li>
</ul>
</li>
<li><p>相关概念</p>
<ol>
<li><p><strong>临界区 <code>Critical Section</code></strong></p>
<ul>
<li><p>表示一种公共资源或共享数据，可以被多个线程使用，但每次只能有一个线程使用，一旦临界区资源被占用，其它线程就必须等待</p>
</li>
<li><p>一段代码内如果存在对共享数据的多线程读写操作，则这段代码称为临界区</p>
</li>
</ul>
</li>
<li><p><strong>竞态条件 <code>Race Condition</code></strong></p>
<ul>
<li>多个线程在临界区内执行，由于代码执行序列不同而导致结果无法预测，称为发生了竞态条件</li>
</ul>
</li>
<li><p>为避免临界区的竞态条件发生</p>
<ol>
<li>阻塞式解决方案：<code>synchronized, Lock</code> </li>
<li>非阻塞式解决方案：原子变量 CAS</li>
</ol>
</li>
<li><p>同步和互斥</p>
<ol>
<li>同步：是由于线程执行的顺序不同，需要一个线程等待其它线程运行到某个点</li>
<li>互斥：保证同一时刻只有一个线程执行临界区代码</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="6-3-JMM-内存交互操作（原子操作）"><a href="#6-3-JMM-内存交互操作（原子操作）" class="headerlink" title="6.3 JMM 内存交互操作（原子操作）"></a>6.3 JMM 内存交互操作（原子操作）</h2><table>
<thead>
<tr>
<th>操作</th>
<th>作用对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>read</code></td>
<td>主内存</td>
<td>从主内存读取数据到工作内存中</td>
</tr>
<tr>
<td><code>load</code></td>
<td>工作内存</td>
<td>将 <code>read</code> 读取的数据载入工作内存变量副本中</td>
</tr>
<tr>
<td><code>use</code></td>
<td>工作内存</td>
<td>从工作内存读取数据传递给执行引擎计算</td>
</tr>
<tr>
<td><code>assign</code></td>
<td>工作内存</td>
<td>将执行引擎计算好的值重新赋值给工作内存</td>
</tr>
<tr>
<td><code>store</code></td>
<td>工作内存</td>
<td>将工作内存数据传送到主内存</td>
</tr>
<tr>
<td><code>write</code></td>
<td>工作内存</td>
<td>将 <code>stroe</code> 传送的数据赋值给主内存的变量</td>
</tr>
<tr>
<td><code>lock</code></td>
<td>主内存</td>
<td>将主内存变量加锁，标记为线程独占状态</td>
</tr>
<tr>
<td><code>unlock</code></td>
<td>主内存</td>
<td>将主内存变量解锁，解锁后才可以被其他线程锁定</td>
</tr>
</tbody></table>
<h2 id="6-4-JMM-特性"><a href="#6-4-JMM-特性" class="headerlink" title="6.4 JMM 特性"></a>6.4 JMM 特性</h2><h3 id="1-原子性-Atomicity"><a href="#1-原子性-Atomicity" class="headerlink" title="1 原子性 Atomicity"></a>1 原子性 <code>Atomicity</code></h3><ol>
<li><p>原子性指一个操作是不可分割的单元，是不可中断的，要嘛都执行，要嘛都不执行</p>
</li>
<li><p>一个原子性操作一旦开始，就不会被其它线程干扰，而一个非原子性操作，在多线程环境下有可能被其它线程所干扰</p>
</li>
<li><p>从一个线程观察另外一个线程的时候，看到的都是一个个原子性的操作</p>
</li>
<li><p>例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">	a = <span class="number">1</span>;</span><br><span class="line">	b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">从一个线程观察另一个线程执行上述代码，只有两种结果</span><br><span class="line">	<span class="number">1</span> a,b 都被赋值成功</span><br><span class="line">	<span class="number">2</span> a,b 都未被赋值</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-可见性-Visibility"><a href="#2-可见性-Visibility" class="headerlink" title="2 可见性 Visibility"></a>2 可见性 <code>Visibility</code></h3><ol>
<li>可见性指当一个线程修改了某个共享变量后，其他线程是否能够立即知道这个修改</li>
<li>每个线程都有自己的工作内存，所以当线程修改完某个变量之后，在其他的线程中，未必能观察到该变量已经被修改</li>
</ol>
<h3 id="3-有序性-Ordering"><a href="#3-有序性-Ordering" class="headerlink" title="3 有序性 Ordering"></a>3 有序性 <code>Ordering</code></h3><ol>
<li>指令重排序<ol>
<li>JVM 在不影响正确性的前提下，可以调整指令的执行顺序，这种特性称之为『指令重排』，指令重排可以提高 CPU 的处理性能</li>
<li><code>as-if-serial</code> 语义：不管如何重排序，必须保证串行语义一致，即单线程下，程序的执行结果不会改变</li>
</ol>
</li>
<li>指令重排在多线程下有可能影响正确性</li>
</ol>
<h2 id="6-5-Happens-Before-规则"><a href="#6-5-Happens-Before-规则" class="headerlink" title="6.5 Happens-Before 规则"></a>6.5 <code>Happens-Before</code> 规则</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>happens-before</code> 规则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据</li>
<li>可以通过此规则分析一个并发程序是否安全</li>
<li>如果 <code>A happens-bofore B</code>，则 A 操作先于 B 操作发生，且 <code>A</code> 操作的结果对 B 可见</li>
</ol>
<h3 id="2-规则"><a href="#2-规则" class="headerlink" title="2 规则"></a>2 规则</h3><table>
<thead>
<tr>
<th>规则</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>程序顺序规则（<code>Program Order Rule</code>）</td>
<td>一个线程内保证语义的串行性，即按照代码顺序执行，前面的操作 <code>happens-before</code> 后续的任何操作</td>
</tr>
<tr>
<td>管程锁定规则（<code>Monitor Lock Rule</code>）</td>
<td>同一个锁的解锁操作 <code>happens-before</code> 后续对这个锁的加锁操作</td>
</tr>
<tr>
<td><code>volatile</code> 变量规则（<code>volatile Variable Rule</code>）</td>
<td><code>volatile</code> 变量的写操作，<code>happens-before</code> 后续对这个变量的读操作</td>
</tr>
<tr>
<td>线程启动规则（<code>Thread Start Rule</code>）</td>
<td>线程 <code>start()</code> 方法 <code>happens-before</code> 线程中的每一个操作</td>
</tr>
<tr>
<td>线程终止规则（<code>Thread Termination Rule</code>）</td>
<td>线程的所有操作 <code>happens-before</code> 线程的终结</td>
</tr>
<tr>
<td>线程中断规则（<code>Thread Interruption Rule</code>）</td>
<td>线程 <code>interrupt()</code> 方法的调用 <code>happens—before</code> 被中断线程的代码检测到中断事件的发生</td>
</tr>
<tr>
<td>对象终结规则（<code>Finalizer Rule</code>）</td>
<td>一个对象的初始化完成（构造函数执行）<code>happens—before</code> 它的 <code>finalize()</code> 方法</td>
</tr>
<tr>
<td>传递性（<code>Transitivity</code>）</td>
<td>如果 <code>A happens-before B，B happens-before C</code>，那么 <code>A happens-before C</code></td>
</tr>
</tbody></table>
<h2 id="6-6-volatile"><a href="#6-6-volatile" class="headerlink" title="6.6 volatile"></a>6.6 <code>volatile</code></h2><h3 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>volatile</code> 是Java虚拟机提供的轻量级的同步机制</li>
<li><code>volatile</code> 有两个作用：<ol>
<li>保证可见性</li>
<li>禁止指令重排序</li>
</ol>
</li>
<li><code>volatile</code> 无法保证原子性</li>
<li>内存屏障 <code>Memory Barrier</code><ol>
<li>对 <code>volatile</code> 变量的写指令后会加入写屏障 <code>storefence</code></li>
<li>对<code>volatile</code> 变量的读指令前会加入读屏障 <code>loadfence</code></li>
</ol>
</li>
</ol>
<h3 id="2-Volatile-可见性"><a href="#2-Volatile-可见性" class="headerlink" title="2 Volatile 可见性"></a>2 <code>Volatile</code> 可见性</h3><ol>
<li>硬件层面：<code>MESI</code><ul>
<li>当某个线程修改了被 <code>volatile</code> 修饰的共享变量的值，会马上同步到主内存，而开启了 CPU 总线嗅探机制的线程就会得知此修改，然后将自己工作内存中的共享变量副本失效，这样使用时就需要重新从主内存中读取</li>
</ul>
</li>
<li>JVM 层面：<code>Memory Barrier</code><ol>
<li>写屏障保证在该屏障之前的，对共享变量的改动，都同步到主内存当中</li>
<li>读屏障保证在该屏障之后，对共享变量的读取，加载的是主内存中最新数据</li>
</ol>
</li>
</ol>
<h3 id="3-Volatile-有序性"><a href="#3-Volatile-有序性" class="headerlink" title="3 Volatile 有序性"></a>3 <code>Volatile</code> 有序性</h3><ol>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li>
<li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li>
</ol>
<h2 id="6-7-synchronized"><a href="#6-7-synchronized" class="headerlink" title="6.7 synchronized"></a>6.7 <code>synchronized</code></h2><h3 id="1-概述-4"><a href="#1-概述-4" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>synchronized</code> 内置锁是一种对象锁（锁的是对象而非引用），作用粒度是对象，可以用来实现对临界资源的同步互斥访问，是可重入的</li>
<li><code>synchronized</code> 可以保证原子性和可见性，不能保证有序性，但如果共享变量完全被 <code>synchronized</code> 控制，则不会出现有序性问题</li>
</ol>
<h3 id="2-同步代码块"><a href="#2-同步代码块" class="headerlink" title="2 同步代码块"></a>2 同步代码块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(锁) &#123;</span><br><span class="line">	1. 同步代码块的锁可以是任意对象</span><br><span class="line">	2. 不要使用 String Integer Long 作为锁对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-同步函数"><a href="#3-同步函数" class="headerlink" title="3 同步函数"></a>3 同步函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 synchronized 返回值 方法名(形参列表)&#123;</span><br><span class="line">	1. 非静态同步函数的锁是 this</span><br><span class="line">	2. 静态同步函数的锁是当前类的字节码对象 类.class</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-synchronized-原理"><a href="#4-synchronized-原理" class="headerlink" title="4 synchronized 原理"></a>4 <code>synchronized</code> 原理</h3><h4 id="1-对象头"><a href="#1-对象头" class="headerlink" title="1 对象头"></a>1 对象头</h4><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" alt=""></p>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/MarkWord32.png" alt=""></p>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/MarkWord64.png" alt=""></p>
<h4 id="2-Monitor：监视器-管程"><a href="#2-Monitor：监视器-管程" class="headerlink" title="2 Monitor：监视器/管程"></a>2 <code>Monitor</code>：监视器/管程</h4><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/monitor.png" alt=""></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Owner</code></td>
<td>当一个线程获取锁，并正常执行，则将 <code>Owner</code> 指向此线程，<code>Owner</code> 只能有一个值</td>
</tr>
<tr>
<td><code>EntryList</code></td>
<td>尝试获取此锁的线程如果获取不到，会阻塞进入 <code>EntryList</code></td>
</tr>
<tr>
<td><code>WaitSet</code></td>
<td>已经获取锁但条件不满足，进入等待状态的线程会进入 <code>WaitSet</code></td>
</tr>
</tbody></table>
<h4 id="3-原理"><a href="#3-原理" class="headerlink" title="3 原理"></a>3 原理</h4><ol>
<li><p>每个 Java 对象都有一个自己的 <code>Monitor</code> 对象，当给对象上锁（重量级锁）后，该对象头的 <code>Mark Word</code> 就会指向 <code>Monitor</code></p>
</li>
<li><p><code>Monitor</code> 的实现依赖底层操作系统的 <code>Mutex lock</code>（互斥锁）实现，它是一个重量级锁性能较低</p>
</li>
<li><p><code>synchronized</code> JVM内置锁通过内部对象 <code>Monitor</code> 实现，基于进入与退出 <code>Monitor</code> 对象实现方法与代码块同步</p>
</li>
<li><p><code>synchronized</code> 关键字被编译成字节码后会被翻译成 <code>monitorenter</code> 和 <code>monitorexit</code> 两条指令分别在同步块逻辑代码的起始位置与结束位置</p>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/smonitor.png" alt=""></p>
</li>
</ol>
<h3 id="4-锁优化"><a href="#4-锁优化" class="headerlink" title="4 锁优化"></a>4 锁优化</h3><h4 id="1-锁粗化"><a href="#1-锁粗化" class="headerlink" title="1 锁粗化"></a>1 锁粗化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sb.append(<span class="number">1</span>);</span><br><span class="line">    sb.append(<span class="number">2</span>);</span><br><span class="line">    sb.append(<span class="number">3</span>);</span><br><span class="line">    sb.append(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">StringBuffer是线程安全的，append方法有sychronized修饰，那么调用了4次append方法，就相当于有了四个同步块</span></span><br><span class="line"><span class="comment">    sychronized()&#123;</span></span><br><span class="line"><span class="comment">        append(1);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    sychronized()&#123;</span></span><br><span class="line"><span class="comment">        append(2);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    sychronized()&#123;</span></span><br><span class="line"><span class="comment">        append(3);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    sychronized()&#123;</span></span><br><span class="line"><span class="comment">        append(4);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">而这是没有必要的，锁粗化相当于</span></span><br><span class="line"><span class="comment">    sychronized()&#123;</span></span><br><span class="line"><span class="comment">        append(1);</span></span><br><span class="line"><span class="comment">        append(2);</span></span><br><span class="line"><span class="comment">        append(3);</span></span><br><span class="line"><span class="comment">        append(4);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<h4 id="2-锁消除"><a href="#2-锁消除" class="headerlink" title="2 锁消除"></a>2 锁消除</h4><ul>
<li>Java虚拟机在 JIT 编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间</li>
</ul>
<h4 id="3-锁膨胀升级"><a href="#3-锁膨胀升级" class="headerlink" title="3 锁膨胀升级"></a>3 锁膨胀升级</h4><h5 id="1-概述-5"><a href="#1-概述-5" class="headerlink" title="1 概述"></a>1 概述</h5><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/synchronized%E9%94%81%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png" alt=""></p>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E9%94%81%E5%8D%87%E7%BA%A7.png" alt=""></p>
<ul>
<li>偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁</li>
<li>轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争</li>
<li>重量级锁：有实际竞争，且锁竞争时间长</li>
</ul>
<h5 id="2-偏向锁"><a href="#2-偏向锁" class="headerlink" title="2 偏向锁"></a>2 偏向锁</h5><ol>
<li>在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁（会涉及到一些 CAS 操作）的代价而引入偏向锁</li>
<li>偏向锁核心思想：如果一个线程获得了锁，那么锁就进入偏向模式，此时 <code>Mark Word</code> 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作（即获取锁的过程），这样就省去了大量有关锁申请的操作</li>
<li>偏向锁默认开启，但有延迟</li>
<li>调用了对象的 <code>hashCode</code> ，会导致偏向锁被撤销</li>
<li>如果发生了竞争，则偏向锁会失效，会膨胀为轻量级锁</li>
</ol>
<h5 id="3-轻量级锁"><a href="#3-轻量级锁" class="headerlink" title="3 轻量级锁"></a>3 轻量级锁</h5><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%811.png" alt=""></p>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%812.png" alt=""></p>
<ol>
<li>轻量级锁所适应的场景是线程交替执行同步块的场合</li>
<li>轻量级锁在没有竞争时，每次锁重入仍需要执行 <code>CAS</code> 操作</li>
<li>如果在尝试加轻量级锁的过程中，<code>CAS</code> 操作无法成功，一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），则轻量级锁会失败，轻量级锁失败后并不会立即膨胀为重量级锁，而是会先使用锁自旋的优化手段</li>
<li><strong>自旋锁</strong><ol>
<li>在大多数情况下，线程持有锁的时间都不会太长，如果当前线程获取轻量级锁失败后直接挂起，可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高</li>
<li>自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，将轻量级锁膨胀为重量级锁</li>
</ol>
</li>
</ol>
<h3 id="5-锁活跃性"><a href="#5-锁活跃性" class="headerlink" title="5 锁活跃性"></a>5 锁活跃性</h3><ol>
<li>死锁：一个线程需要同时获取多把锁，这时就容易发生死锁（例如锁嵌套）</li>
<li>活锁：两个线程互相改变对方的结束条件，导致谁也无法结束</li>
<li>饥饿：一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束</li>
</ol>
<h2 id="6-8-常见线程安全类"><a href="#6-8-常见线程安全类" class="headerlink" title="6.8 常见线程安全类"></a>6.8 常见线程安全类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String</span><br><span class="line">Integer</span><br><span class="line">StringBuffer</span><br><span class="line">Random</span><br><span class="line">Vector</span><br><span class="line">Hashtable</span><br><span class="line">java.util.concurrent.*</span><br></pre></td></tr></table></figure>

<ol>
<li>线程安全指的是多个线程调用这些类的同一实例的同一方法是线程安全的</li>
<li>它们每个方法是原子的，但多个方法的组合不是原子的</li>
</ol>
<h1 id="七-等待唤醒机制"><a href="#七-等待唤醒机制" class="headerlink" title="七 等待唤醒机制"></a>七 等待唤醒机制</h1><h2 id="7-1-wait-notify"><a href="#7-1-wait-notify" class="headerlink" title="7.1 wait/notify"></a>7.1 <code>wait/notify</code></h2><h3 id="1-概述-6"><a href="#1-概述-6" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>只有重量级锁才有等待唤醒方法<ol>
<li><code>wait()</code>：相当于 <code>wait(0)</code>，无限等待直到被唤醒</li>
<li><code>wait(long timeout)</code>：等待指定时间或被唤醒</li>
<li><code>notify()</code></li>
<li><code>notifyAll()</code></li>
</ol>
</li>
<li>获取锁之后才能调用等待唤醒方法，即等待唤醒的方法要在同步代码中执行，且需要同一个锁对象来调用</li>
<li>等待时释放锁，进入 <code>Monitor</code> 的 <code>WaitSet</code>，唤醒之后不会立即获取锁，而是进入 <code>Monitor</code> 的 <code>EntrySet</code> 重新竞争</li>
</ol>
<h3 id="2-wait-amp-sleep"><a href="#2-wait-amp-sleep" class="headerlink" title="2 wait &amp; sleep"></a>2 <code>wait</code> &amp; <code>sleep</code></h3><table>
<thead>
<tr>
<th>方法</th>
<th>所属</th>
<th>参数</th>
<th>锁</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td><code>wait()</code></td>
<td><code>Object</code></td>
<td>无参：无限等待<br/>有参：有限等待</td>
<td>释放锁</td>
<td>必须先获取锁，在同步代码中使用</td>
</tr>
<tr>
<td><code>sleep()</code></td>
<td><code>Thread</code></td>
<td>有参：有限睡眠</td>
<td>不释放锁</td>
<td>可直接使用</td>
</tr>
</tbody></table>
<h3 id="3-模式"><a href="#3-模式" class="headerlink" title="3 模式"></a>3 模式</h3><ol>
<li>同步模式之保护性暂停 <ol>
<li><code>Guarded Suspension</code>：用在一个线程等待另一个线程的执行结果</li>
<li>结果需要从一个线程传递到另一个线程，让他们关联同一个 <code>GuardedObject</code></li>
<li>产生结果的线程与消费结果的线程需要一一对应</li>
<li>JDK 中，<code>join</code> 的实现、<code>Future</code> 的实现，采用的就是此模式</li>
</ol>
</li>
<li>异步模式之生产者/消费者<ol>
<li>产生结果的线程与消费结果的线程不需要一一对应</li>
<li>JDK 中各种阻塞队列，采用的就是这种模式</li>
</ol>
</li>
</ol>
<h2 id="7-2-park-unpark"><a href="#7-2-park-unpark" class="headerlink" title="7.2 park/unpark"></a>7.2 <code>park/unpark</code></h2><h3 id="1-与-wait-amp-notify-相比"><a href="#1-与-wait-amp-notify-相比" class="headerlink" title="1 与 wait &amp; notify 相比"></a>1 与 <code>wait &amp; notify</code> 相比</h3><ol>
<li><code>wait &amp; notify</code> 必须配合 <code>Object Monitor</code> 使用，<code>park &amp; unpark</code> 则不必</li>
<li><code>wait &amp; notify</code> 只能随机唤醒等待线程，<code>park &amp; unpark</code> 是以线程为单位来等待唤醒的，所以精确</li>
<li><code>wait &amp; notify</code> 不能先 <code>notify</code>，<code>park &amp; unpark</code> 可以先 <code>unpark</code>，即先 <code>unpark</code> 也能恢复 <code>park</code> 的线程</li>
</ol>
<h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2 原理"></a>2 原理</h3><ol>
<li>每个线程都有自己的一个 <code>Parker</code> 对象，由三部分组成<ul>
<li><code>_counter</code></li>
<li><code>_cond</code></li>
<li><code>_mutex</code></li>
</ul>
</li>
<li><code>park()</code><ol>
<li>判断 <code>_counter</code><ul>
<li><code>_counter == 0</code> 则等待</li>
<li><code>_counter == 1</code> 则继续运行</li>
</ul>
</li>
<li>将 <code>_counter</code> 设置为 <code>0</code></li>
</ol>
</li>
<li><code>unpark()</code><ol>
<li>将 <code>_counter</code> 设置为 <code>1</code></li>
<li>判断线程状态<ol>
<li>如果线程正在等待，则唤醒线程</li>
<li>如果线程正在运行，则继续运行，且由于 <code>_counter</code> 设置为了 <code>1</code> ，线程下次调用 <code>park()</code> 时，会继续执行</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="八-CAS"><a href="#八-CAS" class="headerlink" title="八 CAS"></a>八 <code>CAS</code></h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><ol>
<li><code>Compare And Swap</code> 或 <code>Compare And Set</code></li>
<li>CAS 是一种无锁算法，体现的是无锁并发、无阻塞并发</li>
<li>CAS 必须借助 <code>volatile</code> ，因为需要保证可见性来读取最新值</li>
<li>内部通过 <code>Unsafe</code> 实现，<code>Unsafe</code> 直接操作虚拟机内存，类似 <code>C C++</code> 的指针</li>
<li><code>ABA</code> 问题：<code>version</code></li>
</ol>
<h2 id="8-2-原理"><a href="#8-2-原理" class="headerlink" title="8.2 原理"></a>8.2 原理</h2><ol>
<li>CAS 包含三个操作数：<ul>
<li>内存值 <code>V</code></li>
<li>预估值 <code>A</code></li>
<li>更新值 <code>B</code></li>
</ul>
</li>
<li>第一次读取内存值记录为 <code>A</code>，之后进行一些操作</li>
<li>当真正写入数据时，再次读取内存值 <code>V</code>，当且仅当 <code>V == A</code> 时，才会更新 <code>V = B</code></li>
</ol>
<h1 id="九-java-util-concurrent-atomic"><a href="#九-java-util-concurrent-atomic" class="headerlink" title="九 java.util.concurrent.atomic"></a>九 <code>java.util.concurrent.atomic</code></h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td>基本类型原子类</td>
<td><code>AtomicInteger</code><br><code>AtomicBoolean</code><br><code>AtomicLong</code></td>
</tr>
<tr>
<td>引用类型原子类</td>
<td><code>AtomicReference&lt;V&gt;</code><br><code>AtomicStampedReference&lt;V&gt;</code><br><code>AtomicMarkableReference&lt;V&gt;</code></td>
</tr>
<tr>
<td>数组类型原子类</td>
<td><code>AtomicIntegerArray</code><br/><code>AtomicLongArray</code><br/><code>AtomicReferenceArray&lt;E&gt;</code></td>
</tr>
<tr>
<td>原子字段更新器</td>
<td><code>AtomicIntegerFieldUpdater&lt;T&gt;</code><br/><code>AtomicLongFieldUpdater&lt;T&gt;</code><br/><code>AtomicReferenceFieldUpdater&lt;T, V&gt;</code></td>
</tr>
<tr>
<td>原子累加器</td>
<td><code>LongAdder</code><br/><code>DoubleAdder</code><br/><code>LongAccumulator</code><br><code>DoubleAccumulator</code></td>
</tr>
</tbody></table>
<ol>
<li><code>AtomicReference&lt;V&gt;</code><ul>
<li>只关心当前值和预期值是否相等，不知道值是否被修改过（ABA问题），如 <code>A → B → C → A</code></li>
</ul>
</li>
<li><code>AtomicStampedReference&lt;V&gt;</code><ul>
<li>增加一个版本号属性，每次修改都使版本号 + 1，可以知道值被修改过几次</li>
</ul>
</li>
<li><code>AtomicMarkableReference&lt;V&gt;</code><ul>
<li>增加要给布尔属性，判断值是否被修改过</li>
</ul>
</li>
</ol>
<h2 id="9-2-AtomicInteger"><a href="#9-2-AtomicInteger" class="headerlink" title="9.2 AtomicInteger"></a>9.2 <code>AtomicInteger</code></h2><h3 id="1-构造-1"><a href="#1-构造-1" class="headerlink" title="1 构造"></a>1 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>AtomicInteger()</code></td>
<td>使用默认值 <code>0</code></td>
</tr>
<tr>
<td><code>AtomicInteger(int initialValue)</code></td>
<td>使用指定值</td>
</tr>
</tbody></table>
<h3 id="2-方法-1"><a href="#2-方法-1" class="headerlink" title="2 方法"></a>2 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>get()</code></td>
<td>获取当前值</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>compareAndSet(int expectedValue, int newValue)</code></td>
<td>如果当前值与预期值相等，则将当前值设置为新值并返回 <code>true</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getAndIncrement()</code></td>
<td><code>i++</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>incrementAndGet()</code></td>
<td><code>++i</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getAndDecrement()</code></td>
<td><code>i--</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>decrementAndGet()</code></td>
<td><code>--i</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getAndAdd(int delta)</code></td>
<td>返回原值，之后将值加上指定值</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>addAndGet(int delta)</code></td>
<td>将值加上指定值并返回</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>getAndUpdate(IntUnaryOperator updateFunction)</code></td>
<td>获取原值并计算</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>updateAndGet(IntUnaryOperator updateFunction)</code></td>
<td>计算并返回</td>
</tr>
</tbody></table>
<h1 id="十-java-util-concurrent-locks"><a href="#十-java-util-concurrent-locks" class="headerlink" title="十 java.util.concurrent.locks"></a>十 <code>java.util.concurrent.locks</code></h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/JUC-locks.png" alt=""></p>
<h2 id="10-1-Lock"><a href="#10-1-Lock" class="headerlink" title="10.1 Lock"></a>10.1 <code>Lock</code></h2><h3 id="1-API"><a href="#1-API" class="headerlink" title="1 API"></a>1 API</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>lock()</code></td>
<td>获取锁</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>unlock()</code></td>
<td>释放锁</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>tryLock()</code></td>
<td>尝试获取锁</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>tryLock(long time, TimeUnit unit)</code></td>
<td>尝试获取锁，会尝试指定时间</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>lockInterruptibly()</code></td>
<td>功能同 <code>locak</code>，如果线程被中断会抛出异常</td>
</tr>
<tr>
<td><code>Condition</code></td>
<td><code>newCondition()</code></td>
<td>创建一个该锁的 <code>Condition</code> 对象</td>
</tr>
</tbody></table>
<h3 id="2-典型使用"><a href="#2-典型使用" class="headerlink" title="2 典型使用"></a>2 典型使用</h3><h4 id="1-lock"><a href="#1-lock" class="headerlink" title="1 lock()"></a>1 <code>lock()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock l = ...;</span><br><span class="line">l.lock(); <span class="comment">// 获取锁后要紧跟 try</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// access the resource protected by this lock</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  l.unlock(); <span class="comment">// 释放锁要在 finally 的第一行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-tryLock"><a href="#2-tryLock" class="headerlink" title="2 tryLock()"></a>2 <code>tryLock()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line"><span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// manipulate protected state</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// perform alternative actions</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-ReentrantLock"><a href="#3-ReentrantLock" class="headerlink" title="3 ReentrantLock"></a>3 <code>ReentrantLock</code></h3><h4 id="1-构造-2"><a href="#1-构造-2" class="headerlink" title="1 构造"></a>1 构造</h4><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ReentrantLock()</code></td>
<td>默认为非公平锁</td>
</tr>
<tr>
<td><code>ReentrantLock(boolean fair)</code></td>
<td>可创建公平锁（但没有必要，会降低并发度）</td>
</tr>
</tbody></table>
<h4 id="2-与-synchronized-比较"><a href="#2-与-synchronized-比较" class="headerlink" title="2 与 synchronized 比较"></a>2 与 <code>synchronized</code> 比较</h4><ol>
<li>在 <code>synchronized</code> 未优化之前，皆为重量级锁，所以才引入 <code>ReentrantLock</code>，<code>ReentrantLock</code> 提供了更丰富的 API</li>
<li><code>synchronized</code> 和 <code>ReetrantLock</code> 都是可重入锁</li>
<li><code>synchronized</code> 获取不到锁会一直阻塞；<code>ReentrantLock</code> 获取不到锁可以被中断或超时</li>
<li><code>ReetrantLock</code> 可设置公平锁</li>
<li><code>synchronized</code>只有一个条件，不满足时进入 <code>WaitSet</code> 等待；<code>ReetrantLock</code> 一个锁可以对应多个 <code>Condition</code></li>
</ol>
<h2 id="10-2-Condition"><a href="#10-2-Condition" class="headerlink" title="10.2 Condition"></a>10.2 <code>Condition</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>await()</code></td>
<td>当前线程等待，直到被打断或被唤醒</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>await(long time, TimeUnit unit)</code></td>
<td>当前线程等待，直到被打断或被唤醒或超时</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>awaitNanos(long nanosTimeout)</code></td>
<td>当前线程等待，直到被打断或被唤醒或超时</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>awaitUninterruptibly()</code></td>
<td>当前线程等待，直到被唤醒</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>signal()</code></td>
<td>唤醒一个等待线程</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>signalAll()</code></td>
<td>唤醒所有等待线程</td>
</tr>
</tbody></table>
<h2 id="10-3-ReadWriteLock"><a href="#10-3-ReadWriteLock" class="headerlink" title="10.3 ReadWriteLock"></a>10.3 <code>ReadWriteLock</code></h2><h3 id="1-概述-7"><a href="#1-概述-7" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>读写锁，将锁更细粒度的划分：<ul>
<li>共享锁（读）</li>
<li>排他锁（写）</li>
</ul>
</li>
<li>读锁可以被多个线程共享（当读操作多时，多个读线程可以并发执行，提高效率），写锁则只能一个线程独占</li>
<li><code>ReentrantReadWriteLock</code>：唯一实现类</li>
<li><code>StampedLock</code>：能力更强的读写锁</li>
</ol>
<h3 id="2-API"><a href="#2-API" class="headerlink" title="2 API"></a>2 API</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Lock</code></td>
<td><code>readLock()</code></td>
<td>获取读锁</td>
</tr>
<tr>
<td><code>Lock</code></td>
<td><code>writeLock()</code></td>
<td>获取写锁</td>
</tr>
</tbody></table>
<h2 id="10-4-LockSupport"><a href="#10-4-LockSupport" class="headerlink" title="10.4 LockSupport"></a>10.4 <code>LockSupport</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>static Object</code></td>
<td><code>getBlocker(Thread t)</code></td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>park()</code></td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>park(Object blocker)</code></td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>parkNanos(long nanos)</code></td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>parkNanos(Object blocker, long nanos)</code></td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>parkUntil(long deadline)</code></td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>parkUntil(Object blocker, long deadline)</code></td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>unpark(Thread thread)</code></td>
</tr>
</tbody></table>
<h1 id="十一-辅助工具类"><a href="#十一-辅助工具类" class="headerlink" title="十一 辅助工具类"></a>十一 辅助工具类</h1><h2 id="11-1-Semaphore"><a href="#11-1-Semaphore" class="headerlink" title="11.1 Semaphore"></a>11.1 <code>Semaphore</code></h2><h3 id="1-概述-8"><a href="#1-概述-8" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>Semaphore</code> 是一个计数信号量，必须由获取它的线程释放</li>
<li>用来控制同时访问资源的线程数量（限流）</li>
</ol>
<h3 id="2-构造"><a href="#2-构造" class="headerlink" title="2 构造"></a>2 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Semaphore(int permits)</code></td>
<td>创建具有给定许可数的计数信号量，默认为非公平信号量</td>
</tr>
<tr>
<td><code>Semaphore(int permits, boolean fair)</code></td>
<td>创建具有给定许可数的计数信号量，可设置为公平信号量</td>
</tr>
</tbody></table>
<h3 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>acquire()</code></td>
<td>从信号量中获取一个许可，在提供一个可用许可之前一直等待</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>acquire(int permits)</code></td>
<td>从信号量中获取指定数量的许可</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>release()</code></td>
<td>释放一个许可，将其返回给信号量</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>release(int permits)</code></td>
<td>释放指定数量的许可，将其返回给信号量</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>availablePermits()</code></td>
<td>获取当前可用的许可个数</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>hasQueuedThreads()</code></td>
<td>是否有线程在等待获取许可</td>
</tr>
<tr>
<td>`int</td>
<td><code>getQueueLength()</code></td>
<td>获取正在等待获取许可的线程数</td>
</tr>
<tr>
<td><code>protected Collection&lt;Thread&gt;</code></td>
<td><code>getQueuedThreads()</code></td>
<td>获取所有等待获取许可的线程集合</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>drainPermits()</code></td>
<td>获取可用许可个数，并将可用许可置为 0</td>
</tr>
</tbody></table>
<h2 id="11-2-CountDownLatch"><a href="#11-2-CountDownLatch" class="headerlink" title="11.2 CountDownLatch"></a>11.2 <code>CountDownLatch</code></h2><h3 id="1-概述-9"><a href="#1-概述-9" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>用来进行线程同步写作，等待所有线程完成倒计时</li>
<li>允许一个或多个线程等待其他线程完成操作</li>
</ol>
<h3 id="2-构造-1"><a href="#2-构造-1" class="headerlink" title="2 构造"></a>2 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>CountDownLatch(int count)</code></td>
<td>构造时传入一个计数</td>
</tr>
</tbody></table>
<h3 id="3-方法-1"><a href="#3-方法-1" class="headerlink" title="3 方法"></a>3 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>countDown()</code></td>
<td>计数减 <code>1</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>await()</code></td>
<td>当前线程等待，当计数归 <code>0</code>，当前线程继续执行</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>await(long timeout, TimeUnit unit)</code></td>
<td>当前线程等待，当计数归 <code>0</code> 或者超时，当前线程继续执行</td>
</tr>
</tbody></table>
<h2 id="11-3-CyclicBarrier"><a href="#11-3-CyclicBarrier" class="headerlink" title="11.3 CyclicBarrier"></a>11.3 <code>CyclicBarrier</code></h2><h3 id="1-概述-10"><a href="#1-概述-10" class="headerlink" title="1 概述"></a>1 概述</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/CyclicBarrier.gif" alt=""></p>
<ol>
<li>循环栅栏，用来进行线程协作，等待线程满足某个计数</li>
<li>阻塞一组线程直到某个事件的发生</li>
<li><code>CountDownLatch</code> 只能拦截一轮，<code>CyclicBarrier</code> 可以实现循环拦截</li>
<li>构造时设置计数，每个线程执行到某个需要同步的时刻则等待，当等待的线程数满足计数时，继续执行</li>
</ol>
<h3 id="2-构造-2"><a href="#2-构造-2" class="headerlink" title="2 构造"></a>2 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>CyclicBarrier(int parties)</code></td>
<td>构造时传入一个计数，表示需要等待的线程数</td>
</tr>
<tr>
<td><code>CyclicBarrier(int parties, Runnable barrierAction)</code></td>
<td><code>barrierAction</code>：等待线程数达到时首先执行的任务</td>
</tr>
</tbody></table>
<h3 id="3-方法-2"><a href="#3-方法-2" class="headerlink" title="3 方法"></a>3 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>await()</code></td>
<td>当前线程等待，直到等待线程数达到初始计数</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>await(long timeout, TimeUnit unit)</code></td>
<td>当前线程等待，直到等待线程数达到初始计数或超时</td>
</tr>
</tbody></table>
<h1 id="十二-线程池"><a href="#十二-线程池" class="headerlink" title="十二 线程池"></a>十二 线程池</h1><h2 id="12-1-线程池体系"><a href="#12-1-线程池体系" class="headerlink" title="12.1 线程池体系"></a>12.1 线程池体系</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/JUC-executor.png" alt=""></p>
<h2 id="12-2-线程池执行过程"><a href="#12-2-线程池执行过程" class="headerlink" title="12.2 线程池执行过程"></a>12.2 线程池执行过程</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%87%E7%A8%8B01.png" alt=""></p>
<p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%87%E7%A8%8B02.png" alt=""></p>
<h2 id="12-3-线程池状态"><a href="#12-3-线程池状态" class="headerlink" title="12.3 线程池状态"></a>12.3 线程池状态</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.png" alt=""></p>
<table>
<thead>
<tr>
<th>状态</th>
<th>高 3 位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Running</code></td>
<td><code>111</code></td>
<td>接收新任务，能处理已添加任务</td>
</tr>
<tr>
<td><code>Shutdown</code></td>
<td><code>000</code></td>
<td>不接收新任务，能处理已添加任务</td>
</tr>
<tr>
<td><code>Stop</code></td>
<td><code>001</code></td>
<td>不接收新任务，不处理已添加任务，且中断正在处理的任务</td>
</tr>
<tr>
<td><code>Tidying</code></td>
<td><code>010</code></td>
<td>所有任务已终止，<code>ctl</code> 记录的活动线程为 0，即将进入终结</td>
</tr>
<tr>
<td><code>Terminated</code></td>
<td><code>011</code></td>
<td>线程池彻底终止</td>
</tr>
</tbody></table>
<ol start="2">
<li>线程池的运行状态和活动线程数信息存储在一个原子变量 <code>AtomicInteger ctl</code> 中，目的是将线程池状态和线程个数合二为一，这样就可以用一次 <code>CAS</code> 原子操作进行赋值</li>
<li><code>ctl</code> 高 3 位表示线程池状态，低 29 位表示线程池数量</li>
</ol>
<h2 id="12-4-线程池数量"><a href="#12-4-线程池数量" class="headerlink" title="12.4 线程池数量"></a>12.4 线程池数量</h2><ol>
<li><code>N<sub>threds</sub> = N<sub>CPU</sub> * U<sub>CPU</sub> * (1 + W/C)</code><ul>
<li><code>N<sub>CPU</sub></code> ：CPU 的核数</li>
<li><code>U<sub>CPU</sub></code> ：CPU 期望利用率 <code>(0, 1]</code></li>
<li><code>W/C</code> ：等待时间和计算时间比率</li>
</ul>
</li>
<li>CPU 密集型运算：<code>线程数 = CPU核数 + 1</code></li>
<li>I/O 密集型运算：<code>线程数 = CPU核数 * 期望CPU利用率 *（CPU计算时间 + 等待时间）/ CPU计算时间</code></li>
</ol>
<h2 id="12-5-ThreadPoolExecutor"><a href="#12-5-ThreadPoolExecutor" class="headerlink" title="12.5 ThreadPoolExecutor"></a>12.5 <code>ThreadPoolExecutor</code></h2><h3 id="1-构造-3"><a href="#1-构造-3" class="headerlink" title="1 构造"></a>1 构造</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, </span><br><span class="line">                    <span class="keyword">int</span> maximumPoolSize, </span><br><span class="line">                    <span class="keyword">long</span> keepAliveTime, </span><br><span class="line">                    TimeUnit unit, </span><br><span class="line">                    BlockingQueue&lt;Runnable&gt; workQueue, </span><br><span class="line">                    ThreadFactory threadFactory, </span><br><span class="line">                    RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int corePoolSize</code></td>
<td>核心线程数</td>
</tr>
<tr>
<td><code>int maximumPoolSize</code></td>
<td>最大线程数</td>
</tr>
<tr>
<td><code>long keepAliveTime</code></td>
<td>线程最大空闲时间，如果线程池中线程数量超过 <code>corePoolSize</code>，超出线程空闲时间超过 <code>keepAliveTime</code> 会被终止</td>
</tr>
<tr>
<td><code>TimeUnit unit</code></td>
<td>空闲时间单位</td>
</tr>
<tr>
<td><code>BlockingQueue&lt;Runnable&gt; workQueue</code></td>
<td>任务阻塞队列</td>
</tr>
<tr>
<td><code>ThreadFactory threadFactory</code></td>
<td>线程工厂</td>
</tr>
<tr>
<td><code>RejectedExecutionHandler handler</code></td>
<td>拒绝策略</td>
</tr>
</tbody></table>
<h4 id="1-Enum-TimeUnit"><a href="#1-Enum-TimeUnit" class="headerlink" title="1 Enum TimeUnit"></a>1 <code>Enum TimeUnit</code></h4><h5 id="1-枚举项：时间粒度"><a href="#1-枚举项：时间粒度" class="headerlink" title="1 枚举项：时间粒度"></a>1 枚举项：时间粒度</h5><table>
<thead>
<tr>
<th>粒度</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>NANOSECONDS</code></td>
<td>纳秒 <code>ns</code></td>
<td><code>1 s  = 10<sup>9</sup> ns</code></td>
</tr>
<tr>
<td><code>MICROSECONDS</code></td>
<td>微秒 <code>μs</code></td>
<td><code>1 s  = 10<sup>6</sup> μs</code></td>
</tr>
<tr>
<td><code>MILLISECONDS</code></td>
<td>毫秒 <code>ms</code></td>
<td><code>1 s  = 10<sup>3</sup> ms</code></td>
</tr>
<tr>
<td><code>SECONDS</code></td>
<td>秒 <code>s</code></td>
<td></td>
</tr>
<tr>
<td><code>MINUTES</code></td>
<td>分 <code>min</code></td>
<td></td>
</tr>
<tr>
<td><code>HOURS</code></td>
<td>时 <code>h</code></td>
<td></td>
</tr>
<tr>
<td><code>DAYS</code></td>
<td>日 <code>d</code></td>
<td></td>
</tr>
</tbody></table>
<h5 id="2-方法：线程"><a href="#2-方法：线程" class="headerlink" title="2 方法：线程"></a>2 方法：线程</h5><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>sleep(long timeout)</code></td>
<td>当前线程睡眠当前粒度的 <code>timout</code>，替代 <code>Thread.sleep(timeout)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>timedJoin(Thread thread, long timeout)</code></td>
<td>指定线程 <code>join</code> 当前粒度的 <code>timeout</code>，替代 <code>t.join(timout)</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>timedWait(Object obj, long timeout)</code></td>
<td>锁对象 <code>obj</code> 等待当前粒度的 <code>timout</code>，替代 <code>obj.wait(timout)</code></td>
</tr>
</tbody></table>
<h5 id="3-方法：时间粒度转换"><a href="#3-方法：时间粒度转换" class="headerlink" title="3 方法：时间粒度转换"></a>3 方法：时间粒度转换</h5><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>long</code></td>
<td><code>convert(Duration duration)</code></td>
<td>将指定时间间隔 <code>duration</code> 转换为当前粒度</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>convert(long sourceDuration, TimeUnit sourceUnit)</code></td>
<td>将指定数值 <code>sourceDuration</code> 的指定粒度 <code>sourceUnit</code> 转换为当前粒度</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toNanos(long duration)</code></td>
<td>将指定数值 <code>duration</code> 的当前粒度转换为纳秒</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toMicros(long duration)</code></td>
<td>将指定数值 <code>duration</code> 的当前粒度转换为微秒</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toMillis(long duration)</code></td>
<td>将指定数值 <code>duration</code> 的当前粒度转换为毫秒</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toSeconds(long duration)</code></td>
<td>将指定数值 <code>duration</code> 的当前粒度转换为秒</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toMinutes(long duration)</code></td>
<td>将指定数值 <code>duration</code> 的当前粒度转换为分</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toHours(long duration)</code></td>
<td>将指定数值 <code>duration</code> 的当前粒度转换为时</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>toDays(long duration)</code></td>
<td>将指定数值 <code>duration</code> 的当前粒度转换为日</td>
</tr>
</tbody></table>
<h4 id="2-ThreadFactory"><a href="#2-ThreadFactory" class="headerlink" title="2 ThreadFactory"></a>2 <code>ThreadFactory</code></h4><ol>
<li>默认使用 <code>Executors.defaultThreadFactory()</code></li>
<li>自定义线程工厂实现此接口</li>
<li>使用不同的工厂，可以更改线程名称，线程组，优先级，守护线程状态等等</li>
</ol>
<h4 id="3-RejectedExecutionHandler"><a href="#3-RejectedExecutionHandler" class="headerlink" title="3 RejectedExecutionHandler"></a>3 <code>RejectedExecutionHandler</code></h4><table>
<thead>
<tr>
<th>内置拒绝策略</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>AbortPolicy</code>（默认）</td>
<td>放弃本次任务，抛 <code>RejectedExecutionException</code> 异常</td>
</tr>
<tr>
<td><code>DiscardPolicy</code></td>
<td>放弃本次任务</td>
</tr>
<tr>
<td><code>DiscardOldestPolicy</code></td>
<td>放弃队列中最早的任务，本次任务取而代之</td>
</tr>
<tr>
<td><code>CallerRunsPolicy</code></td>
<td>让调用者处理任务</td>
</tr>
</tbody></table>
<ul>
<li>自定义拒绝策略实现此接口<ol>
<li><code>Dubbo</code> 的实现：抛 异常之前会记录日志，并 <code>dump</code> 线程栈信息，方便定位</li>
<li><code>Netty</code> 的实现：创建一个新线程来执行任务</li>
<li><code>ActiveMQ</code> 的实现：带超时等待（60s）尝试放入队列</li>
<li><code>PinPoint</code> 的实现：使用了一个拒绝策略链，会逐一尝试</li>
</ol>
</li>
</ul>
<h3 id="2-方法-2"><a href="#2-方法-2" class="headerlink" title="2 方法"></a>2 方法</h3><h4 id="1-提交任务"><a href="#1-提交任务" class="headerlink" title="1 提交任务"></a>1 提交任务</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>`void</td>
<td><code>execute(Runnable command)</code></td>
<td>执行任务 <code>Runnable</code> 任务</td>
</tr>
<tr>
<td><code>&lt;T&gt; Future&lt;T&gt;</code></td>
<td><code>submit(Callable&lt;T&gt; task)</code></td>
<td>提交 <code>Callable</code> 任务，使用 <code>Future</code> 获取任务执行结果</td>
</tr>
<tr>
<td><code>Future&lt;?&gt;</code></td>
<td><code>submit(Runnable task)</code></td>
<td>提交 <code>Runnbale</code> 任务，使用 <code>Future</code> 获取任务执行结果</td>
</tr>
<tr>
<td>`<T> Future<T></td>
<td><code>submit(Runnable task, T result)</code></td>
<td>提交带返回值的 <code>Runnbale</code> 任务，使用 <code>Future</code> 获取任务执行结果</td>
</tr>
<tr>
<td><code>&lt;T&gt; List&lt;Future&lt;T&gt;&gt;</code></td>
<td><code>invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</code></td>
<td>提交多个任务</td>
</tr>
<tr>
<td><code>&lt;T&gt; List&lt;Future&lt;T&gt;&gt;</code></td>
<td><code>invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)</code></td>
<td>提交多个任务，带超时时间</td>
</tr>
<tr>
<td><code>&lt;T&gt; T</code></td>
<td><code>invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</code></td>
<td>提交多个任务，哪个任务先成功执行完毕则返回其结果，其它任务取消</td>
</tr>
<tr>
<td><code>&lt;T&gt; T</code></td>
<td><code>invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)</code></td>
<td>提交多个任务，哪个任务先成功执行完毕则返回其结果，其它任务取消，带超时时间</td>
</tr>
</tbody></table>
<h4 id="2-关闭线程池"><a href="#2-关闭线程池" class="headerlink" title="2 关闭线程池"></a>2 关闭线程池</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>shutdown()</code></td>
<td>线程池状态变为 <code>Shutdown</code>，不再接收新任务，已提交任务会被执行完，此方法不会阻塞调用线程的执行</td>
</tr>
<tr>
<td><code>List&lt;Runnable&gt;</code></td>
<td><code>shutdownNow()</code></td>
<td>线程池状态变为 <code>Stop</code>，不再接收新任务，用 <code>interrupt()</code> 中断正在执行的任务，返回队列中等待执行的任务</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isShutdown()</code></td>
<td>测试线程池是否关闭，线程池状态不为 <code>Running</code>，都会返回 <code>true</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isTerminated()</code></td>
<td>测试是否所有任务都执行完毕了，线程池状态为 <code>Terminated</code>，返回 <code>true</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>awaitTermination(long timeout, TimeUnit unit)</code></td>
<td>由于调用 <code>shutdown</code> 后，调用线程并不会等待所有任务执行完毕，可以使用此方法等待线程池状态变为 <code>Terminated</code></td>
</tr>
</tbody></table>
<h2 id="12-6-Executors"><a href="#12-6-Executors" class="headerlink" title="12.6 Executors"></a>12.6 <code>Executors</code></h2><h3 id="1-固定大小线程池"><a href="#1-固定大小线程池" class="headerlink" title="1 固定大小线程池"></a>1 固定大小线程池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">	return new ThreadPoolExecutor(nThreads, nThreads, </span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS, </span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>核心线程数 = 最大线程数，即不会有救急线程被创建，也就没有超时时间</li>
<li>阻塞队列 <code>LinkedBlockingQueue</code> 最大为 <code>Integer.MAX_VALUE</code></li>
<li>适合任务量已知，相对耗时的任务</li>
</ol>
<h3 id="2-带缓冲线程池"><a href="#2-带缓冲线程池" class="headerlink" title="2 带缓冲线程池"></a>2 带缓冲线程池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">	return new ThreadPoolExecutor(0, Integer.MAX_VALUE, </span><br><span class="line">                                    60L, TimeUnit.SECONDS, </span><br><span class="line">                                    new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>核心线程数为 <code>0</code>，最大线程数为 <code>Integer.MAX_VALUE</code>，意味着全为救急线程，且超时时间为 <code>60s</code></li>
<li>阻塞队列 <code>SynchronousQueue</code> 没有容量，读写操作一一对应，意味着提交一个任务就必须马上执行</li>
<li>适合任务数比较密集，但每个任务耗时较短的情况</li>
</ol>
<h3 id="3-单线程线程池"><a href="#3-单线程线程池" class="headerlink" title="3 单线程线程池"></a>3 单线程线程池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService(</span><br><span class="line">    		new ThreadPoolExecutor(1, 1, </span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS, </span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>核心线程数 = 最大线程数 = 1，即线程数固定为 1</li>
<li>适合多个任务排队执行</li>
<li>单线程线程池 &amp; 自己创建一个线程的区别<ol>
<li>自己创建一个线程，如果某个任务执行失败而终止，那么没有任何补救措施</li>
<li>单线程线程池会新创建一个线程，保证池中始终有一个工作线程，且线程池有任务阻塞队列</li>
</ol>
</li>
<li>单线程线程池 &amp; 数量为 1 的固定大小线程池的区别<ol>
<li>固定大小线程池对外暴漏的是 <code>ThreadPoolExecutor</code> 对象，所以可以使用其方法修改核心线程数</li>
<li>单线程线程池 <code>FinalizableDelegatedExecutorService</code> 使用的是装饰着模式，只对外暴漏了 <code>ExecutorService</code> 的方法，不能使用  <code>ThreadPoolExecutor</code> 的特有方法，无法修改</li>
</ol>
</li>
</ol>
<h3 id="4-任务调度线程池"><a href="#4-任务调度线程池" class="headerlink" title="4 任务调度线程池"></a>4 任务调度线程池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">	return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">	super(corePoolSize, Integer.MAX_VALUE, </span><br><span class="line">		DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">		new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>没有任务调度线程池之前，<code>java.util.Timer</code> 可以用来实现定时功能，缺点：<ol>
<li>所有任务由一个线程调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行</li>
<li>如果某一个任务出现异常，会影响到之后的任务</li>
</ol>
</li>
<li>任务调度线程池可以由不同的线程来执行任务，且某个任务出现异常也不会影响其它任务</li>
</ol>
<h2 id="12-7-ScheduledThreadPoolExecutor"><a href="#12-7-ScheduledThreadPoolExecutor" class="headerlink" title="12.7 ScheduledThreadPoolExecutor"></a>12.7 <code>ScheduledThreadPoolExecutor</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ScheduledFuture&lt;?&gt;</code></td>
<td><code>schedule(Runnable command, long delay, TimeUnit unit)</code></td>
<td>指定延迟后，执行 <code>Runnable</code> 任务</td>
</tr>
<tr>
<td><code>&lt;V&gt; ScheduledFuture&lt;V&gt;</code></td>
<td><code>schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code></td>
<td>指定延迟后，执行 <code>Callable</code> 任务</td>
</tr>
<tr>
<td><code>ScheduledFuture&lt;?&gt;</code></td>
<td><code>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code></td>
<td>初始延迟时间后开始执行任务，到达 <code>period</code> 间隔时间后，判断上一个任务是否执行完毕，若执行完毕则执行下一个任务，否则等待其执行完毕</td>
</tr>
<tr>
<td><code>ScheduledFuture&lt;?&gt;</code></td>
<td><code>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code></td>
<td>初始延迟时间后开始执行任务，上一个任务执行完毕后延迟指定时间再开始执行下一个任务</td>
</tr>
</tbody></table>
<h2 id="12-8-Fork-Join"><a href="#12-8-Fork-Join" class="headerlink" title="12.8 Fork/Join"></a>12.8 <code>Fork/Join</code></h2><h3 id="1-概述-11"><a href="#1-概述-11" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><code>Fork/Join</code> 是 JDK 7 加入的新的线程池实现，体现的是一种分治思想，适用于能够进行任务拆分的 CPU 密集型运算</li>
<li>分支/合并框架的目的是以递归方式将可以并行的任务拆分成更小的任务，然后将每个子任务的结果合并起来生成整体结果</li>
<li><code>Fork/Join</code> 是 <code>ExecutorService</code> 接口的一个实现，它把子任务分配给线程池（称为 <code>ForkJoinPool</code> ）中的工作线程</li>
</ol>
<h3 id="2-任务"><a href="#2-任务" class="headerlink" title="2 任务"></a>2 任务</h3><h4 id="1-概述-12"><a href="#1-概述-12" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li><p>提交给 <code>Fork/Join</code> 线程池的任务需要继承 <code>ForkJoinTask&lt;V&gt;</code></p>
<ol>
<li><code>RecursiveTask&lt;V&gt;</code>：有返回值，<code>V</code>是并行化任务（以及所有子任务）产生的结果类型</li>
<li><code>RecursiveAction</code>：无返回值</li>
</ol>
</li>
<li><p>定义的任务， 只需实现它唯一的抽象方法 <code>V compute()</code>，此方法同时定义了：</p>
<ol>
<li>将任务拆分成子任务的逻辑</li>
<li>无法再拆分或不方便再拆分时，生成单个子任务结果的逻辑</li>
</ol>
</li>
<li><p><code>compute()</code> 伪代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (任务足够小或不可分) &#123;</span><br><span class="line">	顺序计算该任务</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    将任务分成两个子任务</span><br><span class="line">    递归调用本方法，拆分每个子任务，等待所有子任务完成</span><br><span class="line">    合并每个子任务的结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2-ForkJoinTask-lt-V-gt"><a href="#2-ForkJoinTask-lt-V-gt" class="headerlink" title="2 ForkJoinTask&lt;V&gt;"></a>2 <code>ForkJoinTask&lt;V&gt;</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinTask&lt;V&gt; fork()：使用 ForkJoinPool 中另一个线程异步执行子任务</span><br><span class="line">V join()：获取子任务结果，如果尚未完成就等待</span><br></pre></td></tr></table></figure>

<h3 id="3-工作窃取"><a href="#3-工作窃取" class="headerlink" title="3 工作窃取"></a>3 工作窃取</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96.png" alt=""></p>
<ol>
<li>理想情况下，划分并行任务时，应该让每个任务都用完全相同的时间完成，让所有的CPU内核都同样繁忙。不幸的是，实际中，每个子任务所花的时间可能天差地别</li>
<li>分支/合并框架工程用一种称为工作窃取（<code>work stealing</code>）的技术来解决这个问题</li>
<li>工作窃取算法用于在池中的工作线程之间重新分配和平衡任务<ol>
<li>每个线程都为分配给它的任务保存一个双向链式队列，每完成一个任务，就会从队列头上取出下一个任务开始执<br>行</li>
<li>某个线程可能早早完成了分配给它的所有任务，也就是它的队列已经空了，而其他的线程还很忙。这时，这个线程并没有闲下来，而是随机选了一个别的线程，从其队列的尾巴上“偷走”一个任务</li>
<li>这个过程一直继续下去，直到所有的任务都执行完毕，所有的队列都清空</li>
</ol>
</li>
</ol>
<h3 id="4-ForkJoinPool"><a href="#4-ForkJoinPool" class="headerlink" title="4 ForkJoinPool"></a>4 <code>ForkJoinPool</code></h3><h4 id="1-构造-4"><a href="#1-构造-4" class="headerlink" title="1 构造"></a>1 构造</h4><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ForkJoinPool()</code></td>
<td>默认会创建和 CPU 核心数相同大小的线程池</td>
</tr>
<tr>
<td><code>ForkJoinPool(int parallelism)</code></td>
<td>指定线程数</td>
</tr>
</tbody></table>
<h4 id="2-方法-3"><a href="#2-方法-3" class="headerlink" title="2 方法"></a>2 方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; T invoke(ForkJoinTask&lt;T&gt; task)</span><br><span class="line">void execute(ForkJoinTask&lt;?&gt; task)</span><br><span class="line">&lt;T&gt; ForkJoinTask&lt;T&gt; submit(ForkJoinTask&lt;T&gt; task)</span><br></pre></td></tr></table></figure>

<h1 id="十三-线程安全集合"><a href="#十三-线程安全集合" class="headerlink" title="十三 线程安全集合"></a>十三 线程安全集合</h1><h2 id="13-1-概述"><a href="#13-1-概述" class="headerlink" title="13.1 概述"></a>13.1 概述</h2><ol>
<li><p>遗留的线程安全集合如  <code>Hashtable</code> ， <code>Vector</code></p>
</li>
<li><p>使用 <code>Collections</code> 装饰的线程安全集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collections.synchronizedCollection</span><br><span class="line">Collections.synchronizedList</span><br><span class="line">Collections.synchronizedMap</span><br><span class="line">Collections.synchronizedSet</span><br><span class="line">Collections.synchronizedNavigableMap</span><br><span class="line">Collections.synchronizedNavigableSet</span><br><span class="line">Collections.synchronizedSortedMap</span><br><span class="line">Collections.synchronizedSortedSet</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>java.util.concurrent.*</code></p>
<ol>
<li><code>Blocking</code>：大部分实现基于锁，并提供用来阻塞的方法</li>
<li><code>CopyOnWrite</code>：写开销相对较重</li>
<li><code>Concurrent</code>：<ol>
<li>内部很多操作使用 <code>CAS</code> 优化，一般可以提供较高吞吐量</li>
<li>弱一致性<ul>
<li>遍历时弱一致性：当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍<br>历，但这时内容是旧的（非安全容器会抛异常）</li>
<li>求大小弱一致性：size 操作未必是 100% 准确</li>
<li>读取弱一致性</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="13-2-ConcurrentHashMap-lt-K-V-gt"><a href="#13-2-ConcurrentHashMap-lt-K-V-gt" class="headerlink" title="13.2 ConcurrentHashMap&lt;K,V&gt;"></a>13.2 <code>ConcurrentHashMap&lt;K,V&gt;</code></h2><h3 id="1-概述-13"><a href="#1-概述-13" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>JDK 7 中非线程安全的 Map 集合当元素下标相同时，会添加到链表的头部，而 JDK 8 则是添加到链表的尾部</li>
<li>JDK 7 中在多线程环境使用非线程安全的 Map 集合，当扩容时可能出现并发死链，JDK 8 虽然将扩容算法做了调整，但还是会出现其他问题，如扩容丢数据</li>
</ol>
<h3 id="2-重要属性和内部类"><a href="#2-重要属性和内部类" class="headerlink" title="2 重要属性和内部类"></a>2 重要属性和内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 默认为 0</span><br><span class="line">// 当初始化时, 为 -1</span><br><span class="line">// 当扩容时, 为 -(1 + 扩容线程数)</span><br><span class="line">// 当初始化或扩容完成后，为 下一次的扩容的阈值大小</span><br><span class="line">private transient volatile int sizeCtl;</span><br><span class="line"></span><br><span class="line">// 整个 ConcurrentHashMap 就是一个 Node[]</span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">// hash 表</span><br><span class="line">transient volatile Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">// 扩容时的 新 hash 表</span><br><span class="line">private transient volatile Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点</span><br><span class="line">static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node</span><br><span class="line">static final class ReservationNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 作为 treebin 的头节点, 存储 root 和 first</span><br><span class="line">static final class TreeBin&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 作为 treebin 的节点, 存储 parent, left, right</span><br><span class="line">static final class TreeNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-重要方法"><a href="#3-重要方法" class="headerlink" title="3 重要方法"></a>3 重要方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取 Node[] 中第 i 个 Node</span><br><span class="line">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i)</span><br><span class="line"></span><br><span class="line">// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值</span><br><span class="line">static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span><br><span class="line"></span><br><span class="line">// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值</span><br><span class="line">static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v)</span><br></pre></td></tr></table></figure>

<h2 id="13-3-CopyOnWriteArrayList"><a href="#13-3-CopyOnWriteArrayList" class="headerlink" title="13.3 CopyOnWriteArrayList"></a>13.3 <code>CopyOnWriteArrayList</code></h2><ol>
<li><code>ArrayList</code></li>
<li>每次写入时都会复制一个新的容器再写入</li>
<li>在迭代并添加时没有并发修改异常</li>
<li>每次写入都会复制，效率低，适合并发迭代</li>
</ol>
<h1 id="十四-java-lang-ThreadLocal-lt-T-gt"><a href="#十四-java-lang-ThreadLocal-lt-T-gt" class="headerlink" title="十四 java.lang.ThreadLocal&lt;T&gt;"></a>十四 <code>java.lang.ThreadLocal&lt;T&gt;</code></h1><h2 id="14-1-概述"><a href="#14-1-概述" class="headerlink" title="14.1 概述"></a>14.1 概述</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 ThreadLocal</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 Thread</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>ThreadLocal</code> 中有一个静态内部类 <code>ThreadLocalMap</code>，<code>ThreadLocalMap</code> 中有一个静态内部类 <code>Entry</code>，且维护了一个 <code>Entry</code> 类型的数组，其实数据最终存储在了 <code>Entry[]</code> 中</li>
<li><code>TheadLocalMap</code> 的键为 <code>ThreaLoal</code> 本身，值为自定义添加的值</li>
<li>一个 <code>ThreadLocalMap</code> 可以存储 <code>n</code> 个 <code>ThreadLocal</code>，所以存储时，会根据不同的  <code>ThreadLocal</code> 计算出不同的索引，此索引即存储到 <code>ThreadLocalMap</code> 中的 <code>Entry[]</code> 中的位置</li>
<li>每个线程对应一个 <code>ThreadLoaclMap</code> ，不同线程互不干扰</li>
<li>每个线程可以有多个不同的 <code>ThreadLocal</code>（如 <code>ThreadLocal&lt;A&gt;, ThreadLoacl&lt;B&gt;...</code>），所有 <code>ThreadLocal</code> 使用同一个 <code>ThreadLocalMap</code></li>
<li><code>Entry</code> 是一个弱引用<ol>
<li>如果是强引用，即使 <code>ThreadLocal tl = null</code> ，<code>Entry</code> 中的键依然指向 <code>ThreadLocal</code> ，会导致内存泄漏</li>
<li>弱引用还是有内存泄漏问题：当 <code>ThreadLocal</code> 为 <code>null</code> 被当成垃圾回收，但 <code>ThreadLocalMap</code> 生命周期和 <code>Thread</code> 一样，它不会回收，即 <code>Entry</code> 中的键为 <code>null</code> 了，而值还存在，但无法访问到了，所以使用完 <code>ThreadLocal</code> 后，执行 <code>remove()</code> 操作</li>
</ol>
</li>
</ol>
<h2 id="14-2-API"><a href="#14-2-API" class="headerlink" title="14.2 API"></a>14.2 API</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>set(T value)</code></td>
<td>此 <code>ThreadLocal</code> 作为键，<code>value</code> 作为值，存储到当前线程的 <code>ThreadLoaclMap</code> 中</td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>get()</code></td>
<td>从当前线程的 <code>ThreadLoaclMap</code> 中，获取键 <code>ThreadLocal</code> 对应的值</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>remove()</code></td>
<td>从当前线程的 <code>ThreadLoaclMap</code> 中，移除此 <code>ThreadLocal</code> 的键值对</td>
</tr>
</tbody></table>
<h3 id="1-set"><a href="#1-set" class="headerlink" title="1 set"></a>1 <code>set</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的 ThreadLocalMap，如果已存在则直接使用，否则创建一个</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-get"><a href="#2-get" class="headerlink" title="2 get"></a>2 <code>get</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/09/29/Java/Java-%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/09/29/Java/Java-%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">Java-集合</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-09-29 15:54:08 / 修改时间：15:54:24" itemprop="dateCreated datePublished" datetime="2020-09-29T15:54:08+08:00">2020-09-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-java-util-Collection-lt-E-gt"><a href="#一-java-util-Collection-lt-E-gt" class="headerlink" title="一 java.util.Collection&lt;E&gt;"></a>一 <code>java.util.Collection&lt;E&gt;</code></h1><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/Collection.png" alt=""></p>
<h2 id="1-1-API"><a href="#1-1-API" class="headerlink" title="1.1 API"></a>1.1 API</h2><h3 id="1-增"><a href="#1-增" class="headerlink" title="1 增"></a>1 增</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>add(E e)</code></td>
<td>添加一个元素</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>addAll(Collection&lt;? extends E&gt; c)</code></td>
<td>添加一个集合的元素</td>
</tr>
</tbody></table>
<h3 id="2-删"><a href="#2-删" class="headerlink" title="2 删"></a>2 删</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>remove(Object o)</code></td>
<td>删除一个元素</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>removeAll(Collection&lt;?&gt; c)</code></td>
<td>删除交集</td>
</tr>
<tr>
<td><code>default boolean</code></td>
<td><code>removeIf(Predicate&lt;? super E&gt; filter)</code></td>
<td>删除符合条件的元素</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
<td>清空集合</td>
</tr>
</tbody></table>
<h3 id="3-判断"><a href="#3-判断" class="headerlink" title="3 判断"></a>3 判断</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>contains(Object o)</code></td>
<td>判断是否包含指定元素</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>containsAll(Collection&lt;?&gt; c)</code></td>
<td>判断是否包含指定集合</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isEmpty()</code></td>
<td>判断是否为空</td>
</tr>
</tbody></table>
<h3 id="4-获取"><a href="#4-获取" class="headerlink" title="4 获取"></a>4 获取</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>size()</code></td>
<td>获取元素个数</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>retainAll(Collection&lt;?&gt; c)</code></td>
<td>取交集</td>
</tr>
</tbody></table>
<h3 id="5-转换"><a href="#5-转换" class="headerlink" title="5 转换"></a>5 转换</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object[]</code></td>
<td><code>toArray()</code></td>
<td>集合 → 数组</td>
</tr>
<tr>
<td><code>&lt;T&gt; T[]</code></td>
<td><code>toArray(T[] a)</code></td>
<td>集合 → 指定类型的数组（建议传入数组 <code>length = size</code>）</td>
</tr>
<tr>
<td><code>default &lt;T&gt; T[]</code></td>
<td><code>toArray(IntFunction&lt;T[]&gt; generator)</code></td>
<td>集合 → 指定类型的数组（由函数生成）</td>
</tr>
</tbody></table>
<h3 id="6-遍历"><a href="#6-遍历" class="headerlink" title="6 遍历"></a>6 遍历</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Iterator&lt;E&gt;</code></td>
<td><code>iterator()</code></td>
<td>获取迭代器</td>
</tr>
<tr>
<td><code>default Spliterator&lt;E&gt;</code></td>
<td><code>spliterator()</code></td>
<td>获取并行迭代器</td>
</tr>
</tbody></table>
<h3 id="7-流"><a href="#7-流" class="headerlink" title="7 流"></a>7 流</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>default Stream&lt;E&gt;</code></td>
<td><code>stream()</code></td>
<td>获取顺序流</td>
</tr>
<tr>
<td><code>default Stream&lt;E&gt;</code></td>
<td><code>parallelStream()</code></td>
<td>获取并行流</td>
</tr>
</tbody></table>
<h2 id="1-2-java-util-List-lt-E-gt"><a href="#1-2-java-util-List-lt-E-gt" class="headerlink" title="1.2 java.util.List&lt;E&gt;"></a>1.2 <code>java.util.List&lt;E&gt;</code></h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>元素有序（存取顺序一致）</li>
<li>元素有索引</li>
<li>元素可以重复</li>
</ol>
<h3 id="2-API"><a href="#2-API" class="headerlink" title="2 API"></a>2 API</h3><h4 id="1-增-1"><a href="#1-增-1" class="headerlink" title="1 增"></a>1 增</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>add(int index, E element)</code></td>
<td>在指定位置插入元素</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>addAll(int index, Collection&lt;? extends E&gt; c)</code></td>
<td>在指定位置插入一个集合的元素</td>
</tr>
</tbody></table>
<h4 id="2-删-1"><a href="#2-删-1" class="headerlink" title="2 删"></a>2 删</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>E</code></td>
<td><code>remove(int index)</code></td>
<td>删除指定位置的元素并返回</td>
</tr>
</tbody></table>
<h4 id="3-改"><a href="#3-改" class="headerlink" title="3 改"></a>3 改</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>E</code></td>
<td><code>set(int index, E element)</code></td>
<td>修改指定位置的元素</td>
</tr>
</tbody></table>
<h4 id="4-查"><a href="#4-查" class="headerlink" title="4 查"></a>4 查</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>indexOf(Object o)</code></td>
<td>从头开始查询元素第一次出现的索引</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>lastIndexOf(Object o)</code></td>
<td>从尾开始查询元素第一次出现的索引</td>
</tr>
</tbody></table>
<h4 id="5-获取"><a href="#5-获取" class="headerlink" title="5 获取"></a>5 获取</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>E</code></td>
<td><code>get(int index)</code></td>
<td>获取指定位置的元素</td>
</tr>
<tr>
<td><code>List&lt;E&gt;</code></td>
<td><code>subList(int fromIndex, int toIndex)</code></td>
<td>截取集合 <code>[from, to)</code></td>
</tr>
<tr>
<td><code>static &lt;E&gt; List&lt;E&gt;</code></td>
<td><code>of(E... elements)</code></td>
<td>获取包含指定元素的不可修改（只读）的 <code>List</code> 集合</td>
</tr>
<tr>
<td><code>static &lt;E&gt; List&lt;E&gt;</code></td>
<td><code>copyOf(Collection&lt;? extends E&gt; coll)</code></td>
<td>如果传入的集合是不可变的则直接返回，否则通过 <code>of</code> 创建一个包含其元素的不可修改的 <code>List</code> 集合（顺序为指定集合元素的迭代顺序）</td>
</tr>
</tbody></table>
<h4 id="6-遍历-1"><a href="#6-遍历-1" class="headerlink" title="6 遍历"></a>6 遍历</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ListIterator&lt;E&gt;</code></td>
<td><code>listIterator()</code></td>
<td>获取 <code>ListIterator</code> 迭代器</td>
</tr>
<tr>
<td><code>ListIterator&lt;E&gt;</code></td>
<td><code>listIterator(int index)</code></td>
<td>获取 <code>ListIterator</code> 迭代器，从指定索引开始</td>
</tr>
</tbody></table>
<h3 id="3-ArrayList"><a href="#3-ArrayList" class="headerlink" title="3 ArrayList"></a>3 <code>ArrayList</code></h3><h4 id="1-构造"><a href="#1-构造" class="headerlink" title="1 构造"></a>1 构造</h4><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ArrayList()</code></td>
<td>默认容量为 <code>10</code>，每次扩容为原容量的 1.5 倍（JDK8以后，创建时 <code>{}</code>，第一次添加时才创建容量 10 的数组）</td>
</tr>
<tr>
<td><code>ArrayList(int initialCapacity)</code></td>
<td>指定容量</td>
</tr>
<tr>
<td><code>ArrayList(Collection&lt;? extends E&gt; c)</code></td>
<td>包含指定集合元素</td>
</tr>
</tbody></table>
<h4 id="2-ArrayList-VS-Vector"><a href="#2-ArrayList-VS-Vector" class="headerlink" title="2 ArrayList VS Vector"></a>2 <code>ArrayList VS Vector</code></h4><ol>
<li><code>ArrayList</code> 非同步，<code>Vector</code> 同步</li>
<li><code>ArrayList</code> 扩容是原来的 1.5 倍，<code>Vector</code> 扩容是原来的 2 倍</li>
<li><code>Vector</code> 支持 <code>Enumeration</code> </li>
</ol>
<h3 id="4-Stack"><a href="#4-Stack" class="headerlink" title="4 Stack"></a>4 <code>Stack</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>empty()</code></td>
<td>判断是否为空</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>peek()</code></td>
<td>获取但不弹出栈顶元素</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>pop()</code></td>
<td>弹栈（获取并弹出栈顶元素）</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>push(E item)</code></td>
<td>压栈（将元素添加到栈顶）</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>serach(Object o)</code></td>
<td>返回指定元素的位置编号（栈顶为 1）</td>
</tr>
</tbody></table>
<h2 id="1-3-java-util-Set-lt-E-gt"><a href="#1-3-java-util-Set-lt-E-gt" class="headerlink" title="1.3 java.util.Set&lt;E&gt;"></a>1.3 <code>java.util.Set&lt;E&gt;</code></h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>元素唯一，不保证存取顺序<ul>
<li><code>HashSet</code>：元素存取无序</li>
<li><code>LinkedHashSet</code>：元素存取有序</li>
<li><code>TreeSet</code>：元素存取无序但会排序</li>
</ul>
</li>
<li><code>Set</code> 集合底层依赖于 <code>Map</code> 集合，添加到 <code>Set</code> 中的元素作为键，一个内部的共享对象作为值</li>
</ol>
<h3 id="2-API-1"><a href="#2-API-1" class="headerlink" title="2 API"></a>2 API</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static &lt;E&gt; Set&lt;E&gt;</code></td>
<td><code>of(E... elements)</code></td>
<td>获取包含指定元素的不可修改的 <code>Set</code> 集合</td>
</tr>
<tr>
<td><code>static &lt;E&gt; Set&lt;E&gt;</code></td>
<td><code>copyOf(Collection&lt;? extends E&gt; coll)</code></td>
<td>获取包含指定集合中所有元素的不可修改的 <code>Set</code> 集合</td>
</tr>
</tbody></table>
<h3 id="3-HashSet-amp-LinkedHashSet"><a href="#3-HashSet-amp-LinkedHashSet" class="headerlink" title="3 HashSet &amp; LinkedHashSet"></a>3 <code>HashSet</code> &amp; <code>LinkedHashSet</code></h3><ol>
<li>添加元素时，首先 <code>hashCode()</code> 获取元素的哈希值，然后根据某种算法，算出底层数组中的存放位置<ul>
<li>如果此位置上没有元素，则添加成功</li>
<li>如果此位置上有元素<ul>
<li>首先比较哈希值，如果哈希值不同，则添加成功</li>
<li>如果哈希值相同，则比较 <code>equals()</code></li>
</ul>
</li>
</ul>
</li>
<li>元素要存入 <code>HashSet</code> 需要重写 <code>hashCode()</code> 和 <code>equals()</code> 方法</li>
<li>一个位置多个元素以链表形式存储多个元素，七上八下：<ul>
<li>jdk7：新元素在上，指向旧元素</li>
<li>jdk8：新元素在下，旧元素指向新元素</li>
</ul>
</li>
</ol>
<h3 id="4-TreeSet"><a href="#4-TreeSet" class="headerlink" title="4 TreeSet"></a>4 <code>TreeSet</code></h3><ol>
<li>元素具有比较性，元素实现 <code>Comparable</code> 接口</li>
<li>集合具有比较性，集合传入一个实现了 <code>Comparator</code> 接口的比较器</li>
<li><code>TreeSet</code> 判断元素是否相同，就是看到比较结果</li>
</ol>
<h2 id="1-4-Queue-lt-E-gt"><a href="#1-4-Queue-lt-E-gt" class="headerlink" title="1.4 Queue&lt;E&gt;"></a>1.4 <code>Queue&lt;E&gt;</code></h2><h3 id="1-API"><a href="#1-API" class="headerlink" title="1 API"></a>1 API</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>add(E e)</code></td>
<td>向队列末尾添加元素，如果队列已满则抛异常 <code>IllegalStateException</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>offer(E e)</code></td>
<td>向队列末尾添加元素，如果队列已满则返回 <code>false</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>element()</code></td>
<td>获取但不移除队列第一个元素，如果队列为空则抛异常 <code>NoSuchElementEsxception</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>peek()</code></td>
<td>获取但不移除队列第一个元素，如果队列为空则返回 <code>null</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>remove()</code></td>
<td>获取并移除队列第一个元素，如果队列为空则则抛异常 <code>NoSuchElementEsxception</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>poll()</code></td>
<td>获取并移除队列第一个元素，如果队列为空则返回 <code>null</code></td>
</tr>
</tbody></table>
<h3 id="2-Deque-lt-E-gt"><a href="#2-Deque-lt-E-gt" class="headerlink" title="2 Deque&lt;E&gt;"></a>2 <code>Deque&lt;E&gt;</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>addFirst(E e)</code></td>
<td>向队列首部添加元素，如果队列已满则抛异常 <code>IllegalStateException</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>offerFirst(E e)</code></td>
<td>向队列首部添加元素，如果队列已满则返回 <code>false</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>addLast(E e)</code></td>
<td>向队列尾部添加元素，如果队列已满则抛异常 <code>IllegalStateException</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>offerLast(E e)</code></td>
<td>向队列尾部添加元素，如果队列已满则返回 <code>false</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>getFirst()</code></td>
<td>获取但不移除队列第一个元素，如果队列为空则抛异常 <code>NoSuchElementEsxception</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>peekFirst()</code></td>
<td>获取但不移除队列第一个元素，如果队列为空则返回 <code>null</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>getLast()</code></td>
<td>获取但不移除队列最后一个元素，如果队列为空则抛异常 <code>NoSuchElementEsxception</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>peekLast()</code></td>
<td>获取但不移除队列最后一个元素，如果队列为空则返回 <code>null</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>removeFirst()</code></td>
<td>获取并移除队列第一个元素，如果队列为空则则抛异常 <code>NoSuchElementEsxception</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>pollFirst()</code></td>
<td>获取并移除队列第一个元素，如果队列为空则返回 <code>null</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>removeLast()</code></td>
<td>获取并移除队列最后一个元素，如果队列为空则则抛异常 <code>NoSuchElementEsxception</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>pollLast()</code></td>
<td>获取并移除队列最后一个元素，如果队列为空则返回 <code>null</code></td>
</tr>
</tbody></table>
<h3 id="3-BlockingQueue-lt-E-gt"><a href="#3-BlockingQueue-lt-E-gt" class="headerlink" title="3 BlockingQueue&lt;E&gt;"></a>3 <code>BlockingQueue&lt;E&gt;</code></h3><h4 id="1-API-1"><a href="#1-API-1" class="headerlink" title="1 API"></a>1 API</h4><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>add(E e)</code></td>
<td>向队列末尾添加元素，如果队列已满则抛异常 <code>IllegalStateException</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>offer(E e)</code></td>
<td>向队列末尾添加元素，如果队列已满则返回 <code>false</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>offer(E e, long timeout, TimeUnit unit)</code></td>
<td>向队列末尾添加元素，如果队列已满会尝试指定时间，超时则返回 <code>false</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>put(E e)</code></td>
<td>向队列末尾添加元素，如果队列已满则阻塞等待</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>remove()</code></td>
<td>获取并移除队列第一个元素，如果队列为空则则抛异常 <code>NoSuchElementEsxception</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>poll()</code></td>
<td>获取并移除队列第一个元素，如果队列为空则返回 <code>null</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>poll(long timeout, TimeUnit unit)</code></td>
<td>获取并移除队列第一个元素，如果队列为空会尝试指定时间，超时则返回 <code>null</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>take()</code></td>
<td>获取并移除队列第一个元素，如果队列为空则阻塞等待</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>element()</code></td>
<td>获取但不移除队列第一个元素，如果队列为空则抛异常 <code>NoSuchElementEsxception</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>peek()</code></td>
<td>获取但不移除队列第一个元素，如果队列为空则返回 <code>null</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th><code>Throws exception</code></th>
<th><code>Special value</code></th>
<th><code>Times out</code></th>
<th><code>Blocks</code></th>
</tr>
</thead>
<tbody><tr>
<td>增加</td>
<td><code>add(e)</code></td>
<td><code>offer(e)</code></td>
<td><code>offer(e, time, unit)</code></td>
<td><code>put(e)</code></td>
</tr>
<tr>
<td>删除</td>
<td><code>remove()</code></td>
<td><code>poll()</code></td>
<td><code>poll(time, unit)</code></td>
<td><code>take()</code></td>
</tr>
<tr>
<td>检测队首元素</td>
<td><code>element()</code></td>
<td><code>peek()</code></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="2-实现类"><a href="#2-实现类" class="headerlink" title="2 实现类"></a>2 实现类</h4><table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ArrayBlockingQueue</code></td>
<td>数组结构的有界阻塞队列</td>
</tr>
<tr>
<td><code>LinkedBlockingQueue</code></td>
<td>链表结构的有界阻塞队列（默认 <code>Integer.MAX_VALUE</code>，也可以看作是无界的）</td>
</tr>
<tr>
<td><code>SynchronousQueue</code></td>
<td>容量为 0，是一个不存储元素的阻塞队列，读写操作配对出现，只有一个时会阻塞等待</td>
</tr>
<tr>
<td><code>DelayQueue</code></td>
<td>优先级堆支持的，基于时间的调度队列（元素按阻塞程度排序，会先获取阻塞低的元素）</td>
</tr>
<tr>
<td><code>PriorityBlockingQueue</code></td>
<td>优先级堆支持的无界优先级队列（内部使用二叉树排好了序）</td>
</tr>
</tbody></table>
<h1 id="二-java-util-Map-lt-K-V-gt"><a href="#二-java-util-Map-lt-K-V-gt" class="headerlink" title="二 java.util.Map&lt;K,V&gt;"></a>二 <code>java.util.Map&lt;K,V&gt;</code></h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/Map.png" alt=""></p>
<table>
<thead>
<tr>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>HashMap</code></td>
<td>键唯一，存取无序，<code>null</code> 可以作为键和值，线程不安全（非同步）</td>
</tr>
<tr>
<td><code>HashTable</code></td>
<td>键唯一，存取无序，<code>null</code> 不能作为键和值，线程安全（同步）</td>
</tr>
<tr>
<td><code>LinkedHashMap</code></td>
<td>键唯一，存取有序</td>
</tr>
<tr>
<td><code>Properties</code></td>
<td>键唯一，存取无序，键值必须是字符串</td>
</tr>
<tr>
<td><code>TreeMap</code></td>
<td>键唯一，存取无序，元素根据键排序</td>
</tr>
</tbody></table>
<h2 id="2-2-键唯一性"><a href="#2-2-键唯一性" class="headerlink" title="2.2 键唯一性"></a>2.2 键唯一性</h2><h3 id="1-HashMap-HashTable-LinkedHashMap-Properties"><a href="#1-HashMap-HashTable-LinkedHashMap-Properties" class="headerlink" title="1 HashMap HashTable LinkedHashMap Properties"></a>1 <code>HashMap HashTable LinkedHashMap Properties</code></h3><ol>
<li><code>hashCode()</code></li>
<li><code>equals()</code></li>
</ol>
<h3 id="2-TreeMap"><a href="#2-TreeMap" class="headerlink" title="2 TreeMap"></a>2 <code>TreeMap</code></h3><ol>
<li>键具有比较性</li>
<li>集合传入比较器</li>
</ol>
<h2 id="2-3-API"><a href="#2-3-API" class="headerlink" title="2.3 API"></a>2.3 API</h2><h3 id="1-增-2"><a href="#1-增-2" class="headerlink" title="1 增"></a>1 增</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>V</code></td>
<td><code>put​(K key, V value)</code></td>
<td>添加键值对，若 key 已存在返回 value，否则返回 null</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>putAll(Map m)</code></td>
<td>添加一个集合的键值对</td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>putIfAbsent(K key, V value)</code></td>
<td>如果指定的 <code>key</code> 没有值或值为 <code>null</code>，则将其值设置为指定 <code>value</code>，否则返回已有的值</td>
</tr>
</tbody></table>
<h3 id="2-删-2"><a href="#2-删-2" class="headerlink" title="2 删"></a>2 删</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>V</code></td>
<td><code>remove(Object key)</code></td>
<td>根据指定 <code>key</code> 删除并返回 <code>value</code>，若不存在则返回 <code>null</code></td>
</tr>
<tr>
<td><code>default boolean</code></td>
<td><code>remove(Object key, Object value)</code></td>
<td>删除指定键值对</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>clear()</code></td>
<td>清空集合</td>
</tr>
</tbody></table>
<h3 id="3-获取"><a href="#3-获取" class="headerlink" title="3 获取"></a>3 获取</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>V</code></td>
<td><code>get(Object key)</code></td>
<td>根据指定 <code>key</code> 获取 <code>value</code>，若不存在则返回 <code>null</code></td>
</tr>
<tr>
<td><code>default V</code></td>
<td><code>getOrDefault(Object key, V defaultValue)</code></td>
<td>根据指定 <code>key</code> 获取 <code>value</code>，若不存在则返回 <code>defaultValue</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>size()</code></td>
<td>获取键值对个数</td>
</tr>
<tr>
<td><code>static &lt;K, V&gt; Map&lt;K, V&gt;</code></td>
<td><code>copyOf(Map&lt;? extends K, ? extends V&gt; map)</code></td>
<td>获取包含指定集合键值对的不可修改的 <code>Map</code> 集合</td>
</tr>
</tbody></table>
<h3 id="4-判断"><a href="#4-判断" class="headerlink" title="4 判断"></a>4 判断</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>isEmpty()</code></td>
<td>是否为空</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>containsKey(Object key)</code></td>
<td>是否包含指定 <code>key</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>containsValue(Object value)</code></td>
<td>是否包含指定 <code>value</code></td>
</tr>
</tbody></table>
<h3 id="5-遍历"><a href="#5-遍历" class="headerlink" title="5 遍历"></a>5 遍历</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Set&lt;K&gt;</code></td>
<td><code>keySet()</code></td>
<td>获取所有 <code>key</code> 的 <code>Set</code> 集合</td>
</tr>
<tr>
<td><code>Collection&lt;V&gt;</code></td>
<td><code>values()</code></td>
<td>获取所有 <code>value</code> 的集合</td>
</tr>
<tr>
<td><code>Set&lt;Map.Entry&lt;K, V&gt;&gt;</code></td>
<td><code>entrySet()</code></td>
<td>获取所有键值对映射关系的 <code>Set</code> 集合</td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code>forEach(BiConsumer&lt;? super K, ? super V&gt; action)</code></td>
<td>遍历键值对并消费</td>
</tr>
</tbody></table>
<h2 id="2-4-HashMap"><a href="#2-4-HashMap" class="headerlink" title="2.4 HashMap"></a>2.4 <code>HashMap</code></h2><h3 id="1-JDK7：数组-链表"><a href="#1-JDK7：数组-链表" class="headerlink" title="1 JDK7：数组 + 链表"></a>1 JDK7：数组 + 链表</h3><h4 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1 相关概念"></a>1 相关概念</h4><ol>
<li><code>DEFAULT_INITIAL_CAPACITY = 16</code> <ul>
<li>默认初始容量</li>
</ul>
</li>
<li><code>DEFAULT_LOAD_FACTOR = 0.75f</code><ul>
<li>默认加载因子</li>
</ul>
</li>
<li><code>threshold = capacity * loadFactor</code><ul>
<li>阈值/临界值，到达此值数组需要扩容</li>
</ul>
</li>
</ol>
<h4 id="2-过程"><a href="#2-过程" class="headerlink" title="2 过程"></a>2 过程</h4><ol>
<li>构造时，初始化一个长度为 16 的 <code>Entry[]</code> 数组，并算出 <code>threshold</code> 阈值</li>
<li>每次 <code>put()</code>  添加时，先获取 <code>key</code> 的哈希值，然后根据某种算法计算出在 <code>Entry[]</code> 数组中的存放位置<ul>
<li>如果此位置没有数据，则将键值对构建为 <code>Entry</code> 对象添加成功</li>
<li>如果此位置有数据，则比较新加 <code>key</code> 与已存在 <code>key</code> 的哈希值<ul>
<li>如果不同，则添加成功</li>
<li>如果相同，则继续比较 <code>key</code> 的 <code>equals()</code><ul>
<li>如果不同，则添加成功</li>
<li>如果相同，则覆盖 <code>value</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>key</code> 不重复时，当大于等于阈值且要存储的位置没有数据时需要扩容（默认变为原容量 2 倍），且集合元素重新计算位置</li>
<li>同一位置的多个数据以链表形式存在，新元素在上边，旧元素会作为新元素的 <code>next</code></li>
</ol>
<h3 id="2-JDK8：数组-链表-红黑树"><a href="#2-JDK8：数组-链表-红黑树" class="headerlink" title="2 JDK8：数组 + 链表/红黑树"></a>2 JDK8：数组 + 链表/红黑树</h3><h4 id="1-相关概念-1"><a href="#1-相关概念-1" class="headerlink" title="1 相关概念"></a>1 相关概念</h4><ol>
<li><code>DEFAULT_INITIAL_CAPACITY = 16</code> <ul>
<li>默认初始容量</li>
</ul>
</li>
<li><code>DEFAULT_LOAD_FACTOR = 0.75f</code><ul>
<li>默认加载因子</li>
</ul>
</li>
<li><code>MAXIMUM_CAPACITY = 1 &lt;&lt; 30</code><ul>
<li>最大容量</li>
</ul>
</li>
<li><code>TREEIFY_THRESHOLD = 8</code><ul>
<li>树化阈值，当链表长度达到此长度时，要考虑树化</li>
</ul>
</li>
<li><code>UNTREEIFY_THRESHOLD = 6</code><ul>
<li>反树化阈值，当树中的节点个数到达此值时，要考虑变为链表</li>
</ul>
</li>
<li><code>MIN_TREEIFY_CAPACITY = 64</code><ul>
<li>最小树化容量，当达到树化阈值且容量不小于次之时，才会树化</li>
</ul>
</li>
<li><code>threshold = capacity * loadFactor</code><ul>
<li>阈值/临界值，当已用容量到达此值数值时，要考虑扩容</li>
</ul>
</li>
</ol>
<h4 id="2-过程-1"><a href="#2-过程-1" class="headerlink" title="2 过程"></a>2 过程</h4><ol>
<li>构造时，没有初始化数组</li>
<li>第一次 <code>put()</code> 添加时，将数组初始化为长度为 16 的 <code>Node[]</code> 数组，并算出 <code>threshold</code> 阈值</li>
<li>添加时过程相同，区别在于链表存储时七上八下，jdk8新的元素在下边，旧元素的 <code>next</code> 指向新元素</li>
<li>添加时还需要判断该索引下是否已经是树结构<ol>
<li>如果不是，则判断是否需要树化，当达到树化阈值及树化容量时，会将链表变为红黑树</li>
<li>如果是，则添加</li>
</ol>
</li>
<li>添加时还需要判断扩容问题</li>
</ol>
<h2 id="2-5-Properties"><a href="#2-5-Properties" class="headerlink" title="2.5 Properties"></a>2.5 <code>Properties</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>getProperty(String key)</code></td>
<td>根据 <code>key</code> 获取 <code>value</code>，若不存在则返回 <code>null</code></td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getProperty(String key, String defaultValue)</code></td>
<td>根据 <code>key</code> 获取 <code>value</code>，若不存在则返回 <code>defaultValue</code></td>
</tr>
<tr>
<td><code>Object</code></td>
<td><code>setProperty(String key, String value)</code></td>
<td>添加键值对，调用的 <code>HashTable</code> 的 <code>put</code> 方法</td>
</tr>
<tr>
<td><code>Set&lt;String&gt;</code></td>
<td><code>stringPropertyNames()</code></td>
<td>获取所有 <code>key</code> 的 <code>Set</code> 集合</td>
</tr>
<tr>
<td><code>Enumeration&lt;?&gt;</code></td>
<td><code>propertyNames()</code></td>
<td>获取所有 <code>key</code> 的枚举</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>load(InputStream inStream)</code></td>
<td>从字节输入流中读取键值对数据</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>load(Reader reader)</code></td>
<td>从字符输入流中读取键值对数据</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>store(OutputStream out, String comments)</code></td>
<td>将键值对数据写入字节输出流，<code>comment</code> 为描述信息</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>store(Writer writer, String comments)</code></td>
<td>将键值对数据写入字符输出流</td>
</tr>
</tbody></table>
<h1 id="三-集合遍历"><a href="#三-集合遍历" class="headerlink" title="三 集合遍历"></a>三 集合遍历</h1><h2 id="3-1-java-lang-Iterable-lt-T-gt"><a href="#3-1-java-lang-Iterable-lt-T-gt" class="headerlink" title="3.1 java.lang.Iterable&lt;T&gt;"></a>3.1 <code>java.lang.Iterable&lt;T&gt;</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Iterator&lt;T&gt;</code></td>
<td><code>iterator()</code></td>
<td>获取迭代器</td>
</tr>
<tr>
<td><code>default Spliterator&lt;T&gt;</code></td>
<td><code>spliterator()</code></td>
<td>获取并行迭代器</td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code>forEach(Consumer&lt;? super T&gt; action)</code></td>
<td>增强 for 循环</td>
</tr>
</tbody></table>
<h2 id="3-2-java-util-Iterator-lt-E-gt"><a href="#3-2-java-util-Iterator-lt-E-gt" class="headerlink" title="3.2 java.util.Iterator&lt;E&gt;"></a>3.2 <code>java.util.Iterator&lt;E&gt;</code></h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>hasNext()</code></td>
<td>判断是否有下一个元素</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>next()</code></td>
<td>获取下一个元素</td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code>remove()</code></td>
<td>删除 <code>next()</code> 获取的元素，即删除之前要先获取</td>
</tr>
<tr>
<td><code>default void</code></td>
<td><code>forEachRemaining​(Consumer&lt;? super E&gt; action)</code></td>
<td>遍历并消费元素</td>
</tr>
</tbody></table>
<h2 id="3-3-java-util-ListIterator-lt-E-gt"><a href="#3-3-java-util-ListIterator-lt-E-gt" class="headerlink" title="3.3 java.util.ListIterator&lt;E&gt;"></a>3.3 <code>java.util.ListIterator&lt;E&gt;</code></h2><h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h3><ol>
<li><code>ListIterator</code> 是 <code>Iterator</code> 的子接口</li>
<li>在迭代时可以添加修改元素，且可以往回迭代</li>
</ol>
<h3 id="2-API-2"><a href="#2-API-2" class="headerlink" title="2 API"></a>2 API</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>hasNext()</code></td>
<td>判断是否有下一个元素</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>next()</code></td>
<td>获取下一个元素</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>nextIndex()</code></td>
<td>获取下一个元素的索引</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>hasPrevious()</code></td>
<td>判断是否有上一个元素</td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>previous()</code></td>
<td>获取上一个元素</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>previousIndex()</code></td>
<td>获取上一个元素的索引</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>add(E e)</code></td>
<td>添加元素</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>remove()</code></td>
<td>删除 <code>next()</code> 或 <code>previous()</code> 获取的元素</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>set(E e)</code></td>
<td>修改 <code>next()</code> 或 <code>previous()</code> 获取的元素</td>
</tr>
</tbody></table>
<h2 id="3-4-集合遍历的方式"><a href="#3-4-集合遍历的方式" class="headerlink" title="3.4 集合遍历的方式"></a>3.4 集合遍历的方式</h2><h3 id="1-集合转为数组，使用普通-for-循环"><a href="#1-集合转为数组，使用普通-for-循环" class="headerlink" title="1 集合转为数组，使用普通 for 循环"></a>1 集合转为数组，使用普通 for 循环</h3><ul>
<li>遍历时可以增删，索引要相应变化</li>
</ul>
<h3 id="2-迭代器"><a href="#2-迭代器" class="headerlink" title="2 迭代器"></a>2 迭代器</h3><ol>
<li>遍历时如果增会发生并发修改异常 <code>ConcurrentModifyException</code></li>
<li>遍历时可以使用迭代器的删除方法进行删除</li>
</ol>
<h3 id="3-增强-for-循环"><a href="#3-增强-for-循环" class="headerlink" title="3 增强 for 循环"></a>3 增强 for 循环</h3><ol>
<li><code>Iterable</code> 接口的子类或子接口都可以使用 <code>foreach</code>，如数组，集合</li>
<li>遍历时不能增删，因为增强 for 循环底层还是迭代器，增删会发生并发修改异常</li>
</ol>
<h2 id="3-5-modCount"><a href="#3-5-modCount" class="headerlink" title="3.5 modCount"></a>3.5 <code>modCount</code></h2><ol>
<li>在 <code>ArrayList，LinkedList，HashMap...</code> 等集合中有此属性，用来记录集合被修改的次数（添加 删除）</li>
<li>使用迭代器或 <code>foreach</code> 遍历集合时，会记录遍历开始时的 <code>modCount</code><ol>
<li>遍历时使用迭代器自身的增删方法修改集合，不会改变 <code>modCount</code></li>
<li>遍历时使用集合的增删方法，会修改 <code>modCount</code>，前后 <code>modCount</code> 不一致，说明有两个线程在同时操作集合，这种操作有风险，为了保证安全性就会报异常</li>
</ol>
</li>
</ol>
<h1 id="四-泛型（Generics）"><a href="#四-泛型（Generics）" class="headerlink" title="四 泛型（Generics）"></a>四 泛型（Generics）</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ol>
<li>如果没有泛型，就意味着你并不知道集合中存储的是什么类型的数据，那就只能认为都是 Object，所以在使用时，你想要把数据当作某种具体的类型来使用<ol>
<li>需要强制类型转换</li>
<li>有可能 <code>ClassCastException</code> 异常</li>
</ol>
</li>
<li>泛型就是一种可以在使用时明确数据类型的功能（类似形参实参）<ol>
<li>定义时声明了泛型</li>
<li>使用时就可以使用泛型这种功能来明确数据类型</li>
</ol>
</li>
<li>泛型的好处<ol>
<li>明确了数据类型，使用时就不用再做类型转换</li>
<li>限定了数据类型，就意味着如果不合法，编译通不过，把运行期的错误提前到了编译期</li>
</ol>
</li>
<li>泛型：参数化类型 Parameterized type<ul>
<li><code>&lt;引用数据类型&gt;</code></li>
</ul>
</li>
</ol>
<h2 id="4-2-泛型定义"><a href="#4-2-泛型定义" class="headerlink" title="4.2 泛型定义"></a>4.2 泛型定义</h2><h3 id="1-定义语法"><a href="#1-定义语法" class="headerlink" title="1 定义语法"></a>1 定义语法</h3><table>
<thead>
<tr>
<th>目标</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td><code>泛型类</code></td>
<td><code>修饰符 class 类名&lt;泛型形参列表&gt;{}</code></td>
</tr>
<tr>
<td><code>泛型接口</code></td>
<td><code>修饰符 interface 接口名&lt;泛型形参列表&gt;{}</code></td>
</tr>
<tr>
<td><code>泛型方法</code></td>
<td><code>修饰符 &lt;泛型形参列表&gt; 返回值类型 方法名(形参列表) {}</code></td>
</tr>
</tbody></table>
<ol>
<li>泛型形参可以为任意标识符，如 <code>E T K V ...</code></li>
<li>泛型定义时可以限定使用时的类型上下限<ol>
<li><code>T extends 上限</code></li>
<li><code>T super 下限</code></li>
</ol>
</li>
<li>类/接口上定义的泛型，内部非静态成员可以直接使用<ol>
<li>创建对象时指定具体类型</li>
<li>子类上指定具体类型</li>
<li>静态成员不能使用泛型，因为静态比泛型确定具体类型的时机要早</li>
</ol>
</li>
<li>方法上定义的泛型，可以在方法形参和内部使用<ol>
<li>调用方法时指定具体类型</li>
<li>泛型方法可以是静态的，因为是调用时确定的类型</li>
<li>方法上的泛型与类或接口没有关系</li>
</ol>
</li>
</ol>
<h3 id="2-泛型类-接口的子类"><a href="#2-泛型类-接口的子类" class="headerlink" title="2 泛型类/接口的子类"></a>2 泛型类/接口的子类</h3><h4 id="1-明确数据类型"><a href="#1-明确数据类型" class="headerlink" title="1 明确数据类型"></a>1 明确数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 子类名 extends 父类&lt;具体类型&gt; &#123;&#125;</span><br><span class="line">修饰符 class 子类名 implements 接口&lt;具体类型&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-不明确数据类型"><a href="#2-不明确数据类型" class="headerlink" title="2 不明确数据类型"></a>2 不明确数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 子类名&lt;泛型形参列表&gt; extends 父类&lt;泛型形参列表&gt; &#123;&#125;</span><br><span class="line">修饰符 class 子类名&lt;泛型形参列表&gt; implements 接口&lt;泛型形参列表&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-泛型通配符"><a href="#4-3-泛型通配符" class="headerlink" title="4.3 泛型通配符"></a>4.3 泛型通配符</h2><table>
<thead>
<tr>
<th>通配符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;?&gt;</code></td>
<td>写入时只能添加 <code>null</code>，读取时读取的类型为 <code>Object</code></td>
</tr>
<tr>
<td><code>? extends E</code></td>
<td>设定上限，必须是 E 及其子类</td>
</tr>
<tr>
<td><code>? super E</code></td>
<td>设定下限，必须是 E 及其父类</td>
</tr>
</tbody></table>
<ul>
<li><p><code>A</code> 和 <code>B</code> 是子父类关系，<code>G&lt;A&gt;</code> 和 <code>G&lt;B&gt;</code> 没有关系，它们共同父类是 <code>G&lt;?&gt;</code></p>
</li>
<li><p>为什么使用 <code>?</code> 而不能用 <code>Object</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;&#125; <span class="comment">// 正确</span></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	因为使用时，ArrayList&lt;String&gt; 就意味着将通配符指定为 String</span></span><br><span class="line"><span class="comment">	则 ArrayList&lt;String&gt; = new ArrayList&lt;String&gt;(); 没问题</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="number">2</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Collection&lt;Object&gt; c)</span> </span>&#123;&#125; <span class="comment">// 错误</span></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	因为使用时， ArrayList&lt;String&gt; = new ArrayList&lt;Number&gt;(); </span></span><br><span class="line"><span class="comment">	由于接收的是 Object 所以理论上是没有问题的，但泛型前后必须一致，所以错误</span></span><br><span class="line"><span class="comment">	*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="五-java-util-Collections"><a href="#五-java-util-Collections" class="headerlink" title="五 java.util.Collections"></a>五 <code>java.util.Collections</code></h1><h2 id="1-1-增删改查"><a href="#1-1-增删改查" class="headerlink" title="1.1 增删改查"></a>1.1 增删改查</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static &lt;T&gt; boolean</code></td>
<td><code>addAll(Collection&lt;? super T&gt; c, T... elements)</code></td>
<td>添加多个元素到指定集合</td>
</tr>
<tr>
<td><code>static &lt;T&gt; void</code></td>
<td><code>copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</code></td>
<td>将 <code>List</code> 集合 <code>src</code> 中的元素拷贝到 <code>dest</code> 中</td>
</tr>
<tr>
<td><code>static &lt;T&gt; boolean</code></td>
<td><code>replaceAll(List&lt;T&gt; list, T oldVal, T newVal)</code></td>
<td>将 <code>List</code> 中所有的 <code>oldVal</code> 替换为 <code>newVal</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; int</code></td>
<td><code>binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)</code></td>
<td><code>List</code> 集合二分查找，要求 <code>List</code> 中的元素有比较性</td>
</tr>
<tr>
<td><code>static &lt;T&gt; int</code></td>
<td><code>binarySearch(List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c)</code></td>
<td><code>List</code> 集合二分查找，使用指定比较器</td>
</tr>
<tr>
<td><code>static int</code></td>
<td><code>frequency(Collection&lt;?&gt; c, Object o)</code></td>
<td>获取指定元素在集合中出现的次数</td>
</tr>
</tbody></table>
<h2 id="1-2-排序"><a href="#1-2-排序" class="headerlink" title="1.2 排序"></a>1.2 排序</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static &lt;T extends Comparable&lt;? super T&gt;&gt; void</code></td>
<td><code>sort(List&lt;T&gt; list)</code></td>
<td>按照元素自然顺序对 <code>List</code> 集合排序</td>
</tr>
<tr>
<td><code>static &lt;T&gt; void</code></td>
<td><code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code></td>
<td>使用指定比较器对 <code>List</code> 集合排序</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>reverse(List&lt;?&gt; list)</code></td>
<td>反转 <code>LIst</code> 集合</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>shuffle(List&lt;?&gt; list)</code></td>
<td>随机洗牌</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>swap(List&lt;?&gt; list, int i, int j)</code></td>
<td>交换 <code>LIst</code> 集合指定索引的元素</td>
</tr>
</tbody></table>
<h2 id="1-3-获取集合"><a href="#1-3-获取集合" class="headerlink" title="1.3 获取集合"></a>1.3 获取集合</h2><h3 id="1-immutable"><a href="#1-immutable" class="headerlink" title="1 immutable"></a>1 <code>immutable</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static &lt;T&gt; List&lt;T&gt;</code></td>
<td><code>singletonList(T o)</code></td>
<td>返回不可变的只包含一个元素的 <code>List</code> 集合</td>
</tr>
<tr>
<td><code>static &lt;T&gt; Set&lt;T&gt;</code></td>
<td><code>singleton(T o)</code></td>
<td>返回不可变的只包含一个元素的 <code>Set</code> 集合</td>
</tr>
<tr>
<td><code>static &lt;K, V&gt; Map&lt;K, V&gt;</code></td>
<td><code>singletonMap(K key, V value)</code></td>
<td>返回不可变的只包含一对键值的 <code>Map</code> 集合</td>
</tr>
</tbody></table>
<h3 id="2-synchronized"><a href="#2-synchronized" class="headerlink" title="2 synchronized"></a>2 <code>synchronized</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>static &lt;T&gt; Collection&lt;T&gt;</code></td>
<td><code>synchronizedCollection(Collection&lt;T&gt; c)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; List&lt;T&gt;</code></td>
<td><code>synchronizedList(List&lt;T&gt; list)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; Set&lt;T&gt;</code></td>
<td><code>synchronizedSet(Set&lt;T&gt; s)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; NavigableSet&lt;T&gt;</code></td>
<td><code>synchronizedNavigableSet(NavigableSet&lt;T&gt; s)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; SortedSet&lt;T&gt;</code></td>
<td><code>synchronizedSortedSet(SortedSet&lt;T&gt; s)</code></td>
</tr>
<tr>
<td><code>static &lt;K, V&gt; Map&lt;K, V&gt;</code></td>
<td><code>synchronizedMap(Map&lt;K, V&gt; m)</code></td>
</tr>
<tr>
<td><code>static &lt;K, V&gt; NavigableMap&lt;K, V&gt;</code></td>
<td><code>synchronizedNavigableMap(NavigableMap&lt;K, V&gt; m)</code></td>
</tr>
<tr>
<td><code>static &lt;K, V&gt; SortedMap&lt;K, V&gt;</code></td>
<td><code>synchronizedSortedMap(SortedMap&lt;K, V&gt; m)</code></td>
</tr>
</tbody></table>
<h3 id="3-Unmodifiable（只读）"><a href="#3-Unmodifiable（只读）" class="headerlink" title="3 Unmodifiable（只读）"></a>3 <code>Unmodifiable</code>（只读）</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>static &lt;T&gt; Collection&lt;T&gt;</code></td>
<td><code>unmodifiableCollection(Collection&lt;? extends T&gt; c)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; List&lt;T&gt;</code></td>
<td><code>unmodifiableList(List&lt;? extends T&gt; list)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; Set&lt;T&gt;</code></td>
<td><code>unmodifiableSet(Set&lt;? extends T&gt; s)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; NavigableSet&lt;T&gt;</code></td>
<td><code>unmodifiableNavigableSet(NavigableSet&lt;T&gt; s)</code></td>
</tr>
<tr>
<td><code>static &lt;T&gt; SortedSet&lt;T&gt;</code></td>
<td><code>unmodifiableSortedSet(SortedSet&lt;T&gt; s)</code></td>
</tr>
<tr>
<td><code>static &lt;K, V&gt; Map&lt;K, V&gt;</code></td>
<td><code>unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></td>
</tr>
<tr>
<td><code>static &lt;K, V&gt; NavigableMap&lt;K, V&gt;</code></td>
<td><code>unmodifiableNavigableMap(NavigableMap&lt;K, ? extends V&gt; m)</code></td>
</tr>
<tr>
<td><code>static &lt;K, V&gt; SortedMap&lt;K, V&gt;</code></td>
<td><code>unmodifiableSortedMap(SortedMap&lt;K, ? extends V&gt; m)</code></td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://anyeansan.github.io/anyeansan.github.io/2020/09/29/Java/Java-IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/anyeansan.github.io/images/an3.png">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="一蓑烟雨任平生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安₃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/anyeansan.github.io/2020/09/29/Java/Java-IO/" class="post-title-link" itemprop="url">Java-IO</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">✦</span>
              

              <time title="创建时间：2020-09-29 15:52:03 / 修改时间：15:53:01" itemprop="dateCreated datePublished" datetime="2020-09-29T15:52:03+08:00">2020-09-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">☛</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/anyeansan.github.io/categories/CS/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-File"><a href="#一-File" class="headerlink" title="一 File"></a>一 <code>File</code></h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ol>
<li>File 类代表了一个文件或一个目录</li>
<li>File 类中涉及到的关于文件或目录的创建、删除、修改等方法，并未涉及到写入或读取文件内容的操作。如需读写文件内容，必须通过 IO 流来完成</li>
</ol>
<h2 id="1-2-属性"><a href="#1-2-属性" class="headerlink" title="1.2 属性"></a>1.2 属性</h2><table>
<thead>
<tr>
<th>修饰</th>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static char</code></td>
<td><code>separatorChar</code></td>
<td>路径分隔符；<code>unix &#39;/&#39;</code>，<code>windows &#39;\\&#39;</code></td>
</tr>
<tr>
<td><code>static String</code></td>
<td><code>separator</code></td>
<td><code>&quot;&quot; + separatorChar</code></td>
</tr>
<tr>
<td><code>static char</code></td>
<td><code>pathSeparatorChar</code></td>
<td>多个路径之间的分隔符；<code>unix :</code> ，<code>windows  ;</code></td>
</tr>
<tr>
<td><code>static String</code></td>
<td><code>pathSeparator</code></td>
<td><code>&quot;&quot; + pathSeparatorChar</code></td>
</tr>
</tbody></table>
<h2 id="1-3-构造"><a href="#1-3-构造" class="headerlink" title="1.3 构造"></a>1.3 构造</h2><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>File​(String pathname)</code></td>
<td>根据路径字符串构造 <code>File</code></td>
</tr>
<tr>
<td><code>File​(String parent, String child)</code></td>
<td>根据父路径字符串和子路径字符串构造 <code>File</code></td>
</tr>
<tr>
<td><code>File​(File parent, String child)</code></td>
<td>根据父 <code>File</code> 和 子路径字符串构造 <code>File</code></td>
</tr>
<tr>
<td><code>File(URI uri)</code></td>
<td>根据 <code>uri</code> 构造 <code>File</code></td>
</tr>
</tbody></table>
<h2 id="1-4-方法"><a href="#1-4-方法" class="headerlink" title="1.4 方法"></a>1.4 方法</h2><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1 创建"></a>1 创建</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>createNewFile()</code></td>
<td>创建文件，已存在则不创建</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>mkdir()</code></td>
<td>创建目录，已存在则不创建</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>mkdirs()</code></td>
<td>递归创建目录</td>
</tr>
</tbody></table>
<h3 id="2-删除"><a href="#2-删除" class="headerlink" title="2 删除"></a>2 删除</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>delete()</code></td>
<td>删除文件或空目录（不走回收站）</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>renameTo(File dest)</code></td>
<td>路径相同则重命名，路径不同则剪切</td>
</tr>
</tbody></table>
<h3 id="3-判断"><a href="#3-判断" class="headerlink" title="3 判断"></a>3 判断</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>exists()</code></td>
<td>是否存在</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isDirectory()</code></td>
<td>是否是目录</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isFile()</code></td>
<td>是否是文件</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>canRead()</code></td>
<td>是否可读</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>canWrite()</code></td>
<td>是否可写</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isHidden()</code></td>
<td>是否是隐藏</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>isAbsolute()</code></td>
<td>是否是绝对路径</td>
</tr>
</tbody></table>
<h3 id="4-获取"><a href="#4-获取" class="headerlink" title="4 获取"></a>4 获取</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>getName()</code></td>
<td>获取文件名</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getPath()</code></td>
<td>获取构造 File 对象时指定的路径</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getAbsolutePath()</code></td>
<td>获取绝对路径</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getCanonicalPath()</code></td>
<td>获取规范路径（自动解析 <code>. ..</code>）</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>length()</code></td>
<td>获取文件大小</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>lastModified()</code></td>
<td>获取文件最后修改时间</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>getParent()</code></td>
<td>获取父目录路径的字符串</td>
</tr>
<tr>
<td><code>File</code></td>
<td><code>getParentFile()</code></td>
<td>获取父目录路径的 File 对象</td>
</tr>
</tbody></table>
<h3 id="5-遍历目录"><a href="#5-遍历目录" class="headerlink" title="5 遍历目录"></a>5 遍历目录</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>static File[]</code></td>
<td><code>listRoots()</code></td>
<td>获取系统可用盘符</td>
</tr>
<tr>
<td><code>String[]</code></td>
<td><code>list()</code></td>
<td>获取目录下所有文件和目录的字符串名称的数组</td>
</tr>
<tr>
<td><code>String[]</code></td>
<td><code>list(FilenameFilter filter)</code></td>
<td>文件名过滤器</td>
</tr>
<tr>
<td><code>File[]</code></td>
<td><code>listFiles()</code></td>
<td>获取目录下所有文件和目录的 File 对象的数组</td>
</tr>
<tr>
<td><code>File[]</code></td>
<td><code>listFiles(FileFilter filter)</code></td>
<td>文件过滤器</td>
</tr>
<tr>
<td><code>File[]</code></td>
<td><code>listFiles(FilenameFilter filter)</code></td>
<td>文件名过滤器</td>
</tr>
</tbody></table>
<h1 id="二-IO-流的异常处理"><a href="#二-IO-流的异常处理" class="headerlink" title="二 IO 流的异常处理"></a>二 IO 流的异常处理</h1><h2 id="2-1-JDK-7"><a href="#2-1-JDK-7" class="headerlink" title="2.1 JDK 7"></a>2.1 JDK 7</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	in = <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>);</span><br><span class="line">	业务代码;</span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">	异常处理;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(in!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			in.close();</span><br><span class="line">		&#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-JDK-8"><a href="#2-2-JDK-8" class="headerlink" title="2.2 JDK 8"></a>2.2 JDK 8</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (</span><br><span class="line">	需要关闭的资源;</span><br><span class="line">) &#123;</span><br><span class="line">	业务代码;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">	异常处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>实现了 <code>java.lang.AutoCloseble</code> 的资源可以使用此语法自动关闭（无论是否发生异常）</li>
<li>IO 流体系实现了此接口</li>
<li>JDK9 以后要关闭的资源可以在 <code>try</code> 外边初始化</li>
</ol>
<h1 id="三-基础流"><a href="#三-基础流" class="headerlink" title="三 基础流"></a>三 基础流</h1><h2 id="3-1-字节输入流"><a href="#3-1-字节输入流" class="headerlink" title="3.1 字节输入流"></a>3.1 字节输入流</h2><h3 id="1-体系"><a href="#1-体系" class="headerlink" title="1 体系"></a>1 体系</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81.png" alt=""></p>
<h3 id="2-InputStream"><a href="#2-InputStream" class="headerlink" title="2 InputStream"></a>2 <code>InputStream</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>abstract int</code></td>
<td><code>read()</code></td>
<td>读取单个字节，返回字节的 <code>int</code> 值，流末尾返回 <code>-1</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>read​(byte[] b)</code></td>
<td>读取字节并存储到数组中，返回读取的字节个数，流末尾返回 <code>-1</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>read​(byte[] b, int off, int len)</code></td>
<td>读取字节并存储到数组指定位置，返回读取的字节个数，流末尾返回 <code>-1</code></td>
</tr>
<tr>
<td><code>byte[]</code></td>
<td><code>readAllBytes()</code></td>
<td>读取流中所有字节</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>transferTo(OutputStream out)</code></td>
<td>将当前输入流中所有数据传递给输出流，并返回传递字节数</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>close()</code></td>
<td>关闭流</td>
</tr>
</tbody></table>
<ul>
<li>字节流读取中文<ol>
<li>使用 <code>read()</code> 读取一个字节肯定乱码</li>
<li>使用 <code>read(byte[] b)</code> 缓存数组读取有可能乱码，因为数组长度与数据的字节个数未必恰好吻合，有可能会出现一个字符多个字节但只读取到部分的情况</li>
</ol>
</li>
</ul>
<h2 id="3-2-字节输出流"><a href="#3-2-字节输出流" class="headerlink" title="3.2 字节输出流"></a>3.2 字节输出流</h2><h3 id="1-体系-1"><a href="#1-体系-1" class="headerlink" title="1 体系"></a>1 体系</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81.png" alt=""></p>
<h3 id="2-OutputStream"><a href="#2-OutputStream" class="headerlink" title="2 OutputStream"></a>2 <code>OutputStream</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>abstract void</code></td>
<td><code>write​(int b)</code></td>
<td>写单个字节</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>write(byte[] b)</code></td>
<td>写字节数组</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>write(byte[] b, int off, int len)</code></td>
<td>写字节数组的指定部分</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>flush()</code></td>
<td>刷新，即将缓冲区数据写到目的地，刷新后还可以继续写</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>close()</code></td>
<td>关闭前会自动刷新</td>
</tr>
</tbody></table>
<h2 id="3-3-字符输入流"><a href="#3-3-字符输入流" class="headerlink" title="3.3 字符输入流"></a>3.3 字符输入流</h2><h3 id="1-体系-2"><a href="#1-体系-2" class="headerlink" title="1 体系"></a>1 体系</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81.png" alt=""></p>
<h3 id="2-Reader"><a href="#2-Reader" class="headerlink" title="2 Reader"></a>2 <code>Reader</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>read()</code></td>
<td>读取单个字符，返回 Unicode 码元（<code>0~65535</code>），流末尾返回 <code>-1</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>read(char[] cbuf)</code></td>
<td>读取字符并存储到数组中，返回读取的字符个数，流末尾返回 <code>-1</code></td>
</tr>
<tr>
<td><code>abstract int</code></td>
<td><code>read​(char[] cbuf, int off, int len)</code></td>
<td>读取字符并存储到数组指定位置，返回读取的字符个数，流末尾返回 <code>-1</code></td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code>close()</code></td>
<td>关闭流</td>
</tr>
</tbody></table>
<ol>
<li>字符流一次读取一个字符，字符流怎么知道几个字节是一个字符呢？<ul>
<li>跟字符集有关，如GBK中中文都是1开头的</li>
</ul>
</li>
<li>字符流编码转换过程 <code>read()</code><ul>
<li>按照指定字符集读取 → 查询 <code>unicode</code> 中对应的码点（因为 java 为 <code>unicode</code>）</li>
<li>比如文件内容为一个字 “北”，假如使用的码表为GBK，字符流读取结果为 <code>十进制：21271</code>，转为十六进制为 <code>\u5317</code>，先读取文件根据GBK转成了 “北”，然后查“北”在 <code>Unicode</code> 中的码点</li>
</ul>
</li>
</ol>
<h2 id="3-4-字符输出流"><a href="#3-4-字符输出流" class="headerlink" title="3.4 字符输出流"></a>3.4 字符输出流</h2><h3 id="1-体系-3"><a href="#1-体系-3" class="headerlink" title="1 体系"></a>1 体系</h3><p><img src="https://github.com/anyeansan/pics/raw/master/CS/Java/%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81.png" alt=""></p>
<h3 id="2-Writer"><a href="#2-Writer" class="headerlink" title="2 Writer"></a>2 <code>Writer</code></h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>write(int c)</code></td>
<td>写单个字符</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>write(String str)</code></td>
<td>写字符串</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>write(String str, int off, int len)</code></td>
<td>写字符串的指定部分</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>write(char[] cbuf)</code></td>
<td>写字符数组</td>
</tr>
<tr>
<td><code>abstract  void</code></td>
<td><code>write(char[] cbuf, int off, int len)</code></td>
<td>写字符数组的指定部分</td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code>flush()</code></td>
<td>刷新</td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code>close()</code></td>
<td>关闭前会自动刷新</td>
</tr>
</tbody></table>
<h1 id="四-文件流"><a href="#四-文件流" class="headerlink" title="四 文件流"></a>四 文件流</h1><h2 id="4-1-FileInputStream"><a href="#4-1-FileInputStream" class="headerlink" title="4.1 FileInputStream"></a>4.1 <code>FileInputStream</code></h2><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>FileInputStream(File file)</code></td>
<td>根据 File 对象创建，文件必须存在</td>
</tr>
<tr>
<td><code>FileInputStream(String name)</code></td>
<td>根据文件路径创建，文件必须存在</td>
</tr>
</tbody></table>
<h2 id="4-2-FileOutputStream"><a href="#4-2-FileOutputStream" class="headerlink" title="4.2 FileOutputStream"></a>4.2 <code>FileOutputStream</code></h2><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>FileOutputStream(File file [, boolean append])</code></td>
<td>文件不存在会创建，文件存在会清空</td>
</tr>
<tr>
<td><code>FileOutputStream(String name [, boolean append])</code></td>
<td>文件不存在会创建，文件存在会清空</td>
</tr>
</tbody></table>
<h1 id="五-缓冲流"><a href="#五-缓冲流" class="headerlink" title="五 缓冲流"></a>五 缓冲流</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol>
<li>缓存流和定义数组哪个快？<ul>
<li>定义数组快，因为读写操作的都是同一个数组，而缓存流分输入和输出，操作的是两个数组</li>
</ul>
</li>
<li>关闭流时，先关外层，再关内层，而关外层流时内层流会自动关闭</li>
</ol>
<h2 id="5-2-字节缓冲流"><a href="#5-2-字节缓冲流" class="headerlink" title="5.2 字节缓冲流"></a>5.2 字节缓冲流</h2><h3 id="1-BufferedInputStream"><a href="#1-BufferedInputStream" class="headerlink" title="1 BufferedInputStream"></a>1 <code>BufferedInputStream</code></h3><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>BufferedInputStream​(InputStream in [, int size])</code></td>
<td>默认缓存区大小为 <code>8192</code> 字节</td>
</tr>
</tbody></table>
<h3 id="2-BufferedOutputStream"><a href="#2-BufferedOutputStream" class="headerlink" title="2 BufferedOutputStream"></a>2 <code>BufferedOutputStream</code></h3><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>BufferedOutputStream(OutputStream out, int size)</code></td>
<td>默认缓存区大小为 <code>8192</code> 字节</td>
</tr>
</tbody></table>
<h2 id="5-3-字符缓冲流"><a href="#5-3-字符缓冲流" class="headerlink" title="5.3 字符缓冲流"></a>5.3 字符缓冲流</h2><h3 id="1-BufferedReader"><a href="#1-BufferedReader" class="headerlink" title="1 BufferedReader"></a>1 <code>BufferedReader</code></h3><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>BufferedReader​(Reader in [, int sz])</code></td>
<td>默认缓存区大小 <code>8192</code> 字符</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>readLine()</code></td>
<td>读取一行并返回（不包括换行符），流末尾返回 <code>null</code></td>
</tr>
</tbody></table>
<h3 id="2-BufferedWriter"><a href="#2-BufferedWriter" class="headerlink" title="2 BufferedWriter"></a>2 <code>BufferedWriter</code></h3><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>BufferedWriter​(Writer out [, int sz])</code></td>
<td>默认缓存区大小 <code>8192</code> 字符</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>newLine()</code></td>
<td>写出换行符（可跨平台）</td>
</tr>
</tbody></table>
<h1 id="六-转换流"><a href="#六-转换流" class="headerlink" title="六 转换流"></a>六 转换流</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><ol>
<li><p>转换流属于字符流，提供了字节流和字符流之间的转换</p>
<ul>
<li><code>InputStreamReader</code>：<code>InputStream</code> → <code>Reader</code></li>
<li><code>OutputStreamWriter</code>：<code>Writer</code> → <code>OutputStream</code></li>
</ul>
</li>
<li><p>字符流原理就是转换流使用平台默认字符集将字节流转换成了字符流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"test.txt"</span>);</span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"test.txt"</span>),<span class="string">"utf-8"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>字符流 = 转换流(字节流 + 默认字符集)</p>
</li>
<li><p>如果默认字符集是 <code>utf-8</code> ，则上述两句是等价的</p>
</li>
</ul>
</li>
</ol>
<h2 id="6-2-InputStreamReader"><a href="#6-2-InputStreamReader" class="headerlink" title="6.2 InputStreamReader"></a>6.2 <code>InputStreamReader</code></h2><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>InputStreamReader​(InputStream in [, String charsetName)]</code></td>
<td>字节流到字符流的桥梁，使用指定字符集解码</td>
</tr>
</tbody></table>
<ol>
<li>使用字节流读取文本数据时，先读取字节数据，然后使用字符集解码</li>
<li><code>InputStreamReader</code>：读取字节数据并使用字符集解码</li>
</ol>
<h2 id="6-3-OutputStreamWriter"><a href="#6-3-OutputStreamWriter" class="headerlink" title="6.3 OutputStreamWriter"></a>6.3 <code>OutputStreamWriter</code></h2><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>OutputStreamWriter​(OutputStream out [, String charsetName])</code></td>
<td>字符流到字节流的桥梁，使用指定字符集编码</td>
</tr>
</tbody></table>
<ol>
<li>使用字节流写出文本数据时，先使用字符集编码，然后写出字节数据</li>
<li><code>OutputStreamWriter</code>：使用字符集编码并写出字节数据</li>
</ol>
<h2 id="6-4-两种方法实现键盘录入"><a href="#6-4-两种方法实现键盘录入" class="headerlink" title="6.4 两种方法实现键盘录入"></a>6.4 两种方法实现键盘录入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in))</span><br><span class="line">BUfferedWriter bw=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out)) </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure>

<h1 id="七-打印流"><a href="#七-打印流" class="headerlink" title="七 打印流"></a>七 打印流</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ol>
<li>可以对多种数据类型进行打印，并<strong>保持数据的表示形式</strong><ol>
<li><code>write(int)</code> ：只会写出 1 个字节</li>
<li><code>print(int)</code> ：可以写出 4 个字节</li>
</ol>
</li>
<li>不抛出 <code>IOException</code></li>
<li>打印原理<ol>
<li>基本数据类型先变成字符串再打印</li>
<li>引用数据类型非 <code>null</code> 就调用对象的 <code>toString()</code>，<code>null</code> 就打印 <code>null</code></li>
</ol>
</li>
<li><code>PrintWriter &amp; printStream</code><ol>
<li><code>PrintStream</code> 能做的 <code>PrintWriter</code> 也都能实现且功能更强大，但 <code>PrintStream</code> 出现较早，<code>System.out</code> 使用的是 <code>PrintStream</code> 来实现的，所以为了兼容并没有废弃 <code>PrintStream</code></li>
<li>二者都提供了一系列重载的 <code>print println</code> 方法</li>
<li><code>PringtStream</code> 打印的所有字符都使用平台默认的字符集来编码为字节数据，打印字符时，建议使用 <code>PrintWriter</code></li>
<li><code>PrintWriter &amp; printStream</code> 都可以设置自动刷新<ul>
<li><code>printStream</code>：写入字节数组、任何重载版本的 <code>println()</code> 被调用、一个换行符（<code>char</code>）被写入、一个换行符的字节存储（<code>\n</code>）被写入</li>
<li><code>PrintWriter</code>： 自动刷新只对 <code>println() printf() format()</code> 这些方法有效</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="7-2-PrintStream"><a href="#7-2-PrintStream" class="headerlink" title="7.2 PrintStream"></a>7.2 <code>PrintStream</code></h2><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>PrintStream​(File file [, String charsetName])</code></td>
<td>接收 File 对象</td>
</tr>
<tr>
<td><code>PrintStream​(String fileName [, String charsetName])</code></td>
<td>接收字符串路径</td>
</tr>
<tr>
<td><code>PrintStream​(OutputStream out [, boolean autoFlush [, String encoding]])</code></td>
<td>接收字节输出流</td>
</tr>
</tbody></table>
<h2 id="7-3-PrintWriter"><a href="#7-3-PrintWriter" class="headerlink" title="7.3 PrintWriter"></a>7.3 <code>PrintWriter</code></h2><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>PrintWriter​(File file [, String charsetName])</code></td>
<td>接收 File 对象</td>
</tr>
<tr>
<td><code>PrintWriter​(String fileName [, String charsetName])</code></td>
<td>接收字符串路径</td>
</tr>
<tr>
<td><code>PrintWriter​(OutputStream out [, boolean autoFlush [, Charset charset]])</code></td>
<td>接收字节输出流</td>
</tr>
<tr>
<td><code>PrintWriter​(Writer out [, boolean autoFlush])</code></td>
<td>接收字符输出流</td>
</tr>
</tbody></table>
<h2 id="7-4-标准输入输出流"><a href="#7-4-标准输入输出流" class="headerlink" title="7.4 标准输入输出流"></a>7.4 标准输入输出流</h2><table>
<thead>
<tr>
<th>流</th>
<th>类型</th>
<th>说明</th>
<th>设备</th>
</tr>
</thead>
<tbody><tr>
<td><code>System.in</code></td>
<td><code>InputStream</code></td>
<td>标准输入</td>
<td>键盘</td>
</tr>
<tr>
<td><code>System.out</code></td>
<td><code>PrintStream</code></td>
<td>标准输出</td>
<td>显示器（控制台）</td>
</tr>
<tr>
<td><code>System.err</code></td>
<td><code>PrintStream</code></td>
<td>标准错误输出</td>
<td>显示器（控制台）</td>
</tr>
</tbody></table>
<h1 id="八-序列化流（对象流）"><a href="#八-序列化流（对象流）" class="headerlink" title="八 序列化流（对象流）"></a>八 序列化流（对象流）</h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><ol>
<li>序列化 &amp; 反序列化<ul>
<li>序列化：写出一个对象</li>
<li>反序列化：读取一个对象</li>
</ul>
</li>
<li>对象序列化机制：好处在于将对象转化为字节数据，使其在保存和传输时可被还原<ul>
<li>允许把内存中的 Java 对象转换成平台无关的二进制流，从而把这种二进制流持久的保存在磁盘上或通过网络进行传输</li>
<li>当其它程序获取这种二进制流，就可以恢复成原来的 Java 对象</li>
</ul>
</li>
<li>对象序列化的条件：<ol>
<li>对象必须实现序列化接口<ul>
<li><code>Serializable</code> ：序列化标记接口，对象序列化内容和顺序都是默认的</li>
<li><code>Externalizable</code> ：<code>Serializable</code> 的子接口，可定制序列号内容和顺序</li>
</ul>
</li>
<li>对象的所有属性也必须可序列化<ul>
<li>引用类型的属性也必须实现序列化接口</li>
<li>基本类型属性默认可序列化</li>
</ul>
</li>
<li>对象不会序列化的属性<ul>
<li><code>transient</code> 关键字修饰的属性</li>
<li><code>static</code> 关键字修饰的属性</li>
</ul>
</li>
</ol>
</li>
<li>序列化ID ：<code>serialVersionUID</code><ul>
<li>用于判断类和对象是否是同一个版本</li>
<li>建议实现序列化接口时就指定，否则每次重新编译类，序列化ID都会变化</li>
</ul>
</li>
</ol>
<h2 id="8-2-ObjectInputStream"><a href="#8-2-ObjectInputStream" class="headerlink" title="8.2 ObjectInputStream"></a>8.2 <code>ObjectInputStream</code></h2><h3 id="1-构造"><a href="#1-构造" class="headerlink" title="1 构造"></a>1 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ObjectInputStream​(InputStream in)</code></td>
<td>装饰字节输入流</td>
</tr>
</tbody></table>
<h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2 方法"></a>2 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object</code></td>
<td><code>readObject()</code></td>
<td>读取对象</td>
</tr>
</tbody></table>
<h2 id="8-3-ObjectOutputStream"><a href="#8-3-ObjectOutputStream" class="headerlink" title="8.3 ObjectOutputStream"></a>8.3 <code>ObjectOutputStream</code></h2><h3 id="1-构造-1"><a href="#1-构造-1" class="headerlink" title="1 构造"></a>1 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ObjectOutputStream(OutputStream out)</code></td>
<td>装饰字节输出流</td>
</tr>
</tbody></table>
<h3 id="2-方法-1"><a href="#2-方法-1" class="headerlink" title="2 方法"></a>2 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>writeObject(Object obj)</code></td>
<td>写出对象</td>
</tr>
</tbody></table>
<h1 id="九-数据流"><a href="#九-数据流" class="headerlink" title="九 数据流"></a>九 数据流</h1><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><ol>
<li>数据流主要用来操作基本类型和 <code>String</code> 类型的数据，这些数据如果使用其它流读写，可能会出问题</li>
<li>以二进制形式读写数组，字符，字符串，布尔…</li>
</ol>
<h2 id="9-2-DataInputStream"><a href="#9-2-DataInputStream" class="headerlink" title="9.2 DataInputStream"></a>9.2 <code>DataInputStream</code></h2><h3 id="1-构造-2"><a href="#1-构造-2" class="headerlink" title="1 构造"></a>1 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>DataInputStream​(InputStream in)</code></td>
<td>装饰字节输入流</td>
</tr>
</tbody></table>
<h3 id="2-方法-2"><a href="#2-方法-2" class="headerlink" title="2 方法"></a>2 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td><code>readUTF()</code></td>
<td>读字符串</td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>readT()</code></td>
<td>读指定类型数据，<code>readInt() readDouble() ...</code></td>
</tr>
</tbody></table>
<h2 id="9-3-DataOutputStream"><a href="#9-3-DataOutputStream" class="headerlink" title="9.3 DataOutputStream"></a>9.3 <code>DataOutputStream</code></h2><h3 id="1-构造-3"><a href="#1-构造-3" class="headerlink" title="1 构造"></a>1 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>DataOutputStream​(OutputStream out)</code></td>
<td>装饰字节输出流</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>writeUTF​(String str)</code></td>
<td>写字符串</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>writeT(T t)</code></td>
<td>写指定类型数据，<code>writeInt(int i) writeDouble(double d) ...</code></td>
</tr>
</tbody></table>
<h1 id="十-内存流"><a href="#十-内存流" class="headerlink" title="十 内存流"></a>十 内存流</h1><h2 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h2><ol>
<li>操作字节数组</li>
<li>流关闭无效，不抛 <code>IOException</code></li>
<li>向内存中读写数组</li>
<li>字节流读取中文时，可能会乱码，可以使用内存输出流先写到内存中，然后一次性获取所有数据</li>
</ol>
<h2 id="10-2-ByteArrayInputStream"><a href="#10-2-ByteArrayInputStream" class="headerlink" title="10.2 ByteArrayInputStream"></a>10.2 <code>ByteArrayInputStream</code></h2><h3 id="1-构造-4"><a href="#1-构造-4" class="headerlink" title="1 构造"></a>1 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ByteArrayInputStream(byte[] buf [, int offset, int length])</code></td>
<td>把字节数组作为缓冲数组</td>
</tr>
</tbody></table>
<h3 id="2-方法-3"><a href="#2-方法-3" class="headerlink" title="2 方法"></a>2 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>read()</code></td>
<td>读取一个字节</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>read(byte[] b, int off, int len)</code></td>
<td>读取字节并存储在数组中</td>
</tr>
</tbody></table>
<h2 id="10-3-ByteArrayOutputStream"><a href="#10-3-ByteArrayOutputStream" class="headerlink" title="10.3 ByteArrayOutputStream"></a>10.3 <code>ByteArrayOutputStream</code></h2><h3 id="1-构造-5"><a href="#1-构造-5" class="headerlink" title="1 构造"></a>1 构造</h3><table>
<thead>
<tr>
<th>构造</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ByteArrayOutputStream([int size])</code></td>
<td>可以指定缓冲区大小</td>
</tr>
</tbody></table>
<h3 id="2-方法-4"><a href="#2-方法-4" class="headerlink" title="2 方法"></a>2 方法</h3><table>
<thead>
<tr>
<th>修饰</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>write(int b)</code></td>
<td>写出一个字节</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>write(byte[] b, int off, int len)</code></td>
<td>写出数组指定数据</td>
</tr>
<tr>
<td><code>byte[]</code></td>
<td><code>toByteArray()</code></td>
<td>将缓冲区的数据全部取出，获取一个字节数组</td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>toString()</code></td>
<td>将缓冲区的数据用平台默认编码转为字符串</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/anyeansan.github.io/page/2/">2</a><a class="extend next" rel="next" href="/anyeansan.github.io/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          秘笈
        </li>
        <li class="sidebar-nav-overview">
          安₃
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="安₃"
      src="/anyeansan.github.io/images/an3.png">
  <p class="site-author-name" itemprop="name">安₃</p>
  <div class="site-description" itemprop="description">一蓑烟雨任平生</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/anyeansan.github.io/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">琅嬛福地</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/anyeansan.github.io/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">门派</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/anyeansan.github.io/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-star-half-full"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">安₃</span>
</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/anyeansan.github.io/lib/anime.min.js"></script>
  <script src="/anyeansan.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/anyeansan.github.io/lib/velocity/velocity.ui.min.js"></script>
<script src="/anyeansan.github.io/js/utils.js"></script><script src="/anyeansan.github.io/js/motion.js"></script>
<script src="/anyeansan.github.io/js/schemes/pisces.js"></script>
<script src="/anyeansan.github.io/js/next-boot.js"></script>



  




  <script src="/anyeansan.github.io/js/local-search.js"></script>













  

  

</body>
</html>
